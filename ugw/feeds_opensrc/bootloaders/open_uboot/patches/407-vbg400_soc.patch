# HG changeset patch
# Parent bf7305bd257bafae498a39b0bb5860bbb32f3b21

diff --git a/arch/mips/cpu/vbg400/Makefile b/arch/mips/cpu/vbg400/Makefile
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/vbg400/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2003-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(CPU).a
+
+START	= start.o
+COBJS	= cpu.o interrupts.o cache.o time.o\
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(START) $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/mips/cpu/vbg400/cache.c b/arch/mips/cpu/vbg400/cache.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/vbg400/cache.c
@@ -0,0 +1,211 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <asm/addrspace.h>
+#include <asm/yamon.h>
+#include <asm/types.h>
+#include <asm/mipsregs.h>
+#include <asm/cacheops.h>
+
+typedef unsigned long ulong;
+
+#define cache_op(op,addr)						\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	noreorder				\n"	\
+	"	.set	mips3\n\t				\n"	\
+	"	cache	%0, %1					\n"	\
+	"	.set	pop					\n"	\
+	:								\
+	: "i" (op), "R" (*(unsigned char *)(addr)))
+
+u32 get_cpu_id()
+{  
+   u32 config = read_c0_prid();
+   return ((config>>8) & 0xff);
+
+}
+
+u32 icache_lines()
+{
+   /* I-cache lines
+    * Calculated as associativity * sets per way
+	*/
+
+   u32 config,associativity,sets;
+   config = read_c0_config1();
+   associativity = 1+ ((config & M_Config1IA) >> S_Config1IA);
+   sets = (1<<((config & M_Config1IS) >> S_Config1IS)) * 64;
+   return (associativity * sets);
+}
+
+u32 icache_line_size()
+{
+    u32 config, line_size;
+    config=read_c0_config1();
+    line_size= 0x02 <<((config & M_Config1IL) >> (S_Config1IL));
+    return line_size;
+}
+									  
+
+u32 dcache_lines()
+{
+   /* I-cache lines
+    * Calculated as associativity * sets per way
+	*/
+
+   u32 config,associativity,sets;
+   config = read_c0_config1();
+   associativity = 1+ ((config & M_Config1DA) >> S_Config1DA);
+   sets = (1<<((config & M_Config1DS) >> S_Config1DS)) * 64;
+   return (associativity * sets);
+}
+
+u32 dcache_line_size()
+{
+    u32 config, line_size;
+    config=read_c0_config1();
+    line_size= 0x02 <<((config & M_Config1DL) >> (S_Config1DL));
+    return line_size;
+}
+										  
+
+void init_icache()
+{
+    u32 lsize = icache_line_size();
+    u32 start_addr  = KSEG0;
+	u32 aend  = KSEG0  + (icache_lines()*lsize);
+	u32 cpu_id = get_cpu_id();    
+    u32 addr;
+ 
+	write_c0_taglo(0); 
+	//write_c0_taghi(0); /*not applicable to 4kec, 24kec and 34kc, will add if it is needed in the future*/
+    for(addr=start_addr;addr<aend; addr+=lsize){
+        cache_op(Index_Store_Tag_I, addr);
+	}
+
+	
+}
+
+
+void lock_icache()
+{
+    u32 lsize = icache_line_size();
+    u32 start_addr  = 0x9fc00000;
+    u32 aend  = 0x9fc00000 + (icache_lines()*lsize);
+    u32 cpu_id = get_cpu_id();
+    u32 addr;
+
+    for(addr=start_addr;addr<=aend; addr+=lsize){
+	       cache_op(ICACHE_ADDR_FETCH_LOCK, addr);
+      }
+
+}
+
+
+void init_dcache()
+{
+     u32 lsize = dcache_line_size();
+	 u32 start_addr  = 0x9fc00000;
+	 u32 aend  = 0x9fc00000 + (dcache_lines()*lsize);
+	 u32 cpu_id = get_cpu_id();
+	 u32 addr;
+
+     write_c0_dtaglo(0);
+    //write_c0_taghi(0); /*not applicable to 4kec, 24kec and 34kc, will add if it is needed in the future*/
+    for(addr=start_addr;addr<aend; addr+=lsize){
+        cache_op(Index_Store_Tag_D, addr);
+     }
+						 
+}
+
+
+void lock_dcache()
+{
+    u32 lsize = dcache_line_size();
+    u32 start_addr  = 0x9fc00000;
+    u32 aend  = 0x9fc00000 + (dcache_lines()*lsize);
+    u32 cpu_id = get_cpu_id();
+    u32 addr;
+
+    for(addr=start_addr;addr<=aend; addr+=lsize){
+           cache_op(DCACHE_ADDR_FETCH_LOCK, addr);
+		   }
+}
+								 
+
+void flush_cache(ulong start_addr, ulong size)
+{
+	unsigned long lsize = dcache_line_size();
+	unsigned long addr = start_addr & ~(lsize - 1);
+	unsigned long aend = (start_addr + size - 1) & ~(lsize - 1);
+
+	while (1) {
+		cache_op(Hit_Writeback_Inv_D, addr);
+		cache_op(Hit_Invalidate_I, addr);
+		if (addr == aend)
+			break;
+		addr += lsize;
+	}
+}
+
+void flush_dcache_range(ulong start_addr, ulong stop)
+{
+	unsigned long lsize = dcache_line_size();
+	unsigned long addr = start_addr & ~(lsize - 1);
+	unsigned long aend = (stop - 1) & ~(lsize - 1);
+
+	while (1) {
+		cache_op(Hit_Writeback_Inv_D, addr);
+		if (addr == aend)
+			break;
+		addr += lsize;
+	}
+}
+
+void invalidate_dcache_range(ulong start_addr, ulong stop)
+{
+	unsigned long lsize = dcache_line_size();
+	unsigned long addr = start_addr & ~(lsize - 1);
+	unsigned long aend = (stop - 1) & ~(lsize - 1);
+
+	while (1) {
+		cache_op(Hit_Invalidate_D, addr);
+		if (addr == aend)
+			break;
+		addr += lsize;
+	}
+}
+
+
+
+
+void write_one_tlb(int index, u32 pagemask, u32 hi, u32 low0, u32 low1)
+{
+	write_c0_entrylo0(low0);
+	write_c0_pagemask(pagemask);
+	write_c0_entrylo1(low1);
+	write_c0_entryhi(hi);
+	write_c0_index(index);
+	tlb_write_indexed();
+}
+
diff --git a/arch/mips/cpu/vbg400/config.mk b/arch/mips/cpu/vbg400/config.mk
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/vbg400/config.mk
@@ -0,0 +1,39 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+v=$(shell $(AS) --version |grep "GNU assembler" |cut -d. -f2)
+MIPSFLAGS:=$(shell \
+if [ "$v" -lt "14" ]; then \
+	echo "-mcpu=4kc"; \
+else \
+	echo "-march=mips32r2 -mtune=mips32r2"; \
+fi)
+
+#ifneq (,$(findstring r2el,$(CROSS_COMPILE)))
+#ENDIANNESS = -EL -mel
+#else
+#ENDIANNESS = -EB
+#endif
+
+#MIPSFLAGS += $(ENDIANNESS) -mabicalls -v
+
+#PLATFORM_CPPFLAGS += $(MIPSFLAGS)
diff --git a/arch/mips/cpu/vbg400/cpu.c b/arch/mips/cpu/vbg400/cpu.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/vbg400/cpu.c
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+
+int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	printf("*** reset system ***\n");
+	ulong regdata;
+	ulong i=0;
+	/* Configure FLASH to be in HW mode - needed? */
+	regdata = (*(volatile unsigned long *)(VBG400_SPI_MODE_ADDR)) ;
+	regdata &= (~VBG400_SPI_MODE_SW_BIT);
+	*(volatile unsigned long *)(VBG400_SPI_MODE_ADDR) = regdata;
+	/* start from flash */
+    printf("please wait while reboot\n");
+    regdata = (*(volatile unsigned long *)(VBG400_RESET_ADDR)) ;
+	/*clear reset bit*/
+	regdata &= VBG400_REBOOT_BIT_MASK_NOT;
+	*(volatile unsigned long *)(VBG400_RESET_ADDR) = regdata;
+
+    while (1) ;
+	fprintf(stderr, "*** reset failed ***\n");
+	return 0;
+}
+
+void flush_cache(ulong start_addr, ulong size)
+{
+}
+
+/* void write_one_tlb(int index, u32 pagemask, u32 hi, u32 low0, u32 low1)
+{
+	write_32bit_cp0_register(CP0_ENTRYLO0, low0);
+	write_32bit_cp0_register(CP0_PAGEMASK, pagemask);
+	write_32bit_cp0_register(CP0_ENTRYLO1, low1);
+	write_32bit_cp0_register(CP0_ENTRYHI, hi);
+	write_32bit_cp0_register(CP0_INDEX, index);
+	tlb_write_indexed();
+}
+*/
diff --git a/arch/mips/cpu/vbg400/denali_reg_defines.s b/arch/mips/cpu/vbg400/denali_reg_defines.s
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/vbg400/denali_reg_defines.s
@@ -0,0 +1,1035 @@
+#ifdef mt47h64m8_25e
+#ifdef ddr_clk_160
+
+/******************************************************************
+ * COPYRIGHT (c) 2000 Denali Software, Inc.  All rights reserved. *
+ * -------------------------------------------------------------- *
+ * This code is proprietary and confidential information of       *
+ * Denali Software. It may not be reproduced, used or transmitted *
+ * in any form whatsoever without the express and written         *
+ * permission of Denali Software.                                 *
+ ******************************************************************
+ ******************************************************************
+ *                                                                 
+ *   Module:         regconfig.h
+ *   Documentation:  Register programming header file
+ *
+ ******************************************************************
+ ******************************************************************/
+
+/*****************************************************************
+ * WARNING:  This file was automatically generated.  Manual
+ * editing may result in undetermined behavior, and may be in
+ * violation of the Denali Support Agreement.
+ *****************************************************************/
+
+
+
+## ********************************************************************
+## Option: IP Mode                      = CTL
+## Option: Burst Length                  = 4
+## Option: CAS Latency                   = 4
+## Option: Simulation MHz                = 170
+## Option: Auto Precharge Mode     (0/1) = 0
+## Option: DLL Bypass Mode         (0/1) = 0
+## Option: Half-Memory Support     (0/1) = 1
+## Option: Registered Dimm Support (0/1) = 0
+## Option: SYNCRONIOUS 0/1 = 0
+## ********************************************************************
+## Memory: mt47h64m8_25e.xml
+## ********************************************************************
+
+
+.equ               DENALI_CTL_00_DATA ,0b00000000000000000000010000000000 ##0000000000000000 version(RD) 0000_0100 dram_class(RW) 0000000_0 start(RW) 
+.equ               DENALI_CTL_01_DATA ,0b00000000000000000000000000000000 ##000000000000000_0 max_cs_reg(RD) 0000_0000 max_col_reg(RD) 0000_0000 max_row_reg(RD) 
+.equ               DENALI_CTL_02_DATA ,0b00000010000000000000000000100010 ##0000_0010 initaref(RW) 000000000000000000100010 tinit(RW) 
+.equ               DENALI_CTL_03_DATA ,0b00000010000000100000001100001000 ##000_00010 tccd(RW) 00000_010 tbst_int_interval(RW) 0000_0011 wrlat(RW) 0000_1000 caslat_lin(RW) 
+.equ               DENALI_CTL_04_DATA ,0b00000010000010000000101000000010 ##0000_0010 twtr(RW) 00001000 tras_min(RW) 00001010 trc(RW) 00000010 trrd(RW) 
+.equ               DENALI_CTL_05_DATA ,0b00000011000000100000001000000011 ##00000011 tmod(RW) 000_00010 tmrd(RW) 00000_010 trtp(RW) 0000_0011 trp(RW) 
+.equ               DENALI_CTL_06_DATA ,0b00000011000000110010111001101101 ##000_00011 tckesr(RW) 00000_011 tcke(RW) 0010111001101101 tras_max(RW) 
+.equ               DENALI_CTL_07_DATA ,0b00000001000000010000000000000000 ##0000000_1 tras_lockout(RW) 0000000_1 concurrentap(RW) 0000000_0 ap(RW) 0000000_0 writeinterp(RW) 
+.equ               DENALI_CTL_08_DATA ,0b00000000000001100000001100000011 ##00000000000_00110 tdal(RW) 000_00011 twr_int(RW) 00000011 trcd_int(RW) 
+.equ               DENALI_CTL_09_DATA ,0b00000010000000000000000011001000 ##00000_010 bstlen(RW_D) 0000000_0 no_cmd_init(RW) 0000000011001000 tdll(RW) 
+.equ               DENALI_CTL_10_DATA ,0b00000011000000000100010000000000 ##0000_0011 trp_ab(RW) 0000000001000100 tcpd(RW) 00_000000 tfaw(RW) 
+.equ               DENALI_CTL_11_DATA ,0b00000001000000000000000000000000 ##0000000_1 tref_enable(RW) 0000000_0 auto_refresh_mode(RW) 0000000_0 arefresh(WR) 0000000_0 reg_dimm_enable(RW) 
+.equ               DENALI_CTL_12_DATA ,0b00000100110110000000000000010010 ##00_00010011011000 tref(RW) 000000_0000010010 trfc(RW) 
+.equ               DENALI_CTL_13_DATA ,0b00000000000000100000000000000000 ##0000000000000010 tpdex(RW) 0000000_0 power_down(RW) 00000000
+.equ               DENALI_CTL_14_DATA ,0b00000000000101000000000011001000 ##0000000000010100 txsnr(RW) 0000000011001000 txsr(RW) 
+.equ               DENALI_CTL_15_DATA ,0b00000001000000000000000000000000 ##0000000_1 enable_quick_srefresh(RW) 0000000_0 srefresh_exit_no_refresh(RW) 0000000_0 pwrup_srefresh_exit(RW) 0000000_0 srefresh(RW+) 
+.equ               DENALI_CTL_16_DATA ,0b00000000000000000000000000000000 ##0000000000000000 lowpower_power_down_cnt(RW) 000_00000 lowpower_control(RW) 00000_000 cke_delay(RW) 
+.equ               DENALI_CTL_17_DATA ,0b00000000000000000000000000000000 ##0000000000000000 lowpower_external_cnt(RW) 0000000000000000 lowpower_self_refresh_cnt(RW) 
+.equ               DENALI_CTL_18_DATA ,0b00000000000000000000000000000000 ##0000000_0 lowpower_refresh_enable(RW) 0000000000000000 lowpower_internal_cnt(RW) 000_00000 lowpower_auto_enable(RW) 
+.equ               DENALI_CTL_19_DATA ,0b00000000000000000000001100000011 ##00000000000000000000_0011 cksrx(RW) 0000_0011 cksre(RW) 
+.equ               DENALI_CTL_20_DATA ,0b00000000000000000000000000000000 ##000000_00000000000000000000000000 write_modereg(RW+) 
+.equ               DENALI_CTL_21_DATA ,0b00000000000001000100001000000000 ##0000000000_00010001000010 mr0_data_0(RW) 00000000 mrw_status(RD) 
+.equ               DENALI_CTL_22_DATA ,0b00000000000000000000010001000000 ##00_00000000000000 mr2_data_0(RW) 00_00010001000000 mr1_data_0(RW) 
+.equ               DENALI_CTL_23_DATA ,0b00000000000000000000000000000000 ##00_00000000000000 mr3_data_0(RW) 00_00000000000000 mrsingle_data_0(RW) 
+.equ               DENALI_CTL_24_DATA ,0b00001010000000100000000000000000 ##0000_1010 aprebit(RW_D) 00000_010 column_size(RW) 00000_000 addr_pins(RW) 0000000_0 eight_bank_mode(RW) 
+.equ               DENALI_CTL_25_DATA ,0b00000001000000010000101000001010 ##0000000_1 bank_split_en(RW) 0000000_1 addr_cmp_en(RW) 000_01010 command_age_count(RW) 000_01010 age_count(RW) 
+.equ               DENALI_CTL_26_DATA ,0b00000001000000010000000100000001 ##0000000_1 swap_en(RW) 0000000_1 rw_same_en(RW) 0000000_1 priority_en(RW) 0000000_1 placement_en(RW) 
+.equ               DENALI_CTL_27_DATA ,0b00000000000000000000000100000000 ##00000_000 q_fullness(RW) 0000000_0 fast_write(RW) 0000000_1 reduc(RW) 0000000_0 inhibit_dram_cmd(RW) 
+.equ               DENALI_CTL_28_DATA ,0b00000000000000000000000100000000 ##0000_000000000000 int_status(RD) 0000000_1 resync_dll_per_aref_en(RW) 0000000_0 resync_dll(WR) 
+.equ               DENALI_CTL_29_DATA ,0b00000000000000000000000000000000 ##0000_000000000000 int_mask(RW) 00000_00000000000 int_ack(WR) 
+.equ               DENALI_CTL_30_DATA ,0b00000000000000000000000000000000 ##00_000000000000000000000000000000 out_of_range_addr(RD) 
+.equ               DENALI_CTL_31_DATA ,0b00000000000000000000000000000000 ##000000000_0000000 out_of_range_source_id(RD) 00_000000 out_of_range_type(RD) 00_000000 out_of_range_length(RD) 
+.equ               DENALI_CTL_32_DATA ,0b00000000000000000000000000000000 ##00_000000000000000000000000000000 port_cmd_error_addr(RD) 
+.equ               DENALI_CTL_33_DATA ,0b00000000000000000000000000000000 ##00000_000 port_data_error_type(RD) 0_0000000 port_data_error_id(RD) 0000_0000 port_cmd_error_type(RD) 0_0000000 port_cmd_error_id(RD) 
+.equ               DENALI_CTL_34_DATA ,0b00000001000000000000000000000000 ##00000_001 r2w_samecs_dly(RW) 00000_000 r2r_samecs_dly(RW) 0000_0000 add_odt_clk_w2r_samecs(RW) 0000_0000 add_odt_clk_r2w_samecs(RW) 
+.equ               DENALI_CTL_35_DATA ,0b00000000000000000000000000000000 ##000_00000 ocd_adjust_pup_cs_0(RW) 000_00000 ocd_adjust_pdn_cs_0(RW) 00000_000 w2w_samecs_dly(RW) 00000_000 w2r_samecs_dly(RW) 
+.equ               DENALI_CTL_36_DATA ,0b00001111000011110000111100001111 ##0000_1111 ahb1_rdlen(RW) 0000_1111 ahb1_wrlen(RW) 0000_1111 ahb0_rdlen(RW) 0000_1111 ahb0_wrlen(RW) 
+.equ               DENALI_CTL_37_DATA ,0b00001111000011110000111100001111 ##0000_1111 ahb3_rdlen(RW) 0000_1111 ahb3_wrlen(RW) 0000_1111 ahb2_rdlen(RW) 0000_1111 ahb2_wrlen(RW) 
+.equ               DENALI_CTL_38_DATA ,0b00000000000000010000111100001111 ##0000000000000001 axi0_en_size_lt_width_instr(RW) 0000_1111 ahb4_rdlen(RW) 0000_1111 ahb4_wrlen(RW) 
+.equ               DENALI_CTL_39_DATA ,0b00000000000000000000001100000011 ##00000000000000_00 axi0_fifo_type_reg(RW) 00000_011 axi0_w_priority(RW) 00000_011 axi0_r_priority(RW) 
+.equ               DENALI_CTL_40_DATA ,0b00000011000000110000000000000001 ##00000_011 axi1_w_priority(RW) 00000_011 axi1_r_priority(RW) 0000000000000001 axi1_en_size_lt_width_instr(RW) 
+.equ               DENALI_CTL_41_DATA ,0b00000010000000000000000100000000 ##00000_010 axi2_r_priority(RW) 0000000000000001 axi2_en_size_lt_width_instr(RW) 000000_00 axi1_fifo_type_reg(RW) 
+.equ               DENALI_CTL_42_DATA ,0b00000000000000010000000000000010 ##0000000000000001 axi3_en_size_lt_width_instr(RW) 000000_00 axi2_fifo_type_reg(RW) 00000_010 axi2_w_priority(RW) 
+.equ               DENALI_CTL_43_DATA ,0b00000000000000000000001100000011 ##00000000000000_00 axi3_fifo_type_reg(RW) 00000_011 axi3_w_priority(RW) 00000_011 axi3_r_priority(RW) 
+.equ               DENALI_CTL_44_DATA ,0b00000011000000110000000000000001 ##00000_011 axi4_w_priority(RW) 00000_011 axi4_r_priority(RW) 0000000000000001 axi4_en_size_lt_width_instr(RW) 
+.equ               DENALI_CTL_45_DATA ,0b00000010000000000000000100000000 ##00000_010 axi5_r_priority(RW) 0000000000000001 axi5_en_size_lt_width_instr(RW) 000000_00 axi4_fifo_type_reg(RW) 
+.equ               DENALI_CTL_46_DATA ,0b00000000000000000000000000000010 ##00000_000 weighted_round_robin_weight_sharing(RW) 0000000_0 weighted_round_robin_latency_control(RW) 000000_00 axi5_fifo_type_reg(RW) 00000_010 axi5_w_priority(RW) 
+.equ               DENALI_CTL_47_DATA ,0b00000001000000010000000100000000 ##0000_0001 axi0_priority2_relative_priority(RW) 0000_0001 axi0_priority1_relative_priority(RW) 0000_0001 axi0_priority0_relative_priority(RW) 0000_0000 wrr_param_value_err(RD) 
+.equ               DENALI_CTL_48_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi0_priority6_relative_priority(RW) 0000_0001 axi0_priority5_relative_priority(RW) 0000_0001 axi0_priority4_relative_priority(RW) 0000_0001 axi0_priority3_relative_priority(RW) 
+.equ               DENALI_CTL_49_DATA ,0b00000000011001000000000000000001 ##000000_0001100100 axi0_priority_relax(RW) 00000_000 axi0_port_ordering(RW) 0000_0001 axi0_priority7_relative_priority(RW) 
+.equ               DENALI_CTL_50_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi1_priority3_relative_priority(RW) 0000_0001 axi1_priority2_relative_priority(RW) 0000_0001 axi1_priority1_relative_priority(RW) 0000_0001 axi1_priority0_relative_priority(RW) 
+.equ               DENALI_CTL_51_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi1_priority7_relative_priority(RW) 0000_0001 axi1_priority6_relative_priority(RW) 0000_0001 axi1_priority5_relative_priority(RW) 0000_0001 axi1_priority4_relative_priority(RW) 
+.equ               DENALI_CTL_52_DATA ,0b00000001000000000110010000000001 ##0000_0001 axi2_priority0_relative_priority(RW) 000000_0001100100 axi1_priority_relax(RW) 00000_001 axi1_port_ordering(RW) 
+.equ               DENALI_CTL_53_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi2_priority4_relative_priority(RW) 0000_0001 axi2_priority3_relative_priority(RW) 0000_0001 axi2_priority2_relative_priority(RW) 0000_0001 axi2_priority1_relative_priority(RW) 
+.equ               DENALI_CTL_54_DATA ,0b00000010000000010000000100000001 ##00000_010 axi2_port_ordering(RW) 0000_0001 axi2_priority7_relative_priority(RW) 0000_0001 axi2_priority6_relative_priority(RW) 0000_0001 axi2_priority5_relative_priority(RW) 
+.equ               DENALI_CTL_55_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi3_priority1_relative_priority(RW) 0000_0001 axi3_priority0_relative_priority(RW) 000000_0001100100 axi2_priority_relax(RW) 
+.equ               DENALI_CTL_56_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi3_priority5_relative_priority(RW) 0000_0001 axi3_priority4_relative_priority(RW) 0000_0001 axi3_priority3_relative_priority(RW) 0000_0001 axi3_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_57_DATA ,0b00000000000000110000000100000001 ##0000000000000_011 axi3_port_ordering(RW) 0000_0001 axi3_priority7_relative_priority(RW) 0000_0001 axi3_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_58_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi4_priority1_relative_priority(RW) 0000_0001 axi4_priority0_relative_priority(RW) 000000_0001100100 axi3_priority_relax(RW) 
+.equ               DENALI_CTL_59_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi4_priority5_relative_priority(RW) 0000_0001 axi4_priority4_relative_priority(RW) 0000_0001 axi4_priority3_relative_priority(RW) 0000_0001 axi4_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_60_DATA ,0b00000000000001000000000100000001 ##0000000000000_100 axi4_port_ordering(RW) 0000_0001 axi4_priority7_relative_priority(RW) 0000_0001 axi4_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_61_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi5_priority1_relative_priority(RW) 0000_0001 axi5_priority0_relative_priority(RW) 000000_0001100100 axi4_priority_relax(RW) 
+.equ               DENALI_CTL_62_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi5_priority5_relative_priority(RW) 0000_0001 axi5_priority4_relative_priority(RW) 0000_0001 axi5_priority3_relative_priority(RW) 0000_0001 axi5_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_63_DATA ,0b00000000000001010000000100000001 ##0000000000000_101 axi5_port_ordering(RW) 0000_0001 axi5_priority7_relative_priority(RW) 0000_0001 axi5_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_64_DATA ,0b00000000000000000000000001100100 ##000000000000000_0 cke_status(RD) 000000_0001100100 axi5_priority_relax(RW) 
+.equ               DENALI_CTL_65_DATA ,0b00000000000000000000000000000000 ##0000_0000 tdfi_phy_wrlat(RD) 00000000 dll_rst_adj_dly(RW) 0000000000000000 dll_rst_delay(RW) 
+.equ               DENALI_CTL_66_DATA ,0b00000000000000000000011000000000 ##0000000_0 dram_clk_disable(RW) 0000_0000 tdfi_rddata_en(RD) 0000_0110 tdfi_phy_rdlat(RW_D) 0_0000000 update_error_status(RD) 
+.equ               DENALI_CTL_67_DATA ,0b00000000000001001101100000000000 ##0000000000_00010011011000 tdfi_ctrlupd_max(RW) 0000_0000 tdfi_ctrlupd_min(RD) 
+.equ               DENALI_CTL_68_DATA ,0b00000010000000000000001000000000 ##0000001000000000 tdfi_phyupd_type1(RW) 0000001000000000 tdfi_phyupd_type0(RW) 
+.equ               DENALI_CTL_69_DATA ,0b00000010000000000000001000000000 ##0000001000000000 tdfi_phyupd_type3(RW) 0000001000000000 tdfi_phyupd_type2(RW) 
+.equ               DENALI_CTL_70_DATA ,0b00000000000000000000010011011000 ##000000000000000000_00010011011000 tdfi_phyupd_resp(RW) 
+.equ               DENALI_CTL_71_DATA ,0b00000000000000000001100000111000 ##00000000000000000001100000111000 tdfi_ctrlupd_interval(RW) 
+.equ               DENALI_CTL_72_DATA ,0b00000000000000100000001100000100 ##00000_000 tdfi_dram_clk_disable(RW) 0000_0010 tdfi_ctrl_delay(RW_D) 0000_0011 wrlat_adj(RW) 0000_0100 rdlat_adj(RW) 
+.equ               DENALI_CTL_73_DATA ,0b00000000000000000000000100000001 ##00000000000000000000000_1 odt_alt_en(RW) 0000_0001 tdfi_dram_clk_enable(RW) 
+
+/******************************************************************
+ * COPYRIGHT (c) 2000 Denali Software, Inc.  All rights reserved. *
+ * -------------------------------------------------------------- *
+ * This code is proprietary and confidential information of       *
+ * Denali Software. It may not be reproduced, used or transmitted *
+ * in any form whatsoever without the express and written         *
+ * permission of Denali Software.                                 *
+ ******************************************************************
+ ******************************************************************
+ *                                                                 
+ *   Module:         regconfig.h
+ *   Documentation:  Register programming header file
+ *
+ ******************************************************************
+ ******************************************************************/
+
+/*****************************************************************
+ * WARNING:  This file was automatically generated.  Manual
+ * editing may result in undetermined behavior, and may be in
+ * violation of the Denali Support Agreement.
+ *****************************************************************/
+
+
+
+## ********************************************************************
+## Option: IP Mode                      = PHY
+## Option: Burst Length                  = 4
+## Option: CAS Latency                   = 4
+## Option: Simulation MHz                = 170
+## Option: Auto Precharge Mode     (0/1) = 0
+## Option: DLL Bypass Mode         (0/1) = 0
+## Option: Half-Memory Support     (0/1) = 1
+## Option: Registered Dimm Support (0/1) = 0
+## Option: SYNCRONIOUS 0/1 = 0
+## ********************************************************************
+## Memory: mt47h64m8_25e.xml
+## ********************************************************************
+
+
+.equ               DENALI_PHY_00_DATA, 0b00000000000100010001000100000000 ##00000000000100010001000100000000 phy_pad_ctrl_reg_0(RW) 
+.equ               DENALI_PHY_01_DATA, 0b11110011000000010011101000100111 ##11110011000000010011101000100111 den_phy_ctrl_reg_0_0(RW) 
+.equ               DENALI_PHY_02_DATA, 0b00100100110000000000001011000000 ##00100100110000000000001011000000 den_phy_ctrl_reg_1_0(RW) 
+.equ               DENALI_PHY_03_DATA, 0b11110011000000010011101000100111 ##11110011000000010011101000100111 den_phy_ctrl_reg_0_1(RW) 
+.equ               DENALI_PHY_04_DATA, 0b00100100110000000000001011000000 ##00100100110000000000001011000000 den_phy_ctrl_reg_1_1(RW) 
+.equ               DENALI_PHY_05_DATA, 0b00000000000000000010101000000100 ##00000000000000000010101000000100 den_phy_ctrl_reg_2(RW) 
+.equ               DENALI_PHY_06_DATA, 0b00100000000010000001111001100100 ##00100000000010000001111001100100 phy_dll_ctrl_reg_0_0(RW) 
+.equ               DENALI_PHY_07_DATA, 0b00000001000010000001111100001110 ##00000001000010000001111100001110 phy_dll_ctrl_reg_1_0(RW) 
+.equ               DENALI_PHY_08_DATA, 0b00100000000010000001111001100100 ##00100000000010000001111001100100 phy_dll_ctrl_reg_0_1(RW) 
+.equ               DENALI_PHY_09_DATA, 0b00000001000010000001111100001110 ##00000001000010000001111100001110 phy_dll_ctrl_reg_1_1(RW) 
+.equ               DENALI_PHY_10_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 den_phy_obs_reg_0_0(RD) 
+.equ               DENALI_PHY_11_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_0_0(RD) 
+.equ               DENALI_PHY_12_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_1_0(RD) 
+.equ               DENALI_PHY_13_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 den_phy_obs_reg_0_1(RD) 
+.equ               DENALI_PHY_14_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_0_1(RD) 
+.equ               DENALI_PHY_15_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_1_1(RD) 
+#else ##ddr_clk_160
+
+/******************************************************************
+ * COPYRIGHT (c) 2000 Denali Software, Inc.  All rights reserved. *
+ * -------------------------------------------------------------- *
+ * This code is proprietary and confidential information of       *
+ * Denali Software. It may not be reproduced, used or transmitted *
+ * in any form whatsoever without the express and written         *
+ * permission of Denali Software.                                 *
+ ******************************************************************
+ ******************************************************************
+ *                                                                 
+ *   Module:         regconfig.h
+ *   Documentation:  Register programming header file
+ *
+ ******************************************************************
+ ******************************************************************/
+
+/*****************************************************************
+ * WARNING:  This file was automatically generated.  Manual
+ * editing may result in undetermined behavior, and may be in
+ * violation of the Denali Support Agreement.
+ *****************************************************************/
+
+
+
+## ********************************************************************
+## Option: IP Mode                      = CTL
+## Option: Burst Length                  = 4
+## Option: CAS Latency                   = 4
+## Option: Simulation MHz                = 250
+## Option: Auto Precharge Mode     (0/1) = 0
+## Option: DLL Bypass Mode         (0/1) = 0
+## Option: Half-Memory Support     (0/1) = 1
+## Option: Registered Dimm Support (0/1) = 0
+## Option: SYNCRONIOUS 0/1 = 1
+## ********************************************************************
+## Memory: mt47h64m8_25e.xml
+## ********************************************************************
+
+
+.equ               DENALI_CTL_00_DATA ,0b00000000000000000000010000000000 ##0000000000000000 version(RD) 0000_0100 dram_class(RW) 0000000_0 start(RW) 
+.equ               DENALI_CTL_01_DATA ,0b00000000000000000000000000000000 ##000000000000000_0 max_cs_reg(RD) 0000_0000 max_col_reg(RD) 0000_0000 max_row_reg(RD) 
+.equ               DENALI_CTL_02_DATA ,0b00000010000000000000000000110010 ##0000_0010 initaref(RW) 000000000000000000110010 tinit(RW) 
+.equ               DENALI_CTL_03_DATA ,0b00000010000000100000001100001000 ##000_00010 tccd(RW) 00000_010 tbst_int_interval(RW) 0000_0011 wrlat(RW) 0000_1000 caslat_lin(RW) 
+.equ               DENALI_CTL_04_DATA ,0b00000010000011000000111000000010 ##0000_0010 twtr(RW) 00001100 tras_min(RW) 00001110 trc(RW) 00000010 trrd(RW) 
+.equ               DENALI_CTL_05_DATA ,0b00000011000000100000001000000100 ##00000011 tmod(RW) 000_00010 tmrd(RW) 00000_010 trtp(RW) 0000_0100 trp(RW) 
+.equ               DENALI_CTL_06_DATA ,0b00000011000000110100010001011100 ##000_00011 tckesr(RW) 00000_011 tcke(RW) 0100010001011100 tras_max(RW) 
+.equ               DENALI_CTL_07_DATA ,0b00000001000000010000000000000000 ##0000000_1 tras_lockout(RW) 0000000_1 concurrentap(RW) 0000000_0 ap(RW) 0000000_0 writeinterp(RW) 
+.equ               DENALI_CTL_08_DATA ,0b00000000000010000000010000000100 ##00000000000_01000 tdal(RW) 000_00100 twr_int(RW) 00000100 trcd_int(RW) 
+.equ               DENALI_CTL_09_DATA ,0b00000010000000000000000011001000 ##00000_010 bstlen(RW_D) 0000000_0 no_cmd_init(RW) 0000000011001000 tdll(RW) 
+.equ               DENALI_CTL_10_DATA ,0b00000100000000000110010000000000 ##0000_0100 trp_ab(RW) 0000000001100100 tcpd(RW) 00_000000 tfaw(RW) 
+.equ               DENALI_CTL_11_DATA ,0b00000001000000000000000000000000 ##0000000_1 tref_enable(RW) 0000000_0 auto_refresh_mode(RW) 0000000_0 arefresh(WR) 0000000_0 reg_dimm_enable(RW) 
+.equ               DENALI_CTL_12_DATA ,0b00000111010010110000000000011011 ##00_00011101001011 tref(RW) 000000_0000011011 trfc(RW) 
+.equ               DENALI_CTL_13_DATA ,0b00000000000000100000000000000000 ##0000000000000010 tpdex(RW) 0000000_0 power_down(RW) 00000000
+.equ               DENALI_CTL_14_DATA ,0b00000000000111010000000011001000 ##0000000000011101 txsnr(RW) 0000000011001000 txsr(RW) 
+.equ               DENALI_CTL_15_DATA ,0b00000001000000000000000000000000 ##0000000_1 enable_quick_srefresh(RW) 0000000_0 srefresh_exit_no_refresh(RW) 0000000_0 pwrup_srefresh_exit(RW) 0000000_0 srefresh(RW+) 
+.equ               DENALI_CTL_16_DATA ,0b00000000000000000000000000000000 ##0000000000000000 lowpower_power_down_cnt(RW) 000_00000 lowpower_control(RW) 00000_000 cke_delay(RW) 
+.equ               DENALI_CTL_17_DATA ,0b00000000000000000000000000000000 ##0000000000000000 lowpower_external_cnt(RW) 0000000000000000 lowpower_self_refresh_cnt(RW) 
+.equ               DENALI_CTL_18_DATA ,0b00000000000000000000000000000000 ##0000000_0 lowpower_refresh_enable(RW) 0000000000000000 lowpower_internal_cnt(RW) 000_00000 lowpower_auto_enable(RW) 
+.equ               DENALI_CTL_19_DATA ,0b00000000000000000000001100000011 ##00000000000000000000_0011 cksrx(RW) 0000_0011 cksre(RW) 
+.equ               DENALI_CTL_20_DATA ,0b00000000000000000000000000000000 ##000000_00000000000000000000000000 write_modereg(RW+) 
+.equ               DENALI_CTL_21_DATA ,0b00000000000001100100001000000000 ##0000000000_00011001000010 mr0_data_0(RW) 00000000 mrw_status(RD) 
+.equ               DENALI_CTL_22_DATA ,0b00000000000000000000010001000000 ##00_00000000000000 mr2_data_0(RW) 00_00010001000000 mr1_data_0(RW) 
+.equ               DENALI_CTL_23_DATA ,0b00000000000000000000000000000000 ##00_00000000000000 mr3_data_0(RW) 00_00000000000000 mrsingle_data_0(RW) 
+.equ               DENALI_CTL_24_DATA ,0b00001010000000100000000000000000 ##0000_1010 aprebit(RW_D) 00000_010 column_size(RW) 00000_000 addr_pins(RW) 0000000_0 eight_bank_mode(RW) 
+.equ               DENALI_CTL_25_DATA ,0b00000001000000010000101000001010 ##0000000_1 bank_split_en(RW) 0000000_1 addr_cmp_en(RW) 000_01010 command_age_count(RW) 000_01010 age_count(RW) 
+.equ               DENALI_CTL_26_DATA ,0b00000001000000010000000100000001 ##0000000_1 swap_en(RW) 0000000_1 rw_same_en(RW) 0000000_1 priority_en(RW) 0000000_1 placement_en(RW) 
+.equ               DENALI_CTL_27_DATA ,0b00000000000000000000000100000000 ##00000_000 q_fullness(RW) 0000000_0 fast_write(RW) 0000000_1 reduc(RW) 0000000_0 inhibit_dram_cmd(RW) 
+.equ               DENALI_CTL_28_DATA ,0b00000000000000000000000100000000 ##0000_000000000000 int_status(RD) 0000000_1 resync_dll_per_aref_en(RW) 0000000_0 resync_dll(WR) 
+.equ               DENALI_CTL_29_DATA ,0b00000000000000000000000000000000 ##0000_000000000000 int_mask(RW) 00000_00000000000 int_ack(WR) 
+.equ               DENALI_CTL_30_DATA ,0b00000000000000000000000000000000 ##00_000000000000000000000000000000 out_of_range_addr(RD) 
+.equ               DENALI_CTL_31_DATA ,0b00000000000000000000000000000000 ##000000000_0000000 out_of_range_source_id(RD) 00_000000 out_of_range_type(RD) 00_000000 out_of_range_length(RD) 
+.equ               DENALI_CTL_32_DATA ,0b00000000000000000000000000000000 ##00_000000000000000000000000000000 port_cmd_error_addr(RD) 
+.equ               DENALI_CTL_33_DATA ,0b00000000000000000000000000000000 ##00000_000 port_data_error_type(RD) 0_0000000 port_data_error_id(RD) 0000_0000 port_cmd_error_type(RD) 0_0000000 port_cmd_error_id(RD) 
+.equ               DENALI_CTL_34_DATA ,0b00000001000000000000000000000000 ##00000_001 r2w_samecs_dly(RW) 00000_000 r2r_samecs_dly(RW) 0000_0000 add_odt_clk_w2r_samecs(RW) 0000_0000 add_odt_clk_r2w_samecs(RW) 
+.equ               DENALI_CTL_35_DATA ,0b00000000000000000000000000000000 ##000_00000 ocd_adjust_pup_cs_0(RW) 000_00000 ocd_adjust_pdn_cs_0(RW) 00000_000 w2w_samecs_dly(RW) 00000_000 w2r_samecs_dly(RW) 
+.equ               DENALI_CTL_36_DATA ,0b00001111000011110000111100001111 ##0000_1111 ahb1_rdlen(RW) 0000_1111 ahb1_wrlen(RW) 0000_1111 ahb0_rdlen(RW) 0000_1111 ahb0_wrlen(RW) 
+.equ               DENALI_CTL_37_DATA ,0b00001111000011110000111100001111 ##0000_1111 ahb3_rdlen(RW) 0000_1111 ahb3_wrlen(RW) 0000_1111 ahb2_rdlen(RW) 0000_1111 ahb2_wrlen(RW) 
+.equ               DENALI_CTL_38_DATA ,0b00000000000000010000111100001111 ##0000000000000001 axi0_en_size_lt_width_instr(RW) 0000_1111 ahb4_rdlen(RW) 0000_1111 ahb4_wrlen(RW) 
+.equ               DENALI_CTL_39_DATA ,0b00000000000000110000001100000011 ##00000000000000_11 axi0_fifo_type_reg(RW) 00000_011 axi0_w_priority(RW) 00000_011 axi0_r_priority(RW) 
+.equ               DENALI_CTL_40_DATA ,0b00000011000000110000000000000001 ##00000_011 axi1_w_priority(RW) 00000_011 axi1_r_priority(RW) 0000000000000001 axi1_en_size_lt_width_instr(RW) 
+.equ               DENALI_CTL_41_DATA ,0b00000010000000000000000100000011 ##00000_010 axi2_r_priority(RW) 0000000000000001 axi2_en_size_lt_width_instr(RW) 000000_11 axi1_fifo_type_reg(RW) 
+.equ               DENALI_CTL_42_DATA ,0b00000000000000010000001100000010 ##0000000000000001 axi3_en_size_lt_width_instr(RW) 000000_11 axi2_fifo_type_reg(RW) 00000_010 axi2_w_priority(RW) 
+.equ               DENALI_CTL_43_DATA ,0b00000000000000110000001100000011 ##00000000000000_11 axi3_fifo_type_reg(RW) 00000_011 axi3_w_priority(RW) 00000_011 axi3_r_priority(RW) 
+.equ               DENALI_CTL_44_DATA ,0b00000011000000110000000000000001 ##00000_011 axi4_w_priority(RW) 00000_011 axi4_r_priority(RW) 0000000000000001 axi4_en_size_lt_width_instr(RW) 
+.equ               DENALI_CTL_45_DATA ,0b00000010000000000000000100000011 ##00000_010 axi5_r_priority(RW) 0000000000000001 axi5_en_size_lt_width_instr(RW) 000000_11 axi4_fifo_type_reg(RW) 
+.equ               DENALI_CTL_46_DATA ,0b00000000000000000000001100000010 ##00000_000 weighted_round_robin_weight_sharing(RW) 0000000_0 weighted_round_robin_latency_control(RW) 000000_11 axi5_fifo_type_reg(RW) 00000_010 axi5_w_priority(RW) 
+.equ               DENALI_CTL_47_DATA ,0b00000001000000010000000100000000 ##0000_0001 axi0_priority2_relative_priority(RW) 0000_0001 axi0_priority1_relative_priority(RW) 0000_0001 axi0_priority0_relative_priority(RW) 0000_0000 wrr_param_value_err(RD) 
+.equ               DENALI_CTL_48_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi0_priority6_relative_priority(RW) 0000_0001 axi0_priority5_relative_priority(RW) 0000_0001 axi0_priority4_relative_priority(RW) 0000_0001 axi0_priority3_relative_priority(RW) 
+.equ               DENALI_CTL_49_DATA ,0b00000000011001000000000000000001 ##000000_0001100100 axi0_priority_relax(RW) 00000_000 axi0_port_ordering(RW) 0000_0001 axi0_priority7_relative_priority(RW) 
+.equ               DENALI_CTL_50_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi1_priority3_relative_priority(RW) 0000_0001 axi1_priority2_relative_priority(RW) 0000_0001 axi1_priority1_relative_priority(RW) 0000_0001 axi1_priority0_relative_priority(RW) 
+.equ               DENALI_CTL_51_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi1_priority7_relative_priority(RW) 0000_0001 axi1_priority6_relative_priority(RW) 0000_0001 axi1_priority5_relative_priority(RW) 0000_0001 axi1_priority4_relative_priority(RW) 
+.equ               DENALI_CTL_52_DATA ,0b00000001000000000110010000000001 ##0000_0001 axi2_priority0_relative_priority(RW) 000000_0001100100 axi1_priority_relax(RW) 00000_001 axi1_port_ordering(RW) 
+.equ               DENALI_CTL_53_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi2_priority4_relative_priority(RW) 0000_0001 axi2_priority3_relative_priority(RW) 0000_0001 axi2_priority2_relative_priority(RW) 0000_0001 axi2_priority1_relative_priority(RW) 
+.equ               DENALI_CTL_54_DATA ,0b00000010000000010000000100000001 ##00000_010 axi2_port_ordering(RW) 0000_0001 axi2_priority7_relative_priority(RW) 0000_0001 axi2_priority6_relative_priority(RW) 0000_0001 axi2_priority5_relative_priority(RW) 
+.equ               DENALI_CTL_55_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi3_priority1_relative_priority(RW) 0000_0001 axi3_priority0_relative_priority(RW) 000000_0001100100 axi2_priority_relax(RW) 
+.equ               DENALI_CTL_56_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi3_priority5_relative_priority(RW) 0000_0001 axi3_priority4_relative_priority(RW) 0000_0001 axi3_priority3_relative_priority(RW) 0000_0001 axi3_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_57_DATA ,0b00000000000000110000000100000001 ##0000000000000_011 axi3_port_ordering(RW) 0000_0001 axi3_priority7_relative_priority(RW) 0000_0001 axi3_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_58_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi4_priority1_relative_priority(RW) 0000_0001 axi4_priority0_relative_priority(RW) 000000_0001100100 axi3_priority_relax(RW) 
+.equ               DENALI_CTL_59_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi4_priority5_relative_priority(RW) 0000_0001 axi4_priority4_relative_priority(RW) 0000_0001 axi4_priority3_relative_priority(RW) 0000_0001 axi4_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_60_DATA ,0b00000000000001000000000100000001 ##0000000000000_100 axi4_port_ordering(RW) 0000_0001 axi4_priority7_relative_priority(RW) 0000_0001 axi4_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_61_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi5_priority1_relative_priority(RW) 0000_0001 axi5_priority0_relative_priority(RW) 000000_0001100100 axi4_priority_relax(RW) 
+.equ               DENALI_CTL_62_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi5_priority5_relative_priority(RW) 0000_0001 axi5_priority4_relative_priority(RW) 0000_0001 axi5_priority3_relative_priority(RW) 0000_0001 axi5_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_63_DATA ,0b00000000000001010000000100000001 ##0000000000000_101 axi5_port_ordering(RW) 0000_0001 axi5_priority7_relative_priority(RW) 0000_0001 axi5_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_64_DATA ,0b00000000000000000000000001100100 ##000000000000000_0 cke_status(RD) 000000_0001100100 axi5_priority_relax(RW) 
+.equ               DENALI_CTL_65_DATA ,0b00000000000000000000000000000000 ##0000_0000 tdfi_phy_wrlat(RD) 00000000 dll_rst_adj_dly(RW) 0000000000000000 dll_rst_delay(RW) 
+.equ               DENALI_CTL_66_DATA ,0b00000000000000000000011100000000 ##0000000_0 dram_clk_disable(RW) 0000_0000 tdfi_rddata_en(RD) 0000_0111 tdfi_phy_rdlat(RW_D) 0_0000000 update_error_status(RD) 
+.equ               DENALI_CTL_67_DATA ,0b00000000000001110100101100000000 ##0000000000_00011101001011 tdfi_ctrlupd_max(RW) 0000_0000 tdfi_ctrlupd_min(RD) 
+.equ               DENALI_CTL_68_DATA ,0b00000010000000000000001000000000 ##0000001000000000 tdfi_phyupd_type1(RW) 0000001000000000 tdfi_phyupd_type0(RW) 
+.equ               DENALI_CTL_69_DATA ,0b00000010000000000000001000000000 ##0000001000000000 tdfi_phyupd_type3(RW) 0000001000000000 tdfi_phyupd_type2(RW) 
+.equ               DENALI_CTL_70_DATA ,0b00000000000000000000011101001011 ##000000000000000000_00011101001011 tdfi_phyupd_resp(RW) 
+.equ               DENALI_CTL_71_DATA ,0b00000000000000000010010001110111 ##00000000000000000010010001110111 tdfi_ctrlupd_interval(RW) 
+.equ               DENALI_CTL_72_DATA ,0b00000000000000100000001100000100 ##00000_000 tdfi_dram_clk_disable(RW) 0000_0010 tdfi_ctrl_delay(RW_D) 0000_0011 wrlat_adj(RW) 0000_0100 rdlat_adj(RW) 
+.equ               DENALI_CTL_73_DATA ,0b00000000000000000000000100000001 ##00000000000000000000000_1 odt_alt_en(RW) 0000_0001 tdfi_dram_clk_enable(RW) 
+
+/******************************************************************
+ * COPYRIGHT (c) 2000 Denali Software, Inc.  All rights reserved. *
+ * -------------------------------------------------------------- *
+ * This code is proprietary and confidential information of       *
+ * Denali Software. It may not be reproduced, used or transmitted *
+ * in any form whatsoever without the express and written         *
+ * permission of Denali Software.                                 *
+ ******************************************************************
+ ******************************************************************
+ *                                                                 
+ *   Module:         regconfig.h
+ *   Documentation:  Register programming header file
+ *
+ ******************************************************************
+ ******************************************************************/
+
+/*****************************************************************
+ * WARNING:  This file was automatically generated.  Manual
+ * editing may result in undetermined behavior, and may be in
+ * violation of the Denali Support Agreement.
+ *****************************************************************/
+
+
+
+## ********************************************************************
+## Option: IP Mode                      = PHY
+## Option: Burst Length                  = 4
+## Option: CAS Latency                   = 4
+## Option: Simulation MHz                = 250
+## Option: Auto Precharge Mode     (0/1) = 0
+## Option: DLL Bypass Mode         (0/1) = 0
+## Option: Half-Memory Support     (0/1) = 1
+## Option: Registered Dimm Support (0/1) = 0
+## Option: SYNCRONIOUS 0/1 = 1
+## ********************************************************************
+## Memory: mt47h64m8_25e.xml
+## ********************************************************************
+
+
+.equ               DENALI_PHY_00_DATA, 0b00000000000100010001000100000000 ##00000000000100010001000100000000 phy_pad_ctrl_reg_0(RW) 
+.equ               DENALI_PHY_01_DATA, 0b11110100000000010100101100110111 ##11110100000000010100101100110111 den_phy_ctrl_reg_0_0(RW) 
+.equ               DENALI_PHY_02_DATA, 0b00100100110000000000001011000000 ##00100100110000000000001011000000 den_phy_ctrl_reg_1_0(RW) 
+.equ               DENALI_PHY_03_DATA, 0b11110100000000010100101100110111 ##11110100000000010100101100110111 den_phy_ctrl_reg_0_1(RW) 
+.equ               DENALI_PHY_04_DATA, 0b00100100110000000000001011000000 ##00100100110000000000001011000000 den_phy_ctrl_reg_1_1(RW) 
+.equ               DENALI_PHY_05_DATA, 0b00000000000000000010101000000101 ##00000000000000000010101000000101 den_phy_ctrl_reg_2(RW) 
+.equ               DENALI_PHY_06_DATA, 0b00100000000001010001110101000100 ##00100000000001010001110101000100 phy_dll_ctrl_reg_0_0(RW) 
+.equ               DENALI_PHY_07_DATA, 0b00000001000001010001111100001001 ##00000001000001010001111100001001 phy_dll_ctrl_reg_1_0(RW) 
+.equ               DENALI_PHY_08_DATA, 0b00100000000001010001110101000100 ##00100000000001010001110101000100 phy_dll_ctrl_reg_0_1(RW) 
+.equ               DENALI_PHY_09_DATA, 0b00000001000001010001111100001001 ##00000001000001010001111100001001 phy_dll_ctrl_reg_1_1(RW) 
+.equ               DENALI_PHY_10_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 den_phy_obs_reg_0_0(RD) 
+.equ               DENALI_PHY_11_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_0_0(RD) 
+.equ               DENALI_PHY_12_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_1_0(RD) 
+.equ               DENALI_PHY_13_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 den_phy_obs_reg_0_1(RD) 
+.equ               DENALI_PHY_14_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_0_1(RD) 
+.equ               DENALI_PHY_15_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_1_1(RD) 
+#endif ##ddr_clk_160
+#else ##mt47h64m8_25e
+#ifdef k4t51163qj_f8
+#ifdef ddr_clk_160
+
+/******************************************************************
+ * COPYRIGHT (c) 2000 Denali Software, Inc.  All rights reserved. *
+ * -------------------------------------------------------------- *
+ * This code is proprietary and confidential information of       *
+ * Denali Software. It may not be reproduced, used or transmitted *
+ * in any form whatsoever without the express and written         *
+ * permission of Denali Software.                                 *
+ ******************************************************************
+ ******************************************************************
+ *                                                                 
+ *   Module:         regconfig.h
+ *   Documentation:  Register programming header file
+ *
+ ******************************************************************
+ ******************************************************************/
+
+/*****************************************************************
+ * WARNING:  This file was automatically generated.  Manual
+ * editing may result in undetermined behavior, and may be in
+ * violation of the Denali Support Agreement.
+ *****************************************************************/
+
+
+
+## ********************************************************************
+## Option: IP Mode                      = CTL
+## Option: Burst Length                  = 4
+## Option: CAS Latency                   = 4
+## Option: Simulation MHz                = 170
+## Option: Auto Precharge Mode     (0/1) = 0
+## Option: DLL Bypass Mode         (0/1) = 0
+## Option: Half-Memory Support     (0/1) = 0
+## Option: Registered Dimm Support (0/1) = 0
+## Option: SYNCRONIOUS 0/1 = 0
+## ********************************************************************
+## Memory: k4t51163qj_f8.xml
+## ********************************************************************
+
+
+.equ               DENALI_CTL_00_DATA ,0b00000000000000000000010000000000 ##0000000000000000 version(RD) 0000_0100 dram_class(RW) 0000000_0 start(RW) 
+.equ               DENALI_CTL_01_DATA ,0b00000000000000000000000000000000 ##000000000000000_0 max_cs_reg(RD) 0000_0000 max_col_reg(RD) 0000_0000 max_row_reg(RD) 
+.equ               DENALI_CTL_02_DATA ,0b00000010000000000000000000100010 ##0000_0010 initaref(RW) 000000000000000000100010 tinit(RW) 
+.equ               DENALI_CTL_03_DATA ,0b00000010000000100000001100001000 ##000_00010 tccd(RW) 00000_010 tbst_int_interval(RW) 0000_0011 wrlat(RW) 0000_1000 caslat_lin(RW) 
+.equ               DENALI_CTL_04_DATA ,0b00000010000010000000101000000010 ##0000_0010 twtr(RW) 00001000 tras_min(RW) 00001010 trc(RW) 00000010 trrd(RW) 
+.equ               DENALI_CTL_05_DATA ,0b00000011000000100000001000000011 ##00000011 tmod(RW) 000_00010 tmrd(RW) 00000_010 trtp(RW) 0000_0011 trp(RW) 
+.equ               DENALI_CTL_06_DATA ,0b00000011000000110010111001101101 ##000_00011 tckesr(RW) 00000_011 tcke(RW) 0010111001101101 tras_max(RW) 
+.equ               DENALI_CTL_07_DATA ,0b00000001000000010000000000000000 ##0000000_1 tras_lockout(RW) 0000000_1 concurrentap(RW) 0000000_0 ap(RW) 0000000_0 writeinterp(RW) 
+.equ               DENALI_CTL_08_DATA ,0b00000000000001100000001100000011 ##00000000000_00110 tdal(RW) 000_00011 twr_int(RW) 00000011 trcd_int(RW) 
+.equ               DENALI_CTL_09_DATA ,0b00000010000000000000000011001000 ##00000_010 bstlen(RW_D) 0000000_0 no_cmd_init(RW) 0000000011001000 tdll(RW) 
+.equ               DENALI_CTL_10_DATA ,0b00000011000000000100010000001000 ##0000_0011 trp_ab(RW) 0000000001000100 tcpd(RW) 00_001000 tfaw(RW) 
+.equ               DENALI_CTL_11_DATA ,0b00000001000000000000000000000000 ##0000000_1 tref_enable(RW) 0000000_0 auto_refresh_mode(RW) 0000000_0 arefresh(WR) 0000000_0 reg_dimm_enable(RW) 
+.equ               DENALI_CTL_12_DATA ,0b00000100110110000000000000010010 ##00_00010011011000 tref(RW) 000000_0000010010 trfc(RW) 
+.equ               DENALI_CTL_13_DATA ,0b00000000000000110000000000000000 ##0000000000000011 tpdex(RW) 0000000_0 power_down(RW) 00000000
+.equ               DENALI_CTL_14_DATA ,0b00000000000101000000000011001000 ##0000000000010100 txsnr(RW) 0000000011001000 txsr(RW) 
+.equ               DENALI_CTL_15_DATA ,0b00000001000000000000000000000000 ##0000000_1 enable_quick_srefresh(RW) 0000000_0 srefresh_exit_no_refresh(RW) 0000000_0 pwrup_srefresh_exit(RW) 0000000_0 srefresh(RW+) 
+.equ               DENALI_CTL_16_DATA ,0b00000000000000000000000000000000 ##0000000000000000 lowpower_power_down_cnt(RW) 000_00000 lowpower_control(RW) 00000_000 cke_delay(RW) 
+.equ               DENALI_CTL_17_DATA ,0b00000000000000000000000000000000 ##0000000000000000 lowpower_external_cnt(RW) 0000000000000000 lowpower_self_refresh_cnt(RW) 
+.equ               DENALI_CTL_18_DATA ,0b00000000000000000000000000000000 ##0000000_0 lowpower_refresh_enable(RW) 0000000000000000 lowpower_internal_cnt(RW) 000_00000 lowpower_auto_enable(RW) 
+.equ               DENALI_CTL_19_DATA ,0b00000000000000000000001100000011 ##00000000000000000000_0011 cksrx(RW) 0000_0011 cksre(RW) 
+.equ               DENALI_CTL_20_DATA ,0b00000000000000000000000000000000 ##000000_00000000000000000000000000 write_modereg(RW+) 
+.equ               DENALI_CTL_21_DATA ,0b00000000000001000100001000000000 ##0000000000_00010001000010 mr0_data_0(RW) 00000000 mrw_status(RD) 
+.equ               DENALI_CTL_22_DATA ,0b00000000000000000000010001000010 ##00_00000000000000 mr2_data_0(RW) 00_00010001000000 mr1_data_0(RW) 
+.equ               DENALI_CTL_23_DATA ,0b00000000000000000000000000000000 ##00_00000000000000 mr3_data_0(RW) 00_00000000000000 mrsingle_data_0(RW) 
+.equ               DENALI_CTL_24_DATA ,0b00001010000000100000000100000000 ##0000_1010 aprebit(RW_D) 00000_010 column_size(RW) 00000_001 addr_pins(RW) 0000000_0 eight_bank_mode(RW) 
+.equ               DENALI_CTL_25_DATA ,0b00000001000000010000101000001010 ##0000000_1 bank_split_en(RW) 0000000_1 addr_cmp_en(RW) 000_01010 command_age_count(RW) 000_01010 age_count(RW) 
+.equ               DENALI_CTL_26_DATA ,0b00000001000000010000000100000001 ##0000000_1 swap_en(RW) 0000000_1 rw_same_en(RW) 0000000_1 priority_en(RW) 0000000_1 placement_en(RW) 
+.equ               DENALI_CTL_27_DATA ,0b00000000000000000000000000000000 ##00000_000 q_fullness(RW) 0000000_0 fast_write(RW) 0000000_0 reduc(RW) 0000000_0 inhibit_dram_cmd(RW) 
+.equ               DENALI_CTL_28_DATA ,0b00000000000000000000000100000000 ##0000_000000000000 int_status(RD) 0000000_1 resync_dll_per_aref_en(RW) 0000000_0 resync_dll(WR) 
+.equ               DENALI_CTL_29_DATA ,0b00000000000000000000000000000000 ##0000_000000000000 int_mask(RW) 00000_00000000000 int_ack(WR) 
+.equ               DENALI_CTL_30_DATA ,0b00000000000000000000000000000000 ##00_000000000000000000000000000000 out_of_range_addr(RD) 
+.equ               DENALI_CTL_31_DATA ,0b00000000000000000000000000000000 ##000000000_0000000 out_of_range_source_id(RD) 00_000000 out_of_range_type(RD) 00_000000 out_of_range_length(RD) 
+.equ               DENALI_CTL_32_DATA ,0b00000000000000000000000000000000 ##00_000000000000000000000000000000 port_cmd_error_addr(RD) 
+.equ               DENALI_CTL_33_DATA ,0b00000000000000000000000000000000 ##00000_000 port_data_error_type(RD) 0_0000000 port_data_error_id(RD) 0000_0000 port_cmd_error_type(RD) 0_0000000 port_cmd_error_id(RD) 
+.equ               DENALI_CTL_34_DATA ,0b00000001000000000000000000000000 ##00000_001 r2w_samecs_dly(RW) 00000_000 r2r_samecs_dly(RW) 0000_0000 add_odt_clk_w2r_samecs(RW) 0000_0000 add_odt_clk_r2w_samecs(RW) 
+.equ               DENALI_CTL_35_DATA ,0b00000000000000000000000000000000 ##000_00000 ocd_adjust_pup_cs_0(RW) 000_00000 ocd_adjust_pdn_cs_0(RW) 00000_000 w2w_samecs_dly(RW) 00000_000 w2r_samecs_dly(RW) 
+.equ               DENALI_CTL_36_DATA ,0b00001111000011110000111100001111 ##0000_1111 ahb1_rdlen(RW) 0000_1111 ahb1_wrlen(RW) 0000_1111 ahb0_rdlen(RW) 0000_1111 ahb0_wrlen(RW) 
+.equ               DENALI_CTL_37_DATA ,0b00001111000011110000111100001111 ##0000_1111 ahb3_rdlen(RW) 0000_1111 ahb3_wrlen(RW) 0000_1111 ahb2_rdlen(RW) 0000_1111 ahb2_wrlen(RW) 
+.equ               DENALI_CTL_38_DATA ,0b00000000000000010000111100001111 ##0000000000000001 axi0_en_size_lt_width_instr(RW) 0000_1111 ahb4_rdlen(RW) 0000_1111 ahb4_wrlen(RW) 
+.equ               DENALI_CTL_39_DATA ,0b00000000000000000000001100000011 ##00000000000000_00 axi0_fifo_type_reg(RW) 00000_011 axi0_w_priority(RW) 00000_011 axi0_r_priority(RW) 
+.equ               DENALI_CTL_40_DATA ,0b00000011000000110000000000000001 ##00000_011 axi1_w_priority(RW) 00000_011 axi1_r_priority(RW) 0000000000000001 axi1_en_size_lt_width_instr(RW) 
+.equ               DENALI_CTL_41_DATA ,0b00000010000000000000000100000000 ##00000_010 axi2_r_priority(RW) 0000000000000001 axi2_en_size_lt_width_instr(RW) 000000_00 axi1_fifo_type_reg(RW) 
+.equ               DENALI_CTL_42_DATA ,0b00000000000000010000000000000010 ##0000000000000001 axi3_en_size_lt_width_instr(RW) 000000_00 axi2_fifo_type_reg(RW) 00000_010 axi2_w_priority(RW) 
+.equ               DENALI_CTL_43_DATA ,0b00000000000000000000001100000011 ##00000000000000_00 axi3_fifo_type_reg(RW) 00000_011 axi3_w_priority(RW) 00000_011 axi3_r_priority(RW) 
+.equ               DENALI_CTL_44_DATA ,0b00000011000000110000000000000001 ##00000_011 axi4_w_priority(RW) 00000_011 axi4_r_priority(RW) 0000000000000001 axi4_en_size_lt_width_instr(RW) 
+.equ               DENALI_CTL_45_DATA ,0b00000010000000000000000100000000 ##00000_010 axi5_r_priority(RW) 0000000000000001 axi5_en_size_lt_width_instr(RW) 000000_00 axi4_fifo_type_reg(RW) 
+.equ               DENALI_CTL_46_DATA ,0b00000000000000000000000000000010 ##00000_000 weighted_round_robin_weight_sharing(RW) 0000000_0 weighted_round_robin_latency_control(RW) 000000_00 axi5_fifo_type_reg(RW) 00000_010 axi5_w_priority(RW) 
+.equ               DENALI_CTL_47_DATA ,0b00000001000000010000000100000000 ##0000_0001 axi0_priority2_relative_priority(RW) 0000_0001 axi0_priority1_relative_priority(RW) 0000_0001 axi0_priority0_relative_priority(RW) 0000_0000 wrr_param_value_err(RD) 
+.equ               DENALI_CTL_48_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi0_priority6_relative_priority(RW) 0000_0001 axi0_priority5_relative_priority(RW) 0000_0001 axi0_priority4_relative_priority(RW) 0000_0001 axi0_priority3_relative_priority(RW) 
+.equ               DENALI_CTL_49_DATA ,0b00000000011001000000000000000001 ##000000_0001100100 axi0_priority_relax(RW) 00000_000 axi0_port_ordering(RW) 0000_0001 axi0_priority7_relative_priority(RW) 
+.equ               DENALI_CTL_50_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi1_priority3_relative_priority(RW) 0000_0001 axi1_priority2_relative_priority(RW) 0000_0001 axi1_priority1_relative_priority(RW) 0000_0001 axi1_priority0_relative_priority(RW) 
+.equ               DENALI_CTL_51_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi1_priority7_relative_priority(RW) 0000_0001 axi1_priority6_relative_priority(RW) 0000_0001 axi1_priority5_relative_priority(RW) 0000_0001 axi1_priority4_relative_priority(RW) 
+.equ               DENALI_CTL_52_DATA ,0b00000001000000000110010000000001 ##0000_0001 axi2_priority0_relative_priority(RW) 000000_0001100100 axi1_priority_relax(RW) 00000_001 axi1_port_ordering(RW) 
+.equ               DENALI_CTL_53_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi2_priority4_relative_priority(RW) 0000_0001 axi2_priority3_relative_priority(RW) 0000_0001 axi2_priority2_relative_priority(RW) 0000_0001 axi2_priority1_relative_priority(RW) 
+.equ               DENALI_CTL_54_DATA ,0b00000010000000010000000100000001 ##00000_010 axi2_port_ordering(RW) 0000_0001 axi2_priority7_relative_priority(RW) 0000_0001 axi2_priority6_relative_priority(RW) 0000_0001 axi2_priority5_relative_priority(RW) 
+.equ               DENALI_CTL_55_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi3_priority1_relative_priority(RW) 0000_0001 axi3_priority0_relative_priority(RW) 000000_0001100100 axi2_priority_relax(RW) 
+.equ               DENALI_CTL_56_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi3_priority5_relative_priority(RW) 0000_0001 axi3_priority4_relative_priority(RW) 0000_0001 axi3_priority3_relative_priority(RW) 0000_0001 axi3_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_57_DATA ,0b00000000000000110000000100000001 ##0000000000000_011 axi3_port_ordering(RW) 0000_0001 axi3_priority7_relative_priority(RW) 0000_0001 axi3_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_58_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi4_priority1_relative_priority(RW) 0000_0001 axi4_priority0_relative_priority(RW) 000000_0001100100 axi3_priority_relax(RW) 
+.equ               DENALI_CTL_59_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi4_priority5_relative_priority(RW) 0000_0001 axi4_priority4_relative_priority(RW) 0000_0001 axi4_priority3_relative_priority(RW) 0000_0001 axi4_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_60_DATA ,0b00000000000001000000000100000001 ##0000000000000_100 axi4_port_ordering(RW) 0000_0001 axi4_priority7_relative_priority(RW) 0000_0001 axi4_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_61_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi5_priority1_relative_priority(RW) 0000_0001 axi5_priority0_relative_priority(RW) 000000_0001100100 axi4_priority_relax(RW) 
+.equ               DENALI_CTL_62_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi5_priority5_relative_priority(RW) 0000_0001 axi5_priority4_relative_priority(RW) 0000_0001 axi5_priority3_relative_priority(RW) 0000_0001 axi5_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_63_DATA ,0b00000000000001010000000100000001 ##0000000000000_101 axi5_port_ordering(RW) 0000_0001 axi5_priority7_relative_priority(RW) 0000_0001 axi5_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_64_DATA ,0b00000000000000000000000001100100 ##000000000000000_0 cke_status(RD) 000000_0001100100 axi5_priority_relax(RW) 
+.equ               DENALI_CTL_65_DATA ,0b00000000000000000000000000000000 ##0000_0000 tdfi_phy_wrlat(RD) 00000000 dll_rst_adj_dly(RW) 0000000000000000 dll_rst_delay(RW) 
+.equ               DENALI_CTL_66_DATA ,0b00000000000000000000011000000000 ##0000000_0 dram_clk_disable(RW) 0000_0000 tdfi_rddata_en(RD) 0000_0110 tdfi_phy_rdlat(RW_D) 0_0000000 update_error_status(RD) 
+.equ               DENALI_CTL_67_DATA ,0b00000000000001001101100000000000 ##0000000000_00010011011000 tdfi_ctrlupd_max(RW) 0000_0000 tdfi_ctrlupd_min(RD) 
+.equ               DENALI_CTL_68_DATA ,0b00000010000000000000001000000000 ##0000001000000000 tdfi_phyupd_type1(RW) 0000001000000000 tdfi_phyupd_type0(RW) 
+.equ               DENALI_CTL_69_DATA ,0b00000010000000000000001000000000 ##0000001000000000 tdfi_phyupd_type3(RW) 0000001000000000 tdfi_phyupd_type2(RW) 
+.equ               DENALI_CTL_70_DATA ,0b00000000000000000000010011011000 ##000000000000000000_00010011011000 tdfi_phyupd_resp(RW) 
+.equ               DENALI_CTL_71_DATA ,0b00000000000000000001100000111000 ##00000000000000000001100000111000 tdfi_ctrlupd_interval(RW) 
+.equ               DENALI_CTL_72_DATA ,0b00000000000000100000001100000100 ##00000_000 tdfi_dram_clk_disable(RW) 0000_0010 tdfi_ctrl_delay(RW_D) 0000_0011 wrlat_adj(RW) 0000_0100 rdlat_adj(RW) 
+.equ               DENALI_CTL_73_DATA ,0b00000000000000000000000100000001 ##00000000000000000000000_1 odt_alt_en(RW) 0000_0001 tdfi_dram_clk_enable(RW) 
+
+/******************************************************************
+ * COPYRIGHT (c) 2000 Denali Software, Inc.  All rights reserved. *
+ * -------------------------------------------------------------- *
+ * This code is proprietary and confidential information of       *
+ * Denali Software. It may not be reproduced, used or transmitted *
+ * in any form whatsoever without the express and written         *
+ * permission of Denali Software.                                 *
+ ******************************************************************
+ ******************************************************************
+ *                                                                 
+ *   Module:         regconfig.h
+ *   Documentation:  Register programming header file
+ *
+ ******************************************************************
+ ******************************************************************/
+
+/*****************************************************************
+ * WARNING:  This file was automatically generated.  Manual
+ * editing may result in undetermined behavior, and may be in
+ * violation of the Denali Support Agreement.
+ *****************************************************************/
+
+
+
+## ********************************************************************
+## Option: IP Mode                      = PHY
+## Option: Burst Length                  = 4
+## Option: CAS Latency                   = 4
+## Option: Simulation MHz                = 170
+## Option: Auto Precharge Mode     (0/1) = 0
+## Option: DLL Bypass Mode         (0/1) = 0
+## Option: Half-Memory Support     (0/1) = 0
+## Option: Registered Dimm Support (0/1) = 0
+## Option: SYNCRONIOUS 0/1 = 0
+## ********************************************************************
+## Memory: k4t51163qj_f8.xml
+## ********************************************************************
+
+
+.equ               DENALI_PHY_00_DATA, 0b00000000000100010001000100000000 ##00000000000100010001000100000000 phy_pad_ctrl_reg_0(RW) 
+.equ               DENALI_PHY_01_DATA, 0b11110011000000010011101000100111 ##11110011000000010011101000100111 den_phy_ctrl_reg_0_0(RW) 
+.equ               DENALI_PHY_02_DATA, 0b00100100110000000000001011000000 ##00100100110000000000001011000000 den_phy_ctrl_reg_1_0(RW) 
+.equ               DENALI_PHY_03_DATA, 0b11110011000000010011101000100111 ##11110011000000010011101000100111 den_phy_ctrl_reg_0_1(RW) 
+.equ               DENALI_PHY_04_DATA, 0b00100100110000000000001011000000 ##00100100110000000000001011000000 den_phy_ctrl_reg_1_1(RW) 
+.equ               DENALI_PHY_05_DATA, 0b00000000000000000010101000000100 ##00000000000000000010101000000100 den_phy_ctrl_reg_2(RW) 
+.equ               DENALI_PHY_06_DATA, 0b10100000000010000001111001100100 ##00100000000010000001111001100100 phy_dll_ctrl_reg_0_0(RW) 
+.equ               DENALI_PHY_07_DATA, 0b00000001000010000001111100001110 ##00000001000010000001111100001110 phy_dll_ctrl_reg_1_0(RW) 
+.equ               DENALI_PHY_08_DATA, 0b10100000000010000001111001100100 ##00100000000010000001111001100100 phy_dll_ctrl_reg_0_1(RW) 
+.equ               DENALI_PHY_09_DATA, 0b00000001000010000001111100001110 ##00000001000010000001111100001110 phy_dll_ctrl_reg_1_1(RW) 
+.equ               DENALI_PHY_10_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 den_phy_obs_reg_0_0(RD) 
+.equ               DENALI_PHY_11_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_0_0(RD) 
+.equ               DENALI_PHY_12_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_1_0(RD) 
+.equ               DENALI_PHY_13_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 den_phy_obs_reg_0_1(RD) 
+.equ               DENALI_PHY_14_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_0_1(RD) 
+.equ               DENALI_PHY_15_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_1_1(RD) 
+#else ##ddr_clk_160
+
+/******************************************************************
+ * COPYRIGHT (c) 2000 Denali Software, Inc.  All rights reserved. *
+ * -------------------------------------------------------------- *
+ * This code is proprietary and confidential information of       *
+ * Denali Software. It may not be reproduced, used or transmitted *
+ * in any form whatsoever without the express and written         *
+ * permission of Denali Software.                                 *
+ ******************************************************************
+ ******************************************************************
+ *                                                                 
+ *   Module:         regconfig.h
+ *   Documentation:  Register programming header file
+ *
+ ******************************************************************
+ ******************************************************************/
+
+/*****************************************************************
+ * WARNING:  This file was automatically generated.  Manual
+ * editing may result in undetermined behavior, and may be in
+ * violation of the Denali Support Agreement.
+ *****************************************************************/
+
+
+
+## ********************************************************************
+## Option: IP Mode                      = CTL
+## Option: Burst Length                  = 4
+## Option: CAS Latency                   = 4
+## Option: Simulation MHz                = 250
+## Option: Auto Precharge Mode     (0/1) = 0
+## Option: DLL Bypass Mode         (0/1) = 0
+## Option: Half-Memory Support     (0/1) = 0
+## Option: Registered Dimm Support (0/1) = 0
+## Option: SYNCRONIOUS 0/1 = 1
+## ********************************************************************
+## Memory: k4t51163qj_f8.xml
+## ********************************************************************
+
+
+.equ               DENALI_CTL_00_DATA ,0b00000000000000000000010000000000 ##0000000000000000 version(RD) 0000_0100 dram_class(RW) 0000000_0 start(RW) 
+.equ               DENALI_CTL_01_DATA ,0b00000000000000000000000000000000 ##000000000000000_0 max_cs_reg(RD) 0000_0000 max_col_reg(RD) 0000_0000 max_row_reg(RD) 
+.equ               DENALI_CTL_02_DATA ,0b00000010000000000000000000110010 ##0000_0010 initaref(RW) 000000000000000000110010 tinit(RW) 
+.equ               DENALI_CTL_03_DATA ,0b00000010000000100000001100001000 ##000_00010 tccd(RW) 00000_010 tbst_int_interval(RW) 0000_0011 wrlat(RW) 0000_1000 caslat_lin(RW) 
+.equ               DENALI_CTL_04_DATA ,0b00000010000011000000111100000011 ##0000_0010 twtr(RW) 00001100 tras_min(RW) 00001111 trc(RW) 00000011 trrd(RW) 
+.equ               DENALI_CTL_05_DATA ,0b00000011000000100000001000000100 ##00000011 tmod(RW) 000_00010 tmrd(RW) 00000_010 trtp(RW) 0000_0100 trp(RW) 
+.equ               DENALI_CTL_06_DATA ,0b00000011000000110100010001011100 ##000_00011 tckesr(RW) 00000_011 tcke(RW) 0100010001011100 tras_max(RW) 
+.equ               DENALI_CTL_07_DATA ,0b00000001000000010000000000000000 ##0000000_1 tras_lockout(RW) 0000000_1 concurrentap(RW) 0000000_0 ap(RW) 0000000_0 writeinterp(RW) 
+.equ               DENALI_CTL_08_DATA ,0b00000000000010000000010000000100 ##00000000000_01000 tdal(RW) 000_00100 twr_int(RW) 00000100 trcd_int(RW) 
+.equ               DENALI_CTL_09_DATA ,0b00000010000000000000000011001000 ##00000_010 bstlen(RW_D) 0000000_0 no_cmd_init(RW) 0000000011001000 tdll(RW) 
+.equ               DENALI_CTL_10_DATA ,0b00000100000000000110010000001100 ##0000_0100 trp_ab(RW) 0000000001100100 tcpd(RW) 00_001100 tfaw(RW) 
+.equ               DENALI_CTL_11_DATA ,0b00000001000000000000000000000000 ##0000000_1 tref_enable(RW) 0000000_0 auto_refresh_mode(RW) 0000000_0 arefresh(WR) 0000000_0 reg_dimm_enable(RW) 
+.equ               DENALI_CTL_12_DATA ,0b00000111010010110000000000011011 ##00_00011101001011 tref(RW) 000000_0000011011 trfc(RW) 
+.equ               DENALI_CTL_13_DATA ,0b00000000000000110000000000000000 ##0000000000000011 tpdex(RW) 0000000_0 power_down(RW) 00000000
+.equ               DENALI_CTL_14_DATA ,0b00000000000111010000000011001000 ##0000000000011101 txsnr(RW) 0000000011001000 txsr(RW) 
+.equ               DENALI_CTL_15_DATA ,0b00000001000000000000000000000000 ##0000000_1 enable_quick_srefresh(RW) 0000000_0 srefresh_exit_no_refresh(RW) 0000000_0 pwrup_srefresh_exit(RW) 0000000_0 srefresh(RW+) 
+.equ               DENALI_CTL_16_DATA ,0b00000000000000000000000000000000 ##0000000000000000 lowpower_power_down_cnt(RW) 000_00000 lowpower_control(RW) 00000_000 cke_delay(RW) 
+.equ               DENALI_CTL_17_DATA ,0b00000000000000000000000000000000 ##0000000000000000 lowpower_external_cnt(RW) 0000000000000000 lowpower_self_refresh_cnt(RW) 
+.equ               DENALI_CTL_18_DATA ,0b00000000000000000000000000000000 ##0000000_0 lowpower_refresh_enable(RW) 0000000000000000 lowpower_internal_cnt(RW) 000_00000 lowpower_auto_enable(RW) 
+.equ               DENALI_CTL_19_DATA ,0b00000000000000000000001100000011 ##00000000000000000000_0011 cksrx(RW) 0000_0011 cksre(RW) 
+.equ               DENALI_CTL_20_DATA ,0b00000000000000000000000000000000 ##000000_00000000000000000000000000 write_modereg(RW+) 
+.equ               DENALI_CTL_21_DATA ,0b00000000000001100100001000000000 ##0000000000_00011001000010 mr0_data_0(RW) 00000000 mrw_status(RD) 
+.equ               DENALI_CTL_22_DATA ,0b00000000000000000000010001000010 ##00_00000000000000 mr2_data_0(RW) 00_00010001000000 mr1_data_0(RW) 
+.equ               DENALI_CTL_23_DATA ,0b00000000000000000000000000000000 ##00_00000000000000 mr3_data_0(RW) 00_00000000000000 mrsingle_data_0(RW) 
+.equ               DENALI_CTL_24_DATA ,0b00001010000000100000000100000000 ##0000_1010 aprebit(RW_D) 00000_010 column_size(RW) 00000_001 addr_pins(RW) 0000000_0 eight_bank_mode(RW) 
+.equ               DENALI_CTL_25_DATA ,0b00000001000000010000101000001010 ##0000000_1 bank_split_en(RW) 0000000_1 addr_cmp_en(RW) 000_01010 command_age_count(RW) 000_01010 age_count(RW) 
+.equ               DENALI_CTL_26_DATA ,0b00000001000000010000000100000001 ##0000000_1 swap_en(RW) 0000000_1 rw_same_en(RW) 0000000_1 priority_en(RW) 0000000_1 placement_en(RW) 
+.equ               DENALI_CTL_27_DATA ,0b00000000000000000000000000000000 ##00000_000 q_fullness(RW) 0000000_0 fast_write(RW) 0000000_0 reduc(RW) 0000000_0 inhibit_dram_cmd(RW) 
+.equ               DENALI_CTL_28_DATA ,0b00000000000000000000000100000000 ##0000_000000000000 int_status(RD) 0000000_1 resync_dll_per_aref_en(RW) 0000000_0 resync_dll(WR) 
+.equ               DENALI_CTL_29_DATA ,0b00000000000000000000000000000000 ##0000_000000000000 int_mask(RW) 00000_00000000000 int_ack(WR) 
+.equ               DENALI_CTL_30_DATA ,0b00000000000000000000000000000000 ##00_000000000000000000000000000000 out_of_range_addr(RD) 
+.equ               DENALI_CTL_31_DATA ,0b00000000000000000000000000000000 ##000000000_0000000 out_of_range_source_id(RD) 00_000000 out_of_range_type(RD) 00_000000 out_of_range_length(RD) 
+.equ               DENALI_CTL_32_DATA ,0b00000000000000000000000000000000 ##00_000000000000000000000000000000 port_cmd_error_addr(RD) 
+.equ               DENALI_CTL_33_DATA ,0b00000000000000000000000000000000 ##00000_000 port_data_error_type(RD) 0_0000000 port_data_error_id(RD) 0000_0000 port_cmd_error_type(RD) 0_0000000 port_cmd_error_id(RD) 
+.equ               DENALI_CTL_34_DATA ,0b00000001000000000000000000000000 ##00000_001 r2w_samecs_dly(RW) 00000_000 r2r_samecs_dly(RW) 0000_0000 add_odt_clk_w2r_samecs(RW) 0000_0000 add_odt_clk_r2w_samecs(RW) 
+.equ               DENALI_CTL_35_DATA ,0b00000000000000000000000000000000 ##000_00000 ocd_adjust_pup_cs_0(RW) 000_00000 ocd_adjust_pdn_cs_0(RW) 00000_000 w2w_samecs_dly(RW) 00000_000 w2r_samecs_dly(RW) 
+.equ               DENALI_CTL_36_DATA ,0b00001111000011110000111100001111 ##0000_1111 ahb1_rdlen(RW) 0000_1111 ahb1_wrlen(RW) 0000_1111 ahb0_rdlen(RW) 0000_1111 ahb0_wrlen(RW) 
+.equ               DENALI_CTL_37_DATA ,0b00001111000011110000111100001111 ##0000_1111 ahb3_rdlen(RW) 0000_1111 ahb3_wrlen(RW) 0000_1111 ahb2_rdlen(RW) 0000_1111 ahb2_wrlen(RW) 
+.equ               DENALI_CTL_38_DATA ,0b00000000000000010000111100001111 ##0000000000000001 axi0_en_size_lt_width_instr(RW) 0000_1111 ahb4_rdlen(RW) 0000_1111 ahb4_wrlen(RW) 
+.equ               DENALI_CTL_39_DATA ,0b00000000000000110000001100000011 ##00000000000000_11 axi0_fifo_type_reg(RW) 00000_011 axi0_w_priority(RW) 00000_011 axi0_r_priority(RW) 
+.equ               DENALI_CTL_40_DATA ,0b00000011000000110000000000000001 ##00000_011 axi1_w_priority(RW) 00000_011 axi1_r_priority(RW) 0000000000000001 axi1_en_size_lt_width_instr(RW) 
+.equ               DENALI_CTL_41_DATA ,0b00000010000000000000000100000011 ##00000_010 axi2_r_priority(RW) 0000000000000001 axi2_en_size_lt_width_instr(RW) 000000_11 axi1_fifo_type_reg(RW) 
+.equ               DENALI_CTL_42_DATA ,0b00000000000000010000001100000010 ##0000000000000001 axi3_en_size_lt_width_instr(RW) 000000_11 axi2_fifo_type_reg(RW) 00000_010 axi2_w_priority(RW) 
+.equ               DENALI_CTL_43_DATA ,0b00000000000000110000001100000011 ##00000000000000_11 axi3_fifo_type_reg(RW) 00000_011 axi3_w_priority(RW) 00000_011 axi3_r_priority(RW) 
+.equ               DENALI_CTL_44_DATA ,0b00000011000000110000000000000001 ##00000_011 axi4_w_priority(RW) 00000_011 axi4_r_priority(RW) 0000000000000001 axi4_en_size_lt_width_instr(RW) 
+.equ               DENALI_CTL_45_DATA ,0b00000010000000000000000100000011 ##00000_010 axi5_r_priority(RW) 0000000000000001 axi5_en_size_lt_width_instr(RW) 000000_11 axi4_fifo_type_reg(RW) 
+.equ               DENALI_CTL_46_DATA ,0b00000000000000000000001100000010 ##00000_000 weighted_round_robin_weight_sharing(RW) 0000000_0 weighted_round_robin_latency_control(RW) 000000_11 axi5_fifo_type_reg(RW) 00000_010 axi5_w_priority(RW) 
+.equ               DENALI_CTL_47_DATA ,0b00000001000000010000000100000000 ##0000_0001 axi0_priority2_relative_priority(RW) 0000_0001 axi0_priority1_relative_priority(RW) 0000_0001 axi0_priority0_relative_priority(RW) 0000_0000 wrr_param_value_err(RD) 
+.equ               DENALI_CTL_48_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi0_priority6_relative_priority(RW) 0000_0001 axi0_priority5_relative_priority(RW) 0000_0001 axi0_priority4_relative_priority(RW) 0000_0001 axi0_priority3_relative_priority(RW) 
+.equ               DENALI_CTL_49_DATA ,0b00000000011001000000000000000001 ##000000_0001100100 axi0_priority_relax(RW) 00000_000 axi0_port_ordering(RW) 0000_0001 axi0_priority7_relative_priority(RW) 
+.equ               DENALI_CTL_50_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi1_priority3_relative_priority(RW) 0000_0001 axi1_priority2_relative_priority(RW) 0000_0001 axi1_priority1_relative_priority(RW) 0000_0001 axi1_priority0_relative_priority(RW) 
+.equ               DENALI_CTL_51_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi1_priority7_relative_priority(RW) 0000_0001 axi1_priority6_relative_priority(RW) 0000_0001 axi1_priority5_relative_priority(RW) 0000_0001 axi1_priority4_relative_priority(RW) 
+.equ               DENALI_CTL_52_DATA ,0b00000001000000000110010000000001 ##0000_0001 axi2_priority0_relative_priority(RW) 000000_0001100100 axi1_priority_relax(RW) 00000_001 axi1_port_ordering(RW) 
+.equ               DENALI_CTL_53_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi2_priority4_relative_priority(RW) 0000_0001 axi2_priority3_relative_priority(RW) 0000_0001 axi2_priority2_relative_priority(RW) 0000_0001 axi2_priority1_relative_priority(RW) 
+.equ               DENALI_CTL_54_DATA ,0b00000010000000010000000100000001 ##00000_010 axi2_port_ordering(RW) 0000_0001 axi2_priority7_relative_priority(RW) 0000_0001 axi2_priority6_relative_priority(RW) 0000_0001 axi2_priority5_relative_priority(RW) 
+.equ               DENALI_CTL_55_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi3_priority1_relative_priority(RW) 0000_0001 axi3_priority0_relative_priority(RW) 000000_0001100100 axi2_priority_relax(RW) 
+.equ               DENALI_CTL_56_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi3_priority5_relative_priority(RW) 0000_0001 axi3_priority4_relative_priority(RW) 0000_0001 axi3_priority3_relative_priority(RW) 0000_0001 axi3_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_57_DATA ,0b00000000000000110000000100000001 ##0000000000000_011 axi3_port_ordering(RW) 0000_0001 axi3_priority7_relative_priority(RW) 0000_0001 axi3_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_58_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi4_priority1_relative_priority(RW) 0000_0001 axi4_priority0_relative_priority(RW) 000000_0001100100 axi3_priority_relax(RW) 
+.equ               DENALI_CTL_59_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi4_priority5_relative_priority(RW) 0000_0001 axi4_priority4_relative_priority(RW) 0000_0001 axi4_priority3_relative_priority(RW) 0000_0001 axi4_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_60_DATA ,0b00000000000001000000000100000001 ##0000000000000_100 axi4_port_ordering(RW) 0000_0001 axi4_priority7_relative_priority(RW) 0000_0001 axi4_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_61_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi5_priority1_relative_priority(RW) 0000_0001 axi5_priority0_relative_priority(RW) 000000_0001100100 axi4_priority_relax(RW) 
+.equ               DENALI_CTL_62_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi5_priority5_relative_priority(RW) 0000_0001 axi5_priority4_relative_priority(RW) 0000_0001 axi5_priority3_relative_priority(RW) 0000_0001 axi5_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_63_DATA ,0b00000000000001010000000100000001 ##0000000000000_101 axi5_port_ordering(RW) 0000_0001 axi5_priority7_relative_priority(RW) 0000_0001 axi5_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_64_DATA ,0b00000000000000000000000001100100 ##000000000000000_0 cke_status(RD) 000000_0001100100 axi5_priority_relax(RW) 
+.equ               DENALI_CTL_65_DATA ,0b00000000000000000000000000000000 ##0000_0000 tdfi_phy_wrlat(RD) 00000000 dll_rst_adj_dly(RW) 0000000000000000 dll_rst_delay(RW) 
+.equ               DENALI_CTL_66_DATA ,0b00000000000000000000011100000000 ##0000000_0 dram_clk_disable(RW) 0000_0000 tdfi_rddata_en(RD) 0000_0111 tdfi_phy_rdlat(RW_D) 0_0000000 update_error_status(RD) 
+.equ               DENALI_CTL_67_DATA ,0b00000000000001110100101100000000 ##0000000000_00011101001011 tdfi_ctrlupd_max(RW) 0000_0000 tdfi_ctrlupd_min(RD) 
+.equ               DENALI_CTL_68_DATA ,0b00000010000000000000001000000000 ##0000001000000000 tdfi_phyupd_type1(RW) 0000001000000000 tdfi_phyupd_type0(RW) 
+.equ               DENALI_CTL_69_DATA ,0b00000010000000000000001000000000 ##0000001000000000 tdfi_phyupd_type3(RW) 0000001000000000 tdfi_phyupd_type2(RW) 
+.equ               DENALI_CTL_70_DATA ,0b00000000000000000000011101001011 ##000000000000000000_00011101001011 tdfi_phyupd_resp(RW) 
+.equ               DENALI_CTL_71_DATA ,0b00000000000000000010010001110111 ##00000000000000000010010001110111 tdfi_ctrlupd_interval(RW) 
+.equ               DENALI_CTL_72_DATA ,0b00000000000000100000001100000100 ##00000_000 tdfi_dram_clk_disable(RW) 0000_0010 tdfi_ctrl_delay(RW_D) 0000_0011 wrlat_adj(RW) 0000_0100 rdlat_adj(RW) 
+.equ               DENALI_CTL_73_DATA ,0b00000000000000000000000100000001 ##00000000000000000000000_1 odt_alt_en(RW) 0000_0001 tdfi_dram_clk_enable(RW) 
+
+/******************************************************************
+ * COPYRIGHT (c) 2000 Denali Software, Inc.  All rights reserved. *
+ * -------------------------------------------------------------- *
+ * This code is proprietary and confidential information of       *
+ * Denali Software. It may not be reproduced, used or transmitted *
+ * in any form whatsoever without the express and written         *
+ * permission of Denali Software.                                 *
+ ******************************************************************
+ ******************************************************************
+ *                                                                 
+ *   Module:         regconfig.h
+ *   Documentation:  Register programming header file
+ *
+ ******************************************************************
+ ******************************************************************/
+
+/*****************************************************************
+ * WARNING:  This file was automatically generated.  Manual
+ * editing may result in undetermined behavior, and may be in
+ * violation of the Denali Support Agreement.
+ *****************************************************************/
+
+
+
+## ********************************************************************
+## Option: IP Mode                      = PHY
+## Option: Burst Length                  = 4
+## Option: CAS Latency                   = 4
+## Option: Simulation MHz                = 250
+## Option: Auto Precharge Mode     (0/1) = 0
+## Option: DLL Bypass Mode         (0/1) = 0
+## Option: Half-Memory Support     (0/1) = 0
+## Option: Registered Dimm Support (0/1) = 0
+## Option: SYNCRONIOUS 0/1 = 1
+## ********************************************************************
+## Memory: k4t51163qj_f8.xml
+## ********************************************************************
+
+
+.equ               DENALI_PHY_00_DATA, 0b00000000000100010001000100000000 ##00000000000100010001000100000000 phy_pad_ctrl_reg_0(RW) 
+.equ               DENALI_PHY_01_DATA, 0b11110100000000010100101100110111 ##11110100000000010100101100110111 den_phy_ctrl_reg_0_0(RW) 
+.equ               DENALI_PHY_02_DATA, 0b00100100110000000000001011000000 ##00100100110000000000001011000000 den_phy_ctrl_reg_1_0(RW) 
+.equ               DENALI_PHY_03_DATA, 0b11110100000000010100101100110111 ##11110100000000010100101100110111 den_phy_ctrl_reg_0_1(RW) 
+.equ               DENALI_PHY_04_DATA, 0b00100100110000000000001011000000 ##00100100110000000000001011000000 den_phy_ctrl_reg_1_1(RW) 
+.equ               DENALI_PHY_05_DATA, 0b00000000000000000010101000000101 ##00000000000000000010101000000101 den_phy_ctrl_reg_2(RW) 
+.equ               DENALI_PHY_06_DATA, 0b01100000000001010001111001000100 ##00100000000001010001111001000100 phy_dll_ctrl_reg_0_0(RW) 
+.equ               DENALI_PHY_07_DATA, 0b00000001000001010001111100001001 ##00000001000001010001111100001001 phy_dll_ctrl_reg_1_0(RW) 
+.equ               DENALI_PHY_08_DATA, 0b01100000000001010001111001000100 ##00100000000001010001111001000100 phy_dll_ctrl_reg_0_1(RW) 
+.equ               DENALI_PHY_09_DATA, 0b00000001000001010001111100001001 ##00000001000001010001111100001001 phy_dll_ctrl_reg_1_1(RW) 
+.equ               DENALI_PHY_10_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 den_phy_obs_reg_0_0(RD) 
+.equ               DENALI_PHY_11_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_0_0(RD) 
+.equ               DENALI_PHY_12_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_1_0(RD) 
+.equ               DENALI_PHY_13_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 den_phy_obs_reg_0_1(RD) 
+.equ               DENALI_PHY_14_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_0_1(RD) 
+.equ               DENALI_PHY_15_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_1_1(RD) 
+#endif ##ddr_clk_160
+#else  ##k4t51163qj_f8
+#ifdef ddr_clk_160
+
+/******************************************************************
+ * COPYRIGHT (c) 2000 Denali Software, Inc.  All rights reserved. *
+ * -------------------------------------------------------------- *
+ * This code is proprietary and confidential information of       *
+ * Denali Software. It may not be reproduced, used or transmitted *
+ * in any form whatsoever without the express and written         *
+ * permission of Denali Software.                                 *
+ ******************************************************************
+ ******************************************************************
+ *                                                                 
+ *   Module:         regconfig.h
+ *   Documentation:  Register programming header file
+ *
+ ******************************************************************
+ ******************************************************************/
+
+/*****************************************************************
+ * WARNING:  This file was automatically generated.  Manual
+ * editing may result in undetermined behavior, and may be in
+ * violation of the Denali Support Agreement.
+ *****************************************************************/
+
+
+
+## ********************************************************************
+## Option: IP Mode                      = CTL
+## Option: Burst Length                  = 4
+## Option: CAS Latency                   = 4
+## Option: Simulation MHz                = 170
+## Option: Auto Precharge Mode     (0/1) = 0
+## Option: DLL Bypass Mode         (0/1) = 0
+## Option: Half-Memory Support     (0/1) = 0
+## Option: Registered Dimm Support (0/1) = 0
+## Option: SYNCRONIOUS 0/1 = 0
+## ********************************************************************
+## Memory: mt47h32m16_25e.xml
+## ********************************************************************
+
+
+.equ               DENALI_CTL_00_DATA ,0b00000000000000000000010000000000 ##0000000000000000 version(RD) 0000_0100 dram_class(RW) 0000000_0 start(RW) 
+.equ               DENALI_CTL_01_DATA ,0b00000000000000000000000000000000 ##000000000000000_0 max_cs_reg(RD) 0000_0000 max_col_reg(RD) 0000_0000 max_row_reg(RD) 
+.equ               DENALI_CTL_02_DATA ,0b00000010000000000000000000100010 ##0000_0010 initaref(RW) 000000000000000000100010 tinit(RW) 
+.equ               DENALI_CTL_03_DATA ,0b00000010000000100000001100001000 ##000_00010 tccd(RW) 00000_010 tbst_int_interval(RW) 0000_0011 wrlat(RW) 0000_1000 caslat_lin(RW) 
+.equ               DENALI_CTL_04_DATA ,0b00000010000010000000101000000010 ##0000_0010 twtr(RW) 00001000 tras_min(RW) 00001010 trc(RW) 00000010 trrd(RW) 
+.equ               DENALI_CTL_05_DATA ,0b00000011000000100000001000000011 ##00000011 tmod(RW) 000_00010 tmrd(RW) 00000_010 trtp(RW) 0000_0011 trp(RW) 
+.equ               DENALI_CTL_06_DATA ,0b00000011000000110010111001101101 ##000_00011 tckesr(RW) 00000_011 tcke(RW) 0010111001101101 tras_max(RW) 
+.equ               DENALI_CTL_07_DATA ,0b00000001000000010000000000000000 ##0000000_1 tras_lockout(RW) 0000000_1 concurrentap(RW) 0000000_0 ap(RW) 0000000_0 writeinterp(RW) 
+.equ               DENALI_CTL_08_DATA ,0b00000000000001100000001100000011 ##00000000000_00110 tdal(RW) 000_00011 twr_int(RW) 00000011 trcd_int(RW) 
+.equ               DENALI_CTL_09_DATA ,0b00000010000000000000000011001000 ##00000_010 bstlen(RW_D) 0000000_0 no_cmd_init(RW) 0000000011001000 tdll(RW) 
+.equ               DENALI_CTL_10_DATA ,0b00000011000000000100010000000000 ##0000_0011 trp_ab(RW) 0000000001000100 tcpd(RW) 00_000000 tfaw(RW) 
+.equ               DENALI_CTL_11_DATA ,0b00000001000000000000000000000000 ##0000000_1 tref_enable(RW) 0000000_0 auto_refresh_mode(RW) 0000000_0 arefresh(WR) 0000000_0 reg_dimm_enable(RW) 
+.equ               DENALI_CTL_12_DATA ,0b00000100110110000000000000010010 ##00_00010011011000 tref(RW) 000000_0000010010 trfc(RW) 
+.equ               DENALI_CTL_13_DATA ,0b00000000000000100000000000000000 ##0000000000000010 tpdex(RW) 0000000_0 power_down(RW) 00000000
+.equ               DENALI_CTL_14_DATA ,0b00000000000101000000000011001000 ##0000000000010100 txsnr(RW) 0000000011001000 txsr(RW) 
+.equ               DENALI_CTL_15_DATA ,0b00000001000000000000000000000000 ##0000000_1 enable_quick_srefresh(RW) 0000000_0 srefresh_exit_no_refresh(RW) 0000000_0 pwrup_srefresh_exit(RW) 0000000_0 srefresh(RW+) 
+.equ               DENALI_CTL_16_DATA ,0b00000000000000000000000000000000 ##0000000000000000 lowpower_power_down_cnt(RW) 000_00000 lowpower_control(RW) 00000_000 cke_delay(RW) 
+.equ               DENALI_CTL_17_DATA ,0b00000000000000000000000000000000 ##0000000000000000 lowpower_external_cnt(RW) 0000000000000000 lowpower_self_refresh_cnt(RW) 
+.equ               DENALI_CTL_18_DATA ,0b00000000000000000000000000000000 ##0000000_0 lowpower_refresh_enable(RW) 0000000000000000 lowpower_internal_cnt(RW) 000_00000 lowpower_auto_enable(RW) 
+.equ               DENALI_CTL_19_DATA ,0b00000000000000000000001100000011 ##00000000000000000000_0011 cksrx(RW) 0000_0011 cksre(RW) 
+.equ               DENALI_CTL_20_DATA ,0b00000000000000000000000000000000 ##000000_00000000000000000000000000 write_modereg(RW+) 
+.equ               DENALI_CTL_21_DATA ,0b00000000000001000100001000000000 ##0000000000_00010001000010 mr0_data_0(RW) 00000000 mrw_status(RD) 
+.equ               DENALI_CTL_22_DATA ,0b00000000000000000000010001000000 ##00_00000000000000 mr2_data_0(RW) 00_00010001000000 mr1_data_0(RW) 
+.equ               DENALI_CTL_23_DATA ,0b00000000000000000000000000000000 ##00_00000000000000 mr3_data_0(RW) 00_00000000000000 mrsingle_data_0(RW) 
+.equ               DENALI_CTL_24_DATA ,0b00001010000000100000000100000000 ##0000_1010 aprebit(RW_D) 00000_010 column_size(RW) 00000_001 addr_pins(RW) 0000000_0 eight_bank_mode(RW) 
+.equ               DENALI_CTL_25_DATA ,0b00000001000000010000101000001010 ##0000000_1 bank_split_en(RW) 0000000_1 addr_cmp_en(RW) 000_01010 command_age_count(RW) 000_01010 age_count(RW) 
+.equ               DENALI_CTL_26_DATA ,0b00000001000000010000000100000001 ##0000000_1 swap_en(RW) 0000000_1 rw_same_en(RW) 0000000_1 priority_en(RW) 0000000_1 placement_en(RW) 
+.equ               DENALI_CTL_27_DATA ,0b00000000000000000000000000000000 ##00000_000 q_fullness(RW) 0000000_0 fast_write(RW) 0000000_0 reduc(RW) 0000000_0 inhibit_dram_cmd(RW) 
+.equ               DENALI_CTL_28_DATA ,0b00000000000000000000000100000000 ##0000_000000000000 int_status(RD) 0000000_1 resync_dll_per_aref_en(RW) 0000000_0 resync_dll(WR) 
+.equ               DENALI_CTL_29_DATA ,0b00000000000000000000000000000000 ##0000_000000000000 int_mask(RW) 00000_00000000000 int_ack(WR) 
+.equ               DENALI_CTL_30_DATA ,0b00000000000000000000000000000000 ##00_000000000000000000000000000000 out_of_range_addr(RD) 
+.equ               DENALI_CTL_31_DATA ,0b00000000000000000000000000000000 ##000000000_0000000 out_of_range_source_id(RD) 00_000000 out_of_range_type(RD) 00_000000 out_of_range_length(RD) 
+.equ               DENALI_CTL_32_DATA ,0b00000000000000000000000000000000 ##00_000000000000000000000000000000 port_cmd_error_addr(RD) 
+.equ               DENALI_CTL_33_DATA ,0b00000000000000000000000000000000 ##00000_000 port_data_error_type(RD) 0_0000000 port_data_error_id(RD) 0000_0000 port_cmd_error_type(RD) 0_0000000 port_cmd_error_id(RD) 
+.equ               DENALI_CTL_34_DATA ,0b00000001000000000000000000000000 ##00000_001 r2w_samecs_dly(RW) 00000_000 r2r_samecs_dly(RW) 0000_0000 add_odt_clk_w2r_samecs(RW) 0000_0000 add_odt_clk_r2w_samecs(RW) 
+.equ               DENALI_CTL_35_DATA ,0b00000000000000000000000000000000 ##000_00000 ocd_adjust_pup_cs_0(RW) 000_00000 ocd_adjust_pdn_cs_0(RW) 00000_000 w2w_samecs_dly(RW) 00000_000 w2r_samecs_dly(RW) 
+.equ               DENALI_CTL_36_DATA ,0b00001111000011110000111100001111 ##0000_1111 ahb1_rdlen(RW) 0000_1111 ahb1_wrlen(RW) 0000_1111 ahb0_rdlen(RW) 0000_1111 ahb0_wrlen(RW) 
+.equ               DENALI_CTL_37_DATA ,0b00001111000011110000111100001111 ##0000_1111 ahb3_rdlen(RW) 0000_1111 ahb3_wrlen(RW) 0000_1111 ahb2_rdlen(RW) 0000_1111 ahb2_wrlen(RW) 
+.equ               DENALI_CTL_38_DATA ,0b00000000000000010000111100001111 ##0000000000000001 axi0_en_size_lt_width_instr(RW) 0000_1111 ahb4_rdlen(RW) 0000_1111 ahb4_wrlen(RW) 
+.equ               DENALI_CTL_39_DATA ,0b00000000000000000000001100000011 ##00000000000000_00 axi0_fifo_type_reg(RW) 00000_011 axi0_w_priority(RW) 00000_011 axi0_r_priority(RW) 
+.equ               DENALI_CTL_40_DATA ,0b00000011000000110000000000000001 ##00000_011 axi1_w_priority(RW) 00000_011 axi1_r_priority(RW) 0000000000000001 axi1_en_size_lt_width_instr(RW) 
+.equ               DENALI_CTL_41_DATA ,0b00000010000000000000000100000000 ##00000_010 axi2_r_priority(RW) 0000000000000001 axi2_en_size_lt_width_instr(RW) 000000_00 axi1_fifo_type_reg(RW) 
+.equ               DENALI_CTL_42_DATA ,0b00000000000000010000000000000010 ##0000000000000001 axi3_en_size_lt_width_instr(RW) 000000_00 axi2_fifo_type_reg(RW) 00000_010 axi2_w_priority(RW) 
+.equ               DENALI_CTL_43_DATA ,0b00000000000000000000001100000011 ##00000000000000_00 axi3_fifo_type_reg(RW) 00000_011 axi3_w_priority(RW) 00000_011 axi3_r_priority(RW) 
+.equ               DENALI_CTL_44_DATA ,0b00000011000000110000000000000001 ##00000_011 axi4_w_priority(RW) 00000_011 axi4_r_priority(RW) 0000000000000001 axi4_en_size_lt_width_instr(RW) 
+.equ               DENALI_CTL_45_DATA ,0b00000010000000000000000100000000 ##00000_010 axi5_r_priority(RW) 0000000000000001 axi5_en_size_lt_width_instr(RW) 000000_00 axi4_fifo_type_reg(RW) 
+.equ               DENALI_CTL_46_DATA ,0b00000000000000000000000000000010 ##00000_000 weighted_round_robin_weight_sharing(RW) 0000000_0 weighted_round_robin_latency_control(RW) 000000_00 axi5_fifo_type_reg(RW) 00000_010 axi5_w_priority(RW) 
+.equ               DENALI_CTL_47_DATA ,0b00000001000000010000000100000000 ##0000_0001 axi0_priority2_relative_priority(RW) 0000_0001 axi0_priority1_relative_priority(RW) 0000_0001 axi0_priority0_relative_priority(RW) 0000_0000 wrr_param_value_err(RD) 
+.equ               DENALI_CTL_48_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi0_priority6_relative_priority(RW) 0000_0001 axi0_priority5_relative_priority(RW) 0000_0001 axi0_priority4_relative_priority(RW) 0000_0001 axi0_priority3_relative_priority(RW) 
+.equ               DENALI_CTL_49_DATA ,0b00000000011001000000000000000001 ##000000_0001100100 axi0_priority_relax(RW) 00000_000 axi0_port_ordering(RW) 0000_0001 axi0_priority7_relative_priority(RW) 
+.equ               DENALI_CTL_50_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi1_priority3_relative_priority(RW) 0000_0001 axi1_priority2_relative_priority(RW) 0000_0001 axi1_priority1_relative_priority(RW) 0000_0001 axi1_priority0_relative_priority(RW) 
+.equ               DENALI_CTL_51_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi1_priority7_relative_priority(RW) 0000_0001 axi1_priority6_relative_priority(RW) 0000_0001 axi1_priority5_relative_priority(RW) 0000_0001 axi1_priority4_relative_priority(RW) 
+.equ               DENALI_CTL_52_DATA ,0b00000001000000000110010000000001 ##0000_0001 axi2_priority0_relative_priority(RW) 000000_0001100100 axi1_priority_relax(RW) 00000_001 axi1_port_ordering(RW) 
+.equ               DENALI_CTL_53_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi2_priority4_relative_priority(RW) 0000_0001 axi2_priority3_relative_priority(RW) 0000_0001 axi2_priority2_relative_priority(RW) 0000_0001 axi2_priority1_relative_priority(RW) 
+.equ               DENALI_CTL_54_DATA ,0b00000010000000010000000100000001 ##00000_010 axi2_port_ordering(RW) 0000_0001 axi2_priority7_relative_priority(RW) 0000_0001 axi2_priority6_relative_priority(RW) 0000_0001 axi2_priority5_relative_priority(RW) 
+.equ               DENALI_CTL_55_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi3_priority1_relative_priority(RW) 0000_0001 axi3_priority0_relative_priority(RW) 000000_0001100100 axi2_priority_relax(RW) 
+.equ               DENALI_CTL_56_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi3_priority5_relative_priority(RW) 0000_0001 axi3_priority4_relative_priority(RW) 0000_0001 axi3_priority3_relative_priority(RW) 0000_0001 axi3_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_57_DATA ,0b00000000000000110000000100000001 ##0000000000000_011 axi3_port_ordering(RW) 0000_0001 axi3_priority7_relative_priority(RW) 0000_0001 axi3_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_58_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi4_priority1_relative_priority(RW) 0000_0001 axi4_priority0_relative_priority(RW) 000000_0001100100 axi3_priority_relax(RW) 
+.equ               DENALI_CTL_59_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi4_priority5_relative_priority(RW) 0000_0001 axi4_priority4_relative_priority(RW) 0000_0001 axi4_priority3_relative_priority(RW) 0000_0001 axi4_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_60_DATA ,0b00000000000001000000000100000001 ##0000000000000_100 axi4_port_ordering(RW) 0000_0001 axi4_priority7_relative_priority(RW) 0000_0001 axi4_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_61_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi5_priority1_relative_priority(RW) 0000_0001 axi5_priority0_relative_priority(RW) 000000_0001100100 axi4_priority_relax(RW) 
+.equ               DENALI_CTL_62_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi5_priority5_relative_priority(RW) 0000_0001 axi5_priority4_relative_priority(RW) 0000_0001 axi5_priority3_relative_priority(RW) 0000_0001 axi5_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_63_DATA ,0b00000000000001010000000100000001 ##0000000000000_101 axi5_port_ordering(RW) 0000_0001 axi5_priority7_relative_priority(RW) 0000_0001 axi5_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_64_DATA ,0b00000000000000000000000001100100 ##000000000000000_0 cke_status(RD) 000000_0001100100 axi5_priority_relax(RW) 
+.equ               DENALI_CTL_65_DATA ,0b00000000000000000000000000000000 ##0000_0000 tdfi_phy_wrlat(RD) 00000000 dll_rst_adj_dly(RW) 0000000000000000 dll_rst_delay(RW) 
+.equ               DENALI_CTL_66_DATA ,0b00000000000000000000011000000000 ##0000000_0 dram_clk_disable(RW) 0000_0000 tdfi_rddata_en(RD) 0000_0110 tdfi_phy_rdlat(RW_D) 0_0000000 update_error_status(RD) 
+.equ               DENALI_CTL_67_DATA ,0b00000000000001001101100000000000 ##0000000000_00010011011000 tdfi_ctrlupd_max(RW) 0000_0000 tdfi_ctrlupd_min(RD) 
+.equ               DENALI_CTL_68_DATA ,0b00000010000000000000001000000000 ##0000001000000000 tdfi_phyupd_type1(RW) 0000001000000000 tdfi_phyupd_type0(RW) 
+.equ               DENALI_CTL_69_DATA ,0b00000010000000000000001000000000 ##0000001000000000 tdfi_phyupd_type3(RW) 0000001000000000 tdfi_phyupd_type2(RW) 
+.equ               DENALI_CTL_70_DATA ,0b00000000000000000000010011011000 ##000000000000000000_00010011011000 tdfi_phyupd_resp(RW) 
+.equ               DENALI_CTL_71_DATA ,0b00000000000000000001100000111000 ##00000000000000000001100000111000 tdfi_ctrlupd_interval(RW) 
+.equ               DENALI_CTL_72_DATA ,0b00000000000000100000001100000100 ##00000_000 tdfi_dram_clk_disable(RW) 0000_0010 tdfi_ctrl_delay(RW_D) 0000_0011 wrlat_adj(RW) 0000_0100 rdlat_adj(RW) 
+.equ               DENALI_CTL_73_DATA ,0b00000000000000000000000100000001 ##00000000000000000000000_1 odt_alt_en(RW) 0000_0001 tdfi_dram_clk_enable(RW) 
+
+/******************************************************************
+ * COPYRIGHT (c) 2000 Denali Software, Inc.  All rights reserved. *
+ * -------------------------------------------------------------- *
+ * This code is proprietary and confidential information of       *
+ * Denali Software. It may not be reproduced, used or transmitted *
+ * in any form whatsoever without the express and written         *
+ * permission of Denali Software.                                 *
+ ******************************************************************
+ ******************************************************************
+ *                                                                 
+ *   Module:         regconfig.h
+ *   Documentation:  Register programming header file
+ *
+ ******************************************************************
+ ******************************************************************/
+
+/*****************************************************************
+ * WARNING:  This file was automatically generated.  Manual
+ * editing may result in undetermined behavior, and may be in
+ * violation of the Denali Support Agreement.
+ *****************************************************************/
+
+
+
+## ********************************************************************
+## Option: IP Mode                      = PHY
+## Option: Burst Length                  = 4
+## Option: CAS Latency                   = 4
+## Option: Simulation MHz                = 170
+## Option: Auto Precharge Mode     (0/1) = 0
+## Option: DLL Bypass Mode         (0/1) = 0
+## Option: Half-Memory Support     (0/1) = 0
+## Option: Registered Dimm Support (0/1) = 0
+## Option: SYNCRONIOUS 0/1 = 0
+## ********************************************************************
+## Memory: mt47h32m16_25e.xml
+## ********************************************************************
+
+
+.equ               DENALI_PHY_00_DATA, 0b00000000000100010001000100000000 ##00000000000100010001000100000000 phy_pad_ctrl_reg_0(RW) 
+.equ               DENALI_PHY_01_DATA, 0b11110011000000010011101000100111 ##11110011000000010011101000100111 den_phy_ctrl_reg_0_0(RW) 
+.equ               DENALI_PHY_02_DATA, 0b00100100110000000000001011000000 ##00100100110000000000001011000000 den_phy_ctrl_reg_1_0(RW) 
+.equ               DENALI_PHY_03_DATA, 0b11110011000000010011101000100111 ##11110011000000010011101000100111 den_phy_ctrl_reg_0_1(RW) 
+.equ               DENALI_PHY_04_DATA, 0b00100100110000000000001011000000 ##00100100110000000000001011000000 den_phy_ctrl_reg_1_1(RW) 
+.equ               DENALI_PHY_05_DATA, 0b00000000000000000010101000000100 ##00000000000000000010101000000100 den_phy_ctrl_reg_2(RW) 
+.equ               DENALI_PHY_06_DATA, 0b00100000000010000001111001100100 ##00100000000010000001111001100100 phy_dll_ctrl_reg_0_0(RW) 
+.equ               DENALI_PHY_07_DATA, 0b00000001000010000001111100001110 ##00000001000010000001111100001110 phy_dll_ctrl_reg_1_0(RW) 
+.equ               DENALI_PHY_08_DATA, 0b00100000000010000001111001100100 ##00100000000010000001111001100100 phy_dll_ctrl_reg_0_1(RW) 
+.equ               DENALI_PHY_09_DATA, 0b00000001000010000001111100001110 ##00000001000010000001111100001110 phy_dll_ctrl_reg_1_1(RW) 
+.equ               DENALI_PHY_10_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 den_phy_obs_reg_0_0(RD) 
+.equ               DENALI_PHY_11_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_0_0(RD) 
+.equ               DENALI_PHY_12_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_1_0(RD) 
+.equ               DENALI_PHY_13_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 den_phy_obs_reg_0_1(RD) 
+.equ               DENALI_PHY_14_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_0_1(RD) 
+.equ               DENALI_PHY_15_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_1_1(RD) 
+#else ##ddr_clk_160
+
+/******************************************************************
+ * COPYRIGHT (c) 2000 Denali Software, Inc.  All rights reserved. *
+ * -------------------------------------------------------------- *
+ * This code is proprietary and confidential information of       *
+ * Denali Software. It may not be reproduced, used or transmitted *
+ * in any form whatsoever without the express and written         *
+ * permission of Denali Software.                                 *
+ ******************************************************************
+ ******************************************************************
+ *                                                                 
+ *   Module:         regconfig.h
+ *   Documentation:  Register programming header file
+ *
+ ******************************************************************
+ ******************************************************************/
+
+/*****************************************************************
+ * WARNING:  This file was automatically generated.  Manual
+ * editing may result in undetermined behavior, and may be in
+ * violation of the Denali Support Agreement.
+ *****************************************************************/
+
+
+
+## ********************************************************************
+## Option: IP Mode                      = CTL
+## Option: Burst Length                  = 4
+## Option: CAS Latency                   = 4
+## Option: Simulation MHz                = 250
+## Option: Auto Precharge Mode     (0/1) = 0
+## Option: DLL Bypass Mode         (0/1) = 0
+## Option: Half-Memory Support     (0/1) = 0
+## Option: Registered Dimm Support (0/1) = 0
+## Option: SYNCRONIOUS 0/1 = 1
+## ********************************************************************
+## Memory: mt47h32m16_25e.xml
+## ********************************************************************
+
+
+.equ               DENALI_CTL_00_DATA ,0b00000000000000000000010000000000 ##0000000000000000 version(RD) 0000_0100 dram_class(RW) 0000000_0 start(RW) 
+.equ               DENALI_CTL_01_DATA ,0b00000000000000000000000000000000 ##000000000000000_0 max_cs_reg(RD) 0000_0000 max_col_reg(RD) 0000_0000 max_row_reg(RD) 
+.equ               DENALI_CTL_02_DATA ,0b00000010000000000000000000110010 ##0000_0010 initaref(RW) 000000000000000000110010 tinit(RW) 
+.equ               DENALI_CTL_03_DATA ,0b00000010000000100000001100001000 ##000_00010 tccd(RW) 00000_010 tbst_int_interval(RW) 0000_0011 wrlat(RW) 0000_1000 caslat_lin(RW) 
+.equ               DENALI_CTL_04_DATA ,0b00000010000011000000111000000011 ##0000_0010 twtr(RW) 00001100 tras_min(RW) 00001110 trc(RW) 00000011 trrd(RW) 
+.equ               DENALI_CTL_05_DATA ,0b00000011000000100000001000000100 ##00000011 tmod(RW) 000_00010 tmrd(RW) 00000_010 trtp(RW) 0000_0100 trp(RW) 
+.equ               DENALI_CTL_06_DATA ,0b00000011000000110100010001011100 ##000_00011 tckesr(RW) 00000_011 tcke(RW) 0100010001011100 tras_max(RW) 
+.equ               DENALI_CTL_07_DATA ,0b00000001000000010000000000000000 ##0000000_1 tras_lockout(RW) 0000000_1 concurrentap(RW) 0000000_0 ap(RW) 0000000_0 writeinterp(RW) 
+.equ               DENALI_CTL_08_DATA ,0b00000000000010000000010000000100 ##00000000000_01000 tdal(RW) 000_00100 twr_int(RW) 00000100 trcd_int(RW) 
+.equ               DENALI_CTL_09_DATA ,0b00000010000000000000000011001000 ##00000_010 bstlen(RW_D) 0000000_0 no_cmd_init(RW) 0000000011001000 tdll(RW) 
+.equ               DENALI_CTL_10_DATA ,0b00000100000000000110010000000000 ##0000_0100 trp_ab(RW) 0000000001100100 tcpd(RW) 00_000000 tfaw(RW) 
+.equ               DENALI_CTL_11_DATA ,0b00000001000000000000000000000000 ##0000000_1 tref_enable(RW) 0000000_0 auto_refresh_mode(RW) 0000000_0 arefresh(WR) 0000000_0 reg_dimm_enable(RW) 
+.equ               DENALI_CTL_12_DATA ,0b00000111010010110000000000011011 ##00_00011101001011 tref(RW) 000000_0000011011 trfc(RW) 
+.equ               DENALI_CTL_13_DATA ,0b00000000000000100000000000000000 ##0000000000000010 tpdex(RW) 0000000_0 power_down(RW) 00000000
+.equ               DENALI_CTL_14_DATA ,0b00000000000111010000000011001000 ##0000000000011101 txsnr(RW) 0000000011001000 txsr(RW) 
+.equ               DENALI_CTL_15_DATA ,0b00000001000000000000000000000000 ##0000000_1 enable_quick_srefresh(RW) 0000000_0 srefresh_exit_no_refresh(RW) 0000000_0 pwrup_srefresh_exit(RW) 0000000_0 srefresh(RW+) 
+.equ               DENALI_CTL_16_DATA ,0b00000000000000000000000000000000 ##0000000000000000 lowpower_power_down_cnt(RW) 000_00000 lowpower_control(RW) 00000_000 cke_delay(RW) 
+.equ               DENALI_CTL_17_DATA ,0b00000000000000000000000000000000 ##0000000000000000 lowpower_external_cnt(RW) 0000000000000000 lowpower_self_refresh_cnt(RW) 
+.equ               DENALI_CTL_18_DATA ,0b00000000000000000000000000000000 ##0000000_0 lowpower_refresh_enable(RW) 0000000000000000 lowpower_internal_cnt(RW) 000_00000 lowpower_auto_enable(RW) 
+.equ               DENALI_CTL_19_DATA ,0b00000000000000000000001100000011 ##00000000000000000000_0011 cksrx(RW) 0000_0011 cksre(RW) 
+.equ               DENALI_CTL_20_DATA ,0b00000000000000000000000000000000 ##000000_00000000000000000000000000 write_modereg(RW+) 
+.equ               DENALI_CTL_21_DATA ,0b00000000000001100100001000000000 ##0000000000_00011001000010 mr0_data_0(RW) 00000000 mrw_status(RD) 
+.equ               DENALI_CTL_22_DATA ,0b00000000000000000000010001000000 ##00_00000000000000 mr2_data_0(RW) 00_00010001000000 mr1_data_0(RW) 
+.equ               DENALI_CTL_23_DATA ,0b00000000000000000000000000000000 ##00_00000000000000 mr3_data_0(RW) 00_00000000000000 mrsingle_data_0(RW) 
+.equ               DENALI_CTL_24_DATA ,0b00001010000000100000000100000000 ##0000_1010 aprebit(RW_D) 00000_010 column_size(RW) 00000_001 addr_pins(RW) 0000000_0 eight_bank_mode(RW) 
+.equ               DENALI_CTL_25_DATA ,0b00000001000000010000101000001010 ##0000000_1 bank_split_en(RW) 0000000_1 addr_cmp_en(RW) 000_01010 command_age_count(RW) 000_01010 age_count(RW) 
+.equ               DENALI_CTL_26_DATA ,0b00000001000000010000000100000001 ##0000000_1 swap_en(RW) 0000000_1 rw_same_en(RW) 0000000_1 priority_en(RW) 0000000_1 placement_en(RW) 
+.equ               DENALI_CTL_27_DATA ,0b00000000000000000000000000000000 ##00000_000 q_fullness(RW) 0000000_0 fast_write(RW) 0000000_0 reduc(RW) 0000000_0 inhibit_dram_cmd(RW) 
+.equ               DENALI_CTL_28_DATA ,0b00000000000000000000000100000000 ##0000_000000000000 int_status(RD) 0000000_1 resync_dll_per_aref_en(RW) 0000000_0 resync_dll(WR) 
+.equ               DENALI_CTL_29_DATA ,0b00000000000000000000000000000000 ##0000_000000000000 int_mask(RW) 00000_00000000000 int_ack(WR) 
+.equ               DENALI_CTL_30_DATA ,0b00000000000000000000000000000000 ##00_000000000000000000000000000000 out_of_range_addr(RD) 
+.equ               DENALI_CTL_31_DATA ,0b00000000000000000000000000000000 ##000000000_0000000 out_of_range_source_id(RD) 00_000000 out_of_range_type(RD) 00_000000 out_of_range_length(RD) 
+.equ               DENALI_CTL_32_DATA ,0b00000000000000000000000000000000 ##00_000000000000000000000000000000 port_cmd_error_addr(RD) 
+.equ               DENALI_CTL_33_DATA ,0b00000000000000000000000000000000 ##00000_000 port_data_error_type(RD) 0_0000000 port_data_error_id(RD) 0000_0000 port_cmd_error_type(RD) 0_0000000 port_cmd_error_id(RD) 
+.equ               DENALI_CTL_34_DATA ,0b00000001000000000000000000000000 ##00000_001 r2w_samecs_dly(RW) 00000_000 r2r_samecs_dly(RW) 0000_0000 add_odt_clk_w2r_samecs(RW) 0000_0000 add_odt_clk_r2w_samecs(RW) 
+.equ               DENALI_CTL_35_DATA ,0b00000000000000000000000000000000 ##000_00000 ocd_adjust_pup_cs_0(RW) 000_00000 ocd_adjust_pdn_cs_0(RW) 00000_000 w2w_samecs_dly(RW) 00000_000 w2r_samecs_dly(RW) 
+.equ               DENALI_CTL_36_DATA ,0b00001111000011110000111100001111 ##0000_1111 ahb1_rdlen(RW) 0000_1111 ahb1_wrlen(RW) 0000_1111 ahb0_rdlen(RW) 0000_1111 ahb0_wrlen(RW) 
+.equ               DENALI_CTL_37_DATA ,0b00001111000011110000111100001111 ##0000_1111 ahb3_rdlen(RW) 0000_1111 ahb3_wrlen(RW) 0000_1111 ahb2_rdlen(RW) 0000_1111 ahb2_wrlen(RW) 
+.equ               DENALI_CTL_38_DATA ,0b00000000000000010000111100001111 ##0000000000000001 axi0_en_size_lt_width_instr(RW) 0000_1111 ahb4_rdlen(RW) 0000_1111 ahb4_wrlen(RW) 
+.equ               DENALI_CTL_39_DATA ,0b00000000000000110000001100000011 ##00000000000000_11 axi0_fifo_type_reg(RW) 00000_011 axi0_w_priority(RW) 00000_011 axi0_r_priority(RW) 
+.equ               DENALI_CTL_40_DATA ,0b00000011000000110000000000000001 ##00000_011 axi1_w_priority(RW) 00000_011 axi1_r_priority(RW) 0000000000000001 axi1_en_size_lt_width_instr(RW) 
+.equ               DENALI_CTL_41_DATA ,0b00000010000000000000000100000011 ##00000_010 axi2_r_priority(RW) 0000000000000001 axi2_en_size_lt_width_instr(RW) 000000_11 axi1_fifo_type_reg(RW) 
+.equ               DENALI_CTL_42_DATA ,0b00000000000000010000001100000010 ##0000000000000001 axi3_en_size_lt_width_instr(RW) 000000_11 axi2_fifo_type_reg(RW) 00000_010 axi2_w_priority(RW) 
+.equ               DENALI_CTL_43_DATA ,0b00000000000000110000001100000011 ##00000000000000_11 axi3_fifo_type_reg(RW) 00000_011 axi3_w_priority(RW) 00000_011 axi3_r_priority(RW) 
+.equ               DENALI_CTL_44_DATA ,0b00000011000000110000000000000001 ##00000_011 axi4_w_priority(RW) 00000_011 axi4_r_priority(RW) 0000000000000001 axi4_en_size_lt_width_instr(RW) 
+.equ               DENALI_CTL_45_DATA ,0b00000010000000000000000100000011 ##00000_010 axi5_r_priority(RW) 0000000000000001 axi5_en_size_lt_width_instr(RW) 000000_11 axi4_fifo_type_reg(RW) 
+.equ               DENALI_CTL_46_DATA ,0b00000000000000000000001100000010 ##00000_000 weighted_round_robin_weight_sharing(RW) 0000000_0 weighted_round_robin_latency_control(RW) 000000_11 axi5_fifo_type_reg(RW) 00000_010 axi5_w_priority(RW) 
+.equ               DENALI_CTL_47_DATA ,0b00000001000000010000000100000000 ##0000_0001 axi0_priority2_relative_priority(RW) 0000_0001 axi0_priority1_relative_priority(RW) 0000_0001 axi0_priority0_relative_priority(RW) 0000_0000 wrr_param_value_err(RD) 
+.equ               DENALI_CTL_48_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi0_priority6_relative_priority(RW) 0000_0001 axi0_priority5_relative_priority(RW) 0000_0001 axi0_priority4_relative_priority(RW) 0000_0001 axi0_priority3_relative_priority(RW) 
+.equ               DENALI_CTL_49_DATA ,0b00000000011001000000000000000001 ##000000_0001100100 axi0_priority_relax(RW) 00000_000 axi0_port_ordering(RW) 0000_0001 axi0_priority7_relative_priority(RW) 
+.equ               DENALI_CTL_50_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi1_priority3_relative_priority(RW) 0000_0001 axi1_priority2_relative_priority(RW) 0000_0001 axi1_priority1_relative_priority(RW) 0000_0001 axi1_priority0_relative_priority(RW) 
+.equ               DENALI_CTL_51_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi1_priority7_relative_priority(RW) 0000_0001 axi1_priority6_relative_priority(RW) 0000_0001 axi1_priority5_relative_priority(RW) 0000_0001 axi1_priority4_relative_priority(RW) 
+.equ               DENALI_CTL_52_DATA ,0b00000001000000000110010000000001 ##0000_0001 axi2_priority0_relative_priority(RW) 000000_0001100100 axi1_priority_relax(RW) 00000_001 axi1_port_ordering(RW) 
+.equ               DENALI_CTL_53_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi2_priority4_relative_priority(RW) 0000_0001 axi2_priority3_relative_priority(RW) 0000_0001 axi2_priority2_relative_priority(RW) 0000_0001 axi2_priority1_relative_priority(RW) 
+.equ               DENALI_CTL_54_DATA ,0b00000010000000010000000100000001 ##00000_010 axi2_port_ordering(RW) 0000_0001 axi2_priority7_relative_priority(RW) 0000_0001 axi2_priority6_relative_priority(RW) 0000_0001 axi2_priority5_relative_priority(RW) 
+.equ               DENALI_CTL_55_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi3_priority1_relative_priority(RW) 0000_0001 axi3_priority0_relative_priority(RW) 000000_0001100100 axi2_priority_relax(RW) 
+.equ               DENALI_CTL_56_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi3_priority5_relative_priority(RW) 0000_0001 axi3_priority4_relative_priority(RW) 0000_0001 axi3_priority3_relative_priority(RW) 0000_0001 axi3_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_57_DATA ,0b00000000000000110000000100000001 ##0000000000000_011 axi3_port_ordering(RW) 0000_0001 axi3_priority7_relative_priority(RW) 0000_0001 axi3_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_58_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi4_priority1_relative_priority(RW) 0000_0001 axi4_priority0_relative_priority(RW) 000000_0001100100 axi3_priority_relax(RW) 
+.equ               DENALI_CTL_59_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi4_priority5_relative_priority(RW) 0000_0001 axi4_priority4_relative_priority(RW) 0000_0001 axi4_priority3_relative_priority(RW) 0000_0001 axi4_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_60_DATA ,0b00000000000001000000000100000001 ##0000000000000_100 axi4_port_ordering(RW) 0000_0001 axi4_priority7_relative_priority(RW) 0000_0001 axi4_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_61_DATA ,0b00000001000000010000000001100100 ##0000_0001 axi5_priority1_relative_priority(RW) 0000_0001 axi5_priority0_relative_priority(RW) 000000_0001100100 axi4_priority_relax(RW) 
+.equ               DENALI_CTL_62_DATA ,0b00000001000000010000000100000001 ##0000_0001 axi5_priority5_relative_priority(RW) 0000_0001 axi5_priority4_relative_priority(RW) 0000_0001 axi5_priority3_relative_priority(RW) 0000_0001 axi5_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_63_DATA ,0b00000000000001010000000100000001 ##0000000000000_101 axi5_port_ordering(RW) 0000_0001 axi5_priority7_relative_priority(RW) 0000_0001 axi5_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_64_DATA ,0b00000000000000000000000001100100 ##000000000000000_0 cke_status(RD) 000000_0001100100 axi5_priority_relax(RW) 
+.equ               DENALI_CTL_65_DATA ,0b00000000000000000000000000000000 ##0000_0000 tdfi_phy_wrlat(RD) 00000000 dll_rst_adj_dly(RW) 0000000000000000 dll_rst_delay(RW) 
+.equ               DENALI_CTL_66_DATA ,0b00000000000000000000011100000000 ##0000000_0 dram_clk_disable(RW) 0000_0000 tdfi_rddata_en(RD) 0000_0111 tdfi_phy_rdlat(RW_D) 0_0000000 update_error_status(RD) 
+.equ               DENALI_CTL_67_DATA ,0b00000000000001110100101100000000 ##0000000000_00011101001011 tdfi_ctrlupd_max(RW) 0000_0000 tdfi_ctrlupd_min(RD) 
+.equ               DENALI_CTL_68_DATA ,0b00000010000000000000001000000000 ##0000001000000000 tdfi_phyupd_type1(RW) 0000001000000000 tdfi_phyupd_type0(RW) 
+.equ               DENALI_CTL_69_DATA ,0b00000010000000000000001000000000 ##0000001000000000 tdfi_phyupd_type3(RW) 0000001000000000 tdfi_phyupd_type2(RW) 
+.equ               DENALI_CTL_70_DATA ,0b00000000000000000000011101001011 ##000000000000000000_00011101001011 tdfi_phyupd_resp(RW) 
+.equ               DENALI_CTL_71_DATA ,0b00000000000000000010010001110111 ##00000000000000000010010001110111 tdfi_ctrlupd_interval(RW) 
+.equ               DENALI_CTL_72_DATA ,0b00000000000000100000001100000100 ##00000_000 tdfi_dram_clk_disable(RW) 0000_0010 tdfi_ctrl_delay(RW_D) 0000_0011 wrlat_adj(RW) 0000_0100 rdlat_adj(RW) 
+.equ               DENALI_CTL_73_DATA ,0b00000000000000000000000100000001 ##00000000000000000000000_1 odt_alt_en(RW) 0000_0001 tdfi_dram_clk_enable(RW) 
+
+/******************************************************************
+ * COPYRIGHT (c) 2000 Denali Software, Inc.  All rights reserved. *
+ * -------------------------------------------------------------- *
+ * This code is proprietary and confidential information of       *
+ * Denali Software. It may not be reproduced, used or transmitted *
+ * in any form whatsoever without the express and written         *
+ * permission of Denali Software.                                 *
+ ******************************************************************
+ ******************************************************************
+ *                                                                 
+ *   Module:         regconfig.h
+ *   Documentation:  Register programming header file
+ *
+ ******************************************************************
+ ******************************************************************/
+
+/*****************************************************************
+ * WARNING:  This file was automatically generated.  Manual
+ * editing may result in undetermined behavior, and may be in
+ * violation of the Denali Support Agreement.
+ *****************************************************************/
+
+
+
+## ********************************************************************
+## Option: IP Mode                      = PHY
+## Option: Burst Length                  = 4
+## Option: CAS Latency                   = 4
+## Option: Simulation MHz                = 250
+## Option: Auto Precharge Mode     (0/1) = 0
+## Option: DLL Bypass Mode         (0/1) = 0
+## Option: Half-Memory Support     (0/1) = 0
+## Option: Registered Dimm Support (0/1) = 0
+## Option: SYNCRONIOUS 0/1 = 1
+## ********************************************************************
+## Memory: mt47h32m16_25e.xml
+## ********************************************************************
+
+
+.equ               DENALI_PHY_00_DATA, 0b00000000000100010001000100000000 ##00000000000100010001000100000000 phy_pad_ctrl_reg_0(RW) 
+.equ               DENALI_PHY_01_DATA, 0b11110100000000010100101100110111 ##11110100000000010100101100110111 den_phy_ctrl_reg_0_0(RW) 
+.equ               DENALI_PHY_02_DATA, 0b00100100110000000000001011000000 ##00100100110000000000001011000000 den_phy_ctrl_reg_1_0(RW) 
+.equ               DENALI_PHY_03_DATA, 0b11110100000000010100101100110111 ##11110100000000010100101100110111 den_phy_ctrl_reg_0_1(RW) 
+.equ               DENALI_PHY_04_DATA, 0b00100100110000000000001011000000 ##00100100110000000000001011000000 den_phy_ctrl_reg_1_1(RW) 
+.equ               DENALI_PHY_05_DATA, 0b00000000000000000010101000000101 ##00000000000000000010101000000101 den_phy_ctrl_reg_2(RW) 
+.equ               DENALI_PHY_06_DATA, 0b00100000000001010001110101000100 ##00100000000001010001110101000100 phy_dll_ctrl_reg_0_0(RW) 
+.equ               DENALI_PHY_07_DATA, 0b00000001000001010001111100001001 ##00000001000001010001111100001001 phy_dll_ctrl_reg_1_0(RW) 
+.equ               DENALI_PHY_08_DATA, 0b00100000000001010001110101000100 ##00100000000001010001110101000100 phy_dll_ctrl_reg_0_1(RW) 
+.equ               DENALI_PHY_09_DATA, 0b00000001000001010001111100001001 ##00000001000001010001111100001001 phy_dll_ctrl_reg_1_1(RW) 
+.equ               DENALI_PHY_10_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 den_phy_obs_reg_0_0(RD) 
+.equ               DENALI_PHY_11_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_0_0(RD) 
+.equ               DENALI_PHY_12_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_1_0(RD) 
+.equ               DENALI_PHY_13_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 den_phy_obs_reg_0_1(RD) 
+.equ               DENALI_PHY_14_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_0_1(RD) 
+.equ               DENALI_PHY_15_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_1_1(RD) 
+#endif ##ddr_clk_160
+#endif ##k4t51163qj_f8
+#endif ##mt47h64m8_25e
diff --git a/arch/mips/cpu/vbg400/denali_reg_defines_fpga.s b/arch/mips/cpu/vbg400/denali_reg_defines_fpga.s
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/vbg400/denali_reg_defines_fpga.s
@@ -0,0 +1,150 @@
+
+/******************************************************************
+ * COPYRIGHT (c) 2000 Denali Software, Inc.  All rights reserved. *
+ * -------------------------------------------------------------- *
+ * This code is proprietary and confidential information of       *
+ * Denali Software. It may not be reproduced, used or transmitted *
+ * in any form whatsoever without the express and written         *
+ * permission of Denali Software.                                 *
+ ******************************************************************
+ ******************************************************************
+ *                                                                 
+ *   Module:         regconfig.h
+ *   Documentation:  Register programming header file
+ *
+ ******************************************************************
+ ******************************************************************/
+
+/*****************************************************************
+ * WARNING:  This file was automatically generated.  Manual
+ * editing may result in undetermined behavior, and may be in
+ * violation of the Denali Support Agreement.
+ *****************************************************************/
+
+
+##`timescale 10ps/10ps
+
+## ********************************************************************
+## Option: IP Mode                      = CTL
+## Option: Burst Length                  = 4
+## Option: CAS Latency                   = 4
+## Option: Simulation MHz                = 250
+## Option: Auto Precharge Mode     (0/1) = 0
+## Option: DLL Bypass Mode         (0/1) = 0
+## Option: Half-Memory Support     (0/1) = 0
+## Option: Registered Dimm Support (0/1) = 0
+## ********************************************************************
+## Memory: mt47h64m16_25e.xml
+## ********************************************************************
+
+
+.equ               DENALI_CTL_00_DATA, 0b00000000000000000000010000000000 ##0000000000000000 version(RD) 0000_0100 dram_class(RW) 0000000_0 start(RW) 
+.equ               DENALI_CTL_01_DATA, 0b00000000000000000000000000000000 ##000000000000000_0 max_cs_reg(RD) 0000_0000 max_col_reg(RD) 0000_0000 max_row_reg(RD) 
+.equ               DENALI_CTL_02_DATA, 0b00000010000000000000000000110010 ##0000_0010 initaref(RW) 000000000000000000110010 tinit(RW) 
+.equ               DENALI_CTL_03_DATA, 0b00000010000000100000001100001000 ##000_00010 tccd(RW) 00000_010 tbst_int_interval(RW) 0000_0011 wrlat(RW) 0000_1000 caslat_lin(RW) 
+.equ               DENALI_CTL_04_DATA, 0b00000010000011000000111000000011 ##0000_0010 twtr(RW) 00001100 tras_min(RW) 00001110 trc(RW) 00000011 trrd(RW) 
+.equ               DENALI_CTL_05_DATA, 0b00000011000000100000001000000100 ##00000011 tmod(RW) 000_00010 tmrd(RW) 00000_010 trtp(RW) 0000_0100 trp(RW) 
+.equ               DENALI_CTL_06_DATA, 0b00000011000000110100010001011100 ##000_00011 tckesr(RW) 00000_011 tcke(RW) 0100010001011100 tras_max(RW) 
+.equ               DENALI_CTL_07_DATA, 0b00000001000000010000000000000000 ##0000000_1 tras_lockout(RW) 0000000_1 concurrentap(RW) 0000000_0 ap(RW) 0000000_0 writeinterp(RW) 
+.equ               DENALI_CTL_08_DATA, 0b00000000000010000000010000000100 ##00000000000_01000 tdal(RW) 000_00100 twr_int(RW) 00000100 trcd_int(RW) 
+.equ               DENALI_CTL_09_DATA, 0b00000010000000000000000011001000 ##00000_010 bstlen(RW_D) 0000000_0 no_cmd_init(RW) 0000000011001000 tdll(RW) 
+.equ               DENALI_CTL_10_DATA, 0b00000100000000000110010000000000 ##0000_0100 trp_ab(RW) 0000000001100100 tcpd(RW) 00_000000 tfaw(RW) 
+.equ               DENALI_CTL_11_DATA, 0b00000001000000000000000000000000 ##0000000_1 tref_enable(RW) 0000000_0 auto_refresh_mode(RW) 0000000_0 arefresh(WR) 0000000_0 reg_dimm_enable(RW) 
+.equ               DENALI_CTL_12_DATA, 0b00000111100110010000000000011011 ##00_00011110011001 tref(RW) 000000_0000011011 trfc(RW) 
+.equ               DENALI_CTL_13_DATA, 0b00000000000000100000000000000000 ##0000000000000010 tpdex(RW) 0000000_0 power_down(RW) 00000000
+.equ               DENALI_CTL_14_DATA, 0b00000000000111010000000011001000 ##0000000000011101 txsnr(RW) 0000000011001000 txsr(RW) 
+.equ               DENALI_CTL_15_DATA, 0b00000001000000000000000000000000 ##0000000_1 enable_quick_srefresh(RW) 0000000_0 srefresh_exit_no_refresh(RW) 0000000_0 pwrup_srefresh_exit(RW) 0000000_0 srefresh(RW+) 
+.equ               DENALI_CTL_16_DATA, 0b00000000000000000000000000000000 ##0000000000000000 lowpower_power_down_cnt(RW) 000_00000 lowpower_control(RW) 00000_000 cke_delay(RW) 
+.equ               DENALI_CTL_17_DATA, 0b00000000000000000000000000000000 ##0000000000000000 lowpower_external_cnt(RW) 0000000000000000 lowpower_self_refresh_cnt(RW) 
+.equ               DENALI_CTL_18_DATA, 0b00000000000000000000000000000000 ##0000000_0 lowpower_refresh_enable(RW) 0000000000000000 lowpower_internal_cnt(RW) 000_00000 lowpower_auto_enable(RW) 
+.equ               DENALI_CTL_19_DATA, 0b00000000000000000000001100000011 ##00000000000000000000_0011 cksrx(RW) 0000_0011 cksre(RW) 
+.equ               DENALI_CTL_20_DATA, 0b00000000000000000000000000000000 ##000000_00000000000000000000000000 write_modereg(RW+) 
+.equ               DENALI_CTL_21_DATA, 0b00000000000001100100001000000000 ##0000000000_00011001000010 mr0_data_0(RW) 00000000 mrw_status(RD) 
+.equ               DENALI_CTL_22_DATA, 0b00000000000000000000000001000000 ##00_00000000000000 mr2_data_0(RW) 00_00000001000000 mr1_data_0(RW) 
+.equ               DENALI_CTL_23_DATA, 0b00000000000000000000000000000000 ##00_00000000000000 mr3_data_0(RW) 00_00000000000000 mrsingle_data_0(RW) 
+.equ               DENALI_CTL_24_DATA, 0b00001010000000100000000100000000 ##0000_1010 aprebit(RW_D) 00000_010 column_size(RW) 00000_001 addr_pins(RW) 0000000_0 eight_bank_mode(RW) 	
+.equ               DENALI_CTL_25_DATA, 0b00000001000000010001111100011111 ##0000000_1 bank_split_en(RW) 0000000_1 addr_cmp_en(RW) 000_11111 command_age_count(RW) 000_11111 age_count(RW) 
+.equ               DENALI_CTL_26_DATA, 0b00000001000000010000000100000001 ##0000000_1 swap_en(RW) 0000000_1 rw_same_en(RW) 0000000_1 priority_en(RW) 0000000_1 placement_en(RW) 
+.equ               DENALI_CTL_27_DATA, 0b00000000000000000000000000000000 ##00000_000 q_fullness(RW) 0000000_0 fast_write(RW) 0000000_0 reduc(RW) 0000000_0 inhibit_dram_cmd(RW) 
+.equ               DENALI_CTL_28_DATA, 0b00000000000000000000000100000000 ##0000_000000000000 int_status(RD) 0000000_1 resync_dll_per_aref_en(RW) 0000000_0 resync_dll(WR) 
+.equ               DENALI_CTL_29_DATA, 0b00000000000000000000000000000000 ##0000_000000000000 int_mask(RW) 00000_00000000000 int_ack(WR) 
+.equ               DENALI_CTL_30_DATA, 0b00000000000000000000000000000000 ##00_000000000000000000000000000000 out_of_range_addr(RD) 
+.equ               DENALI_CTL_31_DATA, 0b00000000000000000000000000000000 ##000000000_0000000 out_of_range_source_id(RD) 00_000000 out_of_range_type(RD) 00_000000 out_of_range_length(RD) 
+.equ               DENALI_CTL_32_DATA, 0b00000000000000000000000000000000 ##00_000000000000000000000000000000 port_cmd_error_addr(RD) 
+.equ               DENALI_CTL_33_DATA, 0b00000000000000000000000000000000 ##00000_000 port_data_error_type(RD) 0_0000000 port_data_error_id(RD) 0000_0000 port_cmd_error_type(RD) 0_0000000 port_cmd_error_id(RD) 
+.equ               DENALI_CTL_34_DATA, 0b00000001000000000000000000000000 ##00000_001 r2w_samecs_dly(RW) 00000_000 r2r_samecs_dly(RW) 0000_0000 add_odt_clk_w2r_samecs(RW) 0000_0000 add_odt_clk_r2w_samecs(RW) 
+.equ               DENALI_CTL_35_DATA, 0b00000000000000000000000000000000 ##000_00000 ocd_adjust_pup_cs_0(RW) 000_00000 ocd_adjust_pdn_cs_0(RW) 00000_000 w2w_samecs_dly(RW) 00000_000 w2r_samecs_dly(RW) 
+.equ               DENALI_CTL_36_DATA, 0b00001111000011110000111100001111 ##0000_1111 ahb1_rdlen(RW) 0000_1111 ahb1_wrlen(RW) 0000_1111 ahb0_rdlen(RW) 0000_1111 ahb0_wrlen(RW) 
+.equ               DENALI_CTL_37_DATA, 0b00001111000011110000111100001111 ##0000_1111 ahb3_rdlen(RW) 0000_1111 ahb3_wrlen(RW) 0000_1111 ahb2_rdlen(RW) 0000_1111 ahb2_wrlen(RW) 
+.equ               DENALI_CTL_38_DATA, 0b00000000000000010000111100001111 ##0000000000000001 axi0_en_size_lt_width_instr(RW) 0000_1111 ahb4_rdlen(RW) 0000_1111 ahb4_wrlen(RW) 
+.equ               DENALI_CTL_39_DATA, 0b00000000000000110000001100000011 ##00000000000000_00 axi0_fifo_type_reg(RW) 00000_011 axi0_w_priority(RW) 00000_011 axi0_r_priority(RW) 
+.equ               DENALI_CTL_40_DATA, 0b00000011000000110000000000000001 ##00000_011 axi1_w_priority(RW) 00000_011 axi1_r_priority(RW) 0000000000000001 axi1_en_size_lt_width_instr(RW) 
+.equ               DENALI_CTL_41_DATA, 0b00000011000000000000000100000011 ##00000_011 axi2_r_priority(RW) 0000000000000001 axi2_en_size_lt_width_instr(RW) 000000_00 axi1_fifo_type_reg(RW) 
+.equ               DENALI_CTL_42_DATA, 0b00000000000000010000001100000011 ##0000000000000001 axi3_en_size_lt_width_instr(RW) 000000_00 axi2_fifo_type_reg(RW) 00000_011 axi2_w_priority(RW) 
+.equ               DENALI_CTL_43_DATA, 0b00000000000000110000001100000011 ##00000000000000_00 axi3_fifo_type_reg(RW) 00000_011 axi3_w_priority(RW) 00000_011 axi3_r_priority(RW) 
+.equ               DENALI_CTL_44_DATA, 0b00000011000000110000000000000001 ##00000_011 axi4_w_priority(RW) 00000_011 axi4_r_priority(RW) 0000000000000001 axi4_en_size_lt_width_instr(RW) 
+.equ               DENALI_CTL_45_DATA, 0b00000011000000000000000100000011 ##00000_011 axi5_r_priority(RW) 0000000000000001 axi5_en_size_lt_width_instr(RW) 000000_00 axi4_fifo_type_reg(RW) 
+.equ               DENALI_CTL_46_DATA, 0b00000000000000000000001100000011 ##00000_000 weighted_round_robin_weight_sharing(RW) 0000000_0 weighted_round_robin_latency_control(RW) 000000_00 axi5_fifo_type_reg(RW) 00000_011 axi5_w_priority(RW) 
+.equ               DENALI_CTL_47_DATA, 0b00000110000001100000011000000000 ##0000_0110 axi0_priority2_relative_priority(RW) 0000_0110 axi0_priority1_relative_priority(RW) 0000_0110 axi0_priority0_relative_priority(RW) 0000_0000 wrr_param_value_err(RD) 
+.equ               DENALI_CTL_48_DATA, 0b00000110000001100000011000000110 ##0000_0110 axi0_priority6_relative_priority(RW) 0000_0110 axi0_priority5_relative_priority(RW) 0000_0110 axi0_priority4_relative_priority(RW) 0000_0110 axi0_priority3_relative_priority(RW) 
+.equ               DENALI_CTL_49_DATA, 0b00000000011001000000000000000110 ##000000_0001100100 axi0_priority_relax(RW) 00000_000 axi0_port_ordering(RW) 0000_0110 axi0_priority7_relative_priority(RW) 
+.equ               DENALI_CTL_50_DATA, 0b00000101000001010000010100000101 ##0000_0101 axi1_priority3_relative_priority(RW) 0000_0101 axi1_priority2_relative_priority(RW) 0000_0101 axi1_priority1_relative_priority(RW) 0000_0101 axi1_priority0_relative_priority(RW) 
+.equ               DENALI_CTL_51_DATA, 0b00000101000001010000010100000101 ##0000_0101 axi1_priority7_relative_priority(RW) 0000_0101 axi1_priority6_relative_priority(RW) 0000_0101 axi1_priority5_relative_priority(RW) 0000_0101 axi1_priority4_relative_priority(RW) 
+.equ               DENALI_CTL_52_DATA, 0b00000100000000000110010000000001 ##0000_0100 axi2_priority0_relative_priority(RW) 000000_0001100100 axi1_priority_relax(RW) 00000_001 axi1_port_ordering(RW) 
+.equ               DENALI_CTL_53_DATA, 0b00000100000001000000010000000100 ##0000_0100 axi2_priority4_relative_priority(RW) 0000_0100 axi2_priority3_relative_priority(RW) 0000_0100 axi2_priority2_relative_priority(RW) 0000_0100 axi2_priority1_relative_priority(RW) 
+.equ               DENALI_CTL_54_DATA, 0b00000010000001000000010000000100 ##00000_010 axi2_port_ordering(RW) 0000_0100 axi2_priority7_relative_priority(RW) 0000_0100 axi2_priority6_relative_priority(RW) 0000_0100 axi2_priority5_relative_priority(RW) 
+.equ               DENALI_CTL_55_DATA, 0b00000011000000110000000001100100 ##0000_0011 axi3_priority1_relative_priority(RW) 0000_0011 axi3_priority0_relative_priority(RW) 000000_0001100100 axi2_priority_relax(RW) 
+.equ               DENALI_CTL_56_DATA, 0b00000011000000110000001100000011 ##0000_0011 axi3_priority5_relative_priority(RW) 0000_0011 axi3_priority4_relative_priority(RW) 0000_0011 axi3_priority3_relative_priority(RW) 0000_0011 axi3_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_57_DATA, 0b00000000000000110000001100000011 ##0000000000000_011 axi3_port_ordering(RW) 0000_0011 axi3_priority7_relative_priority(RW) 0000_0011 axi3_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_58_DATA, 0b00000010000000100000000001100100 ##0000_0010 axi4_priority1_relative_priority(RW) 0000_0010 axi4_priority0_relative_priority(RW) 000000_0001100100 axi3_priority_relax(RW) 
+.equ               DENALI_CTL_59_DATA, 0b00000010000000100000001000000010 ##0000_0010 axi4_priority5_relative_priority(RW) 0000_0010 axi4_priority4_relative_priority(RW) 0000_0010 axi4_priority3_relative_priority(RW) 0000_0010 axi4_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_60_DATA, 0b00000000000001000000001000000010 ##0000000000000_100 axi4_port_ordering(RW) 0000_0010 axi4_priority7_relative_priority(RW) 0000_0010 axi4_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_61_DATA, 0b00000001000000010000000001100100 ##0000_0001 axi5_priority1_relative_priority(RW) 0000_0001 axi5_priority0_relative_priority(RW) 000000_0001100100 axi4_priority_relax(RW) 
+.equ               DENALI_CTL_62_DATA, 0b00000001000000010000000100000001 ##0000_0001 axi5_priority5_relative_priority(RW) 0000_0001 axi5_priority4_relative_priority(RW) 0000_0001 axi5_priority3_relative_priority(RW) 0000_0001 axi5_priority2_relative_priority(RW) 
+.equ               DENALI_CTL_63_DATA, 0b00000000000001010000000100000001 ##0000000000000_101 axi5_port_ordering(RW) 0000_0001 axi5_priority7_relative_priority(RW) 0000_0001 axi5_priority6_relative_priority(RW) 
+.equ               DENALI_CTL_64_DATA, 0b00000000000000000000000001100100 ##000000000000000_0 cke_status(RD) 000000_0001100100 axi5_priority_relax(RW) 
+.equ               DENALI_CTL_65_DATA, 0b00000000000000000000000000000000 ##0000_0000 tdfi_phy_wrlat(RD) 00000000 dll_rst_adj_dly(RW) 0000000000000000 dll_rst_delay(RW) 
+.equ               DENALI_CTL_66_DATA, 0b00000000000000000000011000000000 ##0000000_0 dram_clk_disable(RW) 0000_0000 tdfi_rddata_en(RD) 0000_0110 tdfi_phy_rdlat(RW_D) 0_0000000 update_error_status(RD) 
+.equ               DENALI_CTL_67_DATA, 0b00000000000001111001100100000000 ##0000000000_00011110011001 tdfi_ctrlupd_max(RW) 0000_0000 tdfi_ctrlupd_min(RD) 
+.equ               DENALI_CTL_68_DATA, 0b00000010000000000000001000000000 ##0000001000000000 tdfi_phyupd_type1(RW) 0000001000000000 tdfi_phyupd_type0(RW) 
+.equ               DENALI_CTL_69_DATA, 0b00000010000000000000001000000000 ##0000001000000000 tdfi_phyupd_type3(RW) 0000001000000000 tdfi_phyupd_type2(RW) 
+.equ               DENALI_CTL_70_DATA, 0b00000000000000000000011110011001 ##000000000000000000_00011110011001 tdfi_phyupd_resp(RW) 
+.equ               DENALI_CTL_71_DATA, 0b00000000000000000010010111111101 ##00000000000000000010010111111101 tdfi_ctrlupd_interval(RW) 
+.equ               DENALI_CTL_72_DATA, 0b00000000000000100000001100000011 ##00000_000 tdfi_dram_clk_disable(RW) 0000_0010 tdfi_ctrl_delay(RW_D) 0000_0011 wrlat_adj(RW) 0000_0011 rdlat_adj(RW) 
+.equ               DENALI_CTL_73_DATA, 0b00000000000000000000000100000001 ##00000000000000000000000_1 odt_alt_en(RW) 0000_0001 tdfi_dram_clk_enable(RW) 
+##* ********************************************************
+##* SimulationValues {{{
+##* ********************************************************
+
+
+## ********************************************************************
+## Option: IP Mode                      = PHY
+## Option: Burst Length                  = 4
+## Option: CAS Latency                   = 4
+## Option: Simulation MHz                = 250
+## Option: Auto Precharge Mode     (0/1) = 0
+## Option: DLL Bypass Mode         (0/1) = 0
+## Option: Half-Memory Support     (0/1) = 0
+## Option: Registered Dimm Support (0/1) = 0
+## ********************************************************************
+## Memory: mt47h64m16_25e.xml
+## ********************************************************************
+
+
+.equ               DENALI_PHY_00_DATA, 0b00000000000100010001000100000000 ##00000000000100010001000100000000 phy_pad_ctrl_reg_0(RW) 
+.equ               DENALI_PHY_01_DATA, 0b11110011000000010011101000100111 ##11110011000000010011101000100111 den_phy_ctrl_reg_0_0(RW) 
+.equ               DENALI_PHY_02_DATA, 0b00100110110000000000001011000000 ##00100110110000000000001011000000 den_phy_ctrl_reg_1_0(RW) 
+.equ               DENALI_PHY_03_DATA, 0b11110011000000010011101000100111 ##11110011000000010011101000100111 den_phy_ctrl_reg_0_1(RW) 
+.equ               DENALI_PHY_04_DATA, 0b00100110110000000000001011000000 ##00100110110000000000001011000000 den_phy_ctrl_reg_1_1(RW) 
+.equ               DENALI_PHY_05_DATA, 0b00000000000000000000000000000100 ##00000000000000000000000000000100 den_phy_ctrl_reg_2(RW) 
+.equ               DENALI_PHY_06_DATA, 0b00100000000011010001110101010111 ##00100000000011010001110101010111 phy_dll_ctrl_reg_0_0(RW) 
+.equ               DENALI_PHY_07_DATA, 0b00000001000100001010010100010111 ##00000001000100001010010100010111 phy_dll_ctrl_reg_1_0(RW) 
+.equ               DENALI_PHY_08_DATA, 0b00100000000011010001110101010111 ##00100000000011010001110101010111 phy_dll_ctrl_reg_0_1(RW) 
+.equ               DENALI_PHY_09_DATA, 0b00000001000100001010010100010111 ##00000001000100001010010100010111 phy_dll_ctrl_reg_1_1(RW) 
+.equ               DENALI_PHY_10_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 den_phy_obs_reg_0_0(RD) 
+.equ               DENALI_PHY_11_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_0_0(RD) 
+.equ               DENALI_PHY_12_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_1_0(RD) 
+.equ               DENALI_PHY_13_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 den_phy_obs_reg_0_1(RD) 
+.equ               DENALI_PHY_14_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_0_1(RD) 
+.equ               DENALI_PHY_15_DATA, 0b00000000000000000000000000000000 ##00000000000000000000000000000000 phy_dll_obs_reg_1_1(RD)
+	
diff --git a/arch/mips/cpu/vbg400/gen3_reg_depot.s b/arch/mips/cpu/vbg400/gen3_reg_depot.s
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/vbg400/gen3_reg_depot.s
@@ -0,0 +1,54 @@
+
+  /* load all modelled registers names... */
+  .equ    gmac_15_intr_mask_reg         , 0x003c  
+  .equ    gmac_07_intr_en_reg           , 0x101c  
+  .equ    gmac_06_op_mode_reg           , 0x1018  
+  .equ    gmac_00_config_reg            , 0x0000  
+  .equ    gmac_03_rx_desc_list_addr_reg , 0x100c  
+  .equ    gmac_04_tx_desc_list_addr_reg , 0x1010  
+  .equ    gmac_01_tx_poll_demand_reg    , 0x1004
+  .equ    gmac_02_rx_poll_demand_reg    , 0x1008
+  .equ    gmac_01_mac_frame_filter_reg  , 0x0004
+  .equ    gmac_14_intr_status_reg       , 0x0038
+  .equ    gmac_54_srgmii_status_reg     , 0x00d8
+  .equ    gmac_05_dma_status_reg        , 0x1014
+  .equ    gmac_00_bus_mode_reg          , 0x1000
+
+  .equ    pci_csr_00_reg                , 0x0000
+  .equ    pci_csr_01_crp_wr_dat_reg     , 0x0004
+  .equ    pci_csr_02_crp_rd_dat_reg     , 0x0008
+  .equ    pci_csr_03_pci_cfgio_addr_reg , 0x000c
+  .equ    pci_csr_04_reg                , 0x0010
+  .equ    pci_csr_05_cfgio_wr_dat_reg   , 0x0014
+  .equ    pci_csr_06_cfgio_rd_dat_reg   , 0x0018
+
+  .equ    dmac_ctrl_reg                 , 0x0040  
+  .equ    dmac_proc_a_int_status_reg    , 0x0000
+  .equ    dmac_proc_a_raw_int_status_reg, 0x0001 
+  .equ    dmac_proc_a_int_mask_reg      , 0x0002
+  .equ    dmac_proc_a_int_clr_reg       , 0x0003   
+  .equ    dmac_proc_b_int_status_reg    , 0x0010
+  .equ    dmac_proc_b_raw_int_status_reg, 0x0011 
+  .equ    dmac_proc_b_int_mask_reg      , 0x0012
+  .equ    dmac_proc_b_int_clr_reg       , 0x0013    
+  .equ    dmac_ch0_ctrl_reg             , 0x0020
+  .equ    dmac_ch0_config_reg           , 0x0021
+  .equ    dmac_ch0_src_type_reg         , 0x0022  
+  .equ    dmac_ch0_src_addr_reg         , 0x0023  
+  .equ    dmac_ch0_src_descrpt_reg      , 0x0024
+  .equ    dmac_ch0_src_ll_strt_ptr_reg  , 0x0025
+  .equ    dmac_ch0_src_ll_buf_addr_reg  , 0x0026
+  .equ    dmac_ch0_src_ll_nxt_descrpt_reg , 0x0027
+  .equ    dmac_ch0_src_ll_ctrl_reg      , 0x0028
+  .equ    dmac_ch0_dest_type_reg        , 0x0029
+  .equ    dmac_ch0_dest_addr_reg        , 0x002a  
+  .equ    dmac_ch0_dest_descript_reg    , 0x002b
+  .equ    dmac_ch0_dest_ll_strt_ptr_reg , 0x002c
+  .equ    dmac_ch0_dest_ll_buf_addr_reg , 0x002d
+  .equ    dmac_ch0_dest_ll_nxt_descrpt_reg , 0x002e
+  .equ    dmac_ch0_dest_ll_ctrl_reg     , 0x002f
+
+  .equ    gen3_shrd_basic_mode_config_reg , 0x0000
+  .equ    gen3_shrd_safety_reg          , 0x0074
+  .equ    gen3_shrd_clock_enable_reg    , 0x000c
+  .equ    gen3_shrd_soft_reset_reg      , 0x0008
diff --git a/arch/mips/cpu/vbg400/interrupts.c b/arch/mips/cpu/vbg400/interrupts.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/vbg400/interrupts.c
@@ -0,0 +1,33 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+void enable_interrupts(void)
+{
+}
+
+int disable_interrupts(void)
+{
+	return 0;
+}
diff --git a/arch/mips/cpu/vbg400/npu_memory_map.s b/arch/mips/cpu/vbg400/npu_memory_map.s
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/vbg400/npu_memory_map.s
@@ -0,0 +1,11 @@
+        .equ     DDR_MEM_BASE_ADDR       ,0xa000 # 64M bytes
+        .equ     BB_DDR_MEM_BASE_ADDR    ,0xa800 # 64M bytes
+        .equ     BASEBAND_MEM_BASE_ADDR  ,0xa600 # 128k bytes
+        .equ     BOOT_BLOCK_BASE_ADDR    ,0xbfc0 # 16 bytes
+        .equ     SYSTEM_IF_BASE_ADDR     ,0xa700 # 256k bytes
+        .equ     GMAC_CSR_BASE_ADDR      ,0xa704 # 256k bytes
+        .equ     DDR_CSR_BASE_ADDR       ,0xa708 # 256k bytes
+        .equ     PCI_CSR_BASE_ADDR       ,0xa710 # 256k bytes
+        .equ     DDRDMA_CSR_BASE_ADDR    ,0xa714 # 256k bytes
+        .equ     PCIDMA_CSR_BASE_ADDR    ,0xa718 # 256k bytes
+        .equ     SHARED_REG_BASE_ADDR    ,0xa71c # 256k bytes
diff --git a/arch/mips/cpu/vbg400/red_fix_loading_and_rm_loading.s b/arch/mips/cpu/vbg400/red_fix_loading_and_rm_loading.s
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/vbg400/red_fix_loading_and_rm_loading.s
@@ -0,0 +1,324 @@
+##
+## Redundancy fix loading and Memories' read margin loading from efuse
+## Written by Amir Rosenblum, Jul. 2011
+##
+## Structure in efuse array:
+##
+## Offset  2 = Shared RAM block 0 - Select address = 0xA01F_019C, selector = 0x00, load fix into 0xA01F_0178
+## Offset  3 = Shared RAM block 1 - Select address = 0xA01F_019C, selector = 0x02, load fix into 0xA01F_0178
+## Offset  4 = Shared RAM block 2 - Select address = 0xA01F_019C, selector = 0x04, load fix into 0xA01F_0178
+## Offset  5 = Shared RAM block 3 - Select address = 0xA01F_019C, selector = 0x06, load fix into 0xA01F_0178
+## Offset  6 = IRAM block 0       - Select address = 0xA018_00E0, selector = 0x10, load fix into 0xA018_00EC
+## Offset  7 = IRAM block 1       - Select address = 0xA018_00E0, selector = 0x12, load fix into 0xA018_00EC
+## Offset  8 = IRAM block 2       - Select address = 0xA018_00E0, selector = 0x14, load fix into 0xA018_00EC
+## Offset  9 = IRAM block 3       - Select address = 0xA018_00E0, selector = 0x16, load fix into 0xA018_00EC
+## Offset 10 = IRAM block 4       - Select address = 0xA018_00E0, selector = 0x18, load fix into 0xA018_00EC
+## Offset 11 = IRAM block 5       - Select address = 0xA018_00E0, selector = 0x1a, load fix into 0xA018_00EC
+## Offset 12 = IRAM block 6       - Select address = 0xA018_00E0, selector = 0x1c, load fix into 0xA018_00EC
+## Offset 13 = IRAM block 7       - Select address = 0xA018_00E0, selector = 0x1e, load fix into 0xA018_00EC
+## Offset 14 = IRAM block 8       - Select address = 0xA018_00E0, selector = 0x20, load fix into 0xA018_00EC
+## Offset 15 = IRAM block 9       - Select address = 0xA018_00E0, selector = 0x22, load fix into 0xA018_00EC
+## Offset 16 = IRAM block 10      - Select address = 0xA018_00E0, selector = 0x24, load fix into 0xA018_00EC
+## Offset 17 = DCACHE0            - Select address = 0xA018_00E0, selector = 0x08/0x09, load fix into 0xA018_00EC (bits[31: 0] / bits [63:32])
+## Offset 18 = DCACHE1            - Select address = 0xA018_00E0, selector = 0x0a/0x0b, load fix into 0xA018_00EC (bits[31: 0] / bits [63:32])
+## Offset 19 = ICACHE             - Select address = 0xA018_00E0, selector = 0x00/0x01/0x02/0x03, load fix into 0xA018_00EC (bits[31: 0] / bits[63: 32] / bits[95: 64] / bits[127: 96])
+	
+
+	.equ	SHARED_REG_BASE,	0xa71c0000
+
+	.equ    EFUSE_DATA,		0x0120
+	.equ    EFUSE_ADDRESS,          0x0124
+	.equ    EFUSE_CONTROL,          0x0128
+	.equ    EFUSE_STATUS,           0x012c
+	.equ    EFUSE_TIMER_CONFIG1,    0x0130
+	.equ    EFUSE_TIMER_CONFIG2,    0x0134
+
+	.equ	EFUSE_BUSY,		0x1
+	.equ	EFUSE_INIT_DONE,	0x2
+
+		
+	.equ	SYS_IF_BASE,		0xa0180000
+	.equ	CPU_SELECT_OFFSET,	0x00e0
+	.equ	CPU_LOAD_OFFSET,	0x00ec
+
+		
+	.equ	HT_EXT_BASE,		0xa01f0000
+	.equ	MAC_SELECT_OFFSET,	0x019c
+	.equ	MAC_LOAD_OFFSET,	0x0178
+	
+
+	.equ	RED_FIX_START_MAC_ADDR,	0x2<<3
+	.equ	RED_FIX_START_CPU_ADDR, 0x6<<3
+	.equ	RED_FIX_START_DCACHE,   0x11<<3
+	.equ	RED_FIX_END_ADDR_PLUS1,	0x14<<3
+
+	li	$10,SHARED_REG_BASE
+
+	li	$20,RED_FIX_START_MAC_ADDR
+	li	$23,RED_FIX_START_CPU_ADDR
+	li	$24,HT_EXT_BASE
+	li	$25,0x0 /* Used to set fix selector, SHRAM block 0 selector is 0x00 */
+	/* Start process only when machine is ready */
+wait_if_busy_pre_start:	
+	lw	$21,EFUSE_STATUS($10)
+	andi	$21,EFUSE_BUSY
+	bne	$21,$0,wait_if_busy_pre_start
+
+#     #    ##    ###  #    #
+##   ##   #  #    #   #    #
+# # # #  #    #   #   ##   #
+#  #  #  #    #   #   # #  #
+#     #  #    #   #   #  # #
+#     #  ######   #   #   ##
+#     #  #    #   #   #    #
+#     #  #    #   #   #    #
+#     #  #    #  ###  #    #
+
+	/* Main loop starts here */
+	/* Currently, handling Shared RAM */
+efuse_start_shram_loop:	
+	bal	do_read_from_efuse
+
+	beq	$22,$0,read_next_byte_shram
+
+	/* Fix is required */
+	sw	$25,MAC_SELECT_OFFSET($24)
+	addiu	$22,-1 /* Subtract 1 from efuse read value - we add 1 to the fix vector value as a flag that a fix is needed */
+	li	$26,1
+	sllv	$26,$26,$22 /* Create the one-hot fix value */
+	sw	$26,MAC_LOAD_OFFSET($24)
+	
+read_next_byte_shram:
+	addiu	$20,+8
+	addiu	$25,+2 /* Set selector for next RAM block */
+	bne	$20,$23,efuse_start_shram_loop /* At this point, $23 points to start of CPU */
+
+	/* Shared RAM is done, start with IRAM */
+	li	$24,SYS_IF_BASE
+	li	$23,RED_FIX_START_DCACHE
+	li	$25,0x10 /* Used to set fix selector, IRAM block 0 selector is 0x10 */
+
+efuse_start_iram_loop:		
+	bal	do_read_from_efuse
+
+	beq	$22,$0,read_next_byte_iram
+
+	/* Fix is required */
+	sw	$25,CPU_SELECT_OFFSET($24)
+	addiu	$22,-1 /* Subtract 1 from efuse read value - we add 1 to the fix vector value as a flag that a fix is needed */
+	li	$26,1
+	sllv	$26,$26,$22 /* Create the one-hot fix value */
+	sw	$26,CPU_LOAD_OFFSET($24)
+	
+read_next_byte_iram:
+	addiu	$20,+8
+	addiu	$25,+2 /* Set selector for next RAM block */
+	bne	$20,$23,efuse_start_iram_loop /* At this point, $23 points to start of DCACHE */
+
+	/* IRAM is done, move to DCACHE */
+	bal	do_read_from_efuse
+
+	beq	$22,$0, test_dcache1
+	
+	/* DCACHE0 needs fixing */	
+	li	$26,0x1
+	addiu	$22,-1
+	li	$25,0x20
+	sub	$25,$22,$25
+	bgez    $25,fix_dc0_bits63to32
+	
+	/* Fix is needed for bits[31:0] */
+	li	$25,0x8
+	sw	$25,CPU_SELECT_OFFSET($24)
+	sllv	$26,$26,$22
+	sw	$26,CPU_LOAD_OFFSET($24)
+	b	test_dcache1
+
+	/* Fix is needed for bits[63:32] */
+fix_dc0_bits63to32: /* In this case, $25 holds the fix vector minus 0x20. Manipulate unused $22 instead of $25 */
+	li	$22,0x9
+	sw	$22,CPU_SELECT_OFFSET($24)
+	sllv	$26,$26,$25
+	sw	$26,CPU_LOAD_OFFSET($24)
+
+	/* DCACHE0 is done, move to DCACHE1 */
+test_dcache1:	
+	addiu	$20,+8
+	bal	do_read_from_efuse
+
+	beq	$22,$0, test_icache
+	
+	/* DCACHE1 needs fixing */	
+	li	$26,0x1
+	addiu	$22,-1
+	li	$25,0x20
+	sub	$25,$22,$25
+	bgez    $25,fix_dc1_bits63to32
+	
+	/* Fix is needed for bits[31:0] */
+	li	$25,0xa
+	sw	$25,CPU_SELECT_OFFSET($24)
+	sllv	$26,$26,$22
+	sw	$26,CPU_LOAD_OFFSET($24)
+	b	test_icache
+
+	/* Fix is needed for bits[63:32] */
+fix_dc1_bits63to32: /* In this case, $25 holds the fix vector minus 0x20. Manipulate unused $22 instead of $25 */
+	li	$22,0xb
+	sw	$22,CPU_SELECT_OFFSET($24)
+	sllv	$26,$26,$25
+	sw	$26,CPU_LOAD_OFFSET($24)
+
+	/* DCACHE1 is done, move to ICACHE */
+test_icache:	
+	addiu	$20,+8
+	bal	do_read_from_efuse
+
+	beq	$22,$0, efuse_routine_done
+
+	/* ICACHE needs fixing */
+	li	$26,0x0 /* $26 will follow the required selector value */
+	addiu	$22,-1
+	li	$25,0x20
+chunk_loop:
+	addiu	$26,+1 /* We start by incrementing the selector value. This means that we point to NEXT required value */
+	sub	$22,$22,$25
+	bgez    $22,chunk_loop
+
+	/* Decrement $26 to point to exact selector required */
+	addiu	$26,-1
+	sw	$26,CPU_SELECT_OFFSET($24)
+	/* Now, generate the one-hot vector */
+	li	$26,0x1
+	sllv	$26,$26,$22
+	sw	$26,CPU_LOAD_OFFSET($24)
+			
+	b	efuse_routine_done
+
+
+#####  #####  #   #   ###   #####        ##     ###    ###   #####   ###    ### 
+#      #      #   #  #   #  #           #  #   #   #  #   #  #      #   #  #   #
+#      #      #   #  #      #          #    #  #      #      #      #      #	 
+#      #      #   #  #      #          #    #  #      #      #      #      #	 
+####   ####   #   #   ###   ####       #    #  #      #      ####    ###    ### 
+#      #      #   #      #  #          ######  #      #      #          #      #
+#      #      #   #      #  #          #    #  #      #      #          #      #
+#      #      #   #  #   #  #          #    #  #   #  #   #  #      #   #  #   #
+#####  #       ###    ###   #####      #    #   ###    ###   #####   ###    ### 
+
+do_read_from_efuse:
+	/* Write address to read from */
+	sw	$20,EFUSE_ADDRESS($10)
+
+	/* Set READ bit - also triggers machine operation */
+	sw	$0,EFUSE_CONTROL($10)
+	
+	/* Wait for machine ready */
+wait_if_busy:	
+	lw	$21,EFUSE_STATUS($10)
+	andi	$21,EFUSE_BUSY
+	bne	$21,$0,wait_if_busy
+
+	/* Load read data into $22 */
+	lw	$22,EFUSE_DATA($10)
+	jr	$31
+	
+	/* We are done */
+efuse_routine_done:
+	nop
+	
+####   #     #         #       ###     ##    #####   ###  #    #   ####
+#   #  ##   ##         #      #   #   #  #    #   #   #   #    #  #    #
+#   #  # # # #         #      #   #  #    #   #   #   #   ##   #  #
+#   #  #  #  #         #      #   #  #    #   #   #   #   # #  #  #
+####   #     #         #      #   #  #    #   #   #   #   #  # #  #
+##     #     #         #      #   #  ######   #   #   #   #   ##  #  ###
+# #    #     #         #      #   #  #    #   #   #   #   #    #  #    #
+#  #   #     #         #      #   #  #    #   #   #   #   #    #  #   ##
+#   #  #     #         #####   ###   #    #  #####   ###  #    #   ### #
+
+	/* RM loading in USB mode is done as follows:	       */
+	/* efuse address 56 (0x38), bit[6]    = RM valid       */
+	/* efuse address 56 (0x38), bits[2:0] = ICACHE DataRAM - to be loaded to 0x001800d4, bit mask 00000007 */
+	/* efuse address 56 (0x38), bits[5:3] = DCACHE DataRAM - to be loaded to 0x001800d4, bit mask 00007000 */
+	/* efuse address 57 (0x39), bits[2:0] = IRAM/SHRAM     - to be loaded to 0x001800d8, bit mask 77777777 (IRAM), 0x001800dc, bit mask 777 (IRAM8,9,10)  and 0x001f01f8, bit mask 00007777 (SHRAM) */
+	/* efuse address 57 (0x39), bits[5:3] = USB RAM        - to be loaded to 0x070000d4, bit mask 70000000 */
+	.equ	EFUSE_RM_REG0_ADDR,	0x38<<3
+	.equ	EFUSE_RM_REG1_ADDR,	0x39<<3
+	
+rm_wait_if_busy_pre_start:	
+	lw	$21,EFUSE_STATUS($10)
+	andi	$21,EFUSE_BUSY
+	bne	$21,$0,rm_wait_if_busy_pre_start
+
+	li	$20,EFUSE_RM_REG0_ADDR
+	bal	do_read_from_efuse
+
+	li	$21,0x1<<6
+	and	$21,$21,$22
+	beq	$21,$0,rm_routine_done /* No need to load RM */
+
+	li	$21,SYS_IF_BASE
+	/* Load the register which holds RM for ICACHE and DCACHE */
+	lw	$23,0x00d4($21)
+	/* Clear the fields for ICACHE and DCACHE. Keep the rest untouched. */
+	li	$24,0xffff8ff8
+	and	$23,$23,$24
+
+	/* Prepare the mask for ICACHE, DCACHE */
+	/* Mask bits[5:3] of the original efuse value */
+	andi	$24,$22,0x38
+	/* Shift to appropriate location - from [5:3] to [14:12] */
+	sll	$24,9
+	/* Now, add bits[2:0] from efuse */
+	andi	$22,$22,0x7
+	or	$24,$24,$22
+
+	/* Combine all together back to the RM register to be written */
+	or	$23,$23,$24
+	sw	$23,0x00d4($21)
+	
+	/* SHRAM/IRAM - since for these RAMs, the register holds only RM for these specific memories,      */
+	/* The approach is not read-modify-write. We create the RM register from scratch and just write it */
+
+	li	$20,EFUSE_RM_REG1_ADDR
+	bal	do_read_from_efuse
+
+	li	$25,0x7
+	/* Get the field for IRAM/SHRAM into RF22 */
+	and	$25,$22,$25
+	/* Duplicate it into RF23 - create a vector with two RM values */
+	sll	$23,$25,4
+	or	$23,$23,$25
+	/* Duplicate it once again - this time to RF22 */
+	sll	$25,$23,8
+	or	$25,$25,$23
+	/* And once again - into RF23 */
+	sll	$23,$25,16
+	or	$23,$23,$25
+	/* We now have a 8-field value in $23. We can write it into IRAM's RM and also into SHRAM - although for SHRAM we need only 4 */
+	/* Write to IRAM's RM reg. */
+	li	$21,SYS_IF_BASE
+	sw	$23,0x00d8($21)
+	sw	$23,0x00dc($21)
+	/* Write to SHRAM's RM reg. */
+	li	$21,HT_EXT_BASE
+	sw	$23,0x01f8($21)
+
+	/* USB ROM */
+	andi	$22,0x38
+	sll	$22,25
+
+	li	$21,0xa7000000
+	lw	$25,0x00d4($21)
+	li	$23,0x0fffffff
+	and	$25,$25,$23
+	or	$25,$25,$22
+
+	sw	$25,0x00d4($21)
+	
+	/* We are done */
+rm_routine_done:	
+	nop	
+
+	
diff --git a/arch/mips/cpu/vbg400/start.S b/arch/mips/cpu/vbg400/start.S
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/vbg400/start.S
@@ -0,0 +1,937 @@
+/*
+ *  Startup Code for MIPS32 CPU-core
+ *
+ *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <configs/vbg400.h>
+
+# Select a Hazard Barrier
+
+#ifdef LIGHT_WEIGHT_HB
+#define HB nop
+#else
+#define HB ehb
+#endif
+
+#define RVECENT(f,n) \
+   b f; nop
+#define XVECENT(f,bev) \
+   b f     ;           \
+   li k0,bev
+
+	.set noreorder
+#	.set noat
+	.set	mips32r2
+
+	.globl _start
+	.text
+_start:
+
+#loop_for_ever_start:
+#bal loop_for_ever_start
+
+to_start:
+	RVECENT(reset,0)	/* U-boot entry point */
+	RVECENT(reset,1)	/* software reboot */
+	RVECENT(romReserved,2)
+	RVECENT(romReserved,3)
+	RVECENT(romReserved,4)
+	RVECENT(romReserved,5)
+	RVECENT(romReserved,6)
+	RVECENT(romReserved,7)
+	RVECENT(romReserved,8)
+	RVECENT(romReserved,9)
+	RVECENT(romReserved,10)
+	RVECENT(romReserved,11)
+	RVECENT(romReserved,12)
+	RVECENT(romReserved,13)
+	RVECENT(romReserved,14)
+	RVECENT(romReserved,15)
+	RVECENT(romReserved,16)
+	RVECENT(romReserved,17)
+	RVECENT(romReserved,18)
+	RVECENT(romReserved,19)
+	RVECENT(romReserved,20)
+	RVECENT(romReserved,21)
+	RVECENT(romReserved,22)
+	RVECENT(romReserved,23)
+	RVECENT(romReserved,24)
+	RVECENT(romReserved,25)
+	RVECENT(romReserved,26)
+	RVECENT(romReserved,27)
+	RVECENT(romReserved,28)
+	RVECENT(romReserved,29)
+	RVECENT(romReserved,30)
+	RVECENT(romReserved,31)
+	RVECENT(romReserved,32)
+	RVECENT(romReserved,33)
+	RVECENT(romReserved,34)
+	RVECENT(romReserved,35)
+	RVECENT(romReserved,36)
+	RVECENT(romReserved,37)
+	RVECENT(romReserved,38)
+	RVECENT(romReserved,39)
+	RVECENT(romReserved,40)
+	RVECENT(romReserved,41)
+	RVECENT(romReserved,42)
+	RVECENT(romReserved,43)
+	RVECENT(romReserved,44)
+	RVECENT(romReserved,45)
+	RVECENT(romReserved,46)
+	RVECENT(romReserved,47)
+	RVECENT(romReserved,48)
+	RVECENT(romReserved,49)
+	RVECENT(romReserved,50)
+	RVECENT(romReserved,51)
+	RVECENT(romReserved,52)
+	RVECENT(romReserved,53)
+	RVECENT(romReserved,54)
+	RVECENT(romReserved,55)
+	RVECENT(romReserved,56)
+	RVECENT(romReserved,57)
+	RVECENT(romReserved,58)
+	RVECENT(romReserved,59)
+	RVECENT(romReserved,60)
+	RVECENT(romReserved,61)
+	RVECENT(romReserved,62)
+	RVECENT(romReserved,63)
+	XVECENT(romExcHandle,0x200)	/* bfc00200: R4000 tlbmiss vector */
+	RVECENT(romReserved,65)
+	RVECENT(romReserved,66)
+	RVECENT(romReserved,67)
+	RVECENT(romReserved,68)
+	RVECENT(romReserved,69)
+	RVECENT(romReserved,70)
+	RVECENT(romReserved,71)
+	RVECENT(romReserved,72)
+	RVECENT(romReserved,73)
+	RVECENT(romReserved,74)
+	RVECENT(romReserved,75)
+	RVECENT(romReserved,76)
+	RVECENT(romReserved,77)
+	RVECENT(romReserved,78)
+	RVECENT(romReserved,79)
+	XVECENT(romExcHandle,0x280)	/* bfc00280: R4000 xtlbmiss vector */
+	RVECENT(romReserved,81)
+	RVECENT(romReserved,82)
+	RVECENT(romReserved,83)
+	RVECENT(romReserved,84)
+	RVECENT(romReserved,85)
+	RVECENT(romReserved,86)
+	RVECENT(romReserved,87)
+	RVECENT(romReserved,88)
+	RVECENT(romReserved,89)
+	RVECENT(romReserved,90)
+	RVECENT(romReserved,91)
+	RVECENT(romReserved,92)
+	RVECENT(romReserved,93)
+	RVECENT(romReserved,94)
+	RVECENT(romReserved,95)
+	XVECENT(romExcHandle,0x300)	/* bfc00300: R4000 cache vector */
+	RVECENT(romReserved,97)
+	RVECENT(romReserved,98)
+	RVECENT(romReserved,99)
+	RVECENT(romReserved,100)
+	RVECENT(romReserved,101)
+	RVECENT(romReserved,102)
+	RVECENT(romReserved,103)
+	RVECENT(romReserved,104)
+	RVECENT(romReserved,105)
+	RVECENT(romReserved,106)
+	RVECENT(romReserved,107)
+	RVECENT(romReserved,108)
+	RVECENT(romReserved,109)
+	RVECENT(romReserved,110)
+	RVECENT(romReserved,111)
+	XVECENT(romExcHandle,0x380)	/* bfc00380: R4000 general vector */
+	RVECENT(romReserved,113)
+	RVECENT(romReserved,114)
+	RVECENT(romReserved,115)
+	RVECENT(romReserved,116)
+	RVECENT(romReserved,116)
+	RVECENT(romReserved,118)
+	RVECENT(romReserved,119)
+	RVECENT(romReserved,120)
+	RVECENT(romReserved,121)
+	RVECENT(romReserved,122)
+	RVECENT(romReserved,123)
+	RVECENT(romReserved,124)
+	RVECENT(romReserved,125)
+	RVECENT(romReserved,126)
+	RVECENT(romReserved,127)
+
+	/* We hope there are no more reserved vectors!
+	 * 128 * 8 == 1024 == 0x400
+	 * so this is address R_VEC+0x400 == 0xbfc00400
+	 */
+	.align 4
+
+reset:
+	        /*# Initialize the register file*/
+        or      $1,$0, $0
+        or      $2,$0, $0
+        or      $3,$0, $0
+        or      $4,$0, $0
+        or      $5,$0, $0
+        or      $6,$0, $0
+        or      $7,$0, $0
+        or      $8,$0, $0
+        or      $9,$0, $0
+        or      $10,$0, $0
+        or      $11,$0, $0
+        or      $12,$0, $0
+        or      $13,$0, $0
+        or      $14,$0, $0
+        or      $15,$0, $0
+        or      $16,$0, $0
+        or      $17,$0, $0
+        or      $18,$0, $0
+        or      $19,$0, $0
+        or      $20,$0, $0
+        or      $21,$0, $0
+        or      $22,$0, $0
+        or      $23,$0, $0
+        or      $24,$0, $0
+        or      $25,$0, $0
+        or      $26,$0, $0
+        or      $27,$0, $0
+        or      $28,$0, $0
+        or      $31,$0, $0
+        or      $30,$0, $0
+
+        /*#now set 0 to all shadow file GPRs*/
+        /* TO DO */
+
+        /*# Clear interrupts mask bits*/
+        mfc0    $10, CP0_STATUS        
+        li      $11, 0xffff00fe /*clear IE and IM7-0 bits*/
+        and     $10, $11        
+        mtc0    $10, CP0_STATUS        
+
+	    /* CAUSE register */
+	    mtc0	zero, CP0_CAUSE
+
+#if 0
+        /*# Disable watch exceptions*/
+        mtc0    $0, $18
+
+        /*# Clear Watch Status bits*/
+        li      $11, 0x3
+        mtc0    $11, $19
+
+        /*# Clear WP bit to avoid watch exception upon user code entry
+        # Clear IV bit - Interrupts go to general exception vector
+        # Clear software interrupts*/
+        mtc0    $0, $13
+#else
+        # Check the presence of additional Watch registers 
+	li	$11, 0x7		# (M_WatchHiI | M_WatchHiR | M_WatchHiW)
+	mtc0	$11, $19		# C0_WatchHi
+        ehb
+	mfc0	$11, $19		# C0_WatchHi
+        srl     $11, $11, 31
+        beq     $11, $0, 1f 
+
+	li	$11, 0x7		
+
+	# Disable watch exceptions
+	mtc0	$0, $18, 1		# C0_WatchLo1
+	mtc0	$0, $18, 2		# C0_WatchLo2
+	mtc0	$0, $18, 3		# C0_WatchLo3
+
+	# Clear Watch Status bits
+	mtc0	$11, $19, 1		# C0_WatchHi1
+	mtc0	$11, $19, 2		# C0_WatchHi2
+	mtc0	$11, $19, 3		# C0_WatchHi3
+
+1:      # There is only one set of Watch register pair
+	# Disable watch exceptions
+	mtc0	$0, $18			# C0_WatchLo
+
+	# Clear Watch Status bits
+	mtc0	$11, $19		# C0_WatchHi
+
+	# Clear WP bit to avoid watch exception upon user code entry
+	# Clear IV bit - Interrupts go to general exception vector
+	# Clear software interrupts
+	mtc0	$0, $13			# C0_Cause
+#endif
+
+	# Set KSeg0 to cacheable
+        # Config.K0
+        mfc0    $10, $16
+        li      $11, 0x7
+        not     $11
+        and     $10, $11
+        or      $10, 0x3
+        mtc0    $10, $16
+
+        /*# Clear Count register*/
+        mtc0    $0, $9
+
+        /*# Set compare to -1 to delay 1st count=compare
+        # Also, clears timer interrupt*/
+        li      $10, -1
+        mtc0    $10, $11
+
+        mtc0    $0,$28
+
+        lui     $3,0x0000
+        ori     $4,$0,0x0010
+        ori     $5,$0,0x4000
+        ori     $6,$0,0x2000
+
+        /*
+
+ ************************************************************************
+ *         C O N F I G 1   R E G I S T E R   ( 1 6, SELECT 1 )          *
+ ************************************************************************
+ *
+ *  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+ *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |M|  MMU Size |  IS |  IL |  IA |  DS |  DL |  DA |Rsvd |W|C|E|F| Config1
+ * | |           |     |     |     |     |     |     |     |R|A|P|P|
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+	mfc0    $10, $16, 1             # .word 0x400a8001
+
+        # Isolate I$ Line Size
+        sll     $11, $10, 10
+        srl     $11, 29
+
+        # Skip ahead if No I$
+        beq     $11, $0, 10f
+HB
+/*        nop*/
+
+        li      $14, 2
+        sllv    $11, $14, $11           # Now have true I$ line size in bytes
+
+        sll     $12, $10, 7
+        srl     $12, 29
+        li      $14, 64
+        sllv    $12, $14, $12           # I$ Sets per way
+
+        sll     $13, $10, 13
+        srl     $13, 29                 # I$ Assoc (-1)
+        add     $13, 1
+        mul     $12, $12, $13           # Total number of sets
+
+        lui     $14, 0x8000             # Get a KSeg0 address for cacheops
+
+        # Clear TagLo/TagHi registers
+        mtc0    $0, $28
+        mtc0    $0, $29
+        mtc0    $0, $28, 2
+        mtc0    $0, $29, 2
+
+        move    $15, $12
+
+        # Index Store Tag Cache Op
+        # Will invalidate the tag entry, clear the lock bit, and clear the LRF bit
+1:      cache   0x8, 0($14)
+        add     $15, -1                 # Decrement set counter
+
+        bne     $15, $0, 1b
+        add     $14, $11                # Get next line address
+
+                # Now go through and invalidate the D$
+        # Now that the I$ has been flushed, the rest of the code can be
+        # moved to kseg0 and run from the cache to go faster
+10:
+
+	# Isolate D$ Line Size
+        sll     $11, $10, 19
+        srl     $11, 29
+
+        # Skip ahead if No D$
+        beq     $11, $0, 10f
+HB
+/*        nop*/
+
+        li      $14, 2
+        sllv    $11, $14, $11           # Now have true D$ line size in bytes
+
+        sll     $12, $10, 16
+        srl     $12, 29
+        li      $14, 64
+        sllv    $12, $14, $12           # D$ Sets per way
+
+        sll     $13, $10, 22
+        srl     $13, 29                 # D$ Assoc (-1)
+        add     $13, 1
+
+        mul     $12, $12, $13           # Get total number of sets
+
+        lui     $14, 0x8000             # Get a KSeg0 address for cacheops
+
+        # Clear TagLo/TagHi registers
+        mtc0    $0, $28
+        mtc0    $0, $29
+
+        move    $15, $12
+
+        # Index Store Tag Cache Op
+        # Will invalidate the tag entry, clear the lock bit, and clear the LRF bit
+1:      cache   0x9, 0($14)
+        add     $15, -1                 # Decrement set counter
+
+        bne     $15, $0, 1b
+        add     $14, $11                # Get next line address
+
+
+        # Now both caches have been flushed
+        # Initialize the TLB
+
+10:
+#if defined(VBG400_DO_TLB)
+	# Determine if we have a TLB
+        mfc0    $11, $16
+
+        sll     $11, 22
+        srl     $11, 29
+
+        li      $15, 0x1        # MT = 1  => TLB
+
+        bne     $11, $15, 15f
+HB
+/*        nop*/
+
+        mfc0    $10, $16, 1                     # .word 0x400a8001
+
+        sll     $11, $10, 1
+        srl     $11, 26         # Number of TLB entries (-1)
+
+        mtc0    $0, $2          # EntryLo0
+        mtc0    $0, $3          # EntryLo1
+        mtc0    $0, $5          # PageMask
+        mtc0    $0, $6          # Wired
+
+        li      $12, 0x80000000
+
+1:
+        mtc0    $11, $0         # Index register
+        mtc0    $12, $10        # EntryHi
+        ssnop                   #.word 0x00000040
+        ssnop                   #.word 0x00000040
+
+#debug trap - open remarks to stop code:
+#loop_for_ever:
+#bal loop_for_ever
+
+        TLBWI
+        add     $12, (2<<13)    # Add 8K to the address to avoid TLB conflict with previous entry
+
+        bne     $11, $0, 1b
+        add     $11, -1
+
+15:
+#endif
+	# Initialize other register files
+        # Good code should obviously not read registers before they are written
+        # so this is not not normally needed. But in simulation certain ways of initializing
+        # registers may not work (xor rN, rN, rN for one)
+
+        # check for the presence of shadow register sets
+        # first verify core is release 2 or higher
+        mfc0    $11, $16
+        sll     $11, 19
+        srl     $11, 29
+        beqz    $11, return
+HB
+/*        nop*/
+
+#define CPUNUM	$3
+#if 1
+#ifndef DO_NOT_CHECK_FOR_CMP
+
+#define GCMP	$8
+
+	# Determine if there is a coherency manager present.
+	# This address is the default configuration address.  If your
+	# system was configured with a different address, you must
+	# change this value.
+	li	GCMP, 0xbfbf8000	# KSEG1(GCMPBASE)
+	lw	$9, 0x0008(GCMP)	# GCR_BASE
+
+	addiu	$10, $0, 0x8000		# li r10, M_GCR_BASE_GCR_BASE (~0x7fff)
+	and	$9, $10
+
+	lui	$10, 0xa000		# KSEG1BASE
+	or	$10, $9
+
+	# This code uses $3 as the CPU number to make descisions about
+	# whether to execute code or not.  For CMP systems, we use the
+	# real CPU number.  For non-CMP, pretend the CPU number is zero
+	# to force the correct behavior.
+
+#loop_forever_before_copy:
+#bal loop_forever_before_copy
+	bne	$10, GCMP, nogcmp
+	move	CPUNUM, $0
+
+	# Change the CCA from non-coherent to coherent
+	# Assumption: GCMP => coherent CCA is usable
+	mfc0	$10, $16		# C0_Config
+
+	ext	$11, $10, 0, 3		# S_ConfigK0, W_ConfigK0
+	xori	$11, 3			# K_CacheAttrCN
+
+	bnez	$11, 1f
+	HB
+
+	li	$11, 5			# K_CacheAttrCCS
+	ins	$10, $11, 0, 3		# S_ConfigK0, W_ConfigK0
+
+	mtc0	$10, $16		# C0_Config
+1:
+	# Check the CPU number
+	mfc0	CPUNUM, $15, 1		# C0_EBase
+	ext	CPUNUM, CPUNUM, 0, 10	# S_EBaseCPUNum, W_EBaseCPUNum
+
+	# Only the Primary Core needs to initialise the Coherence Manager.
+	bnez	CPUNUM, 1f
+	HB
+
+	# Initialise CM
+	#
+	# Rewrite the GCR_BASE register to initialise CM_DEFAULT_TARGET
+	ins	$9, $0, 0, 2		# M_GCR_BASE_CM_DEFAULT_TARGET, S_GCR_BASE_CM_DEFAULT_TARGET
+	sw	$9, 0x0008(GCMP)	# GCR_BASE
+
+	# Disable the CM regions
+	lui	$9, 0xffff
+	sw	$9, 0x0090(GCMP)	# GCR_REG0_BASE
+	sw	$9, 0x0098(GCMP)	# GCR_REG0_MASK
+	sw	$9, 0x00a0(GCMP)	# GCR_REG1_BASE
+	sw	$9, 0x00a8(GCMP)	# GCR_REG1_MASK
+	sw	$9, 0x00b0(GCMP)	# GCR_REG2_BASE
+	sw	$9, 0x00b8(GCMP)	# GCR_REG2_MASK
+	sw	$9, 0x00c0(GCMP)	# GCR_REG3_BASE
+	sw	$9, 0x00c8(GCMP)	# GCR_REG3_MASK
+
+1:
+	# Allow interventions from all other cores (including self)
+	# For CPU 1 and higher, NOP if access not enabled in GCR_ACCESS.
+	li	$9, 0xff
+	sw	$9, 0x2008(GCMP)	# GCR_CL_COHERENCE
+	ehb
+
+#undef GCMP
+#endif	/* DO_NOT_CHECK_FOR_CMP */
+#endif	/* 0 */
+
+nogcmp:
+
+ 	/* Clear watch registers.
+	 */
+	mtc0	zero, CP0_WATCHLO   #done in watch handling above
+	mtc0	zero, CP0_WATCHHI
+
+/*#define VBG400_USE_RPS_E83_PATCH*/
+#define VBG400_ADD_UNCACHED_HERE
+
+	/* CONFIG7 register */
+	mfc0	k0, CP0_CONFIG, 7
+#ifdef VBG400_USE_RPS_E83_PATCH
+	li	k1, 4 /* Disable RPS due to E83 bug of 24KEC */
+	or	k0, k1
+#endif
+#ifdef VBG400_ADD_UNCACHED_HERE
+    li	k1, CONF_CM_UNCACHED
+    or	k0, k1
+#endif
+	mtc0	k0, CP0_CONFIG, 7
+	/* Init Timer */
+	mtc0	zero, CP0_COUNT
+	mtc0	zero, CP0_COMPARE
+
+#ifndef VBG400_ADD_UNCACHED_HERE
+	li	t0, CONF_CM_UNCACHED
+	mtc0	t0, CP0_CONFIG
+#endif
+
+#if 1
+#ifndef DO_NOT_CHECK_FOR_MT
+
+	# Config1 is required for MIPS32
+	mfc0	$8, $16, 1		# C0_Config1
+	bgez	$8, notmtcapable	# No Config2 register
+	HB
+
+	mfc0	$8, $16, 2		# C0_Config2
+	bgez	$8, notmtcapable	# No Config3 register
+	HB
+
+	mfc0	$8, $16, 3		# C0_Config3
+	and	$8, (1 << 2)		# M_Config3MT
+	beqz	$8, notmtcapable
+	HB
+
+	# This core supports MT ASE
+	#
+	# Start up secondary VPE's
+	.set	push
+	.set	mt
+
+startmtconfig:
+	# This is TC0 bound to VPE0.  Therefore VPEConf0.MVP is set.
+
+	# Enter config mode
+	mfc0	$8, $0, 1		# C0_MVPCtl
+	or	$8, (1 << 1)		# M_MVPCtlVPC
+	mtc0	$8, $0, 1		# C0_MVPCtl
+	ehb
+
+#define NTCS	$10
+#define NVPES	$11
+#define TC	$12
+
+	# Get number of TC's and VPE's
+	mfc0	$8, $0, 2		# C0_MVPConf0
+	ext	NTCS, $8, 0, 8		# S_MVPConf0PTC, W_MVPConf0PTC
+	ext	NVPES, $8, 10, 4	# S_MVPConf0PVPE, W_MVPConf0PVPE
+
+	# Initialise TC's/VPE's
+	move	TC, $0
+nexttc:
+	# Select TCn
+	mfc0	$8, $1, 1		# C0_VPECtl
+	ins	$8, TC, 0, 8		# S_VPECtlTargTC, W_VPECtlTargTC
+	mtc0	$8, $1, 1		# C0_VPECtl
+	ehb
+
+	# Bind TC to next VPE
+	beqz	TC, nextvpe		# Don't rebind TC0
+	HB
+
+	# Halt all TC's other than TC0
+	li	$8, 1			# M_TCHaltH
+	mttc0	$8, $2, 4		# C0_TCHalt
+	ehb
+
+	slt	$9, NVPES, TC
+	bnez	$9, 2f			# Bind spare TC's to VPElast
+	move	$9, NVPES
+
+	# Set XTC for active TC's
+	mftc0	$8, $1, 2		# C0_VPEConf0
+	ins	$8, TC, 21, 8		# S_VPEConf0XTC, W_VPEConf0XTC
+	mttc0	$8, $1, 2		# C0_VPEConf0
+
+	move	$9, TC
+2:
+	# Bind TC to a VPE
+	mftc0	$8, $2, 2		# C0_TCBind
+	ins	$8, $9, 0, 4		# S_TCBindCurVPE, W_TCBindCurVPE
+	mttc0	$8, $2, 2		# C0_TCBind
+
+	# Set up TCStatus register:
+	# Disable Coprocessor Usable bits
+	# Disable MDMX/DSP ASE
+	# Clear Dirty TC
+	# not dynamically allocatable
+	# not allocated
+	# Kernel mode
+	# interrupt exempt
+	# ASID 0
+	li	$8, (1 << 10)		# M_TCStatusIXMT
+	mttc0	$8, $2, 1		# C0_TCStatus
+
+#ifndef DO_NOT_INIT_GPRS
+
+	# Initialize the TC's register file
+	# should not be required with good software practices
+	mttgpr	$0, $1
+	mttgpr	$0, $2
+	mttgpr	$0, $3
+	mttgpr	$0, $4
+	mttgpr	$0, $5
+	mttgpr	$0, $6
+	mttgpr	$0, $7
+	mttgpr	$0, $8
+	mttgpr	$0, $9
+	mttgpr	$0, $10
+	mttgpr	$0, $11
+	mttgpr	$0, $12
+	mttgpr	$0, $13
+	mttgpr	$0, $14
+	mttgpr	$0, $15
+	mttgpr	$0, $16
+	mttgpr	$0, $17
+	mttgpr	$0, $18
+	mttgpr	$0, $19
+	mttgpr	$0, $20
+	mttgpr	$0, $21
+	mttgpr	$0, $22
+	mttgpr	$0, $23
+	mttgpr	$0, $24
+	mttgpr	$0, $25
+	mttgpr	$0, $26
+	mttgpr	$0, $27
+	mttgpr	$0, $28
+	mttgpr	$0, $29
+	mttgpr	$0, $30
+	mttgpr	$0, $31
+
+#endif /* DO_NOT_INIT_GPRS */
+
+nextvpe:
+	slt	$9, NVPES, TC
+	bnez	$9, donevpe		# No more VPE's
+	HB
+
+	# Disable multi-threading with TC's
+	mftc0	$8, $1, 1		# C0_VPECtl
+	ins	$8, $0, 15, 1		# S_VPECtlTE, W_VPECtlTE
+	mttc0	$8, $1, 1		# C0_VPECtl
+
+	beqz	TC, 1f
+	HB
+
+	# For VPE1..n
+	# Clear VPA and set master VPE
+	mftc0	$8, $1, 2		# C0_VPEConf0
+	ins	$8, $0, 0, 1		# S_VPEConf0VPA, W_VPEConf0VPA
+	or	$8, (1 << 1)		# M_VPEConf0MVP
+	mttc0	$8, $1, 2		# C0_VPEConf0
+
+	# Copy Status from the current TC to the target TC's Cop0 Status register
+	mfc0	$8, $12			# C0_Status
+	mttc0	$8, $12			# C0_Status
+
+#ifndef OTHER_VPE_EPC_ADDR
+#define OTHER_VPE_EPC_ADDR 0x12345678
+#endif
+	la	$8, OTHER_VPE_EPC_ADDR
+	mttc0	$8, $14			# C0_EPC
+
+	mttc0	$0, $13			# C0_Cause
+
+	mfc0	$8, $16			# C0_Config
+	mttc0	$8, $16			# C0_Config
+
+	mftc0	$8, $15, 1		# C0_EBase
+	ext	$8, $8, 0, 10		# S_EBaseCPUNum, W_EBaseCPUNum
+#loop_forever_before_copy:
+#bal loop_forever_before_copy
+	mttgpr	$8, CPUNUM
+
+	# Finally... arrange for other VPE's to continue from OTHER_VPE_TCRESTART_ADDR
+#ifndef OTHER_VPE_TCRESTART_ADDR
+#define OTHER_VPE_TCRESTART_ADDR 0x12345678
+#endif
+	la	$8, OTHER_VPE_TCRESTART_ADDR
+	mttc0	$8, $2, 3		# C0_TCRestart
+
+	# Yes.. this is undoing all of the work done above... :)
+	mftc0	$8, $2, 1		# C0_TCStatus
+	ins	$8, $0, 10, 1		# S_TCStatusIXMT, W_TCStatusIXMT
+	ori	$8, (1 << 13)		# M_TCStatusA
+	mttc0	$8, $2, 1		# C0_TCStatus
+
+	mttc0	$0, $2, 4		# C0_TCHalt
+
+	mftc0	$8, $1, 2		# C0_VPEConf0
+	ori	$8, 1			# M_VPEConf0VPA
+	mttc0	$8, $1, 2		# C0_VPEConf0
+1:
+
+donevpe:
+	addu	TC, 1
+	sltu	$9, NTCS, TC
+	beqz	$9, nexttc
+	HB
+
+	# Exit config mode
+	mfc0	$8, $0, 1		# C0_MVPCtl
+	ins	$8, $0, 1, 1		# S_MVPCtlVPC, W_MVPCtlVPC
+	mtc0	$8, $0, 1		# C0_MVPCtl
+	ehb
+
+#undef NTCS
+#undef NVPES
+#undef TC
+
+notmtcapable:
+
+#endif	/* DO_NOT_CHECK_FOR_MT */
+#endif	/* 0 */
+
+
+	/* Initialize $gp.
+	 */
+	bal	1f
+HB
+/*        nop*/
+	.word	_gp
+1:
+	lw	gp, 0(ra)
+
+	/* Set up temporary stack.
+	 */
+	li	t0, CONFIG_SYS_SDRAM_BASE + CFG_INIT_SP_OFFSET
+	la	sp, 0(t0)
+	la	t9, board_init_f
+	j	t9
+HB
+/*        nop*/
+
+return:
+        # At this point the chip has been initialized
+        # The address of the real code can be loaded into EPC
+        # An ERet will clear EXL and jump to EPC
+
+        la      $11, 0x80030120
+        mtc0    $11, $14
+        ssnop                   #.word 0x00000040
+        ssnop                   #.word 0x00000040
+        eret
+
+
+
+/*
+ * void relocate_code (addr_sp, gd, addr_moni)
+ *
+ * This "function" does not return, instead it continues in RAM
+ * after relocating the monitor code.
+ *
+ * a0 = addr_sp
+ * a1 = gd
+ * a2 = destination address
+ */
+	.globl	relocate_code
+	.ent	relocate_code
+relocate_code:
+	move	sp, a0		/* Set new stack pointer	*/
+
+	li	t0, CFG_MONITOR_BASE
+	la	t3, in_ram
+	lw	t2, -12(t3)	/* t2 <-- uboot_end_data	*/  //<<<<<------(a0100b64 t in_ram) (a012c3f0 A uboot_end_data)
+													//-12(t3) is NOT uboot_end_data !!!!??? it is declared 3 long before, but no in sys.map
+	move	t1, a2
+
+	/*
+	 * Fix $gp:
+	 *
+	 * New $gp = (Old $gp - CFG_MONITOR_BASE) + Destination Address
+	 */
+	move	t6, gp
+	sub	gp, CFG_MONITOR_BASE
+	add	gp, a2		/* gp now adjusted		*/
+	sub	t6, gp, t6	/* t6 <-- relocation offset	*/
+
+	sub	t4, t2, t0
+	move    t5, t1
+	/*
+	 * t0 = source address
+	 * t1 = target address
+	 * t2 = source end address
+	 */
+	/* On the purple board we copy the code earlier in a special way
+	 * in order to solve flash problems
+	 */
+
+#debug trap - open remarks to stop code:
+#loop_forever_before_copy:
+#bal loop_forever_before_copy
+
+1:
+	lw	t3, 0(t0)       /* relocated code loop here ! */
+	sw	t3, 0(t1)
+	addu	t0, 4
+	ble	t0, t2, 1b
+	addu	t1, 4		/* delay slot			*/
+
+	/* If caches were enabled, we would have to flush them here.
+	 */
+
+	/* Jump to where we've relocated ourselves.
+	 */
+	addi	t0, a2, in_ram - _start
+	j	t0
+HB
+/*	nop*/
+
+	.gpword	_GLOBAL_OFFSET_TABLE_	/* _GLOBAL_OFFSET_TABLE_ - _gp	*/
+#	.gpword	__got_start	/* _GLOBAL_OFFSET_TABLE_ - _gp	*/
+	.word	uboot_end_data
+	.word	uboot_end
+	.word	num_got_entries /*define in u-boot.lds*/
+
+in_ram:
+	/*
+	 * Now we want to update GOT.
+	 *
+	 * GOT[0] is reserved. GOT[1] is also reserved for the dynamic object
+	 * generated by GNU ld. Skip these reserved entries from relocation.
+	 */
+	lw	t3, -4(t0)	/* t3 <-- num_got_entries	*/
+	lw	t4, -16(t0)	/* t4 <-- (_GLOBAL_OFFSET_TABLE_ - _gp)	*/
+	add	t4, t4, gp	/* t4 now holds _GLOBAL_OFFSET_TABLE_	*/
+	addi	t4, t4, 8	/* Skipping first two entries.	*/
+	li	t2, 2
+1:
+	lw	t1, 0(t4)
+	beqz	t1, 2f
+	add	t1, t6		/*t6 hols the reloc offset*/
+	sw	t1, 0(t4)
+2:
+	addi	t2, 1
+	blt	t2, t3, 1b /* if t2 (++ in a loop) < t3 (num_got_entries) jump */
+	addi	t4, 4		/* delay slot			*/
+
+	/* Clear BSS.
+	 */
+	lw	t1, -12(t0)	/* t1 <-- uboot_end_data	*/
+	lw	t2, -8(t0)	/* t2 <-- uboot_end		*/
+	add	t1, t6		/* adjust pointers		*/
+	add	t2, t6
+
+	sub	t1, 4
+1:
+	addi	t1, 4
+	bltl	t1, t2, 1b
+	sw	zero, 0(t1)	/* delay slot			*/
+
+	move	a0, a1
+	la	t9, board_init_r
+	j	t9
+	move	a1, a2		/* delay slot			*/
+
+	.end	relocate_code
+
+	/* Exception handlers.
+	 */
+
+
+romReserved:
+	b	romReserved
+
+romExcHandle:
+	b	romExcHandle
diff --git a/arch/mips/cpu/vbg400/start_bootstrap.S b/arch/mips/cpu/vbg400/start_bootstrap.S
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/vbg400/start_bootstrap.S
@@ -0,0 +1,1486 @@
+/*
+ *  Startup Code for MIPS32 CPU-core
+ *
+ *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/cacheops.h>
+#include <asm/addrspace.h>
+#include <configs/vbg400.h>
+
+//turn off UBOOT_NO_MICRO if running uboot in ram (like using debugger)
+#define UBOOT_NO_MICRO
+
+# Select a Hazard Barrier
+
+#ifdef LIGHT_WEIGHT_HB
+#define HB nop
+#else
+#define HB ehb
+#endif
+#define CFG_BOOTSTRAP_CODE
+
+#define RVECENT(f,n) \
+   b f; nop
+#define XVECENT(f,bev) \
+   b f     ;           \
+   li k0,bev
+
+	.set noreorder
+#	.set noat
+	.set	mips32r2
+
+	.globl _start
+	.text
+_start:
+
+#loop_for_ever_start:
+#bal loop_for_ever_start
+
+	b conf_ddr
+
+to_start:
+	RVECENT(reset,0)	/* U-boot entry point */
+	RVECENT(reset,1)	/* software reboot */
+	RVECENT(romReserved,2)
+	RVECENT(romReserved,3)
+	RVECENT(romReserved,4)
+	RVECENT(romReserved,5)
+	RVECENT(romReserved,6)
+	RVECENT(romReserved,7)
+	RVECENT(romReserved,8)
+	RVECENT(romReserved,9)
+	RVECENT(romReserved,10)
+	RVECENT(romReserved,11)
+	RVECENT(romReserved,12)
+	RVECENT(romReserved,13)
+	RVECENT(romReserved,14)
+	RVECENT(romReserved,15)
+	RVECENT(romReserved,16)
+	RVECENT(romReserved,17)
+	RVECENT(romReserved,18)
+	RVECENT(romReserved,19)
+	RVECENT(romReserved,20)
+	RVECENT(romReserved,21)
+	RVECENT(romReserved,22)
+	RVECENT(romReserved,23)
+	RVECENT(romReserved,24)
+	RVECENT(romReserved,25)
+	RVECENT(romReserved,26)
+	RVECENT(romReserved,27)
+	RVECENT(romReserved,28)
+	RVECENT(romReserved,29)
+	RVECENT(romReserved,30)
+	RVECENT(romReserved,31)
+	RVECENT(romReserved,32)
+	RVECENT(romReserved,33)
+	RVECENT(romReserved,34)
+	RVECENT(romReserved,35)
+	RVECENT(romReserved,36)
+	RVECENT(romReserved,37)
+	RVECENT(romReserved,38)
+	RVECENT(romReserved,39)
+	RVECENT(romReserved,40)
+	RVECENT(romReserved,41)
+	RVECENT(romReserved,42)
+	RVECENT(romReserved,43)
+	RVECENT(romReserved,44)
+	RVECENT(romReserved,45)
+	RVECENT(romReserved,46)
+	RVECENT(romReserved,47)
+	RVECENT(romReserved,48)
+	RVECENT(romReserved,49)
+	RVECENT(romReserved,50)
+	RVECENT(romReserved,51)
+	RVECENT(romReserved,52)
+	RVECENT(romReserved,53)
+	RVECENT(romReserved,54)
+	RVECENT(romReserved,55)
+	RVECENT(romReserved,56)
+	RVECENT(romReserved,57)
+	RVECENT(romReserved,58)
+	RVECENT(romReserved,59)
+	RVECENT(romReserved,60)
+	RVECENT(romReserved,61)
+	RVECENT(romReserved,62)
+	RVECENT(romReserved,63)
+	XVECENT(romExcHandle,0x200)	/* bfc00200: R4000 tlbmiss vector */
+	RVECENT(romReserved,65)
+	RVECENT(romReserved,66)
+	RVECENT(romReserved,67)
+	RVECENT(romReserved,68)
+	RVECENT(romReserved,69)
+	RVECENT(romReserved,70)
+	RVECENT(romReserved,71)
+	RVECENT(romReserved,72)
+	RVECENT(romReserved,73)
+	RVECENT(romReserved,74)
+	RVECENT(romReserved,75)
+	RVECENT(romReserved,76)
+	RVECENT(romReserved,77)
+	RVECENT(romReserved,78)
+	RVECENT(romReserved,79)
+	XVECENT(romExcHandle,0x280)	/* bfc00280: R4000 xtlbmiss vector */
+	RVECENT(romReserved,81)
+	RVECENT(romReserved,82)
+	RVECENT(romReserved,83)
+	RVECENT(romReserved,84)
+	RVECENT(romReserved,85)
+	RVECENT(romReserved,86)
+	RVECENT(romReserved,87)
+	RVECENT(romReserved,88)
+	RVECENT(romReserved,89)
+	RVECENT(romReserved,90)
+	RVECENT(romReserved,91)
+	RVECENT(romReserved,92)
+	RVECENT(romReserved,93)
+	RVECENT(romReserved,94)
+	RVECENT(romReserved,95)
+	XVECENT(romExcHandle,0x300)	/* bfc00300: R4000 cache vector */
+	RVECENT(romReserved,97)
+	RVECENT(romReserved,98)
+	RVECENT(romReserved,99)
+	RVECENT(romReserved,100)
+	RVECENT(romReserved,101)
+	RVECENT(romReserved,102)
+	RVECENT(romReserved,103)
+	RVECENT(romReserved,104)
+	RVECENT(romReserved,105)
+	RVECENT(romReserved,106)
+	RVECENT(romReserved,107)
+	RVECENT(romReserved,108)
+	RVECENT(romReserved,109)
+	RVECENT(romReserved,110)
+	RVECENT(romReserved,111)
+	XVECENT(romExcHandle,0x380)	/* bfc00380: R4000 general vector */
+	RVECENT(romReserved,113)
+	RVECENT(romReserved,114)
+	RVECENT(romReserved,115)
+	RVECENT(romReserved,116)
+	RVECENT(romReserved,116)
+	RVECENT(romReserved,118)
+	RVECENT(romReserved,119)
+	RVECENT(romReserved,120)
+	RVECENT(romReserved,121)
+	RVECENT(romReserved,122)
+	RVECENT(romReserved,123)
+	RVECENT(romReserved,124)
+	RVECENT(romReserved,125)
+	RVECENT(romReserved,126)
+	RVECENT(romReserved,127)
+
+	/* We hope there are no more reserved vectors!
+	 * 128 * 8 == 1024 == 0x400
+	 * so this is address R_VEC+0x400 == 0xbfc00400
+	 */
+	.align 4
+
+    b bypass_ddr
+
+/***** set DDR ***********************************************************************/
+conf_ddr:
+
+/*nop*/
+HB
+
+#include "gen3_reg_depot.s"
+#include "npu_memory_map.s"
+#include "sys_if_map.s"
+
+/*CONFIG_VBG400_CHIP setting is done via config mechanism*/
+#ifdef CONFIG_VBG400_CHIPIT
+	#include "denali_reg_defines_fpga.s"
+#else
+	#ifdef CONFIG_VBG400_DDR_8BIT
+	#define k4t51163qj_e6_8	/*TODO: file not exist yet */
+	#else
+	#define k4t51163qj_f8
+	/*#define k4t51163qj_e6*/
+	#endif
+	#include "denali_reg_defines.s"
+#endif /*0*/
+
+#loop_for_ever_ddr:
+#bal loop_for_ever_ddr
+
+#if 1
+	/**** test if DDR configured already ********
+    * first read gen3_shrd_clock_enable_reg to verify it is not in reset.
+    * If it is confirmed {
+    * 	read the ready bit
+    *   if ready bit is ok
+    * 	  ddr already configured, skip configuration and code copy from (flash to ram)
+    *   else
+    *     configure the ddr and copy code to ddr
+    * }
+    * else {
+    *   enable access to clock enables and soft resets
+    *   configure the ddr and copy code to ddr
+    * }
+	*/
+    
+    lui     $10, SHARED_REG_BASE_ADDR
+	
+	/*test if out of reset - can't access phy if in reset, exception result*/
+    lw      $15, gen3_shrd_clock_enable_reg($10)
+	#bne     $15,0x0000000f,conf_ddr_now
+
+    li      $16, 0x0000000f
+    and     $15, $16, $15
+	bne     $15,0x0000000f,conf_ddr_now
+HB
+/*	nop
+	nop
+*/
+    lui     $10, DDR_CSR_BASE_ADDR
+
+    /* test that PHY has initialized- if not, never configured or error in configuration
+       test bit 20 (init complete) of reg 44 */
+    lw      $15, 0x70($10)
+    li      $16, 0x00100000
+    and     $15, $16, $15
+	beq     $15,$0,conf_ddr_now
+HB
+/*	nop
+	nop
+*/
+    #ddr ready
+
+	b bypass_ddr
+HB
+/*	nop*/
+	/**** end of ddr test ********/
+#endif
+
+conf_ddr_now:
+nop
+
+#loop_for_ever_efuse:
+#nop
+#bal loop_for_ever_efuse
+
+#ifdef WAVE400_READ_EFUSE
+/* eFuse handling done in assembly as well as in c code.
+Assembly code is tested. C code rewrite the assembly in order to have simpler and clear code.
+use compilation switch to select.
+*/
+#ifdef WAVE400_USE_ASSEMBLY_EFUSE
+    #include "red_fix_loading_and_rm_loading.s"
+#else
+	/* Initialize $gp before it is used in jump
+	 */
+	bal	1f
+HB
+/*	nop*/
+	.word	_gp
+1:
+	lw	gp, 0(ra)
+	nop
+.set noat
+    la      ra, return_from_efuse
+    nop
+    b       read_efuse
+HB
+/*	nop*/
+return_from_efuse:
+.set at
+#endif /*WAVE400_USE_ASSEMBLY_EFUSE*/
+#endif /*WAVE400_READ_EFUSE*/
+
+#ifndef CONFIG_VBG400_CHIPIT
+	/*start_clock.s configs the pll, need to define mips24k (TODO: or change file !)*/
+	#define mips24k
+.set reorder
+	#include "start_clock.s"
+.set noreorder
+#endif
+
+	.equ axi0_priority0_relative ,8
+	.equ axi0_priority1_relative ,16
+	.equ axi0_priority2_relative ,24
+   .equ axi0_priority3_relative ,0
+	.equ axi0_priority4_relative ,8
+	.equ axi0_priority5_relative ,16
+	.equ axi0_priority6_relative ,24
+	.equ axi0_priority7_relative ,0
+
+
+	.equ axi1_priority0_relative ,0
+	.equ axi1_priority1_relative ,8
+	.equ axi1_priority2_relative ,16
+   .equ axi1_priority3_relative ,24
+	.equ axi1_priority4_relative ,0
+	.equ axi1_priority5_relative ,8
+	.equ axi1_priority6_relative ,16
+	.equ axi1_priority7_relative ,24
+
+	.equ axi2_priority0_relative ,24
+	.equ axi2_priority1_relative ,0
+	.equ axi2_priority2_relative ,8
+   .equ axi2_priority3_relative ,16
+	.equ axi2_priority4_relative ,24
+	.equ axi2_priority5_relative ,0
+	.equ axi2_priority6_relative ,8
+	.equ axi2_priority7_relative ,16
+
+	.equ axi3_priority0_relative ,16
+	.equ axi3_priority1_relative ,24
+	.equ axi3_priority2_relative ,0
+   .equ axi3_priority3_relative ,8
+	.equ axi3_priority4_relative ,16
+	.equ axi3_priority5_relative ,24
+	.equ axi3_priority6_relative ,0
+	.equ axi3_priority7_relative ,8
+
+	.equ axi4_priority0_relative ,16
+	.equ axi4_priority1_relative ,24
+	.equ axi4_priority2_relative ,0
+   .equ axi4_priority3_relative ,8
+	.equ axi4_priority4_relative ,16
+	.equ axi4_priority5_relative ,24
+	.equ axi4_priority6_relative ,0
+	.equ axi4_priority7_relative ,8
+
+	.equ axi5_priority0_relative ,16
+	.equ axi5_priority1_relative ,24
+	.equ axi5_priority2_relative ,0
+   .equ axi5_priority3_relative ,8
+	.equ axi5_priority4_relative ,16
+	.equ axi5_priority5_relative ,24
+	.equ axi5_priority6_relative ,0
+	.equ axi5_priority7_relative ,8
+
+
+	.equ age_count ,0
+	.equ command_age_count ,8
+     // bb priority to ddr 
+	.equ axi2_r_priority,24
+	.equ axi2_w_priority,0
+     // npu  priority to ddr 
+	.equ axi5_r_priority,24
+	.equ axi5_w_priority,0
+
+#/* Configure clocks */
+
+        lui     $10, SHARED_REG_BASE_ADDR
+
+#        /* Enable access to clock enables and soft resets. */
+        li      $15, 0x0003
+        sw      $15, gen3_shrd_safety_reg($10)
+                
+#        /* Next enable all of the disabled clock networks */
+        lui     $15, 0x0000
+        ori     $15, 0x00ff 
+        sw      $15, gen3_shrd_clock_enable_reg($10)
+
+#        /* Set the GMAC interface mode before taking it out of reset. */
+#        /* Set the top level basic mode configuration register */
+        lw      $15, gen3_shrd_basic_mode_config_reg($10)
+        lui     $16,0xffff
+        ori     $16,0xfffe
+        and     $15,$15,$16
+        sw      $15, gen3_shrd_basic_mode_config_reg($10)
+ 
+#        /* Now take all of the blocks out of reset  */
+        lui     $15, 0x0001
+        ori     $15, 0xffff
+        sw      $15, gen3_shrd_soft_reset_reg($10)
+
+#        /* Disable access to clock enables and soft resets. */
+        lui     $15, 0x0000
+        sw      $15, gen3_shrd_safety_reg($10)
+#/* Configure DDR */
+        lui     $10, DDR_CSR_BASE_ADDR
+
+        li      $15, DENALI_CTL_00_DATA
+        sw      $15, 0x0000($10)
+
+        li      $15, DENALI_CTL_01_DATA
+        sw      $15, 0x0004($10)
+
+        li      $15, DENALI_CTL_02_DATA
+        sw      $15, 0x0008($10)
+
+        li      $15, DENALI_CTL_03_DATA
+        sw      $15, 0x000c($10)
+
+        li      $15, DENALI_CTL_04_DATA
+        sw      $15, 0x0010($10)
+
+        li      $15, DENALI_CTL_05_DATA
+        sw      $15, 0x0014($10)
+
+        li      $15, DENALI_CTL_06_DATA
+        sw      $15, 0x0018($10)
+
+        li      $15, DENALI_CTL_07_DATA
+        sw      $15, 0x001c($10)
+
+        li      $15, DENALI_CTL_08_DATA
+        sw      $15, 0x0020($10)
+
+        li      $15, DENALI_CTL_09_DATA
+        sw      $15, 0x0024($10)
+
+        li      $15, DENALI_CTL_10_DATA
+        sw      $15, 0x0028($10)
+
+        li      $15, DENALI_CTL_11_DATA
+        sw      $15, 0x002c($10)
+
+        li      $15, DENALI_CTL_12_DATA
+        sw      $15, 0x0030($10)
+
+        li      $15, DENALI_CTL_13_DATA
+        sw      $15, 0x0034($10)
+
+        li      $15, DENALI_CTL_14_DATA
+        sw      $15, 0x0038($10)
+
+        li      $15, DENALI_CTL_15_DATA
+        sw      $15, 0x003c($10)
+
+        li      $15, DENALI_CTL_16_DATA
+        sw      $15, 0x0040($10)
+
+        li      $15, DENALI_CTL_17_DATA
+        sw      $15, 0x0044($10)
+
+        li      $15, DENALI_CTL_18_DATA
+        sw      $15, 0x0048($10)
+
+        li      $15, DENALI_CTL_19_DATA
+        sw      $15, 0x004c($10)
+
+        li      $15, DENALI_CTL_20_DATA
+        sw      $15, 0x0050($10)
+
+        li      $15, DENALI_CTL_21_DATA
+        sw      $15, 0x0054($10)
+
+        li      $15, DENALI_CTL_22_DATA
+        sw      $15, 0x0058($10)
+
+        li      $15, DENALI_CTL_23_DATA
+        sw      $15, 0x005c($10)
+
+        li      $15, DENALI_CTL_24_DATA
+        sw      $15, 0x0060($10)
+   // a*a=100 clk is max wait before command priority goes higher 
+        li      $15, (DENALI_CTL_25_DATA & ~(0x1f<<age_count) & ~(0x1f<<command_age_count) )  | 0xa<< age_count  | 0xa<< command_age_count
+        sw      $15, 0x0064($10)
+
+        li      $15, DENALI_CTL_26_DATA
+        sw      $15, 0x0068($10)
+
+        li      $15, DENALI_CTL_27_DATA
+        sw      $15, 0x006c($10)
+
+        li      $15, DENALI_CTL_28_DATA
+        sw      $15, 0x0070($10)
+
+        li      $15, DENALI_CTL_29_DATA
+        sw      $15, 0x0074($10)
+
+        li      $15, DENALI_CTL_30_DATA
+        sw      $15, 0x0078($10)
+
+        li      $15, DENALI_CTL_31_DATA
+        sw      $15, 0x007c($10)
+
+        li      $15, DENALI_CTL_32_DATA
+        sw      $15, 0x0080($10)
+
+        li      $15, DENALI_CTL_33_DATA
+        sw      $15, 0x0084($10)
+
+        li      $15, DENALI_CTL_34_DATA
+        sw      $15, 0x0088($10)
+
+        li      $15, DENALI_CTL_35_DATA
+        sw      $15, 0x008c($10)
+
+        li      $15, DENALI_CTL_36_DATA
+        sw      $15, 0x0090($10)
+
+        li      $15, DENALI_CTL_37_DATA
+        sw      $15, 0x0094($10)
+
+        li      $15, DENALI_CTL_38_DATA
+        sw      $15, 0x0098($10)
+
+        li      $15, DENALI_CTL_39_DATA
+        sw      $15, 0x009c($10)
+
+        li      $15, DENALI_CTL_40_DATA
+        sw      $15, 0x00a0($10)
+
+        li      $15, (DENALI_CTL_41_DATA & ~(0x7<<axi2_r_priority)) | 2<<axi2_r_priority
+        sw      $15, 0x00a4($10)
+
+        li      $15, (DENALI_CTL_42_DATA & ~(0x7<<axi2_w_priority)) | 2<<axi2_w_priority 
+        sw      $15, 0x00a8($10)
+
+        li      $15, DENALI_CTL_43_DATA
+        sw      $15, 0x00ac($10)
+
+        li      $15, DENALI_CTL_44_DATA
+        sw      $15, 0x00b0($10)
+
+        li      $15, (DENALI_CTL_45_DATA & ~(0x7<<axi5_r_priority)) | 2<<axi5_r_priority
+        sw      $15, 0x00b4($10)
+
+        li      $15, (DENALI_CTL_46_DATA & ~(0x7<<axi2_w_priority)) | 2<<axi2_w_priority 
+        sw      $15, 0x00b8($10)
+
+	
+        li      $15, (DENALI_CTL_47_DATA  & ~(0xf<<axi0_priority0_relative) & ~(0xf<<axi0_priority1_relative) & ~(0xf<<axi0_priority2_relative))  | 2<< axi0_priority0_relative  | 1<< axi0_priority1_relative  | 1<<axi0_priority2_relative 
+        sw      $15, 0x00bc($10)
+
+        li      $15, (DENALI_CTL_48_DATA  & ~(0xf<<axi0_priority3_relative) & ~(0xf<<axi0_priority4_relative) & ~(0xf<<axi0_priority5_relative)& ~(0xf<<axi0_priority6_relative))  | 1<< axi0_priority3_relative  | 1<< axi0_priority4_relative  | 1<<axi0_priority5_relative | 1<<axi0_priority6_relative 
+ 
+        sw      $15, 0x00c0($10)
+
+        li      $15, (DENALI_CTL_49_DATA  & ~(0xf<<axi0_priority7_relative)) | 1<< axi0_priority7_relative 
+        sw      $15, 0x00c4($10)
+
+        li      $15, (DENALI_CTL_50_DATA  & ~(0xf<<axi1_priority0_relative) & ~(0xf<<axi1_priority1_relative) & ~(0xf<<axi1_priority2_relative)& ~(0xf<<axi1_priority3_relative))  | 3<< axi1_priority0_relative  | 1<< axi1_priority1_relative  | 1<<axi1_priority2_relative | 1<<axi1_priority3_relative 
+
+        sw      $15, 0x00c8($10)
+
+        li      $15, (DENALI_CTL_51_DATA  & ~(0xf<<axi1_priority4_relative) & ~(0xf<<axi1_priority5_relative) & ~(0xf<<axi1_priority6_relative)& ~(0xf<<axi1_priority7_relative))  | 1<< axi1_priority4_relative  | 1<< axi1_priority5_relative  | 1<<axi1_priority6_relative | 1<<axi1_priority7_relative  
+        sw      $15, 0x00cc($10)
+
+        li      $15, (DENALI_CTL_52_DATA  & ~(0xf<<axi2_priority0_relative)) | 4<< axi2_priority0_relative 
+        sw      $15, 0x00d0($10)
+
+        li      $15, (DENALI_CTL_53_DATA  & ~(0xf<<axi2_priority1_relative) & ~(0xf<<axi2_priority2_relative) & ~(0xf<<axi2_priority3_relative)& ~(0xf<<axi2_priority4_relative))  | 1<< axi2_priority1_relative  | 1<< axi2_priority2_relative  | 1<<axi2_priority3_relative | 1<<axi2_priority4_relative
+        sw      $15, 0x00d4($10)
+
+        li      $15, (DENALI_CTL_54_DATA  & ~(0xf<<axi2_priority5_relative) & ~(0xf<<axi2_priority6_relative) & ~(0xf<<axi2_priority7_relative))  | 1<< axi2_priority5_relative  | 1<< axi2_priority6_relative  | 1<<axi2_priority7_relative 
+        sw      $15, 0x00d8($10)
+
+        li      $15, (DENALI_CTL_55_DATA  & ~(0xf<<axi3_priority0_relative) & ~(0xf<<axi3_priority1_relative) )  | 2<< axi3_priority0_relative  | 1<< axi3_priority1_relative  
+        sw      $15, 0x00dc($10)
+
+        li      $15, (DENALI_CTL_56_DATA  & ~(0xf<<axi3_priority2_relative) & ~(0xf<<axi3_priority3_relative) & ~(0xf<<axi3_priority4_relative)& ~(0xf<<axi3_priority5_relative))  | 1<< axi3_priority2_relative  | 1<< axi3_priority3_relative  | 1<<axi3_priority4_relative | 1<<axi3_priority5_relative  
+        sw      $15, 0x00e0($10)
+
+        li      $15, (DENALI_CTL_57_DATA   & ~(0xf<<axi3_priority6_relative) & ~(0xf<<axi3_priority7_relative) )  | 1<< axi3_priority6_relative  | 1<< axi3_priority7_relative  
+        sw      $15, 0x00e4($10)
+
+        li      $15, (DENALI_CTL_58_DATA   & ~(0xf<<axi4_priority0_relative) & ~(0xf<<axi4_priority1_relative) )  | 3<< axi4_priority0_relative  | 1<< axi4_priority1_relative  
+        sw      $15, 0x00e8($10)
+
+        li      $15, (DENALI_CTL_59_DATA   & ~(0xf<<axi4_priority2_relative) & ~(0xf<<axi4_priority3_relative) & ~(0xf<<axi4_priority4_relative)& ~(0xf<<axi4_priority5_relative))  | 1<< axi4_priority2_relative  | 1<< axi4_priority3_relative  | 1<<axi4_priority4_relative | 1<<axi4_priority5_relative 
+        sw      $15, 0x00ec($10)
+
+        li      $15, (DENALI_CTL_60_DATA   & ~(0xf<<axi4_priority6_relative) & ~(0xf<<axi4_priority7_relative) )  | 1<< axi4_priority6_relative  | 1<< axi4_priority7_relative   
+        sw      $15, 0x000f0($10)
+
+        li      $15, (DENALI_CTL_61_DATA   & ~(0xf<<axi5_priority0_relative) & ~(0xf<<axi5_priority1_relative) )  | 4<< axi5_priority0_relative  | 1<< axi5_priority1_relative   
+        sw      $15, 0x000f4($10)
+
+        li      $15, (DENALI_CTL_62_DATA   & ~(0xf<<axi5_priority2_relative) & ~(0xf<<axi5_priority3_relative) & ~(0xf<<axi5_priority4_relative)& ~(0xf<<axi5_priority5_relative))  | 1<< axi5_priority2_relative  | 1<< axi5_priority3_relative  | 1<<axi5_priority4_relative | 1<<axi5_priority5_relative  
+        sw      $15, 0x00f8($10)
+
+        li      $15, (DENALI_CTL_63_DATA   & ~(0xf<<axi5_priority6_relative) & ~(0xf<<axi5_priority7_relative) )  | 1<< axi5_priority6_relative  | 1<< axi5_priority7_relative
+        sw      $15, 0x00fc($10)
+
+        li      $15, DENALI_CTL_64_DATA
+        sw      $15, 0x0100($10)
+
+        li      $15, DENALI_CTL_65_DATA
+        sw      $15, 0x0104($10)
+
+        li      $15, DENALI_CTL_66_DATA
+        sw      $15, 0x0108($10)
+
+        li      $15, DENALI_CTL_67_DATA
+        sw      $15, 0x010c($10)
+
+        li      $15, DENALI_CTL_68_DATA
+        sw      $15, 0x0110($10)
+
+        li      $15, DENALI_CTL_69_DATA
+        sw      $15, 0x0114($10)
+
+        li      $15, DENALI_CTL_70_DATA
+        sw      $15, 0x0118($10)
+
+        li      $15, DENALI_CTL_71_DATA
+        sw      $15, 0x011c($10)
+
+        li      $15, DENALI_CTL_72_DATA
+        sw      $15, 0x0120($10)
+
+        li      $15, DENALI_CTL_73_DATA
+        sw      $15, 0x0124($10)
+
+
+	
+#ifdef CONFIG_VBG400_CHIPIT
+	li      $15, DENALI_PHY_00_DATA
+#else
+	li      $15, DENALI_PHY_00_DATA | 3<<13
+#endif
+        sw      $15, 0x0200($10)
+
+        li      $15, DENALI_PHY_01_DATA
+        sw      $15, 0x0204($10)
+
+	li      $15, DENALI_PHY_02_DATA
+        sw      $15, 0x0208($10)
+
+	li      $15, DENALI_PHY_03_DATA
+        sw      $15, 0x020c($10)
+
+
+	li      $15, DENALI_PHY_04_DATA
+        sw      $15, 0x0210($10)
+
+        li      $15, DENALI_PHY_05_DATA
+        sw      $15, 0x0214($10)
+
+	li      $15, DENALI_PHY_06_DATA
+        sw      $15, 0x0218($10)
+
+	li      $15, DENALI_PHY_07_DATA
+        sw      $15, 0x021c($10)
+
+	li      $15, DENALI_PHY_08_DATA
+        sw      $15, 0x0220($10)
+
+        li      $15, DENALI_PHY_09_DATA
+        sw      $15, 0x0224($10)
+
+ #  /* set the start bit of the DDR controller */
+        /*  addressing reg 00 */
+        lw      $15, 0x0000($10)
+        li     $16, 0x0001
+        or      $15,$15,$16
+        sw      $15, 0x0000($10)
+	  
+  #  /* wait until PHY has initialized */
+        /* test bit 20 (init complete) of reg 28 */
+wait_ddr_rdy:
+        lw      $15, 0x70($10)
+        li      $16, 0x00100000
+        and     $15, $16, $15
+	    beq     $15,$0,wait_ddr_rdy
+HB
+/*	nop*/
+
+        #ddr ready, continue
+
+#loop_for_ever_ddr_ready:
+#nop
+#nop
+#bal loop_for_ever_ddr_ready
+
+
+		/*copy to DDR */
+        /* Source address in FLASH:    offset 0x00000000, actually 0xBFC00000 */
+        li     t0, CFG_FLASH_BASE_HW
+        /*Destination address in DDR: offset 0x00100000 */
+        li     t1, CONFIG_BOOTSTRAP_TEXT_BASE  
+        /* max size of u-boot, feet to 1 sector in flash. can be modify to real size */
+        li     a2, 0x10000
+        or     a2, a2, CONFIG_BOOTSTRAP_TEXT_BASE #stop condition (TEXT_BASE)
+
+1:
+        lw	t3, 0(t0)
+#ifdef VALIDATE_DDR
+		/*calc checksum*/
+        xor     t4,t4,t3
+#endif
+        sw	t3, 0(t1)
+        addu	t0, 4
+        bne	t1, a2, 1b
+        addu	t1, 4        /* delay slot			*/
+        /*end copy */
+
+#ifdef VALIDATE_DDR
+        /* calc ddr checksum */
+        li      t1,CONFIG_BOOTSTRAP_TEXT_BASE   #point to start of code in DDR
+checksum:
+		lw      t3,0x0000(t1)   #load word
+        xor     t5,t5,t3        #calc ckecksum
+        addi    t1,+4
+        bne     a2,t1,checksum  #more code?
+HB
+/*	nop*/
+        /* if checksum error, loop forever (or print to uart) */
+checksum_err:
+        bne     t4,t5,checksum_err
+nop
+#endif
+
+        /* Jump to where we've relocated ourselves.
+         */
+        li     t0, CONFIG_BOOTSTRAP_TEXT_BASE
+        addi	t0, t0, to_start - _start #_start=go to conf ddr, to_start=after conf ddr, t0 points to 'reset:'
+		and     t0, t0, 0xFFFFFFFC
+        j	t0
+HB
+/*	nop*/
+
+
+/**** End set DDR *******************************************************************/
+bypass_ddr:
+
+#loop_for_ever_reset:
+#bal loop_for_ever_reset
+
+reset:
+	        /*# Initialize the register file*/
+        or      $1,$0, $0
+        or      $2,$0, $0
+        or      $3,$0, $0
+        or      $4,$0, $0
+        or      $5,$0, $0
+        or      $6,$0, $0
+        or      $7,$0, $0
+        or      $8,$0, $0
+        or      $9,$0, $0
+        or      $10,$0, $0
+        or      $11,$0, $0
+        or      $12,$0, $0
+        or      $13,$0, $0
+        or      $14,$0, $0
+        or      $15,$0, $0
+        or      $16,$0, $0
+        or      $17,$0, $0
+        or      $18,$0, $0
+        or      $19,$0, $0
+        or      $20,$0, $0
+        or      $21,$0, $0
+        or      $22,$0, $0
+        or      $23,$0, $0
+        or      $24,$0, $0
+        or      $25,$0, $0
+        or      $26,$0, $0
+        or      $27,$0, $0
+        or      $28,$0, $0
+        or      $31,$0, $0
+        or      $30,$0, $0
+
+        /*#now set 0 to all shadow file GPRs*/
+        /* TO DO */
+
+        /*# Clear interrupts mask bits*/
+        mfc0    $10, CP0_STATUS        
+        li      $11, 0xffff00fe /*clear IE and IM7-0 bits*/
+        and     $10, $11        
+        mtc0    $10, CP0_STATUS        
+
+	    /* CAUSE register */
+	    mtc0	zero, CP0_CAUSE
+
+        # Check the presence of additional Watch registers 
+	li	$11, 0x7		# (M_WatchHiI | M_WatchHiR | M_WatchHiW)
+	mtc0	$11, $19		# C0_WatchHi
+        ehb
+	mfc0	$11, $19		# C0_WatchHi
+        srl     $11, $11, 31
+        beq     $11, $0, 1f 
+
+	li	$11, 0x7		
+
+	# Disable watch exceptions
+	mtc0	$0, $18, 1		# C0_WatchLo1
+	mtc0	$0, $18, 2		# C0_WatchLo2
+	mtc0	$0, $18, 3		# C0_WatchLo3
+
+	# Clear Watch Status bits
+	mtc0	$11, $19, 1		# C0_WatchHi1
+	mtc0	$11, $19, 2		# C0_WatchHi2
+	mtc0	$11, $19, 3		# C0_WatchHi3
+
+1:      # There is only one set of Watch register pair
+	# Disable watch exceptions
+	mtc0	$0, $18			# C0_WatchLo
+
+	# Clear Watch Status bits
+	mtc0	$11, $19		# C0_WatchHi
+
+	# Clear WP bit to avoid watch exception upon user code entry
+	# Clear IV bit - Interrupts go to general exception vector
+	# Clear software interrupts
+	mtc0	$0, $13			# C0_Cause
+
+	# Set KSeg0 to cacheable
+    # Config.K0
+    mfc0    $10, $16
+    li      $11, 0x7
+    not     $11
+    and     $10, $11
+    or      $10, 0x3
+    mtc0    $10, $16
+
+    /*# Clear Count register*/
+    mtc0    $0, $9
+
+    /*# Set compare to -1 to delay 1st count=compare
+    # Also, clears timer interrupt*/
+    li      $10, -1
+    mtc0    $10, $11
+
+    mtc0    $0,$28
+
+    lui     $3,0x0000
+    ori     $4,$0,0x0010
+    ori     $5,$0,0x4000
+    ori     $6,$0,0x2000
+
+    /*
+
+ ************************************************************************
+ *         C O N F I G 1   R E G I S T E R   ( 1 6, SELECT 1 )          *
+ ************************************************************************
+ *
+ *  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+ *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |M|  MMU Size |  IS |  IL |  IA |  DS |  DL |  DA |Rsvd |W|C|E|F| Config1
+ * | |           |     |     |     |     |     |     |     |R|A|P|P|
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+	mfc0    $10, $16, 1             # .word 0x400a8001
+
+        # Isolate I$ Line Size
+        sll     $11, $10, 10
+        srl     $11, 29
+
+        # Skip ahead if No I$
+        beq     $11, $0, 10f
+/*        nop*/
+HB
+
+        li      $14, 2
+        sllv    $11, $14, $11           # Now have true I$ line size in bytes
+
+        sll     $12, $10, 7
+        srl     $12, 29
+        li      $14, 64
+        sllv    $12, $14, $12           # I$ Sets per way
+
+        sll     $13, $10, 13
+        srl     $13, 29                 # I$ Assoc (-1)
+        add     $13, 1
+        mul     $12, $12, $13           # Total number of sets
+
+        lui     $14, 0x8000             # Get a KSeg0 address for cacheops
+
+        # Clear TagLo/TagHi registers
+        mtc0    $0, $28
+        mtc0    $0, $29
+        mtc0    $0, $28, 2
+        mtc0    $0, $29, 2
+
+        move    $15, $12
+
+        # Index Store Tag Cache Op
+        # Will invalidate the tag entry, clear the lock bit, and clear the LRF bit
+1:      cache   0x8, 0($14)
+        add     $15, -1                 # Decrement set counter
+
+        bne     $15, $0, 1b
+        add     $14, $11                # Get next line address
+
+nop
+#loop_for_ever_cache_end:
+#bal loop_for_ever_cache_end
+
+        # Now go through and invalidate the D$
+        # Now that the I$ has been flushed, the rest of the code can be
+        # moved to kseg0 and run from the cache to go faster
+10:
+
+	# Isolate D$ Line Size
+        sll     $11, $10, 19
+        srl     $11, 29
+
+        # Skip ahead if No D$
+        beq     $11, $0, 10f
+        nop
+
+        li      $14, 2
+        sllv    $11, $14, $11           # Now have true D$ line size in bytes
+
+        sll     $12, $10, 16
+        srl     $12, 29
+        li      $14, 64
+        sllv    $12, $14, $12           # D$ Sets per way
+
+        sll     $13, $10, 22
+        srl     $13, 29                 # D$ Assoc (-1)
+        add     $13, 1
+
+        mul     $12, $12, $13           # Get total number of sets
+
+        lui     $14, 0x8000             # Get a KSeg0 address for cacheops
+
+        # Clear TagLo/TagHi registers
+        mtc0    $0, $28
+        mtc0    $0, $29
+
+        move    $15, $12
+
+        # Index Store Tag Cache Op
+        # Will invalidate the tag entry, clear the lock bit, and clear the LRF bit
+1:      cache   0x9, 0($14)
+        add     $15, -1                 # Decrement set counter
+
+        bne     $15, $0, 1b
+        add     $14, $11                # Get next line address
+
+nop
+#loop_for_ever_cache_end_2:
+#bal loop_for_ever_cache_end_2
+
+        # Now both caches have been flushed
+        # Initialize the TLB
+
+10:
+#if defined(VBG400_DO_TLB)
+	# Determine if we have a TLB
+        mfc0    $11, $16
+
+        sll     $11, 22
+        srl     $11, 29
+
+        li      $15, 0x1        # MT = 1  => TLB
+
+        bne     $11, $15, 15f
+        nop
+
+        mfc0    $10, $16, 1                     # .word 0x400a8001
+
+        sll     $11, $10, 1
+        srl     $11, 26         # Number of TLB entries (-1)
+
+        mtc0    $0, $2          # EntryLo0
+        mtc0    $0, $3          # EntryLo1
+        mtc0    $0, $5          # PageMask
+        mtc0    $0, $6          # Wired
+
+        li      $12, 0x80000000
+
+1:
+        mtc0    $11, $0         # Index register
+        mtc0    $12, $10        # EntryHi
+        ssnop                   #.word 0x00000040
+        ssnop                   #.word 0x00000040
+
+#debug trap - open remarks to stop code:
+#loop_for_ever:
+#bal loop_for_ever
+
+        TLBWI
+        add     $12, (2<<13)    # Add 8K to the address to avoid TLB conflict with previous entry
+
+        bne     $11, $0, 1b
+        add     $11, -1
+
+15:
+#endif
+	# Initialize other register files
+        # Good code should obviously not read registers before they are written
+        # so this is not not normally needed. But in simulation certain ways of initializing
+        # registers may not work (xor rN, rN, rN for one)
+
+        # check for the presence of shadow register sets
+        # first verify core is release 2 or higher
+        mfc0    $11, $16
+        sll     $11, 19
+        srl     $11, 29
+        beqz    $11, return
+/*        nop*/
+HB
+
+#define CPUNUM	$3
+#if 1
+#ifndef DO_NOT_CHECK_FOR_CMP
+
+#define GCMP	$8
+
+	# Determine if there is a coherency manager present.
+	# This address is the default configuration address.  If your
+	# system was configured with a different address, you must
+	# change this value.
+	li	GCMP, 0xbfbf8000	# KSEG1(GCMPBASE)
+	lw	$9, 0x0008(GCMP)	# GCR_BASE
+
+	addiu	$10, $0, 0x8000		# li r10, M_GCR_BASE_GCR_BASE (~0x7fff)
+	and	$9, $10
+
+	lui	$10, 0xa000		# KSEG1BASE
+	or	$10, $9
+
+	# This code uses $3 as the CPU number to make descisions about
+	# whether to execute code or not.  For CMP systems, we use the
+	# real CPU number.  For non-CMP, pretend the CPU number is zero
+	# to force the correct behavior.
+
+	bne	$10, GCMP, nogcmp
+	move	CPUNUM, $0
+
+	# Change the CCA from non-coherent to coherent
+	# Assumption: GCMP => coherent CCA is usable
+	mfc0	$10, $16		# C0_Config
+
+	ext	$11, $10, 0, 3		# S_ConfigK0, W_ConfigK0
+	xori	$11, 3			# K_CacheAttrCN
+
+	bnez	$11, 1f
+	HB
+
+	li	$11, 5			# K_CacheAttrCCS
+	ins	$10, $11, 0, 3		# S_ConfigK0, W_ConfigK0
+
+	mtc0	$10, $16		# C0_Config
+1:
+	# Check the CPU number
+	mfc0	CPUNUM, $15, 1		# C0_EBase
+	ext	CPUNUM, CPUNUM, 0, 10	# S_EBaseCPUNum, W_EBaseCPUNum
+
+	# Only the Primary Core needs to initialise the Coherence Manager.
+	bnez	CPUNUM, 1f
+	HB
+
+	# Initialise CM
+	#
+	# Rewrite the GCR_BASE register to initialise CM_DEFAULT_TARGET
+	ins	$9, $0, 0, 2		# M_GCR_BASE_CM_DEFAULT_TARGET, S_GCR_BASE_CM_DEFAULT_TARGET
+	sw	$9, 0x0008(GCMP)	# GCR_BASE
+
+	# Disable the CM regions
+	lui	$9, 0xffff
+	sw	$9, 0x0090(GCMP)	# GCR_REG0_BASE
+	sw	$9, 0x0098(GCMP)	# GCR_REG0_MASK
+	sw	$9, 0x00a0(GCMP)	# GCR_REG1_BASE
+	sw	$9, 0x00a8(GCMP)	# GCR_REG1_MASK
+	sw	$9, 0x00b0(GCMP)	# GCR_REG2_BASE
+	sw	$9, 0x00b8(GCMP)	# GCR_REG2_MASK
+	sw	$9, 0x00c0(GCMP)	# GCR_REG3_BASE
+	sw	$9, 0x00c8(GCMP)	# GCR_REG3_MASK
+
+1:
+	# Allow interventions from all other cores (including self)
+	# For CPU 1 and higher, NOP if access not enabled in GCR_ACCESS.
+	li	$9, 0xff
+	sw	$9, 0x2008(GCMP)	# GCR_CL_COHERENCE
+	ehb
+
+#undef GCMP
+#endif	/* DO_NOT_CHECK_FOR_CMP */
+#endif	/* 0 */
+
+nogcmp:
+
+ 	/* Clear watch registers.
+	 */
+	mtc0	zero, CP0_WATCHLO   #done in watch handling above
+	mtc0	zero, CP0_WATCHHI
+
+/*#define VBG400_USE_RPS_E83_PATCH*/
+#define VBG400_ADD_UNCACHED_HERE
+
+	/* CONFIG7 register */
+	mfc0	k0, CP0_CONFIG, 7
+#ifdef VBG400_USE_RPS_E83_PATCH
+	li	k1, 4 /* Disable RPS due to E83 bug of 24KEC */
+	or	k0, k1
+#endif
+#ifdef VBG400_ADD_UNCACHED_HERE
+    li	k1, CONF_CM_UNCACHED
+    or	k0, k1
+#endif
+	mtc0	k0, CP0_CONFIG, 7
+	/* Init Timer */
+	mtc0	zero, CP0_COUNT
+	mtc0	zero, CP0_COMPARE
+
+#ifndef VBG400_ADD_UNCACHED_HERE
+	li	t0, CONF_CM_UNCACHED
+	mtc0	t0, CP0_CONFIG
+#endif
+
+#if 1
+#ifndef DO_NOT_CHECK_FOR_MT
+
+	# Config1 is required for MIPS32
+	mfc0	$8, $16, 1		# C0_Config1
+	bgez	$8, notmtcapable	# No Config2 register
+	HB
+
+	mfc0	$8, $16, 2		# C0_Config2
+	bgez	$8, notmtcapable	# No Config3 register
+	HB
+
+	mfc0	$8, $16, 3		# C0_Config3
+	and	$8, (1 << 2)		# M_Config3MT
+	beqz	$8, notmtcapable
+	HB
+
+	# This core supports MT ASE
+	#
+	# Start up secondary VPE's
+	.set	push
+	.set	mt
+
+startmtconfig:
+	# This is TC0 bound to VPE0.  Therefore VPEConf0.MVP is set.
+
+	# Enter config mode
+	mfc0	$8, $0, 1		# C0_MVPCtl
+	or	$8, (1 << 1)		# M_MVPCtlVPC
+	mtc0	$8, $0, 1		# C0_MVPCtl
+	ehb
+
+#define NTCS	$10
+#define NVPES	$11
+#define TC	$12
+
+	# Get number of TC's and VPE's
+	mfc0	$8, $0, 2		# C0_MVPConf0
+	ext	NTCS, $8, 0, 8		# S_MVPConf0PTC, W_MVPConf0PTC
+	ext	NVPES, $8, 10, 4	# S_MVPConf0PVPE, W_MVPConf0PVPE
+
+	# Initialise TC's/VPE's
+	move	TC, $0
+nexttc:
+	# Select TCn
+	mfc0	$8, $1, 1		# C0_VPECtl
+	ins	$8, TC, 0, 8		# S_VPECtlTargTC, W_VPECtlTargTC
+	mtc0	$8, $1, 1		# C0_VPECtl
+	ehb
+
+	# Bind TC to next VPE
+	beqz	TC, nextvpe		# Don't rebind TC0
+	HB
+
+	# Halt all TC's other than TC0
+	li	$8, 1			# M_TCHaltH
+	mttc0	$8, $2, 4		# C0_TCHalt
+	ehb
+
+	slt	$9, NVPES, TC
+	bnez	$9, 2f			# Bind spare TC's to VPElast
+	move	$9, NVPES
+
+	# Set XTC for active TC's
+	mftc0	$8, $1, 2		# C0_VPEConf0
+	ins	$8, TC, 21, 8		# S_VPEConf0XTC, W_VPEConf0XTC
+	mttc0	$8, $1, 2		# C0_VPEConf0
+
+	move	$9, TC
+2:
+	# Bind TC to a VPE
+	mftc0	$8, $2, 2		# C0_TCBind
+	ins	$8, $9, 0, 4		# S_TCBindCurVPE, W_TCBindCurVPE
+	mttc0	$8, $2, 2		# C0_TCBind
+
+	# Set up TCStatus register:
+	# Disable Coprocessor Usable bits
+	# Disable MDMX/DSP ASE
+	# Clear Dirty TC
+	# not dynamically allocatable
+	# not allocated
+	# Kernel mode
+	# interrupt exempt
+	# ASID 0
+	li	$8, (1 << 10)		# M_TCStatusIXMT
+	mttc0	$8, $2, 1		# C0_TCStatus
+
+#ifndef DO_NOT_INIT_GPRS
+
+	# Initialize the TC's register file
+	# should not be required with good software practices
+	mttgpr	$0, $1
+	mttgpr	$0, $2
+	mttgpr	$0, $3
+	mttgpr	$0, $4
+	mttgpr	$0, $5
+	mttgpr	$0, $6
+	mttgpr	$0, $7
+	mttgpr	$0, $8
+	mttgpr	$0, $9
+	mttgpr	$0, $10
+	mttgpr	$0, $11
+	mttgpr	$0, $12
+	mttgpr	$0, $13
+	mttgpr	$0, $14
+	mttgpr	$0, $15
+	mttgpr	$0, $16
+	mttgpr	$0, $17
+	mttgpr	$0, $18
+	mttgpr	$0, $19
+	mttgpr	$0, $20
+	mttgpr	$0, $21
+	mttgpr	$0, $22
+	mttgpr	$0, $23
+	mttgpr	$0, $24
+	mttgpr	$0, $25
+	mttgpr	$0, $26
+	mttgpr	$0, $27
+	mttgpr	$0, $28
+	mttgpr	$0, $29
+	mttgpr	$0, $30
+	mttgpr	$0, $31
+
+#endif /* DO_NOT_INIT_GPRS */
+
+nextvpe:
+	slt	$9, NVPES, TC
+	bnez	$9, donevpe		# No more VPE's
+	HB
+
+	# Disable multi-threading with TC's
+	mftc0	$8, $1, 1		# C0_VPECtl
+	ins	$8, $0, 15, 1		# S_VPECtlTE, W_VPECtlTE
+	mttc0	$8, $1, 1		# C0_VPECtl
+
+	beqz	TC, 1f
+	HB
+
+	# For VPE1..n
+	# Clear VPA and set master VPE
+	mftc0	$8, $1, 2		# C0_VPEConf0
+	ins	$8, $0, 0, 1		# S_VPEConf0VPA, W_VPEConf0VPA
+	or	$8, (1 << 1)		# M_VPEConf0MVP
+	mttc0	$8, $1, 2		# C0_VPEConf0
+
+	# Copy Status from the current TC to the target TC's Cop0 Status register
+	mfc0	$8, $12			# C0_Status
+	mttc0	$8, $12			# C0_Status
+
+#ifndef OTHER_VPE_EPC_ADDR
+#define OTHER_VPE_EPC_ADDR 0x12345678
+#endif
+	la	$8, OTHER_VPE_EPC_ADDR
+	mttc0	$8, $14			# C0_EPC
+
+	mttc0	$0, $13			# C0_Cause
+
+	mfc0	$8, $16			# C0_Config
+	mttc0	$8, $16			# C0_Config
+
+	mftc0	$8, $15, 1		# C0_EBase
+	ext	$8, $8, 0, 10		# S_EBaseCPUNum, W_EBaseCPUNum
+	mttgpr	$8, CPUNUM
+
+	# Finally... arrange for other VPE's to continue from OTHER_VPE_TCRESTART_ADDR
+#ifndef OTHER_VPE_TCRESTART_ADDR
+#define OTHER_VPE_TCRESTART_ADDR 0x12345678
+#endif
+	la	$8, OTHER_VPE_TCRESTART_ADDR
+	mttc0	$8, $2, 3		# C0_TCRestart
+
+	# Yes.. this is undoing all of the work done above... :)
+	mftc0	$8, $2, 1		# C0_TCStatus
+	ins	$8, $0, 10, 1		# S_TCStatusIXMT, W_TCStatusIXMT
+	ori	$8, (1 << 13)		# M_TCStatusA
+	mttc0	$8, $2, 1		# C0_TCStatus
+
+	mttc0	$0, $2, 4		# C0_TCHalt
+
+	mftc0	$8, $1, 2		# C0_VPEConf0
+	ori	$8, 1			# M_VPEConf0VPA
+	mttc0	$8, $1, 2		# C0_VPEConf0
+1:
+
+donevpe:
+	addu	TC, 1
+	sltu	$9, NTCS, TC
+	beqz	$9, nexttc
+	HB
+
+	# Exit config mode
+	mfc0	$8, $0, 1		# C0_MVPCtl
+	ins	$8, $0, 1, 1		# S_MVPCtlVPC, W_MVPCtlVPC
+	mtc0	$8, $0, 1		# C0_MVPCtl
+	ehb
+
+#undef NTCS
+#undef NVPES
+#undef TC
+
+notmtcapable:
+
+#endif	/* DO_NOT_CHECK_FOR_MT */
+#endif	/* 0 */
+
+
+	/* Initialize $gp.
+	 */
+	bal	1f
+	nop
+	.word	_gp
+1:
+	lw	gp, 0(ra)
+
+
+nop
+#loop_bofore_exception:
+#bal loop_bofore_exception
+
+	/* Set up temporary stack.
+	 */
+	li	t0, 0xa0000000 + 0x600000
+	la	sp, 0(t0)
+	la	t9, board_init_f
+	j	t9
+	nop
+
+return:
+        # At this point the chip has been initialized
+        # The address of the real code can be loaded into EPC
+        # An ERet will clear EXL and jump to EPC
+
+        la      $11, 0x80030120
+        mtc0    $11, $14
+        ssnop                   #.word 0x00000040
+        ssnop                   #.word 0x00000040
+        eret
+
+
+
+/*
+ * void relocate_code (addr_sp, gd, addr_moni)
+ *
+ * This "function" does not return, instead it continues in RAM
+ * after relocating the monitor code.
+ *
+ * a0 = addr_sp
+ * a1 = gd
+ * a2 = destination address
+ */
+	.globl	relocate_code
+	.ent	relocate_code
+relocate_code:
+	move	sp, a0		/* Set new stack pointer	*/
+
+	li	t0, CONFIG_BOOTSTRAP_TEXT_BASE
+	la	t3, in_ram
+	lw	t2, -12(t3)	/* t2 <-- uboot_end_data	*/  //<<<<<------(a0100b64 t in_ram) (a012c3f0 A uboot_end_data)
+													//-12(t3) is NOT uboot_end_data !!!!??? it is declared 3 long before, but not in sys.map
+	move	t1, a2
+
+	/*
+	 * Fix $gp:
+	 *
+	 * New $gp = (Old $gp - CONFIG_BOOTSTRAP_TEXT_BASE) + Destination Address
+	 */
+	move	t6, gp
+	sub	gp, CONFIG_BOOTSTRAP_TEXT_BASE
+	add	gp, a2		/* gp now adjusted		*/
+	sub	t6, gp, t6	/* t6 <-- relocation offset	*/
+
+	/*
+	 * t0 = source address
+	 * t1 = target address
+	 * t2 = source end address
+	 */
+	/* On the purple board we copy the code earlier in a special way
+	 * in order to solve flash problems
+	 */
+
+1:
+	lw	t3, 0(t0)       /* relocated code loop here ! */
+	sw	t3, 0(t1)
+	addu	t0, 4
+	ble	t0, t2, 1b
+	addu	t1, 4		/* delay slot			*/
+
+	/* If caches were enabled, we would have to flush them here.
+	 */
+
+	/* Jump to where we've relocated ourselves.
+	 */
+	addi	t0, a2, in_ram - _start
+	j	t0
+	nop
+
+	.gpword	_GLOBAL_OFFSET_TABLE_	/* _GLOBAL_OFFSET_TABLE_ - _gp	*/
+#	.gpword	__got_start	/* _GLOBAL_OFFSET_TABLE_ - _gp	*/
+	.word	uboot_end_data
+	.word	uboot_end
+	.word	num_got_entries /*define in u-boot.lds*/
+
+in_ram:
+	/*
+	 * Now we want to update GOT.
+	 *
+	 * GOT[0] is reserved. GOT[1] is also reserved for the dynamic object
+	 * generated by GNU ld. Skip these reserved entries from relocation.
+	 */
+	lw	t3, -4(t0)	/* t3 <-- num_got_entries	*/
+	lw	t4, -16(t0)	/* t4 <-- (_GLOBAL_OFFSET_TABLE_ - _gp)	*/
+and     t4, t4, 0x0FFFFFFF
+	add	t4, t4, gp	/* t4 now holds _GLOBAL_OFFSET_TABLE_	*/
+	addi	t4, t4, 8	/* Skipping first two entries.	*/
+	li	t2, 2
+1:
+	lw	t1, 0(t4)
+	beqz	t1, 2f
+	add	t1, t6		/*t6 hols the reloc offset*/
+	sw	t1, 0(t4)
+2:
+	addi	t2, 1
+	blt	t2, t3, 1b /* if t2 (++ in a loop) < t3 (num_got_entries) jump */
+	addi	t4, 4		/* delay slot			*/
+
+	/* Clear BSS.
+	 */
+	lw	t1, -12(t0)	/* t1 <-- uboot_end_data	*/
+	lw	t2, -8(t0)	/* t2 <-- uboot_end		*/
+	add	t1, t6		/* adjust pointers		*/
+	add	t2, t6
+
+	sub	t1, 4
+1:
+	addi	t1, 4
+	bltl	t1, t2, 1b
+	sw	zero, 0(t1)	/* delay slot			*/
+
+	move	a0, a1
+	la	t9, board_init_r
+	j	t9
+	move	a1, a2		/* delay slot			*/
+
+	.end	relocate_code
+
+	/* Exception handlers.
+	 */
+
+
+romReserved:
+	b	romReserved
+
+romExcHandle:
+	b	romExcHandle
diff --git a/arch/mips/cpu/vbg400/start_clock.s b/arch/mips/cpu/vbg400/start_clock.s
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/vbg400/start_clock.s
@@ -0,0 +1,487 @@
+##############################################################
+##
+## Metalink L.T.D. (c) Copyright 2006.
+## Metalink Confidential Proprietary.
+##
+## $Author: amir $
+## $Date: Wed Jul  6 13:31:17 2011 $
+##
+## $Aliases:  $
+##
+## $Log: start_clock.s.rca $
+## 
+##  Revision: 1.3.1.3.1.17.1.6 Wed Jul  6 13:31:17 2011 amir
+##  Modified BBCPU system I/F base address from NPU side
+## 
+##  Revision: 1.3.1.3.1.17.1.5 Sun Apr  3 10:04:30 2011 amir
+##  Modified PLL activation sequence. New sequence is:
+##  1. Release PLL power down control
+##  2. Wait for PLL lock - either by PLL lock indication or by a timer (wait duration is according to efuse)
+##  3. Only when PLL is locked, enable PLL's outputs
+##  4. Set the clock switch in clkgen module to move from XO to PLL
+## 
+##  Revision: 1.3.1.3.1.17.1.4 Mon Mar 21 16:54:34 2011 amir
+##  Code now polls a bit in efuse array to decide if to poll pll delay indication (default)
+##  or to wait a preconfigured time until PLL lock should be done (efuse bit is "1")
+## 
+##  Revision: 1.3.1.3.1.17.1.3 Sun Mar 13 08:37:52 2011 amir
+##  Added a copy routine from efuse to PLL controls
+##  Modified delay loop time to be variable, according to a value stored in efuse
+## 
+##  Revision: 1.3.1.3.1.17.1.2 Wed Mar  2 14:00:07 2011 oren_a
+##  1. added reduced freq mode config
+##  2. increased pll lock time to 1ms
+## 
+##  Revision: 1.3.1.3.1.17.1.1 Tue Jan 18 11:57:53 2011 michaelk
+##  *** empty comment string ***
+## 
+##  Revision: 1.3.1.3.1.17 Fri Oct 22 09:58:07 2010 oren_a
+##  added seperate_mac_phy_clk_equ
+## 
+##  Revision: 1.3.1.3.1.16 Sun Oct 17 16:37:35 2010 oren_a
+##  *** empty comment string ***
+## 
+##  Revision: 1.3.1.3.1.15 Sun Sep 26 18:03:27 2010 oren_a
+##  changed PLL_LOCK_TIME_IN_US to 30us in short_lock_delay mode
+## 
+##  Revision: 1.3.1.3.1.14 Wed Sep 22 13:15:57 2010 oren_a
+##  changed PLL_LOCK_TIME_IN_US in short_lock_delay mode to 150us due to AFE model change
+## 
+##  Revision: 1.3.1.3.1.13 Tue Sep 21 13:06:06 2010 oren_a
+##  fixed divider values
+## 
+##  Revision: 1.3.1.3.1.12 Thu Sep  2 16:15:24 2010 oren_a
+##  removed fast mode checking for fast_clock_in_boot mode
+## 
+##  Revision: 1.3.1.3.1.11 Wed Sep  1 11:04:32 2010 michaelk
+##  updated timer
+## 
+##  Revision: 1.3.1.3.1.10 Tue Aug 31 18:37:53 2010 michaelk
+##  aded timer interupt disable
+## 
+##  Revision: 1.3.1.3.1.9 Wed Aug 25 18:39:37 2010 oren_a
+##  fixed short pll delay and mac clock 320MHz
+## 
+##  Revision: 1.3.1.3.1.8 Tue Aug 10 12:09:34 2010 oren_a
+##  wait for PLL lock with HW timer
+## 
+##  Revision: 1.3.1.3.1.7 Tue Aug 10 10:01:48 2010 oren_a
+##  changes pll lock time calculations
+## 
+##  Revision: 1.3.1.3.1.6 Thu Aug  5 13:41:13 2010 oren_a
+##  changes for new AFE PLL
+## 
+##  Revision: 1.3.1.3.1.5 Wed Jul 21 18:50:14 2010 michaelk
+##  fixed clk mux
+## 
+##  Revision: 1.3.1.3.1.4 Sun Jul 18 08:44:41 2010 amir
+##  Added SW reset to the phy as part of the seperate_mac_phy_clks sequence
+## 
+##  Revision: 1.3.1.3.1.3 Sun Jul 18 08:38:37 2010 oren_a
+##  added seperate phy and mac clock define
+## 
+##  Revision: 1.3.1.3.1.2 Wed Jun 30 15:45:57 2010 oren_a
+##  added fast_clock_in_boot define
+## 
+##  Revision: 1.3.1.3.1.1 Sun May  2 08:25:08 2010 oren_a
+##  changes for gen3.5 fast/slow clock
+## 
+##  Revision: 1.3.1.3 Tue Jan 27 16:16:46 2009 oren_a
+##  fixed PLL lock time wait
+## 
+##  Revision: 1.3.1.2 Wed Dec 24 19:11:49 2008 michaelk
+##  change jal to bal
+## 
+##  Revision: 1.3.1.1 Thu Aug 28 16:25:47 2008 amir
+##  Now compatible with Erylus initializations
+## 
+##  Revision: 1.3 Tue Nov 27 14:07:12 2007 arikc
+##  delete rxtd equ file
+## 
+##  Revision: 1.2 Thu Aug 16 20:38:24 2007 ronen
+##  this start clock should used from the Upper cpu 
+##  because the base address is for the system interface unit 
+##  accessing from Upper
+##  add 60 Usec delay waiting for Pll Lock
+##  changed the pll write order
+##  first write the pll parameters and then activate the PLL
+##      
+## Spec. Reference:
+## ----------------
+## 
+## Description:
+## ------------
+##
+##############################################################
+	
+/*
+	Version 1.1 (1/2/2006)
+	Standard Clocks init
+	This starts the clocks on the hyperionII chip
+	This function can be called with include dirrective.
+	
+	
+		
+*/	
+	/* RXTD equ file */
+	
+        /* System Interface EQU file */
+
+        .equ    PLL_LOCK_TIME_IN_US,                            1000 
+        .equ    PLL_LOCK_TIME_IN_US_rstq1,                      1200 
+        .equ    PLL_LOCK_TIME_IN_US_rstq2,                      1600 
+        .equ    PLL_LOCK_TIME_IN_US_rstq3,                      2400 
+        .equ    MAC_CLOCK_FREQ_IN_MHZ,                          36
+        .equ    FAST_CLK_DIV,                                   2
+
+        .equ	sys_if_base_address,				0xa6298000
+        .equ    rxtd_base_address,                              0xa630
+        .equ	ht_ext_base,		                        0xa62f
+
+        /* if during boot there is 300MHz clock */
+
+        /* for fast simulation will not wait 1000us for PLL lock */
+        /* for fast simulation will not wait 1000us for PLL lock */
+
+
+        .equ	secure_write_addr,				(0x1A << 2)     
+
+        .equ	pll_mul_div_addr,				(0x10 << 2)
+        .equ	pll_n_field,					0
+        .equ	pll_refdiv_field,				9
+        
+        .equ	pll_control_reg,				(0x11 << 2 )
+        .equ	pll_control_pll_off_field,			3
+        .equ	pll_control_pll_bypass_field,			4
+        .equ	pll_control_pll_refdly_field,			0
+        
+	.equ    pll_param_reg,                                  (0x14 << 2)
+	.equ    pll_param_vco_cal_field,                        9
+	.equ    pll_param_vco_field,                            4 
+	.equ    pll_param_filter_field,                         2
+	.equ    pll_param_pllcp_field,                          0
+	
+	
+        .equ	cpu_clk_select_reg,				(0x16 << 2)
+        .equ	phy_clk_select_mac_reg,				(0x2f << 2)
+	.equ	mac2phy_rst_reg,				(0x45 << 2)    
+        .equ	cpu_clock_gen_reg,				(0x1e << 2)     
+        .equ	cpu_clock_gen_cpu_phy_div_enable_field,		5
+        .equ	cpu_clock_gen_cpu_phy_div_field,		3
+        .equ	cpu_clock_gen_modem_pre_div_field,		2
+        .equ	cpu_clock_gen_modem_xo_sel_field,		1
+        .equ	cpu_clock_gen_lvds_xo_sel_field,		0
+
+	.equ	digital_lpbk_reg,				( 0x25 << 2)
+        .equ	digital_lpbk_rx0_polarity_sel_field,		0
+        .equ	digital_lpbk_rx1_polarity_sel_field_field,	1 
+        .equ	digital_lpbk_rx2_polarity_sel_field_field,	2 
+        .equ	digital_lpbk_tx0_polarity_sel_field,		3 
+        .equ	digital_lpbk_tx1_polarity_sel_field,		4 
+        .equ	digital_lpbk_ch0_lpbk_clk_src_field,		5 
+        .equ	digital_lpbk_ch1_lpbk_clk_src_field,		6 
+        .equ	digital_lpbk_rx0_lpbk_select_field,		7
+        .equ	digital_lpbk_rx1_lpbk_select_field,		9
+        .equ	digital_lpbk_rx2_lpbk_select_field,		11
+        .equ	digital_lpbk_rx_aux_polarity_sel_field,		13
+
+
+        .equ	pll_en_div_reg,                                 (0x10 << 2)
+        .equ	mac_clk_div_d2a_field,                          0
+        .equ	mac_clk_en_d2a_field,                           3
+        .equ	tbus_clk_div_d2a_field,                         4
+        .equ	tbus_clk_en_d2a_field,                          7
+        .equ	phy_clk_div_d2a_field,                          8
+        .equ	phy_clk_en_d2a_field,                           11
+        .equ	adc_clk_div_d2a_field,                          12
+        .equ	adc_clk_en_d2a_field,                           15
+
+## MAC Clock Div
+        .equ    mac_clk_div_d2a_320MHz,                         4
+        .equ    mac_clk_div_d2a_480MHz,                         0
+        .equ    mac_clk_div_d2a_240MHz,                         1
+        .equ    mac_clk_div_d2a_80MHz,                          6
+        .equ    mac_clk_div_d2a_120MHz,                         2
+        .equ    mac_clk_div_d2a_160MHz,                         5
+        .equ    mac_clk_div_d2a_40MHz,                          7
+        .equ    mac_clk_div_d2a_60MHz,                          3
+
+## Phy Clock Div
+        .equ    phy_clk_div_d2a_240MHz,                         0
+        .equ    phy_clk_div_d2a_480MHz,                         1
+        .equ    phy_clk_div_d2a_60MHz,                          2
+        .equ    phy_clk_div_d2a_120MHz,                         3
+
+
+        .equ    pll_ctl_reg,                                    (0x12 << 2)
+        .equ    bbpll_config_d2a_field,                         0
+        .equ    bbpll_pup_d2a_field,                            8
+        .equ    bbpll_ldodis_d2a_field,                         9
+        .equ    bbpll_rstq_cnt_d2a_field,                       10
+        .equ    fcsi_ldo_pd_d2a_field,                          13
+
+	.equ	pll_lock_reg,					0x14<<2
+        .equ    not_in_cached_value,                            0
+        .equ    in_cached_value,                                1
+
+
+        .equ 	 tmr_prescale_addr,                             0x0e << 2
+        .equ 	 tmr_enable_addr,                               0x0f << 2
+	.equ 	 tmr_disable_addr,                              0x3c << 2 
+        .equ     mac_ht_extensions_tmr_irq ,                   ( 0x0034 )
+        .equ 	 tmr_00_init_addr,                              0x10 << 2 
+        .equ 	 tmr_00_cnt_addr,                               0x20 << 2
+
+	/***************************************************/
+	/* Clock Manipulation 240 (default), 160 ,120 MHz  */
+	/***************************************************/
+	
+
+	.equ	sys_clk_fast_divider_reg,	(0x13 << 2)
+        .equ	pll_clk_sel_reg,	        (0x2f << 2)
+	
+	.equ    fast_mode_mac_div           , mac_clk_div_d2a_480MHz 
+	.equ    slow_mode_mac_div           , mac_clk_div_d2a_240MHz 
+        .equ    seperate_mac_phy_clks_equ, 0
+
+
+	.equ	SHARED_REG_BASE,	0xa71c0000
+
+	.equ    EFUSE_DATA,		0x0120
+	.equ    EFUSE_ADDRESS,          0x0124
+	.equ    EFUSE_CONTROL,          0x0128
+	.equ    EFUSE_STATUS,           0x012c
+	.equ    EFUSE_TIMER_CONFIG1,    0x0130
+	.equ    EFUSE_TIMER_CONFIG2,    0x0134
+
+	.equ	EFUSE_BUSY,		0x1
+	
+        /* PLL configuration*/
+
+        li     $10,sys_if_base_address
+
+
+	
+
+	/* Modify the MAC clock divider field */
+	li	$4,0xa7000000
+	lw	$3,0x0060($4)
+	li	$4,0x1<<19 /* CPU fast mode indication @ NPU system I/F */
+
+	/* Store fast mode indication in $4: 1 = fast mode, 0 = slow mode */
+	and	$3,$3,$4
+	srl	$4,$3,19
+
+	
+        /* PLL turning on + PLL config */
+	
+	/* Read offsets 50,51 from efuse array */
+	
+	/* Verify efuse control machine is not busy */
+	li	$5,SHARED_REG_BASE
+poll_efuse_machine_busy:	
+	lw	$13,EFUSE_STATUS($5)
+	andi	$13,EFUSE_BUSY
+	bne	$13,$0,poll_efuse_machine_busy
+/*nop*/
+	/* Write address to read from */
+	li	$13,0x32<<3
+	sw	$13,EFUSE_ADDRESS($5)
+	/* Set READ bit - also triggers machine operation */
+	sw	$0,EFUSE_CONTROL($5)
+	
+	/* Wait for machine ready */
+wait_if_busy:	
+	lw	$13,EFUSE_STATUS($5)
+	andi	$13,EFUSE_BUSY
+	bne	$13,$0,wait_if_busy
+/*nop*/
+
+	/* Load read data into $12 */
+	lw	$12,EFUSE_DATA($5)
+
+	/* Write address to read from */
+	li	$13,0x33<<3
+	sw	$13,EFUSE_ADDRESS($5)
+	/* Set READ bit - also triggers machine operation */
+	sw	$0,EFUSE_CONTROL($5)
+	
+	/* Wait for machine ready */
+wait_if_busy2:	
+	lw	$13,EFUSE_STATUS($5)
+	andi	$13,EFUSE_BUSY
+	bne	$13,$0,wait_if_busy2
+/*nop*/
+
+	/* Load read data into $12 */
+	lw	$13,EFUSE_DATA($5)
+	andi	$14,$13,0x8 /* $14 will hold bit[3] which is "1" if we have a delay loop for PLL lock of "0" if we want to rely on PLL lock indication */
+	andi	$13,0x7
+	or	$5,$13,$0 /* Copy RST_Q to $5 */
+	sll	$13,10
+	or	$12,$12,$13
+	li	$13,0xffffe300
+	
+        lw      $2, pll_ctl_reg($10)
+	and	$2,$2,$13
+        li      $3, ( 1 << bbpll_pup_d2a_field)
+        or      $2,$3,$2
+	or	$2,$2,$12
+        bal     secure_write
+        sw      $2, pll_ctl_reg($10)
+
+	li	$13,(MAC_CLOCK_FREQ_IN_MHZ - 1)
+	beq	$4,$0,fast_mode_delay_continue
+/*nop*/
+	/* If fast mode, override prev. value */
+	li	$13,(MAC_CLOCK_FREQ_IN_MHZ/FAST_CLK_DIV - 1)
+fast_mode_delay_continue:
+	bne	$14,$0,do_pll_delay_loop
+/*nop*/
+
+#/*start endless loop*/
+#		nop
+#endless1:
+#        b  endless1
+#		nop
+#/*end loop*/
+
+pll_lock_poll_loop:
+	lw	$2,pll_lock_reg($10)
+	beq	$2,$0,pll_lock_poll_loop
+/*nop*/
+	b	configure_pll_clocks
+
+do_pll_delay_loop:
+        bal     power_up_delay        
+configure_pll_clocks:
+        /* Update the AFE clock according to equ algo_afe_clock_freq_div*/
+	/* Updated to Feronia V32 */
+        /* for 80MHz algo_afe_clock_freq_div = 6  */ 
+        /* for 40MHz algo_afe_clock_freq_div = 12 */
+        /* Configuring the PLL clocks (0(AFE)=80M, 1(LVDS)= 480M, 2(PHY)=240M, 3(MAC)=160M) */
+        lw      $2, pll_en_div_reg($10)
+	/* We need to modify MAC clock divider's default value value set epending on fast mode and mac freq */
+	beq	$4,$0,set_slow_mode_mac_divider
+/*nop*/
+	li	$3,0xfffffff8
+	/*$2 holds: see Emerald Env, addr 40, mac_clk_div_d2a= bits 0,1,2. Clear 3 litle bits in reg $2*/
+	and	$2,$2,$3
+set_fast_mode_mac_divider:	
+        li	$3,(fast_mode_mac_div   << mac_clk_div_d2a_field)
+        b       set_mac_clock_div        
+set_slow_mode_mac_divider:	
+        li	$3,(slow_mode_mac_div   << mac_clk_div_d2a_field)
+set_mac_clock_div:
+	or	$2,$2,$3
+        li      $3, ((1 << adc_clk_en_d2a_field) | (1 << phy_clk_en_d2a_field) | (1 << tbus_clk_en_d2a_field) | (1 << mac_clk_en_d2a_field))
+        or      $2,$3,$2
+        bal     secure_write
+        sw      $2, pll_en_div_reg($10)
+
+switch_to_pll:	
+        /*Select fast clock (sel=2) */
+        bal     secure_write
+	li	$2,0x00000002
+        sw      $2, cpu_clk_select_reg($10)
+
+        /* check if need to seperate the mac and phy clocks */
+        li      $2,seperate_mac_phy_clks_equ
+        beq     $2,$0,phy_mac_synchronized
+/*nop*/
+        
+        /* sepearte mac and phy */
+        /* Start Phy clock*/
+        lw      $2, cpu_clock_gen_reg($10)
+        ori     $2, $2, ( 1 << cpu_clock_gen_cpu_phy_div_enable_field)
+        sw      $2, cpu_clock_gen_reg($10)
+
+	/* Hold the phy in reset before changing the clock mux */
+	bal	secure_write
+	sw	$0,mac2phy_rst_reg($10)
+	
+        /* Select PHY clock from PHY not MAC */
+        li      $2, 0x0
+        sw      $2, phy_clk_select_mac_reg($10)
+
+	/* Release Phy from reset */
+	bal	secure_write
+        li      $2, 0x1
+	sw	$2,mac2phy_rst_reg($10)
+	
+phy_mac_synchronized:
+        li      $9, rxtd_base_address
+	        
+	b	std_init_cont
+
+##************************************************************ 	
+##  
+##************************************************************ 
+secure_write:
+        li      $12, 0x0000aaaa
+        sw      $12, secure_write_addr($10)
+        li      $12, 0x00005555
+        sw      $12, secure_write_addr($10)
+        jr	$31
+
+##************************************************************ 
+##  
+##************************************************************ 
+power_up_delay:
+
+	/* Enable GCLK to HT Extensions units */	
+	lui	$20,ht_ext_base
+	li	$11,0x000000ff
+	sw	$11,0x0000($20)
+
+	/* Cofigure prescaler */
+        srl     $14,$13,1       # load to $14 prescaler value for reduced freq (half of $13)
+        sll     $14,$14,16      # reduced freq value resides in upper 16ms      # reduced freq value resides in upper 16msbb
+        or      $13,$14,$13
+	sw	$13,tmr_prescale_addr($20)
+
+        /* Configure all timers */
+        li	$11,PLL_LOCK_TIME_IN_US
+	/* We start with 1000us. Then, we decrement $5 which is rst_q and increase lock time accordingly */
+	beq	$5,$0,do_configure
+/*nop*/
+	addiu	$5,-1
+	li	$11,PLL_LOCK_TIME_IN_US_rstq1
+	beq	$5,$0,do_configure
+/*nop*/
+	addiu	$5,-1
+	li	$11,PLL_LOCK_TIME_IN_US_rstq2
+	beq	$5,$0,do_configure
+/*nop*/
+	li	$11,PLL_LOCK_TIME_IN_US_rstq3	
+do_configure:		
+        sw	$11,tmr_00_init_addr($20)
+
+        /* Enable timer 0 */
+	li	$11,0x00000001
+	sw	$11,tmr_enable_addr($20)
+        
+wait_timer_expired:
+        lw      $11,tmr_00_cnt_addr($20)
+        bne     $11,$0,wait_timer_expired
+/*nop*/
+         /* clear  timer irq 0 */
+	li	$11,0x00000001
+	sw	$11,mac_ht_extensions_tmr_irq($20)
+         /* disable GCLK to HT Extensions units */	
+	li	$11,0x00000000
+	sw	$11,0x0000($20)
+        jr      $31                
+
+##************************************************************ 
+##  
+##************************************************************ 
+std_init_cont:
+
+	nop
+	nop
+	nop
+	nop
+	nop
+	
+
diff --git a/arch/mips/cpu/vbg400/sys_if_map.s b/arch/mips/cpu/vbg400/sys_if_map.s
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/vbg400/sys_if_map.s
@@ -0,0 +1,78 @@
+		
+	/* System interface register map */
+   .equ  gclk_addr        ,   0x00 << 2
+   .equ  sw_rst_addr      ,   0x01 << 2
+   .equ  spare_addr       ,   0x02 << 2
+
+ 	.equ	wr_addr,          	0x00000003<<2
+	.equ	rd_addr,          	0x00000004<<2
+	.equ	divr_addr,        	0x00000005<<2
+	.equ	fwl_addr,         	0x00000006<<2
+	.equ	int_reg_addr,     	0x00000007<<2
+	.equ	cont_addr,        	0x00000008<<2
+	.equ	noise_cnt_addr,   	0x00000009<<2
+	.equ	idle_max_addr,    	0x0000000a<<2
+	.equ	count_fif_addr,   	0x0000000b<<2
+	.equ	int_mode_addr,    	0x0000000c<<2
+	
+	.equ	pll_mul_addr,     	0x00000010<<2
+	.equ	pll_div_addr,     	0x00000011<<2
+	.equ	pll_ctrl_addr,    	0x00000012<<2
+	.equ	sys_clk_divr_a,		0x00000013<<2
+	.equ	sys_clk_sw_add,		0x00000014<<2
+	.equ	wakeup_tmr_cnt,		0x00000015<<2
+	.equ	wakeup_tmr_ena,		0x00000016<<2
+
+	.equ	sys_info_addr,    	0x00000018<<2
+	.equ	sys_cfg_addr,     	0x00000019<<2
+	.equ	secure_wr_addr,   	0x0000001a<<2
+	.equ	rst_ex_cpu_add,   	0x0000001b<<2
+
+	.equ	gpio_oen_addr,    	0x00000020<<2
+	.equ	gpio_dat_addr,    	0x00000021<<2
+	.equ	gpio_stb_len_a,		0x00000022<<2
+	
+	.equ	mspi_cfg_addr,    	0x00000030<<2
+	.equ	mspi_wdat_addr,   	0x00000031<<2
+	.equ	mspi_rdat_addr,   	0x00000032<<2
+
+	.equ	boot_sw_ctr_addr, 	0x00000040<<2
+	.equ	int_sw_ctr_addr,  	0x00000041<<2
+	.equ	swdog_mask_addr,  	0x00000042<<2
+	.equ	sw_ctr_addr,      	0x00000043<<2
+	.equ	sw_rst_cnt_addr,  	0x00000044<<2
+
+   .equ    spi_write_addr   , 0x48 << 2
+   .equ    spi_read_addr    , 0x49 << 2
+
+ 	.equ	irq_mask_addr,    	0x00000050<<2
+	.equ	irq_sec_rf_addr,  	0x00000051<<2  
+	.equ	irq_map_00_addr,  	0x00000052<<2
+	.equ	irq_map_01_addr,  	0x00000053<<2
+	.equ	irq_map_02_addr,  	0x00000054<<2
+	.equ	irq_map_03_addr,  	0x00000055<<2
+	.equ	irq_map_04_addr,  	0x00000056<<2
+	.equ	irq_map_05_addr,  	0x00000057<<2
+	.equ	irq_mapped_addr,  	0x00000058<<2
+	.equ	irq_status_addr,  	0x00000059<<2
+	.equ	irq_inter_cpu_ad, 	0x0000005a<<2
+	.equ	irq_to_host_addr, 	0x0000005b<<2
+
+	.equ	t0_max_cnt_addr,  	0x060<<2
+	.equ	t1_max_cnt_addr,  	0x061<<2
+	.equ	t2_max_cnt_addr,  	0x00000062<<2
+	.equ	t3_max_cnt_addr,  	0x00000063<<2
+	.equ	t0_ctr_addr,      	0x00000064<<2
+	.equ	t1_ctr_addr,      	0x00000065<<2
+	.equ	t2_ctr_addr,      	0x00000066<<2
+	.equ	t3_ctr_addr,      	0x00000067<<2
+	.equ	timers_status,    	0x00000068<<2
+	.equ	timers_cfg_addr,  	0x00000069<<2	  
+   .equ  t2_prescaler_add,    0x0000006a<<2
+   .equ  t3_prescaler_add,    0x0000006b<<2
+
+	.equ	ic_hit_addr,      	0x00000070<<2
+	.equ	ic_miss_addr,     	0x00000071<<2
+	.equ	dc_hit_addr,      	0x00000072<<2
+	.equ	dc_miss_addr,     	0x00000073<<2
+
diff --git a/arch/mips/cpu/vbg400/time.c b/arch/mips/cpu/vbg400/time.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/cpu/vbg400/time.c
@@ -0,0 +1,185 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+/* Note:
+* timer 2 is used for the u-boot.
+* this timer support prescaler, default 0 - gives tick every cycle.
+*/
+#define timer_max_count0  	0x180 /*value to count down from for timer 0*/
+#define timer_max_count1  	0x184 /*value to count down from for timer 1*/
+#define timer_max_count2  	0x188 /*value to count down from for timer 2*/
+#define timer_max_count3  	0x18c /*value to count down from for timer 3*/
+#define timer_config  		0x1a4 /*addr 0x1a4:
+                                    bit0-timer0 oneshotmode, bit1-timer1 oneshotmode, bit2-timer2 oneshotmode, bit3-timer3 oneshotmode
+                                    bit4-timer0 enable, bit5-timer1 enable, bit6-timer2 enable, bit7-timer3 enable,*/
+#define timer_2_prescaler  		0x1a8 /*0-no prescaler, like timer 0 & 1*/
+#define timer_3_prescaler  		0x1ac /*0-no prescaler, like timer 0 & 1*/
+#define timer_count_value0  	0x190 /*timer 0 count value*/
+#define timer_count_value1  	0x194 /*timer 1 count value*/
+#define timer_count_value2  	0x198 /*timer 2 count value*/
+#define timer_count_value3  	0x19c /*timer 3 count value*/
+
+#define TIME_CLK_ENABLE_REG_VAL                                 0x00000040
+#define TIME_CLK_ENABLE_REG_MASK                                0x00000040
+
+#define TICKS_2_MICROSEC(x)		((x)/1000000)
+
+void ReadModWriteReg(unsigned long , unsigned long , unsigned long, unsigned long );
+void WriteReg(unsigned long , unsigned long , unsigned long ) ;
+unsigned long ReadReg (unsigned long , unsigned long );
+static void mips_count_set (ulong val)
+{
+	WriteReg (VBG400_SYS_INTERFACE_BASE_ADDR, timer_max_count2, val);
+}
+
+static unsigned long mips_count_get (void)
+{
+	return ( (volatile unsigned long ) ReadReg (VBG400_SYS_INTERFACE_BASE_ADDR, timer_count_value2));
+}
+
+void enable_timer (void) 
+{
+        WriteReg (VBG400_SYS_INTERFACE_BASE_ADDR, timer_config, 0xff);
+}
+
+void disable_timer (void) 
+{
+        WriteReg (VBG400_SYS_INTERFACE_BASE_ADDR, timer_config, 0);
+}
+
+
+/*
+ * timer without interrupts
+ * Explain value of 0x18 for prescaler:
+ *   1/24000000=41.667 nano per cycle
+ *   1/1000000=0.000001 (milisec)
+ *   0.000001/(41.667e-9) =  24 (0x18)
+ * Warning: prescaler id 8 bytes, if clock is higher than 240 need to test if prescaler os not more than 8 bits.
+ *         If it is bigger use half of value and account it on timer Init.
+ */
+int timer_init(void)
+{
+ 	unsigned long prescaler;
+ 	
+ 	ReadModWriteReg (VBG400_SYS_INTERFACE_BASE_ADDR, 0, TIME_CLK_ENABLE_REG_VAL, TIME_CLK_ENABLE_REG_MASK);
+ 	prescaler = TICKS_2_MICROSEC(CONFIG_SYS_HZ);
+ 	WriteReg (VBG400_SYS_INTERFACE_BASE_ADDR, timer_2_prescaler, prescaler);
+// 	WriteReg (VBG400_SYS_INTERFACE_BASE_ADDR, timer_2_prescaler, 0x18);  // 0x18 - gives tick/micro for 24M clock TODO- change when clock change
+	set_timer (0xffffffff);
+	enable_timer();
+	return 0;
+}
+
+void reset_timer(void)
+{
+	WriteReg (VBG400_SYS_INTERFACE_BASE_ADDR, timer_count_value2, 0);
+}
+
+/* get_timer - returns in mili */
+ulong get_timer(ulong base)
+{
+	//return (mips_count_get()/1000) - base;
+	unsigned long temp = mips_count_get();
+    temp = temp/1000;
+	return temp - base;
+}
+
+void set_timer(ulong t)
+{
+	mips_count_set(t);
+}
+
+/* __delay - the timer returns tick every 1 micro. No need to change value */
+void __udelay(unsigned long usec)
+{
+	ulong tmo;
+	ulong start = mips_count_get()/*get_timer(0)*/;
+
+	tmo = usec /* * (CONFIG_SYS_HZ / 1000000)*/;
+
+	mips_count_set (tmo);
+	while ((ulong)((mips_count_get() - start)) < tmo) ;
+
+}
+
+
+void mdelay (unsigned long msec)
+{
+       int i,j;
+	   for(i=0;i<msec;i++)
+	   {
+	      __udelay(1000);
+	   }
+
+}
+									  
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On MIPS it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return mips_count_get();
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On MIPS it returns the number of timer ticks per second.
+ */
+ulong get_tbclk(void)
+{
+	return CONFIG_SYS_HZ;
+}
+
+unsigned long ReadReg (unsigned long base, unsigned long offset ) {
+
+        volatile unsigned long *ptr;
+
+        ptr = (unsigned long *) (base + offset);
+        return *ptr;
+}
+
+void WriteReg(unsigned long add, unsigned long offset, unsigned long val) {
+
+        volatile unsigned long *ptr;
+
+        ptr = (unsigned long *) (add + offset);
+
+        *ptr = val;
+}
+
+void ReadModWriteReg(unsigned long add, unsigned long offset, unsigned long val, unsigned long mask)
+{
+
+        volatile unsigned long *ptr;
+        unsigned long regVal;
+
+        ptr = (unsigned long *) (add + offset);
+        regVal = (*ptr) & (~mask);
+        regVal = regVal | val;
+
+        *ptr = regVal;
+}
