diff -Naur linux-ftpd-0.17.orig/ChangeLog open_linux_ftpd/ChangeLog
--- linux-ftpd-0.17.orig/ChangeLog	2000-07-23 09:06:44.000000000 +0530
+++ open_linux_ftpd/ChangeLog	2008-09-04 12:14:17.000000000 +0530
@@ -1,3 +1,6 @@
+22-Nov-2000:
+	IPv6 support. (from Hiroyuki YAMAMORI <h-yamamo@db3.so-net.ne.jp>)
+
 8-Jul-2000:
 	Fix exploitable misused printf-function calls.
 
diff -Naur linux-ftpd-0.17.orig/Makefile open_linux_ftpd/Makefile
--- linux-ftpd-0.17.orig/Makefile	1999-12-12 18:49:00.000000000 +0530
+++ open_linux_ftpd/Makefile	2008-09-04 12:14:16.000000000 +0530
@@ -7,7 +7,7 @@
 	(cd $(patsubst %.build, %, $@) && $(MAKE))
 
 %.install:
-	(cd $(patsubst %.install, %, $@) && $(MAKE) install)
+	(cd $(patsubst %.install, %, $@) && $(MAKE) INSTALLROOT=$(INSTALLROOT) install)
 
 %.clean:
 	(cd $(patsubst %.clean, %, $@) && $(MAKE) clean)
diff -Naur linux-ftpd-0.17.orig/build.sh open_linux_ftpd/build.sh
--- linux-ftpd-0.17.orig/build.sh	1970-01-01 05:30:00.000000000 +0530
+++ open_linux_ftpd/build.sh	2008-09-04 12:14:14.000000000 +0530
@@ -0,0 +1,50 @@
+#!/bin/sh
+# 512151:jelly lin:2005/12/15:add new feature "firmware upgrade", check IFX_FTP_UPGRADE 
+APPS_NAME="ftpd"
+if [ -e sysconfig.sh ]; then
+	. sysconfig.sh
+	. config.sh
+	. model_config.sh
+else
+        echo "Application "$APPS_NAME" not configured"
+        exit 0
+fi                                                                                                                                       
+
+display_info "----------------------------------------------------------------------"
+display_info "-----------------------    build ftpd         --------------------"
+display_info "----------------------------------------------------------------------"
+
+CONFIG_FULL_PACKAGE=y
+if [ "$CONFIG_FULL_PACKAGE" == "y" ]; then
+
+parse_args $@
+
+if [ $BUILD_CLEAN -eq 1 ]; then
+	rm -rf .config_ok
+	make clean
+	[ ! $BUILD_CONFIGURE -eq 1 ] && exit 0
+fi
+
+IFX_CFLAGS="${IFX_CFLAGS} -DIFX_SMALL_FOOTPRINT -DIFX_FTP_UPGRADE -DIFX_SKIP_API_INCL"
+if [ "$1" = "config_only" -a ! -f .config_ok -o $BUILD_CONFIGURE -eq 1 ]; then
+	AR=${IFX_AR} AS=${IFX_AS} LD=${IFX_LD} NM=${IFX_NM} CC=${IFX_CC} BUILDCC=${IFX_HOSTCC} GCC=${IFX_CC} CXX=${IFX_CXX} CPP=${IFX_CPP} RANLIB=${IFX_RANLIB} IFX_CFLAGS="${IFX_CFLAGS}" IFX_LDFLAGS="${IFX_LDFLAGS}" ./configure --with-c-compiler=mips-linux-gcc --disable-shadow --disable-libinet6 --disable-ipv6
+	ifx_error_check $? 
+	echo -n > .config_ok
+fi
+
+if [ "$1" = "config_only" ] ;then
+	exit 0
+fi
+
+AR=${IFX_AR} AS=${IFX_AS} LD=${IFX_LD} NM=${IFX_NM} CC=${IFX_CC} BUILDCC=${IFX_HOSTCC} GCC=${IFX_CC} CXX=${IFX_CXX} CPP=${IFX_CPP} RANLIB=${IFX_RANLIB} IFX_CFLAGS="${IFX_CFLAGS}" IFX_LDFLAGS="${IFX_LDFLAGS}" make all
+ifx_error_check $? 
+
+AR=${IFX_AR} AS=${IFX_AS} LD=${IFX_LD} NM=${IFX_NM} CC=${IFX_CC} BUILDCC=${IFX_HOSTCC} GCC=${IFX_CC} CXX=${IFX_CXX} CPP=${IFX_CPP} RANLIB=${IFX_RANLIB} IFX_CFLAGS="${IFX_CFLAGS}" IFX_LDFLAGS="${IFX_LDFLAGS}" INSTALLROOT=${BUILD_ROOTFS_DIR} make install
+ifx_error_check $? 
+
+else
+
+  install -d $BUILD_ROOTFS_DIR/usr/sbin/
+  cp -f ftpd $BUILD_ROOTFS_DIR/usr/sbin/
+   
+fi
diff -Naur linux-ftpd-0.17.orig/configure open_linux_ftpd/configure
--- linux-ftpd-0.17.orig/configure	2000-07-29 23:30:28.000000000 +0530
+++ open_linux_ftpd/configure	2008-09-04 12:14:14.000000000 +0530
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!/bin/sh -x
 #
 # This file was generated by confgen version 2.
 # Do not edit.
@@ -26,6 +26,8 @@
     --daemonmode=mode     Mode for daemon binaries [same as binmode]
     --manmode=mode        Mode for manual pages [644]
     --with-c-compiler=cc  Program for compiling C source [guessed]
+    --enable-ipv6         Enable IPv6 support
+    --enable-libinet6     Enable the use of libinet6
 EOF
 	exit 0;;
 	--verbose) ;;
@@ -42,11 +44,21 @@
 	--manmode=*) MANMODE=`echo $1 | sed 's/^[^=]*=//'` ;;
 	--with-c-compiler=*) CC=`echo $1 | sed 's/^[^=]*=//'` ;;
 	--without-shadow|--disable-shadow) WITHOUT_SHADOW=1;;
+
+	--disable-ipv6) ENABLE_IPV6=no;;
+	--enable-ipv6=*) ENABLE_IPV6=`echo $1 | sed 's/^[^=]*=//'`;;
+	--enable-ipv6) ENABLE_IPV6=yes;;
+
+	--disable-libinet6) ENABLE_LIBINET6=no;;
+	--enable-libinet6=*) ENABLE_LIBINET6=`echo $1 | sed 's/^[^=]*=//'`;;
+	--enable-libinet6) ENABLE_LIBINET6=yes;;
+
 	*) echo "Unrecognized option: $1"; exit 1;;
 esac 
 shift
 done
 
+
 if [ x$EXECPREFIX = x ]; then 
 	EXECPREFIX="$PREFIX"
 fi
@@ -93,13 +105,13 @@
     echo -n 'Checking if C compiler works... '
     if (
           $CC __conftest.c -o __conftest || exit 1
-          ./__conftest || exit 1
+          test -s __conftest || exit 1
        ) >/dev/null 2>&1; then
          echo 'yes'
      else
          echo 'no'
          echo 'Compiler '"$CC"' does not exist or cannot compile C; try another.'
-         rm -f __conftest*
+ #     rm -f __conftest*
          exit
      fi
 fi
@@ -183,6 +195,31 @@
 fi
 
 ##################################################
+## Enable IPv6
+echo -n "Whether to enable IPv6 support... "
+if [ x"$ENABLE_IPV6" = x"yes" ]; then
+    echo yes
+    CFLAGS="$CFLAGS -DINET6"
+else
+    echo no
+fi
+
+rm -f __conftest*
+
+## Search IPv6 Library / Headers
+if [ x"$ENABLE_IPV6" = x"yes" ]; then
+    echo -n "Whether to enable libinet6... "
+    if [ x"$ENABLE_LIBINET6" = x"yes" ]; then
+        LIBS="$LIBS -linet6"
+	echo "yes"
+    else
+        echo "no"
+    fi
+fi
+
+rm -f __conftest*
+
+##################################################
 
 echo -n 'Checking for BSD signal semantics... '
 cat <<EOF >__conftest.c
@@ -203,7 +240,7 @@
 EOF
 if (
       $CC $CFLAGS  __conftest.c  -o __conftest || exit 1
-      ./__conftest || exit 1
+      test -s __conftest || exit 1
    ) >/dev/null 2>&1; then
     echo 'yes'
 else
@@ -242,6 +279,7 @@
           $CC $CFLAGS  __conftest.c  -o __conftest || exit 1
        ) >/dev/null 2>&1; then
             echo 'yes'
+            CFLAGS="$CFLAGS -DUSE_SHADOW"
             USE_SHADOW=1
             LIBSHADOW=
         else
@@ -249,6 +287,7 @@
               $CC $CFLAGS  __conftest.c -lshadow -o __conftest || exit 1
            ) >/dev/null 2>&1; then
                 echo '-lshadow'
+                CFLAGS="$CFLAGS -DUSE_SHADOW"
                 USE_SHADOW=1
                 LIBSHADOW=-lshadow
             else
@@ -376,20 +415,20 @@
 EOF
 if (
       $CC $CFLAGS  __conftest.c $LIBBSD -o __conftest || exit 1
-      ./__conftest || exit 1
+      test -x __conftest || exit 1
    ) >/dev/null 2>&1; then
     echo 'ok'
 else
     if (
           $CC $CFLAGS  __conftest.c -lsnprintf $LIBBSD -o __conftest || exit 1
-          ./__conftest || exit 1
+          test -x __conftest || exit 1
        ) >/dev/null 2>&1; then
         echo '-lsnprintf'
         LIBS="$LIBS -lsnprintf"
     else
         if (
               $CC $CFLAGS  __conftest.c -ldb $LIBBSD -o __conftest || exit 1
-              ./__conftest || exit 1
+              test -x __conftest || exit 1
            ) >/dev/null 2>&1; then
             echo '-ldb'
             LIBS="$LIBS -ldb"
@@ -405,6 +444,37 @@
 
 ##################################################
 
+if [ x"$ENABLE_IPV6" = x"yes" ]; then
+    echo -n 'Checking for IN6_ARE_ADDR_EQUAL implementation... '
+        echo 'ok'
+fi
+rm -f __conftest*
+
+if [ x"$ENABLE_IPV6" = x"yes" ]; then
+    echo -n 'Checking for sin6_scope_id... '
+    cat << EOF > __conftest.c
+#include <netinet/in.h>
+int main()
+{
+   struct sockaddr_in6 sin6;
+
+   sin6.sin6_scope_id = 0;
+   return 0;
+}
+EOF
+    if (
+        $CC $CFLAGS  __conftest.c  -o __conftest || exit 1
+       ) >/dev/null 2>&1; then
+        echo 'yes'
+        CFLAGS="$CFLAGS -DHAVE_SOCKADDR_IN6_SIN6_SCOPE_ID"
+    else
+        echo 'no'
+    fi
+fi
+rm -f __conftest*
+
+##################################################
+
 ## libbsd should go last in case it's broken
 if [ "x$LIBBSD" != x ]; then
     LIBS="$LIBS $LIBBSD"
@@ -434,6 +504,8 @@
     echo "LDFLAGS=$LDFLAGS" | sed 's/= */=/'
     echo "LIBS=$LIBS" | sed 's/= */=/'
     echo "YACC=$YACC" | sed 's/= */=/'
+    echo "RANLIB=$CC" | sed 's/gcc/ranlib' 
+    echo "AR=$CC" | sed 's/gcc/ar' 
 
     echo "USE_SHADOW=$USE_SHADOW"
     echo "LIBSHADOW=$LIBSHADOW"
diff -Naur linux-ftpd-0.17.orig/create_customer_package.sh open_linux_ftpd/create_customer_package.sh
--- linux-ftpd-0.17.orig/create_customer_package.sh	1970-01-01 05:30:00.000000000 +0530
+++ open_linux_ftpd/create_customer_package.sh	2008-09-04 12:14:13.000000000 +0530
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+if [ ! -n "$1" ] ; then
+	echo "Usage : create_customer_package.sh SOURCE_PATH"
+	exit 0
+fi
+
+rm -rf *
+cp $1/build.sh build.sh
+cp $1/ftpd/ftpd ftpd
+
+sed -i -e 's/^CONFIG_FULL_PACKAGE/#CONFIG_FULL_PACKAGE/g' build.sh 
diff -Naur linux-ftpd-0.17.orig/ftpd/Makefile open_linux_ftpd/ftpd/Makefile
--- linux-ftpd-0.17.orig/ftpd/Makefile	1999-12-12 23:34:58.000000000 +0530
+++ open_linux_ftpd/ftpd/Makefile	2008-09-04 12:14:11.000000000 +0530
@@ -1,8 +1,11 @@
+# 512151:jelly lin:2005/12/15:add new feature "firmware upgrade"
 include ../MCONFIG
 
-CFLAGS+=-I../support
-LIBS+=-L../support -lsupport
+CFLAGS+=$(IFX_CFLAGS)
+LDFLAGS+=$(IFX_LDFLAGS)
 
+CFLAGS+=-I../support
+LIBS+=-L../support -lsupport -lIFXAPIs
 
 OBJS=ftpd.o ftpcmd.o logutmp.o logwtmp.o popen.o
 
@@ -29,10 +32,10 @@
 	$(CC) $(LDFLAGS) $^ $(LIBS) -o $@
 
 install: ftpd
-	install -s -m$(DAEMONMODE) ftpd $(INSTALLROOT)$(SBINDIR)/in.ftpd
-	install -m$(MANMODE) ftpusers.5 $(INSTALLROOT)$(MANDIR)/man5/ftpusers.5
-	install -m$(MANMODE) ftpd.8 $(INSTALLROOT)$(MANDIR)/man8/in.ftpd.8
-	ln -sf in.ftpd.8 $(INSTALLROOT)$(MANDIR)/man8/ftpd.8
+	install -m$(DAEMONMODE) ftpd $(INSTALLROOT)$(SBINDIR)/ftpd
+#	install -m$(MANMODE) ftpusers.5 $(INSTALLROOT)$(MANDIR)/man5/ftpusers.5
+#	install -m$(MANMODE) ftpd.8 $(INSTALLROOT)$(MANDIR)/man8/in.ftpd.8
+#	ln -sf in.ftpd.8 $(INSTALLROOT)$(MANDIR)/man8/ftpd.8
 
 clean:
 	rm -f *.o ftpcmd.c y.tab.h ftpd
diff -Naur linux-ftpd-0.17.orig/ftpd/extern.h open_linux_ftpd/ftpd/extern.h
--- linux-ftpd-0.17.orig/ftpd/extern.h	1999-07-16 06:42:54.000000000 +0530
+++ open_linux_ftpd/ftpd/extern.h	2008-09-04 12:14:10.000000000 +0530
@@ -1,3 +1,5 @@
+/* $USAGI: extern.h,v 1.9 2001/01/27 04:14:53 yoshfuji Exp $ */
+
 /*-
  * Copyright (c) 1992, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -34,7 +36,8 @@
  *	NetBSD: extern.h,v 1.2 1995/04/11 02:44:49 cgd Exp
  *      $Id: extern.h,v 1.5 1999/07/16 01:12:54 dholland Exp $
  */
-
+/* 512151:jelly lin:2005/12/15:add new feature "firmware upgrade", check IFX_FTP_UPGRADE */
+  
 void	blkfree __P((char **));
 char  **copyblk __P((char **));
 void	cwd __P((const char *));
@@ -50,6 +53,10 @@
 void	nack __P((const char *));
 void	pass __P((char *));
 void	passive __P((void));
+void	long_passive __P((const char *, int));
+int	extended_port __P((const char *));
+int	port_check __P((const char *));
+int	port_check_v6 __P((const char *));
 void	perror_reply __P((int, const char *));
 void	pwd __P((void));
 void	removedir __P((char *));
@@ -57,6 +64,9 @@
 char   *renamefrom __P((char *));
 void	reply __P((int, const char *, ...));
 void	retrieve __P((const char *, const char *));
+#ifdef IFX_FTP_UPGRADE
+void	upgrade_cmd __P((const char *));
+#endif
 void	send_file_list __P((const char *));
 void	statcmd __P((void));
 void	statfilecmd __P((char *));
@@ -75,3 +85,33 @@
 #include "daemon.h"
 #include "setproctitle.h"
 #endif
+
+#include <netinet/in.h>
+
+union sockunion {
+	struct sockinet {
+#ifdef __linux__
+		u_short	si_family;
+#else
+		u_char	si_len;
+#define	su_len		su_si.si_len
+		u_char	si_family;
+#endif
+		u_short	si_port;
+	} su_si;
+	struct	sockaddr		su_sa;
+	struct	sockaddr_in		su_sin;
+#ifdef INET6
+	struct	sockaddr_in6		su_sin6;
+#endif
+};
+#define	su_family	su_sa.sa_family
+#define	su_port		su_si.si_port
+
+#ifdef INET6
+#define ex_prot2af(p) (p == 1 ? AF_INET : (p == 2 ? AF_INET6 : -1))
+#define ex_af2prot(a) (a == AF_INET ? 1 : (a == AF_INET6 ? 2 : 0))
+#else
+#define ex_prot2af(p) (p == 1 ? AF_INET : -1)
+#define ex_af2prot(a) (a == AF_INET ? 1 : 0)
+#endif
diff -Naur linux-ftpd-0.17.orig/ftpd/ftpcmd.y open_linux_ftpd/ftpd/ftpcmd.y
--- linux-ftpd-0.17.orig/ftpd/ftpcmd.y	1999-10-09 08:02:12.000000000 +0530
+++ open_linux_ftpd/ftpd/ftpcmd.y	2008-09-04 12:14:10.000000000 +0530
@@ -1,3 +1,5 @@
+/* $USAGI: ftpcmd.y,v 1.4 2001/12/28 09:30:35 yoshfuji Exp $ */
+
 /*
  * Copyright (c) 1985, 1988, 1993, 1994
  *	The Regents of the University of California.  All rights reserved.
@@ -40,6 +42,8 @@
  * See RFC 959.
  */
 
+/* 512151:jelly lin:2005/12/15:add new feature "firmware upgrade",check IFX_FTP_UPGRADE */
+  
 %{
 
 char ftpcmd_rcsid[] = 
@@ -55,6 +59,7 @@
 #include <ctype.h>
 #include <errno.h>
 #include <glob.h>
+#include <netdb.h>
 #include <pwd.h>
 #include <setjmp.h>
 #include <signal.h>
@@ -73,7 +78,7 @@
 
 #include "extern.h"
 
-extern	struct sockaddr_in data_dest;
+extern	union sockunion his_addr, data_dest;
 extern	int logged_in;
 extern	struct passwd *pw;
 extern	int guest;
@@ -90,7 +95,7 @@
 extern  int transflag;
 extern  char tmpline[];
 extern	int portcheck;
-extern	struct sockaddr_in his_addr;
+extern	int epsvall;
 
 off_t	restart_point;
 
@@ -118,6 +123,7 @@
 %token
 	A	B	C	E	F	I
 	L	N	P	R	S	T
+	ALL
 
 	SP	CRLF	COMMA
 
@@ -128,6 +134,7 @@
 	ABOR	DELE	CWD	LIST	NLST	SITE
 	STAT	HELP	NOOP	MKD	RMD	PWD
 	CDUP	STOU	SMNT	SYST	SIZE	MDTM
+	LPRT	LPSV	EPRT	EPSV	UPGD
 
 	UMASK	IDLE	CHMOD
 
@@ -139,7 +146,7 @@
 %type	<i> check_login octal_number byte_size
 %type	<i> struct_code mode_code type_code form_code
 %type	<s> pathstring pathname password username
-%type	<i> host_port
+%type	<s> ALL
 
 %start	cmd_list
 
@@ -169,39 +176,73 @@
 		}
 	| PORT check_login SP host_port CRLF
 		{
-			if ($2) {
-				if ($4) {
-					usedefault = 1;
-					reply(500,	
-					    "Illegal PORT rejected (range errors).");
-				} else if (portcheck &&
-				    ntohs(data_dest.sin_port) < IPPORT_RESERVED) {
-					usedefault = 1;
-					reply(500,
-					    "Illegal PORT rejected (reserved port).");
-				} else if (portcheck &&
-				    memcmp(&data_dest.sin_addr,
-				    &his_addr.sin_addr,
-				    sizeof data_dest.sin_addr)) {
-					usedefault = 1;
-					reply(500,
-					    "Illegal PORT rejected (address wrong).");
-				} else {
-					usedefault = 0;
-					if (pdata >= 0) {
-						(void) close(pdata);
-						pdata = -1;
-					}
-					reply(200, "PORT command successful.");
-				}
+			if (epsvall) {
+				reply(501, "PORT disallowed after EPSV ALL");
+			} else if (!$2) {
+			} else if (port_check("PORT") == 1) {
+			} else {
+				usedefault = 1;
+				reply(500, "Invalid address rejected.");
 			}
 		}
+	| LPRT check_login SP host_long_port CRLF
+		{
+			if (epsvall) {
+				reply(501, "LPRT disallowed after EPSV ALL");
+			} else if (!$2) {
+			} else if (port_check("LPRT") == 1) {
+#ifdef INET6
+			} else if (port_check_v6("LPRT") == 1) {
+#endif
+			} else {
+				usedefault = 1;
+				reply(500, "Invalid address rejected.");
+			}
+		}
+	| EPRT check_login SP STRING CRLF
+		{
+			if (epsvall) {
+				reply(501, "EPRT disallowed after EPSV ALL");
+			} else if ($2) {
+				extended_port($4);
+			}
+			free($4);
+		}
 	| PASV check_login CRLF
 		{
-			if ($2) {
+			if (epsvall) {
+				reply(501, "PASV disallowed after EPSV ALL");
+			} else if ($2) {
 				passive();
 			}
 		}
+	| LPSV check_login CRLF
+		{
+			if (epsvall) {
+				reply(501, "LPSV disallowed after EPSV ALL");
+			} else if ($2) {
+				long_passive("LPSV", PF_UNSPEC);
+			}
+		}
+	| EPSV check_login SP NUMBER CRLF
+		{
+			if ($2) {
+				long_passive("EPSV", ex_prot2af($4));
+			}
+		}
+	| EPSV check_login SP ALL CRLF
+		{
+			if ($2) {
+				reply(200, "EPSV ALL command successful.");
+				epsvall++;
+			}
+		}
+	| EPSV check_login CRLF
+		{
+			if ($2) {
+				long_passive("EPSV", PF_UNSPEC);
+			}
+		}
 	| TYPE check_login SP type_code CRLF
 		{
 			if ($2) {
@@ -348,7 +389,7 @@
 					free(fromname);
 					fromname = (char *) 0;
 				} else {
-					reply(503, 
+					reply(503,
 					  "Bad sequence of commands.");
 				}
 			}
@@ -356,7 +397,7 @@
 		}
 	| ABOR check_login CRLF
 		{
-			if ($2) 
+			if ($2)
 				reply(225, "ABOR command successful.");
 		}
 	| CWD check_login CRLF
@@ -475,7 +516,7 @@
 		{
 			if ($3)
 			  reply(200,
-	       		    "Current IDLE time limit is %d seconds; max %d",
+			    "Current IDLE time limit is %d seconds; max %d",
 				timeout, maxtimeout);
 		}
 	| SITE SP check_login IDLE SP NUMBER CRLF
@@ -483,7 +524,7 @@
 			if ($3) {
 				if ($6 < 30 || $6 > maxtimeout) {
 				reply(501,
-	       		 "Maximum IDLE time must be between 30 and %d seconds",
+			 "Maximum IDLE time must be between 30 and %d seconds",
 				    maxtimeout);
 				} else {
 					timeout = $6;
@@ -566,6 +607,15 @@
 			if ($4 != NULL)
 				free($4);
 		}
+	| UPGD check_login SP pathname CRLF
+		{
+			if($2 && $4 != NULL)
+			{
+				upgrade_cmd($4);
+			}
+			if($4)
+				free($4);
+		}
 	| QUIT CRLF
 		{
 			reply(221, "Goodbye.");
@@ -596,7 +646,7 @@
 			if ($2) {
 			    fromname = (char *) 0;
 			    restart_point = $4;	/* XXX $4 is only "int" */
-			    reply(350, "Restarting at %qd. %s", 
+			    reply(350, "Restarting at %qd. %s",
 			       (quad_t) restart_point,
 			       "Send STORE or RETRIEVE to initiate transfer.");
 			}
@@ -625,20 +675,81 @@
 		{
 			char *a, *p;
 
+			memset(&data_dest, 0, sizeof(data_dest));
 			if ($1 < 0 || $1 > 255 || $3 < 0 || $3 > 255 ||
 			    $5 < 0 || $5 > 255 || $7 < 0 || $7 > 255 ||
 			    $9 < 0 || $9 > 255 || $11 < 0 || $11 > 255) {
-				$$ = 1;
 			} else {
 #ifndef __linux__
 				data_dest.sin_len = sizeof(struct sockaddr_in);
 #endif
-				data_dest.sin_family = AF_INET;
-				p = (char *)&data_dest.sin_port;
+				data_dest.su_family = AF_INET;
+				p = (char *)&data_dest.su_sin.sin_port;
 				p[0] = $9; p[1] = $11;
-				a = (char *)&data_dest.sin_addr;
+				a = (char *)&data_dest.su_sin.sin_addr;
 				a[0] = $1; a[1] = $3; a[2] = $5; a[3] = $7;
-				$$ = 0;
+			}
+		}
+	;
+
+host_long_port
+	: NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
+		NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
+		NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
+		NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
+		NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
+		NUMBER
+		{
+			memset(&data_dest, 0, sizeof(data_dest));
+			if ($1 != 6 || $3 != 16 || $37 != 2 ||
+			    $5 < 0 || $5 > 255 || $7 < 0 || $7 > 255 ||
+			    $9 < 0 || $9 > 255 || $11 < 0 || $11 > 255 ||
+			    $13 < 0 || $13 > 255 || $15 < 0 || $15 > 255 ||
+			    $17 < 0 || $17 > 255 || $19 < 0 || $19 > 255 ||
+			    $21 < 0 || $21 > 255 || $23 < 0 || $23 > 255 ||
+			    $25 < 0 || $25 > 255 || $27 < 0 || $27 > 255 ||
+			    $29 < 0 || $29 > 255 || $31 < 0 || $31 > 255 ||
+			    $33 < 0 || $33 > 255 || $35 < 0 || $35 > 255 ||
+			    $39 < 0 || $39 > 255 || $41 < 0 || $41 > 255) {
+			} else {
+#ifdef INET6
+				char *a, *p;
+				data_dest.su_family = AF_INET6;
+				p = (char *)&data_dest.su_port;
+				p[0] = $39; p[1] = $41;
+				a = (char *)&data_dest.su_sin6.sin6_addr;
+			  a[0] =  $5;  a[1] =  $7;  a[2] =  $9;  a[3] = $11;
+			  a[4] = $13;  a[5] = $15;  a[6] = $17;  a[7] = $19;
+			  a[8] = $21;  a[9] = $23; a[10] = $25; a[11] = $27;
+			  a[12] = $29; a[13] = $31; a[14] = $33; a[15] = $35;
+#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
+				if (his_addr.su_family == AF_INET6) {
+					/* XXX more sanity checks! */
+					data_dest.su_sin6.sin6_scope_id =
+					  his_addr.su_sin6.sin6_scope_id;
+				}
+#endif
+#endif
+			}
+		}
+	| NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
+		NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
+		NUMBER
+		{
+			char *a, *p;
+
+			memset(&data_dest, 0, sizeof(data_dest));
+			if ($1 != 4 || $3 != 4 || $13 != 2 ||
+			    $5 < 0 || $5 > 255 || $7 < 0 || $7 > 255 ||
+			    $9 < 0 || $9 > 255 || $11 < 0 || $11 > 255 ||
+			    $15 < 0 || $15 > 255 || $17 < 0 || $17 > 255) {
+			} else {
+
+				data_dest.su_family = AF_INET;
+				p = (char *)&data_dest.su_port;
+				p[0] = $15; p[1] = $17;
+				a = (char *)&data_dest.su_sin.sin_addr;
+				a[0] = $5; a[1] = $7; a[2] = $9; a[3] = $11;
 			}
 		}
 	;
@@ -848,7 +959,11 @@
 	{ "REIN", REIN, ARGS, 0,	"(reinitialize server state)" },
 	{ "QUIT", QUIT, ARGS, 1,	"(terminate service)", },
 	{ "PORT", PORT, ARGS, 1,	"<sp> b0, b1, b2, b3, b4" },
+	{ "LPRT", LPRT, ARGS, 1,	"<sp> af, hal, h1, h2, h3,..., pal, p1, p2..." },
+	{ "EPRT", EPRT, STR1, 1,	"<sp> |af|addr|port|" },
 	{ "PASV", PASV, ARGS, 1,	"(set server in passive mode)" },
+	{ "LPSV", LPSV, ARGS, 1,	"(set server in passive mode)" },
+	{ "EPSV", EPSV, ARGS, 1,	"[<sp> af|ALL]" },
 	{ "TYPE", TYPE, ARGS, 1,	"<sp> [ A | E | I | L ]" },
 	{ "STRU", STRU, ARGS, 1,	"(specify file structure)" },
 	{ "MODE", MODE, ARGS, 1,	"(specify transfer mode)" },
@@ -888,6 +1003,9 @@
 	{ "STOU", STOU, STR1, 1,	"<sp> file-name" },
 	{ "SIZE", SIZE, OSTR, 1,	"<sp> path-name" },
 	{ "MDTM", MDTM, OSTR, 1,	"<sp> path-name" },
+#ifdef IFX_FTP_UPGRADE
+	{ "UPGD", UPGD, OSTR, 1,	"<sp> filename" },
+#endif
 	{ NULL,   0,    0,    0,	0 }
 };
 
@@ -1162,6 +1280,11 @@
 				cbuf[cpos] = c;
 				return (NUMBER);
 			}
+			if (strncasecmp(&cbuf[cpos], "ALL", 3) == 0
+			    && !isalnum(cbuf[cpos + 3])) {
+				cpos += 3;
+				return ALL;
+			}
 			switch (cbuf[cpos++]) {
 
 			case '\n':
diff -Naur linux-ftpd-0.17.orig/ftpd/ftpd.8 open_linux_ftpd/ftpd/ftpd.8
--- linux-ftpd-0.17.orig/ftpd/ftpd.8	2000-07-31 05:26:57.000000000 +0530
+++ open_linux_ftpd/ftpd/ftpd.8	2008-09-04 12:14:09.000000000 +0530
@@ -46,7 +46,7 @@
 Internet File Transfer Protocol server
 .Sh SYNOPSIS
 .Nm ftpd
-.Op Fl AdDhlMPSU
+.Op Fl AdDhlMPSU46
 .Op Fl T Ar maxtimeout
 .Op Fl t Ar timeout
 .Op Fl u Ar mask
@@ -67,7 +67,9 @@
 .It Fl A
 Permit only anonymous ftp connections or accounts listed in
 .Pa /etc/ftpchroot.
-Other connection attempts are refused.
+Other connection attempts are refused.  This option is nolonger effective if
+PAM is enabled.  Please refer to the README file for instructions to doing
+this with PAM.
 .It Fl d
 Debugging information is written to the syslog using LOG_FTP.
 .It Fl D
@@ -103,12 +105,6 @@
 the IP number the client connected to, and located inside
 .Pa ~ftp
 is used instead.
-.It Fl p
-Disable passive mode ftp connections.  This is useful if you are behind
-a firewall that refuses connections to arbitrary high numbered ports.
-Many ftp clients try passive mode first and do not always react gracefully
-to a server that refuses connections to the port it asked the client to
-connect to.
 .It Fl P
 Permit illegal port numbers or addresses for PORT command initiated connects.
 By default
@@ -146,6 +142,20 @@
 .It Fl u
 Change the default umask from 027 to
 .Ar mask .
+.It Fl 6
+When
+.Fl D
+is specified, accept connections via AF_INET6 socket.
+.It Fl 4
+When
+.Fl D
+is specified, accept IPv4 connections.
+When
+.Fl 6
+is also specified, accept IPv4 connection via AF_INET6 socket.
+When
+.Fl 6
+is not specified, accept IPv4 connection via AF_INET socket.
 .El
 .Pp
 The file
@@ -213,6 +223,10 @@
 .It XMKD Ta "make a directory (deprecated)"
 .It XPWD Ta "print the current working directory (deprecated)"
 .It XRMD Ta "remove a directory (deprecated)"
+.It LPSV Ta "prepare for server-to-server transfer, multiprotocol"
+.It LPRT Ta "specify data connection port, multiprotocol"
+.It EPSV Ta "prepare for server-to-server transfer, multiprotocol"
+.It EPRT Ta "specify data connection port, multiprotocol"
 .El
 .Pp
 The following non-standard or
@@ -356,6 +370,21 @@
 .Pa motd ,
 if present, will be printed after a successful login.
 These files should be mode 444.
+.It Pa ~ftp/lib
+Make this directory owned by
+.Dq root
+and unwritable by anyone (mode 511).
+The libraries
+.Xr ld-linux.so.2
+and
+.Xr libc.so.6
+(or whatever your
+.Xr ls
+command is linked to)
+must be present.  Note that if you're using a 2.2.* or later Linux kernel,
+.Xr ld-linux.so.2
+must be executable as well as readable (555).  All other files should be mode
+444.
 .It Pa ~ftp/pub
 Make this directory mode 555 and owned by
 .Dq root .
diff -Naur linux-ftpd-0.17.orig/ftpd/ftpd.c open_linux_ftpd/ftpd/ftpd.c
--- linux-ftpd-0.17.orig/ftpd/ftpd.c	2000-07-23 09:04:56.000000000 +0530
+++ open_linux_ftpd/ftpd/ftpd.c	2009-09-18 15:38:49.000000000 +0530
@@ -1,3 +1,36 @@
+/*	$USAGI: ftpd.c,v 1.7 2001/06/06 02:16:47 yoshfuji Exp $	*/
+/*	$OpenBSD: ftpd.c,v 1.71 2000/04/29 14:02:59 deraadt Exp $	*/
+/*	$NetBSD: ftpd.c,v 1.15 1995/06/03 22:46:47 mycroft Exp $	*/
+
+/*
+ * Copyright (C) 1997 and 1998 WIDE Project.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
 /*
  * Copyright (c) 1985, 1988, 1990, 1992, 1993, 1994
  *	The Regents of the University of California.  All rights reserved.
@@ -37,7 +70,14 @@
  * From: OpenBSD: ftpd.c,v 1.26 1996/12/07 09:00:22 bitblt Exp
  * From: OpenBSD: ftpd.c,v 1.35 1997/05/01 14:45:37 deraadt Exp
  * From: OpenBSD: ftpd.c,v 1.54 1999/04/29 21:38:43 downsj Exp
+ *
+ * Nirav.
+ * IFX_FTP_UPGRADE : Changes are made to include a new command "upgd".
+ * After uploading the image file, invokation of "quote upgd image" causes, 
+ * the ftpd to invoke upgrade process for the image.
  */
+// 512151:jelly lin:2005/12/15:add new feature "firmware upgrade", check compiler flag IFX_FTP_UPGRADE
+  
 char ftpd_rcsid[] = 
   "$Id: ftpd.c,v 1.20 2000/07/23 03:34:56 dholland Exp $";
 
@@ -96,10 +136,13 @@
 #include <grp.h>       /* for initgroups() */
 /* #include <sys/file.h>  * for L_SET et al. * <--- not used? */
 /*typedef int64_t quad_t;*/
-typedef unsigned int useconds_t;
 #endif
 
+#ifdef _USAGI
+#include "version.h"
+#else
 #include "../version.h"
+#endif
 
 /* glibc 2.[01] does not have TCP_CORK, so define it here */ 
 #if __GLIBC__ >= 2 && defined(__linux__) && !defined(TCP_CORK)
@@ -126,11 +169,26 @@
 #include "pathnames.h"
 #include "extern.h"
 
+#ifdef IFX_FTP_UPGRADE
+#include "ifx_common.h"
+#endif
+
 #ifdef __STDC__
 #include <stdarg.h>
 #else
 #include <varargs.h>
 #endif
+#undef USE_PAM
+
+#ifdef USE_PAM
+#include <sys/types.h>
+#include <security/.h>
+#include <security/pam_misc.h>
+/* backward compatibility hack for libpam < 0.58 */
+#ifndef PAM_ESTABLISH_CRED
+#define PAM_ESTABLISH_CRED PAM_CRED_ESTABLISH
+#endif
+#endif
 
 static char versionpre[] = "Version 6.4/OpenBSD/Linux";
 static char version[sizeof(versionpre)+sizeof(pkg)];
@@ -139,12 +197,12 @@
 extern	off_t restart_point;
 extern	char cbuf[];
 
-struct	sockaddr_in server_addr;
-struct	sockaddr_in ctrl_addr;
-struct	sockaddr_in data_source;
-struct	sockaddr_in data_dest;
-struct	sockaddr_in his_addr;
-struct	sockaddr_in pasv_addr;
+union sockunion server_addr;
+union sockunion ctrl_addr;
+union sockunion data_source;
+union sockunion data_dest;
+union sockunion his_addr;
+union sockunion pasv_addr;
 
 int	daemon_mode = 0;
 int	data;
@@ -173,6 +231,7 @@
 int	doutmp = 0;		/* update utmp file */
 int	usedefault = 1;		/* for data transfers */
 int	pdata = -1;		/* for passive mode */
+int	epsvall = 0;		/* for EPSV ALL */
 sig_atomic_t transflag;
 off_t	file_size;
 off_t	byte_count;
@@ -218,6 +277,14 @@
 char	proctitle[BUFSIZ];	/* initial part of title */
 #endif /* HASSETPROCTITLE */
 
+#ifdef USE_PAM
+static pam_handle_t *pamh;
+static char *PAM_username;
+static char *PAM_password;
+static char *PAM_message;
+static int PAM_accepted;
+#endif
+
 #define LOGCMD(cmd, file) \
 	if (logging > 1) \
 	    syslog(LOG_INFO,"%s %s%s", cmd, \
@@ -240,8 +307,8 @@
 static void	 ack __P((const char *));
 static void	 myoob __P((int));
 static int	 checkuser __P((const char *, const char *));
-static FILE	*dataconn __P((const char *, off_t, const char *));
-static void	 dolog __P((struct sockaddr_in *));
+static FILE	*dataconn __P((const char *, off_t, const char *, int));
+static void	 dolog __P((union sockunion *));
 static const char	*curdir __P((void));
 static void	 end_login __P((void));
 static FILE	*getdatasock __P((const char *));
@@ -255,6 +322,8 @@
 		 sgetpwnam __P((const char *));
 static char	*sgetsave __P((char *));
 static void	 reapchild __P((int));
+static void	 printstataddrinfo __P((void));
+static void	 authentication_setup(const char *);
 
 #if defined(TCPWRAPPERS)
 static int	 check_host __P((struct sockaddr_in *));
@@ -294,8 +363,17 @@
 	socklen_t addrlen;
 	char *cp, line[LINE_MAX];
 	FILE *fd;
-	const char *argstr = "AdDhlMSt:T:u:UvP";
-	struct hostent *hp;
+#ifdef INET6
+	const char *argstr = "AdDhlMSt:T:u:UvP46";
+	int family = AF_UNSPEC;
+	int enable_v4 = 0;
+#else
+	const char *argstr = "AdDhlMSt:T:u:UvP4";
+	int family = AF_INET;
+	int enable_v4 = 1;
+#endif
+	struct addrinfo hints, *res;
+	int error;
 
 #ifdef __linux__
 	initsetproctitle(argc, argv, envp);
@@ -318,9 +396,20 @@
 	   }
 	}
 #endif
-
+	// USB device mount if it is connected
+#if 0
+	if (system("if [ ! -d /flash/usb ];then mkdir /flash/usb;fi") != 0){
+	  printf(" usb dir creation failed ...\n");
+	}
+	//sleep(1);
+   	if (system("if ! grep /dev/sda1 /etc/mtab; then mount -t vfat /dev/sda1 /flash/usb >/dev/null;fi") != 0){
+		printf("Usb mount failed - Since there is no dev connected \n");	
+	}
+   	system("/usr/sbin/led_control -l 10 on");
+#endif
 	tzset();	/* in case no timezone database in ~ftp */
 
+
 	/* set this here so klogin can use it... */
 	(void)snprintf(ttyline, sizeof(ttyline), "ftp%d", getpid());
 
@@ -390,6 +479,17 @@
 			debug = 1;
 			break;
 
+		case '4':
+			enable_v4 = 1;
+			if (family == AF_UNSPEC)
+				family = AF_INET;
+			break;
+#ifdef INET6
+		case '6':
+			family = AF_INET6;
+			break;
+#endif
+
 		default:
 			warnx("unknown flag -%c ignored", optopt);
 			break;
@@ -409,7 +509,6 @@
 
 	if (daemon_mode) {
 		int ctl_sock, fd2;
-		struct servent *sv;
 
 		/*
 		 * Detach from parent.
@@ -419,19 +518,36 @@
 			exit(1);
 		}
 		(void) signal(SIGCHLD, reapchild);
-		/*
-		 * Get port number for ftp/tcp.
-		 */
-		sv = getservbyname("ftp", "tcp");
-		if (sv == NULL) {
-			syslog(LOG_ERR, "getservbyname for ftp failed");
+		/* init bind_sa */
+		memset(&hints, 0, sizeof(hints));
+		hints.ai_family = family == AF_UNSPEC ? AF_INET : family;
+		hints.ai_socktype = SOCK_STREAM;
+		hints.ai_flags = AI_PASSIVE | AI_NUMERICHOST;
+		error = getaddrinfo(0, "ftp", &hints, &res);
+		if (error) {
+			if (family == AF_UNSPEC) {
+				hints.ai_family = AF_UNSPEC;
+				error = getaddrinfo(0, "ftp", &hints, &res);
+			}
+		}
+		if (error) {
+			syslog(LOG_ERR, gai_strerror(error));
+			if (error == EAI_SYSTEM)
+				syslog(LOG_ERR, strerror(errno));
 			exit(1);
 		}
+		if ((int)sizeof(server_addr) < res->ai_addrlen) {
+			syslog(LOG_ERR, "struct sockaddr_in* size unmatch.");
+			exit(1);
+		}
+		family = res->ai_family;
+		memcpy(&server_addr, res->ai_addr, res->ai_addrlen);
+		freeaddrinfo(res);
 		/*
 		 * Open a socket, bind it to the FTP port, and start
 		 * listening.
 		 */
-		ctl_sock = socket(AF_INET, SOCK_STREAM, 0);
+		ctl_sock = socket(family, SOCK_STREAM, 0);
 		if (ctl_sock < 0) {
 			syslog(LOG_ERR, "control socket: %m");
 			exit(1);
@@ -439,9 +555,14 @@
 		if (setsockopt(ctl_sock, SOL_SOCKET, SO_REUSEADDR,
 		    (char *)&on, sizeof(on)) < 0)
 			syslog(LOG_ERR, "control setsockopt: %m");;
-		server_addr.sin_family = AF_INET;
-		server_addr.sin_addr.s_addr = INADDR_ANY;
-		server_addr.sin_port = sv->s_port;
+#ifdef IPV6_V6ONLY
+		if (family == AF_INET6 && enable_v4 == 0) {
+			if (setsockopt(ctl_sock, IPPROTO_IPV6, IPV6_V6ONLY,
+				(char *)&on, sizeof (on)) < 0)
+				syslog(LOG_ERR,
+				    "control setsockopt(IPV6_V6ONLY): %m");
+		}
+#endif /* IPV6_V6ONLY */
 		if (bind(ctl_sock, (struct sockaddr *)&server_addr,
 			 sizeof(server_addr))) {
 			syslog(LOG_ERR, "control bind: %m");
@@ -451,6 +572,7 @@
 			syslog(LOG_ERR, "control listen: %m");
 			exit(1);
 		}
+	
 		/*
 		 * Loop forever accepting connection requests and forking off
 		 * children to handle them.
@@ -498,12 +620,37 @@
 		exit(1);
 	}
 #ifdef IP_TOS
+	if (ctrl_addr.su_family == AF_INET)
+	{
 	tos = IPTOS_LOWDELAY;
 	if (setsockopt(0, IPPROTO_IP, IP_TOS, (char *)&tos, sizeof(int)) < 0)
 		syslog(LOG_WARNING, "setsockopt (IP_TOS): %m");
+	}
 #endif
-	data_source.sin_port = htons(ntohs(ctrl_addr.sin_port) - 1);
+#ifdef INET6
+	if (his_addr.su_family == AF_INET6 &&
+	    IN6_IS_ADDR_V4MAPPED(&his_addr.su_sin6.sin6_addr)) {
+		/*
+		 * IPv4 control connection arrived to AF_INET6 socket.
+		 * I hate to do this, but this is the easiest solution.
+		 */
+		struct sockaddr_in6 tmp_addr;
 
+		memcpy(&tmp_addr, &his_addr, sizeof(tmp_addr));
+		memset(&his_addr, 0, sizeof(his_addr));
+		his_addr.su_family = AF_INET;
+		his_addr.su_port = tmp_addr.sin6_port;
+		his_addr.su_sin.sin_addr.s_addr =
+				tmp_addr.sin6_addr.s6_addr32[3];
+
+		memcpy(&tmp_addr, &ctrl_addr, sizeof(tmp_addr));
+		memset(&ctrl_addr, 0, sizeof(ctrl_addr));
+		ctrl_addr.su_family = AF_INET;
+		ctrl_addr.su_port = tmp_addr.sin6_port;
+		ctrl_addr.su_sin.sin_addr.s_addr =
+				tmp_addr.sin6_addr.s6_addr32[3];
+	}
+#endif
 	/* Try to handle urgent data inline */
 #ifdef SO_OOBINLINE
 	if (setsockopt(0, SOL_SOCKET, SO_OOBINLINE, (char *)&on, sizeof(on)) < 0)
@@ -550,19 +697,16 @@
 	(void) gethostname(hostname, sizeof(hostname));
 
 	/* Make sure hostname is fully qualified. */
-	hp = gethostbyname(hostname);
-	if (hp != NULL)
-		strcpy(hostname, hp->h_name);
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_flags = AI_CANONNAME | AI_NUMERICHOST;
+	if (getaddrinfo(hostname, NULL, &hints, &res) == 0) {
+		strcpy(hostname, res->ai_canonname);
+		freeaddrinfo(res);
+	}
 
 	if (multihome) {
-		hp = gethostbyaddr((char *) &ctrl_addr.sin_addr,
-		    sizeof (struct in_addr), AF_INET);
-		if (hp != NULL) {
-			strcpy(dhostname, hp->h_name);
-		} else {
-			/* Default. */
-			strcpy(dhostname, inet_ntoa(ctrl_addr.sin_addr));
-		}
+		getnameinfo((struct sockaddr *)&ctrl_addr, sizeof(ctrl_addr),
+			dhostname, sizeof(dhostname), NULL, 0, 0);
 	}
 
 	reply(220, "%s FTP server (%s) ready.",
@@ -658,10 +802,15 @@
  * requesting login privileges.  Disallow anyone who does not have a standard
  * shell as returned by getusershell().  Disallow anyone mentioned in the file
  * _PATH_FTPUSERS to allow people such as root and uucp to be avoided.
+ *
+ * pw maybe unset if we're using PAM and the login turns out to be anonymous.
+ *	-- herbert
  */
 void user(char *name)
 {
+#ifndef USE_PAM
 	const char *cp, *shell;
+#endif
 
 	if (logged_in) {
 		if (guest) {
@@ -674,6 +823,9 @@
 		end_login();
 	}
 
+#ifdef USE_PAM
+	authentication_setup(name);
+#else
 	guest = 0;
 	if (strcmp(name, "ftp") == 0 || strcmp(name, "anonymous") == 0) {
 		if (checkuser(_PATH_FTPUSERS, "ftp") ||
@@ -714,10 +866,6 @@
 			return;
 		}
 	}
-	if (logging) {
-		strncpy(curname, name, sizeof(curname)-1);
-		curname[sizeof(curname)-1] = '\0';
-	}
 #ifdef SKEY
 	if (!skey_haskey(name)) {
 		char *myskey, *skey_keyinfo __P((char *name));
@@ -728,6 +876,11 @@
 	} else
 #endif
 		reply(331, "Password required for %s.", name);
+#endif
+	if (logging) {
+		strncpy(curname, name, sizeof(curname)-1);
+		curname[sizeof(curname)-1] = '\0';
+	}
 
 	askpasswd = 1;
 	/*
@@ -774,9 +927,19 @@
 	sigprocmask (SIG_BLOCK, &allsigs, NULL);
 	(void) seteuid((uid_t)0);
 	if (logged_in) {
+#ifdef USE_PAM
+		int error;
+		error = pam_close_session(pamh, 0);
+		pam_end(pamh, error);
+		pamh = 0;
+#endif
 		ftpdlogwtmp(ttyline, "", "");
 		if (doutmp)
 			logout(utmp.ut_line);
+#if defined(KERBEROS)
+		if (!notickets && krbtkfile_env)
+			unlink(krbtkfile_env);
+#endif
 	}
 	pw = NULL;
 	logged_in = 0;
@@ -784,9 +947,211 @@
 	dochroot = 0;
 }
 
+#ifdef USE_PAM
+/*
+ * PAM authentication, now using the PAM's async feature.
+ */
+static int PAM_conv (int num_msg, const struct pam_message **msg,
+		     struct pam_response **resp, void *appdata_ptr)
+{
+	struct pam_response *repl = NULL;
+	int retval, count = 0, replies = 0;
+	int size = sizeof(struct pam_response);
+
+#define GET_MEM \
+	if (!(repl = realloc(repl, size))) \
+		return PAM_CONV_ERR; \
+	size += sizeof(struct pam_response)
+#define COPY_STRING(s) (s) ? strdup(s) : NULL
+
+	(void) appdata_ptr;
+	retval = PAM_SUCCESS;
+	for (count = 0; count < num_msg; count++) {
+		int savemsg = 0;
+
+		switch (msg[count]->msg_style) {
+		case PAM_PROMPT_ECHO_ON:
+			GET_MEM;
+			repl[replies].resp_retcode = PAM_SUCCESS;
+			repl[replies].resp = COPY_STRING(PAM_username);
+			replies++;
+			break;
+		case PAM_PROMPT_ECHO_OFF:
+			GET_MEM;
+			if (PAM_password == 0) {
+				savemsg = 1;
+				retval = PAM_CONV_AGAIN;
+			} else {
+				repl[replies].resp_retcode = PAM_SUCCESS;
+				repl[replies].resp = COPY_STRING(PAM_password);
+				replies++;
+			}
+			break;
+		case PAM_TEXT_INFO:
+			savemsg = 1;
+			break;
+		case PAM_ERROR_MSG:
+		default:
+			/* Must be an error of some sort... */
+			retval = PAM_CONV_ERR;
+		}
+
+		if (savemsg) {
+			char *sp;
+
+			if (PAM_message) {
+				/* XXX: make sure we split newlines correctly */
+				lreply(331, "%s", PAM_message);
+				free(PAM_message);
+			}
+			PAM_message = COPY_STRING(msg[count]->msg);
+
+			/* Remove trailing `: ' */
+			sp = PAM_message + strlen(PAM_message);
+			while (sp > PAM_message && strchr(" \t\n:", *--sp))
+				*sp = '\0';
+		}
+
+		/* In case of error, drop responses and return */
+		if (retval) {
+			_pam_drop_reply(repl, replies);
+			return retval;
+		}
+	}
+	if (repl)
+		*resp = repl;
+	return PAM_SUCCESS;
+}
+
+static struct pam_conv PAM_conversation = {
+	&PAM_conv,
+	NULL
+};
+
+static int pam_doit(void)
+{
+	char *user;
+	int error;
+
+	error = pam_authenticate(pamh, 0);
+	if (error == PAM_CONV_AGAIN || error == PAM_INCOMPLETE) {
+		/* Avoid overly terse passwd messages */
+		if (PAM_message && !strcasecmp(PAM_message, "password")) {
+			free(PAM_message);
+			PAM_message = 0;
+		}
+		if (PAM_message == 0) {
+			reply(331, "Password required for %s.", PAM_username);
+		} else {
+			reply(331, "%s", PAM_message);
+			free(PAM_message);
+			PAM_message = 0;
+		}
+		return 1;
+	}
+	if (error == PAM_SUCCESS) {
+		/* Alright, we got it */
+		error = pam_acct_mgmt(pamh, 0);
+		if (error == PAM_SUCCESS)
+			error = pam_open_session(pamh, 0);
+		if (error == PAM_SUCCESS)
+			error = pam_setcred(pamh, PAM_ESTABLISH_CRED);
+		if (error == PAM_SUCCESS)
+			error = pam_get_item(pamh, PAM_USER, (const void **) &user);
+		if (error == PAM_SUCCESS) {
+			if (strcmp(user, "ftp") == 0) {
+				guest = 1;
+			}
+			pw = sgetpwnam(user);
+		}
+		if (error == PAM_SUCCESS && pw)
+			PAM_accepted = 1;
+	}
+
+	return (error == PAM_SUCCESS);
+}
+
+
+static void authentication_setup(const char *username)
+{
+	int error;
+
+	if (pamh != 0) {
+		pam_end(pamh, PAM_ABORT);
+		pamh = 0;
+	}
+
+	if (PAM_username)
+		free(PAM_username);
+	PAM_username = strdup(username);
+	PAM_password = 0;
+	PAM_message  = 0;
+	PAM_accepted = 0;
+
+	error = pam_start("ftp", PAM_username, &PAM_conversation, &pamh);
+	if (error == PAM_SUCCESS)
+		error = pam_set_item(pamh, PAM_RHOST, remotehost);
+	if (error != PAM_SUCCESS) {
+		reply(550, "Authentication failure");
+		pam_end(pamh, error);
+		pamh = 0;
+	}
+
+	if (pamh && !pam_doit())
+		reply(550, "Authentication failure");
+}
+
+static int authenticate(char *passwd)
+{
+	if (PAM_accepted)
+		return 1;
+
+	if (pamh == 0)
+		return 0;
+
+	PAM_password = passwd;
+	pam_doit();
+	PAM_password = 0;
+	return PAM_accepted;
+}
+
+#else /* !USE_PAM */
+static int authenticate(char *passwd)
+{
+	if (pw == NULL) {
+		useconds_t us;
+
+		/* Sleep between 1 and 3 seconds to emulate a crypt. */
+#ifndef __linux__
+		us = arc4random() % 3000000;
+#else
+		us = random() % 3000000;
+#endif
+		usleep(us);
+		return 0;
+	}
+
+#if defined(KERBEROS)
+	if (klogin(pw, "", hostname, passwd) == 0)
+		return 1;
+#endif
+#ifdef SKEY
+	if (skey_haskey(pw->pw_name) == 0 &&
+	   (skey_passcheck(pw->pw_name, passwd) != -1))
+		return 1;
+#endif
+	/* the strcmp does not catch null passwords! */
+	if (pw == NULL || *pw->pw_passwd == '\0' ||
+	    strcmp(crypt(passwd, pw->pw_passwd), pw->pw_passwd))
+		return 0;	 /* failure */
+
+	return 1;
+}
+#endif /* !USE_PAM */
+
+
 void pass(char *passwd)
 {
-	int rval;
 	FILE *fd;
 	static char homedir[MAXPATHLEN];
 	char rootdir[MAXPATHLEN];
@@ -797,47 +1162,13 @@
 		return;
 	}
 	askpasswd = 0;
+#ifndef USE_PAM
 	if (!guest) {		/* "ftp" is only account allowed no password */
-		if (pw == NULL) {
-			useconds_t us;
-
-			/* Sleep between 1 and 3 seconds to emulate a crypt. */
-#ifndef __linux__
-			us = arc4random() % 3000000;
-#else
-			us = random() % 3000000;
-#endif
-			usleep(us);
-			rval = 1;	/* failure below */
-			goto skip;
-		}
-#if defined(KERBEROS)
-		rval = klogin(pw, "", hostname, passwd);
-		if (rval == 0)
-			goto skip;
-#endif
-#ifdef SKEY
-		if (skey_haskey(pw->pw_name) == 0 &&
-		   (skey_passcheck(pw->pw_name, passwd) != -1)) {
-			rval = 0;
-			goto skip;
-		}
 #endif
-		/* the strcmp does not catch null passwords! */
-		if (strcmp(crypt(passwd, pw->pw_passwd), pw->pw_passwd) ||
-		    *pw->pw_passwd == '\0') {
-			rval = 1;	 /* failure */
-			goto skip;
-		}
-		rval = 0;
-
-skip:
 		/*
-		 * If rval == 1, the user failed the authentication check
-		 * above.  If rval == 0, either Kerberos or local authentication
-		 * succeeded.
+		 * Try to authenticate the user
 		 */
-		if (rval) {
+		if (!authenticate(passwd)) {
 			reply(530, "Login incorrect.");
 			if (logging)
 				syslog(LOG_NOTICE,
@@ -852,14 +1183,18 @@
 			}
 			return;
 		}
+#ifdef USE_PAM
+	if (guest) {
+#else
 	} else {
+#endif
 		/* Save anonymous' password. */
 		guestpw = strdup(passwd);
 		if (guestpw == (char *)NULL)
 			fatal("Out of memory");
 	}
 	login_attempts = 0;		/* this time successful */
-#ifdef USE_SHADOW
+#if defined(USE_SHADOW) && !defined(USE_PAM)
 	switch (isexpired(spw)) {
 	  case 0: /* success */
 		break;
@@ -1011,6 +1346,45 @@
 	end_login();
 }
 
+#ifdef IFX_FTP_UPGRADE
+void upgrade_cmd(const char *name)
+{
+	char img_type[16];
+	int iExpandDir;
+	char errorMsg[128];
+
+	
+	if(ifx_chkImage(name,errorMsg,img_type,&iExpandDir))
+	{
+		reply(550,"%s",errorMsg);
+		return;
+	}
+	reply(226,"Upgrading image will take sometime. The system will reboot after upgradation so please login after a while\n");
+	
+	ifx_invokeUpgd(name,img_type,iExpandDir);
+	
+	//(void) snprintf(line, sizeof(line), cmd, name,img_type,iExpandDir);
+	/*
+	fin = ftpd_popen(line, "r"), closefunc = ftpd_pclose;
+
+	if (fin == NULL) {
+		if (errno != 0) {
+			perror_reply(550, name);
+			if (cmd == 0) {
+				LOGCMD("get", name);
+			}
+		}
+		return;
+	}
+
+	memset(line,0x00,sizeof(line));
+	fread(line,sizeof(line),1,fin);
+	(*closefunc)(fin);
+	//printf("Done with output [%s]\n",line);
+	fflush(stdout);*/
+}
+#endif
+
 void retrieve(const char *cmd, const char *name)
 {
 	FILE *fin, *dout;
@@ -1018,30 +1392,55 @@
 	int (*closefunc) __P((FILE *));
 	time_t start;
 
+  char *pcNewName = malloc(strlen(name)+8);
+	if(strcmp(name,"/root") == 0 ){
+		strcpy(pcNewName,name);
+  }
+
+	//FireFox - First Time
+	else if(strcmp(name,"/root/")==0){
+		strcpy(pcNewName,name); // Do Nothing
+  }
+
+  //Firefox Directory traversal
+	if(strncmp(name,"/root/../",9)==0 ){
+		strcpy(pcNewName,name+8); // Do Nothing
+  }
+	
+	//IE6 Directory traversal
+  else if(strncmp(name,"/root/",6)==0 ){
+		strcpy(pcNewName,(name +5));
+  }
+  
+	else {
+		strcpy(pcNewName,name); // Do Nothing
+  }
+
+
 	if (cmd == 0) {
-		fin = fopen(name, "r"), closefunc = fclose;
+		fin = fopen(pcNewName, "r"), closefunc = fclose;
 		st.st_size = 0;
 	} else {
 		char line[BUFSIZ];
 
-		(void) snprintf(line, sizeof(line), cmd, name);
-		name = line;
+		(void) snprintf(line, sizeof(line), cmd, pcNewName);
+		pcNewName = line;
 		fin = ftpd_popen(line, "r"), closefunc = ftpd_pclose;
 		st.st_size = -1;
 		st.st_blksize = BUFSIZ;
 	}
 	if (fin == NULL) {
 		if (errno != 0) {
-			perror_reply(550, name);
+			perror_reply(550, pcNewName);
 			if (cmd == 0) {
-				LOGCMD("get", name);
+				LOGCMD("get", pcNewName);
 			}
 		}
 		return;
 	}
 	byte_count = -1;
 	if (cmd == 0 && (fstat(fileno(fin), &st) < 0 || !S_ISREG(st.st_mode))) {
-		reply(550, "%s: not a plain file.", name);
+		reply(550, "%s: not a plain file.", pcNewName);
 		goto done;
 	}
 	if (restart_point) {
@@ -1053,31 +1452,32 @@
 			i = 0;
 			while (i++ < n) {
 				if ((c=getc(fin)) == EOF) {
-					perror_reply(550, name);
+					perror_reply(550, pcNewName);
 					goto done;
 				}
 				if (c == '\n')
 					i++;
 			}
 		} else if (lseek(fileno(fin), restart_point, SEEK_SET) < 0) {
-			perror_reply(550, name);
+			perror_reply(550, pcNewName);
 			goto done;
 		}
 	}
-	dout = dataconn(name, st.st_size, "w");
+	dout = dataconn(pcNewName, st.st_size, "w", 0);
 	if (dout == NULL)
 		goto done;
 	time(&start);
 	send_data(fin, dout, st.st_blksize, st.st_size,
 		  (restart_point == 0 && cmd == 0 && S_ISREG(st.st_mode)));
 	if ((cmd == 0) && stats)
-		logxfer(name, st.st_size, start);
+		logxfer(pcNewName, st.st_size, start);
 	(void) fclose(dout);
 	data = -1;
 	pdata = -1;
 done:
 	if (cmd == 0)
-		LOGBYTES("get", name, byte_count);
+		LOGBYTES("get", pcNewName, byte_count);
+	free(pcNewName);
 	(*closefunc)(fin);
 }
 
@@ -1139,7 +1539,7 @@
 			goto done;
 		}
 	}
-	din = dataconn(name, (off_t)-1, "r");
+	din = dataconn(name, (off_t)-1, "r", unique);
 	if (din == NULL)
 		goto done;
 	if (receive_data(din, fout) == 0) {
@@ -1167,7 +1567,7 @@
 	sigfillset(&allsigs);
 	sigprocmask (SIG_BLOCK, &allsigs, NULL);
 	(void) seteuid((uid_t)0);
-	s = socket(AF_INET, SOCK_STREAM, 0);
+	s = socket(data_dest.su_family, SOCK_STREAM, 0);
 	if (s < 0)
 		goto bad;
 	if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,
@@ -1177,8 +1577,8 @@
 #ifndef __linux__
 	data_source.sin_len = sizeof(struct sockaddr_in);
 #endif
-	data_source.sin_family = AF_INET;
-	data_source.sin_addr = ctrl_addr.sin_addr;
+	data_source = ctrl_addr;
+	data_source.su_port = htons(ntohs(ctrl_addr.su_port) - 1);
 	for (tries = 1; ; tries++) {
 		if (bind(s, (struct sockaddr *)&data_source,
 		    sizeof(data_source)) >= 0)
@@ -1192,9 +1592,12 @@
 	sigprocmask (SIG_UNBLOCK, &allsigs, NULL);
 
 #ifdef IP_TOS
+	if (data_source.su_family == AF_INET)
+	{
 	on = IPTOS_THROUGHPUT;
 	if (setsockopt(s, IPPROTO_IP, IP_TOS, (char *)&on, sizeof(int)) < 0)
 		syslog(LOG_WARNING, "setsockopt (IP_TOS): %m");
+	}
 #endif
 #ifdef TCP_NOPUSH
 	/*
@@ -1227,7 +1630,7 @@
 	return (NULL);
 }
 
-static FILE * dataconn(const char *name, off_t size, const char *mode)
+static FILE * dataconn(const char *name, off_t size, const char *mode, int stou)
 {
 	char sizebuf[32];
 	FILE *file;
@@ -1241,7 +1644,7 @@
 	} else
 		sizebuf[0] = '\0';
 	if (pdata >= 0) {
-		struct sockaddr_in from;
+		union sockunion from;
 		int s;
 		socklen_t fromlen = sizeof(from);
 
@@ -1255,34 +1658,58 @@
 			pdata = -1;
 			return (NULL);
 		}
-		if (ntohs(from.sin_port) < IPPORT_RESERVED) {
+		if (ntohs(from.su_port) < IPPORT_RESERVED) {
 			perror_reply(425, "Can't build data connection");
 			(void) close(pdata);
 			(void) close(s);
 			pdata = -1;
 			return (NULL);
 		}
-		if (from.sin_addr.s_addr != his_addr.sin_addr.s_addr) {
+#ifdef BREAKRFC
+		if ((from.su_family == AF_INET &&
+			from.su_sin.sin_addr.s_addr !=
+			  his_addr.su_sin.sin_addr.s_addr)
+#ifdef INET6
+		  || (from.su_family == AF_INET6 &&
+			!IN6_ARE_ADDR_EQUAL(&from.su_sin6.sin6_addr,
+					&his_addr.su_sin6.sin6_addr))
+#endif
+		) {
 			perror_reply(435, "Can't build data connection"); 
 			(void) close(pdata);
 			(void) close(s);
 			pdata = -1;
 			return (NULL);
 		}
+#endif
 		(void) close(pdata);
 		pdata = s;
 #ifdef IP_TOS
+		if (from.su_family == AF_INET)
+		{
 		tos = IPTOS_THROUGHPUT;
 		(void) setsockopt(s, IPPROTO_IP, IP_TOS, (char *)&tos,
 		    sizeof(int));
+		}
 #endif
-		reply(150, "Opening %s mode data connection for '%s'%s.",
-		     type == TYPE_A ? "ASCII" : "BINARY", name, sizebuf);
+		if (stou) {
+			reply(150, "FILE: %s", name);
+		} else {
+			reply(150,
+			      "Opening %s mode data connection for '%s'%s.",
+			      type == TYPE_A ? "ASCII" : "BINARY", name,
+			      sizebuf);
+		}
 		return (fdopen(pdata, mode));
 	}
 	if (data >= 0) {
-		reply(125, "Using existing data connection for '%s'%s.",
-		    name, sizebuf);
+		if (stou) {
+			reply(125, "FILE: %s", name);
+		} else {
+			reply(125,
+			      "Using existing data connection for '%s'%s.",
+			      name, sizebuf);
+		}
 		usedefault = 1;
 		return (fdopen(data, mode));
 	}
@@ -1291,9 +1718,13 @@
 	usedefault = 1;
 	file = getdatasock(mode);
 	if (file == NULL) {
+		char hbuf[MAXHOSTNAMELEN], pbuf[10];
+
+		getnameinfo((struct sockaddr*)&data_source, sizeof(data_source),
+				hbuf, sizeof(hbuf), pbuf, sizeof(pbuf),
+				NI_NUMERICHOST | NI_NUMERICSERV);
 		reply(425, "Can't create data socket (%s,%d): %s.",
-		    inet_ntoa(data_source.sin_addr),
-		    ntohs(data_source.sin_port), strerror(errno));
+					hbuf, pbuf, strerror(errno));
 		return (NULL);
 	}
 	data = fileno(file);
@@ -1302,19 +1733,29 @@
 	 * attempt to connect to reserved port on client machine;
 	 * this looks like an attack
 	 */
-	if (ntohs(data_dest.sin_port) < IPPORT_RESERVED ||
-	    ntohs(data_dest.sin_port) == 2049) {		/* XXX */
+	if (ntohs(data_dest.su_port) < IPPORT_RESERVED ||
+	    ntohs(data_dest.su_port) == 2049) {		/* XXX */
 		perror_reply(425, "Can't build data connection");
 		(void) fclose(file);
 		data = -1;
 		return NULL;
 	}
-	if (data_dest.sin_addr.s_addr != his_addr.sin_addr.s_addr) {
+#ifdef BREAKRFC
+	if ((data_dest.su_family == AF_INET &&
+		data_dest.su_sin.sin_addr.s_addr !=
+			his_addr.su_sin.sin_addr.s_addr)
+#ifdef INET6
+	  || (data_dest.su_family == AF_INET6 &&
+		!IN6_ARE_ADDR_EQUAL(&data_dest.su_sin6.sin6_addr,
+					&his_addr.su_sin6.sin6_addr))
+#endif
+	) {
 		perror_reply(435, "Can't build data connection");
 		(void) fclose(file);
 		data = -1;
 		return NULL;
 	}
+#endif
 	while (connect(data, (struct sockaddr *)&data_dest,
 	    sizeof(data_dest)) < 0) {
 		if (errno == EADDRINUSE && retry < swaitmax) {
@@ -1327,8 +1768,14 @@
 		data = -1;
 		return (NULL);
 	}
-	reply(150, "Opening %s mode data connection for '%s'%s.",
-	     type == TYPE_A ? "ASCII" : "BINARY", name, sizebuf);
+	if (stou) {
+		reply(150, "FILE: %s", name);
+	} else {
+		reply(150,
+		      "Opening %s mode data connection for '%s'%s.",
+		      type == TYPE_A ? "ASCII" : "BINARY", name,
+		      sizebuf);
+	}
 	return (file);
 }
 
@@ -1466,7 +1913,13 @@
 	int cnt;
 	volatile int bare_lfs = 0;
 	char buf[BUFSIZ];
+#ifdef IFX_FTP_UPGRADE
+	int bFirstTime = 1;
+	int mycount = 0;
+	char mybuf[128];
 
+	memset(mybuf,0x00,sizeof(mybuf));
+#endif
 	transflag++;
 	if (setjmp(urgcatch)) {
 		transflag = 0;
@@ -1488,6 +1941,17 @@
 					goto file_err;
 				byte_count += cnt;
 			}
+#ifdef IFX_FTP_UPGRADE
+			/* XXX: Nirav. Added to make some space for image before upgradation */
+			if(mycount <= 100) {
+				memcpy(mybuf,buf,((sizeof(mybuf) - mycount) < cnt ? (sizeof(mybuf) - mycount) : cnt));
+				mycount += cnt;
+			}
+			if(mycount > 100 && bFirstTime) {
+				ifx_chkImageMem(mybuf,"ftp");
+				bFirstTime = 0;
+			}
+#endif
 		} while (cnt > 0);
 		if (cnt < 0)
 			goto data_err;
@@ -1578,14 +2042,15 @@
 
 void statcmd(void)
 {
-	struct sockaddr_in *sn;
-	u_char *a, *p;
+	char hbuf[MAXHOSTNAMELEN];
 
 	lreply(211, "%s FTP server status:", hostname, version);
 	printf("     %s\r\n", version);
 	printf("     Connected to %s", remotehost);
-	if (!isdigit(remotehost[0]))
-		printf(" (%s)", inet_ntoa(his_addr.sin_addr));
+	getnameinfo((struct sockaddr *)&his_addr, sizeof(his_addr),
+			hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST);
+	if (strcmp(remotehost, hbuf) != 0)
+		printf(" (%s)", hbuf);
 	printf("\r\n");
 	if (logged_in) {
 		if (guest)
@@ -1607,25 +2072,69 @@
 #endif
 	printf("; STRUcture: %s; transfer MODE: %s\r\n",
 	    strunames[stru], modenames[mode]);
-	if (data != -1)
+	printstataddrinfo();
+	reply(211, "End of status");
+}
+
+static void
+printstataddrinfo(void)
+{
+	int i, ispsv, af = 0; int alen = 0;
+	union sockunion *su;
+	u_char *p, *a = NULL;
+	char hbuf[MAXHOSTNAMELEN];
+
+	if (epsvall)
+		printf("     EPSV only mode (EPSV ALL)\r\n");
+
+	ispsv = pdata != -1 ? 1 : 0;
+
+	if (data != -1 || ispsv || usedefault == 0) {
 		printf("     Data connection open\r\n");
-	else if (pdata != -1) {
-		printf("     in Passive mode");
-		sn = &pasv_addr;
-		goto printaddr;
-	} else if (usedefault == 0) {
-		printf("     PORT");
-		sn = &data_dest;
-printaddr:
-		a = (u_char *) &sn->sin_addr;
-		p = (u_char *) &sn->sin_port;
-#define UC(b) (((int) b) & 0xff)
-		printf(" (%d,%d,%d,%d,%d,%d)\r\n", UC(a[0]),
-			UC(a[1]), UC(a[2]), UC(a[3]), UC(p[0]), UC(p[1]));
-#undef UC
-	} else
+	} else {
 		printf("     No data connection\r\n");
-	reply(211, "End of status");
+		return;
+	}
+
+	su = ispsv ? &pasv_addr : &data_dest;
+
+	if (su->su_family == AF_INET) {
+		a = (u_char *) &su->su_sin.sin_addr;
+		alen = sizeof(su->su_sin.sin_addr);
+		af = 4;
+#ifdef INET6
+	} else if (su->su_family == AF_INET6) {
+		a = (u_char *) &su->su_sin6.sin6_addr;
+		alen = sizeof(su->su_sin6.sin6_addr);
+		af = 6;
+#endif
+	}
+
+	p = (u_char *) &su->su_port;
+
+	if (epsvall == 0) {
+		/* PORT/PASV */
+		if (alen == 4) {
+			printf("     %s (%u,%u,%u,%u,%u,%u)\r\n",
+				ispsv ? "PASV" : "PORT",
+				a[0], a[1], a[2], a[3], p[0], p[1]);
+		}
+		/* LPRT/LPSV */
+		if (alen > 0) {
+			printf("     %s (%d,%d,",
+				ispsv ? "LPSV" : "LPRT", af, alen);
+			for (i = 0; i < alen; i++)
+				printf("%u,", a[i]);
+			printf("%u,%u,%u)\r\n", 2, p[0], p[1]);
+		}
+	}
+	/* EPRT/EPSV */
+	if (a && getnameinfo((struct sockaddr *)su, sizeof(pasv_addr),
+			hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST) == 0) {
+		printf("     %s |%d|%s|%d|\r\n",
+			ispsv ? "EPSV" : "EPRT", ex_af2prot(su->su_family),
+					hbuf, htons(su->su_port));
+	}
 }
 
 void fatal(const char *s)
@@ -1737,9 +2246,34 @@
 void cwd(const char *path)
 {
 	FILE *message;
+  char *pcNewName = malloc(strlen(path)+8);
+
+  //IE6-WinXP Logged in first times
+	if(strcmp(path,"/root") == 0 ){
+		strcpy(pcNewName,"/");
+  }
+
+	//FireFox - First Time
+	else if(strcmp(path,"/root/") == 0){
+		strcpy(pcNewName,"/"); // Do Nothing
+  }  
+
+  //Firefox Directory traversal
+	else if(strncmp(path,"/root/../",9) ==0 ){
+		strcpy(pcNewName,(path +8));
+  }
+	
+	//IE6 Directory traversal
+  else if(strncmp(path,"/root/",6) == 0){
+		strcpy(pcNewName,(path +5));
+  }
+  
+	else {
+		strcpy(pcNewName,path); // Do Nothing
+  }
 
-	if (chdir(path) < 0)
-		perror_reply(550, path);
+	if (chdir(pcNewName) < 0)
+		perror_reply(550, pcNewName);
 	else {
 		if ((message = fopen(_PATH_CWDMESG, "r")) != NULL) {
 			char *cp, line[LINE_MAX];
@@ -1754,19 +2288,29 @@
 		}
 		ack("CWD");
 	}
+  free(pcNewName);
 }
 
+#ifndef min
+#define min(a,b)	((a) < (b) ? (a) : (b))
+#endif
 void replydirname(const char *name, const char *message)
 {
+	char *p, *ep;
 	char npath[MAXPATHLEN];
-	int i;
 
-	for (i = 0; *name != '\0' && i < (int)sizeof(npath) - 1; i++, name++) {
-		npath[i] = *name;
-		if (*name == '"')
-			npath[++i] = '"';
+	p = npath;
+	ep = &npath[sizeof(npath) - 1];
+	while (*name) {
+		if (*name == '"' && ep - p >= 2) {
+			*p++ = *name++;
+			*p++ = '"';
+		} else if (ep - p >= 1)
+			*p++ = *name++;
+		else
+			break;
 	}
-	npath[i] = '\0';
+	*p = '\0';
 	reply(257, "\"%s\" %s", npath, message);
 }
 
@@ -1795,8 +2339,14 @@
 
 	if (getcwd(path, sizeof path) == (char *)NULL)
 		reply(550, "%s.", path);
-	else
+
+	else{
+    if(strcmp(path,"/root")==0){
+			strcpy(path,"/");
+			chdir(path);
+		}
 		replydirname(path, "is current directory.");
+	}
 }
 
 char * renamefrom(char *name)
@@ -1821,24 +2371,26 @@
 		ack("RNTO");
 }
 
-static void dolog(struct sockaddr_in *sn)
+static void dolog(union sockunion *su)
 {
-	struct hostent *hp = gethostbyaddr((char *)&sn->sin_addr,
-		sizeof(struct in_addr), AF_INET);
+	char hbuf[MAXHOSTNAMELEN], addstr[MAXHOSTNAMELEN + 4];
 
-	if (hp)
-		(void) strncpy(remotehost, hp->h_name, sizeof(remotehost)-1);
-	else
-		(void) strncpy(remotehost, inet_ntoa(sn->sin_addr),
-		    sizeof(remotehost)-1);
-	remotehost[sizeof(remotehost)-1] = '\0';
+	memset(remotehost, '\0', sizeof(remotehost));
+	getnameinfo((struct sockaddr *)su, sizeof(ctrl_addr),
+			remotehost, sizeof(remotehost), NULL, 0, NI_NUMERICHOST);
+	memset(hbuf, '\0', sizeof(hbuf));
+	getnameinfo((struct sockaddr *)su, sizeof(ctrl_addr),
+			hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST);
+	addstr[0] = '\0';
+	if (strcmp(remotehost, hbuf) != 0)
+		sprintf(addstr, " (%s)", hbuf);
 #ifdef HASSETPROCTITLE
 	snprintf(proctitle, sizeof(proctitle), "%s: connected", remotehost);
 	setproctitle("%s", proctitle);
 #endif /* HASSETPROCTITLE */
 
 	if (logging)
-		syslog(LOG_INFO, "connection from %s", remotehost);
+		syslog(LOG_INFO, "connection from %s%s", remotehost, addstr);
 }
 
 /*
@@ -1847,22 +2399,12 @@
  */
 void dologout(int status)
 {
-	sigset_t allsigs;
-
 	transflag = 0;
+	end_login();
+	
+	//system("/bin/umount /dev/sda1");
+   	//system("/usr/sbin/led_control -l 10 off");
 
-	if (logged_in) {
-		sigfillset(&allsigs);
-		sigprocmask(SIG_BLOCK, &allsigs, NULL);
-		(void) seteuid((uid_t)0);
-		ftpdlogwtmp(ttyline, "", "");
-		if (doutmp)
-			logout(utmp.ut_line);
-#if defined(KERBEROS)
-		if (!notickets && krbtkfile_env)
-			unlink(krbtkfile_env);
-#endif
-	}
 	/* beware of flushing buffers after a SIGPIPE */
 	_exit(status);
 }
@@ -1939,7 +2481,7 @@
 	if (high_data_ports) {
 		for (port = FTP_DATA_BOTTOM; port <= FTP_DATA_TOP; port++) {
 			pasv_addr = ctrl_addr;
-			pasv_addr.sin_port = htons(port);
+			pasv_addr.su_port = htons(port);
 			if (bind(pdata, (struct sockaddr *) &pasv_addr,
 				 sizeof(pasv_addr)) == 0)
 				break;
@@ -1953,7 +2495,7 @@
 #endif
 	{
 		pasv_addr = ctrl_addr;
-		pasv_addr.sin_port = 0;
+		pasv_addr.su_port = 0;
 		if (bind(pdata, (struct sockaddr *)&pasv_addr,
 			 sizeof(pasv_addr)) < 0)
 			goto pasv_error;
@@ -1964,8 +2506,8 @@
 		goto pasv_error;
 	if (listen(pdata, 1) < 0)
 		goto pasv_error;
-	a = (char *) &pasv_addr.sin_addr;
-	p = (char *) &pasv_addr.sin_port;
+	a = (char *) &pasv_addr.su_sin.sin_addr;
+	p = (char *) &pasv_addr.su_port;
 
 #define UC(b) (((int) b) & 0xff)
 
@@ -1981,6 +2523,297 @@
 }
 
 /*
+ * Long Passive defined in RFC 1639.
+ *   228 Entering Long Passive Mode (af, hal, h1, h2, h3,..., pal, p1, p2...)
+ * Extended Passive defined in RFC 2428.
+ *   229 Entering Extended Passive Mode (|||port|)
+ */
+void
+long_passive(const char *cmd, int pf)
+{
+	socklen_t len;
+#ifdef IP_PORTRANGE
+	int on;
+#else
+	u_short port;
+#endif
+	u_char *p, *a;
+
+	if (pf != PF_UNSPEC && ctrl_addr.su_family != pf) {
+		/*
+		 * XXX
+		 * only EPRT/EPSV ready clients will understand this
+		 */
+		pf = ex_af2prot(ctrl_addr.su_family);
+		if (strcmp(cmd, "EPSV") == 0 && pf)
+			reply(522, "Network protocol mismatch, use (%d)", pf);
+		else
+			reply(501, "Network protocol mismatch"); /*XXX*/
+
+		return;
+	}
+		
+	if (pdata >= 0)		/* close old port if one set */
+		close(pdata);
+
+	pdata = socket(ctrl_addr.su_family, SOCK_STREAM, 0);
+	if (pdata < 0) {
+		perror_reply(425, "Can't open passive connection");
+		return;
+	}
+
+#ifdef IP_PORTRANGE
+	if (ctrl_addr.su_family == AF_INET) {
+		on = high_data_ports ? IP_PORTRANGE_HIGH : IP_PORTRANGE_DEFAULT;
+
+		if (setsockopt(pdata, IPPROTO_IP, IP_PORTRANGE,
+				(char *)&on, sizeof(on)) < 0)
+			goto pasv_error;
+	}
+#else
+	if (high_data_ports) {
+		for (port = FTP_DATA_BOTTOM; port <= FTP_DATA_TOP; port++) {
+			pasv_addr = ctrl_addr;
+			pasv_addr.su_port = htons(port);
+			if (bind(pdata, (struct sockaddr *) &pasv_addr,
+					sizeof(pasv_addr)) == 0)
+				break;
+			if (errno != EADDRINUSE)
+				goto pasv_error;
+		}
+		if (port > FTP_DATA_TOP)
+			goto pasv_error;
+	} else
+#endif
+	{
+		pasv_addr = ctrl_addr;
+		pasv_addr.su_port = 0;
+		if (bind(pdata, (struct sockaddr *)&pasv_addr,
+				sizeof(pasv_addr)) < 0)
+			goto pasv_error;
+	}
+
+	len = sizeof(pasv_addr);
+	if (getsockname(pdata, (struct sockaddr *) &pasv_addr, &len) < 0)
+		goto pasv_error;
+	if (listen(pdata, 1) < 0)
+		goto pasv_error;
+
+	p = (u_char *) &pasv_addr.su_port;
+	if (strcmp(cmd, "LPSV") == 0) {
+		if (pasv_addr.su_family == AF_INET) {
+			a = (u_char *) &pasv_addr.su_sin.sin_addr;
+			reply(228,
+		  "Entering Long Passive Mode (%u,%u,%u,%u,%u,%u,%u,%u,%u)",
+				4, 4, a[0], a[1], a[2], a[3], 2, p[0], p[1]);
+#ifdef INET6
+		} else if (pasv_addr.su_family == AF_INET6) {
+			a = (u_char *) &pasv_addr.su_sin6.sin6_addr;
+			reply(228,
+			  "Entering Long Passive Mode (%u,%u,%u,%u,%u,%u,"
+			  "%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u)",
+			  6, 16, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7],
+			  a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],
+			  2, p[0], p[1]);
+#endif
+		} else {
+			goto pasv_error;
+		}
+		return;
+	} else if (strcmp(cmd, "EPSV") == 0) {
+		if (ex_af2prot(pasv_addr.su_family) > 0) {
+			reply(229, "Entering Extended Passive Mode (|||%u|)",
+				ntohs(pasv_addr.su_port));
+			return;
+		}
+	} else {
+		/* more proper error code? */
+	}
+
+pasv_error:
+	(void) close(pdata);
+	pdata = -1;
+	perror_reply(425, "Can't open passive connection");
+	return;
+}
+
+/*
+ * Extended Port defined in RFC 2428.
+ *   EPRT |proto|addr|port|
+ */
+int
+extended_port(const char *arg)
+{
+	char *tmp = NULL;
+	char *result[3];
+	char *p, *q;
+	char delim;
+	struct addrinfo hints;
+	struct addrinfo *res = NULL;
+	int i;
+	unsigned long proto;
+
+	tmp = strdup(arg);
+	if (debug)
+		syslog(LOG_DEBUG, "%s", tmp);
+	if (!tmp) {
+		fatal("not enough core.");
+		/*NOTREACHED*/
+	}
+	p = tmp;
+	delim = p[0];
+	p++;
+	memset(result, 0, sizeof(result));
+	for (i = 0; i < 3; i++) {
+		q = strchr(p, delim);
+		if (!q || *q != delim)
+			goto parsefail;
+		*q++ = '\0';
+		result[i] = p;
+		if (debug)
+			syslog(LOG_DEBUG, "%d: %s", i, p);
+		p = q;
+	}
+
+	/* some more sanity check */
+	p = NULL;
+	(void)strtoul(result[2], &p, 10);
+	if (!*result[2] || *p)
+		goto parsefail;
+	p = NULL;
+	proto = strtoul(result[0], &p, 10);
+	if (!*result[0] || *p)
+		goto parsefail;	/* not 522, since not numeric */
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = ex_prot2af((int)proto);
+	if (hints.ai_family < 0)
+		goto protounsupp;
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_flags = AI_NUMERICHOST;	/*no DNS*/
+	if (getaddrinfo(result[1], result[2], &hints, &res))
+		goto parsefail;
+	if (res->ai_next)
+		goto parsefail;
+	if ((int)sizeof(data_dest) < res->ai_addrlen) {
+		if (debug)
+			syslog(LOG_DEBUG, "ai_addrlen large");
+		goto parsefail;
+	}
+	memcpy(&data_dest, res->ai_addr, res->ai_addrlen);
+#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
+	if (his_addr.su_family == AF_INET6 &&
+	    data_dest.su_family == AF_INET6) {
+		/* XXX more sanity checks! */
+		data_dest.su_sin6.sin6_scope_id =
+		    his_addr.su_sin6.sin6_scope_id;
+	}
+#endif
+	if (port_check("EPRT") == 1) {
+#ifdef INET6
+	} else if (port_check_v6("EPRT") == 1) {
+#endif
+	} else {
+		goto parsefail;
+	}
+
+	if (tmp)
+		free(tmp);
+	if (res)
+		freeaddrinfo(res);
+	return 0;
+
+parsefail:
+	reply(500, "Invalid argument, rejected.");
+	usedefault = 1;
+	if (tmp)
+		free(tmp);
+	if (res)
+		freeaddrinfo(res);
+	return -1;
+
+protounsupp:
+	reply(522, "Network protocol mismatch, use (%d)",
+			ex_af2prot(his_addr.su_family));
+	usedefault = 1;
+	if (tmp)
+		free(tmp);
+	if (res)
+		freeaddrinfo(res);
+	return -1;
+}
+
+/* Return 1, if port check is done. Return 0, if not yet. */
+int
+port_check(const char *pcmd)
+{
+	if (his_addr.su_family == AF_INET) {
+		if (data_dest.su_family != AF_INET) {
+			usedefault = 1;
+			reply(500, "Invalid address rejected.");
+			return 1;
+		}
+		if (portcheck &&
+		    ntohs(data_dest.su_port) < IPPORT_RESERVED) {
+			usedefault = 1;
+			reply(500,
+			    "Illegal PORT rejected (reserved port).");
+		} else if (portcheck &&
+			   data_dest.su_sin.sin_addr.s_addr !=
+				his_addr.su_sin.sin_addr.s_addr) {
+			usedefault = 1;
+			reply(500,
+			    "Illegal PORT rejected (address wrong).");
+		} else {
+			usedefault = 0;
+			if (pdata >= 0) {
+				(void) close(pdata);
+				pdata = -1;
+			}
+			reply(200, "%s command successful.", pcmd);
+		}
+		return 1;
+	}
+	return 0;
+}
+
+#ifdef INET6
+/* Return 1, if port check is done. Return 0, if not yet. */
+int
+port_check_v6(const char *pcmd)
+{
+	if (his_addr.su_family == AF_INET6) {
+		if (data_dest.su_family != AF_INET6) {
+			usedefault = 1;
+			reply(500, "Invalid address rejected.");
+			return 1;
+		}
+		if (portcheck &&
+		    ntohs(data_dest.su_port) < IPPORT_RESERVED) {
+			usedefault = 1;
+			reply(500,
+			    "Illegal PORT rejected (reserved port).");
+		} else if (portcheck && !IN6_ARE_ADDR_EQUAL(
+					&data_dest.su_sin6.sin6_addr,
+					&his_addr.su_sin6.sin6_addr)) {
+			usedefault = 1;
+			reply(500,
+			    "Illegal PORT rejected (address wrong).");
+		} else {
+			usedefault = 0;
+			if (pdata >= 0) {
+				(void) close(pdata);
+				pdata = -1;
+			}
+			reply(200, "%s command successful.", pcmd);
+		}
+		return 1;
+	}
+	return 0;
+}
+#endif
+
+/*
  * Generate unique name for file with basename "local".
  * The file named "local" is already known to exist.
  * Generates failure reply on error.
@@ -2101,7 +2934,7 @@
 
 		if (S_ISREG(st.st_mode)) {
 			if (dout == NULL) {
-				dout = dataconn("file list", (off_t)-1, "w");
+				dout = dataconn("file list", (off_t)-1, "w", 0);
 				if (dout == NULL)
 					goto out;
 				transflag++;
@@ -2143,7 +2976,7 @@
 			    S_ISREG(st.st_mode))) {
 				if (dout == NULL) {
 					dout = dataconn("file list", (off_t)-1,
-						"w");
+						"w", 0);
 					if (dout == NULL)
 						goto out;
 					transflag++;
@@ -2230,16 +3063,24 @@
 }
 
 #if defined(TCPWRAPPERS)
-static int check_host(struct sockaddr_in *sin)
+static int check_host(union sockunion *su)
 {
-	struct hostent *hp = gethostbyaddr((char *)&sin->sin_addr,
-		sizeof(struct in_addr), AF_INET);
-	char *addr = inet_ntoa(sin->sin_addr);
+	char hbuf[MAXHOSTNAMELEN], addr[MAXHOSTNAMELEN];
+
+	if (su->su_family != AF_INET)
+		return 1;	/*XXX*/
+
+	memset(hbuf, '\0', sizeof(hbuf));
+	getnameinfo((struct sockaddr *)su, sizeof(his_addr),
+			hbuf, sizeof(hbuf), NULL, 0, 0);
+	memset(addr, '\0', sizeof(addr));
+	getnameinfo((struct sockaddr *)su, sizeof(his_addr),
+			addr, sizeof(addr), NULL, 0, NI_NUMERICHOST);
 
-	if (hp) {
-		if (!hosts_ctl("ftpd", hp->h_name, addr, STRING_UNKNOWN)) {
+	if (strcmp(hbuf, addr)) {
+		if (!hosts_ctl("ftpd", hbuf, addr, STRING_UNKNOWN)) {
 			syslog(LOG_NOTICE, "tcpwrappers rejected: %s [%s]",
-			    hp->h_name, addr);
+				hbuf, addr);
 			return (0);
 		}
 	} else {
diff -Naur linux-ftpd-0.17.orig/ftpd/logwtmp.c open_linux_ftpd/ftpd/logwtmp.c
--- linux-ftpd-0.17.orig/ftpd/logwtmp.c	1999-07-16 06:04:29.000000000 +0530
+++ open_linux_ftpd/ftpd/logwtmp.c	2008-09-04 12:14:07.000000000 +0530
@@ -41,7 +41,6 @@
   "$Id: logwtmp.c,v 1.5 1999/07/16 00:34:29 dholland Exp $";
 
 #include <sys/types.h>
-#include <sys/time.h>
 #include <sys/stat.h>
 
 #include <fcntl.h>
@@ -49,6 +48,7 @@
 #include <unistd.h>
 #include <stdio.h>
 #include <string.h>
+#include <time.h>
 #include "extern.h"
 
 static int fd = -1;
diff -Naur linux-ftpd-0.17.orig/support/Makefile open_linux_ftpd/support/Makefile
--- linux-ftpd-0.17.orig/support/Makefile	1999-08-01 03:35:52.000000000 +0530
+++ open_linux_ftpd/support/Makefile	2008-09-04 12:14:05.000000000 +0530
@@ -1,6 +1,9 @@
 include ../MCONFIG
 
-OBJS=daemon.o setproctitle.o isexpired.o vis.o
+CFLAGS+=$(IFX_CFLAGS)
+LDFLAGS+=$(IFX_LDFLAGS)
+
+OBJS=setproctitle.o isexpired.o vis.o
 
 all: libsupport.a
 
@@ -8,12 +11,11 @@
 	$(CC) $(CFLAGS) -DHASSETPROCTITLE $< -c
 
 libsupport.a: $(OBJS)
-	ar -cruv $@ $^
-	ranlib $@
+	$(AR) -cruv $@ $^
+	$(RANLIB) $@
 
 install: ;
 clean:
 	rm -f *.o libsupport.a
 
 setproctitle.o: setproctitle.h
-daemon.o: daemon.h
diff -Naur linux-ftpd-0.17.orig/support/setproctitle.c open_linux_ftpd/support/setproctitle.c
--- linux-ftpd-0.17.orig/support/setproctitle.c	1999-09-29 06:58:07.000000000 +0530
+++ open_linux_ftpd/support/setproctitle.c	2008-09-04 12:14:01.000000000 +0530
@@ -139,7 +139,7 @@
 	(void) strcpy(Argv[0], buf);
 	p = &Argv[0][i];
 	while (p < LastArgv)
-		*p++ = ' ';
+		*p++ = '\0';
 	Argv[1] = NULL;
 }
 
