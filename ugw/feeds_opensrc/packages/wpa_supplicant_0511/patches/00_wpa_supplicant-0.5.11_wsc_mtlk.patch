diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/common.h wpa_supplicant-0.5.11/common.h
--- wpa_supplicant-0.5.11.ORIG/common.h	2008-11-28 18:21:29.000000000 +0200
+++ wpa_supplicant-0.5.11/common.h	2010-06-28 10:19:12.000000000 +0300
@@ -22,6 +22,12 @@
 #include <byteswap.h>
 #endif /* __linux__ */
 
+// This define fixes gcc-2.95 compilation bug on Sigma8621/22/24 platforms
+// http://www.busybox.net/lists/busybox/2006-August/023674.html
+#if defined(__UCLIBC__) && !defined(__ARCH_HAS_MMU__)
+#define         daemon  clone
+#endif
+
 #if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__DragonFly__)
 #include <sys/types.h>
 #include <sys/endian.h>
@@ -409,6 +415,9 @@
 #define WPA_ASSERT(a) do { } while (0)
 #endif
 
+#ifdef EAP_WSC
+extern int g_wsc;
+#endif
 
 #ifdef _MSC_VER
 #undef vsnprintf
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/.config wpa_supplicant-0.5.11/.config
--- wpa_supplicant-0.5.11.ORIG/.config	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/.config	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,332 @@
+# Example wpa_supplicant build time configuration
+#
+# This file lists the configuration options that are used when building the
+# hostapd binary. All lines starting with # are ignored. Configuration option
+# lines must be commented out complete, if they are not to be included, i.e.,
+# just setting VARIABLE=n is not disabling that variable.
+#
+# This file is included in Makefile, so variables like CFLAGS and LIBS can also
+# be modified from here. In most cases, these lines should use += in order not
+# to override previous values of the variables.
+
+
+# Uncomment following two lines and fix the paths if you have installed OpenSSL
+# or GnuTLS in non-default location
+#CFLAGS += -I/usr/local/openssl/include
+#LIBS += -L/usr/local/openssl/lib
+CFLAGS += -I/../../../lib/libssl/include
+LIBS += -L/../../../lib/libssl/build
+
+# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
+# the kerberos files are not in the default include path. Following line can be
+# used to fix build issues on such systems (krb5.h not found).
+#CFLAGS += -I/usr/include/kerberos
+
+# Example configuration for various cross-compilation platforms
+
+#### sveasoft (e.g., for Linksys WRT54G) ######################################
+#CC=mipsel-uclibc-gcc
+#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
+#CFLAGS += -Os
+#CPPFLAGS += -I../src/include -I../../src/router/openssl/include
+#LIBS += -L/opt/brcm/hndtools-mipsel-uclibc-0.9.19/lib -lssl
+###############################################################################
+
+#### openwrt (e.g., for Linksys WRT54G) #######################################
+#CC=mipsel-uclibc-gcc
+#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
+#CFLAGS += -Os
+#CPPFLAGS=-I../src/include -I../openssl-0.9.7d/include \
+#	-I../WRT54GS/release/src/include
+#LIBS = -lssl
+###############################################################################
+
+
+# Driver interface for Host AP driver
+#CONFIG_DRIVER_HOSTAP=y
+
+# Driver interface for Agere driver
+#CONFIG_DRIVER_HERMES=y
+# Change include directories to match with the local setup
+#CFLAGS += -I../../hcf -I../../include -I../../include/hcf
+#CFLAGS += -I../../include/wireless
+
+# Driver interface for madwifi driver
+#CONFIG_DRIVER_MADWIFI=y
+# Change include directories to match with the local setup
+#CFLAGS += -I../madwifi/wpa
+#CFLAGS += -I/home/assafh/madwifi/madwifi-0.9.2-dongle-WPS
+
+# Driver interface for Prism54 driver
+# (Note: Prism54 is not yet supported, i.e., this will not work as-is and is
+# for developers only)
+#CONFIG_DRIVER_PRISM54=y
+
+# Driver interface for ndiswrapper
+#CONFIG_DRIVER_NDISWRAPPER=y
+
+# Driver interface for Atmel driver
+#CONFIG_DRIVER_ATMEL=y
+
+# Driver interface for Broadcom driver
+#CONFIG_DRIVER_BROADCOM=y
+# Example path for wlioctl.h; change to match your configuration
+#CFLAGS += -I/opt/WRT54GS/release/src/include
+
+# Driver interface for Intel ipw2100/2200 driver
+#CONFIG_DRIVER_IPW=y
+
+# Driver interface for generic Linux wireless extensions
+CONFIG_DRIVER_WEXT=y
+
+# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
+#CONFIG_DRIVER_BSD=y
+#CFLAGS += -I/usr/local/include
+#LIBS += -L/usr/local/lib
+
+# Driver interface for Windows NDIS
+#CONFIG_DRIVER_NDIS=y
+#CFLAGS += -I/usr/include/w32api/ddk
+#LIBS += -L/usr/local/lib
+# For native build using mingw
+#CONFIG_NATIVE_WINDOWS=y
+# Additional directories for cross-compilation on Linux host for mingw target
+#CFLAGS += -I/opt/mingw/mingw32/include/ddk
+#LIBS += -L/opt/mingw/mingw32/lib
+#CC=mingw32-gcc
+# By default, driver_ndis uses WinPcap for low-level operations. This can be
+# replaced with the following option which replaces WinPcap calls with NDISUIO.
+# However, this requires that WZC is disabled (net stop wzcsvc) before starting
+# wpa_supplicant.
+# CONFIG_USE_NDISUIO=y
+
+# Driver interface for development testing
+#CONFIG_DRIVER_TEST=y
+
+# Driver interface for wired Ethernet drivers
+#CONFIG_DRIVER_WIRED=y
+
+# Enable IEEE 802.1X Supplicant (automatically included if any EAP method is
+# included)
+CONFIG_IEEE8021X_EAPOL=y
+
+# EAP-MD5
+CONFIG_EAP_MD5=y
+
+# EAP-MSCHAPv2
+CONFIG_EAP_MSCHAPV2=y
+
+# EAP-TLS
+CONFIG_EAP_TLS=y
+
+# EAL-PEAP
+CONFIG_EAP_PEAP=y
+
+# EAP-TTLS
+CONFIG_EAP_TTLS=y
+
+# EAP-FAST
+# Note: Default OpenSSL package does not include support for all the
+# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
+# the OpenSSL library must be patched (openssl-0.9.8d-tls-extensions.patch)
+# to add the needed functions.
+#CONFIG_EAP_FAST=y
+
+# EAP-GTC
+CONFIG_EAP_GTC=y
+
+# EAP-OTP
+#CONFIG_EAP_OTP=y
+
+# EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
+#CONFIG_EAP_SIM=y
+
+# EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
+#CONFIG_EAP_PSK=y
+
+# EAP-PAX
+#CONFIG_EAP_PAX=y
+
+# LEAP
+#CONFIG_EAP_LEAP=y
+
+# EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
+#CONFIG_EAP_AKA=y
+
+# EAP-SAKE
+#CONFIG_EAP_SAKE=y
+
+# EAP-GPSK
+#CONFIG_EAP_GPSK=y
+# Include support for optional SHA256 cipher suite in EAP-GPSK
+#CONFIG_EAP_GPSK_SHA256=y
+
+# For Wi-Fi Simple Configuration
+CONFIG_EAP_WSC=y
+
+# Use Madwifi driver that supports new WSC IEs
+CONFIG_WSC_IE=y
+
+# PKCS#12 (PFX) support (used to read private key and certificate file from
+# a file that usually has extension .p12 or .pfx)
+#CONFIG_PKCS12=y
+
+# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
+# engine.
+#CONFIG_SMARTCARD=y
+
+# PC/SC interface for smartcards (USIM, GSM SIM)
+# Enable this if EAP-SIM or EAP-AKA is included
+#CONFIG_PCSC=y
+
+# Development testing
+#CONFIG_EAPOL_TEST=y
+
+# Select control interface backend for external programs, e.g, wpa_cli:
+# unix = UNIX domain sockets (default for Linux/*BSD)
+# udp = UDP sockets using localhost (127.0.0.1)
+# named_pipe = Windows Named Pipe (default for Windows)
+# y = use default (backwards compatibility)
+# If this option is commented out, control interface is not included in the
+# build.
+CONFIG_CTRL_IFACE=y
+
+# Include support for GNU Readline and History Libraries in wpa_cli.
+# When building a wpa_cli binary for distribution, please note that these
+# libraries are licensed under GPL and as such, BSD license may not apply for
+# the resulting binary.
+#CONFIG_READLINE=y
+
+# Remove debugging code that is printing out debug message to stdout.
+# This can be used to reduce the size of the wpa_supplicant considerably
+# if debugging code is not needed. The size reduction can be around 35%
+# (e.g., 90 kB).
+#CONFIG_NO_STDOUT_DEBUG=y
+
+# Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
+# 35-50 kB in code size.
+#CONFIG_NO_WPA=y
+
+# Remove WPA2 support. This allows WPA to be used, but removes WPA2 code to
+# save about 1 kB in code size when building only WPA-Personal (no EAP support)
+# or 6 kB if building for WPA-Enterprise.
+#CONFIG_NO_WPA2=y
+
+# Remove AES extra functions. This can be used to reduce code size by about
+# 1.5 kB by removing extra AES modes that are not needed for commonly used
+# client configurations (they are needed for some EAP types).
+#CONFIG_NO_AES_EXTRAS=y
+
+# Select configuration backend:
+# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
+#	path is given on command line, not here; this option is just used to
+#	select the backend that allows configuration files to be used)
+# winreg = Windows registry (see win_example.reg for an example)
+CONFIG_BACKEND=file
+
+# Select program entry point implementation:
+# main = UNIX/POSIX like main() function (default)
+# main_winsvc = Windows service (read parameters from registry)
+# main_none = Very basic example (development use only)
+#CONFIG_MAIN=main
+
+# Select wrapper for operatins system and C library specific functions
+# unix = UNIX/POSIX like systems (default)
+# win32 = Windows systems
+# none = Empty template
+#CONFIG_OS=unix
+
+# Select event loop implementation
+# eloop = select() loop (default)
+# eloop_win = Windows events and WaitForMultipleObject() loop
+# eloop_none = Empty template
+#CONFIG_ELOOP=eloop
+
+# Select layer 2 packet implementation
+# linux = Linux packet socket (default)
+# pcap = libpcap/libdnet/WinPcap
+# freebsd = FreeBSD libpcap
+# winpcap = WinPcap with receive thread
+# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
+# none = Empty template
+#CONFIG_L2_PACKET=linux
+
+# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
+CONFIG_PEERKEY=y
+
+# IEEE 802.11w (management frame protection)
+# This version is an experimental implementation based on IEEE 802.11w/D1.0
+# draft and is subject to change since the standard has not yet been finalized.
+# Driver support is also needed for IEEE 802.11w.
+#CONFIG_IEEE80211W=y
+
+# Select TLS implementation
+# openssl = OpenSSL (default)
+# gnutls = GnuTLS (needed for TLS/IA, see also CONFIG_GNUTLS_EXTRA)
+# internal = Internal TLSv1 implementation (experimental)
+# none = Empty template
+#CONFIG_TLS=openssl
+
+# Whether to enable TLS/IA support, which is required for EAP-TTLSv1.
+# You need CONFIG_TLS=gnutls for this to have any effect. Please note that
+# even though the core GnuTLS library is released under LGPL, this extra
+# library uses GPL and as such, the terms of GPL apply to the combination
+# of wpa_supplicant and GnuTLS if this option is enabled. BSD license may not
+# apply for distribution of the resulting binary.
+#CONFIG_GNUTLS_EXTRA=y
+
+# If CONFIG_TLS=internal is used, additional library and include paths are
+# needed for LibTomMath. Alternatively, an integrated, minimal version of
+# LibTomMath can be used. See beginning of libtommath.c for details on benefits
+# and drawbacks of this option.
+#CONFIG_INTERNAL_LIBTOMMATH=y
+#ifndef CONFIG_INTERNAL_LIBTOMMATH
+#LTM_PATH=/usr/src/libtommath-0.39
+#CFLAGS += -I$(LTM_PATH)
+#LIBS += -L$(LTM_PATH)
+#LIBS_p += -L$(LTM_PATH)
+#endif
+
+# Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
+# This is only for Windows builds and requires WMI-related header files and
+# WbemUuid.Lib from Platform SDK even when building with MinGW.
+#CONFIG_NDIS_EVENTS_INTEGRATED=y
+#PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
+
+# Add support for DBus control interface
+#CONFIG_CTRL_IFACE_DBUS=y
+
+# Add support for loading EAP methods dynamically as shared libraries.
+# When this option is enabled, each EAP method can be either included
+# statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
+# Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
+# be loaded in the beginning of the wpa_supplicant configuration file
+# (see load_dynamic_eap parameter in the example file) before being used in
+# the network blocks.
+#
+# Note that some shared parts of EAP methods are included in the main program
+# and in order to be able to use dynamic EAP methods using these parts, the
+# main program must have been build with the EAP method enabled (=y or =dyn).
+# This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
+# unless at least one of them was included in the main build to force inclusion
+# of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
+# in the main build to be able to load these methods dynamically.
+#
+# Please also note that using dynamic libraries will increase the total binary
+# size. Thus, it may not be the best option for targets that have limited
+# amount of memory/flash.
+#CONFIG_DYNAMIC_EAP_METHODS=y
+
+# Include client MLME (management frame processing).
+# This can be used to move MLME processing of Devicescape IEEE 802.11 stack
+# into user space.
+#CONFIG_CLIENT_MLME=y
+# Currently, driver_devicescape.c build requires some additional parameters
+# to be able to include some of the kernel header files. Following lines can
+# be used to set these (WIRELESS_DEV must point to the root directory of the
+# wireless-dev.git tree).
+#WIRELESS_DEV=/usr/src/wireless-dev
+#CFLAGS += -I$(WIRELESS_DEV)/net/mac80211
+
+# Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
+#CONFIG_DEBUG_FILE=y
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/config.c wpa_supplicant-0.5.11/config.c
--- wpa_supplicant-0.5.11.ORIG/config.c	2008-02-18 02:27:56.000000000 +0200
+++ wpa_supplicant-0.5.11/config.c	2010-06-28 10:19:12.000000000 +0300
@@ -871,6 +871,13 @@
 			ssid->leap++;
 		else
 			ssid->non_leap++;
+
+#ifdef EAP_WSC
+		if (methods[num_methods].method == EAP_TYPE_WSC) {
+			wpa_printf(MSG_ERROR, "Setting g_wsc=1 ");
+			g_wsc = 1;
+		}
+#endif		
 		num_methods++;
 		if (last)
 			break;
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/config_file.c wpa_supplicant-0.5.11/config_file.c
--- wpa_supplicant-0.5.11.ORIG/config_file.c	2007-03-25 04:09:49.000000000 +0200
+++ wpa_supplicant-0.5.11/config_file.c	2010-06-28 10:19:12.000000000 +0300
@@ -248,6 +248,10 @@
 	struct wpa_ssid *ssid, *tail = NULL, *head = NULL;
 	struct wpa_config *config;
 	int id = 0;
+ 
+#ifdef EAP_WSC
+	g_wsc = 0;
+#endif
 
 	config = wpa_config_alloc_empty(NULL, NULL);
 	if (config == NULL)
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/defconfig wpa_supplicant-0.5.11/defconfig
--- wpa_supplicant-0.5.11.ORIG/defconfig	2007-12-09 06:20:43.000000000 +0200
+++ wpa_supplicant-0.5.11/defconfig	2010-06-28 10:19:12.000000000 +0300
@@ -158,6 +158,12 @@
 # Include support for optional SHA256 cipher suite in EAP-GPSK
 #CONFIG_EAP_GPSK_SHA256=y
 
+# For Wi-Fi Simple Configuration
+#CONFIG_EAP_WSC=y
+
+# Use Madwifi driver that supports new WSC IEs
+#CONFIG_WSC_IE=y
+
 # PKCS#12 (PFX) support (used to read private key and certificate file from
 # a file that usually has extension .p12 or .pfx)
 CONFIG_PKCS12=y
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/driver.h wpa_supplicant-0.5.11/driver.h
--- wpa_supplicant-0.5.11.ORIG/driver.h	2007-03-25 04:09:49.000000000 +0200
+++ wpa_supplicant-0.5.11/driver.h	2010-06-28 10:19:12.000000000 +0300
@@ -752,6 +752,19 @@
 	 * (management frame processing) to wpa_supplicant.
 	 */
 	 int (*mlme_remove_sta)(void *priv, const u8 *addr);
+
+#ifdef WSC_NEW_IE
+	int (*set_wsc_probe_request_ie)(void *priv, u8 *iebuf, int iebuflen);
+	int (*start_receive_beacons)(void *priv);
+	int (*stop_receive_beacons)(void *priv);
+	int (*init_l2_packet)(void *priv, void (*handler)(void *ctx,
+		const u8 *src_addr, const u8 *buf, size_t len));
+	int (*deinit_l2_packet)(void *priv);
+	int (*process_frame)(void *priv, void *ctx, const u8 *src_addr,
+		const u8 *buf, size_t len, u8 *newbuf, int *newlen, u8 *frameType);
+	int (*start_receive_pr_resps)(void *priv);
+	int (*stop_receive_pr_resps)(void *priv);
+#endif
 };
 
 #endif /* DRIVER_H */
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/driver_madwifi.c wpa_supplicant-0.5.11/driver_madwifi.c
--- wpa_supplicant-0.5.11.ORIG/driver_madwifi.c	2007-12-28 02:21:09.000000000 +0200
+++ wpa_supplicant-0.5.11/driver_madwifi.c	2010-06-28 10:19:12.000000000 +0300
@@ -44,6 +44,9 @@
 	void *ctx;
 	char ifname[IFNAMSIZ + 1];
 	int sock;
+#ifdef WSC_NEW_IE
+	struct l2_packet_data * l2_sock;
+#endif
 };
 
 static int
@@ -73,7 +76,7 @@
 		if (show_err) {
 #ifdef MADWIFI_NG
 			int first = IEEE80211_IOCTL_SETPARAM;
-			int last = IEEE80211_IOCTL_KICKMAC;
+			int last = IEEE80211_IOCTL_FILTERFRAME;
 			static const char *opnames[] = {
 				"ioctl[IEEE80211_IOCTL_SETPARAM]",
 				"ioctl[IEEE80211_IOCTL_GETPARAM]",
@@ -106,6 +109,10 @@
 				"ioctl[IEEE80211_IOCTL_WDSDELMAC]",
 				NULL,
 				"ioctl[IEEE80211_IOCTL_KICKMAC]",
+				"ioctl[IEEE80211_IOCTL_GET_APPIEBUF]",
+				"ioctl[IEEE80211_IOCTL_SET_APPIEBUF]",
+				NULL,
+				"ioctl[IEEE80211_IOCTL_FILTERFRAME]",
 			};
 #else /* MADWIFI_NG */
 			int first = IEEE80211_IOCTL_SETPARAM;
@@ -133,8 +140,10 @@
 			    idx < (int) (sizeof(opnames) / sizeof(opnames[0]))
 			    && opnames[idx])
 				perror(opnames[idx]);
-			else
+			else {
+				wpa_printf(MSG_DEBUG, "got an error for private ioctl 0x%X", op);
 				perror("ioctl[unknown???]");
+			}
 		}
 		return -1;
 	}
@@ -350,11 +359,17 @@
 					  params->wpa_ie_len) < 0)
 		ret = -1;
 
+#ifdef EAP_WSC
+	if (!g_wsc) {
+#endif
 	if (params->pairwise_suite == CIPHER_NONE &&
 	    params->group_suite == CIPHER_NONE &&
 	    params->key_mgmt_suite == KEY_MGMT_NONE &&
 	    params->wpa_ie_len == 0)
 		privacy = 0;
+#ifdef EAP_WSC
+	}
+#endif
 
 	if (set80211param(drv, IEEE80211_PARAM_PRIVACY, privacy, 1) < 0)
 		ret = -1;
@@ -470,6 +485,158 @@
 	return wpa_driver_wext_get_scan_results(drv->wext, results, max_size);
 }
 
+#ifdef WSC_NEW_IE
+static int
+wpa_driver_madwifi_set_wsc_probe_request_ie(void *priv, u8 *iebuf, int iebuflen)
+{
+	struct wpa_driver_madwifi_data *drv = priv;
+	u8 buf[256];
+	struct ieee80211req_getset_appiebuf * pr_req_ie;
+
+	wpa_printf(MSG_DEBUG, "%s buflen = %d\n",
+		__FUNCTION__, iebuflen);
+
+	pr_req_ie = (struct ieee80211req_getset_appiebuf *) buf;
+	pr_req_ie->app_frmtype = IEEE80211_APPIE_FRAME_PROBE_REQ;
+	pr_req_ie->app_buflen = iebuflen;
+	memcpy(&(pr_req_ie->app_buf[0]), iebuf, iebuflen);
+
+	return set80211priv(drv, IEEE80211_IOCTL_SET_APPIEBUF, pr_req_ie,
+		sizeof(struct ieee80211req_getset_appiebuf) + iebuflen, 1);
+}
+
+static int
+wpa_driver_madwifi_start_receive_beacons(void *priv)
+{
+	sruct wpa_driver_madwifi_data *drv = priv;
+	struct ieee80211req_set_filter filt;
+
+	wpa_printf(MSG_DEBUG, "%s Enter\n", __FUNCTION__);
+
+	filt.app_filterype = IEEE80211_FILTER_TYPE_BEACON;
+
+	wpa_printf(MSG_DEBUG, "app_filterype = %x\n (IEEE80211_FILTER_TYPE_BEACON)", filt.app_filterype);
+	return set80211priv(drv, IEEE80211_IOCTL_FILTERFRAME, &filt, sizeof(struct ieee80211req_set_filter), 1);
+}
+
+static int
+wpa_driver_madwifi_stop_receive_beacons(void *priv)
+{
+	struct wpa_driver_madwifi_data *drv = priv;
+	struct ieee80211req_set_filter filt;
+
+	wpa_printf(MSG_DEBUG, "%s Enter\n", __FUNCTION__);
+
+	filt.app_filterype = 0;
+
+	return set80211priv(drv, IEEE80211_IOCTL_FILTERFRAME, &filt,
+            sizeof(struct ieee80211req_set_filter), 1);
+}
+
+static int
+wpa_driver_madwifi_process_frame(void *driver, void *ctx, const unsigned char *src_addr, const unsigned char *buf, size_t len, unsigned char *newbuf, int *newlen, u8 *frameType)
+{
+	static int j = 0;
+	u8 * frm;
+	u8 * endfrm;
+	char ssid[32];
+	u8 bssid[6];
+	struct ieee80211_frame *wh;
+	u8 * tmpptr;
+	u8 subtype;
+	
+	printf("Received %d bytes; beacon or pr-resp number %d\n", len, j++);
+
+	wh = (struct ieee80211_frame *) buf;
+	frm = (u8 *)&wh[1];
+	endfrm = (u8 *) (buf + len);
+
+	subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;
+	if (subtype == IEEE80211_FC0_SUBTYPE_BEACON)
+		*frameType = 1;
+	else if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
+		*frameType = 3;
+	else
+		*frameType = 0;
+
+	printf("frameType = %d\n", *frameType);
+	memcpy(bssid, wh->i_addr3, IEEE80211_ADDR_LEN);
+
+	// skip timestamp(8), beac interval(2), cap info (2)
+	frm += 12;
+	// get ssid
+	while (frm < endfrm)
+	{
+		switch (*frm)
+		{
+		case IEEE80211_ELEMID_SSID:
+			if (frm[1] > 1)
+			{
+				// printf("ssid len = %d\n", frm[1]);
+				memset(ssid, 0, 32);
+				memcpy(ssid, &frm[2], frm[1]);
+				printf("ssid: %s\n", ssid);
+			}
+			else
+			{
+				// printf("ssid: <hidden>\n");
+			}
+			
+			break;
+		case IEEE80211_ELEMID_VENDOR:
+			// check for WFA OUI
+			if (frm[1] > 4 && frm[2] == 0x00 && frm[3] == 0x50 && frm[4] == 0xF2 && frm[5]==0x04)
+			{
+				tmpptr = newbuf;
+				memcpy(tmpptr, ssid, 32);
+				tmpptr += 32;
+				memcpy(tmpptr, bssid, 6);
+				tmpptr += 6;
+				memcpy(tmpptr, &frm[6], frm[1] - 4);
+				tmpptr += (frm[1] - 4);
+				*newlen = (int) (tmpptr - newbuf);
+				printf("Got WSC IE; ssid = %s, IE len = %d, newlen = %d\n", ssid, frm[1], *newlen);
+			}
+		default:
+			break;
+		} // switch
+
+		frm += frm[1] + 2;
+	} // while
+	
+	return 0;
+}
+
+static int
+wpa_driver_madwifi_start_receive_pr_resps(void *priv)
+{
+	struct wpa_driver_madwifi_data *drv = priv;
+	struct ieee80211req_set_filter filt;
+
+	wpa_printf(MSG_DEBUG, "%s Enter\n", __FUNCTION__);
+
+	filt.app_filterype = IEEE80211_FILTER_TYPE_PROBE_RESP;
+
+	return set80211priv(drv, IEEE80211_IOCTL_FILTERFRAME, &filt,
+		sizeof(struct ieee80211req_set_filter), 1);
+}
+
+static int
+wpa_driver_madwifi_stop_receive_pr_resps(void *priv)
+{
+	struct wpa_driver_madwifi_data *drv = priv;
+	struct ieee80211req_set_filter filt;
+
+	wpa_printf(MSG_DEBUG, "%s Enter\n", __FUNCTION__);
+
+	filt.app_filterype = 0;
+
+	return set80211priv(drv, IEEE80211_IOCTL_FILTERFRAME, &filt,
+		sizeof(struct ieee80211req_set_filter), 1);
+}
+
+#endif /* WSC_NEW_IE */
+
 
 static int wpa_driver_madwifi_set_operstate(void *priv, int state)
 {
@@ -546,6 +713,36 @@
 	os_free(drv);
 }
 
+#ifdef WSC_NEW_IE
+int wpa_driver_madwifi_init_l2_packet(void *priv, void (*handler)(void *ctx, const unsigned char *src_addr, const unsigned char *buf, size_t len))
+{
+	struct wpa_driver_madwifi_data *drv = priv;
+	u8 own_addr[ETH_ALEN + 1];
+
+	drv->l2_sock = l2_packet_init(drv->ifname, NULL, 0x0019/*ETH_P_EAPOL*/,
+				handler, drv, 1);
+	if (drv->l2_sock == NULL)
+	{
+		printf("l2_packet_init failed\n");
+		return -1;
+	}
+
+	if (l2_packet_get_own_addr(drv->l2_sock, own_addr))
+		return -1;
+
+	printf("l2_packet_init Successful\n");
+	return 0;
+}
+
+int wpa_driver_madwifi_deinit_l2_packet(void *priv)
+{
+	struct wpa_driver_madwifi_data *drv = priv;
+
+	l2_packet_deinit(drv->l2_sock);
+
+	return 0;
+}
+#endif /*  WSC_NEW_IE */
 
 const struct wpa_driver_ops wpa_driver_madwifi_ops = {
 	.name			= "madwifi",
@@ -564,4 +761,14 @@
 	.associate		= wpa_driver_madwifi_associate,
 	.set_auth_alg		= wpa_driver_madwifi_set_auth_alg,
 	.set_operstate		= wpa_driver_madwifi_set_operstate,
+#ifdef WSC_NEW_IE
+	.set_wsc_probe_request_ie = wpa_driver_madwifi_set_wsc_probe_request_ie,
+	.start_receive_beacons = wpa_driver_madwifi_start_receive_beacons,
+	.stop_receive_beacons = wpa_driver_madwifi_stop_receive_beacons,
+	.init_l2_packet = wpa_driver_madwifi_init_l2_packet,
+	.deinit_l2_packet = wpa_driver_madwifi_deinit_l2_packet,
+	.process_frame = wpa_driver_madwifi_process_frame,
+	.start_receive_pr_resps = wpa_driver_madwifi_start_receive_pr_resps,
+	.stop_receive_pr_resps = wpa_driver_madwifi_stop_receive_pr_resps,
+#endif
 };
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/driver_wext.c wpa_supplicant-0.5.11/driver_wext.c
--- wpa_supplicant-0.5.11.ORIG/driver_wext.c	2008-10-25 20:15:57.000000000 +0200
+++ wpa_supplicant-0.5.11/driver_wext.c	2010-06-28 10:19:12.000000000 +0300
@@ -16,6 +16,8 @@
  * of drivers. In addition to this, some of the common functions in this file
  * can be used by other driver interface implementations that use generic WE
  * ioctls, but require private ioctls for some of the functionality.
+ *
+ * $Id: driver_wext.c 2556 2008-05-06 15:37:57Z andreit $
  */
 
 #include "includes.h"
@@ -53,12 +55,29 @@
 #endif
 #endif /* CONFIG_CLIENT_MLME */
 
+#ifdef WSC_NEW_IE
+#include "wsc_ie.h"
+
+enum wsc_ie_types {
+	IE_WSC_BEACON     = 0,
+	IE_WSC_PROBE_REQ  = 1,
+	IE_WSC_PROBE_RESP = 2
+};
+
+typedef void (*l2_pkt_handler_t)(void *ctx, const u8 *src_addr,
+	const u8 *buf, size_t len);
+#endif
+
 
 struct wpa_driver_wext_data {
 	void *ctx;
 	int event_sock;
 	int ioctl_sock;
 	int mlme_sock;
+#ifdef WSC_NEW_IE
+	struct l2_packet_data *l2_sock;
+	l2_pkt_handler_t l2_pkt_handler;
+#endif
 	char ifname[IFNAMSIZ + 1];
 	int ifindex;
 	int ifindex2;
@@ -80,6 +99,8 @@
 	char mlmedev[IFNAMSIZ + 1];
 
 	int scan_complete_events;
+
+	u8 cloned_mac_addr[ETH_ALEN];
 };
 
 
@@ -957,6 +978,7 @@
 	drv = os_zalloc(sizeof(*drv));
 	if (drv == NULL)
 		return NULL;
+	drv->cloned_mac_addr[0] = 0xff;
 	drv->ctx = ctx;
 	os_strncpy(drv->ifname, ifname, sizeof(drv->ifname));
 
@@ -1240,10 +1262,12 @@
 		if (ioctl(drv->ioctl_sock, SIOCGIWSCAN, &iwr) == 0)
 			break;
 
-		if (errno == E2BIG && res_buf_len < 100000) {
+		if (errno == E2BIG && res_buf_len < 0xffff) {
 			os_free(res_buf);
 			res_buf = NULL;
 			res_buf_len *= 2;
+			if (res_buf_len > 0xffff)
+				res_buf_len = 0xffff; /* 16-bit length field */
 			wpa_printf(MSG_DEBUG, "Scan results did not fit - "
 				   "trying larger buffer (%lu bytes)",
 				   (unsigned long) res_buf_len);
@@ -2136,6 +2160,16 @@
 	return 0;
 }
 
+static const u8* wpa_driver_wext_get_mac_addr(void *priv)
+{
+	struct wpa_driver_wext_data *drv = priv;
+
+	if (drv->cloned_mac_addr[0] == 0xff)
+		return NULL;
+
+	return drv->cloned_mac_addr;
+}
+
 
 int wpa_driver_wext_alternative_ifindex(struct wpa_driver_wext_data *drv,
 					const char *ifname)
@@ -2432,16 +2466,22 @@
 
 static int wpa_driver_wext_set_param(void *priv, const char *param)
 {
-#ifdef CONFIG_CLIENT_MLME
 	struct wpa_driver_wext_data *drv = priv;
+	static const char maclon_tag[] = "maclone=";
+	const char *p = param;
+#ifdef CONFIG_CLIENT_MLME
 	const char *pos, *pos2;
 	size_t len;
+#endif
+	int a[ETH_ALEN];
+	int r;
 
 	if (param == NULL)
 		return 0;
 
 	wpa_printf(MSG_DEBUG, "%s: param='%s'", __func__, param);
 
+#ifdef CONFIG_CLIENT_MLME
 	pos = os_strstr(param, "mlmedev=");
 	if (pos) {
 		pos += 8;
@@ -2464,6 +2504,23 @@
 	}
 #endif /* CONFIG_CLIENT_MLME */
 
+	p = os_strstr(param, maclon_tag);
+	if (p) {
+		p += os_strlen(maclon_tag);
+		r = sscanf(p, "%x:%x:%x:%x:%x:%x", a,a+1,a+2,a+3,a+4,a+5);
+		if (r != 6) {
+			wpa_printf(MSG_DEBUG, "invalid %s param value %s",
+					maclon_tag, p);
+			return -1;
+		}
+		drv->cloned_mac_addr[0] = a[0];
+		drv->cloned_mac_addr[1] = a[1];
+		drv->cloned_mac_addr[2] = a[2];
+		drv->cloned_mac_addr[3] = a[3];
+		drv->cloned_mac_addr[4] = a[4];
+		drv->cloned_mac_addr[5] = a[5];
+	}
+
 	return 0;
 }
 
@@ -2473,6 +2530,235 @@
 	return drv->we_version_compiled;
 }
 
+#ifdef WSC_NEW_IE
+static int
+start_l2_packet(struct wpa_driver_wext_data *drv, l2_pkt_handler_t handler)
+{
+	u8 own_addr[ETH_ALEN + 1];
+
+	if (drv->l2_sock) {
+		wpa_printf(MSG_DEBUG, "socket already inited");
+		return 0;
+	}
+
+	drv->l2_sock = l2_packet_init(drv->ifname, NULL,
+				0x0003/*ETH_P_ALL*/, handler, drv, 1);
+	if (drv->l2_sock == NULL)
+	{
+		printf("l2_packet_init failed\n");
+		return -1;
+	}
+
+	if (l2_packet_get_own_addr(drv->l2_sock, own_addr))
+		return -1;
+
+	printf("l2_packet_init Successful\n");
+	return 0;
+}
+
+static int
+wpa_driver_wext_init_l2_packet(void *priv, l2_pkt_handler_t handler)
+{
+	struct wpa_driver_wext_data *drv = priv;
+
+	drv->l2_pkt_handler = handler;
+//	start_l2_packet(drv, handler);
+	return 0;
+}
+
+static int
+wpa_driver_wext_deinit_l2_packet(void *priv)
+{
+	struct wpa_driver_wext_data *drv = priv;
+
+	l2_packet_deinit(drv->l2_sock);
+
+	drv->l2_sock = 0;
+
+	return 0;
+}
+
+static int
+wpa_driver_wext_start_receive_beacons(void *priv)
+{
+	struct wpa_driver_wext_data *drv = priv;
+
+	if (!drv->l2_pkt_handler) {
+		wpa_printf(MSG_DEBUG, "l2 socket didn't ever inited");
+		return -1;
+	}
+	return start_l2_packet(drv, drv->l2_pkt_handler);
+}
+
+static int
+wpa_driver_wext_stop_receive_beacons(void *priv)
+{
+	return wpa_driver_wext_deinit_l2_packet(priv);
+}
+
+static int
+wpa_driver_wext_start_receive_pr_resps(void *priv)
+{
+	struct wpa_driver_wext_data *drv = priv;
+
+	if (!drv->l2_pkt_handler) {
+		wpa_printf(MSG_DEBUG, "l2 socket didn't ever inited");
+		return -1;
+	}
+	return start_l2_packet(drv, drv->l2_pkt_handler);
+}
+
+static int
+wpa_driver_wext_stop_receive_pr_resps(void *priv)
+{
+	return wpa_driver_wext_deinit_l2_packet(priv);
+}
+
+static int
+wpa_driver_wext_set_wsc_probe_req_ie(void *priv, u8 *ie, int ie_len)
+{
+	struct wpa_driver_wext_data *drv = priv;
+	struct iwreq iwr;
+	int ret = 0;
+
+	memset(&iwr, 0, sizeof(iwr));
+	strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	iwr.u.data.pointer = (caddr_t) ie;
+	iwr.u.data.length = ie_len;
+	iwr.u.data.flags = IE_WSC_PROBE_REQ;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWGENIE, &iwr) < 0) {
+		perror("ioctl[SIOCSIWGENIE]");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+
+#define	IEEE80211_ADDR_LEN	6	/* size of 802.11 address */
+#define	IEEE80211_FC0_SUBTYPE_MASK		0xf0
+#define	IEEE80211_FC0_SUBTYPE_PROBE_RESP	0x50
+#define	IEEE80211_FC0_SUBTYPE_BEACON		0x80
+
+/*
+ * Management information element payloads.
+ */
+
+enum {
+	IEEE80211_ELEMID_SSID		= 0,
+	IEEE80211_ELEMID_RATES		= 1,
+	IEEE80211_ELEMID_FHPARMS	= 2,
+	IEEE80211_ELEMID_DSPARMS	= 3,
+	IEEE80211_ELEMID_CFPARMS	= 4,
+	IEEE80211_ELEMID_TIM		= 5,
+	IEEE80211_ELEMID_IBSSPARMS	= 6,
+	IEEE80211_ELEMID_COUNTRY	= 7,
+	IEEE80211_ELEMID_REQINFO	= 10,
+	IEEE80211_ELEMID_CHALLENGE	= 16,
+	/* 17-31 reserved for challenge text extension */
+	IEEE80211_ELEMID_PWRCNSTR	= 32,
+	IEEE80211_ELEMID_PWRCAP		= 33,
+	IEEE80211_ELEMID_TPCREQ		= 34,
+	IEEE80211_ELEMID_TPCREP		= 35,
+	IEEE80211_ELEMID_SUPPCHAN	= 36,
+	IEEE80211_ELEMID_CHANSWITCHANN	= 37,
+	IEEE80211_ELEMID_MEASREQ	= 38,
+	IEEE80211_ELEMID_MEASREP	= 39,
+	IEEE80211_ELEMID_QUIET		= 40,
+	IEEE80211_ELEMID_IBSSDFS	= 41,
+	IEEE80211_ELEMID_ERP		= 42,
+	IEEE80211_ELEMID_RSN		= 48,
+	IEEE80211_ELEMID_XRATES		= 50,
+	IEEE80211_ELEMID_TPC		= 150,
+	IEEE80211_ELEMID_CCKM		= 156,
+	IEEE80211_ELEMID_VENDOR		= 221,	/* vendor private */
+};
+
+struct ieee80211_frame {
+	u_int8_t i_fc[2];
+	u_int8_t i_dur[2];
+	u_int8_t i_addr1[IEEE80211_ADDR_LEN];
+	u_int8_t i_addr2[IEEE80211_ADDR_LEN];
+	u_int8_t i_addr3[IEEE80211_ADDR_LEN];
+	u_int8_t i_seq[2];
+	/* possibly followed by addr4[IEEE80211_ADDR_LEN]; */
+	/* see below */
+} __packed;
+
+static int
+wpa_driver_wext_process_frame(void *driver, void *ctx, const u8 *src_addr,
+	const u8 *buf, size_t len, u8 *newbuf, int *newlen, u8 *frameType)
+{
+	u8 * frm;
+	u8 * endfrm;
+	char ssid[32];
+	u8 bssid[6];
+	struct ieee80211_frame *wh;
+	u8 * tmpptr;
+	u8 subtype;
+
+	/*printf("Received %d bytes; beacon or pr-resp number %d\n", len, j++);*/
+
+	wh = (struct ieee80211_frame *) buf;
+	frm = (u8 *)&wh[1];
+	endfrm = (u8 *) (buf + len);
+
+	subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;
+	*frameType = 0;
+	if (subtype == IEEE80211_FC0_SUBTYPE_BEACON)
+		*frameType = WSC_IE_TYPE_SET_BEACON_IE;
+	else if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
+		*frameType = WSC_IE_TYPE_SET_PROBE_RESPONSE_IE;
+
+	/*printf("frameType = %d\n", *frameType);*/
+	memcpy(bssid, wh->i_addr3, IEEE80211_ADDR_LEN);
+
+	// skip timestamp(8), beac interval(2), cap info (2)
+	frm += 12;
+	while (frm < endfrm)
+	{
+		switch (*frm)
+		{
+		case IEEE80211_ELEMID_SSID:
+			if (frm[1] > 1)
+			{
+				// printf("ssid len = %d\n", frm[1]);
+				memset(ssid, 0, 32);
+				memcpy(ssid, &frm[2], frm[1]);
+				/*printf("ssid: %s\n", ssid);*/
+			}
+			else
+			{
+				// printf("ssid: <hidden>\n");
+			}
+
+			break;
+		case IEEE80211_ELEMID_VENDOR:
+			// check for WFA OUI
+			if (frm[1] > 4 && frm[2] == 0x00 && frm[3] == 0x50 && frm[4] == 0xF2 && frm[5]==0x04)
+			{
+				tmpptr = newbuf;
+				memcpy(tmpptr, ssid, 32);
+				tmpptr += 32;
+				memcpy(tmpptr, bssid, 6);
+				tmpptr += 6;
+				memcpy(tmpptr, &frm[6], frm[1] - 4);
+				tmpptr += (frm[1] - 4);
+				*newlen = (int) (tmpptr - newbuf);
+				/* printf("Got WSC IE; ssid = %s, IE len = %d, newlen = %d\n", ssid, frm[1], *newlen); */
+			}
+		default:
+			break;
+		} // switch
+
+		frm += frm[1] + 2;
+	} // while
+
+	return 0;
+}
+#endif
+
 
 const struct wpa_driver_ops wpa_driver_wext_ops = {
 	.name = "wext",
@@ -2492,6 +2778,7 @@
 	.init = wpa_driver_wext_init,
 	.deinit = wpa_driver_wext_deinit,
 	.set_param = wpa_driver_wext_set_param,
+	.get_mac_addr = wpa_driver_wext_get_mac_addr,
 	.add_pmkid = wpa_driver_wext_add_pmkid,
 	.remove_pmkid = wpa_driver_wext_remove_pmkid,
 	.flush_pmkid = wpa_driver_wext_flush_pmkid,
@@ -2506,4 +2793,14 @@
 	.mlme_add_sta = wpa_driver_wext_mlme_add_sta,
 	.mlme_remove_sta = wpa_driver_wext_mlme_remove_sta,
 #endif /* CONFIG_CLIENT_MLME */
+#ifdef WSC_NEW_IE
+	.start_receive_beacons = wpa_driver_wext_start_receive_beacons,
+	.stop_receive_beacons = wpa_driver_wext_stop_receive_beacons,
+	.start_receive_pr_resps = wpa_driver_wext_start_receive_pr_resps,
+	.stop_receive_pr_resps = wpa_driver_wext_stop_receive_pr_resps,
+	.init_l2_packet = wpa_driver_wext_init_l2_packet,
+	.deinit_l2_packet = wpa_driver_wext_deinit_l2_packet,
+	.set_wsc_probe_request_ie = wpa_driver_wext_set_wsc_probe_req_ie,
+	.process_frame = wpa_driver_wext_process_frame,
+#endif
 };
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/eap_defs.h wpa_supplicant-0.5.11/eap_defs.h
--- wpa_supplicant-0.5.11.ORIG/eap_defs.h	2007-03-25 04:09:50.000000000 +0200
+++ wpa_supplicant-0.5.11/eap_defs.h	2010-06-28 10:19:12.000000000 +0300
@@ -58,7 +58,8 @@
 	EAP_TYPE_PAX = 46 /* RFC 4746 */,
 	EAP_TYPE_PSK = 47 /* RFC 4764 */,
 	EAP_TYPE_SAKE = 48 /* RFC 4763 */,
-	EAP_TYPE_EXPANDED = 254 /* RFC 3748 */,
+	EAP_TYPE_EXPANDED = 253 /* RFC 3748 */,
+	EAP_TYPE_WSC = 254, /* Wireless Simple Config */
 	EAP_TYPE_GPSK = 255 /* EXPERIMENTAL - type not yet allocated
 			     * draft-ietf-emu-eap-gpsk-01.txt */
 } EapType;
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/eap_methods.c wpa_supplicant-0.5.11/eap_methods.c
--- wpa_supplicant-0.5.11.ORIG/eap_methods.c	2007-03-25 04:09:50.000000000 +0200
+++ wpa_supplicant-0.5.11/eap_methods.c	2010-06-28 10:19:12.000000000 +0300
@@ -441,6 +441,13 @@
 	}
 #endif /* EAP_PAX */
 
+#ifdef EAP_WSC
+	if (ret == 0) {
+		int eap_peer_wsc_register(void);
+		ret = eap_peer_wsc_register();
+	}
+#endif /* EAP_PAX */
+
 #ifdef EAP_SAKE
 	if (ret == 0) {
 		int eap_peer_sake_register(void);
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/eap_wsc.c wpa_supplicant-0.5.11/eap_wsc.c
--- wpa_supplicant-0.5.11.ORIG/eap_wsc.c	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/eap_wsc.c	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,256 @@
+/*
+ * WPA Supplicant / Wi-Fi Simple Configuration 7C Proposal
+ * Copyright (c) 2004-2005, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright (c) 2005 Intel Corporation. All rights reserved.
+ * Contact Information: Harsha Hegde  <harsha.hegde@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README, README_WSC and COPYING for more details.
+ * 
+ * $Id: eap_wsc.c 1711 2007-10-19 06:56:28Z oleksandrb $
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#ifdef __linux__
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#endif
+#include <openssl/evp.h>
+#include <openssl/err.h>
+#include <openssl/dh.h>
+#include <openssl/bn.h>
+#include <openssl/rand.h>
+
+#include "common.h"
+#include "eloop.h"
+#include "eap_i.h"
+#include "wpa_supplicant.h"
+#include "eap_wsc.h"
+#include "UdpLib.h"
+
+#define WSC_EAP_UDP_PORT            37000
+#define WSC_EAP_UDP_ADDR            "127.0.0.1"
+
+// This function is called from wpa_supplicant_init; it is responsible
+// to initiate the connection with Intel WPS application
+struct eap_wsc_data *eap_wsc_init(void)
+{
+    struct eap_wsc_data *data;
+
+    wpa_printf(MSG_DEBUG,"@#*@#*@#*EAP-WSC: Entered eap_wsc_init *#@*#@*#@");
+
+    data = malloc(sizeof(*data));
+    if (data == NULL)
+        return data;
+    memset(data, 0, sizeof(*data));
+
+    data->udpFdEap = udp_open();
+
+    return data;
+}
+
+void eap_wsc_deinit(struct eap_wsc_data **priv)
+{
+    struct eap_wsc_data *data = *priv;
+
+    wpa_printf(MSG_DEBUG,"@#*@#*@#*EAP-WSC: Entered eap_wsc_reset *#@*#@*#@");
+
+
+    if (data == NULL)
+        return;
+
+    if (data->udpFdEap != -1)
+    {
+        udp_close(data->udpFdEap);
+        data->udpFdEap = -1;
+        free(data);
+        *priv = NULL;
+   }
+}
+
+u8 *eap_wsc_process(struct eap_wsc_data *data, const u8 *reqData, size_t reqDataLen, size_t *respDataLen)
+{
+    struct eap_hdr *req;
+    int recvBytes;
+    u8 *resp;
+    u8 *sendBuf;
+    u32 sendBufLen;
+    struct sockaddr_in from;
+    struct sockaddr_in to;
+    WSC_NOTIFY_DATA notifyData;
+
+    wpa_printf(MSG_DEBUG,"@#*@#*@#*EAP-WSC: Entered eap_wsc_process *#@*#@*#@");
+
+    req = (struct eap_hdr *) reqData;
+    wpa_printf(MSG_DEBUG, "EAP-WSC : Received packet(len=%lu) ",
+               (unsigned long) reqDataLen);
+    if(ntohs(req->length) != reqDataLen)
+    {
+        wpa_printf(MSG_INFO, "EAP-WSC: Pkt length in pkt(%d) differs from" 
+            " supplied (%d)\n", ntohs(req->length), reqDataLen);
+        return NULL;
+    }
+
+    notifyData.type = WSC_NOTIFY_TYPE_PROCESS_REQ;
+    notifyData.length = reqDataLen;
+    notifyData.u.process.state = data->state;
+
+    sendBuf = (u8 *) malloc(sizeof(WSC_NOTIFY_DATA) + reqDataLen);
+    if ( ! sendBuf)
+    {
+        wpa_printf(MSG_INFO, "EAP-WSC: Memory allocation "
+                "for the sendBuf failed\n");
+        return NULL;
+    }
+
+    memcpy(sendBuf, &notifyData, sizeof(WSC_NOTIFY_DATA));
+    memcpy(sendBuf + sizeof(WSC_NOTIFY_DATA), reqData, reqDataLen);
+    sendBufLen = sizeof(WSC_NOTIFY_DATA) + reqDataLen;
+
+    to.sin_addr.s_addr = inet_addr(WSC_EAP_UDP_ADDR);
+    to.sin_family = AF_INET;
+    to.sin_port = htons(WSC_EAP_UDP_PORT);
+
+    if (udp_write(data->udpFdEap, (char *) sendBuf, sendBufLen, &to) < 
+            sendBufLen)
+    {
+        wpa_printf(MSG_INFO, "EAP-WSC: Sending Eap message to "
+                "upper Layer failed\n");
+        free(sendBuf);
+        return NULL;
+    }
+
+    free(sendBuf);
+
+    recvBytes = udp_read_timed(data->udpFdEap, (char *) data->recvBuf, 
+            WSC_RECVBUF_SIZE, &from, 5);
+
+    if (recvBytes == -1)
+    {
+        wpa_printf(MSG_INFO, "EAP-WSC: Reading EAP message "
+                "from upper layer failed\n");
+        return NULL;
+    }
+
+    data->recvNotify = (WSC_NOTIFY_DATA *) data->recvBuf;
+    if ((data->recvNotify->type != WSC_NOTIFY_TYPE_PROCESS_RESULT) ||
+    (data->recvNotify->u.processResult.result != WSC_NOTIFY_RESULT_SUCCESS))
+    {
+        wpa_printf(MSG_INFO, "EAP-WSC: Process Message failed "
+            "somewhere\n");
+        return NULL;
+    }
+    
+    resp = (u8 *) malloc(data->recvNotify->length);
+    if ( ! resp)
+    {
+        wpa_printf(MSG_INFO, "EAP-WSC: Memory allocation "
+                "for the resp failed\n");
+        return NULL;
+    }
+
+    memcpy(resp, data->recvNotify + 1, data->recvNotify->length);
+    *respDataLen = data->recvNotify->length;
+
+    return resp;
+}
+
+
+static void * eap_wsc_mthd_init(struct eap_sm *sm)
+{
+    struct eap_wsc_data *data;
+
+    wpa_printf(MSG_DEBUG,"@#*@#*@#*EAP-WSC: Entered eap_wsc_mthd_init *#@*#@*#@");
+
+    data = eap_wsc_init();
+
+    sm->eap_method_priv = data;
+
+    return data;
+}
+
+
+static void eap_wsc_mthd_deinit(struct eap_sm *sm, void *priv)
+{
+    struct eap_wsc_data *p_data = priv;
+    wpa_printf(MSG_DEBUG,"@#*@#*@#*EAP-WSC: Entered eap_wsc_mthd_deinit *#@*#@*#@"); 
+
+    eap_wsc_deinit(&p_data);
+}
+
+static u8 * eap_wsc_mthd_process(struct eap_sm *sm, void *priv,
+                                 struct eap_method_ret *ret,
+                                 const u8 *reqData, size_t reqDataLen,
+                                 size_t *respDataLen)
+{
+    u8 *resp;
+    WSC_NOTIFY_DATA *recvNotify;
+
+    wpa_printf(MSG_DEBUG,"@#*@#*@#*EAP-WSC: Entered eap_wsc_mthd_process *#@*#@*#@");
+
+    resp = eap_wsc_process(priv, reqData, reqDataLen, respDataLen);
+    recvNotify = ((struct eap_wsc_data *)priv)->recvNotify;
+
+    if (resp == NULL)
+    {
+        ret->ignore = TRUE;
+        return NULL;
+    }
+    else
+    {
+        ret->ignore = FALSE;
+        ret->decision = DECISION_COND_SUCC;
+        ret->allowNotifications = FALSE;
+        
+        /*check if we're done*/
+        if (recvNotify->u.processResult.done)
+        {
+            ret->methodState = METHOD_DONE;
+        }
+        else
+        {
+            wpa_printf(MSG_INFO, "Always setting it to METHOD_CONT\n");
+            ret->methodState = METHOD_CONT;
+        }
+        return resp;
+    }
+}
+
+/*
+const struct eap_method eap_method_wsc =
+{
+    .method = EAP_TYPE_WSC ,
+    .name = "WSC",
+    .init = eap_wsc_mthd_init,
+    .deinit = eap_wsc_mthd_deinit,
+    .process = eap_wsc_mthd_process,
+};
+*/
+
+int eap_peer_wsc_register(void)
+{
+    struct eap_method *eap;
+    int ret;
+
+    eap = eap_peer_method_alloc(EAP_PEER_METHOD_INTERFACE_VERSION,
+                    EAP_VENDOR_IETF, EAP_TYPE_WSC, "WSC");
+    if (eap == NULL)
+        return -1;
+
+    eap->init = eap_wsc_mthd_init;
+    eap->deinit = eap_wsc_mthd_deinit;
+    eap->process = eap_wsc_mthd_process;
+
+    ret = eap_peer_method_register(eap);
+    if (ret)
+        eap_peer_method_free(eap);
+    return ret;
+}
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/eap_wsc.h wpa_supplicant-0.5.11/eap_wsc.h
--- wpa_supplicant-0.5.11.ORIG/eap_wsc.h	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/eap_wsc.h	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,65 @@
+/* $Id: eap_wsc.h 1668 2007-09-19 08:20:05Z assafh $ */
+
+#ifndef EAP_WSC_H
+#define EAP_WSC_H
+
+/*#pragma pack(push, 1)*/
+
+#define WSC_RECVBUF_SIZE    2048
+
+
+#define WSC_NOTIFY_TYPE_BUILDREQ              1
+#define WSC_NOTIFY_TYPE_BUILDREQ_RESULT       2
+#define WSC_NOTIFY_TYPE_PROCESS_REQ           3
+#define WSC_NOTIFY_TYPE_PROCESS_RESP          4
+#define WSC_NOTIFY_TYPE_PROCESS_RESULT        5
+
+#define WSC_NOTIFY_RESULT_SUCCESS          0x00
+#define WSC_NOTIFY_RESULT_FAILURE          0xFF
+
+typedef struct wsc_notify_buildreq_tag {
+    u32    id;
+    u32 state;
+}__attribute__((packed)) WSC_NOTIFY_BUILDREQ;
+
+typedef struct wsc_notify_process_buildreq_result_tag {
+    u8 result;
+}__attribute__((packed)) WSC_NOTIFY_BUILDREQ_RESULT;
+
+typedef struct wsc_notify_process_tag {
+    u32 state;
+}__attribute__((packed)) WSC_NOTIFY_PROCESS;
+
+typedef struct wsc_notify_process_result_tag {
+    u8 result;
+    u8 done;
+}__attribute__((packed)) WSC_NOTIFY_PROCESS_RESULT;
+
+typedef struct wsc_notify_data_tag {
+    u8 type;
+    u8 addr[6]; //MAC ADDR of the peer station
+    union {
+        WSC_NOTIFY_BUILDREQ bldReq;
+        WSC_NOTIFY_BUILDREQ_RESULT bldReqResult;
+        WSC_NOTIFY_PROCESS process;
+        WSC_NOTIFY_PROCESS_RESULT processResult;
+    } u;
+    u32 length; // length of the data that follows
+}__attribute__((packed)) WSC_NOTIFY_DATA;
+
+
+struct eap_wsc_data {
+    enum { START, CONTINUE, SUCCESS, FAILURE } state;
+    int udpFdEap;
+    int udpFdCom;
+    u8 recvBuf[WSC_RECVBUF_SIZE];
+    WSC_NOTIFY_DATA *recvNotify;
+};
+
+struct eap_wsc_data *eap_wsc_init(void);
+void eap_wsc_deinit(struct eap_wsc_data **priv);
+u8 *eap_wsc_process(struct eap_wsc_data *data, const u8 *reqData, size_t reqDataLen, size_t *respDataLen);
+
+/*#pragma pack(pop)*/
+
+#endif /*EAP_WSC_H*/
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/events.c wpa_supplicant-0.5.11/events.c
--- wpa_supplicant-0.5.11.ORIG/events.c	2007-11-29 04:49:08.000000000 +0200
+++ wpa_supplicant-0.5.11/events.c	2010-06-28 10:19:12.000000000 +0300
@@ -87,6 +87,10 @@
 
 void wpa_supplicant_mark_disassoc(struct wpa_supplicant *wpa_s)
 {
+#ifdef EAP_WSC
+	// Try to deinitiate wps interface
+	eap_wsc_deinit(&(wpa_s->wsc_data));
+#endif
 	wpa_supplicant_set_state(wpa_s, WPA_DISCONNECTED);
 	os_memset(wpa_s->bssid, 0, ETH_ALEN);
 	os_memset(wpa_s->pending_bssid, 0, ETH_ALEN);
@@ -472,7 +476,11 @@
 				continue;
 			}
 
+#ifdef WSC_NEW_IE
+			if (!(g_wsc || wpa_supplicant_match_privacy(bss, ssid))) {
+#else
 			if (!wpa_supplicant_match_privacy(bss, ssid)) {
+#endif
 				wpa_printf(MSG_DEBUG, "   skip - "
 					   "privacy mismatch");
 				continue;
@@ -712,7 +720,13 @@
 	eapol_sm_notify_portEnabled(wpa_s->eapol, FALSE);
 	eapol_sm_notify_portValid(wpa_s->eapol, FALSE);
 	if (wpa_s->key_mgmt == WPA_KEY_MGMT_PSK)
+	{
+#ifdef EAP_WSC
+		// PSK key management, could be EAP registrar; initiate wps interface
+		wpa_s->wsc_data = eap_wsc_init();
+#endif		
 		eapol_sm_notify_eap_success(wpa_s->eapol, FALSE);
+	}
 	/* 802.1X::portControl = Auto */
 	eapol_sm_notify_portEnabled(wpa_s->eapol, TRUE);
 	wpa_s->eapol_received = 0;
@@ -749,7 +763,7 @@
 			"pre-shared key may be incorrect");
 	}
 	if (wpa_s->wpa_state >= WPA_ASSOCIATED)
-		wpa_supplicant_req_scan(wpa_s, 0, 100000);
+		wpa_supplicant_req_scan(wpa_s, 5, 0);
 	bssid = wpa_s->bssid;
 	if (os_memcmp(bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN) == 0)
 		bssid = wpa_s->pending_bssid;
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/l2_packet_linux.c wpa_supplicant-0.5.11/l2_packet_linux.c
--- wpa_supplicant-0.5.11.ORIG/l2_packet_linux.c	2007-11-29 04:44:36.000000000 +0200
+++ wpa_supplicant-0.5.11/l2_packet_linux.c	2010-06-28 10:19:12.000000000 +0300
@@ -135,13 +135,16 @@
 		return NULL;
 	}
 
-	if (ioctl(l2->fd, SIOCGIFHWADDR, &ifr) < 0) {
-		perror("ioctl[SIOCGIFHWADDR]");
-		close(l2->fd);
-		os_free(l2);
-		return NULL;
+	if (!own_addr) {
+		if (ioctl(l2->fd, SIOCGIFHWADDR, &ifr) < 0) {
+			perror("ioctl[SIOCGIFHWADDR]");
+			close(l2->fd);
+			free(l2);
+			return NULL;
+		}
+		own_addr = ifr.ifr_hwaddr.sa_data;
 	}
-	os_memcpy(l2->own_addr, ifr.ifr_hwaddr.sa_data, ETH_ALEN);
+	os_memcpy(l2->own_addr, own_addr, ETH_ALEN);
 
 	eloop_register_read_sock(l2->fd, l2_packet_receive, l2, NULL);
 
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/Makefile wpa_supplicant-0.5.11/Makefile
--- wpa_supplicant-0.5.11.ORIG/Makefile	2008-11-28 18:21:29.000000000 +0200
+++ wpa_supplicant-0.5.11/Makefile	2010-06-28 10:19:12.000000000 +0300
@@ -1,3 +1,4 @@
+#$Id: Makefile 2890 2008-07-29 08:17:30Z andreit $
 ifndef CC
 CC=gcc
 endif
@@ -7,7 +8,7 @@
 endif
 
 # Include directories for CVS version
-CFLAGS += -I. -I../utils -I../hostapd
+#CFLAGS += -I. -I../utils -I../hostapd
 
 ALL=wpa_supplicant wpa_passphrase wpa_cli
 
@@ -420,6 +421,20 @@
 CONFIG_IEEE8021X_EAPOL=y
 endif
 
+ifdef CONFIG_EAP_WSC          
+# EAP-WSC Wireless Simple config files
+CFLAGS += -DEAP_WSC
+OBJS += eap_wsc.o UdpLib.o
+LIBS += -lssl -lcrypto     
+CONFIG_IEEE8021X_EAPOL=y
+endif             
+
+ifdef CONFIG_WSC_IE     
+# Support for new WSC IEs
+CFLAGS += -DWSC_NEW_IE
+OBJS += wsc_ie.o    
+endif  
+
 ifdef CONFIG_IEEE8021X_EAPOL
 # IEEE 802.1X/EAPOL state machines (e.g., for RADIUS authentication)
 CFLAGS += -DIEEE8021X_EAPOL
@@ -772,6 +787,7 @@
 
 wpa_supplicant: .config $(OBJS)
 	$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
+	if [ "$(STRIP)" ]; then cp wpa_supplicant wpa_supplicant_debug && $(STRIP) wpa_supplicant; fi
 
 eapol_test: .config $(OBJS_t)
 	$(LDO) $(LDFLAGS) -o eapol_test $(OBJS_t) $(LIBS)
@@ -781,9 +797,11 @@
 
 wpa_passphrase: $(OBJS_p)
 	$(LDO) $(LDFLAGS) -o wpa_passphrase $(OBJS_p) $(LIBS_p)
+	if [ "$(STRIP)" ]; then cp wpa_passphrase wpa_passphrase_debug && $(STRIP) wpa_passphrase; fi
 
 wpa_cli: $(OBJS_c)
 	$(LDO) $(LDFLAGS) -o wpa_cli $(OBJS_c) $(LIBS_c)
+	if [ "$(STRIP)" ]; then cp wpa_cli wpa_cli_debug && $(STRIP) wpa_cli; fi
 
 OBJSa=asn1_test.o asn1.o x509v3.o common.o os_unix.o \
 	crypto_$(CONFIG_CRYPTO).o md5.o sha1.o \
@@ -892,6 +910,9 @@
 
 clean:
 	rm -f core *~ *.o *.d eap_*.so $(ALL) $(WINALL)
+ 
+romfs:
+	echo "stub"
 
 %.eps: %.fig
 	fig2dev -L eps $*.fig $*.eps
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/Makefile.440epx wpa_supplicant-0.5.11/Makefile.440epx
--- wpa_supplicant-0.5.11.ORIG/Makefile.440epx	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/Makefile.440epx	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.440epx
+#
+# @brief   This file for AMCC PPC440EPx to build the wpa_supplicant utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/amcc/toolchain/usr/bin/ppc_4xxFP-
+CFLAGS=-O2
+CC=${CROSS_COMPILE}gcc
+STRIP=${CROSS_COMPILE}strip
+export CC STRIP CFLAGS 
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/Makefile.5vt1310 wpa_supplicant-0.5.11/Makefile.5vt1310
--- wpa_supplicant-0.5.11.ORIG/Makefile.5vt1310	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/Makefile.5vt1310	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.5vt1310
+#
+# @brief   This file for ZCOM 5VT1310 to build the wpa_supplicant utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/crosstool/uClibc/bin/arm-linux-uclibc-
+CFLAGS=-O2
+CC=${CROSS_COMPILE}gcc
+STRIP=${CROSS_COMPILE}strip
+export CC STRIP CFLAGS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/Makefile.amazon wpa_supplicant-0.5.11/Makefile.amazon
--- wpa_supplicant-0.5.11.ORIG/Makefile.amazon	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/Makefile.amazon	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.amazon
+#
+# @brief   This file for Infineon Amazon_S to build the wpa_supplicant utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/infineon/toolchain/compiler/mips-linux-
+CFLAGS=-O2
+CC=${CROSS_COMPILE}gcc
+STRIP=/opt/uclibc-toolchain/ifx-lxdb26-1.0.2/gcc-3.4.4/toolchain-mips/bin/mips-linux-strip
+export CC STRIP CFLAGS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/Makefile.cavium wpa_supplicant-0.5.11/Makefile.cavium
--- wpa_supplicant-0.5.11.ORIG/Makefile.cavium	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/Makefile.cavium	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,23 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.cavium
+#
+# @brief   This file for CAVIUM to build the wpa_supplicant utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/cavium/Nitrox-SOHO-2.8.3/uClinux/brecis/tools/mipsisa32-brecis-uclinux/bin/mips-
+CFLAGS=-mips32 -mtune=4kc -EB -I/opt/toolchains/cavium/Nitrox-SOHO-2.8.3-we18/uClinux/brecis/tools/mipsisa32-brecis-uclinux/mipsisa32-brecis-uclinux/include/openssl
+CC=${CROSS_COMPILE}gcc
+STRIP=${CROSS_COMPILE}strip
+LIBS=-L/opt/toolchains/cavium/Nitrox-SOHO-2.8.3-we18/uClinux/brecis/tools/mipsisa32-brecis-uclinux/mipsisa32-brecis-uclinux/lib
+export CC STRIP CFLAGS LIBS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/Makefile.dma wpa_supplicant-0.5.11/Makefile.dma
--- wpa_supplicant-0.5.11.ORIG/Makefile.dma	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/Makefile.dma	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.dma
+#
+# @brief   This file for Sigma 8621 to build the wpa_supplicant utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/sigma/8621_dma/toolchain/toolchain/bin/arm-elf-
+CFLAGS=-Os -march=armv4 -mtune=arm7tdmi -mshort-load-bytes -msoft-float
+CC=${CROSS_COMPILE}gcc
+LIBS=-L/opt/toolchains/sigma/8624_dtv/toolchain/toolchain/lib -Wl,-elf2flt="-s32768"
+export CC CFLAGS LIBS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/Makefile.dtv wpa_supplicant-0.5.11/Makefile.dtv
--- wpa_supplicant-0.5.11.ORIG/Makefile.dtv	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/Makefile.dtv	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.dtv
+#
+# @brief   This file for Sigma 8624 to build the wpa_supplicant utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/sigma/8624_dtv/toolchain/toolchain/bin/arm-elf-
+CFLAGS=-Os -march=armv4 -mtune=arm7tdmi -mshort-load-bytes -msoft-float
+CC=${CROSS_COMPILE}gcc
+LIBS=-L/opt/toolchains/sigma/8624_dtv/toolchain/toolchain/lib -Wl,-elf2flt="-s32768"
+export CC CFLAGS LIBS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/Makefile.MTLK wpa_supplicant-0.5.11/Makefile.MTLK
--- wpa_supplicant-0.5.11.ORIG/Makefile.MTLK	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/Makefile.MTLK	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,39 @@
+######### Metalink (c) #####################
+######### Standard header begin ############
+
+## TOPDIR may be set. It points to the top directory where all the E_* variables are in Makefiles.MTLK.vars
+ifdef E_TOPDIR
+include $(E_TOPDIR)/scripts/Makefile.MTLK.vars
+else
+$(error "E_TOPDIR doesn't defined")
+endif
+
+######### Standard header end ##############
+
+CFLAGS=-Os -I$(E_TOPDIR)/l/openssl/include 
+CC=$(E_CC)
+LIBS=-L$(E_TOPDIR)/l/openssl
+LIBS_p=-L$(E_TOPDIR)/l/openssl
+STRIP=$(E_STRIP)
+export CC CFLAGS LIBS LIBS_p STRIP
+
+CONF:
+	echo No configuration here
+COMP:
+	make all
+
+CLEAN:
+	make clean
+
+INSTALL: FORCE
+	install -D -m 755 wpa_supplicant $(E_DEST)/root/mtlk/etc/wpa_supplicant
+	install -D -m 755 wpa_passphrase $(E_DEST)/root/mtlk/etc/wpa_passphrase
+	install -D -m 755 wpa_cli $(E_DEST)/root/mtlk/etc/wpa_cli
+STRIP:
+	$(E_STRIP) $(E_DEST)/root/mtlk/etc/wpa_supplicant
+	$(E_STRIP) $(E_DEST)/root/mtlk/etc/wpa_passphrase
+	$(E_STRIP) $(E_DEST)/root/mtlk/etc/wpa_cli
+
+FORCE:
+
+	
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/Makefile.pika wpa_supplicant-0.5.11/Makefile.pika
--- wpa_supplicant-0.5.11.ORIG/Makefile.pika	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/Makefile.pika	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.pika
+#
+# @brief   This file for Sigma 8622 to build the wpa_supplicant utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/sigma/8622_pika/toolchain/toolchain/bin/arm-elf-
+CFLAGS=-Os -march=armv4 -mtune=arm7tdmi -mshort-load-bytes -msoft-float
+CC=${CROSS_COMPILE}gcc
+LIBS=-L/opt/toolchains/sigma/8624_dtv/toolchain/toolchain/lib -Wl,-elf2flt="-s32768"
+export CC CFLAGS LIBS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/Makefile.STAR wpa_supplicant-0.5.11/Makefile.STAR
--- wpa_supplicant-0.5.11.ORIG/Makefile.STAR	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/Makefile.STAR	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,23 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.str9102
+#
+# @brief   This file for STAR 9102 Dorado to build the wpa_supplicant utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/star/tools/arm-uclibc-3.4.6/bin/arm-linux-uclibc-
+CFLAGS=-Os -I/opt/apps-rootfs/openssl-0.9.8a/include
+LIBS=-L/opt/apps-rootfs/openssl-0.9.8a 
+LIBS_p=-L/opt/apps-rootfs/openssl-0.9.8a 
+CC=${CROSS_COMPILE}gcc
+export CC CFLAGS LIBS LIBS_p
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/Makefile.str9102 wpa_supplicant-0.5.11/Makefile.str9102
--- wpa_supplicant-0.5.11.ORIG/Makefile.str9102	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/Makefile.str9102	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.str9102
+#
+# @brief   This file for STAR 9102 Dorado to build the wpa_supplicant utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/star/toolchain/tools/arm-uclibc-3.4.6/bin/arm-linux-uclibc-
+CFLAGS=-Os
+CC=${CROSS_COMPILE}gcc
+STRIP=${CROSS_COMPILE}strip
+export CC STRIP CFLAGS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/Makefile.vantage wpa_supplicant-0.5.11/Makefile.vantage
--- wpa_supplicant-0.5.11.ORIG/Makefile.vantage	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/Makefile.vantage	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.vantage
+#
+# @brief   This file for Sigma 8634 to build the wpa_supplicant utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/sigma/8634_jabil/toolchain/toolchain/build_mipsel_nofpu/staging_dir/bin/mipsel-linux-
+CFLAGS=-O2
+CC=${CROSS_COMPILE}gcc
+STRIP=${CROSS_COMPILE}strip
+export CC STRIP CFLAGS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/Makefile.vantage26 wpa_supplicant-0.5.11/Makefile.vantage26
--- wpa_supplicant-0.5.11.ORIG/Makefile.vantage26	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/Makefile.vantage26	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Copyright (c) 2006-2007 Metalink Broadband (Israel)
+#
+# @file    Makefile.vantage26
+#
+# @brief   This file for Sigma 8634 (linux-2.6) to build the wpa_supplicant utility
+#
+# Author:  Oleksandr Baglei <OleksandrB@metalinkbb.com>
+#
+
+CROSS_COMPILE=/opt/toolchains/sigma/8634_jabil/toolchain26/toolchain/build_mipsel_nofpu/staging_dir/bin/mipsel-linux-
+CFLAGS=-O2
+CC=${CROSS_COMPILE}gcc
+STRIP=${CROSS_COMPILE}strip
+export CC STRIP CFLAGS
+
+all:
+	make
+
+clean:
+	make clean
+
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/UdpLib.c wpa_supplicant-0.5.11/UdpLib.c
--- wpa_supplicant-0.5.11.ORIG/UdpLib.c	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/UdpLib.c	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,279 @@
+/*
+ * WPA Supplicant / Wi-Fi Simple Configuration 7C Proposal
+ * Copyright (c) 2005 Intel Corporation. All rights reserved.
+ * Contact Information: Harsha Hegde  <harsha.hegde@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README, README_WSC and COPYING for more details.
+ */
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <errno.h>
+#include "UdpLib.h"
+
+// Comment out the next line if debug strings are not needed
+#define U_DEBUG
+
+void DEBUGF(char *, ...);
+
+
+/******************************************************************************
+ * udp_open()
+ *
+ * This function opens a UDP socket and returns the socket to the calling 
+ * application. The application will use this socket in any subsequent calls.
+ * 
+ * Returns socket handle on success or -1 if there is an error.
+ ****************************************************************************/
+int udp_open()
+{
+    int        new_sock;     // temporary socket handle
+#ifdef _WIN32_REAL
+    int           retval; 
+    WSADATA       wsa_data;
+#endif // _WIN32_REAL
+
+    DEBUGF("Entered udp_open\n");
+
+#ifdef _WIN32_REAL
+    retval = WSAStartup(MAKEWORD(2, 0), &wsa_data);
+    if (retval != 0)
+    {
+        DEBUGF("WSAStartup call failed.\n");
+        return -1;
+    }
+#endif // _WIN32_REAL
+
+    // create INTERNET, udp datagram socket
+    new_sock = (int) socket(AF_INET, SOCK_DGRAM, 0); 
+
+    if ( new_sock < 0 ) {
+        DEBUGF("socket call failed.\n");
+        return -1;
+    }
+
+    DEBUGF("Socket open successful, sd: %d\n", new_sock);
+
+    return new_sock;
+}
+
+
+/******************************************************************************
+ * udp_bind(int fd, int portno)
+ *
+ * This call is used typically by the server application to establish a
+ * well known port. 
+ * 
+ * Returns 1 if succeeds and returns -1 in case of an error.
+ ****************************************************************************/
+int udp_bind(int fd, int portno)
+{
+    struct sockaddr_in binder;
+
+    DEBUGF("Entered udp_bind\n");
+
+    binder.sin_family = AF_INET;
+    binder.sin_addr.s_addr = INADDR_ANY;
+    binder.sin_port = htons(portno);
+
+    // bind protocol to socket
+    if (bind(fd, (struct sockaddr *)&binder, sizeof(binder)))
+    {
+        DEBUGF("bind call for socket [%d] failed.\n", fd);
+        return -1;
+    }
+
+    DEBUGF("Binding successful for socket [%d]\n", fd);
+
+    return 1;
+}
+
+
+/******************************************************************************
+ * udp_close(int fd)
+ *
+ * Closes a UDP session. Closes the socket and returns.
+ ****************************************************************************/
+void udp_close(int fd)
+{
+    DEBUGF("Entered udp_close\n");
+
+#ifdef _WIN32_REAL
+    WSACleanup();
+    closesocket(fd);
+#endif // _WIN32_REAL
+
+#ifdef __linux__
+    close(fd);
+#endif // __linux__
+
+    return;
+}
+
+
+/******************************************************************************
+ * udp_write(int fd, char * buf, int len, struct sockaddr_in * to)
+ * 
+ * This function is called by the application to send data.
+ * fd - socket handle
+ * buf - data buffer
+ * len - byte count of data in buf
+ * to - socket address structure that contains remote ip address and port
+ *      where the data is to be sent
+ * 
+ * Returns bytesSent if succeeded. If there is an error -1 is returned
+ ****************************************************************************/
+int udp_write(int fd, char * buf, int len, struct sockaddr_in * to)
+{
+    int            bytes_sent;
+
+    DEBUGF("Entered udp_write; len = %d\n", len);
+    bytes_sent = sendto(fd, buf, len, 0, 
+           (struct sockaddr *) to, 
+           sizeof(struct sockaddr_in));
+    if (bytes_sent < 0)
+    {
+        DEBUGF("sendto on socket %d failed\n", fd);
+        return -1;
+    }
+    return bytes_sent;
+}
+
+
+/******************************************************************************
+ * udp_read(int fd, char * buf, int len, struct sockaddr_in * from)
+ * 
+ * This function is called by the application to receive data. 
+ * fd - socket handle
+ * buf - data buffer in which the received data will be put
+ * len - size of buf in bytes
+ * from - socket address structure that contains remote ip address and port
+ *        from where the data is received
+ * 
+ * Returns bytes received if succeeded. If there is an error -1 is returned
+ ****************************************************************************/
+int udp_read(int fd, char * buf, int len, struct sockaddr_in * from)
+{
+    int bytes_recd = 0;
+    unsigned int fromlen = 0;
+    fd_set        fdvar;
+    int            sel_ret;
+
+    DEBUGF("Entered udp_read\n");
+
+    FD_ZERO(&fdvar);
+    // we have to wait for only one descriptor
+    FD_SET(fd, &fdvar);
+    
+    sel_ret = select(32, &fdvar, (fd_set *) 0, (fd_set *) 0, NULL);
+    
+    // if select returns negative value, system error
+    if (sel_ret < 0)
+    {
+        DEBUGF("select call failed; system error\n");
+        return -1;
+    }
+
+    // Otherwise Read notification might has come, since we are
+    // waiting for only one fd we need not check the bit. Go ahead
+    // and read the packet
+    fromlen = sizeof (struct sockaddr_in);
+    bytes_recd = recvfrom(fd, buf, len, 0,
+                (struct sockaddr *)from, &fromlen);
+    if (bytes_recd < 0)
+    {
+        DEBUGF("recvfrom on socket %d failed\n", fd);
+        return -1;
+    }
+
+    DEBUGF("Read %d bytes\n", bytes_recd);
+    return bytes_recd;
+}
+
+/******************************************************************************
+ * udp_read_timed(int fd, char * buf, int len, 
+ *                  struct sockaddr_in * from, int timeout)
+ * 
+ * This function is called by the application to receive data. 
+ * fd - socket handle
+ * buf - data buffer in which the received data will be put
+ * len - size of buf in bytes
+ * from - socket address structure that contains remote ip address and port
+ *        from where the data is received
+ * timeout - wait time in seconds
+ * 
+ * Returns bytes received if succeeded. If there is an error -1 is returned
+ ****************************************************************************/
+int udp_read_timed(int fd, char * buf, int len, 
+            struct sockaddr_in * from, int timeout)
+{
+    int bytes_recd = 0;
+    unsigned int fromlen = 0;
+    fd_set        fdvar;
+    int            sel_ret;
+    struct timeval tv;
+
+    DEBUGF("Entered udp_read\n");
+
+    tv.tv_sec = timeout;
+    tv.tv_usec = 0;
+
+    FD_ZERO(&fdvar);
+    // we have to wait for only one descriptor
+    FD_SET(fd, &fdvar);
+    
+    sel_ret = select(32, &fdvar, (fd_set *) 0, (fd_set *) 0, &tv);
+    
+    // if select returns negative value, system error
+    if (sel_ret < 0)
+    {
+        DEBUGF("select call failed; system error\n");
+        return -1;
+    }
+    else if (sel_ret == 0)
+    {
+        DEBUGF("select call timed out\n");
+        return -1;
+    }
+
+    // Otherwise Read notification might has come, since we are
+    // waiting for only one fd we need not check the bit. Go ahead
+    // and read the packet
+    fromlen = sizeof (struct sockaddr_in);
+    bytes_recd = recvfrom(fd, buf, len, 0,
+                (struct sockaddr *)from, &fromlen);
+    if (bytes_recd < 0)
+    {
+        DEBUGF("recvfrom on socket %d failed\n", fd);
+        return -1;
+    }
+
+    DEBUGF("Read %d bytes\n", bytes_recd);
+    return bytes_recd;
+}
+
+void DEBUGF(char * strFormat, ...)
+{
+#ifdef U_DEBUG
+    char     szTraceMsg[1000];
+    va_list  lpArgv;
+
+    va_start(lpArgv, strFormat);
+    vsprintf(szTraceMsg, strFormat, lpArgv);
+    va_end(lpArgv); 
+
+    fprintf(stdout, "UdpLib: %s", szTraceMsg);
+#endif
+}
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/UdpLib.h wpa_supplicant-0.5.11/UdpLib.h
--- wpa_supplicant-0.5.11.ORIG/UdpLib.h	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/UdpLib.h	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,13 @@
+#ifndef _UDPLIB_
+#define _UDPLIB_
+
+int udp_open();
+int udp_bind(int fd, int portno);
+void udp_close(int fd);
+int udp_write(int fd, char * buf, int len, struct sockaddr_in * to);
+int udp_read(int fd, char * buf, int len, struct sockaddr_in * from);
+int udp_read_timed(int fd, char * buf, int len, 
+        struct sockaddr_in * from, int timeout);
+ 
+#endif // _UDPLIB_
+
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/version.h wpa_supplicant-0.5.11/version.h
--- wpa_supplicant-0.5.11.ORIG/version.h	2008-11-28 18:20:27.000000000 +0200
+++ wpa_supplicant-0.5.11/version.h	2010-06-28 10:19:12.000000000 +0300
@@ -1,6 +1,6 @@
 #ifndef VERSION_H
 #define VERSION_H
 
-#define VERSION_STR "0.5.11"
+#define VERSION_STR "0.5.11_mtlk-1.2.6"
 
 #endif /* VERSION_H */
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/wpa_supplicant.c wpa_supplicant-0.5.11/wpa_supplicant.c
--- wpa_supplicant-0.5.11.ORIG/wpa_supplicant.c	2008-10-25 20:12:57.000000000 +0200
+++ wpa_supplicant-0.5.11/wpa_supplicant.c	2010-06-28 10:19:12.000000000 +0300
@@ -27,6 +27,9 @@
 #include "config.h"
 #include "l2_packet.h"
 #include "wpa_supplicant_i.h"
+#ifdef WSC_NEW_IE
+#include "wsc_ie.h"
+#endif
 #include "ctrl_iface.h"
 #include "ctrl_iface_dbus.h"
 #include "pcsc_funcs.h"
@@ -184,7 +187,11 @@
 	/* TODO: could add l2_packet_sendmsg that allows fragments to avoid
 	 * extra copy here */
 
-	if (wpa_s->key_mgmt == WPA_KEY_MGMT_PSK ||
+	if (
+#ifdef EAP_WSC
+#else
+	    wpa_s->key_mgmt == WPA_KEY_MGMT_PSK ||
+#endif
 	    wpa_s->key_mgmt == WPA_KEY_MGMT_NONE) {
 		/* Current SSID is not using IEEE 802.1X/EAP, so drop possible
 		 * EAPOL frames (mainly, EAPOL-Start) from EAPOL state
@@ -897,6 +904,9 @@
 	int reconf_ctrl;
 	if (wpa_s->confname == NULL)
 		return -1;
+
+	wpa_supplicant_disassociate(wpa_s, REASON_DEAUTH_LEAVING);
+
 	conf = wpa_config_read(wpa_s->confname);
 	if (conf == NULL) {
 		wpa_msg(wpa_s, MSG_ERROR, "Failed to parse the configuration "
@@ -939,6 +949,7 @@
 	wpa_supplicant_clear_status(wpa_s);
 	wpa_s->reassociate = 1;
 	wpa_supplicant_req_scan(wpa_s, 0, 0);
+	//TODO: scan only if there is no bssid in the config. file
 	wpa_msg(wpa_s, MSG_DEBUG, "Reconfiguration completed");
 	return 0;
 }
@@ -1289,6 +1300,12 @@
 	}
 
 	sel = ie.key_mgmt & ssid->key_mgmt;
+#ifdef EAP_WSC
+	if (g_wsc) {
+                wpa_s->key_mgmt = WPA_KEY_MGMT_IEEE8021X_NO_WPA;
+                wpa_msg(wpa_s, MSG_DEBUG, "WPA: using KEY_MGMT 802.1X NO WPA");
+        } else
+#endif
 	if (sel & WPA_KEY_MGMT_IEEE8021X) {
 		wpa_s->key_mgmt = WPA_KEY_MGMT_IEEE8021X;
 		wpa_msg(wpa_s, MSG_DEBUG, "WPA: using KEY_MGMT 802.1X");
@@ -1620,6 +1637,10 @@
 				   int reason_code)
 {
 	u8 *addr = NULL;
+#ifdef EAP_WSC
+	// Try to deinitiate wps interface
+	eap_wsc_deinit(&(wpa_s->wsc_data));
+#endif
 	wpa_supplicant_set_state(wpa_s, WPA_DISCONNECTED);
 	if (os_memcmp(wpa_s->bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN) != 0)
 	{
@@ -1940,6 +1961,9 @@
 			     const u8 *buf, size_t len)
 {
 	struct wpa_supplicant *wpa_s = ctx;
+	struct ieee802_1x_hdr *hdr = (struct ieee802_1x_hdr *)buf;
+	struct eap_hdr *req = (struct eap_hdr *)(hdr+1);
+	u8 *type = (u8 *)(req+1);
 
 	wpa_printf(MSG_DEBUG, "RX EAPOL from " MACSTR, MAC2STR(src_addr));
 	wpa_hexdump(MSG_MSGDUMP, "RX EAPOL", buf, len);
@@ -1978,6 +2002,34 @@
 		return;
 	wpa_drv_poll(wpa_s);
 	wpa_sm_rx_eapol(wpa_s->wpa, src_addr, buf, len);
+#ifdef EAP_WSC
+	if ((wpa_s->key_mgmt == WPA_KEY_MGMT_PSK) &&
+	    (hdr->type != IEEE802_1X_TYPE_EAPOL_KEY))
+	{
+		// Check if this is WPS packet
+		if ((hdr->type == IEEE802_1X_TYPE_EAP_PACKET) &&
+			((req->code == EAP_CODE_REQUEST) || (req->code == EAP_CODE_RESPONSE)) &&
+			(*type == EAP_TYPE_WSC))
+		{
+			//Send this packet to WPS application
+			u8 *resp;
+			size_t respDataLen;
+			WSC_NOTIFY_DATA *recvNotify;
+			
+			// The len includes 4 bytes of header - exclude them
+			resp = eap_wsc_process(wpa_s->wsc_data, (u8 *)req, (len-sizeof(hdr)), &respDataLen);
+			recvNotify = wpa_s->wsc_data->recvNotify;
+			if (resp != NULL)
+			{
+				// Send response to AP
+				wpa_supplicant_eapol_send(wpa_s,
+										IEEE802_1X_TYPE_EAP_PACKET,
+										resp, respDataLen);
+				free (resp);
+			}
+		}
+	}
+#endif
 }
 
 
@@ -2352,6 +2404,13 @@
 			return -1;
 	}
 
+#ifdef WSC_NEW_IE
+	if (wsc_ie_init(wpa_s) < 0)
+	{
+		return -1;
+	}
+#endif 
+
 	return 0;
 }
 
@@ -2376,6 +2435,11 @@
 
 	wpas_dbus_unregister_iface(wpa_s);
 
+#ifdef WSC_NEW_IE
+	if (wpa_s->drv_priv)
+		wsc_ie_deinit(wpa_s);
+#endif
+
 	wpa_supplicant_cleanup(wpa_s);
 
 	if (wpa_s->drv_priv)
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/wpa_supplicant_i.h wpa_supplicant-0.5.11/wpa_supplicant_i.h
--- wpa_supplicant-0.5.11.ORIG/wpa_supplicant_i.h	2007-12-28 02:50:15.000000000 +0200
+++ wpa_supplicant-0.5.11/wpa_supplicant_i.h	2010-06-28 10:19:12.000000000 +0300
@@ -16,6 +16,9 @@
 #define WPA_SUPPLICANT_I_H
 
 #include "driver.h"
+#ifdef EAP_WSC
+#include "eap_wsc.h"
+#endif
 
 struct wpa_blacklist {
 	struct wpa_blacklist *next;
@@ -333,6 +336,10 @@
 
 	struct wpa_blacklist *blacklist;
 
+#ifdef EAP_WSC
+	struct eap_wsc_data *wsc_data;
+#endif
+
 	int scan_req; /* manual scan request; this forces a scan even if there
 		       * are no enabled networks in the configuration */
 	int scan_res_tried; /* whether ap_scan=1 mode has tried to fetch scan
@@ -693,4 +700,80 @@
 	return -1;
 }
 
+#ifdef WSC_NEW_IE
+static inline int wpa_drv_set_wsc_probe_request_ie(
+					struct wpa_supplicant *wpa_s,
+					u8 *iebuf, int iebuflen)
+{
+	if (wpa_s->driver->set_wsc_probe_request_ie)
+		return wpa_s->driver->set_wsc_probe_request_ie(wpa_s->drv_priv,
+						 iebuf, iebuflen);
+	return -1;
+}
+
+static inline int wpa_drv_start_receive_beacons(
+					struct wpa_supplicant *wpa_s)
+{
+	if (wpa_s->driver->start_receive_beacons)
+		return wpa_s->driver->start_receive_beacons(wpa_s->drv_priv);
+	return -1;
+}
+
+static inline int wpa_drv_stop_receive_beacons(
+					struct wpa_supplicant *wpa_s)
+{
+	if (wpa_s->driver->stop_receive_beacons)
+		return wpa_s->driver->stop_receive_beacons(wpa_s->drv_priv);
+	return -1;
+}
+
+static inline int wpa_drv_init_l2_packet(
+					struct wpa_supplicant *wpa_s,
+					void (*handler)(void *ctx, const unsigned char *src_addr, 
+							const unsigned char *buf, size_t len))
+{
+	if (wpa_s->driver->init_l2_packet)
+		return wpa_s->driver->init_l2_packet(wpa_s->drv_priv, handler);
+	return -1;
+}
+
+static inline int wpa_drv_deinit_l2_packet(
+					struct wpa_supplicant *wpa_s)
+{
+	if (wpa_s->driver->deinit_l2_packet)
+		return wpa_s->driver->deinit_l2_packet(wpa_s->drv_priv);
+	return -1;
+}
+
+static inline int wpa_drv_process_frame(
+					struct wpa_supplicant *wpa_s,
+					void *ctx,
+					const unsigned char *src_addr, const unsigned char *buf, 
+					size_t len, unsigned char *newbuf, int *newlen,
+					unsigned char *frameType)
+{
+	if (wpa_s->driver->process_frame)
+		return wpa_s->driver->process_frame(wpa_s->drv_priv, ctx, src_addr, 
+							buf, len, newbuf, newlen, frameType);
+	return -1;
+}
+
+static inline int wpa_drv_start_receive_pr_resps(
+					struct wpa_supplicant *wpa_s)
+{
+	if (wpa_s->driver->start_receive_pr_resps)
+		return wpa_s->driver->start_receive_pr_resps(wpa_s->drv_priv);
+	return -1;
+}
+
+static inline int wpa_drv_stop_receive_pr_resps(
+					struct wpa_supplicant *wpa_s)
+{
+	if (wpa_s->driver->stop_receive_pr_resps)
+		return wpa_s->driver->stop_receive_pr_resps(wpa_s->drv_priv);
+	return -1;
+}
+
+#endif /*  WSC_NEW_IE */
+
 #endif /* WPA_SUPPLICANT_I_H */
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/wsc_ie.c wpa_supplicant-0.5.11/wsc_ie.c
--- wpa_supplicant-0.5.11.ORIG/wsc_ie.c	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/wsc_ie.c	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,265 @@
+/*
+ * wpa_supplicant / Wi-Fi Simple Configuration 7C Proposal
+ * Copyright (c) 2005 Intel Corporation. All rights reserved.
+ * Contact Information: Harsha Hegde  <harsha.hegde@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README, README_WSC and COPYING for more details.
+ * 
+ * $Id: wsc_ie.c 2466 2008-04-02 08:25:35Z andreit $
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <time.h>
+#include <errno.h>
+
+#include "common.h"
+#include "driver.h"
+#include "driver_wext.h"
+#include "eloop.h"
+#include "wpa_supplicant.h"
+#include "wpa.h"
+#include "wpa_supplicant_i.h"
+#include "wireless_copy.h"
+
+#include "UdpLib.h"
+#include "wsc_ie.h"
+
+// Comment out the next line if debug strings are not needed
+#define U_DEBUG
+
+void DEBUGF(char *, ...);
+
+static WSC_IE_DATA * g_wsc_ie_data;
+int g_wsc=0;
+
+
+static void wsc_ie_read_callback(int sock, void *eloop_ctx, void *sock_ctx)
+{
+    WSC_IE_DATA * data = eloop_ctx;
+    WSC_IE_COMMAND_DATA * cmdData;
+    char readBuf[WSC_WLAN_DATA_MAX_LENGTH];
+    int recvBytes;
+    struct sockaddr_in from;
+    u8 * bufPtr;
+    int retval;
+    char ssid[36];
+
+    wpa_printf(MSG_INFO, "WSC_IE: Entered wsc_ie_read_callback. "
+            "sock = %d", sock);
+
+    recvBytes = udp_read(data->udpFdCom, readBuf,
+            WSC_WLAN_DATA_MAX_LENGTH, &from);
+
+    if (recvBytes == -1)
+    {
+        wpa_printf(MSG_ERROR, "WSC_IE: Reading Command message "
+                "from upper layer failed");
+        return;
+    }
+
+    cmdData = (WSC_IE_COMMAND_DATA *) readBuf;
+
+    if (cmdData->type == WSC_IE_TYPE_SET_PROBE_REQUEST_IE)
+    {
+        wpa_printf(MSG_INFO, "WSC_IE: SET_PROBE_REQUEST_IE from upper layer");
+        bufPtr = (u8 *) &(cmdData->data[0]);
+        wpa_drv_set_wsc_probe_request_ie(data->wpa_s, bufPtr, cmdData->length);
+    }
+    else if (cmdData->type == WSC_IE_TYPE_SEND_BEACONS_UP)
+    {
+        wpa_printf(MSG_INFO, "WSC_IE: SEND_BEACONS_UP from upper layer");
+        bufPtr = (u8 *) &(cmdData->data[0]);
+        if (bufPtr[0] == 1)
+        {
+            g_wsc_ie_data->sendUp = 1;
+            wpa_printf(MSG_INFO, "WSC_IE: Activate = 1\n");
+            retval = wpa_drv_start_receive_beacons(data->wpa_s);
+            printf("\n\n*** wpa_drv_start_receive_beacons return val = %d\n\n", retval);
+        }
+        else
+        {
+            g_wsc_ie_data->sendUp = 0;
+            wpa_printf(MSG_INFO, "WSC_IE: Activate = 0\n");
+            retval = wpa_drv_stop_receive_beacons(data->wpa_s);
+        }
+    }
+    else if (cmdData->type == WSC_IE_TYPE_SEND_PR_RESPS_UP)
+    {
+        wpa_printf(MSG_INFO, "WSC_IE: SEND_PR_RESPS_UP from upper layer");
+        bufPtr = (u8 *) &(cmdData->data[0]);
+        if (bufPtr[0] == 1)
+        {
+            wpa_printf(MSG_INFO, "WSC_IE: Activate = 1\n");
+            retval = wpa_drv_start_receive_pr_resps(data->wpa_s);
+            printf("wpa_drv_start_receive_pr_resps return val = %d\n", retval);
+        }
+        else
+        {
+            wpa_printf(MSG_INFO, "WSC_IE: Activate = 0\n");
+            retval = wpa_drv_stop_receive_pr_resps(data->wpa_s);
+            printf("wpa_drv_stop_receive_pr_resps return val = %d\n", retval);
+        }
+    }
+    else if (cmdData->type == WSC_IE_TYPE_SEND_PROBE_REQUEST)
+    {
+        wpa_printf(MSG_INFO, "WSC_IE: SEND_PROBE_REQUEST from upper layer");
+        bufPtr = (u8 *) &(cmdData->data[0]);
+        strcpy(ssid, (char *) bufPtr);
+
+        wpa_printf(MSG_INFO, "WSC_IE: SSID received from up = %s\n", ssid);
+        retval = wpa_drv_scan(data->wpa_s, (const u8*)ssid, strlen(ssid));
+        printf("wpa_drv_scan return val = %d\n", retval);
+    }
+    else
+    {
+        wpa_printf(MSG_ERROR, "WSC_IE: Wrong command type from upper layer");
+        return;
+    }
+    return;
+}
+
+static void
+wsc_handle_frames(void *ctx, const unsigned char *src_addr, const unsigned char *buf, size_t len)
+{
+    u8 newbuf[256];
+    int newlen;
+    WSC_IE_COMMAND_DATA * cmdData;
+    struct sockaddr_in to;
+    u8 frameType = 0;
+
+
+    cmdData = (WSC_IE_COMMAND_DATA *) newbuf;
+    newlen = 0;
+    if (wpa_drv_process_frame(g_wsc_ie_data->wpa_s, ctx, src_addr, 
+                buf, len, newbuf + sizeof(WSC_IE_COMMAND_DATA), &newlen, 
+                &frameType) < 0)
+    {
+        wpa_printf(MSG_ERROR, "process_frame was not called or successful\n");
+        return;
+    }
+
+//    printf("Process frames done; newlen = %d, frameType = %d\n", 
+//            newlen, frameType);
+
+    if (frameType != WSC_IE_TYPE_SET_BEACON_IE &&
+        frameType != WSC_IE_TYPE_SET_PROBE_RESPONSE_IE)
+    {
+        wpa_printf(MSG_ERROR, "Not a Beacon or Probe-Response\n");
+        return;
+    }
+
+    if (newlen)
+    {
+        if (frameType == 1) {
+            if (! g_wsc_ie_data->sendUp) 
+                return;
+            /* this code causes every 50 beacon to go up
+            if ( (g_wsc_ie_data->sendCounter % 50) != 0) {
+                g_wsc_ie_data->sendCounter++;
+                return; // only send up 1 in 50 beacons
+            }*/
+            g_wsc_ie_data->sendCounter++;
+            cmdData->type = WSC_IE_TYPE_BEACON_IE_DATA;
+            wpa_printf(MSG_INFO, "\n\nWSC_IE: sending up WSC beacon\\nn");
+        }
+        else {
+            cmdData->type = WSC_IE_TYPE_PROBE_RESPONSE_IE_DATA;
+            wpa_printf(MSG_INFO, "WSC_IE: sending up WSC probe response\n");
+        }
+
+        cmdData->length = newlen;
+
+        to.sin_addr.s_addr = inet_addr(WSC_WLAN_UDP_ADDR);
+        to.sin_family = AF_INET;
+        to.sin_port = htons(WSC_WLAN_UDP_PORT);
+
+        newlen += sizeof(WSC_IE_COMMAND_DATA);
+
+        if (udp_write(g_wsc_ie_data->udpFdCom, (char *) newbuf, 
+                newlen, &to) < newlen)
+        {
+            wpa_printf(MSG_INFO, "WSC_IE: Sending Beacon Data to "
+                    "upper Layer failed");
+            return;
+        }
+
+        // printf("udp_write done\n");
+    }
+}
+
+
+int wsc_ie_init(struct wpa_supplicant *wpa_s)
+{
+    struct sockaddr_in to;
+    char sendBuf[5];
+
+    wpa_printf(MSG_INFO, "\n\n******WSC_IE: In wsc_ie_init\n\n");
+    
+    g_wsc_ie_data = malloc(sizeof(WSC_IE_DATA));
+    
+    if (g_wsc_ie_data == NULL)
+    {
+        return -1;
+    }
+
+    memset(g_wsc_ie_data, 0, sizeof(WSC_IE_DATA));
+
+    g_wsc_ie_data->wpa_s = wpa_s;
+    g_wsc_ie_data->sendUp = 0;
+    g_wsc_ie_data->sendCounter = 0;
+    g_wsc_ie_data->udpFdCom = udp_open();
+
+    eloop_register_read_sock(g_wsc_ie_data->udpFdCom, wsc_ie_read_callback,
+                 g_wsc_ie_data, NULL);
+    /* Send a start packet */
+    strcpy(sendBuf, "PORT");
+    to.sin_addr.s_addr = inet_addr(WSC_WLAN_UDP_ADDR);
+    to.sin_family = AF_INET;
+    to.sin_port = htons(WSC_WLAN_UDP_PORT);
+
+    if (udp_write(g_wsc_ie_data->udpFdCom, sendBuf, 5, &to) < 5)
+    {
+        wpa_printf(MSG_ERROR, "WSC_IE: Sending Port message to "
+                "upper Layer failed");
+        return -1;
+    }
+
+    // register to get l2_packets
+    wpa_drv_init_l2_packet(wpa_s, wsc_handle_frames);
+
+    return 0;
+}
+
+int wsc_ie_deinit(struct wpa_supplicant *wpa_s)
+{
+    wpa_drv_deinit_l2_packet(wpa_s);
+
+    if (g_wsc_ie_data->udpFdCom != -1)
+    {
+        eloop_unregister_read_sock(g_wsc_ie_data->udpFdCom);
+        udp_close(g_wsc_ie_data->udpFdCom);
+        g_wsc_ie_data->udpFdCom = -1;
+    }
+
+    g_wsc_ie_data->wpa_s = NULL;
+
+    free(g_wsc_ie_data);
+    g_wsc_ie_data = NULL;
+
+    return 0;
+}
diff -Naur -x '\.svn' wpa_supplicant-0.5.11.ORIG/wsc_ie.h wpa_supplicant-0.5.11/wsc_ie.h
--- wpa_supplicant-0.5.11.ORIG/wsc_ie.h	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant-0.5.11/wsc_ie.h	2010-06-28 10:19:12.000000000 +0300
@@ -0,0 +1,51 @@
+/* $Id: wsc_ie.h 2466 2008-04-02 08:25:35Z andreit $ */
+
+#ifndef _WSC_IE_H_
+#define _WSC_IE_H_
+
+/*#pragma pack(push, 1)*/
+
+typedef struct wsc_ie_data {
+    struct wpa_supplicant *wpa_s;
+    int udpFdCom;
+    int sendCounter;
+    int sendUp;
+}__attribute__((packed)) WSC_IE_DATA;
+
+#define WSC_WLAN_UDP_PORT       38000
+#define WSC_WLAN_UDP_ADDR       "127.0.0.1"
+
+#define WSC_WLAN_DATA_MAX_LENGTH         1024
+
+#define WSC_IE_TYPE_SET_BEACON_IE                1
+#define WSC_IE_TYPE_SET_PROBE_REQUEST_IE         2
+#define WSC_IE_TYPE_SET_PROBE_RESPONSE_IE        3
+#define WSC_IE_TYPE_BEACON_IE_DATA               4
+#define WSC_IE_TYPE_PROBE_REQUEST_IE_DATA        5
+#define WSC_IE_TYPE_PROBE_RESPONSE_IE_DATA       6
+#define WSC_IE_TYPE_SEND_BEACONS_UP              7
+#define WSC_IE_TYPE_SEND_PR_RESPS_UP             8
+#define WSC_IE_TYPE_SEND_PROBE_REQUEST           9
+#define WSC_IE_TYPE_MAX                         10
+
+typedef struct wsc_ie_command_data {
+    u8  type;
+    u32 length;
+    u8  data[0];
+}__attribute__((packed)) WSC_IE_COMMAND_DATA;
+
+typedef struct wsc_ie_beacon_data
+{
+    char ssid[32];
+    u8   macAddr[6];
+    u8   data[0];
+}__attribute__((packed)) WSC_IE_BEACON_DATA;
+
+
+int wsc_ie_init(struct wpa_supplicant *wpa_s);
+int wsc_ie_deinit(struct wpa_supplicant *wpa_s);
+ 
+/*#pragma pack(pop)*/
+
+#endif // _WSC_IE_H_
+
