diff -Naur zebra-0.94/README_RIPD_STANDALONE open_zebra/README_RIPD_STANDALONE
--- zebra-0.94/README_RIPD_STANDALONE	1970-01-01 05:30:00.000000000 +0530
+++ open_zebra/README_RIPD_STANDALONE	2009-11-13 19:47:57.140783000 +0530
@@ -0,0 +1,64 @@
+Steps:
+======
+1. configureing ripd Standalone:
+    enable option 'ripd_standalone' in the configure script
+Example:
+>./configure --target=mips-linux --host=mips-linux --build=i386-pc-linux-gnu --prefix=/usr --disable-vtysh --disable-ipv6 --enable-ripd_standalone --disable-debug_ripd_standalone --disable-bgpd --disable-ripngd --disable-ospfd --disable-ospf6d --disable-bgp-announce IFX_CFLAGS="${IFX_CFLAGS} " LDFLAGS="${IFX_LDFLAGS}"
+
+
+2. Configuring ripd.conf 
+    Keep ripd.conf in the location as specified by 
+	${prefix}/etc/ripd.conf where as prefix is the value specified
+	in the configure script
+   
+	In the above example, place the ripd.conf in dir:  /usr/etc
+3. Run ripd 
+
+Enabling debugging of ripd:
+===========================
+	Enable the option debug-ripd_standalone option in the configure script
+
+Writing configuration file for ripd
+===================================
+The configuration commands supported are:
+
+enable/config commands:
+	debug rip events
+	debug rip packet
+	debug rip packet <send|recv>
+    
+    log stdout
+	log file <FILENAME>
+	log syslog
+
+interface commands:
+	interface <IFNAME>
+	ip rip send version <1|2>
+	ip rip send version 1 2
+	ip rip send version 2 1
+	ip rip receive version <1|2>
+	ip rip receive version 1 2
+	ip rip receive version 2 1
+	ip rip authentication mode <md5|text>
+	ip rip authentication key-chain <LINE>
+	ip rip authentication string <LINE>
+	ip split-horizon
+
+rip commands:
+	network <prefix/ifname>
+	neighbor <prefix>
+	default-information originate
+	version <1|2>
+	passive-interface <IFNAME>
+	default-metric <1-16>
+	timers basic <5-2147483647> <5-2147483647> <5-2147483647>
+	route <A.B.C.D/M>
+	distance <1-255>
+	distance <1-255> <A.B.C.D/M>
+	distance <1-255> <A.B.C.D/M> <WORD>  {WORD: accesslist name}
+
+IMPORTANT NOTE:
+===============
+1)You *MUST* give only ONE SPACE between the words in configuration commands, otherwise parser would fail.
+2) Use "!" or "#"  for comments in configuration file
+

diff -Naur zebra-0.94/bgpd/Makefile.am open_zebra/bgpd/Makefile.am
--- zebra-0.94/bgpd/Makefile.am	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/bgpd/Makefile.am	2009-11-13 19:47:57.157775000 +0530
@@ -4,6 +4,9 @@
 DEFS = @DEFS@ -DSYSCONFDIR=\"$(sysconfdir)/\"
 INSTALL_SDATA=@INSTALL@ -m 600
 
+LDFLAGS = @LDFLAGS@ $(IFX_LDFLAGS)
+CFLAGS = @CFLAGS@ $(IFX_CFLAGS)
+
 noinst_LIBRARIES = libbgp.a
 sbin_PROGRAMS = bgpd
 
diff -Naur zebra-0.94/build.sh open_zebra/build.sh
--- zebra-0.94/build.sh	1970-01-01 05:30:00.000000000 +0530
+++ open_zebra/build.sh	2009-11-13 19:47:57.546775000 +0530
@@ -0,0 +1,55 @@
+#!/bin/sh
+APPS_NAME="zebra-0.94"
+if [ -e sysconfig.sh ]; then
+	. sysconfig.sh
+	. config.sh
+	. model_config.sh
+else
+	echo "Application "$APPS_NAME" not configured"
+	exit 1;
+fi
+display_info "----------------------------------------------------------------------"
+display_info "-----------------------      build zebra-0.94 ------------------------"
+display_info "----------------------------------------------------------------------"
+
+parse_args $@
+
+if [ $BUILD_CLEAN -eq 1 ]; then
+	make "$clean"
+	rm -rf autom4te.cache
+	rm -f config.cache
+	rm -f aclocal.m4
+	rm -f config.h.in
+	rm -f configure
+	rm -rf .config_ok
+	find . -name Makefile.in | xargs rm -rf
+	find . -name Makefile | xargs rm -rf
+	#165001:henryhsu:20050809:fix for build clean fail
+	[ ! $BUILD_CONFIGURE -eq 1 ] && exit 0
+	#165001
+fi
+
+if [ "$1" = "config_only" -a ! -f .config_ok -o $BUILD_CONFIGURE -eq 1 ]; then
+	find . -name Makefile.in | xargs rm -rf
+	aclocal
+	autoheader
+	autoconf
+	automake --foreign --add-missing
+	AR="$IFX_AR" AS="$IFX_AS" LD="$IFX_LD" NM="$IFX_NM" CC="$IFX_CC" BUILDCC="$IFX_HOSTCC" GCC="$IFX_CC" CXX="$IFX_CXX" CPP="$IFX_CPP" RANLIB="$IFX_RANLIB" IFX_CFLAGS="$IFX_CFLAGS" IFX_LDFLAGS="$IFX_LDFLAGS" TARGET="$TARGET" BUILD="$BUILD" HOST="$HOST" ./configure --target="$TARGET" --host="$HOST" --build="$BUILD" --prefix=/usr --disable-vtysh --disable-ipv6 --enable-ripd_standalone --disable-debug_ripd_standalone --disable-bgpd --disable-ripngd --disable-ospfd --disable-ospf6d --disable-bgp-announce --disable-bgpd --disable-ripngd --disable-ospfd --disable-ospf6d --disable-bgp-announce --disable-zebra IFX_CFLAGS="$IFX_CFLAGS" IFX_LDFLAGS="$IFX_LDFLAGS"
+	ifx_error_check $? 
+	echo -n > .config_ok
+fi
+
+if [ "$1" = "config_only" ] ;then
+	exit 0
+fi
+
+make IFX_CFLAGS="$IFX_CFLAGS -DVTY_REMOVE -DRIPD_MEMORY_FIX" IFX_LDFLAGS="$IFX_LDFLAGS" all
+ifx_error_check $? 
+
+#make install DESTDIR="$BUILD_ROOTFS_DIR"
+
+install -d "$BUILD_ROOTFS_DIR"/usr/sbin
+
+cp -f ripd/ripd "$BUILD_ROOTFS_DIR"/usr/sbin
+ifx_error_check $? 
diff -Naur zebra-0.94/configure.ac open_zebra/configure.ac
--- zebra-0.94/configure.ac	2003-11-04 23:30:40.000000000 +0530
+++ open_zebra/configure.ac	2009-11-13 19:47:57.553775000 +0530
@@ -55,6 +55,18 @@
 dnl ----------------------
 dnl Packages configuration
 dnl ----------------------
+
+dnl  ----- chandrav 
+dnl   adding ripd_standalone option
+dnl  -----
+AC_ARG_ENABLE(ripd_standalone,
+[  --enable-ripd_standalone     Turn on ripd_standalone ])
+dnl  ------ chandrav 
+dnl   Adding debug option for the ripd_standalone
+dnl  -----
+AC_ARG_ENABLE(debug_ripd_standalone,
+     [  --enable-debug_ripd_standalone  Turn on debug for ripd_standalone])
+dnl -- end chandrav
 AC_ARG_ENABLE(vtysh,
 [  --enable-vtysh,       Make integrated VTY version of zebra])
 AC_ARG_ENABLE(ipv6,
@@ -410,6 +422,51 @@
 AC_CHECK_FUNCS(getaddrinfo, [have_getaddrinfo=yes], [have_getaddrinfo=no])
 
 dnl ----------
+dnl chandrav ripd_standalone check
+dnl ----------
+dnl AC_MSG_CHECKING(whether does this OS have ripd_standalone )
+dnl if test "${enable_ripd_standalone}" = "no"; then
+dnl    AC_MSG_RESULT(disabled)
+dnl   AC_DEFINE(RIPD_STANDALONE,,RIPD_STANDALONE)
+dnl else
+dnl 	echo "i am unable to do ripd_standalone"
+dnl fi
+
+dnl ----------
+dnl chandrav   ripd_standalone test
+dnl ----------
+AC_MSG_CHECKING(whether ripd_standalone option is enabled..)
+if test "${enable_ripd_standalone}" = "yes"; then
+   AC_DEFINE(RIPD_STANDALONE,,RIPD_STANDALONE)
+   echo "Ripd Standalone is enabled.."
+else
+dnl  AC_MSG_RESULT(disabled)
+dnl  AC_DEFINE(RIPD_STANDALONE,,RIPD_STANDALONE)
+   echo "Ripd Standalone is disabled.."
+fi
+dnl ----- chandrav
+dnl conditional variable used in the ripd/Makefile.am 
+dnl ------
+AM_CONDITIONAL(CONFIGURE_RIPD_STANDALONE, test "${enable_ripd_standalone}" = "yes" )
+
+dnl ----------
+dnl chandrav   debug_ripd_standalone test
+dnl ----------
+AC_MSG_CHECKING(whether debug_ripd_standalone option is enabled..)
+if test "${enable_debug_ripd_standalone}" = "yes"; then
+   AC_DEFINE(DEBUG_RIPD_STANDALONE,,DEBUG_RIPD_STANDALONE)
+   echo "Debug Ripd-Standalone is enabled.."
+else
+dnl  AC_MSG_RESULT(disabled)
+dnl  AC_DEFINE(RIPD_STANDALONE,,RIPD_STANDALONE)
+   echo "Debug Ripd-Standalone is disabled.."
+fi
+dnl ----- chandrav
+dnl conditional variable used in the ripd/Makefile.am 
+dnl ------
+AM_CONDITIONAL(CONFIGURE_DEBUG_RIPD_STANDALONE, test "${enable_debug_ripd_standalone}" = "yes" )
+
+dnl ----------
 dnl IPv6 check
 dnl ----------
 AC_MSG_CHECKING(whether does this OS have IPv6 stack)
diff -Naur zebra-0.94/ifx_make.mk open_zebra/ifx_make.mk
--- zebra-0.94/ifx_make.mk	1970-01-01 05:30:00.000000000 +0530
+++ open_zebra/ifx_make.mk	2009-11-13 19:47:58.991631000 +0530
@@ -0,0 +1,72 @@
+include .app_configured
+
+ifeq ($(MAKE_USED),1)
+include $(INCLUDE_DIR)/Rules.mk
+include $(INCLUDE_DIR)/Makefile.common
+
+APP_NAME=zebra
+APP_TYPE=OPEN
+APP_VER=0.94-IFX
+CONFIG_FULL_PACKAGE=y
+IFX_CFLAGS	+=-DVTY_REMOVE -DRIPD_MEMORY_FIX
+
+all: configure compile install
+
+define menuconfig
+        config FEATURE_ZEBRA
+                bool 'zebra'
+                help
+		  GNU Zebra is free software that manages TCP/IP based routing protocols
+endef
+
+define configure
+        aclocal
+        autoheader
+        autoconf
+        automake --foreign --add-missing
+        $(BUILD_FLAGS) ./configure --target=$(TARGET) --host=$(HOST) \
+	--build=$(BUILD) --prefix=/usr --disable-vtysh --disable-ipv6 \
+	--enable-ripd_standalone --disable-debug_ripd_standalone \
+	--disable-bgpd --disable-ripngd --disable-ospfd --disable-ospf6d \
+	--disable-bgp-announce --disable-bgpd --disable-ripngd \
+	--disable-ospfd --disable-ospf6d --disable-bgp-announce \
+	--disable-zebra IFX_CFLAGS="$(IFX_CFLAGS)" IFX_LDFLAGS="$(IFX_LDFLAGS)"
+endef
+
+define compile
+        $(MAKE) $(BUILD_FLAGS) IFX_CFLAGS="$(IFX_CFLAGS)" IFX_LDFLAGS="$(IFX_LDFLAGS)" all
+endef
+
+define install
+        install -d $(BUILD_ROOTFS_DIR)/usr/sbin
+        cp -f ripd/ripd $(BUILD_ROOTFS_DIR)/usr/sbin
+endef
+
+define clean
+	if [ -e Makefile ];then \
+		$(MAKE) clean; \
+	fi
+endef
+
+define distlean
+	if [ -e Makefile ];then \
+		$(MAKE) distclean; \
+	fi
+        rm -rf autom4te.cache
+        rm -f config.cache
+        rm -f aclocal.m4
+        rm -f config.h.in
+        rm -f configure
+        rm -rf .config_ok
+        find . -name Makefile.in | xargs rm -rf
+        find . -name Makefile | xargs rm -rf
+endef
+
+
+$(eval $(call define_eval_application))
+else
+export MAKE_USED=1
+all %:
+	@$(MAKE) -s -C $(BUILD_TOOLS_DIR) make_installed
+	@$(BUILD_TOOLS_DIR)/tmp/bin/make -f ifx_make.mk $@
+endif
diff -Naur zebra-0.94/lib/Makefile.am open_zebra/lib/Makefile.am
--- zebra-0.94/lib/Makefile.am	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/lib/Makefile.am	2009-11-13 19:47:57.754785000 +0530
@@ -3,14 +3,34 @@
 INCLUDES = @INCLUDES@ -I.. -I$(top_srcdir) -I$(top_srcdir)/lib
 DEFS = @DEFS@ -DSYSCONFDIR=\"$(sysconfdir)/\"
 
+LDFLAGS = @LDFLAGS@ $(IFX_LDFLAGS)
+CFLAGS = @CFLAGS@ $(IFX_CFLAGS)
+
 noinst_LIBRARIES = libzebra.a
 
+#libzebra_a_SOURCES = \
+#	version.c network.c pid_output.c getopt.c getopt1.c daemon.c \
+#	print_version.c checksum.c vector.c linklist.c vty.c command.c \
+#	sockunion.c prefix.c thread.c if.c memory.c buffer.c table.c hash.c \
+#	filter.c routemap.c distribute.c stream.c str.c log.c plist.c \
+#	zclient.c sockopt.c smux.c md5.c keychain.c
+# chandrav -- for removing unneeded files for ripd_standalone
+if CONFIGURE_RIPD_STANDALONE
+libzebra_a_SOURCES = \
+	version.c network.c pid_output.c getopt.c getopt1.c daemon.c \
+	print_version.c checksum.c vector.c linklist.c \
+	sockunion.c prefix.c thread.c if.c memory.c buffer.c table.c hash.c \
+	filter.c distribute.c stream.c str.c log.c plist.c \
+	sockopt.c smux.c md5.c keychain.c
+else
 libzebra_a_SOURCES = \
 	version.c network.c pid_output.c getopt.c getopt1.c daemon.c \
 	print_version.c checksum.c vector.c linklist.c vty.c command.c \
 	sockunion.c prefix.c thread.c if.c memory.c buffer.c table.c hash.c \
 	filter.c routemap.c distribute.c stream.c str.c log.c plist.c \
 	zclient.c sockopt.c smux.c md5.c keychain.c
+endif
+
 
 libzebra_a_DEPENDENCIES = @LIB_REGEX@
 
diff -Naur zebra-0.94/lib/command.c open_zebra/lib/command.c
--- zebra-0.94/lib/command.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/lib/command.c	2009-11-13 19:47:57.768784000 +0530
@@ -2232,7 +2232,7 @@
 
   return CMD_SUCCESS;
 }
-
+#ifndef RIPD_STANDALONE
 /* Help display function for all node. */
 DEFUN (config_help,
        config_help_cmd,
@@ -2257,6 +2257,7 @@
   return CMD_SUCCESS;
 }
 
+
 /* Help display function for all node. */
 DEFUN (config_list,
        config_list_cmd,
@@ -2273,6 +2274,7 @@
 	       VTY_NEWLINE);
   return CMD_SUCCESS;
 }
+#endif
 
 /* Write current configuration into file. */
 DEFUN (config_write_file, 
@@ -2390,6 +2392,7 @@
        "write",  
        "Write running configuration to memory, network, or terminal\n");
 
+#ifndef RIPD_STANDALONE
 ALIAS (config_write_file, 
        config_write_memory_cmd,
        "write memory",  
@@ -2402,6 +2405,7 @@
        "Copy configuration\n"
        "Copy running config to... \n"
        "Copy running config to startup config (same as write file)\n");
+#endif
 
 /* Write current configuration into the terminal. */
 DEFUN (config_write_terminal,
@@ -2446,6 +2450,7 @@
        SHOW_STR
        "running configuration\n");
 
+
 /* Write startup configuration into the terminal. */
 DEFUN (show_startup_config,
        show_startup_config_cmd,
@@ -2661,7 +2666,8 @@
 
   return CMD_SUCCESS;
 }
-	
+
+#ifndef RIPD_STANDALONE
 DEFUN (service_password_encrypt,
        service_password_encrypt_cmd,
        "service password-encryption",
@@ -2772,6 +2778,8 @@
   host.lines = -1;
   return CMD_SUCCESS;
 }
+#endif
+
 
 DEFUN (config_log_stdout,
        config_log_stdout_cmd,
@@ -3027,7 +3035,7 @@
   return CMD_SUCCESS;
 }
 
-
+#ifndef RIPD_STANDALONE
 DEFUN (banner_motd_default,
        banner_motd_default_cmd,
        "banner motd default",
@@ -3049,6 +3057,8 @@
   host.motd = NULL;
   return CMD_SUCCESS;
 }
+#endif
+
 
 /* Set config filename.  Called from vty.c */
 void
@@ -3063,12 +3073,15 @@
   install_element (node, &config_exit_cmd);
   install_element (node, &config_quit_cmd);
   install_element (node, &config_end_cmd);
+  #ifndef RIPD_STANDALONE
   install_element (node, &config_help_cmd);
   install_element (node, &config_list_cmd);
-
   install_element (node, &config_write_terminal_cmd);
+  #endif
   install_element (node, &config_write_file_cmd);
+  #ifndef RIPD_STANDALONE
   install_element (node, &config_write_memory_cmd);
+  #endif
   install_element (node, &config_write_cmd);
   install_element (node, &show_running_config_cmd);
 }
@@ -3100,13 +3113,19 @@
   install_element (VIEW_NODE, &show_version_cmd);
   if (terminal)
     {
+	  #ifndef RIPD_STANDALONE		
       install_element (VIEW_NODE, &config_list_cmd);
+      #endif
       install_element (VIEW_NODE, &config_exit_cmd);
       install_element (VIEW_NODE, &config_quit_cmd);
+      #ifndef RIPD_STANDALONE
       install_element (VIEW_NODE, &config_help_cmd);
+	  #endif
       install_element (VIEW_NODE, &config_enable_cmd);
+	  #ifndef RIPD_STANDALONE
       install_element (VIEW_NODE, &config_terminal_length_cmd);
       install_element (VIEW_NODE, &config_terminal_no_length_cmd);
+	  #endif
     }
 
   if (terminal)
@@ -3114,12 +3133,16 @@
       install_default (ENABLE_NODE);
       install_element (ENABLE_NODE, &config_disable_cmd);
       install_element (ENABLE_NODE, &config_terminal_cmd);
+      #ifndef RIPD_STANDALONE
       install_element (ENABLE_NODE, &copy_runningconfig_startupconfig_cmd);
+      #endif
     }
   install_element (ENABLE_NODE, &show_startup_config_cmd);
   install_element (ENABLE_NODE, &show_version_cmd);
+  #ifndef RIPD_STANDALONE
   install_element (ENABLE_NODE, &config_terminal_length_cmd);
   install_element (ENABLE_NODE, &config_terminal_no_length_cmd);
+  #endif
 
   if (terminal)
     install_default (CONFIG_NODE);
@@ -3144,12 +3167,14 @@
       install_element (CONFIG_NODE, &no_config_log_trap_cmd);
       install_element (CONFIG_NODE, &config_log_record_priority_cmd);
       install_element (CONFIG_NODE, &no_config_log_record_priority_cmd);
+	  #ifndef RIPD_STANDALONE
       install_element (CONFIG_NODE, &service_password_encrypt_cmd);
       install_element (CONFIG_NODE, &no_service_password_encrypt_cmd);
       install_element (CONFIG_NODE, &banner_motd_default_cmd);
       install_element (CONFIG_NODE, &no_banner_motd_cmd);
       install_element (CONFIG_NODE, &service_terminal_length_cmd);
       install_element (CONFIG_NODE, &no_service_terminal_length_cmd);
+      #endif
     }
 
   srand(time(NULL));
diff -Naur zebra-0.94/lib/distribute.c open_zebra/lib/distribute.c
--- zebra-0.94/lib/distribute.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/lib/distribute.c	2009-11-13 19:47:57.776775000 +0530
@@ -298,6 +298,8 @@
   return 1;
 }
 
+#ifndef VTY_REMOVE
+
 DEFUN (distribute_list_all,
        distribute_list_all_cmd,
        "distribute-list WORD (in|out)",
@@ -760,6 +762,8 @@
   return write;
 }
 
+#endif  /* VTY_REMOVE */
+
 /* Clear all distribute list. */
 void
 distribute_list_reset ()
@@ -772,6 +776,8 @@
 distribute_list_init (int node)
 {
   disthash = hash_create (distribute_hash_make, distribute_cmp);
+  
+  #ifndef VTY_REMOVE
 
   if (node == RIP_NODE)
     {
@@ -795,4 +801,6 @@
       install_element (RIPNG_NODE, &ipv6_distribute_list_prefix_cmd);
       install_element (RIPNG_NODE, &no_ipv6_distribute_list_prefix_cmd);
     }
+  #endif   /* VTY_REMOVE */
+
 }
diff -Naur zebra-0.94/lib/filter.c open_zebra/lib/filter.c
--- zebra-0.94/lib/filter.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/lib/filter.c	2009-11-13 19:47:57.827791000 +0530
@@ -568,6 +568,8 @@
   return NULL;
 }
 
+#ifndef VTY_REMOVE
+
 int
 vty_access_list_remark_unset (struct vty *vty, afi_t afi, char *name)
 {
@@ -1878,6 +1880,8 @@
   return write;
 }
 
+#endif  /* VTY_REMOVE */
+
 /* Access-list node. */
 struct cmd_node access_node =
 {
@@ -1886,12 +1890,16 @@
   1
 };
 
+#ifndef VTY_REMOVE
+
 int
 config_write_access_ipv4 (struct vty *vty)
 {
   return config_write_access (vty, AFI_IP);
 }
 
+#endif /* VTY_REMOVE */
+
 void
 access_list_reset_ipv4 ()
 {
@@ -1925,6 +1933,8 @@
 void
 access_list_init_ipv4 ()
 {
+  #ifndef VTY_REMOVE	
+
   install_node (&access_node, config_write_access_ipv4);
 
   install_element (ENABLE_NODE, &show_ip_access_list_cmd);
@@ -1972,6 +1982,8 @@
   install_element (CONFIG_NODE, &no_access_list_all_cmd);
   install_element (CONFIG_NODE, &no_access_list_remark_cmd);
   install_element (CONFIG_NODE, &no_access_list_remark_arg_cmd);
+  #endif /* VTY_REMOVE */
+
 }
 
 #ifdef HAVE_IPV6
@@ -1981,12 +1993,14 @@
   "",
   1
 };
+#ifndef VTY_REMOVE
 
 int
 config_write_access_ipv6 (struct vty *vty)
 {
   return config_write_access (vty, AFI_IP6);
 }
+#endif /* VTY_REMOVE */
 
 void
 access_list_reset_ipv6 ()
diff -Naur zebra-0.94/lib/if.c open_zebra/lib/if.c
--- zebra-0.94/lib/if.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/lib/if.c	2009-11-13 19:47:57.844776000 +0530
@@ -19,6 +19,10 @@
  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  */
+/* 
+506212:tc.chen 2005/06/21 fix rip can not receive packet from wan side
+	       with ip over atm mode
+*/
 
 #include <zebra.h>
 
@@ -53,6 +57,12 @@
   struct interface *ifp;
 
   ifp = XMALLOC (MTYPE_IF, sizeof (struct interface));
+  #ifdef RIPD_MEMORY_FIX
+  if ( !ifp ) {
+  	return NULL;
+  }
+  #endif
+
   memset (ifp, 0, sizeof (struct interface));
   return ifp;
 }
@@ -63,13 +73,26 @@
   struct interface *ifp;
 
   ifp = if_new ();
+  #ifdef RIPD_MEMORY_FIX
+  if ( !ifp ) {
+  	return NULL;
+  }
+  #endif
   
   listnode_add (iflist, ifp);
   ifp->connected = list_new ();
   ifp->connected->del = (void (*) (void *)) connected_free;
 
+  #ifdef RIPD_MEMORY_FIX
+  if (if_master.if_new_hook) {
+    if ( ( (*if_master.if_new_hook) (ifp) ) ) {
+		return NULL;
+	}
+  }
+  #else
   if (if_master.if_new_hook)
     (*if_master.if_new_hook) (ifp);
+  #endif
 
   return ifp;
 }
@@ -258,6 +281,12 @@
   if (ifp == NULL)
     {
       ifp = if_create ();
+      #ifdef RIPD_MEMORY_FIX
+	  if ( !ifp ) {
+  		return NULL;
+	  }
+	  #endif
+
       strncpy (ifp->name, name, IFNAMSIZ);
     }
   return ifp;
@@ -288,6 +317,12 @@
 int
 if_is_pointopoint (struct interface *ifp)
 {
+  // 506212:tc.chen  start
+  //    nasX interface is ipoa/eoa interface, it is not a point to point 
+  //    interface. The interface of iopa mode is just faked as point to point.
+  if (!strncmp(ifp->name,"nas",3))
+	return 0;
+  // 506212:tc.chen  end
   return ifp->flags & IFF_POINTOPOINT;
 }
 
@@ -362,6 +397,8 @@
     if_dump (getdata (node));
 }
 
+#ifndef VTY_REMOVE  //chandrav jan11
+
 DEFUN (interface_desc, 
        interface_desc_cmd,
        "description .LINE",
@@ -424,6 +461,12 @@
   if (ifp == NULL)
     {
       ifp = if_create ();
+	  #ifdef RIPD_MEMORY_FIX
+	  if ( !ifp ) {
+  		return CMD_WARNING;
+	  }
+	  #endif
+
       strncpy (ifp->name, argv[0], INTERFACE_NAMSIZ);
     }
   vty->index = ifp;
@@ -461,6 +504,7 @@
     }
   return CMD_SUCCESS;
 }
+#endif /*VTY_REMOVE  */
 
 /* Allocate connected structure. */
 struct connected *
diff -Naur zebra-0.94/lib/keychain.c open_zebra/lib/keychain.c
--- zebra-0.94/lib/keychain.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/lib/keychain.c	2009-11-13 19:47:57.848782000 +0530
@@ -230,6 +230,8 @@
   key_free (key);
 }
 
+#ifndef VTY_REMOVE
+
 DEFUN (key_chain,
        key_chain_cmd,
        "key chain WORD",
@@ -366,6 +368,7 @@
 
   return CMD_SUCCESS;
 }
+#endif /*  VTY_REMOVE */
 
 /* Convert HH:MM:SS MON DAY YEAR to time_t value.  -1 is returned when
    given string is malformed. */
@@ -464,6 +467,7 @@
 
   return time;
 }
+#ifndef VTY_REMOVE
 
 int
 key_lifetime_set (struct vty *vty, struct key_range *krange, char *stime_str,
@@ -865,6 +869,8 @@
 				    argv[3], argv[4]);
 }
 
+#endif  /* VTY_REMOVE  */
+
 struct cmd_node keychain_node =
 {
   KEYCHAIN_NODE,
@@ -891,6 +897,7 @@
 
   return len;
 }
+#ifndef VTY_REMOVE
 
 int
 keychain_config_write (struct vty *vty)
@@ -952,12 +959,15 @@
 
   return 0;
 }
+#endif  /* VTY_REMOVE */
 
 void
 keychain_init ()
 {
   keychain_list = list_new ();
 
+  #ifndef VTY_REMOVE
+
   install_node (&keychain_node, keychain_config_write);
   install_node (&keychain_key_node, NULL);
 
@@ -998,4 +1008,6 @@
   install_element (KEYCHAIN_KEY_NODE, &send_lifetime_infinite_month_day_cmd);
   install_element (KEYCHAIN_KEY_NODE, &send_lifetime_duration_day_month_cmd);
   install_element (KEYCHAIN_KEY_NODE, &send_lifetime_duration_month_day_cmd);
+  #endif /* VTY_REMOVE  */
+
 }
diff -Naur zebra-0.94/lib/log.c open_zebra/lib/log.c
--- zebra-0.94/lib/log.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/lib/log.c	2009-11-13 19:47:57.858775000 +0530
@@ -141,8 +141,11 @@
       fflush (stderr);
     }
 
+  #ifndef VTY_REMOVE
   /* Terminal monitor. */
   vty_log (zlog_proto_names[zl->protocol], format, args[ZLOG_NOLOG_INDEX]);
+  #endif  /* VTY_REMOVE  */
+
 }
 
 void
diff -Naur zebra-0.94/lib/memory.c open_zebra/lib/memory.c
--- zebra-0.94/lib/memory.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/lib/memory.c	2009-11-13 19:47:57.868780000 +0530
@@ -232,7 +232,7 @@
   int index;
   char *format;
 };
-
+#ifndef RIPD_STANDALONE
 struct memory_list memory_list_lib[] =
 {
   { MTYPE_TMP,                "Temporary memory" },
@@ -311,6 +311,7 @@
   { MTYPE_BGP_REGEXP,             "BGP regexp" },
   { -1, NULL }
 };
+#endif
 
 struct memory_list memory_list_rip[] =
 {
@@ -323,6 +324,7 @@
   { -1, NULL }
 };
 
+#ifndef RIPD_STANDALONE
 struct memory_list memory_list_ospf[] =
 {
   { MTYPE_OSPF_TOP,           "OSPF top        " },
@@ -372,6 +374,8 @@
   { MTYPE_OSPF6_OTHER,        "OSPF6 other       " },
   { -1, NULL },
 };
+#endif
+
 
 struct memory_list memory_list_separator[] =
 {
@@ -379,6 +383,8 @@
   {-1, NULL}
 };
 
+#ifndef VTY_REMOVE
+
 void
 show_memory_vty (struct vty *vty, struct memory_list *list)
 {
@@ -390,7 +396,7 @@
     else
       vty_out (vty, "%-22s: %5ld\r\n", m->format, mstat[m->index].alloc);
 }
-
+#ifndef RIPD_STANDALONE
 DEFUN (show_memory_all,
        show_memory_all_cmd,
        "show memory all",
@@ -411,6 +417,7 @@
   return CMD_SUCCESS;
 }
 
+
 ALIAS (show_memory_all,
        show_memory_cmd,
        "show memory",
@@ -427,6 +434,7 @@
   show_memory_vty (vty, memory_list_lib);
   return CMD_SUCCESS;
 }
+#endif
 
 DEFUN (show_memory_rip,
        show_memory_rip_cmd,
@@ -439,6 +447,15 @@
   return CMD_SUCCESS;
 }
 
+#ifdef RIPD_STANDALONE
+ALIAS (show_memory_rip,
+       show_memory_cmd,
+       "show memory",
+       "Show running system information\n"
+       "Memory statistics\n");
+#endif
+
+#ifndef RIPD_STANDALONE
 DEFUN (show_memory_bgp,
        show_memory_bgp_cmd,
        "show memory bgp",
@@ -471,23 +488,38 @@
   show_memory_vty (vty, memory_list_ospf6);
   return CMD_SUCCESS;
 }
+#endif
+#endif /* VTY_REMOVE  */
 
 void
 memory_init ()
 {
+  #ifndef VTY_REMOVE
+
   install_element (VIEW_NODE, &show_memory_cmd);
+  #ifndef RIPD_STANDALONE
   install_element (VIEW_NODE, &show_memory_all_cmd);
   install_element (VIEW_NODE, &show_memory_lib_cmd);
+  #endif
   install_element (VIEW_NODE, &show_memory_rip_cmd);
+  #ifndef RIPD_STANDALONE
   install_element (VIEW_NODE, &show_memory_bgp_cmd);
   install_element (VIEW_NODE, &show_memory_ospf_cmd);
   install_element (VIEW_NODE, &show_memory_ospf6_cmd);
+  #endif
 
   install_element (ENABLE_NODE, &show_memory_cmd);
+  #ifndef RIPD_STANDALONE
   install_element (ENABLE_NODE, &show_memory_all_cmd);
   install_element (ENABLE_NODE, &show_memory_lib_cmd);
+  #endif
   install_element (ENABLE_NODE, &show_memory_rip_cmd);
+  #ifndef RIPD_STANDALONE
   install_element (ENABLE_NODE, &show_memory_bgp_cmd);
   install_element (ENABLE_NODE, &show_memory_ospf_cmd);
   install_element (ENABLE_NODE, &show_memory_ospf6_cmd);
+  #endif
+
+  #endif /* VTY_REMOVE */
+
 }
diff -Naur zebra-0.94/lib/plist.c open_zebra/lib/plist.c
--- zebra-0.94/lib/plist.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/lib/plist.c	2009-11-13 19:47:57.934762000 +0530
@@ -648,6 +648,8 @@
   return NULL;
 }
 
+#ifndef VTY_REMOVE
+
 int
 vty_invalid_prefix_range (struct vty *vty, char *prefix)
 {
@@ -902,6 +904,7 @@
 
   return CMD_SUCCESS;
 }
+#endif /*VTY_REMOVE */
 
 enum display_type
 {
@@ -912,6 +915,7 @@
   longer_display,
   first_match_display
 };
+#ifndef VTY_REMOVE
 
 void
 vty_show_prefix_entry (struct vty *vty, afi_t afi, struct prefix_list *plist,
@@ -2480,6 +2484,7 @@
   
   return write;
 }
+#endif /* VTY_REMOVE */
 
 int stream_putc (struct stream *, u_char);
 int stream_putl (struct stream *, u_int32_t);
@@ -2572,6 +2577,8 @@
     prefix_list_delete (plist);
 }
 
+#ifndef VTY_REMOVE
+
 /* return prefix count */
 int
 prefix_bgp_show_prefix_list (struct vty *vty, afi_t afi, char *name)
@@ -2610,6 +2617,8 @@
   return plist->count;
 }
 
+#endif /* VTY_REMOVE */
+
 void
 prefix_list_reset_orf ()
 {
@@ -2651,11 +2660,14 @@
   1
 };
 
+#ifndef VTY_REMOVE
+
 int
 config_write_prefix_ipv4 (struct vty *vty)
 {
   return config_write_prefix_afi (AFI_IP, vty);
 }
+#endif /* VTY_REMOVE */
 
 void
 prefix_list_reset_ipv4 ()
@@ -2692,6 +2704,8 @@
 void
 prefix_list_init_ipv4 ()
 {
+  #ifndef VTY_REMOVE
+
   install_node (&prefix_node, config_write_prefix_ipv4);
 
   install_element (CONFIG_NODE, &ip_prefix_list_cmd);
@@ -2749,6 +2763,8 @@
   install_element (ENABLE_NODE, &clear_ip_prefix_list_cmd);
   install_element (ENABLE_NODE, &clear_ip_prefix_list_name_cmd);
   install_element (ENABLE_NODE, &clear_ip_prefix_list_name_prefix_cmd);
+  #endif /* VTY_REMOVE */
+
 }
 
 #ifdef HAVE_IPV6
diff -Naur zebra-0.94/lib/version.c open_zebra/lib/version.c
--- zebra-0.94/lib/version.c	2003-11-27 05:42:05.000000000 +0530
+++ open_zebra/lib/version.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,2 +0,0 @@
-
-char *host_name = "";
diff -Naur zebra-0.94/lib/vty.c open_zebra/lib/vty.c
--- zebra-0.94/lib/vty.c	2003-11-27 05:38:49.000000000 +0530
+++ open_zebra/lib/vty.c	2009-11-13 19:47:58.013706000 +0530
@@ -2557,6 +2557,7 @@
   return CMD_SUCCESS;
 }
 
+#ifndef RIPD_STANDALONE
 DEFUN (service_advanced_vty,
        service_advanced_vty_cmd,
        "service advanced-vty",
@@ -2623,6 +2624,8 @@
 
   return CMD_SUCCESS;
 }
+#endif
+
 
 /* Display current configuration. */
 int
@@ -2789,15 +2792,19 @@
   install_node (&vty_node, vty_config_write);
 
   install_element (VIEW_NODE, &config_who_cmd);
+  #ifndef RIPD_STANDALONE
   install_element (VIEW_NODE, &show_history_cmd);
+  #endif
   install_element (ENABLE_NODE, &config_who_cmd);
   install_element (CONFIG_NODE, &line_vty_cmd);
+  #ifndef RIPD_STANDALONE
   install_element (CONFIG_NODE, &service_advanced_vty_cmd);
   install_element (CONFIG_NODE, &no_service_advanced_vty_cmd);
   install_element (CONFIG_NODE, &show_history_cmd);
   install_element (ENABLE_NODE, &terminal_monitor_cmd);
   install_element (ENABLE_NODE, &terminal_no_monitor_cmd);
   install_element (ENABLE_NODE, &show_history_cmd);
+  #endif
 
   install_default (VTY_NODE);
   install_element (VTY_NODE, &exec_timeout_min_cmd);
diff -Naur zebra-0.94/lib/vty.h open_zebra/lib/vty.h
--- zebra-0.94/lib/vty.h	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/lib/vty.h	2009-11-13 19:47:58.016699000 +0530
@@ -189,7 +189,11 @@
 void vty_reset (void);
 void vty_finish (void);
 struct vty *vty_new (void);
+
+#ifndef VTY_REMOVE
 int vty_out (struct vty *, const char *, ...) PRINTF_ATTRIBUTE(2, 3);
+#endif
+
 void vty_read_config (char *, char *, char *);
 void vty_time_print (struct vty *, int);
 void vty_serv_sock (const char *, unsigned short, char *);
diff -Naur zebra-0.94/ospf6d/Makefile.am open_zebra/ospf6d/Makefile.am
--- zebra-0.94/ospf6d/Makefile.am	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/ospf6d/Makefile.am	2009-11-13 19:47:58.043703000 +0530
@@ -4,6 +4,9 @@
 DEFS = @DEFS@ -DSYSCONFDIR=\"$(sysconfdir)/\"
 INSTALL_SDATA=@INSTALL@ -m 600
 
+LDFLAGS = @LDFLAGS@ $(IFX_LDFLAGS)
+CFLAGS = @CFLAGS@ $(IFX_CFLAGS)
+
 noinst_LIBRARIES = libospf6.a
 sbin_PROGRAMS = ospf6d
 
diff -Naur zebra-0.94/ospfd/Makefile.am open_zebra/ospfd/Makefile.am
--- zebra-0.94/ospfd/Makefile.am	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/ospfd/Makefile.am	2009-11-13 19:47:58.294697000 +0530
@@ -4,6 +4,9 @@
 DEFS = @DEFS@ $(LOCAL_OPTS) -DSYSCONFDIR=\"$(sysconfdir)/\"
 INSTALL_SDATA=@INSTALL@ -m 600
 
+LDFLAGS = @LDFLAGS@ $(IFX_LDFLAGS)
+CFLAGS = @CFLAGS@ $(IFX_CFLAGS)
+
 noinst_LIBRARIES = libospf.a
 sbin_PROGRAMS = ospfd
 
diff -Naur zebra-0.94/ripd/Makefile.am open_zebra/ripd/Makefile.am
--- zebra-0.94/ripd/Makefile.am	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/ripd/Makefile.am	2009-11-13 19:47:58.577697000 +0530
@@ -1,24 +1,62 @@
 ## Process this file with automake to produce Makefile.in.
 
 INCLUDES = @INCLUDES@ -I.. -I$(top_srcdir) -I$(top_srcdir)/lib
-DEFS = @DEFS@ -DSYSCONFDIR=\"$(sysconfdir)/\"
+## chandrav added -DMULTIPATH_NUM=@MULTIPATH_NUM@
+DEFS = @DEFS@ -DSYSCONFDIR=\"$(sysconfdir)/\" -DMULTIPATH_NUM=@MULTIPATH_NUM@
+
 INSTALL_SDATA=@INSTALL@ -m 600
 
-noinst_LIBRARIES = librip.a
+LDFLAGS = @LDFLAGS@ $(IFX_LDFLAGS)
+CFLAGS = @CFLAGS@ $(IFX_CFLAGS)
+
+if CONFIGURE_RIPD_STANDALONE
+noinst_LIBRARIES = librip.a libkernelcomm.a
+else
+noinst_LIBRARIES = librip.a 
+endif
+
 sbin_PROGRAMS = ripd
 
+if CONFIGURE_RIPD_STANDALONE
+if  CONFIGURE_DEBUG_RIPD_STANDALONE
 librip_a_SOURCES = \
 	ripd.c rip_zebra.c rip_interface.c rip_debug.c rip_snmp.c \
-	rip_routemap.c rip_peer.c rip_offset.c
+	rip_peer.c rip_communication.c rip_read_config.c rip_parser.c
 
 noinst_HEADERS = \
-	ripd.h rip_debug.h
+	ripd.h rip_debug.h rip_read_config.h
+libkernelcomm_a_SOURCES = \
+		../zebra/if_netlink.c ../zebra/rtread_netlink.c ../zebra/if_proc.c  ../zebra/debug.c ../zebra/ioctl.c ../zebra/interface.c ../zebra/rt_netlink.c ../zebra/connected.c 
+ripd_LDADD = ./libkernelcomm.a ../lib/libzebra.a
 
-ripd_SOURCES = \
-	rip_main.c $(librip_a_SOURCES)
+else
+librip_a_SOURCES = \
+	ripd.c rip_zebra.c rip_interface.c rip_snmp.c \
+	rip_peer.c rip_communication.c rip_read_config.c rip_parser.c
+
+noinst_HEADERS = \
+	ripd.h rip_read_config.h
+libkernelcomm_a_SOURCES = \
+		../zebra/if_netlink.c ../zebra/rtread_netlink.c ../zebra/if_proc.c  ../zebra/ioctl.c ../zebra/interface.c ../zebra/rt_netlink.c ../zebra/connected.c
+ripd_LDADD = ./libkernelcomm.a ../lib/libzebra.a
+endif
+
+else
+librip_a_SOURCES = \
+	ripd.c rip_zebra.c rip_interface.c rip_debug.c rip_snmp.c \
+	rip_routemap.c rip_peer.c rip_offset.c 
+
+noinst_HEADERS = \
+	ripd.h rip_debug.h 
 
 ripd_LDADD = ../lib/libzebra.a
 
+endif
+
+ripd_SOURCES = \
+	rip_main.c $(librip_a_SOURCES) 
+
+
 sysconf_DATA = ripd.conf.sample
 
 EXTRA_DIST = $(sysconf_DATA) RIPv2-MIB.txt
diff -Naur zebra-0.94/ripd/rip_communication.c open_zebra/ripd/rip_communication.c
--- zebra-0.94/ripd/rip_communication.c	1970-01-01 05:30:00.000000000 +0530
+++ open_zebra/ripd/rip_communication.c	2009-11-13 19:47:58.582697000 +0530
@@ -0,0 +1,264 @@
+#include <stdio.h>
+
+#include <zebra.h>
+
+#include "vector.h"
+#include "vty.h"
+#include "command.h"
+#include "prefix.h"
+#include "table.h"
+#include "stream.h"
+#include "linklist.h"
+#include "log.h"
+#include "if.h"
+#include "ripd.h"
+#include "ripd/rip_debug.h"
+
+/* XXX: check if this is needed and why */
+/* Default rtm_table for all clients */
+int rtm_table_default = 0;
+
+void rip_enable_apply (struct interface *);
+void rip_passive_interface_apply (struct interface *);
+int rip_if_down(struct interface *ifp);
+
+int
+zebra_check_addr (struct prefix *p)
+{
+  if (p->family == AF_INET)
+     {
+        u_int32_t addr;
+        addr = p->u.prefix4.s_addr;
+        addr = ntohl (addr);
+        if (IPV4_NET127 (addr) || IN_CLASSD (addr))
+        return 0;
+     }
+  return 1;
+}
+
+
+/* Interface down information. */
+void
+zebra_interface_down_update (struct interface *ifp)
+{
+	#ifdef DEBUG_RIPD_STANDALONE
+	 if (IS_RIP_DEBUG_EVENT)
+	    zlog_info("RIPDS:interface is DOWN now :%s ",ifp->name);
+	#endif
+	 /* Lookup this by interface index. */
+    if( !if_lookup_by_name (ifp->name) ) {
+       return;
+	}
+
+    rip_if_down(ifp);
+}
+
+/* Interface up information. */
+void
+zebra_interface_up_update (struct interface *ifp)
+{
+  	#ifdef DEBUG_RIPD_STANDALONE
+	 if (IS_RIP_DEBUG_EVENT)
+  		zlog_info("RIPDS:interface %s is UP now ",ifp->name);
+
+	#endif
+
+  
+  if ( !if_lookup_by_name (ifp->name) ) {
+
+     /* If such interface does not exist, indicate an error */
+     return;
+  }
+
+  rip_enable_apply (ifp);
+ 
+  /* Check for a passive interface */
+  rip_passive_interface_apply (ifp);
+
+  /* Apply distribute list to the all interface. */
+  rip_distribute_update_interface (ifp);
+
+}
+
+
+/* Interface information update. */
+void
+zebra_interface_add_update (struct interface *ifp)
+{
+	struct interface *ifpnew;
+	
+    
+	#ifdef DEBUG_RIPD_STANDALONE
+	 if (IS_RIP_DEBUG_EVENT)
+		zlog_info("RIPDS:Interface %s is Added ",ifp->name);
+	#endif
+
+    /* If such interface does not exist, make new one. */
+    if ( !if_lookup_by_name(ifp->name) ) {
+          ifpnew = if_create ();
+	      strncpy (ifpnew->name, ifp->name, IFNAMSIZ);
+          memcpy(ifpnew,ifp,sizeof(*ifp));
+		
+		  rip_enable_apply (ifp);
+    	  /* Apply distribute list to the all interface. */
+   	 	  rip_distribute_update_interface (ifp);
+		  return ;
+	}
+
+	rip_enable_apply (ifp);
+    /* Apply distribute list to the all interface. */
+    rip_distribute_update_interface (ifp);
+
+}
+
+void
+zebra_interface_delete_update (struct interface *ifp)
+{
+   	#ifdef DEBUG_RIPD_STANDALONE
+	 if (IS_RIP_DEBUG_EVENT)
+    	zlog_info("RIPDS:Interface %s is Deleted ",ifp->name);
+	#endif
+
+	if ( !if_lookup_by_name (ifp->name) ) {
+     	/* If such interface does not exist, indicate an error */
+     	return;
+    }
+
+    if (if_is_up (ifp)) {
+        rip_if_down(ifp);
+    } 
+
+
+}
+
+/* Interface address addition. */
+void
+zebra_interface_address_add_update (struct interface *ifp,
+                    struct connected *ifc)
+{
+    struct prefix *p;
+
+	#ifdef DEBUG_RIPD_STANDALONE
+	 if (IS_RIP_DEBUG_EVENT)
+		zlog_info("RIPDS:Interface address is added for if:%s ",ifp->name);
+	#endif
+
+	if ( !if_lookup_by_index(ifp->ifindex) ) {
+     	/* If such interface does not exist, indicate an error */
+     	return ;
+    }
+
+	if (ifc == NULL) {
+        return ;
+	}
+  	/* Add connected address to the interface. */
+    listnode_add (ifp->connected, ifc);
+
+    p = ifc->address;
+    if (p->family == AF_INET) {
+      /* Check is this interface is RIP enabled or not.*/
+      rip_enable_apply (ifc->ifp);
+	  #ifdef HAVE_SNMP
+      rip_ifaddr_add (ifc->ifp, ifc);
+      #endif /* HAVE_SNMP */
+	}
+
+}
+
+/* Interface address deletion. */
+void
+zebra_interface_address_delete_update (struct interface *ifp,
+                       struct connected *ifc)
+{
+    struct prefix *p;
+    struct connected *temp;
+
+	if ( !if_lookup_by_index(ifp->ifindex) ) {
+     	/* If such interface does not exist, indicate an error */
+     	return;
+    }
+
+	p = ifc->address;
+
+	temp = connected_delete_by_prefix (ifp, p);
+
+   	#ifdef DEBUG_RIPD_STANDALONE
+	 if (IS_RIP_DEBUG_EVENT)
+		zlog_info("RIPDS:Interface address is Deleted for if:%s ",ifp->name);
+	#endif
+ 
+	if (temp) {
+       if (p->family == AF_INET) {
+	      /* Check if this interface is RIP enabled or not.*/
+	      rip_enable_apply (ifc->ifp);
+	   }
+	   #ifdef HAVE_SNMP
+	   rip_ifaddr_delete (ifc->ifp, ifc);
+       #endif /* HAVE_SNMP */
+
+	   /*
+		*  chandrav ppp crash bug fix
+		*  Commented the below line of code to fix problem 
+		*  of ripd crashing upon creation of ppp interface 
+	    */
+	   #if 0
+       connected_free (ifc);
+	   #endif
+
+    }
+
+}
+
+
+int
+rib_add_ipv4 (int type, int flags, struct prefix_ipv4 *p,
+          struct in_addr *gate, unsigned int ifindex, u_int32_t vrf_id,
+		            u_int32_t metric, u_char distance)
+{ 
+	#ifdef DEBUG_RIPD_STANDALONE
+	 if (IS_RIP_DEBUG_EVENT)
+		zlog_info("RIPDS:rib_add_ipv4 is called");
+	#endif
+
+    /* Make it sure prefixlen is applied to the prefix. */
+    apply_mask_ipv4 (p);
+
+	rip_redistribute_add (type,RIP_ROUTE_REDISTRIBUTE, p, ifindex, gate);
+	return 0;
+}
+
+
+int
+rib_delete_ipv4 (int type, int flags, struct prefix_ipv4 *p,
+         struct in_addr *gate, unsigned int ifindex, u_int32_t vrf_id)
+{
+	#ifdef DEBUG_RIPD_STANDALONE
+	 if (IS_RIP_DEBUG_EVENT)
+		zlog_info("RIPDS:rib_delete_ipv4 is called ");
+	#endif
+
+    /* Apply mask. */
+    apply_mask_ipv4 (p);
+
+    rip_redistribute_delete (type,RIP_ROUTE_REDISTRIBUTE, p, ifindex);
+	return 0;
+}
+
+#ifdef HAVE_IPV6
+int
+rib_add_ipv6 (int type, int flags, struct prefix_ipv6 *p,
+          struct in_addr *gate, unsigned int ifindex, u_int32_t vrf_id,
+		            u_int32_t metric, u_char distance)
+{ 
+	return 0;
+}
+
+
+int
+rib_delete_ipv6 (int type, int flags, struct prefix_ipv6 *p,
+         struct in_addr *gate, unsigned int ifindex, u_int32_t vrf_id)
+{
+	return 0;
+}
+#endif
+
diff -Naur zebra-0.94/ripd/rip_debug.c open_zebra/ripd/rip_debug.c
--- zebra-0.94/ripd/rip_debug.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/ripd/rip_debug.c	2009-11-13 19:47:58.584698000 +0530
@@ -23,11 +23,18 @@
 #include "command.h"
 #include "ripd/rip_debug.h"
 
+#if defined(RIPD_STANDALONE) && defined(DEBUG_RIPD_STANDALONE)
+#include "zebra/debug.h"
+#endif
+
+
 /* For debug statement. */
 unsigned long rip_debug_event = 0;
 unsigned long rip_debug_packet = 0;
 unsigned long rip_debug_zebra = 0;
 
+#ifndef VTY_REMOVE
+
 DEFUN (debug_rip_events,
        debug_rip_events_cmd,
        "debug rip events",
@@ -36,6 +43,10 @@
        "RIP events\n")
 {
   rip_debug_event = RIP_DEBUG_EVENT;
+  #if defined(RIPD_STANDALONE) && defined(DEBUG_RIPD_STANDALONE)
+  zebra_debug_kernel = ZEBRA_DEBUG_KERNEL;
+  #endif
+  
   return CMD_WARNING;
 }
 
@@ -88,7 +99,9 @@
   rip_debug_packet |= RIP_DEBUG_DETAIL;
   return CMD_SUCCESS;
 }
+#endif /* VTY_REMOVE */
 
+#ifndef RIPD_STANDALONE
 DEFUN (debug_rip_zebra,
        debug_rip_zebra_cmd,
        "debug rip zebra",
@@ -99,6 +112,9 @@
   rip_debug_zebra = RIP_DEBUG_ZEBRA;
   return CMD_WARNING;
 }
+#endif
+
+#ifndef VTY_REMOVE
 
 DEFUN (no_debug_rip_events,
        no_debug_rip_events_cmd,
@@ -109,6 +125,10 @@
        "RIP events\n")
 {
   rip_debug_event = 0;
+  #if defined(RIPD_STANDALONE) && defined(DEBUG_RIPD_STANDALONE)
+  zebra_debug_kernel =0;
+  #endif
+
   return CMD_SUCCESS;
 }
 
@@ -150,7 +170,9 @@
     }
   return CMD_SUCCESS;
 }
+#endif /* VTY_REMOVE */
 
+#ifndef RIPD_STANDALONE
 DEFUN (no_debug_rip_zebra,
        no_debug_rip_zebra_cmd,
        "no debug rip zebra",
@@ -162,6 +184,9 @@
   rip_debug_zebra = 0;
   return CMD_WARNING;
 }
+#endif
+
+#ifndef VTY_REMOVE
 
 DEFUN (show_debugging_rip,
        show_debugging_rip_cmd,
@@ -201,6 +226,12 @@
 
   return CMD_SUCCESS;
 }
+#endif /* VTY_REMOVE */
+
+#ifdef RIPD_STANDALONE
+#define debug_node rip_debug_node
+#endif
+
 
 /* Debug node. */
 struct cmd_node debug_node =
@@ -210,6 +241,12 @@
     1
   };
 
+#ifdef RIPD_STANDALONE
+#define config_write_debug rip_config_write_debug
+#endif
+
+#ifndef VTY_REMOVE
+
 int
 config_write_debug (struct vty *vty)
 {
@@ -249,6 +286,7 @@
     }
   return write;
 }
+#endif /* VTY_REMOVE */
 
 void
 rip_debug_reset ()
@@ -264,6 +302,8 @@
   rip_debug_event = 0;
   rip_debug_packet = 0;
   rip_debug_zebra = 0;
+  
+  #ifndef VTY_REMOVE
 
   install_node (&debug_node, config_write_debug);
 
@@ -271,21 +311,32 @@
   install_element (ENABLE_NODE, &debug_rip_packet_cmd);
   install_element (ENABLE_NODE, &debug_rip_packet_direct_cmd);
   install_element (ENABLE_NODE, &debug_rip_packet_detail_cmd);
+  #ifndef RIPD_STANDALONE
   install_element (ENABLE_NODE, &debug_rip_zebra_cmd);
+  #endif
   install_element (ENABLE_NODE, &no_debug_rip_events_cmd);
   install_element (ENABLE_NODE, &no_debug_rip_packet_cmd);
   install_element (ENABLE_NODE, &no_debug_rip_packet_direct_cmd);
+  #ifndef RIPD_STANDALONE
   install_element (ENABLE_NODE, &no_debug_rip_zebra_cmd);
+  #endif
 
   install_element (CONFIG_NODE, &debug_rip_events_cmd);
   install_element (CONFIG_NODE, &debug_rip_packet_cmd);
   install_element (CONFIG_NODE, &debug_rip_packet_direct_cmd);
   install_element (CONFIG_NODE, &debug_rip_packet_detail_cmd);
+  #ifndef RIPD_STANDALONE
   install_element (CONFIG_NODE, &debug_rip_zebra_cmd);
+  #endif
   install_element (CONFIG_NODE, &no_debug_rip_events_cmd);
   install_element (CONFIG_NODE, &no_debug_rip_packet_cmd);
   install_element (CONFIG_NODE, &no_debug_rip_packet_direct_cmd);
+  #ifndef RIPD_STANDALONE
   install_element (CONFIG_NODE, &no_debug_rip_zebra_cmd);
+  #endif
 
   install_element (ENABLE_NODE, &show_debugging_rip_cmd);
+
+  #endif /* VTY_REMOVE */
+
 }
diff -Naur zebra-0.94/ripd/rip_interface.c open_zebra/ripd/rip_interface.c
--- zebra-0.94/ripd/rip_interface.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/ripd/rip_interface.c	2009-11-13 19:47:58.589710000 +0530
@@ -111,6 +111,12 @@
   struct rip_interface *ri;
 
   ri = XMALLOC (MTYPE_RIP_INTERFACE, sizeof (struct rip_interface));
+  #ifdef RIPD_MEMORY_FIX
+  if (!ri) {
+  	return NULL;
+  }
+  #endif
+
   memset (ri, 0, sizeof (struct rip_interface));
 
   /* Default authentication type is simple password for Cisco
@@ -196,9 +202,10 @@
   /* RIPv2 support multicast. */
   if (version == RIPv2 && if_is_multicast (ifp))
     {
-      
+    #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
       if (IS_RIP_DEBUG_EVENT)
 	zlog_info ("multicast request on %s", ifp->name);
+	#endif
 
       rip_request_send (NULL, ifp, version);
       return;
@@ -208,9 +215,10 @@
   if (if_is_pointopoint (ifp) || if_is_broadcast (ifp))
     {
       listnode cnode;
-
+	#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
       if (IS_RIP_DEBUG_EVENT)
 	zlog_info ("broadcast request to %s", ifp->name);
+	#endif
 
       for (cnode = listhead (ifp->connected); cnode; nextnode (cnode))
 	{
@@ -295,9 +303,10 @@
 
   if (! rip)
     return;
-
+  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
   if (IS_RIP_DEBUG_EVENT)
     zlog_info ("request to the all neighbor");
+  #endif
 
   /* Send request to all neighbor. */
   for (rp = route_top (rip->neighbor); rp; rp = route_next (rp))
@@ -313,8 +322,10 @@
 
   if (if_is_up (ifp) && if_is_multicast (ifp))
     {
+		#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
       if (IS_RIP_DEBUG_EVENT)
 	zlog_info ("multicast join at %s", ifp->name);
+		#endif
 
       for (cnode = listhead (ifp->connected); cnode; nextnode (cnode))
 	{
@@ -346,8 +357,10 @@
 
   if (if_is_up (ifp) && if_is_multicast (ifp))
     {
+		#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
       if (IS_RIP_DEBUG_EVENT)
 	zlog_info ("multicast leave from %s", ifp->name);
+		#endif
 
       for (cnode = listhead (ifp->connected); cnode; nextnode (cnode))
 	{
@@ -492,6 +505,7 @@
   return 0;
 }
 
+#ifndef RIPD_STANDALONE
 /* Inteface link down message processing. */
 int
 rip_interface_down (int command, struct zclient *zclient, zebra_size_t length)
@@ -509,10 +523,11 @@
     return 0;
 
   rip_if_down(ifp);
- 
+	#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
   if (IS_RIP_DEBUG_ZEBRA)
     zlog_info ("interface %s index %d flags %ld metric %d mtu %d is down",
 	       ifp->name, ifp->ifindex, ifp->flags, ifp->metric, ifp->mtu);
+	#endif
 
   return 0;
 }
@@ -529,11 +544,11 @@
 
   if (ifp == NULL)
     return 0;
-
+	#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
   if (IS_RIP_DEBUG_ZEBRA)
     zlog_info ("interface %s index %d flags %ld metric %d mtu %d is up",
 	       ifp->name, ifp->ifindex, ifp->flags, ifp->metric, ifp->mtu);
-
+	#endif
   /* Check if this interface is RIP enabled or not.*/
   rip_enable_apply (ifp);
  
@@ -553,10 +568,11 @@
   struct interface *ifp;
 
   ifp = zebra_interface_add_read (zclient->ibuf);
-
+	#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
   if (IS_RIP_DEBUG_ZEBRA)
     zlog_info ("interface add %s index %d flags %ld metric %d mtu %d",
 	       ifp->name, ifp->ifindex, ifp->flags, ifp->metric, ifp->mtu);
+	#endif
 
   /* Check if this interface is RIP enabled or not.*/
   rip_enable_apply (ifp);
@@ -596,6 +612,7 @@
 
   return 0;
 }
+#endif
 
 void
 rip_interface_clean ()
@@ -718,8 +735,10 @@
   
   if (ri->running)
    {
+	   #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
      if (IS_RIP_DEBUG_EVENT)
        zlog_info ("turn off %s", ifp->name);
+		#endif
 
      /* Leave from multicast group. */
      rip_multicast_leave (ifp, rip->sock);
@@ -744,6 +763,7 @@
     }
 }
 
+#ifndef RIPD_STANDALONE
 int
 rip_interface_address_add (int command, struct zclient *zclient,
 			   zebra_size_t length)
@@ -760,9 +780,11 @@
 
   if (p->family == AF_INET)
     {
+		#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
       if (IS_RIP_DEBUG_ZEBRA)
 	zlog_info ("connected address %s/%d is added", 
 		   inet_ntoa (p->u.prefix4), p->prefixlen);
+		#endif
       
       /* Check is this interface is RIP enabled or not.*/
       rip_enable_apply (ifc->ifp);
@@ -789,10 +811,12 @@
       p = ifc->address;
       if (p->family == AF_INET)
 	{
+		#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 	  if (IS_RIP_DEBUG_ZEBRA)
 
 	    zlog_info ("connected address %s/%d is deleted",
 		       inet_ntoa (p->u.prefix4), p->prefixlen);
+		#endif
 
 #ifdef HAVE_SNMP
 	  rip_ifaddr_delete (ifc->ifp, ifc);
@@ -808,6 +832,8 @@
 
   return 0;
 }
+#endif
+
 
 /* Check interface is enabled by network statement. */
 int
@@ -990,7 +1016,9 @@
 	  {
 	    rip_redistribute_delete (ZEBRA_ROUTE_CONNECT, RIP_ROUTE_INTERFACE,
 				     &address, connected->ifp->ifindex);
-	    if (rip_redistribute_check (ZEBRA_ROUTE_CONNECT))
+	    #ifndef RIPD_STANDALONE
+		if (rip_redistribute_check (ZEBRA_ROUTE_CONNECT))
+        #endif		
 	      rip_redistribute_add (ZEBRA_ROUTE_CONNECT, RIP_ROUTE_REDISTRIBUTE,
 				    &address, connected->ifp->ifindex, NULL);
 	  }
@@ -1041,8 +1069,10 @@
     {
       if (! ri->running)
 	{
+		#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 	  if (IS_RIP_DEBUG_EVENT)
 	    zlog_info ("turn on %s", ifp->name);
+		#endif
 
 	  /* Add interface wake up thread. */
 	  if (! ri->t_wakeup)
@@ -1055,8 +1085,10 @@
     {
       if (ri->running)
 	{
+		#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 	  if (IS_RIP_DEBUG_EVENT)
 	    zlog_info ("turn off %s", ifp->name);
+		#endif
 
 	  /* Might as well clean up the route table as well */ 
 	  rip_if_down(ifp);
@@ -1256,6 +1288,9 @@
   rip_passive_interface_apply_all ();
 }
 
+
+#ifndef VTY_REMOVE
+
 /* RIP enable network or interface configuration. */
 DEFUN (rip_network,
        rip_network_cmd,
@@ -1917,6 +1952,11 @@
   return 0;
 }
 
+#endif /* VTY_REMOVE */
+
+#ifdef RIPD_STANDALONE
+#define interface_node rip_interface_node
+#endif
 struct cmd_node interface_node =
 {
   INTERFACE_NODE,
@@ -1928,7 +1968,13 @@
 int
 rip_interface_new_hook (struct interface *ifp)
 {
+  #ifdef RIPD_MEMORY_FIX
+  if (  !(ifp->info = rip_interface_new () ) ) {
+  	return 1;
+  }
+  #else
   ifp->info = rip_interface_new ();
+  #endif
   return 0;
 }
 
@@ -1956,6 +2002,8 @@
   /* RIP passive interface. */
   Vrip_passive_interface = vector_init (1);
 
+  #ifndef VTY_REMOVE
+
   /* Install interface node. */
   install_node (&interface_node, rip_interface_config_write);
 
@@ -1998,4 +2046,6 @@
 
   install_element (INTERFACE_NODE, &rip_split_horizon_cmd);
   install_element (INTERFACE_NODE, &no_rip_split_horizon_cmd);
+  #endif  /* VTY_REMOVE */
+
 }
diff -Naur zebra-0.94/ripd/rip_main.c open_zebra/ripd/rip_main.c
--- zebra-0.94/ripd/rip_main.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/ripd/rip_main.c	2009-11-13 19:47:58.591709000 +0530
@@ -33,6 +33,14 @@
 
 #include "ripd/ripd.h"
 
+#ifdef VTY_REMOVE
+
+#include "rip_debug.h"
+#include "zebra/debug.h"
+
+#endif /*  VTY_REMOVE */
+
+
 /* ripd options. */
 static struct option longopts[] = 
 {
@@ -69,6 +77,19 @@
 /* Process ID saved for use by init system */
 char *pid_file = PATH_RIPD_PID;
 
+
+#ifdef RIPD_STANDALONE
+/* function prototypes for kernel inits */
+void kernel_init ();
+void route_read ();
+void interface_list ();
+#endif
+
+//#ifdef DEBUG_RIPD_STANDALONE
+//void zebra_debug_init ();
+//#endif
+
+
 /* Help information display. */
 static void
 usage (char *progname, int status)
@@ -126,11 +147,17 @@
   rip_reset ();
   zlog_info ("ripd restarting!");
 
+  #ifndef VTY_REMOVE
+
   /* Reload config file. */
   vty_read_config (config_file, config_current, config_default);
 
   /* Create VTY's socket */
   vty_serv_sock (vty_addr, vty_port, RIP_VTYSH_PATH);
+  
+  #else
+  rip_read_config(config_file, config_current, config_default);
+  #endif /* VTY_REMOVE */
 
   /* Try to return to normal operation. */
 }
@@ -234,22 +261,52 @@
 
   /* Library initialization. */
   signal_init ();
+
+  #ifndef VTY_REMOVE
   cmd_init (1);
   vty_init ();
+  #endif /*VTY_REMOVE */
+
   memory_init ();
   keychain_init ();
-
   /* RIP related initialization. */
   rip_init ();
   rip_if_init ();
+
+  #ifdef RIPD_STANDALONE
+  if (! rip) {
+      if (rip_create () < 0) {
+		printf("unable to create rip");fflush(stdout);
+	  }
+  }
+  #endif
+
+  #ifndef RIPD_STANDALONE
   rip_zclient_init ();
-  rip_peer_init ();
+  #endif
 
+  #ifdef RIPD_STANDALONE
+  kernel_init();
+  interface_list();
+  route_read();
+  #endif
+  
+  //#ifdef RIPD_STANDALONE
+  //zebra_debug_init();
+  //#endif
+  
+  rip_peer_init ();
+  
+  #ifndef VTY_REMOVE
   /* Sort all installed commands. */
   sort_node ();
 
   /* Get configuration file. */
   vty_read_config (config_file, config_current, config_default);
+  #else
+  rip_read_config(config_file, config_current, config_default);
+  #endif /* VTY_REMOVE */
+
 
   /* Change to the daemon program. */
   if (daemon_mode)
@@ -258,8 +315,11 @@
   /* Pid file create. */
   pid_output (pid_file);
 
+  #ifndef VTY_REMOVE
   /* Create VTY's socket */
   vty_serv_sock (vty_addr, vty_port, RIP_VTYSH_PATH);
+  #endif /* VTY_REMOVE */
+
 
   /* Execute each thread. */
   while (thread_fetch (master, &thread))
diff -Naur zebra-0.94/ripd/rip_parser.c open_zebra/ripd/rip_parser.c
--- zebra-0.94/ripd/rip_parser.c	1970-01-01 05:30:00.000000000 +0530
+++ open_zebra/ripd/rip_parser.c	2009-11-13 19:47:58.596709000 +0530
@@ -0,0 +1,248 @@
+#ifdef VTY_REMOVE
+#include "rip_read_config.h"
+
+#define CONFIG_MODE		 	0
+#define INTERFACE_MODE 		1
+#define RIP_MODE 			2
+
+#ifdef DEBUG_RIPD_STANDALONE	
+#define CONFIG_CMDS_LEN 		5
+#else
+#define CONFIG_CMDS_LEN			3
+#endif
+
+#define INTERFACE_CMDS_LEN  	10
+#define RIP_CMDS_LEN			10
+
+typedef struct command_element_t  {
+		char *cmd_string;
+		int (*func) (struct interface *,int, char **);
+}command_element;
+
+int command_mode = CONFIG_MODE;
+struct interface *cmd_current_interface = NULL;
+
+char cmd_type[2][12] = {
+				{"interface"},
+				{"router rip"}
+			 };
+command_element		cmd_config[] = { 
+				#ifdef DEBUG_RIPD_STANDALONE	
+				{"debug rip events",debug_rip_events},
+				{"debug rip packet",debug_rip_packet},
+				#endif
+				{"log stdout",config_log_stdout},
+				{"log file",config_log_file},
+				{"log syslog",config_log_syslog}
+		  	 }; 
+command_element		cmd_interface[] = { 
+	            {"interface",rip_interface},
+				{"ip rip send version 1 2",ip_rip_send_version_1 },
+				{"ip rip send version 2 1",ip_rip_send_version_2},
+				{"ip rip send version",ip_rip_send_version},
+				{"ip rip receive version 1 2",ip_rip_receive_version_1},
+				{"ip rip receive version 2 1",ip_rip_receive_version_2},
+				{"ip rip receive version",ip_rip_receive_version},
+				{"ip rip authentication mode",ip_rip_authentication_mode},
+				{"ip rip authentication key-chain",ip_rip_authentication_key_chain},
+				{"ip rip authentication string",ip_rip_authentication_string }
+					 				
+			 };	
+
+command_element		cmd_rip[] = {
+				{"network", rip_network},
+				{"neighbor",rip_neighbor},
+				{"default-information originate",rip_default_information_originate},
+				{"version",rip_version},
+				{"passive-interface",rip_passive_interface},
+				{"default-metric",rip_default_metric},
+				{"timers basic",rip_timers},
+				{"route",rip_route},
+				{"distance",rip_distance},
+				{"ip split-horizon",rip_split_horizon}
+							
+			 };
+char* remove_spaces(char *cp) {
+
+    if (cp == NULL) {
+	    return NULL;
+	}
+    while (( isspace ((int) *cp) || *cp =='\r' || *cp == '\t') 
+					&& *cp != '\0') {
+    	cp++;
+	}
+	 /* Return if there is only white spaces */
+	if (*cp == '\0') {
+    	return NULL;
+	}
+
+	if (*cp == '!' || *cp == '#') {
+    	return NULL;
+	}
+
+	while( ( isspace(cp[strlen(cp)-1]) ) || 
+			( cp[strlen(cp)-1] == '\n' ) ||
+			( cp[strlen(cp)-1] == '\r' ) ) {
+		cp[strlen(cp)-1] = '\0';
+	}
+
+	return cp;
+	
+}
+int execute_cmd(char *buf,command_element *cmd ) {
+   	
+   	int argc =0;
+   	char *argv[CMD_ARGC_MAX];
+   	char *temp;
+   	int i =0;
+    
+    if ( buf == NULL || cmd== NULL ) {
+		return 1;
+	}
+		
+  if ( strcmp(buf,cmd->cmd_string) ) {	
+	buf = buf + strlen(cmd->cmd_string)+1;
+	strcpy(buf,remove_spaces(buf) );
+
+   	if ( (temp = strtok(buf," ") ) ) {
+		if ( !temp  ) {
+			argc =0;
+			argv[i] = NULL;
+			goto execute;
+		}
+		argv[i]= malloc(strlen(temp)+1);
+		if ( !argv[i] ) return -1;
+		strcpy(argv[i],temp);
+		argc++;
+   	}
+	while( ( temp = strtok(NULL," ") ) ) {
+		i++;
+		argv[i]= malloc(strlen(temp)+1);
+		if ( !argv[i] ) return -1;
+		strcpy(argv[i],temp);
+		argc++;		
+    }
+  } else {
+  	argc = 0;
+	argv[0]=NULL;
+  }	  
+execute: 
+	      	  if ( cmd->func )
+		          (cmd->func)(cmd_current_interface,argc,argv);	
+
+   	for ( i =0;i<argc;i++) {
+      if (argv[i] ) {
+		free(argv[i]);	
+	  }
+	}
+
+	return 0;
+}
+
+
+void set_command_mode(char *buf) {
+   if (strstr(buf,cmd_type[0])== buf ){
+		command_mode = INTERFACE_MODE;
+        // execute interface <> here
+		execute_cmd(buf,&cmd_interface[0]);
+		buf = buf + strlen(cmd_interface[0].cmd_string)+1;
+		#if 1   //chandrav
+	   cmd_current_interface = NULL;
+       cmd_current_interface= if_lookup_by_name (buf);
+	   if (!cmd_current_interface ) {
+	   		fprintf (stderr, "Error occured while getting interfce:%s",buf);
+		   	exit(1);
+       }
+		#endif
+
+	
+	}else if (strstr(buf,cmd_type[1]) == buf ) {
+		command_mode = RIP_MODE;
+	
+	} else {
+		command_mode = CONFIG_MODE;
+	
+	}
+    
+	
+}
+
+void rip_read_config_file(FILE *confp) {
+   char buf[VTY_BUFSIZ+1];
+
+   int i =0;
+   int initialize_mode = 1;
+
+   while(fgets(buf,VTY_BUFSIZ,confp) ) {
+	    
+	    if (remove_spaces(buf)) {
+			strcpy(buf,remove_spaces(buf) );
+		} else {
+			continue;
+		}
+		
+        if (initialize_mode) {
+			set_command_mode(buf);
+			initialize_mode = 0;
+			if ( command_mode != CONFIG_MODE ) {
+				continue;
+			}
+		}
+		switch(command_mode) {
+			case CONFIG_MODE:
+				config_mode:
+				for (i = 0; i < CONFIG_CMDS_LEN;i++) {
+					if (strstr(buf,cmd_config[i].cmd_string) == buf) {
+						execute_cmd(buf,&cmd_config[i]);
+						break;
+					}
+				}
+				if ( i == CONFIG_CMDS_LEN ) {
+					set_command_mode(buf);
+				    if ( command_mode != CONFIG_MODE ) {
+						continue;
+					}	
+					fprintf (stderr, "Error occured during reading below line.\n%s\n",buf);
+					exit(1);
+				}
+				break;
+					
+			case INTERFACE_MODE:
+				for (i = 1; i < INTERFACE_CMDS_LEN;i++) {
+					if (strstr(buf,cmd_interface[i].cmd_string) == buf) {
+						execute_cmd(buf,&cmd_interface[i]);
+						break;
+					}
+				}
+				if ( i == INTERFACE_CMDS_LEN ) {
+					set_command_mode(buf);
+				    if ( command_mode != CONFIG_MODE ) {
+						continue;
+					} 
+					goto config_mode;
+					
+				}
+				break;
+
+			case RIP_MODE:	
+				for (i = 0; i < RIP_CMDS_LEN;i++) {
+					if (strstr(buf,cmd_rip[i].cmd_string) == buf) {
+						execute_cmd(buf,&cmd_rip[i]);
+						break;
+					}
+				}
+				if ( i == RIP_CMDS_LEN ) {
+					set_command_mode(buf);
+				    if ( command_mode == INTERFACE_MODE ) {
+						continue;
+					}	
+					goto config_mode;
+				}
+				break;
+
+		}
+   }
+
+}
+
+#endif   /* VTY_REMOVE */
diff -Naur zebra-0.94/ripd/rip_peer.c open_zebra/ripd/rip_peer.c
--- zebra-0.94/ripd/rip_peer.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/ripd/rip_peer.c	2009-11-13 19:47:58.599697000 +0530
@@ -39,6 +39,12 @@
   struct rip_peer *new;
 
   new = XMALLOC (MTYPE_RIP_PEER, sizeof (struct rip_peer));
+  #ifdef RIPD_MEMORY_FIX
+  if ( !new ) {
+	return NULL;  	
+  }
+  #endif
+
   memset (new, 0, sizeof (struct rip_peer));
   return new;
 }
@@ -106,6 +112,11 @@
   else
     {
       peer = rip_peer_new ();
+	  #ifdef RIPD_MEMORY_FIX
+	  if (!peer) {
+		  return NULL;
+	  }
+	  #endif
       peer->addr = *addr;
       listnode_add_sort (peer_list, peer);
     }
@@ -125,6 +136,12 @@
 {
   struct rip_peer *peer;
   peer = rip_peer_get (&from->sin_addr);
+  #ifdef RIPD_MEMORY_FIX
+  if (!peer) {
+	  return;
+  }
+  #endif
+
   peer->version = version;
 }
 
@@ -133,6 +150,12 @@
 {
   struct rip_peer *peer;
   peer = rip_peer_get (&from->sin_addr);
+  #ifdef RIPD_MEMORY_FIX
+  if (!peer) {
+	  return;
+  }
+  #endif
+
   peer->recv_badroutes++;
 }
 
@@ -141,6 +164,12 @@
 {
   struct rip_peer *peer;
   peer = rip_peer_get (&from->sin_addr);
+  #ifdef RIPD_MEMORY_FIX
+  if (!peer) {
+	  return;
+  }
+  #endif
+
   peer->recv_badpackets++;
 }
 
@@ -179,6 +208,8 @@
   return buf;
 }
 
+#ifndef VTY_REMOVE
+
 void
 rip_peer_display (struct vty *vty)
 {
@@ -196,6 +227,8 @@
 	       VTY_NEWLINE);
     }
 }
+#endif /* VTY_REMOVE */
+
 
 int
 rip_peer_list_cmp (struct rip_peer *p1, struct rip_peer *p2)
diff -Naur zebra-0.94/ripd/rip_read_config.c open_zebra/ripd/rip_read_config.c
--- zebra-0.94/ripd/rip_read_config.c	1970-01-01 05:30:00.000000000 +0530
+++ open_zebra/ripd/rip_read_config.c	2009-11-13 19:47:58.601701000 +0530
@@ -0,0 +1,878 @@
+#ifdef VTY_REMOVE
+
+#include "rip_read_config.h"
+
+/***** COMMANDS CUPPORTED *****/
+
+#if 0
+
+enable/config commands:
+	debug rip events
+	debug rip packet
+	debug rip packet (send/recv)
+	**debug rip packet (send/recv) detail
+    
+    log stdout
+	log file FILENAME
+	log syslog
+
+interface commands:
+	interface IFNAME
+	ip rip send version (1|2)
+	ip rip send version 1 2
+	ip rip send version 2 1
+	ip rip receive version (1|2)
+	ip rip receive version (1 2)
+	ip rip receive version (2 1)
+	ip rip authentication mode (md5|text)
+	ip rip authentication key-chain LINE
+	ip rip authentication string LINE
+	ip split-horizon
+
+rip commands:
+	network <prefix/ifname>
+	neighbor <prefix>
+	default-information originate
+	version <1|2>
+	passive-interface IFNAME
+	default-metric <1-16>
+	timers basic <5-2147483647> <5-2147483647> <5-2147483647>
+	route A.B.C.D/M
+	distance <1-255>
+	distance <1-255> A.B.C.D/M
+	distance <1-255> A.B.C.D/M WORD  {WORD: accesslist name}
+	
+#endif
+
+
+#ifdef DEBUG_RIPD_STANDALONE	
+/****   ENABLE COMMANDS ***/
+/* debug rip events */
+
+/* debug rip events */
+int debug_rip_events(struct interface *ifp,int argc,char **argv)
+{
+  rip_debug_event = RIP_DEBUG_EVENT;
+  zebra_debug_kernel = ZEBRA_DEBUG_KERNEL;
+  
+  return CMD_SUCCESS;
+}
+
+
+/* debug rip packet */
+int debug_rip_packet(struct interface *ifp,int argc,char **argv)
+{
+	if ( argc == 0 ) {
+		debug_rip_packet_all(NULL,0,NULL);
+	}else {
+		debug_rip_packet_direct(NULL,argc,argv);
+	}
+	return CMD_SUCCESS;
+}
+
+/* debug rip packet */
+int debug_rip_packet_all(struct interface *ifp,int argc,char **argv)
+{
+  rip_debug_packet = RIP_DEBUG_PACKET;
+  rip_debug_packet |= RIP_DEBUG_SEND;
+  rip_debug_packet |= RIP_DEBUG_RECV;
+  return CMD_SUCCESS;
+}
+
+/* debug rip packet (recv|send) */
+int debug_rip_packet_direct(struct interface *ifp,int argc,char **argv)
+{
+  rip_debug_packet |= RIP_DEBUG_PACKET;
+  if (strncmp ("send", argv[0], strlen (argv[0])) == 0)
+    rip_debug_packet |= RIP_DEBUG_SEND;
+  if (strncmp ("recv", argv[0], strlen (argv[0])) == 0)
+    rip_debug_packet |= RIP_DEBUG_RECV;
+  rip_debug_packet &= ~RIP_DEBUG_DETAIL;
+  return CMD_SUCCESS;
+}
+/* debug rip packet (recv|send) detail */
+int debug_rip_packet_detail(struct interface *ifp,int argc,char **argv)
+{
+  rip_debug_packet |= RIP_DEBUG_PACKET;
+  if (strncmp ("send", argv[0], strlen (argv[0])) == 0)
+    rip_debug_packet |= RIP_DEBUG_SEND;
+  if (strncmp ("recv", argv[0], strlen (argv[0])) == 0)
+    rip_debug_packet |= RIP_DEBUG_RECV;
+  rip_debug_packet |= RIP_DEBUG_DETAIL;
+  return CMD_SUCCESS;
+}
+
+#endif
+
+/* log stdout */
+int config_log_stdout(struct interface *ifp,int argc,char **argv)
+{
+  zlog_set_flag (NULL, ZLOG_STDOUT);
+  return CMD_SUCCESS;
+}
+
+/* log file FILENAME */
+
+int config_log_file(struct interface *ifp,int argc,char **argv)
+{
+  int ret;
+  char *cwd;
+  char *fullpath;
+
+  /* Path detection. */
+  if (! IS_DIRECTORY_SEP (*argv[0]))
+    {
+      cwd = getcwd (NULL, MAXPATHLEN);
+      fullpath = XMALLOC (MTYPE_TMP,
+			  strlen (cwd) + strlen (argv[0]) + 2);
+      sprintf (fullpath, "%s/%s", cwd, argv[0]);
+    }
+  else
+    fullpath = argv[0];
+
+  ret = zlog_set_file (NULL, ZLOG_FILE, fullpath);
+
+  if (!ret)
+    {
+      //vty_out (vty, "can't open logfile %s\n", argv[0]);
+      return CMD_WARNING;
+    }
+
+  return CMD_SUCCESS;
+}
+
+/*  log syslog */
+
+int config_log_syslog(struct interface *ifp,int argc,char **argv)
+{
+  zlog_set_flag (NULL, ZLOG_SYSLOG);
+  zlog_default->facility = LOG_DAEMON;
+  return CMD_SUCCESS;
+}
+
+
+
+/****  RIP_COMMANDS *****/
+/* "network (A.B.C.D/M|WORD)" */
+
+int rip_network(struct interface *ifp,int argc,char **argv) {
+   int ret;
+   struct prefix_ipv4 p;
+
+   ret = str2prefix_ipv4 (argv[0], &p);
+
+   if (ret)
+     ret = rip_enable_network_add ((struct prefix *) &p);
+   else
+     ret = rip_enable_if_add (argv[0]);
+
+   if (ret < 0){
+      return CMD_WARNING;
+   }
+
+   rip_enable_apply_all ();
+   return CMD_SUCCESS;
+
+}
+
+/* default-information originate */
+int rip_default_information_originate(struct interface *ifp,int argc,char **argv)
+{
+  struct prefix_ipv4 p;
+
+  if (! rip->default_information)
+    {
+      memset (&p, 0, sizeof (struct prefix_ipv4));
+      p.family = AF_INET;
+
+      rip->default_information = 1;
+  
+      rip_redistribute_add (ZEBRA_ROUTE_RIP, RIP_ROUTE_STATIC, &p, 0, NULL);
+    }
+
+  return CMD_SUCCESS;
+}
+
+
+
+/*  "neighbor A.B.C.D" */
+int rip_neighbor(struct interface *ifp,int argc,char **argv) {
+  int ret;
+  struct prefix_ipv4 p;
+
+  ret = str2prefix_ipv4 (argv[0], &p);
+
+  if (ret <= 0)
+    {
+      //vty_out (vty, "Please specify address by A.B.C.D%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  rip_neighbor_add (&p);
+  
+  return CMD_SUCCESS;
+
+}
+
+/* "passive-interface IFNAME" */
+int rip_passive_interface(struct interface *ifp,int argc,char **argv) {
+  return rip_passive_interface_set (NULL,argv[0] );
+}
+
+
+/* "version <1-2>" */
+int rip_version(struct interface *ifp,int argc,char **argv) {
+  int version;
+
+  version = atoi (argv[0]);
+  if (version != RIPv1 && version != RIPv2)
+    {
+      //vty_out (vty, "invalid rip version %d%s", version,
+	  //     VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+  rip->version = version;
+
+  return CMD_SUCCESS;
+
+}
+
+/* "default-metric <1-16>" */
+
+int rip_default_metric(struct interface *ifp,int argc,char **argv)
+{
+  if (rip)
+    {
+      rip->default_metric = atoi (argv[0]);
+      /* rip_update_default_metric (); */
+    }
+  return CMD_SUCCESS;
+}
+
+/* "timers basic <5-2147483647> <5-2147483647> <5-2147483647>" */
+int rip_timers( struct interface *ifp,int argc,char **argv )
+{
+  unsigned long update;
+  unsigned long timeout;
+  unsigned long garbage;
+  char *endptr = NULL;
+  unsigned long RIP_TIMER_MAX = 2147483647;
+  unsigned long RIP_TIMER_MIN = 5;
+
+  update = strtoul (argv[0], &endptr, 10);
+  if (update > RIP_TIMER_MAX || update < RIP_TIMER_MIN || *endptr != '\0')  
+    {
+      //vty_out (vty, "update timer value error%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+  
+  timeout = strtoul (argv[1], &endptr, 10);
+  if (timeout > RIP_TIMER_MAX || timeout < RIP_TIMER_MIN || *endptr != '\0') 
+    {
+      //vty_out (vty, "timeout timer value error%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+  
+  garbage = strtoul (argv[2], &endptr, 10);
+  if (garbage > RIP_TIMER_MAX || garbage < RIP_TIMER_MIN || *endptr != '\0') 
+    {
+      //vty_out (vty, "garbage timer value error%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Set each timer value. */
+  rip->update_time = update;
+  rip->timeout_time = timeout;
+  rip->garbage_time = garbage;
+
+  /* Reset update timer thread. */
+  rip_event (RIP_UPDATE_EVENT, 0);
+
+  return CMD_SUCCESS;
+}
+
+/* "route A.B.C.D/M" */
+int rip_route( struct interface *ifp,int argc,char **argv ) 
+{
+  int ret;
+  struct prefix_ipv4 p;
+  struct route_node *node;
+
+  ret = str2prefix_ipv4 (argv[0], &p);
+  if (ret < 0)
+    {
+      //vty_out (vty, "Malformed address%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+  apply_mask_ipv4 (&p);
+
+  /* For router rip configuration. */
+  node = route_node_get (rip->route, (struct prefix *) &p);
+
+  if (node->info)
+    {
+      //vty_out (vty, "There is already same static route.%s", VTY_NEWLINE);
+      route_unlock_node (node);
+      return CMD_WARNING;
+    }
+
+  node->info = "static";
+
+  rip_redistribute_add (ZEBRA_ROUTE_RIP, RIP_ROUTE_STATIC, &p, 0, NULL);
+
+  return CMD_SUCCESS;
+}
+
+/* "distance <1-255>" */
+int rip_distance(struct interface *ifp, int argc,char **argv )
+{
+  rip->distance = atoi (argv[0]);
+  return CMD_SUCCESS;
+}
+
+/*"distance <1-255> A.B.C.D/M" */
+
+int rip_distance_source(struct interface *ifp,int argc,char **argv ) 
+{
+  return rip_distance_set (NULL, argv[0], argv[1], NULL);
+  
+}
+
+/*"distance <1-255> A.B.C.D/M WORD" */
+int rip_distance_source_access_list(struct interface *ifp,int argc,char **argv )
+{
+  return rip_distance_set (NULL,argv[0], argv[1], argv[2] );
+}
+
+
+/****  CONFIG COMMANDS *******/
+
+/*** Distribute-list commands */
+/* distribute-list WORD (in|out)" */
+int distribute_list_all(struct interface *ifp,int argc,char **argv )
+{
+  enum distribute_type type;
+  struct distribute *dist;
+
+  /* Check of distribute list type. */
+  if (strncmp (argv[1], "i", 1) == 0)
+    type = DISTRIBUTE_IN;
+  else if (strncmp (argv[1], "o", 1) == 0)
+    type = DISTRIBUTE_OUT;
+  else
+    {
+      //vty_out (vty, "distribute list direction must be [in|out]%s",
+	  //     VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Get interface name corresponding distribute list. */
+  dist = distribute_list_set (NULL, type, argv[0]);
+
+  return CMD_SUCCESS;
+}
+
+/*  distribute-list WORD (in|out) WORD",
+ */
+int distribute_list(struct interface *ifp,int argc,char **argv )
+{
+  enum distribute_type type;
+  struct distribute *dist;
+
+  /* Check of distribute list type. */
+  if (strncmp (argv[1], "i", 1) == 0)
+    type = DISTRIBUTE_IN;
+  else if (strncmp (argv[1], "o", 1) == 0)
+    type = DISTRIBUTE_OUT;
+  else
+    {
+      //vty_out (vty, "distribute list direction must be [in|out]%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Get interface name corresponding distribute list. */
+  dist = distribute_list_set (argv[2], type,argv[0]);
+
+  return CMD_SUCCESS;
+}       
+/* distribute-list prefix WORD (in|out)", */
+
+int districute_list_prefix_all(struct interface *ifp,int argc,char **argv )
+{
+  enum distribute_type type;
+  struct distribute *dist;
+
+  /* Check of distribute list type. */
+  if (strncmp (argv[1], "i", 1) == 0)
+    type = DISTRIBUTE_IN;
+  else if (strncmp (argv[1], "o", 1) == 0)
+    type = DISTRIBUTE_OUT;
+  else
+    {
+      //vty_out (vty, "distribute list direction must be [in|out]%s", 
+	  //     VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Get interface name corresponding distribute list. */
+  dist = distribute_list_prefix_set (NULL, type, argv[0]);
+
+  return CMD_SUCCESS;
+}       
+
+/** distribute-list prefix WORD (in|out) WORD", **/
+
+int districute_list_prefix(struct interface *ifp,int argc,char **argv )
+{
+  enum distribute_type type;
+  struct distribute *dist;
+
+  /* Check of distribute list type. */
+  if (strncmp (argv[1], "i", 1) == 0)
+    type = DISTRIBUTE_IN;
+  else if (strncmp (argv[1], "o", 1) == 0)
+    type = DISTRIBUTE_OUT;
+  else
+    {
+      //vty_out (vty, "distribute list direction must be [in|out]%s", 
+	  //     VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Get interface name corresponding distribute list. */
+  dist = distribute_list_prefix_set (argv[2], type, argv[0]);
+
+  return CMD_SUCCESS;
+}       
+
+
+/* INTERFACE COMMANDS */
+
+/* "interface IFNAME" */
+int rip_interface( struct interface *intf,int argc, char **argv)
+{
+  struct interface *ifp;
+
+  ifp = if_lookup_by_name (argv[0]);
+
+  if (ifp == NULL)
+    {
+      ifp = if_create ();
+	  #ifdef RIPD_MEMORY_FIX
+	  if ( !ifp ) {
+  		return CMD_WARNING;
+	  }
+	  #endif
+
+      strncpy (ifp->name, argv[0], INTERFACE_NAMSIZ);
+	}
+  //intf = ifp;
+  return CMD_SUCCESS;
+}
+
+/** Before calling any of the below methods,
+ * please call
+ *   ifp = if_lookup_by_name (intf);
+ *     if (!ifp ) {
+ *	  return CMD_WARNING;
+ *    }
+ *	 This will return the ifp structure;
+ *	 pass this ifp to any/all of the below calls
+ */
+ 
+/*"ip rip send version (1|2)",
+  */
+
+int ip_rip_send_version( struct interface *ifp,int argc, char **argv)
+{
+  struct rip_interface *ri;
+
+  ri = ifp->info;
+
+  /* Version 1. */
+  if (atoi (argv[0]) == 1)
+    {
+      ri->ri_send = RI_RIP_VERSION_1;
+      return CMD_SUCCESS;
+    }
+  if (atoi (argv[0]) == 2)
+    {
+      ri->ri_send = RI_RIP_VERSION_2;
+      return CMD_SUCCESS;
+    }
+  return CMD_WARNING;
+}
+
+/*"ip rip send version 1 2",
+*/
+int ip_rip_send_version_1(struct interface *ifp,int argc, char **argv)
+{
+  struct rip_interface *ri;
+
+  ri = ifp->info;
+
+  /* Version 1 and 2. */
+  ri->ri_send = RI_RIP_VERSION_1_AND_2;
+  return CMD_SUCCESS;
+}
+/* "ip rip send version 2 1",
+*/
+int ip_rip_send_version_2(struct interface *ifp,int argc, char **argv)
+{
+  struct rip_interface *ri;
+
+  ri = ifp->info;
+
+  /* Version 1 and 2. */
+  ri->ri_send = RI_RIP_VERSION_1_AND_2;
+  return CMD_SUCCESS;
+}
+
+/* "ip rip receive version (1|2)" */
+int ip_rip_receive_version(struct interface *ifp,int argc, char **argv)
+{
+  struct rip_interface *ri;
+
+  ri = ifp->info;
+
+  /* Version 1. */
+  if (atoi (argv[0]) == 1)
+    {
+      ri->ri_receive = RI_RIP_VERSION_1;
+      return CMD_SUCCESS;
+    }
+  if (atoi (argv[0]) == 2)
+    {
+      ri->ri_receive = RI_RIP_VERSION_2;
+      return CMD_SUCCESS;
+    }
+  return CMD_WARNING;
+}
+
+/**ip rip receive version 1 2",*/
+int ip_rip_receive_version_1(struct interface *ifp,int argc, char **argv )
+{
+  struct rip_interface *ri;
+
+  ri = ifp->info;
+
+  /* Version 1 and 2. */
+  ri->ri_receive = RI_RIP_VERSION_1_AND_2;
+  return CMD_SUCCESS;
+}
+
+/** "ip rip receive version 2 1", **/
+int ip_rip_receive_version_2(struct interface *ifp,int argc, char **argv)
+{
+  struct rip_interface *ri;
+  
+  ri = ifp->info;
+
+  /* Version 1 and 2. */
+  ri->ri_receive = RI_RIP_VERSION_1_AND_2;
+  return CMD_SUCCESS;
+}
+
+/** "ip rip authentication mode (md5|text)" **/
+
+int ip_rip_authentication_mode(struct interface *ifp,int argc, char **argv)
+{
+  struct rip_interface *ri;
+  
+  ri = ifp->info;
+
+  if (strncmp ("md5", argv[0], strlen (argv[0])) == 0)
+    ri->auth_type = RIP_AUTH_MD5;
+  else if (strncmp ("text", argv[0], strlen (argv[0])) == 0)
+    ri->auth_type = RIP_AUTH_SIMPLE_PASSWORD;
+  else
+    {
+      //vty_out (vty, "mode should be md5 or text%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  return CMD_SUCCESS;
+}
+
+/**"ip rip authentication key-chain LINE", */
+int ip_rip_authentication_key_chain(struct interface *ifp,int argc, char **argv )
+{
+  struct rip_interface *ri;
+
+  ri = ifp->info;
+
+  if (ri->auth_str)
+    {
+	  #ifndef VTY_REMOVE 
+	  vty_out (vty, "%% authentication string configuration exists%s",
+	       VTY_NEWLINE);
+      #endif
+      return CMD_WARNING;
+    }
+
+  if (ri->key_chain)
+    free (ri->key_chain);
+
+  ri->key_chain = strdup (argv[0]);
+
+  return CMD_SUCCESS;
+}
+
+
+/** "ip rip authentication string LINE" **/
+int ip_rip_authentication_string(struct interface *ifp,int argc, char **argv )
+{
+  struct rip_interface *ri;
+
+  ri = ifp->info;
+
+  if (strlen (argv[0]) > 16)
+    { 
+	  #ifndef VTY_REMOVE	
+      vty_out (vty, "%% RIPv2 authentication string must be shorter than 16%s",
+	       VTY_NEWLINE);
+	  #endif
+      return CMD_WARNING;
+    }
+
+  if (ri->key_chain)
+    {
+      //vty_out (vty, "%% key-chain configuration exists%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  if (ri->auth_str)
+    free (ri->auth_str);
+
+  ri->auth_str = strdup (argv[0]);
+
+  return CMD_SUCCESS;
+}
+/*ip split-horizon*/
+int rip_split_horizon(struct interface *ifp,int argc, char **argv)
+{
+  struct rip_interface *ri;
+
+  ri = ifp->info;
+
+  ri->split_horizon = 1;
+  return CMD_SUCCESS;
+}
+
+FILE *
+use_backup_config (char *fullpath)
+{
+  char *fullpath_sav, *fullpath_tmp;
+  FILE *ret = NULL;
+  struct stat buf;
+  int tmp, sav;
+  int c;
+  char buffer[512];
+  
+  fullpath_sav = malloc (strlen (fullpath) + strlen (CONF_BACKUP_EXT) + 1);
+  strcpy (fullpath_sav, fullpath);
+  strcat (fullpath_sav, CONF_BACKUP_EXT);
+  if (stat (fullpath_sav, &buf) == -1)
+    {
+      free (fullpath_sav);
+      return NULL;
+    }
+
+  fullpath_tmp = malloc (strlen (fullpath) + 8);
+  sprintf (fullpath_tmp, "%s.XXXXXX", fullpath);
+  
+  /* Open file to configuration write. */
+  tmp = mkstemp (fullpath_tmp);
+  if (tmp < 0)
+    {
+      free (fullpath_sav);
+      free (fullpath_tmp);
+      return NULL;
+    }
+
+  sav = open (fullpath_sav, O_RDONLY);
+  if (sav < 0)
+    {
+      free (fullpath_sav);
+      free (fullpath_tmp);
+      unlink (fullpath_tmp);
+      return NULL;
+    }
+  
+  while((c = read (sav, buffer, 512)) > 0)
+    write (tmp, buffer, c);
+  
+  close (sav);
+  close (tmp);
+  
+  if (link (fullpath_tmp, fullpath) == 0)
+    ret = fopen (fullpath, "r");
+
+  unlink (fullpath_tmp);
+  
+  free (fullpath_sav);
+  free (fullpath_tmp);
+  return fopen (fullpath, "r");
+}
+
+void rip_read_config(char *config_file, char *config_current_dir, char *config_default_dir) 
+{
+
+  char *cwd;
+  FILE *confp = NULL;
+  char *fullpath;
+  
+  /* If -f flag specified. */
+  if (config_file != NULL)
+    {
+      if (! IS_DIRECTORY_SEP (config_file[0]))
+	{
+	  cwd = getcwd (NULL, MAXPATHLEN);
+	  fullpath = XMALLOC (MTYPE_TMP, 
+			      strlen (cwd) + strlen (config_file) + 2);
+	  sprintf (fullpath, "%s/%s", cwd, config_file);
+	}
+      else
+	fullpath = config_file;
+
+      confp = fopen (fullpath, "r");
+
+      if (confp == NULL)
+	{
+	  confp = use_backup_config (fullpath);
+	  if (confp)
+	    fprintf (stderr, "WARNING: using backup configuration file!\n");
+	  else
+	    {
+	      fprintf (stderr, "can't open configuration file [%s]\n", 
+		       config_file);
+	      exit(1);
+	    }
+	}
+    }
+  else
+    {
+      /* Relative path configuration file open. */
+      if (config_current_dir)
+	{
+	  confp = fopen (config_current_dir, "r");
+	  if (confp == NULL)
+	    {
+	      confp = use_backup_config (config_current_dir);
+	      if (confp)
+		fprintf (stderr, "WARNING: using backup configuration file!\n");
+	    }
+	}
+
+      /* If there is no relative path exists, open system default file. */
+      if (confp == NULL)
+	{
+
+	  confp = fopen (config_default_dir, "r");
+	  if (confp == NULL)
+	    {
+	      confp = use_backup_config (config_default_dir);
+	      if (confp)
+		{
+		  fprintf (stderr, "WARNING: using backup configuration file!\n");
+		  fullpath = config_default_dir;
+		}
+	      else
+		{
+		  fprintf (stderr, "can't open configuration file [%s]\n",
+			   config_default_dir);
+		  exit (1);
+		}
+	    }      
+	  else
+	    fullpath = config_default_dir;
+	}
+      else
+	{
+	  /* Rleative path configuration file. */
+	  cwd = getcwd (NULL, MAXPATHLEN);
+	  fullpath = XMALLOC (MTYPE_TMP, 
+			      strlen (cwd) + strlen (config_current_dir) + 2);
+	  sprintf (fullpath, "%s/%s", cwd, config_current_dir);
+	}  
+    }  
+
+	rip_read_config_file(confp);
+	fclose (confp);
+
+}
+
+#if 0 //used for testing purpose --chandrav
+int rip_read_config_test( char *config_file, char *config_current_dir, char *config_default_dir ) 
+{
+struct interface *ifp;
+
+char *argv1[CMD_ARGC_MAX];
+char *argv2[CMD_ARGC_MAX];
+char *argv3[CMD_ARGC_MAX];
+char *argv5[CMD_ARGC_MAX];
+char *argv6[CMD_ARGC_MAX];
+
+argv1[0]= malloc(100);
+argv2[0]= malloc(100);
+argv3[0]= malloc(100);
+argv5[0]= malloc(100);
+argv6[0]= malloc(100);
+
+
+strcpy(argv1[0],"eth1");
+strcpy(argv5[0],"lo");
+//strcpy(argv6[0],"172.20.22.78/24");
+strcpy(argv6[0],"eth1");
+
+strcpy(argv2[0],"2");
+strcpy(argv3[0],"20.18.18.18");
+
+printf("before calling rip_interface");
+//----interface eth0
+rip_interface(NULL,1,argv1);
+    //  --- ip rip send version 2
+	//  --- ip rip receive version 2  
+printf("called rip_interface");
+
+    ifp = if_lookup_by_name ("eth1");
+    if (!ifp ) {
+ 	  return CMD_WARNING;
+    }
+	ip_rip_send_version(ifp,0,argv2);
+    ip_rip_receive_version(ifp,0,argv2);
+
+#ifdef DEBUG_RIPD_STANDALONE
+// ---- debug rip packet,events
+debug_rip_events(NULL,0,NULL);
+debug_rip_packet(NULL,0,NULL);
+#endif
+
+//---- log stdout
+config_log_stdout(NULL,0,NULL);
+
+
+
+//--- interface lo
+rip_interface(NULL,1,argv5);
+    //  --- ip rip send version 2
+	//  --- ip rip receive version 2  
+    ifp = if_lookup_by_name ("lo");
+    if (!ifp ) {
+ 	  return CMD_WARNING;
+    }
+	ip_rip_send_version(ifp,0,argv2);
+    ip_rip_receive_version(ifp,0,argv2);
+	
+	
+//----  network eth0
+rip_network(NULL,0,argv6);
+// -- after router rip command ---
+rip_version(NULL,0,argv2);
+rip_neighbor(NULL,0,argv3);
+return 0;
+}
+#endif //#if 0
+
+
+#endif /* VTY_REMOVE */
diff -Naur zebra-0.94/ripd/rip_read_config.h open_zebra/ripd/rip_read_config.h
--- zebra-0.94/ripd/rip_read_config.h	1970-01-01 05:30:00.000000000 +0530
+++ open_zebra/ripd/rip_read_config.h	2009-11-13 19:47:58.604699000 +0530
@@ -0,0 +1,83 @@
+#ifndef __RIP_READ_CONFIG_H__
+#define __RIP_READ_CONFIG_H__
+#include <zebra.h>
+
+#include "if.h"
+#include "command.h"
+#include "prefix.h"
+#include "table.h"
+#include "thread.h"
+#include "memory.h"
+#include "log.h"
+#include "stream.h"
+#include "filter.h"
+#include "sockunion.h"
+#include "routemap.h"
+#include "plist.h"
+#include "distribute.h"
+#include "md5-gnu.h"
+#include "keychain.h"
+
+#include "ripd/ripd.h"
+#include "ripd/rip_debug.h"
+
+#ifdef DEBUG_RIPD_STANDALONE
+#include "zebra/debug.h"
+#endif
+
+#include "log.h"
+
+extern struct interface *cmd_current_interface ;
+
+int debug_rip_events(struct interface *ifp,int argc,char **argv);
+int debug_rip_packet(struct interface *ifp,int argc,char **argv);
+int debug_rip_packet_all(struct interface *ifp,int argc,char **argv);
+int debug_rip_packet_direct(struct interface *ifp,int argc,char **argv);
+int config_log_stdout(struct interface *ifp,int argc,char **argv);
+int config_log_file(struct interface *ifp,int argc,char **argv);
+int config_log_syslog(struct interface *ifp,int argc,char **argv);
+int rip_network(struct interface *ifp,int argc,char **argv) ;
+int rip_default_information_originate(struct interface *ifp,int argc,char **argv);
+int rip_neighbor(struct interface *ifp,int argc,char **argv) ;
+int rip_enable_network_add (struct prefix *p);
+int rip_enable_if_add (char *ifname);
+void rip_enable_apply_all ();
+int rip_neighbor_add (struct prefix_ipv4 *p);
+int rip_passive_interface_set (struct vty *vty, char *ifname);
+int rip_passive_interface(struct interface *ifp,int argc,char **argv);
+int rip_version(struct interface *ifp,int argc,char **argv);
+int rip_default_metric(struct interface *ifp,int argc,char **argv);
+int rip_timers( struct interface *ifp,int argc,char **argv );
+int rip_route( struct interface *ifp,int argc,char **argv ) ;
+int rip_distance(struct interface *ifp, int argc,char **argv );
+int rip_distance_source(struct interface *ifp,int argc,char **argv ) ;
+int rip_distance_source_access_list(struct interface *ifp,int argc,char **argv );
+int distribute_list_all(struct interface *ifp,int argc,char **argv );
+int distribute_list(struct interface *ifp,int argc,char **argv );
+int districute_list_prefix_all(struct interface *ifp,int argc,char **argv );
+int districute_list_prefix(struct interface *ifp,int argc,char **argv );
+int rip_interface( struct interface *intf,int argc, char **argv);
+int ip_rip_send_version( struct interface *ifp,int argc, char **argv);
+int ip_rip_send_version_1(struct interface *ifp,int argc, char **argv);
+int ip_rip_send_version_2(struct interface *ifp,int argc, char **argv);
+int ip_rip_receive_version(struct interface *ifp,int argc, char **argv);
+int ip_rip_receive_version_1(struct interface *ifp,int argc, char **argv );
+int ip_rip_receive_version_2(struct interface *ifp,int argc, char **argv);
+int ip_rip_authentication_mode(struct interface *ifp,int argc, char **argv);
+int ip_rip_authentication_key_chain(struct interface *ifp,int argc, char **argv );
+int ip_rip_authentication_string(struct interface *ifp,int argc, char **argv );
+int rip_split_horizon(struct interface *ifp,int argc, char **argv);
+
+
+	
+	
+void rip_event (enum rip_event event, int sock);
+int rip_distance_set (struct vty *vty, char *distance_str, char *ip_str,char *access_list_str);
+struct distribute * distribute_list_set (char *ifname, enum distribute_type type, char *alist_name);
+struct distribute * distribute_list_prefix_set (char *ifname, enum distribute_type type,
+			    char *plist_name);
+
+void rip_read_config(char *config_file, char *config_current_dir, char *config_default_dir);
+void rip_read_config_file(FILE *filep);
+
+#endif
diff -Naur zebra-0.94/ripd/rip_zebra.c open_zebra/ripd/rip_zebra.c
--- zebra-0.94/ripd/rip_zebra.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/ripd/rip_zebra.c	2009-11-13 19:47:58.611704000 +0530
@@ -30,6 +30,12 @@
 #include "ripd/ripd.h"
 #include "ripd/rip_debug.h"
 
+#ifdef RIPD_STANDALONE
+#include "zebra/rib.h"
+#include "memory.h"
+#endif
+
+#ifndef RIPD_STANDALONE
 /* All information about zebra. */
 struct zclient *zclient = NULL;
 
@@ -40,12 +46,107 @@
 int rip_interface_address_delete (int, struct zclient *, zebra_size_t);
 int rip_interface_up (int, struct zclient *, zebra_size_t);
 int rip_interface_down (int, struct zclient *, zebra_size_t);
-
+#endif
+
+
+
+#ifdef RIPD_STANDALONE
+int kernel_add_ipv4 (struct prefix *p, struct rib *rib);
+int kernel_delete_ipv4 (struct prefix *p, struct rib *rib);
+
+/* function taken from zebra/zebra_rib.c */
+void
+nexthop_add (struct rib *rib, struct nexthop *nexthop)
+{
+  struct nexthop *last;
+
+  for (last = rib->nexthop; last && last->next; last = last->next)
+    ;
+  if (last)
+    last->next = nexthop;
+  else
+    rib->nexthop = nexthop;
+  nexthop->prev = last;
+
+  rib->nexthop_num++;
+}
+
+/* function taken from zebra/zebra_rib.c */
+struct nexthop *
+nexthop_ipv4_add (struct rib *rib, struct in_addr *ipv4)
+{
+  struct nexthop *nexthop;
+
+  nexthop = XMALLOC (MTYPE_NEXTHOP, sizeof (struct nexthop));
+  #ifdef RIPD_MEMORY_FIX
+  if ( !nexthop ) {
+	  return NULL ;
+  }
+  #endif
+
+  memset (nexthop, 0, sizeof (struct nexthop));
+  nexthop->type = NEXTHOP_TYPE_IPV4;
+  nexthop->gate.ipv4 = *ipv4;
+
+  nexthop_add (rib, nexthop);
+
+  return nexthop;
+}
+
+#endif
+
+
 /* RIPd to zebra command interface. */
 void
 rip_zebra_ipv4_add (struct prefix_ipv4 *p, struct in_addr *nexthop, 
 		    u_int32_t metric, u_char distance)
 {
+  #ifdef RIPD_STANDALONE
+  struct rib *rib;
+  /* Make it sure prefixlen is applied to the prefix. */
+  apply_mask_ipv4 (p);
+
+  rib = XMALLOC (MTYPE_RIB, sizeof (struct rib));
+  #ifdef RIPD_MEMORY_FIX
+  if (!rib) {
+	  return ;
+  }
+  #endif
+
+  memset (rib, 0, sizeof (struct rib));
+
+  rib->type = ZEBRA_ROUTE_RIP;
+  rib->flags = 0;
+  rib->metric = metric;
+  
+  if (distance && distance != ZEBRA_RIP_DISTANCE_DEFAULT)
+	{
+	  rib->distance = distance;
+	}
+  #ifdef RIPD_MEMORY_FIX
+  if ( !nexthop_ipv4_add (rib, nexthop) ) {
+	  XFREE(MTYPE_RIB,rib);
+	  return ;
+  }
+  #else
+  nexthop_ipv4_add (rib, nexthop);
+  #endif
+
+  rib->uptime = time (NULL);
+  
+  rib->nexthop->flags = NEXTHOP_FLAG_ACTIVE;
+  kernel_add_ipv4((struct prefix *)p,rib);
+  rip_global_route_changes++;
+
+  XFREE(MTYPE_RIB,rib);
+  XFREE(MTYPE_NEXTHOP,rib->nexthop);
+  //chandrav
+  #ifdef DEBUG_RIPD_STANDALONE
+	 if (IS_RIP_DEBUG_EVENT)
+		zlog_info("RIPDS:rip_zebra_ipv4_add is called");
+  #endif
+
+  #else
   struct zapi_ipv4 api;
 
   if (zclient->redist[ZEBRA_ROUTE_RIP])
@@ -70,12 +171,57 @@
 
       rip_global_route_changes++;
     }
+  #endif
+  
 }
 
 void
 rip_zebra_ipv4_delete (struct prefix_ipv4 *p, struct in_addr *nexthop, 
 		       u_int32_t metric)
 {
+  #ifdef RIPD_STANDALONE
+  struct rib *rib;
+
+  /* Make it sure prefixlen is applied to the prefix. */
+  apply_mask_ipv4 (p);
+
+  rib = XMALLOC (MTYPE_RIB, sizeof (struct rib));
+  #ifdef RIPD_MEMORY_FIX
+  if (!rib) {
+	  return ;
+  }
+  #endif
+
+  memset (rib, 0, sizeof (struct rib));
+
+  rib->type = ZEBRA_ROUTE_RIP;
+  rib->flags = 0;
+  rib->metric = metric;
+
+  #ifdef RIPD_MEMORY_FIX
+  if ( !nexthop_ipv4_add (rib, nexthop) ) {
+	  XFREE(MTYPE_RIB,rib);
+	  return;
+  }
+  #else
+  nexthop_ipv4_add (rib, nexthop);
+  #endif
+
+  rib->uptime = time (NULL);
+  rib->nexthop->flags = NEXTHOP_FLAG_FIB;
+  kernel_delete_ipv4((struct prefix *)p,rib);
+  rip_global_route_changes++;
+
+  XFREE(MTYPE_RIB,rib);
+  XFREE(MTYPE_NEXTHOP,rib->nexthop);
+
+  //chandrav
+  #ifdef DEBUG_RIPD_STANDALONE
+	 if (IS_RIP_DEBUG_EVENT)
+		zlog_info("RIPDS:rip_zebra_ipv4_delete is called");
+  #endif
+
+  #else
   struct zapi_ipv4 api;
 
   if (zclient->redist[ZEBRA_ROUTE_RIP])
@@ -94,8 +240,11 @@
 
       rip_global_route_changes++;
     }
+  #endif
+  
 }
 
+#ifndef RIPD_STANDALONE
 /* Zebra route add and delete treatment. */
 int
 rip_zebra_read_ipv4 (int command, struct zclient *zclient, zebra_size_t length)
@@ -145,13 +294,16 @@
 
   return 0;
 }
+#endif
 
+#ifndef RIPD_STANDALONE
 void
 rip_zclient_reset ()
 {
   zclient_reset (zclient);
 }
 
+
 /* RIP route-map set for redistribution */
 void
 rip_routemap_set (int type, char *name)
@@ -196,6 +348,7 @@
 
   return 0;
 }
+
 
 /* Redistribution types */
 static struct {
@@ -210,7 +363,9 @@
   {ZEBRA_ROUTE_BGP,     1, "bgp"},
   {0, 0, NULL}
 };
+#endif
 
+#ifndef RIPD_STANDALONE
 DEFUN (router_zebra,
        router_zebra_cmd,
        "router zebra",
@@ -234,7 +389,9 @@
   zclient_stop (zclient);
   return CMD_SUCCESS;
 }
+#endif
 
+#ifndef RIPD_STANDALONE
 int
 rip_redistribute_set (int type)
 {
@@ -342,6 +499,7 @@
   return CMD_WARNING;
 }
 
+
 DEFUN (no_rip_redistribute_type,
        no_rip_redistribute_type_cmd,
        "no redistribute (kernel|connected|static|ospf|bgp)",
@@ -373,6 +531,7 @@
   return CMD_WARNING;
 }
 
+
 DEFUN (rip_redistribute_type_routemap,
        rip_redistribute_type_routemap_cmd,
        "redistribute (kernel|connected|static|ospf|bgp) route-map WORD",
@@ -541,6 +700,10 @@
 
   return CMD_WARNING;
 }
+#endif
+
+#ifndef VTY_REMOVE
+
 
 /* Default information originate. */
 
@@ -587,6 +750,10 @@
   return CMD_SUCCESS;
 }
 
+#endif /* VTY_REMOVE */
+
+#ifndef RIPD_STANDALONE
+
 /* RIP configuration write function. */
 int
 config_write_zebra (struct vty *vty)
@@ -612,6 +779,7 @@
   char *str[] = { "system", "kernel", "connected", "static", "rip",
 		  "ripng", "ospf", "ospf6", "bgp"};
 
+		  
   for (i = 0; i < ZEBRA_ROUTE_MAX; i++)
     if (i != zclient->redist_default && zclient->redist[i])
       {
@@ -646,6 +814,7 @@
   return 0;
 }
 
+
 /* Zebra node structure. */
 struct cmd_node zebra_node =
 {
@@ -653,6 +822,7 @@
   "%s(config-router)# ",
 };
 
+
 void
 rip_zclient_init ()
 {
@@ -667,7 +837,9 @@
   zclient->ipv4_route_delete = rip_zebra_read_ipv4;
   zclient->interface_up = rip_interface_up;
   zclient->interface_down = rip_interface_down;
-  
+
+  #ifndef VTY_REMOVE 
+
   /* Install zebra node. */
   install_node (&zebra_node, config_write_zebra);
 
@@ -688,4 +860,8 @@
   install_element (RIP_NODE, &no_rip_redistribute_type_metric_routemap_cmd);
   install_element (RIP_NODE, &rip_default_information_originate_cmd);
   install_element (RIP_NODE, &no_rip_default_information_originate_cmd);
+  #endif /* VTY_REMOVE */
+
 }
+#endif
+
diff -Naur zebra-0.94/ripd/ripd.c open_zebra/ripd/ripd.c
--- zebra-0.94/ripd/ripd.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/ripd/ripd.c	2009-11-13 19:47:58.615708000 +0530
@@ -77,6 +77,10 @@
     {0,              NULL}
   };
 
+
+#ifdef RIPD_STANDALONE
+#define route_info rip_route_info
+#endif
 /* Each route type's strings and default preference. */
 struct
 {  
@@ -124,6 +128,12 @@
   struct rip_info *new;
 
   new = XMALLOC (MTYPE_RIP_INFO, sizeof (struct rip_info));
+  #ifdef RIPD_MEMORY_FIX
+  if (!new) {
+  	return NULL;
+  }
+  #endif
+
   memset (new, 0, sizeof (struct rip_info));
   return new;
 }
@@ -216,9 +226,11 @@
       if (access_list_apply (ri->list[RIP_FILTER_IN], 
 			     (struct prefix *) p) == FILTER_DENY)
 	{
+	  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 	  if (IS_RIP_DEBUG_PACKET)
 	    zlog_info ("%s/%d filtered by distribute in",
 		       inet_ntoa (p->prefix), p->prefixlen);
+      #endif
 	  return -1;
 	}
     }
@@ -227,9 +239,11 @@
       if (prefix_list_apply (ri->prefix[RIP_FILTER_IN], 
 			     (struct prefix *) p) == PREFIX_DENY)
 	{
+	  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 	  if (IS_RIP_DEBUG_PACKET)
 	    zlog_info ("%s/%d filtered by prefix-list in",
 		       inet_ntoa (p->prefix), p->prefixlen);
+	  #endif
 	  return -1;
 	}
     }
@@ -247,9 +261,12 @@
 	      if (access_list_apply (alist,
 				     (struct prefix *) p) == FILTER_DENY)
 		{
+		  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 		  if (IS_RIP_DEBUG_PACKET)
 		    zlog_info ("%s/%d filtered by distribute in",
 			       inet_ntoa (p->prefix), p->prefixlen);
+		  #endif
+		  
 		  return -1;
 		}
 	    }
@@ -263,9 +280,11 @@
 	      if (prefix_list_apply (plist,
 				     (struct prefix *) p) == PREFIX_DENY)
 		{
+		  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 		  if (IS_RIP_DEBUG_PACKET)
 		    zlog_info ("%s/%d filtered by prefix-list in",
 			       inet_ntoa (p->prefix), p->prefixlen);
+		  #endif
 		  return -1;
 		}
 	    }
@@ -286,9 +305,11 @@
       if (access_list_apply (ri->list[RIP_FILTER_OUT],
 			     (struct prefix *) p) == FILTER_DENY)
 	{
+   	  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 	  if (IS_RIP_DEBUG_PACKET)
 	    zlog_info ("%s/%d is filtered by distribute out",
 		       inet_ntoa (p->prefix), p->prefixlen);
+      #endif
 	  return -1;
 	}
     }
@@ -297,9 +318,11 @@
       if (prefix_list_apply (ri->prefix[RIP_FILTER_OUT],
 			     (struct prefix *) p) == PREFIX_DENY)
 	{
+	  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 	  if (IS_RIP_DEBUG_PACKET)
 	    zlog_info ("%s/%d is filtered by prefix-list out",
 		       inet_ntoa (p->prefix), p->prefixlen);
+      #endif
 	  return -1;
 	}
     }
@@ -317,9 +340,11 @@
 	      if (access_list_apply (alist,
 				     (struct prefix *) p) == FILTER_DENY)
 		{
+		  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 		  if (IS_RIP_DEBUG_PACKET)
 		    zlog_info ("%s/%d filtered by distribute out",
 			       inet_ntoa (p->prefix), p->prefixlen);
+		  #endif
 		  return -1;
 		}
 	    }
@@ -333,9 +358,11 @@
 	      if (prefix_list_apply (plist,
 				     (struct prefix *) p) == PREFIX_DENY)
 		{
+		  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 		  if (IS_RIP_DEBUG_PACKET)
 		    zlog_info ("%s/%d filtered by prefix-list out",
 			       inet_ntoa (p->prefix), p->prefixlen);
+		  #endif
 		  return -1;
 		}
 	    }
@@ -409,7 +436,12 @@
      arrived. If the result is greater than infinity, use infinity
      (RFC2453 Sec. 3.9.2) */
   /* Zebra ripd can handle offset-list in. */
+
+  #ifndef RIPD_STANDALONE
   ret = rip_offset_list_apply_in (&p, ifp, &rte->metric);
+  #else
+  ret =0;
+  #endif
 
   /* If offset-list does not modify the metric use interface's
      metric. */
@@ -428,8 +460,10 @@
   /* Check nexthop address. */
   if (rip_nexthop_check (nexthop) < 0)
     {
-      if (IS_RIP_DEBUG_PACKET)
+      #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
+	  if (IS_RIP_DEBUG_PACKET)
 	zlog_info ("Nexthop address %s is invalid", inet_ntoa (*nexthop));
+	  #endif
       return;
     }
 
@@ -463,6 +497,12 @@
       if (rte->metric != RIP_METRIC_INFINITY)
 	{
 	  rinfo = rip_info_new ();
+	  #ifdef RIPD_MEMORY_FIX
+	  if (!rinfo) {
+	  	return;
+	  }
+	  #endif
+
 	  
 	  /* - Setting the destination prefix and length to those in
 	     the RTE. */
@@ -595,7 +635,11 @@
 		  /* - The metric for the route is set to 16
 		     (infinity).  This causes the route to be removed
 		     from service.*/
+		  #ifdef RIPD_STANDALONE
+   		  rip_zebra_ipv4_delete (&p, &rinfo->nexthop, rinfo->metric );
+          #else
 		  rip_zebra_ipv4_delete (&p, &rinfo->nexthop, oldmetric);
+		  #endif
 		  rinfo->flags &= ~RIP_RTF_FIB;
 
 		  /* - The route change flag is to indicate that this
@@ -738,10 +782,11 @@
 {
   struct rip_interface *ri;
   char *auth_str;
-
+  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
   if (IS_RIP_DEBUG_EVENT)
     zlog_info ("RIPv2 simple password authentication from %s",
 	       inet_ntoa (from->sin_addr));
+  #endif
 
   ri = ifp->info;
 
@@ -788,9 +833,10 @@
   u_char digest[RIP_AUTH_MD5_SIZE];
   u_int16_t packet_len;
   char *auth_str = NULL;
-  
+  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
   if (IS_RIP_DEBUG_EVENT)
     zlog_info ("RIPv2 MD5 authentication from %s", inet_ntoa (from->sin_addr));
+  #endif
 
   ri = ifp->info;
   md5 = (struct rip_md5_info *) &packet->rte;
@@ -1069,14 +1115,18 @@
 		  if (rinfo->type == ZEBRA_ROUTE_RIP
 		      && rinfo->sub_type == RIP_ROUTE_RTE)
 		    {
+			  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 		      if (IS_RIP_DEBUG_EVENT)
 			zlog_info ("Next hop %s is on RIP network.  Set nexthop to the packet's originator", inet_ntoa (rte->nexthop));
+		      #endif
 		      rte->nexthop = rinfo->from;
 		    }
 		  else
-		    {
+		    { 
+ 			  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 		      if (IS_RIP_DEBUG_EVENT)
 			zlog_info ("Next hop %s is not directly reachable. Treat it as 0.0.0.0", inet_ntoa (rte->nexthop));
+			  #endif
 		      rte->nexthop.s_addr = 0;
 		    }
 
@@ -1084,8 +1134,10 @@
 		}
 	      else
 		{
+		  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 		  if (IS_RIP_DEBUG_EVENT)
 		    zlog_info ("Next hop %s is not directly reachable. Treat it as 0.0.0.0", inet_ntoa (rte->nexthop));
+		  #endif
 		  rte->nexthop.s_addr = 0;
 		}
 
@@ -1145,8 +1197,10 @@
 	  && (rte->prefix.s_addr == 0)
 	  && (rte->mask.s_addr != 0))
 	{
+	  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 	  if (IS_RIP_DEBUG_EVENT)
 	    zlog_info ("Default route with non-zero netmask.  Set zero to netmask");
+	  #endif
 	  rte->mask.s_addr = 0;
 	}
 	  
@@ -1197,9 +1251,11 @@
   ret = sendto (sock, buf, size, 0, (struct sockaddr *)&sin,
 		sizeof (struct sockaddr_in));
 
+  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
   if (IS_RIP_DEBUG_EVENT)
     zlog_info ("SEND to socket %d port %d addr %s",
 	       sock, ntohs (sin.sin_port), inet_ntoa(sin.sin_addr));
+  #endif
 
   if (ret < 0)
     zlog_warn ("can't send packet : %s", strerror (errno));
@@ -1262,6 +1318,12 @@
     }
 
   rinfo = rip_info_new ();
+  #ifdef RIPD_MEMORY_FIX
+  if (!rinfo) {
+	  return;
+  }
+  #endif
+
     
   rinfo->type = type;
   rinfo->sub_type = sub_type;
@@ -1504,19 +1566,22 @@
   /* Check is this packet comming from myself? */
   if (if_check_address (from.sin_addr)) 
     {
+	  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
       if (IS_RIP_DEBUG_PACKET)
 	zlog_warn ("ignore packet comes from myself");
+      #endif
       return -1;
     }
 
   /* Which interface is this packet comes from. */
   ifp = if_lookup_address (from.sin_addr);
-
+  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
   /* RIP packet received */
   if (IS_RIP_DEBUG_EVENT)
     zlog_info ("RECV packet from %s port %d on %s",
 	       inet_ntoa (from.sin_addr), ntohs (from.sin_port),
 	       ifp ? ifp->name : "unknown");
+  #endif
 
   /* If this packet come from unknown interface, ignore it. */
   if (ifp == NULL)
@@ -1562,10 +1627,11 @@
       rip_peer_bad_packet (&from);
       return -1;
     }
-
+  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
   /* Dump RIP packet. */
   if (IS_RIP_DEBUG_RECV)
     rip_packet_dump (packet, len, "RECV");
+  #endif
 
   /* RIP version adjust.  This code should rethink now.  RFC1058 says
      that "Version 1 implementations are to ignore this extra data and
@@ -1578,8 +1644,10 @@
   ri = ifp->info;
   if (! ri->running && ! rip_neighbor_lookup (&from))
     {
+	  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
       if (IS_RIP_DEBUG_EVENT)
 	zlog_info ("RIP is not enabled on interface %s.", ifp->name);
+	  #endif
       rip_peer_bad_packet (&from);
       return -1;
     }
@@ -1591,9 +1659,11 @@
 	{
 	  if (packet->version != rip->version) 
 	    {
+ 		  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 	      if (IS_RIP_DEBUG_PACKET)
 		zlog_warn ("  packet's v%d doesn't fit to my version %d", 
 			   packet->version, rip->version);
+	      #endif
 	      rip_peer_bad_packet (&from);
 	      return -1;
 	    }
@@ -1603,18 +1673,22 @@
 	  if (packet->version == RIPv1)
 	    if (! (ri->ri_receive & RIPv1))
 	      {
+		#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 		if (IS_RIP_DEBUG_PACKET)
 		  zlog_warn ("  packet's v%d doesn't fit to if version spec", 
 			     packet->version);
+		#endif
 		rip_peer_bad_packet (&from);
 		return -1;
 	      }
 	  if (packet->version == RIPv2)
 	    if (! (ri->ri_receive & RIPv2))
 	      {
+		  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 		if (IS_RIP_DEBUG_PACKET)
 		  zlog_warn ("  packet's v%d doesn't fit to if version spec", 
 			     packet->version);
+		  #endif
 		rip_peer_bad_packet (&from);
 		return -1;
 	      }
@@ -1629,9 +1703,11 @@
       && rtenum 
       && (packet->version == RIPv2) && (packet->rte->family == 0xffff))
     {
+	  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
       if (IS_RIP_DEBUG_EVENT)
 	zlog_warn ("packet RIPv%d is dropped because authentication disabled", 
 		   packet->version);
+	  #endif
       rip_peer_bad_packet (&from);
       return -1;
     }
@@ -1652,8 +1728,10 @@
       /* We follow maximum security. */
       if (packet->version == RIPv1 && packet->rte->family == 0xffff)
 	{
+	  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 	  if (IS_RIP_DEBUG_PACKET)
 	    zlog_warn ("packet RIPv%d is dropped because authentication enabled", packet->version);
+	  #endif
 	  rip_peer_bad_packet (&from);
 	  return -1;
 	}
@@ -1668,15 +1746,19 @@
 		  ret = rip_auth_simple_password (packet->rte, &from, ifp);
 		  if (! ret)
 		    {
+				#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 		      if (IS_RIP_DEBUG_EVENT)
 			zlog_warn ("RIPv2 simple password authentication failed");
+				#endif
 		      rip_peer_bad_packet (&from);
 		      return -1;
 		    }
 		  else
 		    {
+				#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 		      if (IS_RIP_DEBUG_EVENT)
 			zlog_info ("RIPv2 simple password authentication success");
+				#endif
 		    }
                 }
 	      else if (ntohs (packet->rte->tag) == RIP_AUTH_MD5)
@@ -1684,24 +1766,30 @@
 		  ret = rip_auth_md5 (packet, &from, ifp);
 		  if (! ret)
 		    {
+				#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 		      if (IS_RIP_DEBUG_EVENT)
 			zlog_warn ("RIPv2 MD5 authentication failed");
+				#endif
 		      rip_peer_bad_packet (&from);
 		      return -1;
 		    }
 		  else
 		    {
+				#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 		      if (IS_RIP_DEBUG_EVENT)
 			zlog_info ("RIPv2 MD5 authentication success");
+				#endif
 		    }
 		  /* Reset RIP packet length to trim MD5 data. */
 		  len = ret; 
                 }
 	      else
 		{
+			#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 		  if (IS_RIP_DEBUG_EVENT)
 		    zlog_warn ("Unknown authentication type %d",
 			       ntohs (packet->rte->tag));
+			#endif
 		  rip_peer_bad_packet (&from);
 		  return -1;
 		}
@@ -1711,8 +1799,10 @@
 	      /* There is no authentication in the packet. */
 	      if (ri->auth_str || ri->key_chain)
 		{
+			#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 		  if (IS_RIP_DEBUG_EVENT)
 		    zlog_warn ("RIPv2 authentication failed: no authentication in packet");
+			#endif
 		  rip_peer_bad_packet (&from);
 		  return -1;
 		}
@@ -1898,7 +1988,7 @@
   struct prefix_ipv4 classfull;
   int num;
   int rtemax;
-
+	#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
   /* Logging output event. */
   if (IS_RIP_DEBUG_EVENT)
     {
@@ -1908,6 +1998,7 @@
 	zlog_info ("update routes on interface %s ifindex %d",
 		   ifp->name, ifp->ifindex);
     }
+	#endif
 
   /* Set output stream. */
   s = rip->obuf;
@@ -1960,17 +2051,19 @@
 	if (version == RIPv1)
 	  {
 	    memcpy (&classfull, &rp->p, sizeof (struct prefix_ipv4));
-
+		#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 	    if (IS_RIP_DEBUG_PACKET)
 	      zlog_info("%s/%d before RIPv1 mask check ",
 			inet_ntoa (classfull.prefix), classfull.prefixlen);
+		#endif
 
 	    apply_classful_mask_ipv4 (&classfull);
 	    p = &classfull;
-
+		#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 	    if (IS_RIP_DEBUG_PACKET)
 	      zlog_info("%s/%d after RIPv1 mask check",
 			inet_ntoa (p->prefix), p->prefixlen);
+		#endif
 	  }
 	else 
 	  p = (struct prefix_ipv4 *) &rp->p;
@@ -2015,7 +2108,9 @@
 	    && rinfo->type != ZEBRA_ROUTE_CONNECT
 	    && rinfo->ifindex == ifp->ifindex)
 	  rinfo->nexthop_out = rinfo->nexthop;
-           
+  
+   // chandrav -- for removing routemap.c from lib	
+    #ifndef	RIPD_STANDALONE
 	/* Apply route map - continue, if deny */
 	if (rip->route_map[rinfo->type].name
 	    && rinfo->sub_type != RIP_ROUTE_INTERFACE)
@@ -2025,12 +2120,15 @@
 
 	    if (ret == RMAP_DENYMATCH) 
 	      {
+		  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 		if (IS_RIP_DEBUG_PACKET)
 		  zlog_info ("%s/%d is filtered by route-map",
 			     inet_ntoa (p->prefix), p->prefixlen);
+		  #endif
 		continue;
 	      }
 	  }
+	#endif
 
 	/* When route-map does not set metric. */
 	if (! rinfo->metric_set)
@@ -2052,9 +2150,11 @@
 	      }
 	  }
 
+    #ifndef RIPD_STANDALONE
 	/* Apply offset-list */
 	if (rinfo->metric != RIP_METRIC_INFINITY)
 	  rip_offset_list_apply_out (p, ifp, &rinfo->metric_out);
+    #endif
 
 	if (rinfo->metric_out > RIP_METRIC_INFINITY)
 	  rinfo->metric_out = RIP_METRIC_INFINITY;
@@ -2068,10 +2168,11 @@
 
 	    ret = rip_send_packet (STREAM_DATA (s), stream_get_endp (s),
 				   to, ifp);
-
+		#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 	    if (ret >= 0 && IS_RIP_DEBUG_SEND)
 	      rip_packet_dump ((struct rip_packet *)STREAM_DATA (s),
 			       stream_get_endp(s), "SEND");
+		#endif
 	    num = 0;
 	    stream_reset (s);
 	  }
@@ -2084,10 +2185,11 @@
 	rip_auth_md5_set (s, ifp);
 
       ret = rip_send_packet (STREAM_DATA (s), stream_get_endp (s), to, ifp);
-
+	#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
       if (ret >= 0 && IS_RIP_DEBUG_SEND)
 	rip_packet_dump ((struct rip_packet *)STREAM_DATA (s),
 			 stream_get_endp (s), "SEND");
+	#endif
       num = 0;
       stream_reset (s);
     }
@@ -2108,8 +2210,10 @@
   /* When RIP version is 2 and multicast enable interface. */
   if (version == RIPv2 && if_is_multicast (ifp)) 
     {
+		#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
       if (IS_RIP_DEBUG_EVENT)
 	zlog_info ("multicast announce on %s ", ifp->name);
+		#endif
 
       rip_output_process (ifp, NULL, route_type, version);
       return;
@@ -2132,11 +2236,12 @@
 	      memset (&to, 0, sizeof (struct sockaddr_in));
 	      to.sin_addr = p->prefix;
 	      to.sin_port = htons (RIP_PORT_DEFAULT);
-
+		#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 	      if (IS_RIP_DEBUG_EVENT)
 		zlog_info ("%s announce to %s on %s",
 			   if_is_pointopoint (ifp) ? "unicast" : "broadcast",
 			   inet_ntoa (to.sin_addr), ifp->name);
+		#endif
 
 	      rip_output_process (ifp, &to, route_type, version);
 	    }
@@ -2176,6 +2281,7 @@
 
       if (ri->running)
 	{
+	#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 	  if (IS_RIP_DEBUG_EVENT) 
 	    {
 	      if (ifp->name) 
@@ -2185,6 +2291,7 @@
 		zlog_info ("SEND UPDATE to _unknown_ ifindex %d",
 			   ifp->ifindex);
 	    }
+	#endif
 
 	  /* If there is no version configuration in the interface,
              use rip's version setting. */
@@ -2236,9 +2343,10 @@
 {
   /* Clear timer pointer. */
   rip->t_update = NULL;
-
+	#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
   if (IS_RIP_DEBUG_EVENT)
     zlog_info ("update timer fire!");
+	#endif
 
   /* Process update output. */
   rip_update_process (rip_all_route);
@@ -2303,11 +2411,11 @@
       rip->t_triggered_interval = NULL;
     }
   rip->trigger = 0;
-
+	#if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
   /* Logging triggered update. */
   if (IS_RIP_DEBUG_EVENT)
     zlog_info ("triggered update!");
-
+	#endif
   /* Split Horizon processing is done when generating triggered
      updates as well as normal updates (see section 2.6). */
   rip_update_process (rip_changed_route);
@@ -2361,6 +2469,12 @@
 rip_create ()
 {
   rip = XMALLOC (MTYPE_RIP, sizeof (struct rip));
+  #ifdef RIPD_MEMORY_FIX
+  if (!rip) {
+	  return -1;
+  }
+  #endif
+
   memset (rip, 0, sizeof (struct rip));
 
   /* Set initial value. */
@@ -2447,6 +2561,8 @@
     }
 }
 
+#ifndef VTY_REMOVE
+
 DEFUN (router_rip,
        router_rip_cmd,
        "router rip",
@@ -2708,6 +2824,8 @@
   return CMD_SUCCESS;
 }
 
+#endif /* VTY_REMOVE */
+
 struct route_table *rip_distance_table;
 
 struct rip_distance
@@ -2724,6 +2842,12 @@
 {
   struct rip_distance *new;
   new = XMALLOC (MTYPE_RIP_DISTANCE, sizeof (struct rip_distance));
+  #ifdef RIPD_MEMORY_FIX
+  if (!new) {
+  	return NULL;
+  }
+  #endif
+
   memset (new, 0, sizeof (struct rip_distance));
   return new;
 }
@@ -2746,8 +2870,11 @@
 
   ret = str2prefix_ipv4 (ip_str, &p);
   if (ret == 0)
-    {
+    { 
+      #ifndef VTY_REMOVE
       vty_out (vty, "Malformed prefix%s", VTY_NEWLINE);
+      #endif /* VTY_REMOVE */
+
       return CMD_WARNING;
     }
 
@@ -2763,6 +2890,12 @@
   else
     {
       rdistance = rip_distance_new ();
+	  #ifdef RIPD_MEMORY_FIX
+	  if (!rdistance) {
+	  	return CMD_WARNING;
+	  }
+	  #endif
+
       rn->info = rdistance;
     }
 
@@ -2781,6 +2914,8 @@
   return CMD_SUCCESS;
 }
 
+#ifndef VTY_REMOVE
+
 int
 rip_distance_unset (struct vty *vty, char *distance_str, char *ip_str,
 		    char *access_list_str)
@@ -2819,6 +2954,7 @@
 
   return CMD_SUCCESS;
 }
+#endif /* VTY_REMOVE */
 
 void
 rip_distance_reset ()
@@ -2881,6 +3017,8 @@
   return 0;
 }
 
+#ifndef VTY_REMOVE
+
 void
 rip_distance_show (struct vty *vty)
 {
@@ -2938,8 +3076,13 @@
        "Distance value\n"
        "IP source prefix\n")
 {
+  #ifdef RIPD_MEMORY_FIX
+  return rip_distance_set (vty, argv[0], argv[1], NULL);
+  #else
   rip_distance_set (vty, argv[0], argv[1], NULL);
   return CMD_SUCCESS;
+  #endif
+  
 }
 
 DEFUN (no_rip_distance_source,
@@ -2962,8 +3105,12 @@
        "IP source prefix\n"
        "Access list name\n")
 {
+  #ifdef RIPD_MEMORY_FIX
+  return rip_distance_set (vty, argv[0], argv[1], argv[2]);
+  #else
   rip_distance_set (vty, argv[0], argv[1], argv[2]);
   return CMD_SUCCESS;
+  #endif
 }
 
 DEFUN (no_rip_distance_source_access_list,
@@ -3007,6 +3154,7 @@
       vty_out (vty, "%5s", timebuf);
     }
 }
+#endif /* VTY_REMOVE */
 
 char *
 rip_route_type_print (int sub_type)
@@ -3028,6 +3176,8 @@
     }
 }
 
+#ifndef VTY_REMOVE
+
 DEFUN (show_ip_rip,
        show_ip_rip_cmd,
        "show ip rip",
@@ -3088,6 +3238,7 @@
       }
   return CMD_SUCCESS;
 }
+#endif /* VTY_REMOVE */
 
 /* Return next event time. */
 int
@@ -3100,6 +3251,8 @@
   return thread->u.sands.tv_sec - timer_now.tv_sec;
 }
 
+#ifndef VTY_REMOVE
+
 DEFUN (show_ip_protocols_rip,
        show_ip_protocols_rip_cmd,
        "show ip protocols",
@@ -3136,7 +3289,11 @@
 
   /* Redistribute information. */
   vty_out (vty, "  Redistributing:");
+ 
+  #ifndef RIPD_STANDALONE
   config_write_rip_redistribute (vty, 0);
+  #endif
+  
   vty_out (vty, "%s", VTY_NEWLINE);
 
   vty_out (vty, "  Default version control: send version %d,", rip->version);
@@ -3221,12 +3378,16 @@
 	    vty_out (vty, " default-information originate%s",
 		     VTY_NEWLINE);
 	}
-
+	  #ifndef RIPD_STANDALONE
       /* Redistribute configuration. */
       config_write_rip_redistribute (vty, 1);
-
+	  #endif
+      
+	  /* chandrav -- deleting offset -list */
+      #ifndef RIPD_STANDALONE
       /* RIP offset-list configuration. */
       config_write_rip_offset_list (vty);
+      #endif
 
       /* RIP enabled network and interface configuration. */
       config_write_rip_network (vty, 1);
@@ -3262,6 +3423,7 @@
     }
   return write;
 }
+#endif /* VTY_REMOVE  */
 
 /* RIP node structure. */
 struct cmd_node rip_node =
@@ -3439,10 +3601,15 @@
 
   rip_clean_network ();
   rip_passive_interface_clean ();
+  #ifndef RIPD_STANDALONE
   rip_offset_clean ();
+  #endif
   rip_interface_clean ();
   rip_distance_reset ();
+  #ifndef RIPD_STANDALONE
   rip_redistribute_clean ();
+  #endif
+  
 }
 
 /* Reset all values to the default settings. */
@@ -3453,12 +3620,19 @@
   rip_global_route_changes = 0;
   rip_global_queries = 0;
 
+  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
   /* Call ripd related reset functions. */
   rip_debug_reset ();
+  #endif
+  #ifndef RIPD_STANDALONE
   rip_route_map_reset ();
-
+  #endif
+  
+  #ifndef VTY_REMOVE
   /* Call library reset functions. */
   vty_reset ();
+  #endif  /* VTY_REMOVE */
+
   access_list_reset ();
   prefix_list_reset ();
 
@@ -3467,7 +3641,10 @@
   rip_interface_reset ();
   rip_distance_reset ();
 
+  #ifndef RIPD_STANDALONE
   rip_zclient_reset ();
+  #endif
+  
 }
 
 /* Allocate new rip structure and set default value. */
@@ -3477,6 +3654,8 @@
   /* Randomize for triggered update random(). */
   srand (time (NULL));
 
+  #ifndef VTY_REMOVE
+
   /* Install top nodes. */
   install_node (&rip_node, config_write_rip);
 
@@ -3506,12 +3685,18 @@
   install_element (RIP_NODE, &rip_distance_source_access_list_cmd);
   install_element (RIP_NODE, &no_rip_distance_source_access_list_cmd);
 
-  /* Debug related init. */
-  rip_debug_init ();
+  #endif /*  VTY_REMOVE */
 
+  #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
+   /* Debug related init. */
+  rip_debug_init ();
+  #endif
+  
+  #ifndef RIPD_STANDALONE
   /* Filter related init. */
   rip_route_map_init ();
   rip_offset_init ();
+  #endif
 
   /* SNMP init. */
 #ifdef HAVE_SNMP
diff -Naur zebra-0.94/ripd/ripd.h open_zebra/ripd/ripd.h
--- zebra-0.94/ripd/ripd.h	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/ripd/ripd.h	2009-11-13 19:47:58.620705000 +0530
@@ -366,6 +366,10 @@
 int if_check_address (struct in_addr addr);
 int if_valid_neighbor (struct in_addr addr);
 
+#ifdef RIPD_STANDALONE
+int rip_create ();
+#endif
+
 int rip_request_send (struct sockaddr_in *, struct interface *, u_char);
 int rip_neighbor_lookup (struct sockaddr_in *);
 void rip_redistribute_add (int, int, struct prefix_ipv4 *, unsigned int, 
@@ -379,7 +383,11 @@
 
 int config_write_rip_network (struct vty *, int);
 int config_write_rip_offset_list (struct vty *);
+
+#ifndef RIPD_STANDALONE
 int config_write_rip_redistribute (struct vty *, int);
+#endif
+
 
 void rip_peer_init ();
 void rip_peer_update (struct sockaddr_in *, u_char);
@@ -409,4 +417,9 @@
 extern long rip_global_route_changes;
 extern long rip_global_queries;
 
+//chandrav added to remove vty code
+#ifdef VTY_REMOVE
+void rip_read_config(char *config_file, char *config_current_dir, char *config_default_dir);
+#endif
+
 #endif /* _ZEBRA_RIP_H */
diff -Naur zebra-0.94/ripngd/Makefile.am open_zebra/ripngd/Makefile.am
--- zebra-0.94/ripngd/Makefile.am	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/ripngd/Makefile.am	2009-11-13 19:47:58.662700000 +0530
@@ -4,6 +4,9 @@
 DEFS = @DEFS@ -DSYSCONFDIR=\"$(sysconfdir)/\"
 INSTALL_SDATA=@INSTALL@ -m 600
 
+LDFLAGS = @LDFLAGS@ $(IFX_LDFLAGS)
+CFLAGS = @CFLAGS@ $(IFX_CFLAGS)
+
 noinst_LIBRARIES = libripng.a
 sbin_PROGRAMS = ripngd
 
diff -Naur zebra-0.94/version.h open_zebra/version.h
--- zebra-0.94/version.h	1970-01-01 05:30:00.000000000 +0530
+++ open_zebra/version.h	2009-11-13 19:47:58.739703000 +0530
@@ -0,0 +1,3 @@
+#include "lib/version.h"
+#define APP_NAME 	"Zebra"
+#define APP_VER		"0.94-IFX"
diff -Naur zebra-0.94/vtysh/Makefile.am open_zebra/vtysh/Makefile.am
--- zebra-0.94/vtysh/Makefile.am	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/vtysh/Makefile.am	2009-11-13 19:47:58.745700000 +0530
@@ -5,6 +5,9 @@
 
 LIBS = @LIBS@ @CURSES@ @LIBPAM@
 
+LDFLAGS = @LDFLAGS@ $(IFX_LDFLAGS)
+CFLAGS = @CFLAGS@ $(IFX_CFLAGS)
+
 bin_PROGRAMS = vtysh
 
 vtysh_SOURCES = vtysh_main.c vtysh.c vtysh_cmd.c vtysh_user.c vtysh_config.c
diff -Naur zebra-0.94/zebra/Makefile.am open_zebra/zebra/Makefile.am
--- zebra-0.94/zebra/Makefile.am	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/zebra/Makefile.am	2009-11-13 19:47:58.802710000 +0530
@@ -14,6 +14,9 @@
 kernel_method = @KERNEL_METHOD@
 other_method = @OTHER_METHOD@
 
+LDFLAGS = @LDFLAGS@ $(IFX_LDFLAGS)
+CFLAGS = @CFLAGS@ $(IFX_CFLAGS)
+
 otherobj = $(ipforward) $(if_method) $(if_proc) $(rt_method) \
 	$(rtread_method) $(kernel_method) $(other_method)
 
diff -Naur zebra-0.94/zebra/connected.c open_zebra/zebra/connected.c
--- zebra-0.94/zebra/connected.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/zebra/connected.c	2009-11-13 19:47:58.805709000 +0530
@@ -83,8 +83,11 @@
     return;
 
   rib_add_ipv4 (ZEBRA_ROUTE_CONNECT, 0, &p, NULL, ifp->ifindex, 0, 0, 0);
-
+  
+  #ifndef RIPD_STANDALONE
   rib_update ();
+  #endif
+  
 }
 
 /* Add connected IPv4 route to the interface. */
@@ -177,7 +180,9 @@
 
   rib_delete_ipv4 (ZEBRA_ROUTE_CONNECT, 0, &p, NULL, ifp->ifindex, 0);
 
+  #ifndef RIPD_STANDALONE
   rib_update ();
+  #endif
 }
 
 /* Delete connected IPv4 route to the interface. */
@@ -267,7 +272,9 @@
 
   rib_add_ipv6 (ZEBRA_ROUTE_CONNECT, 0, &p, NULL, ifp->ifindex, 0);
 
+  #ifndef RIPD_STANDALONE
   rib_update ();
+  #endif
 }
 
 /* Add connected IPv6 route to the interface. */
@@ -356,7 +363,9 @@
 
   rib_delete_ipv6 (ZEBRA_ROUTE_CONNECT, 0, &p, NULL, ifp->ifindex, 0);
 
+  #ifndef RIPD_STANDALONE
   rib_update ();
+  #endif
 }
 
 void
diff -Naur zebra-0.94/zebra/debug.c open_zebra/zebra/debug.c
--- zebra-0.94/zebra/debug.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/zebra/debug.c	2009-11-13 19:47:58.810697000 +0530
@@ -29,6 +29,8 @@
 unsigned long zebra_debug_packet;
 unsigned long zebra_debug_kernel;
 
+#ifndef VTY_REMOVE
+
 DEFUN (show_debugging_zebra,
        show_debugging_zebra_cmd,
        "show debugging zebra",
@@ -192,6 +194,7 @@
   zebra_debug_kernel = 0;
   return CMD_SUCCESS;
 }
+#endif /* VTY_REMOVE */
 
 /* Debug node. */
 struct cmd_node debug_node =
@@ -201,6 +204,8 @@
   1
 };
 
+#ifndef VTY_REMOVE
+
 int
 config_write_debug (struct vty *vty)
 {
@@ -240,12 +245,14 @@
     }
   return write;
 }
+#endif /* VTY_REMOVE */
 
 void
 zebra_debug_init ()
 {
   zebra_debug_event = 0;
   zebra_debug_packet = 0;
+  #ifndef VTY_REMOVE
 
   install_node (&debug_node, config_write_debug);
 
@@ -269,4 +276,6 @@
   install_element (CONFIG_NODE, &no_debug_zebra_events_cmd);
   install_element (CONFIG_NODE, &no_debug_zebra_packet_cmd);
   install_element (CONFIG_NODE, &no_debug_zebra_kernel_cmd);
+  #endif  /* VTY_REMOVE */
+
 }
diff -Naur zebra-0.94/zebra/interface.c open_zebra/zebra/interface.c
--- zebra-0.94/zebra/interface.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/zebra/interface.c	2009-11-13 19:47:58.823725000 +0530
@@ -61,6 +61,7 @@
     }
 }
 
+#ifndef RIPD_STANDALONE
 /* Called when new interface is added. */
 int
 if_zebra_new_hook (struct interface *ifp)
@@ -108,6 +109,7 @@
     XFREE (MTYPE_TMP, ifp->info);
   return 0;
 }
+#endif
 
 /* Wake up configured address if it is not in current kernel
    address. */
@@ -189,15 +191,29 @@
       SET_FLAG (ifp->status, ZEBRA_INTERFACE_ACTIVE);
 
       if_addr_wakeup (ifp);
-
+    #ifndef RIPD_STANDALONE
       if (IS_ZEBRA_DEBUG_KERNEL)
 	zlog_info ("interface %s index %d becomes active.", 
 		   ifp->name, ifp->ifindex);
+    #else
+      #ifdef DEBUG_RIPD_STANDALONE
+	     if (IS_ZEBRA_DEBUG_KERNEL)
+		zlog_info ("interface %s index %d becomes active.", 
+		   ifp->name, ifp->ifindex);
+      #endif
+    #endif
     }
   else
     {
+	#ifndef RIPD_STANDALONE
       if (IS_ZEBRA_DEBUG_KERNEL)
 	zlog_info ("interface %s index %d is added.", ifp->name, ifp->ifindex);
+	#else  
+		#ifdef DEBUG_RIPD_STANDALONE
+	        if (IS_ZEBRA_DEBUG_KERNEL)
+		zlog_info ("interface %s index %d is added.", ifp->name, ifp->ifindex);
+		#endif
+    #endif
     }
 }
 
@@ -219,10 +235,18 @@
 
   /* Mark interface as inactive */
   UNSET_FLAG (ifp->status, ZEBRA_INTERFACE_ACTIVE);
-  
+  #ifndef RIPD_STANDALONE
   if (IS_ZEBRA_DEBUG_KERNEL)
     zlog_info ("interface %s index %d is now inactive.",
 	       ifp->name, ifp->ifindex);
+  #else  
+		#ifdef DEBUG_RIPD_STANDALONE
+		  if (IS_ZEBRA_DEBUG_KERNEL)
+		    zlog_info ("interface %s index %d is now inactive.",
+			       ifp->name, ifp->ifindex);
+		#endif
+  #endif
+  
 
   /* Delete connected routes from the kernel. */
   if (ifp->connected)
@@ -284,8 +308,11 @@
 	}
     }
 
+  #ifndef RIPD_STANDALONE
   /* Examine all static routes. */
   rib_update ();
+  #endif
+  
 }
 
 /* Interface goes down.  We have to manage different behavior of based
@@ -318,9 +345,12 @@
 #endif /* HAVE_IPV6 */
 	}
     }
-
+  
+  #ifndef RIPD_STANDALONE
   /* Examine all static routes which direct to the interface. */
   rib_update ();
+  #endif
+  
 }
 
 void
@@ -340,6 +370,8 @@
     }
 }
 
+#ifndef VTY_REMOVE
+
 /* Printout flag information into vty */
 void
 if_flag_dump_vty (struct vty *vty, unsigned long flag)
@@ -609,6 +641,7 @@
 #endif /* __bsdi__ || __NetBSD__ */
 #endif /* HAVE_NET_RT_IFLIST */
 }
+#endif /* VTY_REMOVE */
 
 /* Check supported address family. */
 int
@@ -623,6 +656,7 @@
   return 0;
 }
 
+#ifndef RIPD_STANDALONE
 /* Wrapper hook point for zebra daemon so that ifindex can be set 
  * DEFUN macro not used as extract.pl HAS to ignore this
  * See also interface_cmd in lib/if.c
@@ -681,6 +715,7 @@
 
   return CMD_SUCCESS;
 } 
+#endif
 
 struct cmd_node interface_node =
 {
@@ -688,6 +723,7 @@
   "%s(config-if)# ",
   1
 };
+#ifndef VTY_REMOVE
 
 /* Show all or specified interface to vty. */
 DEFUN (show_interface, show_interface_cmd,
@@ -1341,7 +1377,9 @@
     }
   return 0;
 }
+#endif /*  VTY_REMOVE */
 
+#ifndef RIPD_STANDALONE
 /* Allocate and initialize interface vector. */
 void
 zebra_if_init ()
@@ -1350,7 +1388,8 @@
   if_init ();
   if_add_hook (IF_NEW_HOOK, if_zebra_new_hook);
   if_add_hook (IF_DELETE_HOOK, if_zebra_delete_hook);
-  
+
+  #ifndef VTY_REMOVE  
   /* Install configuration write function. */
   install_node (&interface_node, if_config_write);
 
@@ -1384,4 +1423,9 @@
   install_element (INTERFACE_NODE, &no_ip_address_secondary_cmd);
   install_element (INTERFACE_NODE, &no_ip_address_label_cmd);
 #endif /* HAVE_NETLINK */
+
+#endif  /*  VTY_REMOVE */
+
 }
+#endif
+
diff -Naur zebra-0.94/zebra/main.c open_zebra/zebra/main.c
--- zebra-0.94/zebra/main.c	2003-11-04 23:30:42.000000000 +0530
+++ open_zebra/zebra/main.c	2009-11-13 19:47:58.875724000 +0530
@@ -256,7 +256,10 @@
   /* Zebra related initialize. */
   zebra_init ();
   rib_init ();
+  #ifndef RIPD_STANDALONE
   zebra_if_init ();
+  #endif
+  
   zebra_debug_init ();
   zebra_vty_init ();
   access_list_init ();
diff -Naur zebra-0.94/zebra/rt_netlink.c open_zebra/zebra/rt_netlink.c
--- zebra-0.94/zebra/rt_netlink.c	2003-11-27 05:38:49.000000000 +0530
+++ open_zebra/zebra/rt_netlink.c	2009-11-13 19:47:58.893702000 +0530
@@ -228,6 +228,7 @@
               /* If the error field is zero, then this is an ACK */
               if (err->error == 0) 
                 {
+ 			      #ifndef RIPD_STANDALONE
                   if (IS_ZEBRA_DEBUG_KERNEL) 
                     {  
                       zlog_info("%s: %s ACK: type=%s(%u), seq=%u, pid=%d", 
@@ -236,6 +237,20 @@
                         err->msg.nlmsg_type, err->msg.nlmsg_seq,
 		        err->msg.nlmsg_pid);
                     }
+				  	#else  
+					#ifdef DEBUG_RIPD_STANDALONE
+			                if (IS_ZEBRA_DEBUG_KERNEL) 
+	                    {  
+    	                  zlog_info("%s: %s ACK: type=%s(%u), seq=%u, pid=%d", 
+        	                __FUNCTION__, nl->name,
+            	            lookup (nlmsg_str, err->msg.nlmsg_type),
+                	        err->msg.nlmsg_type, err->msg.nlmsg_seq,
+			        err->msg.nlmsg_pid);
+    	                }
+
+					#endif
+
+  				  #endif
                 
                   /* return if not a multipart message, otherwise continue */  
                   if(!(h->nlmsg_flags & NLM_F_MULTI)) 
@@ -262,20 +277,33 @@
 	      */
 	      return -1;
 	    }
-
+      #ifndef RIPD_STANDALONE
 	  /* OK we got netlink message. */
 	  if (IS_ZEBRA_DEBUG_KERNEL)
 	    zlog_info ("netlink_parse_info: %s type %s(%u), seq=%u, pid=%d",
 		      nl->name,
 		      lookup (nlmsg_str, h->nlmsg_type), h->nlmsg_type,
 		      h->nlmsg_seq, h->nlmsg_pid);
+	  	#else  
+		#ifdef DEBUG_RIPD_STANDALONE
+		  if (IS_ZEBRA_DEBUG_KERNEL)
+		    zlog_info ("netlink_parse_info: %s type %s(%u), seq=%u, pid=%d",
+			      nl->name,
+			      lookup (nlmsg_str, h->nlmsg_type), h->nlmsg_type,
+			      h->nlmsg_seq, h->nlmsg_pid);
+		#endif
+
+	  #endif
+	  
 
 	  /* skip unsolicited messages originating from command socket */
 	  if (nl != &netlink_cmd && h->nlmsg_pid == netlink_cmd.snl.nl_pid)
 	    {
+		  #if  !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
 	      if (IS_ZEBRA_DEBUG_KERNEL)
 		zlog_info ("netlink_parse_info: %s packet comes from %s",
 			  nl->name, netlink_cmd.name);
+		  #endif
 	      continue;
 	    }
 
@@ -569,6 +597,11 @@
       p.family = AF_INET;
       memcpy (&p.prefix, dest, 4);
       p.prefixlen = rtm->rtm_dst_len;
+      //chandrav
+      #if defined(RIPD_STANDALONE) && defined(DEBUG_RIPD_STANDALONE)
+	  if (IS_ZEBRA_DEBUG_KERNEL)
+	    zlog_info("RIPDS:netlink_routing_table:Calling rib_add_ipv4..");
+      #endif
 
       rib_add_ipv4 (ZEBRA_ROUTE_KERNEL, flags, &p, gate, index, table, 0, 0);
     }
@@ -627,6 +660,7 @@
       return 0;
     }
 
+  #if  !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
   /* Connected route. */
   if (IS_ZEBRA_DEBUG_KERNEL)
     zlog_info ("%s %s %s proto %s",
@@ -634,6 +668,8 @@
 	       rtm->rtm_family == AF_INET ? "ipv4" : "ipv6",
 	       rtm->rtm_type == RTN_UNICAST ? "unicast" : "multicast",
 	       lookup (rtproto_str, rtm->rtm_protocol));
+  #endif
+  
 
   if (rtm->rtm_type != RTN_UNICAST)
     {
@@ -690,7 +726,7 @@
       p.family = AF_INET;
       memcpy (&p.prefix, dest, 4);
       p.prefixlen = rtm->rtm_dst_len;
-
+    #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
       if (IS_ZEBRA_DEBUG_KERNEL)
 	{
 	  if (h->nlmsg_type == RTM_NEWROUTE)
@@ -700,6 +736,7 @@
 	    zlog_info ("RTM_DELROUTE %s/%d",
 		       inet_ntoa (p.prefix), p.prefixlen);
 	}
+    #endif
 
       if (h->nlmsg_type == RTM_NEWROUTE)
 	rib_add_ipv4 (ZEBRA_ROUTE_KERNEL, 0, &p, gate, index, table, 0, 0);
@@ -716,7 +753,8 @@
       p.family = AF_INET6;
       memcpy (&p.prefix, dest, 16);
       p.prefixlen = rtm->rtm_dst_len;
-
+    
+    #if  !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
       if (IS_ZEBRA_DEBUG_KERNEL)
 	{
 	  if (h->nlmsg_type == RTM_NEWROUTE)
@@ -728,6 +766,8 @@
 		       inet_ntop (AF_INET6, &p.prefix, buf, BUFSIZ),
 		       p.prefixlen);
 	}
+    #endif
+	  
 
       if (h->nlmsg_type == RTM_NEWROUTE)
 	rib_add_ipv6 (ZEBRA_ROUTE_KERNEL, 0, &p, gate, index, 0);
@@ -829,24 +869,53 @@
 int
 netlink_information_fetch (struct sockaddr_nl *snl, struct nlmsghdr *h)
 {
-  switch (h->nlmsg_type)
+   #if defined(RIPD_STANDALONE) && defined(DEBUG_RIPD_STANDALONE)
+	  if (IS_ZEBRA_DEBUG_KERNEL)
+	    zlog_info("RIPDS:inside netlink_information_fetch..");
+   #endif
+
+   switch (h->nlmsg_type)
     {
     case RTM_NEWROUTE:
+	 #if defined(RIPD_STANDALONE) && defined(DEBUG_RIPD_STANDALONE)
+	  if (IS_ZEBRA_DEBUG_KERNEL)
+	    zlog_info("RIPDS:RTM_NEWROUTE..");
+     #endif
       return netlink_route_change (snl, h);
       break;
     case RTM_DELROUTE:
+	 #if defined(RIPD_STANDALONE) && defined(DEBUG_RIPD_STANDALONE)
+	  if (IS_ZEBRA_DEBUG_KERNEL)
+	    zlog_info("RIPDS:RTM_DELROUTE..");
+     #endif
       return netlink_route_change (snl, h);
       break;
     case RTM_NEWLINK:
+  	 #if defined(RIPD_STANDALONE) && defined(DEBUG_RIPD_STANDALONE)
+	  if (IS_ZEBRA_DEBUG_KERNEL)
+	    zlog_info("RIPDS:RTM_NEWLINK..");
+     #endif
       return netlink_link_change (snl, h);
       break;
     case RTM_DELLINK:
+  	 #if defined(RIPD_STANDALONE) && defined(DEBUG_RIPD_STANDALONE)
+	  if (IS_ZEBRA_DEBUG_KERNEL)
+	    zlog_info("RIPDS:RTM_DELLINK..");
+     #endif
       return netlink_link_change (snl, h);
       break;
     case RTM_NEWADDR:
+  	 #if defined(RIPD_STANDALONE) && defined(DEBUG_RIPD_STANDALONE)
+	  if (IS_ZEBRA_DEBUG_KERNEL)
+	    zlog_info("RIPDS:RTM_NEWADDR..");
+     #endif
       return netlink_interface_addr (snl, h);
       break;
     case RTM_DELADDR:
+  	 #if defined(RIPD_STANDALONE) && defined(DEBUG_RIPD_STANDALONE)
+	  if (IS_ZEBRA_DEBUG_KERNEL)
+	    zlog_info("RIPDS:RTM_DELADDR..");
+     #endif
       return netlink_interface_addr (snl, h);
       break;
     default:
@@ -1007,11 +1076,13 @@
 
   /* Request an acknowledgement by setting NLM_F_ACK */
   n->nlmsg_flags |= NLM_F_ACK;
-  
+  #if  !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
   if (IS_ZEBRA_DEBUG_KERNEL) 
     zlog_info ("netlink_talk: %s type %s(%u), seq=%u", netlink_cmd.name,
 	      lookup (nlmsg_str, n->nlmsg_type), n->nlmsg_type,
 	      n->nlmsg_seq);
+  #endif
+  
 
   /* Send message to netlink interface. */
   status = sendmsg (nl->sock, &msg, 0);
@@ -1341,8 +1412,12 @@
   /* If there is no useful nexthop then return. */
   if (nexthop_num == 0)
     {
+	
+    #if !defined(RIPD_STANDALONE) || defined(DEBUG_RIPD_STANDALONE)
       if (IS_ZEBRA_DEBUG_KERNEL)
 	zlog_info ("netlink_route_multipath(): No useful nexthop.");
+    #endif
+	  
       return 0;
     }
 
@@ -1467,6 +1542,11 @@
 {
   int ret;
   int sock;
+  //chandrav
+  #if defined(RIPD_STANDALONE) && defined(DEBUG_RIPD_STANDALONE)
+	 if (IS_ZEBRA_DEBUG_KERNEL)
+		zlog_info("RIPDS:in kernel_read");
+  #endif
 
   sock = THREAD_FD (thread);
   ret = netlink_parse_info (netlink_information_fetch, &netlink);
@@ -1488,6 +1568,11 @@
 #endif /* HAVE_IPV6 */
   netlink_socket (&netlink, groups);
   netlink_socket (&netlink_cmd, 0);
+  //chandrav
+  #if defined(RIPD_STANDALONE) && defined(DEBUG_RIPD_STANDALONE)
+	 if (IS_ZEBRA_DEBUG_KERNEL)
+		zlog_info("RIPDS:in kernel_init");
+  #endif
 
   /* Register kernel socket. */
   if (netlink.sock > 0)
