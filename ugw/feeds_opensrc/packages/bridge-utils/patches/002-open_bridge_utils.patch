diff -Naur bridge-utils-1.4/.gitignore open_bridge_utils/.gitignore
--- bridge-utils-1.4/.gitignore	2008-01-08 21:50:35.000000000 +0530
+++ open_bridge_utils/.gitignore	1970-01-01 05:30:00.000000000 +0530
@@ -1,35 +0,0 @@
-#
-# NOTE! Don't add files that are generated in specific
-# subdirectories here. Add them in the ".gitignore" file
-# in that subdirectory instead.
-#
-# Normal rules
-#
-.*
-*.o
-*.o.*
-*.a
-*.s
-*.so
-
-# Generated by configure
-Makefile
-bridge-utils.spec
-configure
-config.*
-
-#
-# Top-level generic files
-#
-tags
-TAGS
-
-# quilt's files
-patches
-series
-
-# cscope files
-cscope.*
-
-*.orig
-*.rej
diff -Naur bridge-utils-1.4/brctl/brctld.c open_bridge_utils/brctl/brctld.c
--- bridge-utils-1.4/brctl/brctld.c	1970-01-01 05:30:00.000000000 +0530
+++ open_bridge_utils/brctl/brctld.c	2009-11-03 10:05:20.133131000 +0530
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2000 Lennert Buytenhek
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <netinet/in.h>
+#include <signal.h>
+#include <sys/resource.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#include <asm/param.h>
+#include "libbridge.h"
+#include "brctl.h"
+
+char *help_message =
+"addbr\t\t\t\t\tadd bridge\n"
+"addif\t\t\t<device>\tadd interface to bridge\n"
+"bridge\t\t\t<bridge>\tselect bridge to work in\n"
+"delbr\t\t\t\t\tdelete bridge\n"
+"delif\t\t\t<device>\tdelete interface from bridge\n"
+"setageing\t\t<time>\t\tset ageing time\n"
+"setbridgeprio\t\t<prio>\t\tset bridge priority\n"
+"setfd\t\t\t<time>\t\tset bridge forward delay\n"
+"setgcint\t\t<time>\t\tset garbage collection interval\n"
+"sethello\t\t<time>\t\tset hello time\n"
+"setmaxage\t\t<time>\t\tset max message age\n"
+"setpathcost\t\t<port> <cost>\tset path cost\n"
+"setportprio\t\t<port> <prio>\tset port priority\n"
+"show\t\t\t\t\tshow a list of bridges\n"
+"showmacs\t\t\t\tshow a list of mac addrs\n"
+"showstp\t\t\t\t\tshow bridge stp info\n"
+"stp\t\t\t<state>\t\tturn stp on/off\n"
+"quit\t\t\t\t\texit this session\n"
+"\n";
+
+void help()
+{
+	fprintf(stderr, help_message);
+}
+
+struct bridge *br = NULL;
+
+int forkaway()
+{
+	int f;
+
+	f = fork();
+	if (f < 0) {
+		perror("fork");
+		exit(-1);
+	}
+
+	return f;
+}
+
+void runchild(int sock)
+{
+	char hostname[128];
+
+	if (forkaway())
+		return;
+
+	/* Hack. */
+	close(0); dup(sock);
+	close(1); dup(sock);
+	close(2); dup(sock);
+
+	br_init();
+	gethostname(hostname, 128);
+
+	printf("\n\n\n\n");
+	printf("brctld\t\tCopyright (C) 2000 Lennert Buytenhek <buytenh@gnu.org>\n");
+	printf("======================================================================");
+	printf("\n\n\n\n");
+
+	while (1) {
+		char arg0[128];
+		char arg1[128];
+		char cmd[128];
+		struct command *cmdptr;
+		char line[1024];
+		int numcmd;
+
+		printf("<%s> ", hostname);
+		fflush(stdout);
+		line[1023] = 0;
+		fgets(line, 1023, stdin);
+		while (strlen(line) > 0 &&
+		       (line[strlen(line)-1] == '\r' ||
+			line[strlen(line)-1] == '\n'))
+			line[strlen(line)-1] = 0;
+
+		numcmd = sscanf(line, "%s %s %s", cmd, arg0, arg1);
+
+		if (!strcmp(cmd, "help")) {
+			help();
+			continue;
+		} else if (!strcmp(cmd, "bridge")) {
+			if (numcmd != 2) {
+				fprintf(stderr, "invalid number of arguments\n");
+				continue;
+			}
+
+			br = br_find_bridge(arg0);
+			if (br != NULL)
+				printf("now using bridge %s\n\n", arg0);
+			else
+				printf("can't find bridge %s\n\n", arg0);
+			continue;
+		} else if (!strcmp(cmd, "quit")) {
+			break;
+		}
+
+		if ((cmdptr = br_command_lookup(cmd)) == NULL) {
+			printf("unknown command '%s'\n\n", line);
+			continue;
+		}
+
+		if (cmdptr->needs_bridge_argument && br == NULL) {
+			printf("this command needs a bridge\n\n");
+			continue;
+		}
+
+		br_refresh();
+		cmdptr->func(br, arg0, arg1);
+		printf("\n");
+	}
+
+	shutdown(sock, 2);
+	exit(0);
+}
+
+void sigchild(int sig)
+{
+	int status;
+
+	wait3(&status, WNOHANG, NULL);
+}
+
+int main(int argc, char *argv[])
+{
+	struct sockaddr_in addr;
+	int sock;
+	int x;
+
+	if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+		perror("socket");
+		return 1;
+	}
+
+	x = 1;
+	if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &x, sizeof(x)) < 0) {
+		perror("setsockopt");
+		return 1;
+	}
+
+	addr.sin_family = AF_INET;
+	addr.sin_addr.s_addr = htonl(INADDR_ANY);
+	addr.sin_port = htons(31338);
+	if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		perror("bind");
+		return 1;
+	}
+
+	if (listen(sock, 1) < 0) {
+		perror("listen");
+		return 1;
+	}
+
+	if (forkaway())
+		return 0;
+
+	setsid();
+	signal(SIGCHLD, sigchild);
+
+	while (1) {
+		int len;
+		int newsock;
+
+		len = sizeof(addr);
+		if ((newsock = accept(sock, (struct sockaddr *)&addr, &len)) < 0) {
+			perror("accept");
+			return 1;
+		}
+
+		runchild(newsock);
+	}
+
+	return 0;
+}
diff -Naur bridge-utils-1.4/build.sh open_bridge_utils/build.sh
--- bridge-utils-1.4/build.sh	1970-01-01 05:30:00.000000000 +0530
+++ open_bridge_utils/build.sh	2009-11-03 10:05:20.378058000 +0530
@@ -0,0 +1,55 @@
+#!/bin/sh
+
+APPS_NAME="bridge-utils 1.4"
+
+if [ -e sysconfig.sh ]; then
+	. sysconfig.sh
+	. config.sh
+	. model_config.sh
+else
+        echo "Application "$APPS_NAME" not configured"
+        exit 0
+fi
+
+display_info "----------------------------------------------------------------------"
+display_info "----------------------- build $APPS_NAME ------------------------"
+display_info "----------------------------------------------------------------------"
+
+parse_args $@
+
+if [ $BUILD_CLEAN -eq 1 ]; then
+	rm -rf .config_ok
+	make -s distclean
+	find . -name Makefile | xargs rm -rf
+	rm -rf install_sh missing mkinstalldirs autom4te.cache config.log
+	rm -f config.cache
+	rm -f aclocal.m4
+	rm -f config.h.in
+	rm -f configure
+	[ ! $BUILD_CONFIGURE -eq 1 ] && exit 0
+fi
+
+if [ "$1" = "config_only" -a ! -f .config_ok -o $BUILD_CONFIGURE -eq 1 ]; then
+	aclocal
+	autoheader
+	autoconf
+	automake --foreign --add-missing
+	AR=${IFX_AR} AS=${IFX_AS} LD=${IFX_LD} NM=${IFX_NM} CC=${IFX_CC} BUILDCC=${IFX_HOSTCC} CXX=${IFX_CXX} RANLIB=${IFX_RANLIB} OBJCOPY=${IFX_OBJCOPY} OBJDUMP=${IFX_OBJDUMP} TARGET=${TARGET} HOST=${HOST} BUILD=${BUILD} CFLAGS="${IFX_CFLAGS}" ./configure --target=${TARGET} --host=${HOST} --build=${BUILD} --prefix=/usr --with-linux-headers=./kenrel/include
+	ifx_error_check $? 
+	echo -n > .config_ok
+fi
+
+if [ "$1" = "config_only" ] ;then
+	exit 0
+fi
+
+make -s IFX_CFLAGS="${IFX_CFLAGS}" IFX_LDFLAGS="${IFX_LDFLAGS}"
+ifx_error_check $? 
+
+${IFX_STRIP} brctl/brctl
+ifx_error_check $? 
+
+install -d ${BUILD_ROOTFS_DIR}/usr/sbin/
+cp -f brctl/brctl ${BUILD_ROOTFS_DIR}/usr/sbin/.
+ifx_error_check $?
+
diff -Naur bridge-utils-1.4/ifx_make.mk open_bridge_utils/ifx_make.mk
--- bridge-utils-1.4/ifx_make.mk	1970-01-01 05:30:00.000000000 +0530
+++ open_bridge_utils/ifx_make.mk	2009-11-03 10:05:21.835983000 +0530
@@ -0,0 +1,70 @@
+include .app_configured
+
+ifeq ($(MAKE_USED),1)
+include $(INCLUDE_DIR)/Rules.mk
+include $(INCLUDE_DIR)/Makefile.common
+
+APP_NAME=bridge_utils
+APP_TYPE=OPEN
+APP_VER=1.4-IFX
+CONFIG_FULL_PACKAGE=y
+
+all: configure compile install
+
+define menuconfig
+config FEATURE_BRIDGE_UTILS
+	bool 'bridge-utils'
+	help
+	  bridge_utils
+endef
+
+define configure
+        aclocal
+        autoheader
+        autoconf
+        -automake --foreign --add-missing
+        $(BUILD_FLAGS) ./configure --target=$(TARGET) --host=$(HOST) \
+	--build=$(BUILD) --prefix=/usr --with-linux-headers=$(KERNEL_SOURCE_DIR)/include \
+	IFX_CFLAGS="$(IFX_CFLAGS)" IFX_LDFLAGS="$(IFX_LDFLAGS)"
+endef
+
+define compile
+        $(MAKE) $(BUILD_FLAGS) IFX_CFLAGS="$(IFX_CFLAGS)" IFX_LDFLAGS="$(IFX_LDFLAGS)"
+	$(IFX_STRIP) $(USER_OPENSOURCE_DIR)/bridge_utils/brctl/brctl
+endef
+
+define install
+        install -d $(BUILD_ROOTFS_DIR)/usr/sbin
+	cp -f $(USER_OPENSOURCE_DIR)/bridge_utils/brctl/brctl $(BUILD_ROOTFS_DIR)/usr/sbin/.
+endef
+
+define clean
+	if [ -e Makefile ];then \
+		$(MAKE) clean; \
+	fi
+endef
+
+define distclean
+	if [ -e Makefile ];then \
+		$(MAKE) -s distclean; \
+	fi
+	rm -rf install_sh missing mkinstalldirs autom4te.cache config.log
+        rm -rf autom4te.cache
+        rm -f config.cache
+        rm -f aclocal.m4
+        rm -f config.h.in
+        rm -f configure
+        find . -name Makefile | xargs rm -rf
+        find . -name bridge-utils.spec | xargs rm -f
+endef
+
+$(eval $(call define_eval_application))
+
+else
+export MAKE_USED=1
+all configure %:
+	@$(MAKE) -s -C $(BUILD_TOOLS_DIR) make_installed
+	@$(BUILD_TOOLS_DIR)/tmp/bin/make -f ifx_make.mk $@
+
+.PHONY: configure
+endif
diff -Naur bridge-utils-1.4/libbridge/config.h open_bridge_utils/libbridge/config.h
--- bridge-utils-1.4/libbridge/config.h	1970-01-01 05:30:00.000000000 +0530
+++ open_bridge_utils/libbridge/config.h	2009-11-03 10:05:21.275987000 +0530
@@ -0,0 +1,77 @@
+/* libbridge/config.h.  Generated by configure.  */
+/* libbridge/config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define to 1 if you have the `gethostname' function. */
+#define HAVE_GETHOSTNAME 1
+
+/* Define to 1 if you have the `if_indextoname' function. */
+#define HAVE_IF_INDEXTONAME 1
+
+/* Define to 1 if you have the `if_nametoindex' function. */
+#define HAVE_IF_NAMETOINDEX 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `socket' function. */
+#define HAVE_SOCKET 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strdup' function. */
+#define HAVE_STRDUP 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the `uname' function. */
+#define HAVE_UNAME 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "bridge-utils"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "bridge-utils 1.2"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "bridge-utils"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.2"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
diff -Naur bridge-utils-1.4/libbridge/if_index.c open_bridge_utils/libbridge/if_index.c
--- bridge-utils-1.4/libbridge/if_index.c	1970-01-01 05:30:00.000000000 +0530
+++ open_bridge_utils/libbridge/if_index.c	2009-11-03 10:05:20.969056000 +0530
@@ -0,0 +1,259 @@
+/* Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <net/if.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+//#include <bits/libc-lock.h>
+
+/* Try to get a socket to talk to the kernel.  */
+#if defined SIOCGIFINDEX || defined SIOCGIFNAME
+static int
+internal_function
+opensock (void)
+{
+  /* Cache the last AF that worked, to avoid many redundant calls to
+     socket().  */
+  static int sock_af = -1;
+  int fd = -1;
+  __libc_lock_define_initialized (static, lock);
+
+  if (sock_af != -1)
+    {
+      fd = __socket (sock_af, SOCK_DGRAM, 0);
+      if (fd != -1)
+        return fd;
+    }
+
+  __libc_lock_lock (lock);
+
+  if (sock_af != -1)
+    fd = __socket (sock_af, SOCK_DGRAM, 0);
+
+  if (fd == -1)
+    {
+      fd = __socket (sock_af = AF_INET6, SOCK_DGRAM, 0);
+      if (fd < 0)
+	fd = __socket (sock_af = AF_INET, SOCK_DGRAM, 0);
+      if (fd < 0)
+	fd = __socket (sock_af = AF_IPX, SOCK_DGRAM, 0);
+      if (fd < 0)
+	fd = __socket (sock_af = AF_AX25, SOCK_DGRAM, 0);
+      if (fd < 0)
+	fd = __socket (sock_af = AF_APPLETALK, SOCK_DGRAM, 0);
+    }
+
+  __libc_lock_unlock (lock);
+  return fd;
+}
+#endif
+
+unsigned int
+if_nametoindex (const char *ifname)
+{
+#ifndef SIOCGIFINDEX
+  __set_errno (ENOSYS);
+  return 0;
+#else
+  struct ifreq ifr;
+  int fd = opensock ();
+
+  if (fd < 0)
+    return 0;
+
+  strncpy (ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
+  if (__ioctl (fd, SIOCGIFINDEX, &ifr) < 0)
+    {
+      int saved_errno = errno;
+      close (fd);
+      if (saved_errno == EINVAL)
+	__set_errno (ENOSYS);
+      return 0;
+    }
+  close (fd);
+  return ifr.ifr_ifindex;
+#endif
+}
+
+void
+if_freenameindex (struct if_nameindex *ifn)
+{
+  struct if_nameindex *ptr = ifn;
+  while (ptr->if_name || ptr->if_index)
+    {
+      if (ptr->if_name)
+	free (ptr->if_name);
+      ++ptr;
+    }
+  free (ifn);
+}
+
+struct if_nameindex *
+if_nameindex (void)
+{
+#ifndef SIOCGIFINDEX
+  __set_errno (ENOSYS);
+  return NULL;
+#else
+  int fd = opensock ();
+  struct ifconf ifc;
+  unsigned int nifs, i;
+  int rq_len;
+  struct if_nameindex *idx = NULL;
+  static int old_siocgifconf;
+#define RQ_IFS	4
+
+  if (fd < 0)
+    return NULL;
+
+  ifc.ifc_buf = NULL;
+
+  /* We may be able to get the needed buffer size directly, rather than
+     guessing.  */
+  if (! old_siocgifconf)
+    {
+      ifc.ifc_buf = NULL;
+      ifc.ifc_len = 0;
+      if (__ioctl (fd, SIOCGIFCONF, &ifc) < 0 || ifc.ifc_len == 0)
+	{
+	  old_siocgifconf = 1;
+	  rq_len = RQ_IFS * sizeof (struct ifreq);
+	}
+      else
+	rq_len = ifc.ifc_len;
+    }
+  else
+    rq_len = RQ_IFS * sizeof (struct ifreq);
+
+  /* Read all the interfaces out of the kernel.  */
+  do
+    {
+      ifc.ifc_buf = alloca (ifc.ifc_len = rq_len);
+      if (ifc.ifc_buf == NULL || __ioctl (fd, SIOCGIFCONF, &ifc) < 0)
+	{
+	  close (fd);
+	  return NULL;
+	}
+      rq_len *= 2;
+    }
+  while (ifc.ifc_len == rq_len && old_siocgifconf);
+
+  nifs = ifc.ifc_len / sizeof (struct ifreq);
+
+  idx = malloc ((nifs + 1) * sizeof (struct if_nameindex));
+  if (idx == NULL)
+    {
+      close (fd);
+      return NULL;
+    }
+
+  for (i = 0; i < nifs; ++i)
+    {
+      struct ifreq *ifr = &ifc.ifc_req[i];
+      idx[i].if_name = strdup (ifr->ifr_name);
+      if (idx[i].if_name == NULL
+	  || __ioctl (fd, SIOCGIFINDEX, ifr) < 0)
+	{
+	  int saved_errno = errno;
+	  unsigned int j;
+
+	  for (j =  0; j < i; ++j)
+	    free (idx[j].if_name);
+	  free (idx);
+	  close (fd);
+	  if (saved_errno == EINVAL)
+	    __set_errno (ENOSYS);
+	  return NULL;
+	}
+      idx[i].if_index = ifr->ifr_ifindex;
+    }
+
+  idx[i].if_index = 0;
+  idx[i].if_name = NULL;
+
+  close (fd);
+  return idx;
+#endif
+}
+
+char *
+if_indextoname (unsigned int ifindex, char *ifname)
+{
+#ifndef SIOCGIFINDEX
+  __set_errno (ENOSYS);
+  return NULL;
+#else
+  struct if_nameindex *idx;
+  struct if_nameindex *p;
+  char *result = NULL;
+
+#ifdef SIOCGIFNAME
+  /* We may be able to do the conversion directly, rather than searching a
+     list.  This ioctl is not present in kernels before version 2.1.50.  */
+  struct ifreq ifr;
+  int fd;
+  static int siocgifname_works_not;
+
+  if (!siocgifname_works_not)
+    {
+      int serrno = errno;
+
+      fd = opensock ();
+
+      if (fd < 0)
+	return NULL;
+
+      ifr.ifr_ifindex = ifindex;
+      if (__ioctl (fd, SIOCGIFNAME, &ifr) < 0)
+	{
+	  if (errno == EINVAL)
+	    siocgifname_works_not = 1; /* Don't make the same mistake twice. */
+	}
+      else
+	{
+	  close (fd);
+	  return strncpy (ifname, ifr.ifr_name, IFNAMSIZ);
+	}
+
+      close (fd);
+
+      __set_errno (serrno);
+    }
+#endif
+
+  idx = if_nameindex ();
+
+  if (idx != NULL)
+    {
+      for (p = idx; p->if_index || p->if_name; ++p)
+	if (p->if_index == ifindex)
+	  {
+	    result = strncpy (ifname, p->if_name, IFNAMSIZ);
+	    break;
+	  }
+
+      if_freenameindex (idx);
+    }
+  return result;
+#endif
+}
diff -Naur bridge-utils-1.4/libbridge/libbridge_compat.c open_bridge_utils/libbridge/libbridge_compat.c
--- bridge-utils-1.4/libbridge/libbridge_compat.c	1970-01-01 05:30:00.000000000 +0530
+++ open_bridge_utils/libbridge/libbridge_compat.c	2009-11-03 10:05:20.869056000 +0530
@@ -0,0 +1,35 @@
+/*
+ * Compatability glue for systems lacking the if_nametoindex and
+ * if_indextoname functions.
+ *
+ * The file 'if_index.c' was taken verbatimly from the GNU C Library
+ * version 2.1 (990920) and is Copyright (C) 1997, 1998, 1999 Free
+ * Software Foundation, Inc.
+ */
+
+/*
+ * On how to use this file: Serge Caron writes:
+ *
+ * I installed compat-glibc-6.2-2.1.3.2.i386.rpm in my Red Hat 5.2 box
+ *
+ * from the directory where libbridge is stored I ran
+ *
+ * gcc -Wall -g -nostdinc -I- -I.
+ *   -I /usr/i386-glibc21-linux/include
+ *   -I /usr/lib/gcc-lib/i386-redhat-linux/2.7.23/include
+ *   -c libbridge_compat.c
+ *
+ * Now this gives a nice .o file that keeps make happy. Running make in the top
+ * directory builds brctl and brctld against glibc-2.0.7.
+ */
+
+#define _BITS_LIBC_LOCK_H 1
+#define __libc_lock_define_initialized(a,b)
+#define __libc_lock_lock(a)
+#define __libc_lock_unlock(a)
+#define __ioctl ioctl
+#define __set_errno(a) {errno = (a);}
+#define __socket socket
+#define internal_function
+
+#include "if_index.c"
diff -Naur bridge-utils-1.4/misc/README open_bridge_utils/misc/README
--- bridge-utils-1.4/misc/README	1970-01-01 05:30:00.000000000 +0530
+++ open_bridge_utils/misc/README	2009-11-03 10:05:21.346986000 +0530
@@ -0,0 +1,10 @@
+Files in this directory:
+
+bidi.c		A quick-and-dirty hack that allows you to 'connect'
+		multiple file descriptors together (everything
+		received on one fd will be sent out to all the other
+		fds). Works great for tying ethertaps together (for
+		testing stp protocol interaction et al.).
+
+		The command-line arguments are the names of the
+		ethertaps to be connected together.
diff -Naur bridge-utils-1.4/misc/bidi.c open_bridge_utils/misc/bidi.c
--- bridge-utils-1.4/misc/bidi.c	1970-01-01 05:30:00.000000000 +0530
+++ open_bridge_utils/misc/bidi.c	2009-11-03 10:05:21.311989000 +0530
@@ -0,0 +1,97 @@
+/*
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation; either version 2 of
+ *	the License, or (at your option) any later version.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <sys/poll.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+char *names[1024];
+int numfds;
+struct pollfd pfd[1024];
+
+void rcvd_packet(int index, unsigned char *buf, int len)
+{
+	int i;
+	int dmp;
+
+	printf("%s: %i\n", names[index], len);
+	dmp = (len + 15) >> 4;
+	if (dmp > 8)
+		dmp = 8;
+
+	for (i=0;i<dmp;i++) {
+		int j;
+
+		for (j=0;j<16;j++)
+			printf("%.2x ", buf[(i<<4)|j]);
+
+		printf("\n");
+	}
+
+	printf("\n");
+}
+
+void loop()
+{
+	while (1) {
+		int i;
+
+		if (poll(pfd, numfds, -1) < 0) {
+			perror("poll");
+			break;
+		}
+
+		for (i=0;i<numfds;i++) {
+			unsigned char buf[2048];
+			int j;
+			int len;
+
+			if (!(pfd[i].revents & POLLIN))
+				continue;
+
+			if ((len = read(pfd[i].fd, buf, 2048)) < 0)
+				continue;
+
+			rcvd_packet(i, buf, len);
+			for (j=0;j<numfds;j++)
+				if (i != j)
+					write(pfd[j].fd, buf, len);
+		}
+	}
+}
+
+void openfds(int argc, char *argv[])
+{
+	int i;
+
+	numfds = 0;
+	for (i=1;i<argc;i++) {
+		int fd;
+
+		if ((fd = open(argv[i], O_RDWR)) < 0) {
+			perror("open");
+			continue;
+		}
+
+		names[numfds] = argv[i];
+		pfd[numfds].fd = fd;
+		pfd[numfds].events = POLLIN;
+		numfds++;
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	openfds(argc, argv);
+	loop();
+
+	return 0;
+}
diff -Naur bridge-utils-1.4/version.h open_bridge_utils/version.h
--- bridge-utils-1.4/version.h	1970-01-01 05:30:00.000000000 +0530
+++ open_bridge_utils/version.h	2009-11-03 10:05:21.376983000 +0530
@@ -0,0 +1,3 @@
+#define APP_NAME    "Bridge util"
+#define APP_VER     "1.2-IFX"
+
