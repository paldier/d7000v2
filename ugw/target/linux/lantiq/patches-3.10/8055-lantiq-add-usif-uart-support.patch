# HG changeset patch
# Parent b8eb4cc6ea364a967cf34a6406406118e2b20886

diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -1138,6 +1138,26 @@ config SERIAL_LANTIQ
 	  Support for console and UART on Lantiq SoCs.
 
 
+config SERIAL_LANTIQ_USIF_UART
+	tristate "Lantiq serial driver"
+	depends on (LANTIQ) && !LANTIQ_USIF_SPI && !SOC_FALCON
+	select SERIAL_CORE
+	help
+	  Support for console and UART on Lantiq SoCs using USIF interface.
+
+config SERIAL_LANTIQ_USIF_UART_CONSOLE
+        bool "Console on Lantiq SoCs serial port"
+        depends on SERIAL_LANTIQ_USIF_UART=y
+        select SERIAL_CORE_CONSOLE
+	default n
+        help
+	  Support for console on Lantiq SoCs serial ports using USIF interface.
+
+config LANTIQ_USIF_UART_DEFAULT_BAUDRATE
+        depends on SERIAL_LANTIQ_USIF_UART
+        int "Lantiq USIF UART Default Baudrate"
+        default "115200"
+
 config SERIAL_QE
 	tristate "Freescale QUICC Engine serial port support"
 	depends on QUICC_ENGINE
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -85,3 +85,4 @@ obj-$(CONFIG_SERIAL_AR933X)   += ar933x_
 obj-$(CONFIG_SERIAL_EFM32_UART) += efm32-uart.o
 obj-$(CONFIG_SERIAL_ARC)	+= arc_uart.o
 obj-$(CONFIG_SERIAL_RP2)	+= rp2.o
+obj-$(CONFIG_SERIAL_LANTIQ_USIF_UART)	+= lantiq_usif_uart.o
diff --git a/drivers/tty/serial/lantiq_usif_reg.h b/drivers/tty/serial/lantiq_usif_reg.h
new file mode 100644
--- /dev/null
+++ b/drivers/tty/serial/lantiq_usif_reg.h
@@ -0,0 +1,856 @@
+/******************************************************************************
+**
+** FILE NAME    : ltqmips_usif_reg.h
+** PROJECT      : IFX UEIP
+** MODULES      : USIF for UART and SPI
+**
+** DATE         : 21 Aug 2008
+** AUTHOR       : Lei Chuanhua
+** DESCRIPTION  : USIF module register definitioin
+** COPYRIGHT    :       Copyright (c) 2008 ~ 2009
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+** HISTORY
+** $Date         $Author         $Comment
+** 21 Aug, 2009  Lei Chuanhua    Initial version
+** 26 Jun, 2009  Lei Chuanhua    Code review modification
+*******************************************************************************/
+
+#ifndef LTQMIPS_USIF_REG_H
+#define LTQMIPS_USIF_REG_H
+
+/*!
+ \file ltqmips_usif_reg.h
+ \ingroup LANTIQ_USIF_SPI
+ \brief ifx usif module register definition
+*/
+#include <asm/io.h>
+
+#define LANTIQ_USIF_PHY_BASE    0x1DA00000
+#define LANTIQ_USIF_VIRT_BASE  (LANTIQ_USIF_PHY_BASE + KSEG1)
+#define LANTIQ_USIF_SIZE       0x100000 /* 1MB */
+
+#define LANTIQ_REG_R32(_r)                   __raw_readl((volatile unsigned int *)(_r))
+#define LANTIQ_REG_W32(_v, _r)               __raw_writel((_v), (volatile unsigned int *)(_r))
+
+#define LANTIQ_REG_CLR_BIT(_f, _r) \
+    LANTIQ_REG_W32(LANTIQ_REG_R32((_r)) &~ (_f), (_r))
+
+/* USIF System Registers */
+#define LANTIQ_USIF_CLC             0x00 /* Clock Control Register */
+
+#define LANTIQ_USIF_CLC_RUN_STAT    0x00000001
+#define LANTIQ_USIF_CLC_CFG_STAT    0x00000002
+#define LANTIQ_USIF_CLC_STAT_M      0x00000003
+#define LANTIQ_USIF_CLC_MOD_EN      0x00000004
+#define LANTIQ_USIF_CLC_MOD_DIS     0x00000008
+#define LANTIQ_USIF_CLC_SPEN_EN     0x00000010
+#define LANTIQ_USIF_CLC_SPEN_DIS    0x00000020
+#define LANTIQ_USIF_CLC_FSOE_EN     0x00000040
+#define LANTIQ_USIF_CLC_FSOE_DIS    0x00000080
+#define LANTIQ_USIF_CLC_EDR_EN      0x00000100
+#define LANTIQ_USIF_CLC_EDR_DIS     0x00000200
+#define LANTIQ_USIF_CLC_IDR_EN      0x00000400
+#define LANTIQ_USIF_CLC_IDR_DIS     0x00000800
+
+#define LANTIQ_USIF_CLC_CNT         0x04 /* Clock Control Counter Register */
+
+#define LANTIQ_USIF_CLC_CNT_RMC     0x000000ff
+#define LANTIQ_USIF_CLC_CNT_RMC_S   0
+#define LANTIQ_USIF_CLC_CNT_ORMC    0x0000ff00
+#define LANTIQ_USIF_CLC_CNT_ORMC_S  8
+
+#define LANTIQ_USIF_CLC_STAT        0x08 /* Clock Control Status Register */
+
+#define LANTIQ_USIF_CLC_STAT_RUN              0x00000001
+#define LANTIQ_USIF_CLC_STAT_MODEN            0x00000002
+#define LANTIQ_USIF_CLC_STAT_SPEN             0x00000004
+#define LANTIQ_USIF_CLC_STAT_FSOE             0x00000008
+#define LANTIQ_USIF_CLC_STAT_EDRE             0x00000010
+#define LANTIQ_USIF_CLC_STAT_IDRE             0x00000020
+#define LANTIQ_USIF_CLC_STAT_CNT_UPDATE_DONE  0x00000040
+#define LANTIQ_USIF_CLC_STAT_KERN_IDL         0x00000080
+#define LANTIQ_USIF_CLC_STAT_FIFO_IDL         0x00000100
+
+#define LANTIQ_USIF_CLC_STAT_CFG_UPDATE_DONE  (LANTIQ_USIF_CLC_STAT_MODEN |\
+	LANTIQ_USIF_CLC_STAT_CNT_UPDATE_DONE | LANTIQ_USIF_CLC_STAT_KERN_IDL\
+	| LANTIQ_USIF_CLC_STAT_FIFO_IDL)
+
+#define LANTIQ_USIF_CLC_STAT_RUN_UPDATE_DONE  (LANTIQ_USIF_CLC_STAT_MODEN |\
+	LANTIQ_USIF_CLC_STAT_CNT_UPDATE_DONE | LANTIQ_USIF_CLC_STAT_KERN_IDL\
+	| LANTIQ_USIF_CLC_STAT_RUN | LANTIQ_USIF_CLC_STAT_FIFO_IDL)
+
+#define LANTIQ_USIF_ID                        0x0c
+
+#define LANTIQ_USIF_ID_TS_VER_NR              0xffff0000
+#define LANTIQ_USIF_ID_TS_VER_NR_S            16
+#define LANTIQ_USIF_ID_MOD_ID                 0x0000ff00
+#define LANTIQ_USIF_ID_MOD_ID_S               8
+#define LANTIQ_USIF_ID_REV_NR                 0x000000ff
+#define LANTIQ_USIF_ID_REV_NR_S               0
+
+#define LANTIQ_USIF_FIFO_ID                   0x10
+
+#define LANTIQ_USIF_FIFO_ID_TX                0x000000ff
+#define LANTIQ_USIF_FIFO_ID_TX_S              0
+#define LANTIQ_USIF_FIFO_ID_RX                0x0000ff00
+#define LANTIQ_USIF_FIFO_ID_RX_S              8
+#define LANTIQ_USIF_FIFO_ID_RPS               0x003f0000
+#define LANTIQ_USIF_FIFO_ID_RPS_S             16
+#define LANTIQ_USIF_FIFO_ID_DPLUS_CLS_ID      0x07000000
+#define LANTIQ_USIF_FIFO_ID_DPLUS_CLS_ID_S    24
+
+enum {
+	LANTIQ_USIF_FIFO_ID_DPLUS_CLS_WIDTH0 = 0, /* Dplus disabled */
+	LANTIQ_USIF_FIFO_ID_DPLUS_CLS_WIDTH2,
+	LANTIQ_USIF_FIFO_ID_DPLUS_CLS_WIDTH4,
+	LANTIQ_USIF_FIFO_ID_DPLUS_CLS_WIDTH8,
+};
+
+#define LANTIQ_USIF_SRB_MSCONF_ID      0x14
+
+#define LANTIQ_USIF_SRB_ERRCONF_ID     0x18
+
+#define LANTIQ_USIF_SWCID           0x1c /* USIF sw check identity */
+
+/* USIF Special Function Registers */
+#define LANTIQ_USIF_MSS_SET         0x100 /* Modemstatus Set Register */
+
+#define LANTIQ_USIF_MSS_SET_FCO     0x00000001
+#define LANTIQ_USIF_MSS_SET_DTR     0x00000004
+#define LANTIQ_USIF_MSS_SET_DSR     0x00000008
+#define LANTIQ_USIF_MSS_SET_DCD     0x00000010
+#define LANTIQ_USIF_MSS_SET_RI      0x00000020
+
+#define LANTIQ_USIF_MSS_CLR         0x104
+
+#define LANTIQ_USIF_MSS_CLR_FCO     0x00000001
+#define LANTIQ_USIF_MSS_CLR_DTR     0x00000004
+#define LANTIQ_USIF_MSS_CLR_DSR     0x00000008
+#define LANTIQ_USIF_MSS_CLR_DCD     0x00000010
+#define LANTIQ_USIF_MSS_CLR_RI      0x00000020
+
+#define LANTIQ_USIF_MSS_STAT        0x108
+
+#define LANTIQ_USIF_MSS_STAT_FCO    0x00000001
+#define LANTIQ_USIF_MSS_STAT_FCI    0x00000002
+#define LANTIQ_USIF_MSS_STAT_DTR    0x00000004
+#define LANTIQ_USIF_MSS_STAT_DSR    0x00000008
+#define LANTIQ_USIF_MSS_STAT_DCD    0x00000010
+#define LANTIQ_USIF_MSS_STAT_RI     0x00000020
+
+#define LANTIQ_USIF_MSS_CTRL         0x10c
+
+#define LANTIQ_USIF_MSS_CTRL_FCIEN   0x00000001
+#define LANTIQ_USIF_MSS_CTRL_FCOEN   0x00000002
+
+#define LANTIQ_USIF_MODE_CFG         0x110
+
+#define LANTIQ_USIF_MODE_CFG_SYNC    0x00000001
+#define LANTIQ_USIF_MODE_CFG_MA      0x00000002
+#define LANTIQ_USIF_MODE_CFG_RX_EN   0x00000004
+#define LANTIQ_USIF_MODE_CFG_FC_EN   0x00000008
+#define LANTIQ_USIF_MODE_CFG_LB      0x00000010
+#define LANTIQ_USIF_MODE_CFG_ECH     0x00000020
+#define LANTIQ_USIF_MODE_CFG_TX_INV  0x00000040
+#define LANTIQ_USIF_MODE_CFG_RX_INV  0x00000080
+#define LANTIQ_USIF_MODE_CFG_SC_FRC  0x00000100
+#define LANTIQ_USIF_MODE_CFG_SC_POL  0x00000200
+#define LANTIQ_USIF_MODE_CFG_SC_PH   0x00000400
+#define LANTIQ_USIF_MODE_CFG_TX_IDLE 0x00000800
+#define LANTIQ_USIF_MODE_CFG_AB_EN   0x00001000
+#define LANTIQ_USIF_MODE_CFG_EC_EN   0x00002000
+#define LANTIQ_USIF_MODE_CFG_EQA     0x00004000
+#define LANTIQ_USIF_MODE_CFG_HDEN    0x00008000
+#define LANTIQ_USIF_MODE_CFG_TX_EN   0x00010000
+
+#define LANTIQ_USIF_MODE_CFG_SC_MODE_MASK  (LANTIQ_USIF_MODE_CFG_SC_POL |\
+	LANTIQ_USIF_MODE_CFG_SC_PH)
+
+#define LANTIQ_USIF_MODE_CFG_TXRX_EN       (LANTIQ_USIF_MODE_CFG_RX_EN |\
+	LANTIQ_USIF_MODE_CFG_TX_EN)
+
+#define LANTIQ_USIF_MODE_CFG_TXRX_MASK      LANTIQ_USIF_MODE_CFG_TXRX_EN
+
+#define LANTIQ_USIF_PRTC_CFG          0x114 /* Protocol Configuration Register */
+
+#define LANTIQ_USIF_PRTC_CFG_CLEN5    0x05
+#define LANTIQ_USIF_PRTC_CFG_CLEN6    0x06
+#define LANTIQ_USIF_PRTC_CFG_CLEN7    0x07
+#define LANTIQ_USIF_PRTC_CFG_CLEN8    0x08
+#define LANTIQ_USIF_PRTC_CFG_CLEN16   0x10
+#define LANTIQ_USIF_PRTC_CFG_CLEN32   0x00
+#define LANTIQ_USIF_PRTC_CFG_CLEN     0x0000001f
+#define LANTIQ_USIF_PRTC_CFG_CLEN_S   0
+#define LANTIQ_USIF_PRTC_CFG_HD_MSB   0x00000080
+#define LANTIQ_USIF_PRTC_CFG_PAR      0x00000100
+#define LANTIQ_USIF_PRTC_CFG_ODD      0x00000200
+#define LANTIQ_USIF_PRTC_CFG_ERR_FE   0x00000400
+#define LANTIQ_USIF_PRTC_CFG_STP2     0x00001000
+#define LANTIQ_USIF_PRTC_CFG_WK_UP    0x00002000
+#define LANTIQ_USIF_PRTC_CFG_FCS_INV  0x00040000
+#define LANTIQ_USIF_PRTC_CFG_FCO_TL   0x03F00000
+#define LANTIQ_USIF_PRTC_CFG_FCO_TL_S 20
+#define LANTIQ_USIF_PRTC_CFG_SFCO_EN  0x04000000
+#define LANTIQ_USIF_PRTC_CFG_SFCI_EN  0x08000000
+#define LANTIQ_USIF_PRTC_CFG_SLIP_EN  0x10000000
+#define LANTIQ_USIF_PRTC_CFG_SLIP_EXT 0x20000000
+#define LANTIQ_USIF_PRTC_CFG_HDLC     0x40000000
+
+#define LANTIQ_USIF_PRTC_STAT         0x118 /* Protocol Status Register */
+
+#define LANTIQ_USIF_PRTC_STAT_CLEN    0x0000001f
+#define LANTIQ_USIF_PRTC_STAT_CLEN_S  0
+#define LANTIQ_USIF_PRTC_STAT_PAR     0x00000100
+#define LANTIQ_USIF_PRTC_STAT_ODD     0x00000200
+#define LANTIQ_USIF_PRTC_STAT_AB_DONE 0x00008000
+#define LANTIQ_USIF_PRTC_STAT_BCRV    0x0fff0000
+#define LANTIQ_USIF_PRTC_STAT_BRCV_S  16
+#define LANTIQ_USIF_PRTC_STAT_TXACT   0x80000000
+
+#define LANTIQ_USIF_FRM_CTRL          0x11c /* Frame Control Register */
+
+#define LANTIQ_USIF_FRM_CTRL_SFEN     0x00000001
+#define LANTIQ_USIF_FRM_CTRL_IBEN     0x00000004
+#define LANTIQ_USIF_FRM_CTRL_IAEN     0x00000008
+#define LANTIQ_USIF_FRM_CTRL_DLEN     0x0000fff0
+#define LANTIQ_USIF_FRM_CTRL_DLEN_S   4
+#define LANTIQ_USIF_FRM_CTRL_ICLK     0x00040000
+#define LANTIQ_USIF_FRM_CTRL_STOP     0x00100000
+#define LANTIQ_USIF_FRM_CTRL_PLEN     0xffc00000
+#define LANTIQ_USIF_FRM_CTRL_PLEN_S   22
+
+#define LANTIQ_USIF_FRM_STAT          0x120 /* Frame Status Register */
+
+#define LANTIQ_USIF_FRM_STAT_SFEN     0x00000001
+#define LANTIQ_USIF_FRM_STAT_DBSY     0x00000002
+#define LANTIQ_USIF_FRM_STAT_PBSY     0x00000004
+#define LANTIQ_USIF_FRM_STAT_DCNT     0x0000fff0
+#define LANTIQ_USIF_FRM_STAT_DCNT_S   4
+#define LANTIQ_USIF_FRM_STAT_PCNT     0xffc00000
+#define LANTIQ_USIF_FRM_STAT_PCNT_S   22
+
+#define LANTIQ_USIF_CRC_CFG           0x124 /* CRC Configuration Register */
+
+#define LANTIQ_USIF_CRC_CFG_GRADE8    0x00000008
+#define LANTIQ_USIF_CRC_CFG_GRADE16   0x00000010
+#define LANTIQ_USIF_CRC_CFG_GRADE32   0x00
+#define LANTIQ_USIF_CRC_CFG_INIT      0x00000100
+#define LANTIQ_USIF_CRC_CFG_HD_MSB    0x00000200
+#define LANTIQ_USIF_CRC_CFG_REFO      0x00000400
+#define LANTIQ_USIF_CRC_CFG_FIN_XOR   0x00000800
+#define LANTIQ_USIF_CRC_CFG_ENDIAN    0x00001000
+
+#define LANTIQ_USIF_CRCPOLY_CFG       0x128
+
+#define LANTIQ_USIF_CRC_CTRL          0x12c
+
+#define LANTIQ_USIF_CRC_CTRL_RX_EN    0x00000001
+#define LANTIQ_USIF_CRC_CTRL_TX_EN    0x00000002
+
+#define LANTIQ_USIF_CS_CFG            0x130
+
+#define LANTIQ_USIF_CS_CFG_EN         0x00000001
+#define LANTIQ_USIF_CS_CFG_EACS       0x00000002
+#define LANTIQ_USIF_CS_CFG_INV        0x00000010
+#define LANTIQ_USIF_CS_CFG_CS0_HI     0x00000100
+#define LANTIQ_USIF_CS_CFG_CS1_HI     0x00000200
+#define LANTIQ_USIF_CS_CFG_CS2_HI     0x00000400
+#define LANTIQ_USIF_CS_CFG_CS3_HI     0x00000800
+#define LANTIQ_USIF_CS_CFG_CS4_HI     0x00001000
+#define LANTIQ_USIF_CS_CFG_CS5_HI     0x00002000
+#define LANTIQ_USIF_CS_CFG_CS6_HI     0x00004000
+#define LANTIQ_USIF_CS_CFG_CS7_HI     0x00008000
+#define LANTIQ_USIF_CS_CFG_CSO_CLK    0x000f0000
+#define LANTIQ_USIF_CS_CFG_CS0_CLK_S  16
+#define LANTIQ_USIF_CS_CFG_CS0_FRM    0x00f00000
+#define LANTIQ_USIF_CS_CFG_CS0_FRM_S  20
+#define LANTIQ_USIF_CS_CFG_CSO_INV    0xFF000000
+#define LANTIQ_USIF_CS_CFG_CSO_INV_S  24
+#define LANTIQ_USIF_CS_CFG_CSX_DEFAULT 0xFF000000
+
+#define LANTIQ_USIF_CS_OFFSET         8
+#define LANTIQ_USIF_CS_INV_OFFSET     24
+
+#define LANTIQ_USIF_FDIV_CFG          0x140
+
+#define LANTIQ_USIF_FDIV_CFG_INC      0x0001ff
+#define LANTIQ_USIF_FDIV_CFG_INC_S    0
+#define LANTIQ_USIF_FDIV_CFG_DEC      0xffff0000
+#define LANTIQ_USIF_FDIV_CFG_DEC_S    16
+
+#define LANTIQ_USIF_BC_CFG            0x144
+
+#define LANTIQ_USIF_BC_CFG_BCRV       0x00001fff
+#define LANTIQ_USIF_BC_CFG_BCRV_S     0
+#define LANTIQ_USIF_BC_CFG_SCDIV_HALF 0x01000000
+
+#define LANTIQ_USIF_ICTMO_CFG         0x148
+
+#define LANTIQ_USIF_ICTMO_CFG_TMO     0x0000ffff
+#define LANTIQ_USIF_ICTMO_CFG_TMO_S   0
+
+#define LANTIQ_USIF_ICTM_CFG          0x14c
+
+#define LANTIQ_USIF_ICTM_CFG_TM       0x00003fff
+#define LANTIQ_USIF_ICTM_CFG_TM_S     0
+
+#define LANTIQ_USIF_ECTM_CFG          0x150
+
+#define LANTIQ_USIF_ECTM_CFG_ECTM     0x000003ff
+#define LANTIQ_USIF_ECTM_CFG_ECTM_S   0
+
+/* USIF Chip Select Timing Configuration */
+#define LANTIQ_USIF_CS_TIM0_CFG       0x154
+#define LANTIQ_USIF_CS_TIM1_CFG       0x158
+#define LANTIQ_USIF_CS_TIM2_CFG       0x15C
+#define LANTIQ_USIF_CS_TIM3_CFG       0x160
+#define LANTIQ_USIF_CS_TIM4_CFG       0x164
+#define LANTIQ_USIF_CS_TIM5_CFG       0x168
+#define LANTIQ_USIF_CS_TIM6_CFG       0x16C
+#define LANTIQ_USIF_CS_TIM7_CFG       0x170
+#define LANTIQ_USIF_CS_TIMX_CFG(cs)   (LANTIQ_USIF_CS_TIM0_CFG + (cs << 2))
+
+/* Setup/Hold/Idle defintion in CS timing configuration */
+#define LANTIQ_USIF_CS_TIM_CFG_IDLE    0x000000FF
+#define LANTIQ_USIF_CS_TIM_CFG_IDLE_S  0
+#define LANTIQ_USIF_CS_TIM_CFG_HOLD    0x0000FF00
+#define LANTIQ_USIF_CS_TIM_CFG_HOLD_S  8
+#define LANTIQ_USIF_CS_TIM_CFG_SETUP   0x00FF0000
+#define LANTIQ_USIF_CS_TIM_CFG_SETUP_S 16
+
+/* USIF Data Buffer Registers */
+#define LANTIQ_USIF_FIFO_CFG          0x30 /* FIFO configuration register */
+
+#define LANTIQ_USIF_FIFO_CFG_RXBS     0x00000007
+#define LANTIQ_USIF_FIFO_CFG_RXBS_S   0
+#define LANTIQ_USIF_FIFO_CFG_RXFC     0x00000008
+#define LANTIQ_USIF_FIFO_CFG_TXBS     0x00000070
+#define LANTIQ_USIF_FIFO_CFG_TXBS_S   4
+#define LANTIQ_USIF_FIFO_CFG_TXFC     0x00000080
+#define LANTIQ_USIF_FIFO_CFG_RXFA     0x00000700
+#define LANTIQ_USIF_FIFO_CFG_RX_SWAP  0x00000800
+#define LANTIQ_USIF_FIFO_CFG_RXFA_S   8
+#define LANTIQ_USIF_FIFO_CFG_TXFA     0x00007000
+#define LANTIQ_USIF_FIFO_CFG_TXFA_S   12
+#define LANTIQ_USIF_FIFO_CFG_TX_SWAP  0x00008000
+enum {
+	LANTIQ_USIF_RXFIFO_BURST_WORD1 = 0,
+	LANTIQ_USIF_RXFIFO_BURST_WORD2,
+	LANTIQ_USIF_RXFIFO_BURST_WORD4,
+	LANTIQ_USIF_RXFIFO_BURST_WORD8,
+	LANTIQ_USIF_RXFIFO_BURST_WORD16,
+};
+
+enum {
+	LANTIQ_USIF_TXFIFO_BURST_WORD1 = 0,
+	LANTIQ_USIF_TXFIFO_BURST_WORD2,
+	LANTIQ_USIF_TXFIFO_BURST_WORD4,
+	LANTIQ_USIF_TXFIFO_BURST_WORD8,
+	LANTIQ_USIF_TXFIFO_BURST_WORD16,
+};
+
+enum {
+	LANTIQ_USIF_RXFIFO_ALIGN_BYTE = 0,
+	LANTIQ_USIF_RXFIFO_ALIGN_HALFWORD,
+	LANTIQ_USIF_RXFIFO_ALIGN_WORD,
+	LANTIQ_USIF_RXFIFO_ALIGN_DWORD,
+};
+
+enum {
+	LANTIQ_USIF_TXFIFO_ALIGN_BYTE = 0,
+	LANTIQ_USIF_TXFIFO_ALIGN_HALFWORD,
+	LANTIQ_USIF_TXFIFO_ALIGN_WORD,
+	LANTIQ_USIF_TXFIFO_ALIGN_DWORD,
+};
+
+#define LANTIQ_USIF_FIFO_CTRL              0x34
+
+#define LANTIQ_USIF_FIFO_CTRL_TX_START     0x00000001
+#define LANTIQ_USIF_FIFO_CTRL_TX_ABORT     0x00000002
+#define LANTIQ_USIF_FIFO_CTRL_TX_SETEOP    0x00000004
+#define LANTIQ_USIF_FIFO_CTRL_RX_START     0x00000010
+#define LANTIQ_USIF_FIFO_CTRL_RX_ABORT     0x00000020
+#define LANTIQ_USIF_FIFO_CTRL_RX_AR_ON     0x00000040
+#define LANTIQ_USIF_FIFO_CTRL_RX_AR_OFF    0x00000080
+
+#define LANTIQ_USIF_MRPS_CTRL            0x38
+
+#define LANTIQ_USIF_MRPS_CTRL_MRPS       0x00003fff
+#define LANTIQ_USIF_MRPS_CTRL_MRPS_S     0
+
+#define LANTIQ_USIF_MRPS_MIN             1
+#define LANTIQ_USIF_MRPS_MAX             16383
+
+#define LANTIQ_USIF_FIFO_STAT              0x44
+
+#define LANTIQ_USIF_FIFO_STAT_RX_FFS       0x000000ff
+#define LANTIQ_USIF_FIFO_STAT_RX_FFS_S     0
+#define LANTIQ_USIF_FIFO_STAT_RX_AR_ON     0x00010000
+#define LANTIQ_USIF_FIFO_STAT_RX_EOP       0x00020000
+#define LANTIQ_USIF_FIFO_STAT_RX_THR_EXC   0x00040000
+#define LANTIQ_USIF_FIFO_STAT_MRPS_WE      0x00080000
+#define LANTIQ_USIF_FIFO_STAT_TX_FFS       0x00ff0000
+#define LANTIQ_USIF_FIFO_STAT_TX_FFS_S     16
+#define LANTIQ_USIF_FIFO_STAT_TX_THR_EXC   0x40000000
+#define LANTIQ_USIF_FIFO_STAT_TPS_WE       0x80000000
+
+#define LANTIQ_USIF_FIFO_STAT_TXRX_FFS_MASK (LANTIQ_USIF_FIFO_STAT_RX_FFS |\
+	LANTIQ_USIF_FIFO_STAT_TX_FFS)
+
+#define LANTIQ_USIF_TXD_SB                 0x48
+
+#define LANTIQ_USIF_TXD_SB_TX_CLS          0x00000007
+#define LANTIQ_USIF_TXD_SB_TX_CLS_S        0
+#define LANTIQ_USIF_TXD_SB_TX_BE           0x00000030
+#define LANTIQ_USIF_TXD_SB_TX_BE_S         4
+#define LANTIQ_USIF_TXD_SB_XME             0x00000080
+
+/* TX class number */
+enum {
+	LANTIQ_USIF_TXD_CLASS0 = 0,
+	LANTIQ_USIF_TXD_CLASS1,
+	LANTIQ_USIF_TXD_CLASS2,
+	LANTIQ_USIF_TXD_CLASS3,
+	LANTIQ_USIF_TXD_CLASS4,
+	LANTIQ_USIF_TXD_CLASS5,
+	LANTIQ_USIF_TXD_CLASS6,
+	LANTIQ_USIF_TXD_CLASS7,
+};
+
+/* BPI byte enable */
+enum {
+	LANTIQ_USIF_TXD_BE4 = 0,
+	LANTIQ_USIF_TXD_BE1,
+	LANTIQ_USIF_TXD_BE2,
+	LANTIQ_USIF_TXD_BE3,
+};
+
+#define LANTIQ_USIF_DPLUS_CTRL                 0x2c /* DPLUS control register */
+
+#define LANTIQ_USIF_DPLUS_CTRL_SET_MASK        0x00000080
+#define LANTIQ_USIF_DPLUS_CTRL_RX_MASK         0x0000ff00
+#define LANTIQ_USIF_DPLUS_CTRL_RX_MASK_S       8
+#define LANTIQ_USIF_DPLUS_CTRL_RX_MASK_OFFSET  LANTIQ_USIF_DPLUS_CTRL_RX_MASK_S
+#define LANTIQ_USIF_DPLUS_CTRL_TX_EN           0x00400000
+#define LANTIQ_USIF_DPLUS_CTRL_TX_DIS          0x00800000
+
+#define LANTIQ_USIF_DPLUS_STAT                 0x4c /* DPLUS Status register */
+
+#define LANTIQ_USIF_DPLUS_STAT_RX_CLS          0x00000007
+#define LANTIQ_USIF_DPLUS_STAT_RX_CLS_S        0
+#define LANTIQ_USIF_DPLUS_STAT_RX_BE           0x00000030
+#define LANTIQ_USIF_DPLUS_STAT_RX_BE_S         4
+#define LANTIQ_USIF_DPLUS_STAT_RME             0x00000080
+#define LANTIQ_USIF_DPLUS_STAT_RX_MASK         0x0000ff00
+#define LANTIQ_USIF_DPLUS_STAT_RX_MASK_S       8
+#define LANTIQ_USIF_DPLUS_STAT_TX_EN           0x00400000
+#define LANTIQ_USIF_DPLUS_STAT_TX_ACT          0x00800000
+#define LANTIQ_USIF_DPLUS_STAT_RX_EN           0x01000000
+#define LANTIQ_USIF_DPLUS_STAT_RX_FIFO_EMPTY   0x80000000
+
+/* Transmit Data Register, range 0x4000-0x7FFF */
+#define LANTIQ_USIF_TXD                  0x40000
+/* Receive Data Register, range 0x8000-0xBFFF */
+#define LANTIQ_USIF_RXD                  0x80000
+
+/* USIF Interrupt, DMA and CRC Registers */
+
+/* Raw Interrupt Status Register for debug */
+#define LANTIQ_USIF_RIS                  0x80
+/* Interrupt Mask Control Register, enable/disable */
+#define LANTIQ_USIF_IMSC                 0x84
+/* Masked Interrupt Status Register, status */
+#define LANTIQ_USIF_MIS                  0x88
+/* Interrupt Clear Register, clear */
+#define LANTIQ_USIF_ICR                  0x98
+/* Interrupt Set Register for debug */
+#define LANTIQ_USIF_ISR                  0x90
+
+/* Interrupt flags (Register: IMSC, MIS, RIS, ICR and ISR) */
+#define LANTIQ_USIF_INT_RX_LSREQ         0x00000001
+#define LANTIQ_USIF_INT_RX_SREQ          0x00000002
+#define LANTIQ_USIF_INT_RX_LBREQ         0x00000004
+#define LANTIQ_USIF_INT_RX_BREQ          0x00000008
+#define LANTIQ_USIF_INT_TX_LSREQ         0x00000010
+#define LANTIQ_USIF_INT_TX_SREQ          0x00000020
+#define LANTIQ_USIF_INT_TX_LBREQ         0x00000040
+#define LANTIQ_USIF_INT_TX_BREQ          0x00000080
+#define LANTIQ_USIF_INT_TX_REQ           (LANTIQ_USIF_INT_TX_BREQ |\
+	LANTIQ_USIF_INT_TX_SREQ)
+#define LANTIQ_USIF_INT_AB               0x00000100
+#define LANTIQ_USIF_INT_WKP              0x00000200
+#define LANTIQ_USIF_INT_DATA_ALL         0x000000af
+#define LANTIQ_USIF_INT_DATA_ALL_S       0
+
+
+/* Error interrupt flags */
+#define LANTIQ_USIF_INT_RXUR             0x00000800
+#define LANTIQ_USIF_INT_RXOF             0x00001000
+#define LANTIQ_USIF_INT_TXUR             0x00002000
+#define LANTIQ_USIF_INT_TXOF             0x00004000
+#define LANTIQ_USIF_INT_PE               0x00008000
+#define LANTIQ_USIF_INT_FE               0x00010000
+#define LANTIQ_USIF_INT_PHE              0x00020000
+#define LANTIQ_USIF_INT_CRC              0x00080000
+#define LANTIQ_USIF_INT_SLIP             0x00100000
+#define LANTIQ_USIF_INT_MC               0x00200000
+#define LANTIQ_USIF_INT_ERR_ALL          0x003BF800
+#define LANTIQ_USIF_INT_ERR_ALL_s        11
+
+/* Status interrupt flags */
+#define LANTIQ_USIF_INT_FCO             0x00800000
+#define LANTIQ_USIF_INT_FCI             0x01000000
+#define LANTIQ_USIF_INT_DTR             0x02000000
+#define LANTIQ_USIF_INT_DSR             0x04000000
+#define LANTIQ_USIF_INT_DCD             0x08000000
+#define LANTIQ_USIF_INT_RI              0x10000000
+#define LANTIQ_USIF_INT_TX_FIN          0x20000000
+#define LANTIQ_USIF_INT_FRM_PAUSE       0x40000000
+#define LANTIQ_USIF_INT_TMO             0x80000000
+#define LANTIQ_USIF_INT_STA_ALL         0xff800000
+#define LANTIQ_USIF_INT_STA_ALL_S       23
+#define LANTIQ_USIF_INT_STA_CLR_ALL     0xff800000
+
+#define LANTIQ_USIF_INT_ALL       \
+	(LANTIQ_USIF_INT_DATA_ALL | LANTIQ_USIF_INT_ERR_ALL |\
+	LANTIQ_USIF_INT_STA_ALL | LANTIQ_USIF_INT_AB | LANTIQ_USIF_INT_WKP)
+
+#define LANTIQ_USIF_INT_CLR_ALL  LANTIQ_USIF_INT_ALL
+
+/* Interrupt setup flags for USIF TX */
+#define LANTIQ_USIF_INT_TRANSMIT                  \
+	(LANTIQ_USIF_INT_TX_BREQ | LANTIQ_USIF_INT_TX_SREQ)
+
+/* Interrupt setup flags for USIF RX */
+#define LANTIQ_USIF_INT_RECEIVE                   \
+	(LANTIQ_USIF_INT_RX_BREQ | LANTIQ_USIF_INT_RX_LBREQ | \
+	LANTIQ_USIF_INT_RX_SREQ | LANTIQ_USIF_INT_RX_LSREQ)
+
+/* Interrupt mask for the error interrupt */
+#define LANTIQ_USIF_INT_ERR_MASK                   \
+	(LANTIQ_USIF_INT_RXUR | LANTIQ_USIF_INT_TXUR |\
+	LANTIQ_USIF_INT_TXOF | LANTIQ_USIF_INT_PHE  |\
+	LANTIQ_USIF_INT_CRC)
+
+/**
+ * The following recieve interrupt source need to be checked but it
+ * need not generate any interrupts. These are processed in the error
+ * handling function for received characters
+ */
+#define LANTIQ_USIF_RX_ERR                        \
+	(LANTIQ_USIF_INT_RXOF | LANTIQ_USIF_INT_PE | LANTIQ_USIF_INT_FE)
+
+/* Macro definitions, used for reading and writing to the ports */
+
+/* Get USIF idenitifcation register */
+#define LANTIQ_USIF_GET_ID(_p)                 \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_ID))
+
+/* Set clock Control Register */
+#define LANTIQ_USIF_SET_RUN_CONTROL(_v, _p)      \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_CLC))
+
+#define LANTIQ_USIF_CLC_CONFIG_MODE(_p)  \
+	LANTIQ_USIF_SET_RUN_CONTROL((LANTIQ_USIF_CLC_CFG_STAT), (_p))
+
+#define LANTIQ_USIF_CLC_RUN_MODE(_p)  \
+	LANTIQ_USIF_SET_RUN_CONTROL((LANTIQ_USIF_CLC_RUN_STAT), (_p))
+
+/* Clock Control Counter Set */
+#define LANTIQ_USIF_SET_CLOCK_COUNTER(_v, _p)    \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_CLC_CNT))
+
+/* Get Clock Control Counter */
+#define LANTIQ_USIF_GET_CLOCK_COUNTER(p)      \
+	LANTIQ_REG_R32((volatile u32 *)((p)->membase + LANTIQ_USIF_CLC_CNT))
+
+/* Get Clock Control Status */
+#define LANTIQ_USIF_GET_CLOCK_STATUS(_p)       \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_CLC_STAT))
+
+/* Modem Status Set */
+#define LANTIQ_USIF_SET_MODEM_STATUS(_v, _p)     \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_MSS_SET))
+
+/* Modemstatus Clear */
+#define LANTIQ_USIF_CLR_MODEM_STATUS(_v, _p)     \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_MSS_CLR))
+
+/* Get Modem status */
+#define LANTIQ_USIF_GET_MODEM_STATUS(_p)       \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_MSS_STAT))
+
+/* Modem Status Control */
+#define LANTIQ_USIF_MODEM_FLOW_CTRL(_v, _p)      \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_MSS_CTRL))
+
+/* Updated the mode configuration register */
+#define LANTIQ_USIF_SET_MODE_CONFIG(_v, _p)      \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_MODE_CFG))
+
+/* Get the mode configuration register */
+#define LANTIQ_USIF_GET_MODE_CONFIG(p)        \
+	LANTIQ_REG_R32((volatile u32 *)((p)->membase + LANTIQ_USIF_MODE_CFG))
+
+/* Update the protocol configuration register */
+#define LANTIQ_USIF_SET_PROTOCOL_CONFIG(_v, _p)  \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_PRTC_CFG))
+
+/* Get the protocol configuration register */
+#define LANTIQ_USIF_GET_PROTOCOL_CONFIG(_p)   \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_PRTC_CFG))
+
+/* Get the protocol status */
+#define LANTIQ_USIF_GET_PROTOCOL_STATUS(_p)   \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_PRTC_STAT))
+
+/* Set the chip select configuration register */
+#define LANTIQ_USIF_SET_CHIPSELECT_CONFIG(_v, _p)  \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_CS_CFG))
+
+/* Get the chip select configuration register */
+#define LANTIQ_USIF_GET_CHIPSELECT_CONFIG(_p)  \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_CS_CFG))
+
+/* Update the fractional divider configuration register */
+#define LANTIQ_USIF_FRAC_DIV_CONFIG(_v, _p)      \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_FDIV_CFG))
+
+/* Get the fractional divider configuration register */
+#define LANTIQ_USIF_GET_FRAC_DIV(_p)           \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_FDIV_CFG))
+
+/* Update the baudrate counter configuration register */
+#define LANTIQ_USIF_BAUDRATE_COUNTER_CONFIG(_v, _p)    \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_BC_CFG))
+
+/* Get the baudrate counter configuration register */
+#define LANTIQ_USIF_GET_BAUDRATE_COUNTER(_p)      \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_BC_CFG))
+
+/* Update the intercharacter timeout  configuration register */
+#define LANTIQ_USIF_INTERCHARACTER_TIMEOUT_CONFIG(_v, _p)  \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_ICTMO_CFG))
+
+/* Get the intercharacter timeout */
+#define LANTIQ_USIF_GET_INTERCHARACTER_TIMEOUT(_p)   \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_ICTMO_CFG))
+
+/* Update the chip select timing configuration */
+#define LANTIQ_USIF_SET_CS_TIMING_CONFIG(_v, _cs, _p)    \
+	LANTIQ_REG_W32((_v), (volatile u32 *)  \
+	((_p)->membase + LANTIQ_USIF_CS_TIMX_CFG((_cs))))
+
+/* Get the chip select timing configuration */
+#define LANTIQ_USIF_GET_CS_TIMING_CONFIG(_p, _cs)      \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_CS_TIMX_CFG(_cs)))
+
+/* Update the fifo configuration register */
+#define LANTIQ_USIF_SET_FIFO_CONFIG(_v, _p)      \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_FIFO_CFG))
+
+/* Get the fifo configuration */
+#define LANTIQ_USIF_GET_FIFO_CONFIG(_p)        \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_FIFO_CFG))
+
+/* Get the fifo status */
+#define LANTIQ_USIF_GET_FIFO_STATUS(_p)        \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_FIFO_STAT))
+
+/* Get RX filling level */
+#define LANTIQ_USIF_GET_RX_FILL_FIFO(_p)       \
+	MS(LANTIQ_USIF_GET_FIFO_STATUS((_p)), LANTIQ_USIF_FIFO_STAT_RX_FFS)
+
+/* Get TX filling level */
+#define LANTIQ_USIF_GET_TX_FILL_FIFO(_p)       \
+	MS(LANTIQ_USIF_GET_FIFO_STATUS((_p)), LANTIQ_USIF_FIFO_STAT_TX_FFS)
+
+/* Get FIFO ID <Size> */
+#define LANTIQ_USIF_GET_FIFO_ID(_p)           \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_FIFO_ID))
+
+/* Get SW control id */
+#define LANTIQ_USIF_GET_SWC_ID(_p)           \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_SWCID))
+
+/* Get TX/RX  fifo size */
+#define LANTIQ_USIF_GET_TX_FIFO_SIZE(_p)      \
+	((MS(LANTIQ_USIF_GET_FIFO_ID((_p)), LANTIQ_USIF_FIFO_ID_TX)))
+
+#define LANTIQ_USIF_GET_RX_FIFO_SIZE(_p)      \
+	((MS(LANTIQ_USIF_GET_FIFO_ID((_p)), LANTIQ_USIF_FIFO_ID_RX)))
+
+/* Get the character from receive buffer */
+#define LANTIQ_USIF_GET_RX_WORD(_p)           \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_RXD))
+
+#define LANTIQ_USIF_GET_RX_CHAR(_p)          \
+	((u8)LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_RXD)))
+
+/* Update transmission data sideband register */
+#define LANTIQ_USIF_CONFIG_TXD_SIDEBAND(_v, _p) \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_TXD_SB))
+
+/* Get transmission data sideband register */
+#define LANTIQ_USIF_GET_TXD_SIDEBAND_CONFIG(_p) \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_TXD_SB))
+
+/* Put one word to transmit buffer */
+#define LANTIQ_USIF_PUT_TX_WORD(_v, _p)          \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_TXD))
+
+/* Get one word from transmit buffer */
+#define LANTIQ_USIF_GET_TX_WORD(_p)          \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_TXD))
+
+#define LANTIQ_USIF_TXD_SIDEBAND_LAST_WORD_CONFIG(_x, _p) do {               \
+	LANTIQ_USIF_CONFIG_TXD_SIDEBAND(                                 \
+	(LANTIQ_USIF_TXD_SB_XME | SM(LANTIQ_USIF_TXD_CLASS0, LANTIQ_USIF_TXD_SB_TX_CLS)\
+	| SM((_x), LANTIQ_USIF_TXD_SB_TX_BE)), (_p));                            \
+} while (0)
+
+/* Put one byte to transmit buffer */
+#define LANTIQ_USIF_PUT_TX_CHAR(_v, _p)   do {                              \
+	LANTIQ_USIF_TXD_SIDEBAND_LAST_WORD_CONFIG(LANTIQ_USIF_TXD_BE1, (_p));     \
+	LANTIQ_USIF_PUT_TX_WORD((u32)(_v), (_p));                               \
+} while (0)
+
+
+/* Put last word to transmit buffer */
+#define LANTIQ_USIF_PUT_TX_LAST_WORD(_x, _v, _p)   do {                      \
+	LANTIQ_USIF_TXD_SIDEBAND_LAST_WORD_CONFIG((_x), (_p));                 \
+	LANTIQ_USIF_PUT_TX_WORD((u32)(_v), (_p));                              \
+} while (0)
+
+#define LANTIQ_USIF_TXD_SIDEBAND_CLS_LAST_WORD_CONFIG(_x, _y, _p) do {         \
+	LANTIQ_USIF_CONFIG_TXD_SIDEBAND(                                   \
+	(LANTIQ_USIF_TXD_SB_XME | SM((_x), LANTIQ_USIF_TXD_SB_TX_CLS)       \
+	| SM((_y), LANTIQ_USIF_TXD_SB_TX_BE)), (_p));                         \
+} while (0)
+
+/* Put one byte to transmit buffer */
+#define LANTIQ_USIF_PUT_TX_CLS_CHAR(_x, _v, _p)   do {                       \
+	LANTIQ_USIF_TXD_SIDEBAND_CLS_LAST_WORD_CONFIG   \
+	((_x), (LANTIQ_USIF_TXD_BE1), (_p));            \
+	LANTIQ_USIF_PUT_TX_WORD((u32)(_v), (_p));                          \
+} while (0)
+
+/* Put last word to transmit buffer */
+#define LANTIQ_USIF_PUT_TX_CLS_LAST_WORD(_x, _y, _v, _p)   do {         \
+	LANTIQ_USIF_TXD_SIDEBAND_CLS_LAST_WORD_CONFIG((_x), (_y), (_p));  \
+	LANTIQ_USIF_PUT_TX_WORD((u32)(_v), (_p));                        \
+} while (0)
+
+#define LANTIQ_USIF_SET_FIFO_CTRL(_v, _p)                  \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_FIFO_CTRL))
+
+/* Config the Maximum Received Packet Size Register */
+#define LANTIQ_USIF_CONFIG_RX_MRPS(_v, _p)       \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_MRPS_CTRL))
+
+/* Read the Maximum Received Packet Size Register */
+#define LANTIQ_USIF_GET_RX_MRPS(_p)            \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_MRPS_CTRL))
+
+/* Set DPLUS control register, write only */
+#define LANTIQ_USIF_CONFIG_DPLUS_CONTROL(_v, _p)  \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_DPLUS_CTRL))
+
+/* Get DPLUS status */
+#define LANTIQ_USIF_GET_DPLUS_STATUS(_p) \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_DPLUS_STAT))
+
+/* Get RX byte enable */
+#define LANTIQ_USIF_GET_DPLUS_RXBE(_p)         \
+	MS(LANTIQ_USIF_GET_DPLUS_STATUS((_p)), LANTIQ_USIF_DPLUS_STAT_RX_BE)
+
+/* Set Interrupt Mask Control Register */
+#define LANTIQ_USIF_SET_INT_MASK(_v, _p)         \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_IMSC))
+
+/* Get Interrupt Mask Control Register */
+#define LANTIQ_USIF_GET_INT_MASK(_p)           \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_IMSC))
+
+/* Clear Interrupt Mask Control Register */
+#define LANTIQ_USIF_CLR_INT_MASK(_v, _p)           \
+	LANTIQ_REG_CLR_BIT((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_IMSC))
+
+/* Get Raw Interrupt Status, from RIS register < debug only> */
+#define LANTIQ_USIF_GET_RAW_INT_STATUS(_p)     \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_RIS))
+
+/* Get Interrupt status, from MIS Register */
+#define LANTIQ_USIF_GET_INT_STATUS(_p)         \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_MIS))
+
+/* Set Interrupt Register <debug only> */
+#define LANTIQ_USIF_SET_INT(_v, _p)              \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_ISR))
+
+/* Clear Interrupt Register */
+#define LANTIQ_USIF_CLR_INT(_v, _p)              \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_ICR))
+
+/* Structure for transmit word */
+typedef union lantiq_usif_txd {
+	struct {
+		u8 byte[4];
+	} txd_byte;
+	u32 txd_word;
+} LANTIQ_USIF_TXD_t;
+
+/* Structure for receive word */
+typedef union lantiq_usif_rxd {
+	struct {
+		u8 byte[4];
+	} rxd_byte;
+	u32 rxd_word;
+} LANTIQ_USIF_RXD_t;
+
+
+/* Helper Macros */
+
+/*
+*  Register Operation
+*/
+#define LANTIQ_REG_R32(_r)                    __raw_readl((volatile unsigned int *)(_r))
+#define LANTIQ_REG_W32(_v, _r)               __raw_writel((_v), (volatile unsigned int *)(_r))
+#define LANTIQ_REG_W32_MASK(_clr, _set, _r)   LANTIQ_REG_W32((LANTIQ_REG_R32((_r)) & ~(_clr)) | (_set), (_r)) 
+#define LANTIQ_REG_R16(_r)                    __raw_readw((_r)) 
+#define LANTIQ_REG_W16(_v, _r)               __raw_writew((_v), (_r)) 
+#define LANTIQ_REG_W16_MASK(_clr, _set, _r)   LANTIQ_REG_W16((LANTIQ_REG_R16((_r)) & ~(_clr)) | (_set), (_r))
+#define LANTIQ_REG_R8(_r)                     __raw_readb((_r))
+#define LANTIQ_REG_W8(_v, _r)                __raw_writeb((_v), (_r))
+#define LANTIQ_REG_W8_MASK(_clr, _set, _r)    LANTIQ_REG_W8((LANTIQ_REG_R8((_r)) & ~(_clr)) | (_set), (_r))
+
+/*
+* Register manipulation macros that expect bit field defines
+* to follow the convention that an _S suffix is appended for
+* a shift count, while the field mask has no suffix. Or can use
+* _M as suffix
+*/
+
+/* Shift first, then mask, usually for write operation */
+#define SM(_v, _f)  (((_v) << _f##_S) & (_f))
+
+/* Mask first , then shift, usually for read operation */
+#define MS(_v, _f)  (((_v) & (_f)) >> _f##_S)
+
+/* Always report fatal error */
+#define LANTIQ_KASSERT(exp, msg) do {    \
+    if (unlikely(!(exp))) {      \
+	        printk msg;               \
+			BUG();                    \
+	}                             \
+} while (0)
+
+
+#endif /* LTQMIPS_USIF_REG_H */
+
diff --git a/drivers/tty/serial/lantiq_usif_uart.c b/drivers/tty/serial/lantiq_usif_uart.c
new file mode 100644
--- /dev/null
+++ b/drivers/tty/serial/lantiq_usif_uart.c
@@ -0,0 +1,2659 @@
+/******************************************************************************
+**
+** FILE NAME    : lantiq_usif_uart.c
+** PROJECT      : Lantiq
+** MODULES      : Serial driver for USIF
+** AUTHOR       : Lei Chuanhua
+** DESCRIPTION  : USIF module for uart driver
+** COPYRIGHT    :       Copyright (c) 2014
+**			Lantiq Deutschland GmbH 
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+** HISTORY
+** $Date        $Author         $Comment
+** 15 May,2009  Lei Chuanhua    Verififed on RTL REL 26p5/RTL 28.
+*******************************************************************************/
+#include <linux/module.h>
+#include <asm/irq.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/serial_core.h>
+#include <linux/tty_flip.h>
+#include <linux/proc_fs.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <irq.h>
+
+/* Project header */
+#include <lantiq_soc.h>
+#include <linux/clk.h>
+
+#include "lantiq_usif_uart.h"
+
+#define LANTIQ_USIF_UART_VER_MAJOR          1
+#define LANTIQ_USIF_UART_VER_MID            1
+#define LANTIQ_USIF_UART_VER_MINOR          4
+
+#define UART_PORT_TO_TTY(port)  ((port)->state->port.tty)
+#define UART_PORT_TO_XMIT(port) (&((port)->state->xmit))
+#define UART_PORT_TO_MSR(port)  ((port)->state->port.delta_msr_wait)
+
+/* #define LANTIQ_USIF_UART_DEBUG */
+
+enum {
+	USIF_UART_MSG_TX = 0x00000001,
+	USIF_UART_MSG_RX = 0x00000002,
+	USIF_UART_MSG_INT = 0x00000004, /* Interrupt msg */
+	USIF_UART_MSG_CFG = 0x00000008,
+	USIF_UART_MSG_DEBUG = 0x00000010,
+	USIF_UART_MSG_ERROR = 0x00000020,
+	USIF_UART_MSG_INIT = 0x00000040,
+	USIF_UART_MSG_CONSOLE = 0x00000080,
+	USIF_UART_MSG_ANY = 0x000000FF, /* anything */
+};
+
+#ifdef LANTIQ_USIF_UART_DEBUG
+#define INLINE
+static void lantiq_usif_uart_debug(LANTIQ_USIF_UART_PORT_t *port,
+	const char *fmt, ...);
+
+#define LANTIQ_USIF_UART_PRINT(_port, _m, _fmt, args...) do { \
+	if ((_port)->debug & (_m)) {                 \
+		lantiq_usif_uart_debug((_port), (_fmt), ##args); \
+	}  \
+} while (0)
+
+#else
+#define INLINE  inline
+#define LANTIQ_USIF_UART_PRINT(_port, _m, _fmt, ...)
+#endif /* LANTIQ_USIF_DEBUG */
+
+static int lantiq_usif_uart_hw_initialized;
+
+static void lantiq_usif_uart_stop_tx(struct uart_port *port);
+
+extern unsigned int ifx_get_usif_hz(void);
+
+#if defined(CONFIG_SERIAL_LANTIQ_USIF_UART_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#if defined(CONFIG_USE_PALLADIUM)
+#define LANTIQ_USIF_UART_MAX_BAUDRATE         4800
+#define LANTIQ_USIF_UART_DEFAULT_BAUDRATE     LANTIQ_USIF_BAUD_2400
+#elif defined(CONFIG_USE_VENUS)
+#define LANTIQ_USIF_UART_MAX_BAUDRATE         57600
+#define LANTIQ_USIF_UART_DEFAULT_BAUDRATE     LANTIQ_USIF_BAUD_38400
+#else
+#define LANTIQ_USIF_UART_MAX_BAUDRATE        115200
+#define LANTIQ_USIF_UART_DEFAULT_BAUDRATE    CONFIG_LANTIQ_USIF_UART_DEFAULT_BAUDRATE
+#endif /* CONFIG_USE_PALLADIUM */
+
+/* XXX, adjust the following table according to uart_clk clock */
+static const LANTIQ_USIF_HW_BAUDTABLE_t lantiq_usif_uart_baudrate_table[] = {
+	/* baud table index 0, for palladium  75638 */
+	{LANTIQ_USIF_UART_MAX_BAUDRATE,
+
+	 {
+	  {19, 292, 0, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_300},
+	  {97, 300, 0, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_1200},
+	  {194, 203, 0, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_2400},
+	  {474, 111, 0, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_4800},
+	  /* The following is placeholder */
+	  {1, 1, 71, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_9600},
+	  {1, 1, 35, 1, 1, 10, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_19200},
+	  {1, 1, 11, 1, 1, 20, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_38400},
+	  {1, 1, 11, 1, 1, 29, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_57600},
+	  {1, 1, 5, 1, 2, 58, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_115200},
+	  }
+	 },
+
+	/* baud table index 1 for Venus 1000000 */
+	{LANTIQ_USIF_UART_MAX_BAUDRATE,
+	 {
+	  {3, 2, 124, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_300},
+	  {12, 13, 24, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_1200},
+	  {24, 1, 24, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_2400},
+	  {48, 77, 4, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_4800},
+	  {96, 29, 4, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_9600},
+	  {192, 433, 0, 1, 1, 10, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_19200},
+	  {384, 241, 0, 1, 1, 20, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_38400},
+	  {482, 41, 0, 1, 1, 29, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_57600},
+	  /* The following is placeholder */
+	  {1, 1, 5, 1, 2, 58, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_115200},
+	  }
+	 },
+
+	/* baud table index 2 for silicon 100000000 */
+	{LANTIQ_USIF_UART_MAX_BAUDRATE,
+	 {
+	  {1, 2, 6921, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_300},
+	  {1, 346, 14, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_1200},
+	  {1, 185, 13, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_2400},
+	  {1, 92, 13, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_4800},
+	  {1, 92, 6, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_9600},
+	  {25, 601, 12, 1, 1, 10, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_19200},
+	  {25, 288, 12, 1, 1, 20, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_38400},
+	  {75, 551, 12, 1, 1, 29, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_57600},
+	  {75, 238, 12, 1, 2, 58, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_115200},
+	  }
+	 },
+
+	/* baud table index 3 for silicon 20000000 */
+	{LANTIQ_USIF_UART_MAX_BAUDRATE,
+	 {
+	  {1, 259, 15, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_300},
+	  {1, 346, 2, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_1200},
+	  {3, 139, 10, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_2400},
+	  {5, 88, 13, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_4800},
+	  {5, 88, 6, 1, 1, 5, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_9600},
+	  {29, 89, 15, 1, 1, 10, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_19200},
+	  {29, 30, 15, 1, 1, 20, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_38400},
+	  {77, 480, 2, 1, 1, 29, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_57600},
+	  {154, 403, 2, 1, 2, 58, 0, LANTIQ_USIF_HW_SHORT_TIMEOUT_115200},
+	  }
+	 },
+};
+
+#ifdef LANTIQ_USIF_UART_DEBUG
+//extern void prom_printf(const char *fmt, ...);
+#define prom_printf printk
+
+/**
+ * \fn static void lantiq_usif_uart_debug(LANTIQ_USIF_UART_PORT_t *port,
+ *  const char *fmt, ...)
+ * \brief Debug all kinds of level message
+ *
+ * \param   port    Pointer to structure #lantiq_usif_uart_debug
+ * \param   fmt     debug output format
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static void
+lantiq_usif_uart_debug(LANTIQ_USIF_UART_PORT_t *port, const char *fmt, ...)
+{
+	static char buf[256] = { 0 }; /* XXX */
+	va_list ap;
+
+	va_start(ap, fmt);
+	vsnprintf(buf, sizeof(buf), fmt, ap);
+	va_end(ap);
+
+	printk(KERN_INFO "%s\n", buf);
+}
+
+/**
+ * \fn static void  lantiq_usif_uart_reg_dump(struct uart_port *port)
+ * \brief Call this function to dump register through prom_printf
+ *
+ * \param   port    Pointer to structure #usif_uart
+ * \return  none
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static void lantiq_usif_uart_reg_dump(struct uart_port *port)
+{
+	prom_printf("USIF_ID           0x%08x\n", LANTIQ_USIF_GET_ID(port));
+	prom_printf("USIF_SWCID        0x%08x\n",
+		LANTIQ_USIF_GET_SWC_ID(port));
+	prom_printf("USIF_FIFO_ID      0x%08x\n",
+		LANTIQ_USIF_GET_FIFO_ID(port));
+
+	prom_printf("USIF_CLC_CNT      0x%08x\n",
+		LANTIQ_USIF_GET_CLOCK_COUNTER(port));
+	prom_printf("USIF_CLC_STAT     0x%08x\n",
+		LANTIQ_USIF_GET_CLOCK_STATUS(port));
+
+	prom_printf("USIF_MODE_CFG     0x%08x\n",
+		LANTIQ_USIF_GET_MODE_CONFIG(port));
+	prom_printf("USIF_PRTC_CFG     0x%08x\n",
+		LANTIQ_USIF_GET_PROTOCOL_CONFIG(port));
+	prom_printf("USIF_PRTC_STAT    0x%08x\n",
+		LANTIQ_USIF_GET_PROTOCOL_STATUS(port));
+
+	prom_printf("USIF_CS_CFG       0x%08x\n",
+		LANTIQ_USIF_GET_CHIPSELECT_CONFIG(port));
+	prom_printf("USIF_FDIV_CFG     0x%08x\n",
+		LANTIQ_USIF_GET_FRAC_DIV(port));
+	prom_printf("USIF_BC_CFG       0x%08x\n",
+		LANTIQ_USIF_GET_BAUDRATE_COUNTER(port));
+	prom_printf("USIF_ICTMO_CFG    0x%08x\n",
+		LANTIQ_USIF_GET_INTERCHARACTER_TIMEOUT(port));
+
+	prom_printf("USIF_FIFO_CFG     0x%08x\n",
+		LANTIQ_USIF_GET_FIFO_CONFIG(port));
+	prom_printf("USIF_FIFO_STAT    0x%08x\n",
+		LANTIQ_USIF_GET_FIFO_STATUS(port));
+	prom_printf("USIF_TXD_SB       0x%08x\n",
+		LANTIQ_USIF_GET_TXD_SIDEBAND_CONFIG(port));
+	prom_printf("USIF_DPLUS_STAT   0x%08x\n",
+		LANTIQ_USIF_GET_DPLUS_STATUS(port));
+	prom_printf("USIF_TXD          0x%08x\n",
+		LANTIQ_USIF_GET_TX_WORD(port));
+	if (LANTIQ_USIF_GET_CLOCK_STATUS(port) & LANTIQ_USIF_CLC_STAT_RUN) {
+		prom_printf("USIF_RXD          0x%08x\n",
+			LANTIQ_USIF_GET_RX_WORD(port));
+	}
+	prom_printf("USIF_MRPS_CTRL    0x%08x\n",
+		LANTIQ_USIF_GET_RX_MRPS(port));
+	prom_printf("USIF_RIS          0x%08x\n",
+		LANTIQ_USIF_GET_RAW_INT_STATUS(port));
+	prom_printf("USIF_IMSC         0x%08x\n",
+		LANTIQ_USIF_GET_INT_MASK(port));
+	prom_printf("USIF_MIS          0x%08x\n",
+		LANTIQ_USIF_GET_INT_STATUS(port));
+}
+
+#endif /* LANTIQ_USIF_DEBUG */
+
+/**
+ * \fn  static unsigned int lantiq_usif_uart_rx_err(struct uart_port *port,
+ *  u8 *flg)
+ *
+ * \brief  Helper function receive interrupts, to check any error occured.
+ *
+ * The return value of this function tells whether to ignore the receiveed
+ * character or not, where as the 'flg' is updated with the received character
+ * is normal or contain any error.
+
+ * \param  port   pointer to USIF uart port.
+ * \param   flg    pointer, this function updates it with appropriate flag.
+ *
+ * \return  USIF_UART_RX_GOOD_CHAR    Need to insert  the data to FLIP buffer
+ * \return  USIF_UART_RX_IGNORE_CHAR  Ignore the received data
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static unsigned int lantiq_usif_uart_rx_err(struct uart_port *port, u8 *flg)
+{
+	u32 ret;
+	u32 error_state;
+	struct tty_struct *tty = UART_PORT_TO_TTY(port);
+
+	/* The 'flg' is set to normal, if no error detected */
+	*flg = TTY_NORMAL;
+	ret = LANTIQ_USIF_UART_RX_GOOD_CHAR;
+
+	/*
+	 * USIF supports RX overflow error, parity error and frame error.
+	 * It does not support the break error
+	 */
+	error_state = LANTIQ_USIF_GET_INT_STATUS(port) & LANTIQ_USIF_RX_ERR;
+	if (error_state) {
+		if ((error_state & LANTIQ_USIF_INT_RXOF)) {
+			port->icount.overrun++;
+			LANTIQ_USIF_UART_IRQ_LOCK(port);
+			LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_RXOF, port);
+			LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+		}
+		if ((error_state & LANTIQ_USIF_INT_PE)) {
+			port->icount.parity++;
+			LANTIQ_USIF_UART_IRQ_LOCK(port);
+			LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_PE, port);
+			LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+		}
+		if ((error_state & LANTIQ_USIF_INT_FE)) {
+			port->icount.frame++;
+			LANTIQ_USIF_UART_IRQ_LOCK(port);
+			LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_FE, port);
+			LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+		}
+
+		/* Check whether we need to ignore the characters */
+		if (error_state & port->ignore_status_mask)
+			return LANTIQ_USIF_UART_RX_IGNORE_CHAR;
+
+		/* Check whether we need to read the characters with errors */
+		error_state &= port->read_status_mask;
+		if (error_state & LANTIQ_USIF_INT_PE)
+			*flg = TTY_PARITY;
+		else if (error_state & LANTIQ_USIF_INT_FE)
+			*flg = TTY_FRAME;
+
+		if (error_state & LANTIQ_USIF_INT_RXOF) {
+			/*
+			 * If we have overrun error, report it immediately,
+			 * as it does not affect the received characters
+			 */
+			tty_insert_flip_char(tty->port, 0, TTY_OVERRUN);
+		}
+	}
+	/* Else do nothing, no error detected */
+	return ret;
+}
+
+/**
+ * \fn     static INLINE void  lantiq_usif_uart_run_time_config
+ * (struct uart_port *port)
+ *
+ * \brief  Call this function to reset some runtime parameters
+ *
+ * \param  port   pointer to USIF uart port.
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static INLINE void lantiq_usif_uart_run_time_config(struct uart_port *port)
+{
+	u32 reg;
+
+	/*
+	 * NB, Configure RX MRPS to zero, so intercharacter timeout must be set
+	 * This is important, otherwise, rx interrupt may not generate.
+	 * MRPS should be configured for every rx transaction
+	 * Once config/run mode switched, MRPS will be reset to zero
+	 */
+	LANTIQ_USIF_CONFIG_RX_MRPS(0, port);
+
+	/* TX sideband register, class 0, no DMA for RX/TX */
+	LANTIQ_USIF_CONFIG_TXD_SIDEBAND(
+		SM(LANTIQ_USIF_TXD_CLASS0, LANTIQ_USIF_TXD_SB_TX_CLS), port);
+	reg = LANTIQ_USIF_DPLUS_CTRL_TX_DIS | LANTIQ_USIF_DPLUS_CTRL_RX_MASK |
+		LANTIQ_USIF_DPLUS_CTRL_SET_MASK;
+	LANTIQ_USIF_CONFIG_DPLUS_CONTROL(reg, port);
+}
+
+/**
+ * \fn static void lantiq_usif_uart_rx_breq(struct uart_port *port)
+ *
+ * \brief  Receive interrupt service routine for BREQ.
+ *
+ * The TOPSPIN Receive FIFO is configured as Flow-Controller mode,
+ * byte aligned and burst size is set to four words. So, each received
+ * word will have four characters
+ *
+ * \param  port   pointer to USIF uart port.
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static void lantiq_usif_uart_rx_breq(struct uart_port *port)
+{
+	u8 flg;
+	struct tty_struct *tty = UART_PORT_TO_TTY(port);
+	LANTIQ_USIF_UART_PORT_t *usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+	LANTIQ_USIF_UART_PROC_STAT_t *stat = &(usif_port_p->usif_proc_data);
+	LANTIQ_USIF_RXD_t rxd_data;
+	u32 word_cnt, char_cnt;
+
+	/* Read each words in the whole burst */
+	for (word_cnt = 0; word_cnt < LANTIQ_USIF_UART_RX_BUSRT_SIZE;
+	     word_cnt++) {
+
+		stat->rx_read_fifo++;
+
+		/* Read the word from the RX FIFO, update the local
+		   RPS counter and RX counter */
+		rxd_data.rxd_word = LANTIQ_USIF_GET_RX_WORD(port);
+		usif_port_p->rx_rps_cnt +=
+			LANTIQ_USIF_UART_RX_FIFO_CHARS_PER_WORD;
+		port->icount.rx += LANTIQ_USIF_UART_RX_FIFO_CHARS_PER_WORD;
+
+		/*
+		 * Check whether any error set. If any error set, check
+		 * whether the character need to be ignored, using
+		 * ignore_status_mask and read_status_mask.
+		 * Note that, we ignore the whole word (4 characters)
+		 */
+		if (lantiq_usif_uart_rx_err(port, &flg) !=
+		    LANTIQ_USIF_UART_RX_IGNORE_CHAR) {
+			for (char_cnt = 0;
+			     char_cnt < LANTIQ_USIF_UART_RX_FIFO_CHARS_PER_WORD;
+			     char_cnt++) {
+				unsigned char rx_byte =
+					rxd_data.rxd_byte.byte[char_cnt];
+
+				if (!uart_handle_sysrq_char(port, rx_byte)) {
+					tty_insert_flip_char(tty->port, rx_byte,
+							flg);
+				}
+			}
+		}
+	}
+	stat->rx_intr_breq++;
+	/*
+	 * Try to push the data from FLIP buffer to line discipline. This need
+	 * not be required in case of low latency enabled as it does that while
+	 * checking the sufficient space in FLIP buffer initially
+	 */
+	if (!(tty->port->low_latency))
+		tty_flip_buffer_push(tty->port);
+
+	LANTIQ_USIF_UART_IRQ_LOCK(port);
+	LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_RX_BREQ, port);
+	LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+}
+
+/**
+ * \fn     static void lantiq_usif_uart_rx_lbreq(struct uart_port *port)
+ *
+ * \brief  Receive interrupt service routine for LBREQ.
+ *
+ * \param  port   pointer to USIF uart port.
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static void lantiq_usif_uart_rx_lbreq(struct uart_port *port)
+{
+	char flg;
+	struct tty_struct *tty = UART_PORT_TO_TTY(port);
+	LANTIQ_USIF_UART_PORT_t *usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+	LANTIQ_USIF_UART_PROC_STAT_t *stat = &(usif_port_p->usif_proc_data);
+	u32 word_cnt, char_cnt;
+	u32 ign_char;
+	u32 rx_cnt = 0;
+	u32 reg;
+	LANTIQ_USIF_RXD_t rxd_data;
+
+	/* Receive complete words first */
+	for (word_cnt = 0; word_cnt < LANTIQ_USIF_UART_RX_BUSRT_SIZE - 1;
+	     word_cnt++) {
+
+		stat->rx_read_fifo++;
+		rxd_data.rxd_word = LANTIQ_USIF_GET_RX_WORD(port);
+
+		/*
+		 * Check whether any error set. If any error set, check
+		 * whether the character need to be ignored, using
+		 * ignore_status_mask and read_status_mask. Note that,
+		 * we ignore the whole word (4 characters)
+		 */
+		ign_char = lantiq_usif_uart_rx_err(port, &flg);
+
+		for (char_cnt = 0;
+		     char_cnt < LANTIQ_USIF_UART_RX_FIFO_CHARS_PER_WORD;
+		     char_cnt++) {
+			usif_port_p->rx_rps_cnt++;
+			port->icount.rx++;
+			if (ign_char != LANTIQ_USIF_UART_RX_IGNORE_CHAR) {
+				unsigned char rx_byte =
+					rxd_data.rxd_byte.byte[char_cnt];
+
+				if (!uart_handle_sysrq_char(port, rx_byte)) {
+					tty_insert_flip_char(tty->port, rx_byte,
+						flg);
+				}
+			}
+		}
+	}
+
+	/* Receive the last complete or incomplete word */
+	stat->rx_read_fifo++;
+	reg = LANTIQ_USIF_GET_DPLUS_STATUS(port);
+	if (reg & LANTIQ_USIF_DPLUS_STAT_RME) {
+		rx_cnt = MS(reg, LANTIQ_USIF_DPLUS_STAT_RX_BE);
+		if (rx_cnt == 0)
+			rx_cnt = LANTIQ_USIF_UART_RX_FIFO_CHARS_PER_WORD;
+
+	}
+	rxd_data.rxd_word = LANTIQ_USIF_GET_RX_WORD(port);
+	/*
+	 * Check wh1ether any error set. If any error set, check whether the
+	 * character need to be ignored, using ignore_status_mask and
+	 * read_status_mask. Note that, we ignore the whole word (4 chracters)
+	 */
+	ign_char = lantiq_usif_uart_rx_err(port, &flg);
+
+	for (char_cnt = 0; char_cnt < rx_cnt; char_cnt++) {
+		usif_port_p->rx_rps_cnt++;
+		port->icount.rx++;
+		if (ign_char != LANTIQ_USIF_UART_RX_IGNORE_CHAR) {
+			unsigned char rx_byte =
+				rxd_data.rxd_byte.byte[char_cnt];
+
+			if (!uart_handle_sysrq_char(port, rx_byte))
+				tty_insert_flip_char(tty->port, rx_byte, flg);
+
+		}
+	}
+
+	stat->rx_intr_lbreq++;
+
+	/* Completed the reception of packet, clear this count */
+	usif_port_p->rx_rps_cnt = 0x00;
+
+	/* Try to push the data from FLIP buffer to line discipline. */
+	tty_flip_buffer_push(tty->port);
+	LANTIQ_USIF_UART_IRQ_LOCK(port);
+	LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_RX_LBREQ, port);
+	LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+}
+
+/**
+ * \fn     static void lantiq_usif_uart_rx_sreq(struct uart_port *port)
+ *
+ * \brief  Receive interrupt service routine for SREQ.
+ *
+
+ * \param  port   pointer to USIF uart port.
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static void lantiq_usif_uart_rx_sreq(struct uart_port *port)
+{
+	u8 flg;
+	struct tty_struct *tty = UART_PORT_TO_TTY(port);
+	LANTIQ_USIF_UART_PORT_t *usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+	LANTIQ_USIF_UART_PROC_STAT_t *stat = &(usif_port_p->usif_proc_data);
+	u32 char_cnt;
+	LANTIQ_USIF_RXD_t rxd_data;
+
+	stat->rx_read_fifo++;
+	rxd_data.rxd_word = LANTIQ_USIF_GET_RX_WORD(port);
+	usif_port_p->rx_rps_cnt += LANTIQ_USIF_UART_RX_FIFO_CHARS_PER_WORD;
+	port->icount.rx += LANTIQ_USIF_UART_RX_FIFO_CHARS_PER_WORD;
+
+#ifdef LANTIQ_USIF_UART_DEBUG
+	{
+		int i;
+
+		/* XXX, dump the data to verify  */
+		prom_printf("%s rxd_data.rxd_word 0x%08x\n", __func__,
+			rxd_data.rxd_word);
+		prom_printf("USIF_DPLUS_STAT 0x%08x\n",
+			LANTIQ_USIF_GET_DPLUS_STATUS(port));
+
+		for (i = 0; i < 4; i++) {
+			prom_printf("rxd_byte.byte[%d], %c\n", i,
+				rxd_data.rxd_byte.byte[i]);
+		}
+	}
+#endif
+
+	/*
+	 * Check whether any error set. If any error set, check whether the
+	 * character need to be ignored, using ignore_status_mask and
+	 * read_status_mask. Note that, we ignore the whole word (4 bytes)
+	 */
+	if (lantiq_usif_uart_rx_err(port, &flg) !=
+	    LANTIQ_USIF_UART_RX_IGNORE_CHAR) {
+		for (char_cnt = 0;
+			char_cnt < LANTIQ_USIF_UART_RX_FIFO_CHARS_PER_WORD;
+			char_cnt++) {
+			unsigned char rx_byte =
+				rxd_data.rxd_byte.byte[char_cnt];
+
+			if (!uart_handle_sysrq_char(port, rx_byte))
+				tty_insert_flip_char(tty->port, rx_byte, flg);
+
+		}
+	}
+
+	stat->rx_intr_sreq++;
+	/*
+	 * We need not try to push the data from FLIP buffer to line
+	 * dicsipline here, as, at the most, we can get only 3 single
+	 * requests in a row and the fourth one would be the last single
+	 * request
+	 */
+	LANTIQ_USIF_UART_IRQ_LOCK(port);
+	LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_RX_SREQ, port);
+	LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+}
+
+/**
+ * \fn     static void lantiq_usif_uart_rx_lsreq(struct uart_port *port)
+ *
+ * \brief  Receive interrupt service routine for LSREQ.
+ *
+ * \param  port   pointer to USIF uart port.
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static void lantiq_usif_uart_rx_lsreq(struct uart_port *port)
+{
+	u8 flg;
+	struct tty_struct *tty = UART_PORT_TO_TTY(port);
+	LANTIQ_USIF_UART_PORT_t *usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+	LANTIQ_USIF_UART_PROC_STAT_t *stat = &(usif_port_p->usif_proc_data);
+	u32 char_cnt;
+	u32 ign_char;
+	u32 rx_cnt = 0;
+	LANTIQ_USIF_RXD_t rxd_data;
+	u32 reg;
+
+	stat->rx_read_fifo++;
+
+	reg = LANTIQ_USIF_GET_DPLUS_STATUS(port);
+	if (reg & LANTIQ_USIF_DPLUS_STAT_RME) {
+		rx_cnt = MS(reg, LANTIQ_USIF_DPLUS_STAT_RX_BE);
+		if (rx_cnt == 0)
+			rx_cnt = LANTIQ_USIF_UART_RX_FIFO_CHARS_PER_WORD;
+
+	}
+
+	rxd_data.rxd_word = LANTIQ_USIF_GET_RX_WORD(port);
+
+#ifdef LANTIQ_USIF_UART_DEBUG
+	{
+		int i;
+
+		/* XXX, dump the data to verify  */
+		prom_printf("%s rxd_data.rxd_word 0x%08x\n", __func__,
+			rxd_data.rxd_word);
+		prom_printf("USIF_DPLUS_STAT 0x%08x\n",
+			LANTIQ_USIF_GET_DPLUS_STATUS(port));
+
+		for (i = 0; i < rx_cnt; i++) {
+			prom_printf("rxd_byte.byte[%d], %c\n", i,
+				rxd_data.rxd_byte.byte[i]);
+		}
+	}
+#endif
+	/*
+	 * Check wh1ether any error set. If any error set, check whether the
+	 * character need to be ignored, using ignore_status_mask and
+	 * read_status_mask. Note that, we ignore the whole word (4 chracters)
+	 */
+	ign_char = lantiq_usif_uart_rx_err(port, &flg);
+
+	for (char_cnt = 0; char_cnt < rx_cnt; char_cnt++) {
+		usif_port_p->rx_rps_cnt++;
+		port->icount.rx++;
+		if (ign_char != LANTIQ_USIF_UART_RX_IGNORE_CHAR) {
+			unsigned char rx_byte =
+				rxd_data.rxd_byte.byte[char_cnt];
+
+			if (!uart_handle_sysrq_char(port, rx_byte))
+				tty_insert_flip_char(tty->port, rx_byte, flg);
+
+		}
+	}
+	stat->rx_intr_lsreq++;
+	/* Completed the reception of packet, clear this count */
+	usif_port_p->rx_rps_cnt = 0x00;
+
+	tty_flip_buffer_push(tty->port);
+	LANTIQ_USIF_UART_IRQ_LOCK(port);
+	LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_RX_LSREQ, port);
+	LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+}
+
+/**
+ * \fn     static int lantiq_usif_uart_put_tx_word(struct uart_port *port)
+ *
+ * \brief  Helper function transmit interrupts, to put the word into FIFO.
+ *
+ *
+ * \param  port   pointer to USIF uart port.
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static int lantiq_usif_uart_put_tx_word(struct uart_port *port)
+{
+	int xme = 0; /* Transmit Message End */
+	int xbe = 0; /* Transmit Byte Enable */
+	u32 tx_tps_cnt;
+	struct circ_buf *xmit = UART_PORT_TO_XMIT(port);
+	LANTIQ_USIF_UART_PORT_t *usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+	LANTIQ_USIF_UART_PROC_STAT_t *stat = &(usif_port_p->usif_proc_data);
+	LANTIQ_USIF_TXD_t txd_data;
+	u32 char_cnt;
+
+	tx_tps_cnt = uart_circ_chars_pending(xmit);
+
+	/* Sanity check, return immediately */
+	if (tx_tps_cnt == 0) {
+		LANTIQ_USIF_CLR_INT_MASK(LANTIQ_USIF_INT_TRANSMIT, port);
+		return 0;
+	}
+
+	/* Last word or last incomplete word processing */
+	if (tx_tps_cnt <= LANTIQ_USIF_UART_TX_FIFO_CHARS_PER_WORD) {
+		xme = 1;
+		xbe = (tx_tps_cnt == LANTIQ_USIF_UART_TX_FIFO_CHARS_PER_WORD)
+			? 0 : tx_tps_cnt;
+	}
+
+	for (char_cnt = 0; char_cnt < LANTIQ_USIF_UART_TX_FIFO_CHARS_PER_WORD;
+		char_cnt++) {
+		if (tx_tps_cnt) {
+#ifdef LANTIQ_USIF_UART_DEBUG
+			prom_printf("%s 0x%02x %c\n", __func__,
+				xmit->buf[xmit->tail],
+				xmit->buf[xmit->tail]);
+#endif
+			txd_data.txd_byte.byte[char_cnt] =
+				xmit->buf[xmit->tail];
+			xmit->tail =
+				(xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+			port->icount.tx++;
+			tx_tps_cnt--;
+		} else {
+			LANTIQ_USIF_CLR_INT_MASK(LANTIQ_USIF_INT_TRANSMIT, port);
+			break;
+		}
+	}
+	LANTIQ_USIF_UART_IRQ_LOCK(port);
+	/* XXX, Last Complete/incomplete word */
+	if (xme == 1)
+		LANTIQ_USIF_TXD_SIDEBAND_LAST_WORD_CONFIG(xbe, port);
+	LANTIQ_USIF_PUT_TX_WORD(txd_data.txd_word, port);
+	LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+	stat->tx_write_fifo++;
+	return 0;
+}
+
+/**
+ * \fn     static void lantiq_usif_uart_tx_check_stopped(struct uart_port *port)
+ *
+ * \brief  Helper function transmit interrupts, to check whether the
+ *         data transmit is stopped.
+ *
+ *         The data transmission could be forced to stop, due to flow control
+ *         de-assertion by TTY layer.
+ *
+ * \param  port   pointer to USIF uart port.
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static void lantiq_usif_uart_tx_check_stopped(struct uart_port *port)
+{
+	LANTIQ_USIF_UART_PORT_t *usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+	LANTIQ_USIF_UART_PROC_STAT_t *stat = &(usif_port_p->usif_proc_data);
+
+	if (uart_tx_stopped(port)) {
+		stat->tx_stopped++;
+		LANTIQ_USIF_UART_IRQ_LOCK(port);
+		LANTIQ_USIF_CLR_INT_MASK(LANTIQ_USIF_INT_TRANSMIT, port);
+		LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+	}
+}
+
+/**
+ * \fn     static void lantiq_usif_uart_transmit_chars(struct uart_port *port,
+ * unsigned int burst_type)
+ *
+ *
+ * \brief  Transmit interrupt service routine.
+ *
+ * The TOPSPIN Transmit FIFO is configured as Flow-Controller mode,
+ * byte aligned and the burst size is set to four words. So each transmitted
+ * word will have four characters
+ *
+ * \param  port        pointer to USIF uart port.
+ * \param  burst_type  Interrupt source, burst type.
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static void
+lantiq_usif_uart_transmit_chars(struct uart_port *port, unsigned int burst_type)
+{
+	u32 word_cnt;
+	u32 tx_fifo_fs;
+	LANTIQ_USIF_UART_PORT_t *usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+	LANTIQ_USIF_UART_PROC_STAT_t *stat = &(usif_port_p->usif_proc_data);
+
+	/* Get the TX FIFO filled stages */
+	tx_fifo_fs = LANTIQ_USIF_GET_TX_FILL_FIFO(port);
+
+	/*
+	 * Service the transmit request, depending on burst type
+	 * XXX, should decode every bit, but USIF BREQ/SREQ will come together
+	 * if TX FIFO is empty.
+	 */
+	switch (burst_type) {
+	case LANTIQ_USIF_INT_TX_REQ:
+	case LANTIQ_USIF_INT_TX_BREQ:
+		/* Check whether sufficient empty space in FIFO */
+		if ((LANTIQ_USIF_GET_TX_FIFO_SIZE(port) - tx_fifo_fs) <
+			LANTIQ_USIF_UART_TX_BUSRT_SIZE) {
+			stat->tx_req_fifo_full++;
+		} else {
+			for (word_cnt = 0;
+				word_cnt < LANTIQ_USIF_UART_TX_BUSRT_SIZE;
+				word_cnt++) {
+				if (!lantiq_usif_uart_put_tx_word(port))
+					break;
+
+			}
+		}
+
+		/*
+		 * The transmission cannot be stopped while the data is
+		 * partially written during the burst request. Note that,
+		 * the data is transmitted in 4 words (4*4 characters)
+		 * per burst request and 4 characters per single request
+		 */
+		lantiq_usif_uart_tx_check_stopped(port);
+		stat->tx_intr_breq++;
+		LANTIQ_USIF_UART_IRQ_LOCK(port);
+		LANTIQ_USIF_CLR_INT(burst_type, port);
+		LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+		break;
+
+	case LANTIQ_USIF_INT_TX_SREQ:
+		/* Check whether sufficient empty space in FIFO */
+		if ((LANTIQ_USIF_GET_TX_FIFO_SIZE(port) - tx_fifo_fs) < 0x01)
+			stat->tx_req_fifo_full++;
+		else
+			lantiq_usif_uart_put_tx_word(port);
+
+		lantiq_usif_uart_tx_check_stopped(port);
+		stat->tx_intr_sreq++;
+		LANTIQ_USIF_UART_IRQ_LOCK(port);
+		LANTIQ_USIF_CLR_INT(burst_type, port);
+		LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+		break;
+
+	default:
+		printk(KERN_ERR "%s: Should not come here\n", __func__);
+		break;
+	}
+}
+
+/**
+ * \fn     static irqreturn_t lantiq_usif_uart_err_intr(int irq, void *dev_id)
+ *
+ * \brief  Error handler routine.
+ *
+ *         The LANTIQ_USIF_INT_RXOF, LANTIQ_USIF_INT_PE and LANTIQ_USIF_INT_FE
+ *         errors are handled while servicing the receive interrupts, so these
+ *         interrupts mask are disabled.
+ *
+ * \param  irq         interrupt irq number
+ * \param  dev_id      cast to USIF uart port
+ *
+ * \return  IRQ_HANDLED irq has been handled
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static irqreturn_t
+lantiq_usif_uart_err_intr(int irq, void *dev_id)
+{
+	u32 status;
+	struct uart_port *port = dev_id;
+	LANTIQ_USIF_UART_PORT_t *usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+	LANTIQ_USIF_UART_PROC_STAT_t *stat = &(usif_port_p->usif_proc_data);
+
+	status = LANTIQ_USIF_GET_INT_STATUS(port) & LANTIQ_USIF_INT_ERR_MASK;
+	if (status & LANTIQ_USIF_INT_RXUR) {
+		stat->err_int_rxur++;
+		LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_RXUR, port);
+	}
+
+	if (status & LANTIQ_USIF_INT_TXUR) {
+		stat->err_int_txur++;
+		LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_TXUR, port);
+	}
+
+	if (status & LANTIQ_USIF_INT_TXOF) {
+		stat->err_int_txof++;
+		LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_TXOF, port);
+	}
+
+	if (status & LANTIQ_USIF_INT_PHE) {
+		stat->err_int_phe++;
+		LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_PHE, port);
+	}
+
+	if (status & LANTIQ_USIF_INT_CRC) {
+		stat->err_int_crc++;
+		LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_CRC, port);
+	}
+
+	/*
+	 * WAR, flush write, fix hardware timing issue. Make sure device clear
+	 * operation happens before ICU clear operation. Other ways to do are
+	 * mmiowb() and etc
+	 */
+	LANTIQ_USIF_GET_INT_STATUS(port);
+	return IRQ_HANDLED;
+}
+
+/**
+ * \fn     static void lantiq_usif_uart_start_tx(struct uart_port *port)
+ *
+ * \brief  This function is used to initiate a transmision
+ *
+ * \param  port     pointer to USIF uart port
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static void lantiq_usif_uart_start_tx(struct uart_port *port)
+{
+	u32 cr;
+	struct circ_buf *xmit = UART_PORT_TO_XMIT(port);
+	LANTIQ_USIF_UART_PORT_t *usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+	LANTIQ_USIF_UART_PROC_STAT_t *stat = &(usif_port_p->usif_proc_data);
+
+	stat->tx_start_req++;
+
+	/*
+	 * Do not the start the transmission, if the circular buffer has no
+	 * data or the data transmission is stopped. But need to transmit
+	 * software flow control data (not implemented now)
+	 */
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		lantiq_usif_uart_stop_tx(port);
+		return;
+	}
+
+	/*
+	 * If a XON/XOFF character needs to be transmitted out, the
+	 * x_char field of the port is set by the serial core
+	 */
+	if (port->x_char) {
+		LANTIQ_USIF_UART_IRQ_LOCK(port);
+		LANTIQ_USIF_PUT_TX_CHAR(port->x_char, port);
+		LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+
+	/*
+	 * Initiate the transmission, only if the transmission is not active
+	 * already or stopped due to flow control
+	 */
+	if ((usif_port_p->tx_progress ==
+		LANTIQ_USIF_UART_TX_PROGRESS_INACTIVE)) {
+		/*
+		 * Initiate the TPS register to start the transmission
+		 * Note that, the transmit FIFO in TOPSPIN module is used in
+		 * flow control mode
+		 */
+		if (uart_circ_chars_pending(xmit)) {
+			usif_port_p->tx_progress =
+				LANTIQ_USIF_UART_TX_PROGRESS_ACTIVE;
+		} else
+			return; /* No data to send, return immediately */
+	}
+	/*
+	 * Set the TX mask. We need to process the TX interrupts.
+	 * Enable mask, if not enabled already
+	 */
+	LANTIQ_USIF_UART_IRQ_LOCK(port);
+	cr = LANTIQ_USIF_GET_INT_MASK(port);
+	if ((cr & LANTIQ_USIF_INT_TRANSMIT) != LANTIQ_USIF_INT_TRANSMIT) {
+		cr |= LANTIQ_USIF_INT_TRANSMIT | LANTIQ_USIF_INT_TX_FIN;
+		LANTIQ_USIF_SET_INT_MASK(cr, port);
+	}
+	LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+}
+
+/**
+ * \fn     static void lantiq_usif_uart_stop_tx(struct uart_port *port)
+ *
+ * \brief  This function is used to stop the transmision
+ *
+ * \param  port     pointer to USIF uart port
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static void lantiq_usif_uart_stop_tx(struct uart_port *port)
+{
+	LANTIQ_USIF_UART_PORT_t *usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+	LANTIQ_USIF_UART_PROC_STAT_t *stat = &(usif_port_p->usif_proc_data);
+
+	/* Remove the TX mask. We do not want to process TX interrupts
+	   any more now */
+	stat->tx_stop_req++;
+
+	LANTIQ_USIF_UART_IRQ_LOCK(port);
+	LANTIQ_USIF_CLR_INT_MASK(LANTIQ_USIF_INT_TRANSMIT | LANTIQ_USIF_INT_TX_FIN,
+			port);
+	LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+}
+
+/**
+ * \fn static irqreturn_t lantiq_usif_uart_status_intr(int irq, void *dev_id)
+ *
+ * \brief  STA interrupt handler routine.
+ *
+ * \param  irq         interrupt irq number
+ * \param   dev_id     pointer to USIF uart port
+ *
+ * \return IRQ_HANDLED  irq has been handled
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static irqreturn_t
+lantiq_usif_uart_status_intr(int irq, void *dev_id)
+{
+	struct uart_port *port = dev_id;
+	LANTIQ_USIF_UART_PORT_t *usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+	LANTIQ_USIF_UART_PROC_STAT_t *stat = &(usif_port_p->usif_proc_data);
+	struct circ_buf *xmit = UART_PORT_TO_XMIT(port);
+	u32 status, modem_status;
+
+	status = LANTIQ_USIF_GET_INT_STATUS(port) & LANTIQ_USIF_INT_STA_ALL;
+#ifdef LANTIQ_USIF_UART_DEBUG
+	prom_printf("%s irq %d USIF_MIS 0x%08x\n", __func__, irq,
+		LANTIQ_USIF_GET_INT_STATUS(port));
+	prom_printf("%s irq %d USIF_RIS 0x%08x\n", __func__, irq,
+		LANTIQ_USIF_GET_RAW_INT_STATUS(port));
+	prom_printf("%s irq %d USIF_IMSC 0x%08x\n", __func__, irq,
+		LANTIQ_USIF_GET_INT_MASK(port));
+#endif
+	/* XXX, handle spurious interrupts */
+	if ((status & LANTIQ_USIF_INT_FCI)) {
+		modem_status = LANTIQ_USIF_GET_MODEM_STATUS(port);
+
+		uart_handle_cts_change(port,
+			modem_status & LANTIQ_USIF_MSS_STAT_FCI);
+
+		wake_up_interruptible(&UART_PORT_TO_MSR(port));
+
+		LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_FCI, port);
+	}
+	if ((status & LANTIQ_USIF_INT_TX_FIN)) {
+		if (uart_tx_stopped(port)) {
+			lantiq_usif_uart_stop_tx(port);
+			usif_port_p->tx_progress =
+				LANTIQ_USIF_UART_TX_PROGRESS_INACTIVE;
+		} else {
+			/* not available now Initiate another transmission,
+			 * if the circular buffer has still characters to send
+			 */
+			if (uart_circ_empty(xmit)) {
+				lantiq_usif_uart_stop_tx(port);
+				usif_port_p->tx_progress =
+					LANTIQ_USIF_UART_TX_PROGRESS_INACTIVE;
+				uart_write_wakeup(port);
+			}
+			/* We still have data, no need to trigger another
+			   transaction */
+		}
+		stat->tx_intr_txfin++;
+		LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_TX_FIN, port);
+	}
+
+	if (status) {
+		/*
+		 * Do nothing, just clear all interrupt sources For some
+		 * reason we need to do this, though these interrupt
+		 * sources mask is disabled
+		 */
+		LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_STA_CLR_ALL, port);
+	}
+	/*
+	 * We need to handle other modem signals RI, DSR and DCD also, if the
+	 * chip supports it. Right now, USIF supports only CTS and RTS.
+	 */
+	/*
+	 * WAR, flush write, fix hardware timing issue. Make sure device clear
+	 * operation happens before ICU clear operation. Other ways to do are
+	 * mmiowb() and etc
+	 */
+	LANTIQ_USIF_GET_INT_STATUS(port);
+	return IRQ_HANDLED;
+}
+
+/**
+ * \fn static irqreturn_t lantiq_usif_uart_data_intr(int irq, void *dev_id)
+ *
+ * \brief  Interrupt handler routine for receive and transmit.
+ *
+ * \param  irq         interrupt irq number
+ * \param  dev_id      cast to USIF uart port
+ *
+ * \return IRQ_HANDLED  irq has been handled
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static irqreturn_t
+lantiq_usif_uart_data_intr(int irq, void *dev_id)
+{
+	u32 status;
+	struct uart_port *port = dev_id;
+
+	status = LANTIQ_USIF_GET_INT_STATUS(port) & LANTIQ_USIF_INT_DATA_ALL;
+#ifdef LANTIQ_USIF_UART_DEBUG
+	prom_printf("%s irq %d USIF_MIS 0x%08x\n", __func__, irq,
+		LANTIQ_USIF_GET_INT_STATUS(port));
+	prom_printf("%s irq %d USIF_RIS 0x%08x\n", __func__, irq,
+		LANTIQ_USIF_GET_RAW_INT_STATUS(port));
+	prom_printf("%s irq %d USIF_IMSC 0x%08x\n", __func__, irq,
+		LANTIQ_USIF_GET_INT_MASK(port));
+#endif
+	/* Handle the RX interrupts */
+	if (status & LANTIQ_USIF_INT_RECEIVE) {
+		/* Note that these interrupts are cleared in the service
+		   routine */
+		if (status & LANTIQ_USIF_INT_RX_BREQ)
+			lantiq_usif_uart_rx_breq(port);
+
+		if (status & LANTIQ_USIF_INT_RX_LBREQ)
+			lantiq_usif_uart_rx_lbreq(port);
+
+		if (status & LANTIQ_USIF_INT_RX_SREQ)
+			lantiq_usif_uart_rx_sreq(port);
+
+		if (status & LANTIQ_USIF_INT_RX_LSREQ)
+			lantiq_usif_uart_rx_lsreq(port);
+
+	}
+	/* Handle the Tx interrupt */
+	if (status & LANTIQ_USIF_INT_TRANSMIT) {
+		/* Note that these interrupts are cleared in the service
+		   routine */
+		lantiq_usif_uart_transmit_chars(port,
+			(status & LANTIQ_USIF_INT_TRANSMIT));
+	}
+	/*
+	 * WAR, flush write, fix hardware timing issue. Make sure device
+	 * clear operation happens before ICU clear operation. Other ways
+	 * to do are mmiowb() and etc
+	 */
+	LANTIQ_USIF_GET_INT_STATUS(port);
+	return IRQ_HANDLED;
+}
+
+/**
+ * \fn static unsigned int lantiq_usif_uart_tx_empty(struct uart_port *port)
+ *
+ * \brief  This function is used to check whether TX FIFO is empty or not
+ *
+ * \param  port     pointer to USIF uart port
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static unsigned int lantiq_usif_uart_tx_empty(struct uart_port *port)
+{
+	return (LANTIQ_USIF_GET_TX_FILL_FIFO(port) == 0) ? TIOCSER_TEMT : 0;
+}
+
+/**
+ * \fn static void lantiq_usif_uart_set_mctrl(struct uart_port *port,
+ *     unsigned int mctrl)
+ *
+ * \brief  This function is used to set the modem signals
+ *
+ * \param  port     pointer to USIF uart port
+ * \param  mctrl
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static void
+lantiq_usif_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	u32 m_set = 0x00;
+	u32 m_clr = 0x00;
+
+	if (mctrl & TIOCM_RTS)
+		m_set = LANTIQ_USIF_MSS_SET_FCO;
+	else
+		m_clr = LANTIQ_USIF_MSS_CLR_FCO;
+
+	if (mctrl & TIOCM_DTR)
+		m_set |= LANTIQ_USIF_MSS_SET_DTR;
+	else
+		m_clr |= LANTIQ_USIF_MSS_CLR_DTR;
+
+	if (m_set)
+		LANTIQ_USIF_SET_MODEM_STATUS(m_set, port);
+
+	if (m_clr)
+		LANTIQ_USIF_CLR_MODEM_STATUS(m_clr, port);
+}
+
+/**
+ * \fn static unsigned int lantiq_usif_uart_get_mctrl(struct uart_port *port)
+ *
+ * \brief  This function is used to get the modem signal status
+ *
+ * \param  port     pointer to USIF uart port
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static unsigned int lantiq_usif_uart_get_mctrl(struct uart_port *port)
+{
+	u32 status;
+	u32 ret = 0;
+
+	status = LANTIQ_USIF_GET_MODEM_STATUS(port);
+	if (status & LANTIQ_USIF_MSS_STAT_FCI)
+		ret = TIOCM_CTS;
+
+	if (status & LANTIQ_USIF_MSS_STAT_DCD)
+		ret |= TIOCM_CAR;
+
+	if (status & LANTIQ_USIF_MSS_STAT_RI)
+		ret |= TIOCM_RNG;
+
+	if (status & LANTIQ_USIF_MSS_STAT_DSR)
+		ret |= TIOCM_DSR;
+
+	/*
+	 * If the port does not support CTS, DCD (CAR) or DSR, the driver
+	 * should indicate that the signal is permanently active
+	 */
+	ret |= (TIOCM_DSR | TIOCM_CAR);
+	return ret;
+}
+
+/**
+ * \fn     static void lantiq_usif_uart_stop_rx(struct uart_port *port)
+ *
+ * \brief  This function is used to stop reception
+ *
+ * \param  port     pointer to USIF uart port
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static void lantiq_usif_uart_stop_rx(struct uart_port *port)
+{
+	LANTIQ_USIF_UART_IRQ_LOCK(port);
+	LANTIQ_USIF_CLR_INT_MASK(LANTIQ_USIF_INT_RECEIVE, port);
+	LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+}
+
+/**
+ * \fn     static void lantiq_usif_uart_enable_ms(struct uart_port *port)
+ *
+ * \brief  This function is used to enable the modem signal interrupts
+ *
+ * \param  port     pointer to USIF uart port
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static void lantiq_usif_uart_enable_ms(struct uart_port *port)
+{
+	/* Set the STA mask. We would like to process the CTS interrupt */
+	LANTIQ_USIF_UART_IRQ_LOCK(port);
+	LANTIQ_USIF_CLR_INT_MASK(LANTIQ_USIF_INT_FCI, port);
+	LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+}
+
+/**
+ * \fn static void lantiq_usif_uart_break_ctl(struct uart_port *port,
+ * int break_state)
+ *
+ * \brief  This function is used to send break signal
+ *
+ * \param  port        pointer to USIF uart port
+ * \param  break_state break state
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static void
+lantiq_usif_uart_break_ctl(struct uart_port *port, int break_state)
+{
+	/* The USIF module does not support this now */
+}
+
+/**
+ * \fn static INLINE void lantiq_usif_uart_clc_cfg_mode(struct uart_port *port)
+ * \brief enter configuration mode.
+ *
+ * \param   port    pointer to USIF uart port
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static INLINE void lantiq_usif_uart_clc_cfg_mode(struct uart_port *port)
+{
+	int i;
+#define LANTIQ_USIF_UART_CLC_CFG_TIMEOUT  10
+
+	/*
+	 * HW WAR, dummy read to make sure the previous read/write
+	 * to take effect before we go to config mode Please note,
+	 * must be a config register, instead of status register
+	 */
+#ifndef CONFIG_USE_EMULATOR
+	LANTIQ_USIF_GET_MODE_CONFIG(port);
+#endif /* CONFIG_USE_EMULATOR */
+	LANTIQ_USIF_CLC_CONFIG_MODE(port);
+	for (i = 0; i < LANTIQ_USIF_UART_CLC_CFG_TIMEOUT; i++) {
+		if ((LANTIQ_USIF_GET_CLOCK_STATUS(port) &
+			LANTIQ_USIF_CLC_STAT_CFG_UPDATE_DONE)
+			== LANTIQ_USIF_CLC_STAT_CFG_UPDATE_DONE) {
+			break;
+		}
+	}
+	if (i >= LANTIQ_USIF_UART_CLC_CFG_TIMEOUT)
+		printk(KERN_ERR "%s timeout\n", __func__);
+
+#undef LANTIQ_USIF_UART_CLC_CFG_TIMEOUT
+}
+
+/**
+ * \fn static INLINE void lantiq_usif_uart_clc_run_mode(struct uart_port *port)
+ * \brief enter running mode.
+ *
+ * \param   port    pointer to USIF uart port
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static INLINE void lantiq_usif_uart_clc_run_mode(struct uart_port *port)
+{
+	int i;
+#define LANTIQ_USIF_UART_CLC_RUN_TIMEOUT  10
+	/*
+	 * WAR, Dummy read to make sure the previous configuration
+	 * to take effec before we go to running mode.
+	 * Please note, must be a config register, instead of status
+	 * register
+	 */
+#ifndef CONFIG_USE_EMULATOR
+	LANTIQ_USIF_GET_MODE_CONFIG(port);
+#endif /* CONFIG_USE_EMULATOR */
+	LANTIQ_USIF_CLC_RUN_MODE(port);
+	for (i = 0; i < LANTIQ_USIF_UART_CLC_RUN_TIMEOUT; i++) {
+		if ((LANTIQ_USIF_GET_CLOCK_STATUS(port) &
+			LANTIQ_USIF_CLC_STAT_RUN_UPDATE_DONE)
+			== LANTIQ_USIF_CLC_STAT_RUN_UPDATE_DONE) {
+			break;
+		}
+	}
+	if (i >= LANTIQ_USIF_UART_CLC_RUN_TIMEOUT)
+		printk(KERN_ERR "%s timeout\n", __func__);
+
+#undef LANTIQ_USIF_UART_CLC_RUN_TIMEOUT
+}
+
+/**
+ * \fn     static int lantiq_usif_uart_startup(struct uart_port *port)
+ *
+ * \brief  This function is called while starting the serial port
+ *
+ *         Initialise all interrupts and assign priority to each of them.
+ *         But enable only the receive interupts
+ *
+ * \param  port        pointer to USIF uart port
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static int lantiq_usif_uart_startup(struct uart_port *port)
+{
+	int ret = 0;
+	u32 reg;
+	LANTIQ_USIF_UART_PORT_t *usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+	struct tty_struct *tty = UART_PORT_TO_TTY(port);
+	LANTIQ_USIF_UART_PROC_STAT_t *stat = &(usif_port_p->usif_proc_data);
+
+	LANTIQ_USIF_UART_PRINT(usif_port_p, USIF_UART_MSG_INIT,
+			"%s: port=%p (%08lx,%p)\n", __func__,
+			port->mapbase, port->membase);
+
+	LANTIQ_USIF_UART_IRQ_LOCK(port);
+	/* Configuration Mode */
+	lantiq_usif_uart_clc_cfg_mode(port);
+	/* Enable RX */
+	reg = LANTIQ_USIF_GET_MODE_CONFIG(port);
+	reg |= LANTIQ_USIF_MODE_CFG_RX_EN;
+	LANTIQ_USIF_SET_MODE_CONFIG(reg, port);
+
+	/* Enable TX flow control  */
+	reg = LANTIQ_USIF_GET_FIFO_CONFIG(port);
+	reg |= LANTIQ_USIF_FIFO_CFG_TXFC;
+	LANTIQ_USIF_SET_FIFO_CONFIG(reg, port);
+
+	/* Switch to USIF working mode */
+	lantiq_usif_uart_clc_run_mode(port);
+
+	/* XXX, Running time configuration */
+	lantiq_usif_uart_run_time_config(port);
+	LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+
+	ret = request_irq(usif_port_p->tx_irq, lantiq_usif_uart_data_intr,
+		IRQF_SHARED, "USIF_TX_REQ", port);
+	if (ret) {
+		printk(KERN_ERR "%s: can't get irq %d for Tx\n", __func__,
+			usif_port_p->tx_irq);
+		goto done;
+	}
+
+	ret = request_irq(usif_port_p->rx_irq, lantiq_usif_uart_data_intr,
+		IRQF_SHARED, "USIF_RX_REQ", port);
+	if (ret) {
+		printk(KERN_ERR "%s: can't get irq %d for Rx\n", __func__,
+			usif_port_p->rx_irq);
+		goto err1;
+	}
+
+	/* Request for handle for STA interrupts, which is used to detect
+	   CTS status change */
+	ret = request_irq(usif_port_p->status_irq, lantiq_usif_uart_status_intr,
+		IRQF_SHARED, "USIF_STAT", port);
+	if (ret) {
+		printk(KERN_ERR "%s: can't get irq %d for status\n",
+			__func__, usif_port_p->status_irq);
+		goto err2;
+	}
+
+	/*
+	 * Request for handle for ERR interrupts  We may continue
+	 * the normal operation, though unable to get handler here
+	 */
+	ret = request_irq(usif_port_p->err_irq,
+		lantiq_usif_uart_err_intr,
+		IRQF_SHARED, "USIF_ERR", port);
+	if (ret) {
+		printk(KERN_ERR "%s: can't get irq %d for error\n",
+			__func__, usif_port_p->err_irq);
+		goto err3;
+	}
+
+	/* XXX, autobaud and wakeup interrupt */
+
+	/* Reset the Rx and Tx local counters */
+	usif_port_p->tx_progress = LANTIQ_USIF_UART_TX_PROGRESS_INACTIVE;
+	usif_port_p->rx_rps_cnt = 0x00;
+
+	/*
+	 * Update the 'low latency' flag before enabling the receive interrupts.
+	 * Enable the low latency while pushing the received data into FLIP
+	 * buffer. It is required only for higher baudrate operation or large
+	 * data packets, where each data packet size is more than 512 bytes.
+	 * Enabling low latency could consume more CPU while servicing
+	 * receive interrupts. If the low latency flag is not enabled, then
+	 * there are chances of loosing received data from RX FIFO.
+	 * Note: It is advised to use hardware flowcontrol while using higher
+	 * baudrates and large data packets, as it is observed that, the data
+	 * has been dropped without this
+	 */
+	tty->port->low_latency = ((port->flags & ASYNC_LOW_LATENCY) ? 1 : 0);
+
+	stat->rx_low_latency = tty->port->low_latency;
+
+	LANTIQ_USIF_UART_IRQ_LOCK(port);
+	/* Enable only the receive interrupts, TX interrupt will be
+	   enabled later */
+	LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_CLR_ALL, port);
+	LANTIQ_USIF_SET_INT_MASK(LANTIQ_USIF_INT_RECEIVE, port);
+	LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+#ifdef LANTIQ_USIF_UART_DEBUG
+	lantiq_usif_uart_reg_dump(port);
+#endif
+	LANTIQ_USIF_UART_PRINT(usif_port_p, USIF_UART_MSG_INIT,
+		"%s succeed\n", __func__);
+	return 0;
+err3:
+	free_irq(usif_port_p->status_irq, port);
+err2:
+	free_irq(usif_port_p->rx_irq, port);
+err1:
+	free_irq(usif_port_p->tx_irq, port);
+done:
+	return ret;
+}
+
+/**
+ * \fn     static void lantiq_usif_uart_shutdown(struct uart_port *port)
+ *
+ * \brief  This function is called while closing the serial port
+ *
+ *         De-initialise all interrupts and assign prioroty to each of them.
+ *
+ * \param  port        pointer to USIF uart port
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static void lantiq_usif_uart_shutdown(struct uart_port *port)
+{
+	LANTIQ_USIF_UART_PORT_t *usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+
+	/* Switch to USIF configuration mode  */
+	lantiq_usif_uart_clc_cfg_mode(port);
+
+	/* Disable all interrupts, disable the port */
+	LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_CLR_ALL, port);
+	LANTIQ_USIF_SET_INT_MASK(0, port);
+
+	/* Free the interrupt */
+	free_irq(usif_port_p->tx_irq, port);
+	free_irq(usif_port_p->rx_irq, port);
+	free_irq(usif_port_p->status_irq, port);
+	free_irq(usif_port_p->err_irq, port);
+}
+
+#if 1
+static unsigned int lantiq_get_usif_hz(void)
+{
+	return (100000000);
+}
+#endif
+
+/**
+ * \fn static unsigned int lantiq_usif_uart_get_kernel_clk(struct uart_port *port)
+ * \brief Get USIF UART clock speed.
+ * Returns the current operating speed of the UART, depending on chip
+ * specific bus speed and RMC setting in CLC register.
+ *
+ * \param   port     Pointer to structure #struct uart_port
+ * \return  >0       Peripheral speed in HZ
+ * \return  0        Error
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static unsigned int lantiq_usif_uart_get_kernel_clk(struct uart_port *port)
+{
+	/* This function assumes that the CLC register is set with the
+	 * appropriate value for RMC.
+	 */
+	u32 rmc;
+
+	rmc = MS(LANTIQ_USIF_GET_CLOCK_COUNTER(port), LANTIQ_USIF_CLC_CNT_RMC);
+	if (rmc == 0) {
+		printk(KERN_ERR "%s rmc==0\n", __func__);
+		return 0;
+	}
+	return (unsigned int) (lantiq_get_usif_hz() / rmc);
+}
+
+/**
+ * \fn static unsigned int lantiq_usif_uart_clk_to_baudtbl_idx
+ * (struct uart_port * port)
+ * \brief convert usif kernel clock to baud table index
+ *
+ * \param   port     Pointer to structure #struct uart_port
+ * \return  int      baud table index 0~3
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static int lantiq_usif_uart_clk_to_baudtbl_idx(struct uart_port *port)
+{
+	int baud_tbl_idx;
+
+	unsigned int clk = lantiq_usif_uart_get_kernel_clk(port);
+
+	switch (clk) {
+	case 78583:
+		baud_tbl_idx = 0;
+		break;
+	case 1000000:
+		baud_tbl_idx = 1;
+		break;
+	case 100000000:
+		baud_tbl_idx = 2;
+		break;
+	case 20000000:
+		baud_tbl_idx = 3;
+		break;
+	default:
+		baud_tbl_idx = 2;
+		break;
+	}
+	return baud_tbl_idx;
+}
+
+/**
+ * \fn     static u32 lantiq_usif_uart_get_baud(struct uart_port *port)
+ *
+ * \brief  This function is used to obtain baudrate according to
+ *         fdiv and baud counter register configuration
+ *
+ * \param  port      pointer to usif uart port.
+ *
+ * \return None
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+#ifdef CONFIG_SERIAL_LANTIQ_USIF_UART_CONSOLE
+static u32 lantiq_usif_uart_get_baud(struct uart_port *port)
+{
+	u32 inc, dec;
+	u32 bcrv;
+	u32 fdiv;
+	u32 ibaud = LANTIQ_USIF_UART_DEFAULT_BAUDRATE;
+
+	fdiv = LANTIQ_USIF_GET_FRAC_DIV(port);
+
+	inc = MS(fdiv, LANTIQ_USIF_FDIV_CFG_INC);
+	dec = MS(fdiv, LANTIQ_USIF_FDIV_CFG_DEC);
+
+	bcrv = MS(LANTIQ_USIF_GET_BAUDRATE_COUNTER(port),
+		  LANTIQ_USIF_BC_CFG_BCRV);
+	bcrv += 1;
+
+	if (inc == 0 || dec == 0)
+		ibaud = (u32) ((port->uartclk >> 4) / bcrv);
+
+	if (inc != 0 && dec != 0) {
+		/* XXX, possible overflow */
+		ibaud = (u32) ((port->uartclk >> 4) * inc /
+			((inc + dec) * bcrv));
+	}
+	return ibaud;
+}
+#endif /* CONFIG_SERIAL_LANTIQ_USIF_UART_CONSOLE */
+
+/**
+ * \fn static LANTIQ_USIF_HW_BAUDRATE_IDX_t lantiq_usif_uart_baud_to_idx
+ *  (unsigned int baud)
+ *
+ * \brief  This function is used to convert baud rate to baud rate index
+ *
+ * \param  baud        baud rate to be converted
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static LANTIQ_USIF_HW_BAUDRATE_IDX_t
+lantiq_usif_uart_baud_to_idx(unsigned int baud)
+{
+	LANTIQ_USIF_HW_BAUDRATE_IDX_t baudrate = LANTIQ_USIF_HW_BPS_115200;
+
+	switch (baud) {
+	case 300:
+		baudrate = LANTIQ_USIF_HW_BPS_300;
+		break;
+	case 1200:
+		baudrate = LANTIQ_USIF_HW_BPS_1200;
+		break;
+	case 2400:
+		baudrate = LANTIQ_USIF_HW_BPS_2400;
+		break;
+	case 4800:
+		baudrate = LANTIQ_USIF_HW_BPS_4800;
+		break;
+	case 9600:
+		baudrate = LANTIQ_USIF_HW_BPS_9600;
+		break;
+	case 19200:
+		baudrate = LANTIQ_USIF_HW_BPS_19200;
+		break;
+	case 38400:
+		baudrate = LANTIQ_USIF_HW_BPS_38400;
+		break;
+	case 57600:
+		baudrate = LANTIQ_USIF_HW_BPS_57600;
+		break;
+	case 115200:
+		baudrate = LANTIQ_USIF_HW_BPS_115200;
+		break;
+	case 0:
+
+	default:
+		/* Set the default baudrate as 115200 */
+		break;
+	}
+	return baudrate;
+}
+
+/**
+ * \fn static void lantiq_usif_uart_baud_setup(struct uart_port *port, u32 baud)
+ *
+ * \brief  This function is used to set up uart baudrate
+ *
+ * \param  port        pointer to USIF uart port
+ * \param  baud        baud rate to be set up
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static void lantiq_usif_uart_baud_setup(struct uart_port *port, u32 baud)
+{
+	int baud_tbl_index;
+	u32 baud_bc_cfg;
+	u32 ictmo_cfg;
+	LANTIQ_USIF_HW_BAUDRATE_IDX_t baudrate;
+	LANTIQ_USIF_BAUDRATE_FDIV_t baud_fdiv;
+	LANTIQ_USIF_UART_PORT_t *usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+
+	if (usif_port_p->prev_baud == baud)
+		return;
+
+	usif_port_p->prev_baud = baud;
+
+	/* Set the default baud rate configuration, as 115200 */
+	baudrate = lantiq_usif_uart_baud_to_idx(baud);
+	baud_tbl_index = lantiq_usif_uart_clk_to_baudtbl_idx(port);
+
+	baud_fdiv.fdiv_cfg_bits.inc =
+		lantiq_usif_uart_baudrate_table[baud_tbl_index].fpi[baudrate].
+		inc;
+	baud_fdiv.fdiv_cfg_bits.dec =
+		lantiq_usif_uart_baudrate_table[baud_tbl_index].fpi[baudrate].
+		dec;
+	baud_fdiv.fdiv_cfg_bits.dummy = 0;
+	baud_bc_cfg =
+		lantiq_usif_uart_baudrate_table[baud_tbl_index].fpi[baudrate].
+		bc;
+	ictmo_cfg =
+		lantiq_usif_uart_baudrate_table[baud_tbl_index].fpi[baudrate].
+		tmo;
+
+	/* fdiv < inc, dec >, bc <bcriv> */
+	LANTIQ_USIF_FRAC_DIV_CONFIG(baud_fdiv.fdiv_cfg_word, port);
+
+	/* Update the baudrate counter configuration register for baudrate */
+	LANTIQ_USIF_BAUDRATE_COUNTER_CONFIG(baud_bc_cfg, port);
+
+	/*
+	 * Update the intercharacter timeout configuration register, for RX
+	 * Value not calculated/optinimed, just set some large value
+	 * Observed that, this value is small or not set, then RPS is not
+	 * updated
+	 */
+	LANTIQ_USIF_INTERCHARACTER_TIMEOUT_CONFIG(ictmo_cfg, port);
+}
+
+/**
+ * \fn static void lantiq_usif_uart_set_termios(struct uart_port *port,
+ *  struct ktermios *termios, struct ktermios *old)
+ *
+ * \brief  This function is used to update the serial hardware setup,
+ *         due to change in teminal I/O settings.
+ *
+ * Update all the USIF hardware setup depending on the terminal
+ * I/O setup
+ *
+ * \param  port        pointer to USIF uart port
+ * \param  termios     structure pointer to present terminal I/O settngs
+ * \param  old         structure pointer to old terminal I/O settngs
+ *
+ * \return  None
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+
+static void
+lantiq_usif_uart_set_termios(struct uart_port *port, struct ktermios *termios,
+		     struct ktermios *old)
+{
+	u32 old_int_mask;
+	u32 mode_cfg;
+	u32 prtc_cfg;
+	u32 baud;
+	LANTIQ_USIF_UART_PORT_t *usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+	LANTIQ_USIF_UART_PROC_STAT_t *stat = &(usif_port_p->usif_proc_data);
+
+	prtc_cfg = LANTIQ_USIF_GET_PROTOCOL_CONFIG(port);
+	prtc_cfg &= ~LANTIQ_USIF_PRTC_CFG_CLEN;
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		prtc_cfg |= LANTIQ_USIF_PRTC_CFG_CLEN5;
+		break;
+
+	case CS6:
+		prtc_cfg |= LANTIQ_USIF_PRTC_CFG_CLEN6;
+		break;
+
+	case CS7:
+		prtc_cfg |= LANTIQ_USIF_PRTC_CFG_CLEN7;
+		break;
+
+	case CS8:
+	default:
+		prtc_cfg |= LANTIQ_USIF_PRTC_CFG_CLEN8;
+		break;
+	}
+	if (termios->c_cflag & CSTOPB) {
+		/* Use two stop bits */
+		prtc_cfg |= LANTIQ_USIF_PRTC_CFG_STP2;
+	}
+
+	if (termios->c_cflag & PARENB) {
+		/* Enable parity, by default even parity */
+		prtc_cfg |= LANTIQ_USIF_PRTC_CFG_PAR;
+
+		/* Set odd parity */
+		if (termios->c_cflag & PARODD)
+			prtc_cfg |= LANTIQ_USIF_PRTC_CFG_ODD;
+	}
+
+	mode_cfg = LANTIQ_USIF_GET_MODE_CONFIG(port);
+
+	/* Ignore all received characters if CREAD is not set */
+	if ((termios->c_cflag & CREAD) == 0)
+		mode_cfg &= ~LANTIQ_USIF_MODE_CFG_RX_EN;
+	else
+		mode_cfg |= LANTIQ_USIF_MODE_CFG_RX_EN;
+
+	/*
+	 * This driver does support the hardware flowcontrol, which is in-turn
+	 * controlled by software, not by the internal hardware of USIF module
+	 */
+	if (termios->c_cflag & CRTSCTS) {
+		prtc_cfg |= (LANTIQ_USIF_PRTC_CFG_SFCI_EN |
+			 LANTIQ_USIF_PRTC_CFG_SFCO_EN);
+		prtc_cfg |= SM(8, LANTIQ_USIF_PRTC_CFG_FCO_TL);
+	}
+
+	/* Ask the core to calculate the divisor for us */
+	baud = uart_get_baud_rate(port, termios, old, 0,
+				LANTIQ_USIF_UART_MAX_BAUDRATE);
+
+	/* Wait till the FIFO becomes empty before
+	   we enter the configure mode */
+	while (LANTIQ_USIF_GET_TX_FILL_FIFO(port) != 0x00)
+		;
+
+	/* Sanity Check again */
+	if (((LANTIQ_USIF_GET_FIFO_STATUS(port) &
+		LANTIQ_USIF_FIFO_STAT_TXRX_FFS_MASK) != 0x00)) {
+		printk(KERN_ERR "%s busy\n", __func__);
+		return;
+	}
+
+	LANTIQ_USIF_UART_IRQ_LOCK(port);
+
+	/* Update the per-port timeout */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	/* Update the read_status_mask and ignore_status_mask */
+
+	/* RX overflow/overrun error */
+	port->read_status_mask = LANTIQ_USIF_INT_RXOF;
+
+	if (termios->c_iflag & INPCK) {
+		port->read_status_mask |=
+			LANTIQ_USIF_INT_FE | LANTIQ_USIF_INT_PE;
+	}
+
+	if (termios->c_iflag & (BRKINT | PARMRK)) {
+		/* USIF does not support the break interrupt error */
+		port->read_status_mask |= port->read_status_mask;
+	}
+
+	/* Characters to ignore */
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR) {
+		port->ignore_status_mask |=
+			LANTIQ_USIF_INT_FE | LANTIQ_USIF_INT_PE;
+	}
+
+	if (termios->c_iflag & IGNBRK) {
+		/*
+		 * If we're ignoring parity and break indicators,
+		 *   ignore overruns too (for real raw support)
+		 */
+		if (termios->c_iflag & IGNPAR)
+			port->ignore_status_mask |= LANTIQ_USIF_INT_RXOF;
+
+	}
+
+	old_int_mask = LANTIQ_USIF_GET_INT_MASK(port);
+	/* Switch to USIF configuration mode */
+	lantiq_usif_uart_clc_cfg_mode(port);
+
+	/* Disable all interrupts */
+	LANTIQ_USIF_SET_INT_MASK(0, port);
+
+	if (usif_port_p->prev_mode_cfg != mode_cfg) {
+		/* Update the mode configuration register with the settings */
+		LANTIQ_USIF_SET_MODE_CONFIG(mode_cfg, port);
+		usif_port_p->prev_mode_cfg = mode_cfg;
+	}
+
+	if (usif_port_p->prev_prtc_cfg != prtc_cfg) {
+		/* Update the protocol configuration register
+		   with the settings */
+		LANTIQ_USIF_SET_PROTOCOL_CONFIG(prtc_cfg, port);
+		usif_port_p->prev_prtc_cfg = prtc_cfg;
+	}
+
+	lantiq_usif_uart_baud_setup(port, baud);
+
+	/* Enable the CTS interrupt  */
+	if (termios->c_cflag & CRTSCTS) {
+		/* We care about only CTS interrupt, now  */
+		old_int_mask |= LANTIQ_USIF_INT_FCI;
+	} else {
+		/* Disable the CTS interrupt */
+		old_int_mask &= (~LANTIQ_USIF_INT_FCI);
+	}
+
+	/* We need to take care the transmission finished interrupt  */
+	old_int_mask |= LANTIQ_USIF_INT_TX_FIN;
+
+	/* Set the mask, to enable STA/ ERR interrupts */
+	old_int_mask |= LANTIQ_USIF_INT_ERR_MASK | LANTIQ_USIF_INT_STA_ALL;
+
+	/* XXX, in release, TMO interrupt doesn't need */
+	old_int_mask &= ~LANTIQ_USIF_INT_TMO;
+
+	/* Switch to USIF working mode */
+	lantiq_usif_uart_clc_run_mode(port);
+
+	lantiq_usif_uart_run_time_config(port);
+
+	/* Set the mask for interrupts */
+	LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_CLR_ALL, port);
+	LANTIQ_USIF_SET_INT_MASK(old_int_mask, port);
+	LANTIQ_USIF_UART_IRQ_UNLOCK(port);
+
+	/* To make baudrate configuration take effect, we need
+	*  some certain delay */
+	udelay(10);
+
+	stat->tx_bytes = port->icount.tx;
+	stat->rx_bytes = port->icount.rx;
+
+}
+
+/**
+ * \fn     static const char* lantiq_usif_uart_type(struct uart_port *port)
+ *
+ * \brief  This function is used to get the pointer to a string
+ *         constant describing the port
+ *
+ * \param  port        pointer to USIF uart port
+ *
+ * \return  "USIF_UART"
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static const char *lantiq_usif_uart_type(struct uart_port *port)
+{
+	return (port->type == IFX_PORT_USIF_UART) ? "USIF_UART" : NULL;
+}
+
+/**
+ *
+ * \fn    static void lantiq_usif_uart_release_port(struct uart_port *port)
+ *
+ * \brief This function is used to release the memory used by the port
+ *
+ * \param  port - pointer to USIF uart port.
+ *
+ * \return NONE
+ *
+ * NOTES: Releases the virtual memory allocated to USIF using
+ *        'lantiq_usif_uart_request_port' function.
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static void lantiq_usif_uart_release_port(struct uart_port *port)
+{
+	iounmap(port->membase);
+}
+
+/**
+ * \fn     static int lantiq_usif_uart_request_port(struct uart_port *port)
+ *
+ * \brief  This function is used to allocate the memory for the port
+ *
+ *   Allocates virtual memory to USIF using the physical address pointed
+ *   'mapbase' using the 'ioremap_nocache' utility
+ *
+ * \param  port        pointer to USIF uart port
+ *
+ * \return 0           successfully
+ *         -EBUSY
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static int lantiq_usif_uart_request_port(struct uart_port *port)
+{
+	LANTIQ_USIF_UART_PORT_t *usif_port_p;
+
+	usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+	port->membase = ioremap_nocache(port->mapbase, LANTIQ_USIF_SIZE);
+	if (!port->membase) {
+		/* If USIF is used as console and failed here,
+		   restore the hardcoded virtual address  */
+#ifdef CONFIG_SERIAL_LANTIQ_USIF_UART_CONSOLE
+		port->membase = (char *) (LANTIQ_USIF_VIRT_BASE);
+#endif
+		printk(KERN_ERR "%s: Failed during io remap\n", __func__);
+		return -EBUSY;
+	}
+	/* XXX, enter running mode? */
+	LANTIQ_USIF_UART_PRINT(usif_port_p, USIF_UART_MSG_INIT,
+		"%s: io remap 0x%x\n", __func__,
+		(unsigned int) port->membase);
+	return 0;
+}
+
+/**
+ * \fn static void lantiq_usif_uart_config_port(struct uart_port *port, int flags)
+ *
+ * \brief This function is used to perform any autoconfiguration steps
+ *   required for the port.
+ *
+ *  Just calls 'lantiq_usif_uart_request_port' function, if the port type is
+ *  'UART_CONFIG_TYPE'
+ *
+ * \param  port        pointer to USIF uart port
+ * \param  flags       Indicate type of port
+ *
+ * \return None
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static void lantiq_usif_uart_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE) {
+		if (!lantiq_usif_uart_request_port(port))
+			port->type = IFX_PORT_USIF_UART;
+	}
+}
+
+/**
+ * \fn static int lantiq_usif_uart_verify_port(struct uart_port *port,
+ *  struct serial_struct *ser)
+ *
+ * \brief  This function is used to verify the new serial port information
+ *        contained within serial information is suitable for this port type
+ *
+ * \param  port      pointer to USIF uart port
+ * \param  ser       serial_struct, details about the port
+ *
+ * \return None
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static int
+lantiq_usif_uart_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	int ret = 0;
+
+	if ((ser->type != PORT_UNKNOWN)
+		&& (ser->type != IFX_PORT_USIF_UART)) {
+		ret = -EINVAL;
+	}
+
+	if ((ser->irq < 0) || (ser->irq >= NR_IRQS))
+		ret = -EINVAL;
+
+	if ((ser->baud_base) < (LANTIQ_USIF_BAUD_MIN))
+		ret = -EINVAL;
+
+	return ret;
+}
+
+/*
+ * This structure has the callback functions used by the higher layers of
+ * TTY driver. Initialise it with appropriate functions implmented.
+ */
+static struct uart_ops lantiq_usif_uart_ops = {
+	.tx_empty = lantiq_usif_uart_tx_empty,
+	.set_mctrl = lantiq_usif_uart_set_mctrl,
+	.get_mctrl = lantiq_usif_uart_get_mctrl,
+	.stop_tx = lantiq_usif_uart_stop_tx,
+	.start_tx = lantiq_usif_uart_start_tx,
+	.stop_rx = lantiq_usif_uart_stop_rx,
+	.enable_ms = lantiq_usif_uart_enable_ms,
+	.break_ctl = lantiq_usif_uart_break_ctl,
+	.startup = lantiq_usif_uart_startup,
+	.shutdown = lantiq_usif_uart_shutdown,
+	.set_termios = lantiq_usif_uart_set_termios,
+	.type = lantiq_usif_uart_type,
+	.release_port = lantiq_usif_uart_release_port,
+	.request_port = lantiq_usif_uart_request_port,
+	.config_port = lantiq_usif_uart_config_port,
+	.verify_port = lantiq_usif_uart_verify_port,
+};
+
+/*
+ * This structure is the main enrty point to this driver.Initialise it with the
+ *   basic information about the device.
+ *   Note:
+ *   1. The 'membase' is initialized later, with the ACTUAL virtual address
+ *       using 'ioremap_nocache' utility.
+ *   2. The console setup uses the hardcoded virtual address, to print the
+ *       console messages during startup, but once this driver is up, it uses
+ *       the virtual address generated by 'ioremap_nocache' utility.
+ */
+static LANTIQ_USIF_UART_PORT_t lantiq_usif_uart_ports[LANTIQ_USIF_UART_NR] = {
+	{
+	 .port = {
+		  .iobase = (unsigned int) LANTIQ_USIF_VIRT_BASE,
+		  .membase = (unsigned char __iomem *) (LANTIQ_USIF_VIRT_BASE),
+		  .mapbase = LANTIQ_USIF_PHY_BASE,
+		  .iotype = SERIAL_IO_MEM,
+		  .irq = LANTIQ_USIF_RX_INT,
+		  .uartclk = 0,
+		  .fifosize = LANTIQ_USIF_UART_TX_FIFO_LENGTH,
+		  .type = IFX_PORT_USIF_UART,
+		  .ops = &lantiq_usif_uart_ops,
+#ifdef CONFIG_USIF_UART_LOW_LATENCY
+		  .flags = (ASYNC_BOOT_AUTOCONF | ASYNC_LOW_LATENCY),
+#else
+		  .flags = ASYNC_BOOT_AUTOCONF,
+#endif
+		  .line = 0, /* Port index in one uart driver */
+		  },
+	 .tx_progress = LANTIQ_USIF_UART_TX_PROGRESS_INACTIVE,
+	 .rx_rps_cnt = 0,
+	 .tx_irq = LANTIQ_USIF_TX_INT,
+	 .rx_irq = LANTIQ_USIF_RX_INT,
+	 .wakeup_irq = LANTIQ_USIF_WKP_INT,
+	 .autobaud_irq = LANTIQ_USIF_AB_INT,
+	 .status_irq = LANTIQ_USIF_STA_INT,
+	 .err_irq = LANTIQ_USIF_EIR_INT,
+	 .debug = USIF_UART_MSG_ANY,
+	 }
+};
+
+/**
+ * \fn static inline void lantiq_usif_uart_pm_enable(void)
+ * \brief Clock gating on USIF module
+ *
+ * \return none
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static inline void lantiq_usif_uart_pm_enable(void)
+{
+	struct clk *clk, *ahb_clk;
+	
+	/* Activate USIF SPI */
+	clk = clk_get_sys("1da00000.usif", "NULL");
+	if (IS_ERR(clk)) {
+	        printk(KERN_ERR "USIF: failed to get clock\n");
+			        return;
+	}
+	clk_enable(clk);
+	
+	ahb_clk = clk_get_sys(NULL, "ahb");
+	if (IS_ERR(ahb_clk)) {
+	        printk(KERN_ERR "USIF: failed to get AHBS clock\n");
+			        return;
+	}
+	clk_enable(ahb_clk);
+}
+
+/**
+ * \fn static inline void lantiq_usif_uart_pm_disable(void)
+ * \brief Clock gating off USIF module
+ *
+ * \return none
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static inline void lantiq_usif_uart_pm_disable(void)
+{
+	struct clk *clk, *ahb_clk;
+	
+	/* Activate USIF SPI */
+	clk = clk_get_sys("1da00000.usif", "usif");
+	if (IS_ERR(clk)) {
+	        printk(KERN_ERR "USIF: failed to get clock\n");
+			        return;
+	}
+	clk_disable(clk);
+
+	ahb_clk = clk_get_sys(NULL, "ahb");
+	if (IS_ERR(ahb_clk)) {
+	        printk(KERN_ERR "USIF: failed to get AHBS clock\n");
+			        return;
+	}
+	clk_enable(ahb_clk);
+}
+
+/**
+ * \fn     static int lantiq_usif_uart_hw_init(void)
+ *
+ * \brief  This function is used to initialize USIF hardware configuration
+ *
+ * \return 0       OK
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static int lantiq_usif_uart_hw_init(void)
+{
+	u32 reg = 0;
+	struct uart_port *port;
+	LANTIQ_USIF_UART_PORT_t *usif_port_p;
+
+	port = &lantiq_usif_uart_ports[0].port;
+
+	usif_port_p = (LANTIQ_USIF_UART_PORT_t *) port;
+
+	/* Enable USIF/AHBS */
+	lantiq_usif_uart_pm_enable();
+
+	/* RMC first for AHB clock dmain  */
+	LANTIQ_USIF_SET_CLOCK_COUNTER(
+		(SM(LANTIQ_USIF_UART_DEFAULT_RMC, LANTIQ_USIF_CLC_CNT_RMC) |
+		SM(LANTIQ_USIF_UART_DEFAULT_ORMC, LANTIQ_USIF_CLC_CNT_ORMC)), port);
+
+	/* Switch to USIF configuration mode */
+	reg = LANTIQ_USIF_CLC_MOD_EN;
+	LANTIQ_USIF_SET_RUN_CONTROL(reg, port);
+	lantiq_usif_uart_clc_cfg_mode(port);
+
+	/* Disable all interrupts */
+	LANTIQ_USIF_SET_INT_MASK(0, port);
+	LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_ALL, port);
+
+	/* Mode configuration, Master, async, Enable Tx only
+	 * NB, console only needs TX, serial driver startup will
+	 * Enable RX.
+	 */
+	reg = LANTIQ_USIF_MODE_CFG_TX_EN | LANTIQ_USIF_MODE_CFG_MA;
+	LANTIQ_USIF_SET_MODE_CONFIG(reg, port);
+
+	/* One byte per character, LSB first, even parity */
+	reg = LANTIQ_USIF_PRTC_CFG_CLEN8
+		/* | LANTIQ_USIF_PRTC_CFG_ERR_FE | LANTIQ_USIF_PRTC_CFG_PAR */ ;
+	LANTIQ_USIF_SET_PROTOCOL_CONFIG(reg, port);
+
+	/* Baudrate Setup */
+	lantiq_usif_uart_baud_setup(port, LANTIQ_USIF_UART_DEFAULT_BAUDRATE);
+
+	/* Configure the TX/RX FIFO */
+	reg = LANTIQ_USIF_UART_FIFO_SETUP;
+	/* Enable TX swap and RX swap  */
+	reg |= LANTIQ_USIF_FIFO_CFG_TX_SWAP | LANTIQ_USIF_FIFO_CFG_RX_SWAP;
+	LANTIQ_USIF_SET_FIFO_CONFIG(reg, port);
+
+	/* IMP, must be set after FIFO_CFG during configuraiton phase */
+	LANTIQ_USIF_SET_FIFO_CTRL(LANTIQ_USIF_FIFO_CTRL_RX_AR_ON, port);
+
+	/* Switch to USIF working mode */
+	lantiq_usif_uart_clc_run_mode(port);
+
+	lantiq_usif_uart_run_time_config(port);
+
+	port->uartclk = lantiq_usif_uart_get_kernel_clk(port);
+	LANTIQ_USIF_UART_PRINT(usif_port_p, USIF_UART_MSG_INIT,
+		"%s: uart kernel clock %d\n", __func__, port->uartclk);
+	lantiq_usif_uart_hw_initialized = 1;
+#ifdef LANTIQ_USIF_UART_DEBUG
+	lantiq_usif_uart_reg_dump(port);
+#endif /* LANTIQ_USIF_UART_DEBUG */
+	return 0;
+}
+
+#ifdef CONFIG_SERIAL_LANTIQ_USIF_UART_CONSOLE
+
+/**
+ * \fn static void lantiq_usif_uart_outb(struct uart_port *port, const char c)
+ *
+ * \brief  This function is used to write one character
+ *
+ * \param  port    pointer to usif console port.
+ * \param  c       character to be written
+ *
+ * \return None
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static void lantiq_usif_uart_outb(struct uart_port *port, const char c)
+{
+	LANTIQ_USIF_TXD_t txd_data;
+
+	/* Wait till the FIFO becomes empty */
+	while (LANTIQ_USIF_GET_TX_FILL_FIFO(port) != 0x00)
+		;
+
+	txd_data.txd_byte.byte[0] = c;
+	LANTIQ_USIF_PUT_TX_LAST_WORD(LANTIQ_USIF_TXD_BE1, txd_data.txd_word, port);
+
+	/* Wait till the FIFO becomes empty */
+	while ((LANTIQ_USIF_GET_TX_FILL_FIFO(port)) != 0x00)
+		;
+}
+
+/**
+ * \fn static void lantiq_usif_uart_console_write(struct console *co,
+ *  const char *s, unsigned int count)
+ *
+ *
+ * \brief  This function is used to write the initial debug prints
+ *  to the console
+ *
+ * \param  co      pointer to usif console port.
+ * \param  s       String to be written
+ * \param  count   Number of characters to be written
+ *
+ * \return None
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static void
+lantiq_usif_uart_console_write(struct console *co, const char *s,
+		       unsigned int count)
+{
+	u32 i;
+	struct uart_port *port;
+
+	/* is this a valid port */
+	if ((co->index == -1) || co->index >= LANTIQ_USIF_UART_NR)
+		co->index = 0;
+
+	port = &lantiq_usif_uart_ports[co->index].port;
+
+	/*
+	 * Send each character, until we finish sending all charcaters.
+	 * At this stage, no interrupts are used, we depend only on the
+	 * filled FIFO stages. So, if the FIFO is filled, wait till we get
+	 * little room to write data into the FIFO
+	 */
+	for (i = 0; i < count; i++) {
+		/*
+		 * If a newline character is detected, then we need to
+		 * send the carriage return character also, followed by
+		 * the newline character
+		 */
+		if (s[i] == '\n')
+			lantiq_usif_uart_outb(port, '\r');
+		lantiq_usif_uart_outb(port, s[i]);
+	}
+}
+
+/**
+ * \fn  static void __init lantiq_usif_console_get_options(struct uart_port *port,
+ *  int *baud, int *parity, int *bits, int* flow)
+ *
+ * \brief  This function is used to set initial console setup
+ *
+ * \param  port    pointer to usif console port.
+ * \param  baud    Baudrate
+ * \param  parity  Parity setup
+ * \param  bits    Number of bits
+ * \param  flow    Flowcontrol
+ *
+ * \return None
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static void __init
+lantiq_usif_console_get_options(struct uart_port *port, int *baud,
+			int *parity, int *bits, int *flow)
+{
+	u32 clen;
+	u32 prtc_cfg;
+	u32 ibaud = LANTIQ_USIF_UART_DEFAULT_BAUDRATE;
+
+	prtc_cfg = LANTIQ_USIF_GET_PROTOCOL_CONFIG(port);
+
+	*parity = 'n';
+	if (prtc_cfg & LANTIQ_USIF_PRTC_CFG_PAR) {
+		if (prtc_cfg & LANTIQ_USIF_PRTC_CFG_ODD)
+			*parity = 'o';
+		else
+			*parity = 'e';
+	}
+
+	/* By default, the flow control is disabled */
+	*flow = 'n';
+
+	/* By default, the character length is 8 */
+	clen = MS(prtc_cfg, LANTIQ_USIF_PRTC_CFG_CLEN);
+	if ((clen == LANTIQ_USIF_PRTC_CFG_CLEN7)
+		|| (clen == LANTIQ_USIF_PRTC_CFG_CLEN8)) {
+		*bits = clen;
+	} else {
+		*bits = 0x08;
+		printk(KERN_ERR "%s: invalid character length %d",
+			__func__, clen);
+	}
+
+	ibaud = lantiq_usif_uart_get_baud(port);
+	/*
+	 * This doesn't work exactly because we use integer
+	 * math to calculate baud which results in rounding
+	 * errors. Try to make this work for both the fractional
+	 * divider and baud counter reload register. Also try to
+	 * avoid rounding errors using integer math.
+	 */
+	if (ibaud > 1100 && ibaud < 2300)
+		ibaud = 1200;
+	if (ibaud > 2300 && ibaud < 4600)
+		ibaud = 2400;
+	if (ibaud > 4600 && ibaud < 9300)
+		ibaud = 4800;
+	if (ibaud > 9300 && ibaud < 18600)
+		ibaud = 9600;
+	if (ibaud > 18600 && ibaud < 37200)
+		ibaud = 19200;
+	if (ibaud > 37200 && ibaud < 55800)
+		ibaud = 38400;
+	if (ibaud > 55800 && ibaud < 111700)
+		ibaud = 57600;
+	if (ibaud > 111700 && ibaud < 223400)
+		ibaud = 115200;
+	*baud = ibaud;
+}
+
+/**
+ * \fn static int __init lantiq_usif_uart_console_setup(struct console *co,
+ *  char *options)
+ *
+ * \brief  This function is used to set default console setup
+ *
+ * \param  co         pointer to usif console port.
+ * \param  options    Setup options
+ *
+ * \return 0          OK
+ *
+ * \ingroup LANTIQ_USIF_UART_FUNCTIONS
+ */
+static int __init
+lantiq_usif_uart_console_setup(struct console *co, char *options)
+{
+	u32 reg;
+	struct uart_port *port;
+	int baud = LANTIQ_USIF_UART_DEFAULT_BAUDRATE;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/* is this a valid port */
+	if ((co->index == -1) || co->index >= LANTIQ_USIF_UART_NR)
+		co->index = 0;
+
+	port = &lantiq_usif_uart_ports[co->index].port;
+
+	lantiq_usif_uart_clc_cfg_mode(port);
+
+	/* Need not set the USIF baudrate registers, as by default
+	   it is set to 115200 */
+
+	/*
+	 * Also, need not set the mode and protocol configuration
+	 * registers, as by default, it is set to asynchrounous mode
+	 * and 8 bit character length
+	 */
+
+	/*
+	 * Configure TX FIFO, but note that, we will not get any USIF
+	 * interrupts at startup TX FIFO, non flowcontrol mode, byte
+	 * aligned, burst size 4 words
+	 */
+	/* Non flow control */
+	reg = LANTIQ_USIF_GET_FIFO_CONFIG(port);
+	reg &= ~LANTIQ_USIF_FIFO_CFG_TXFC;
+
+	LANTIQ_USIF_SET_FIFO_CONFIG(reg, port);
+
+	/* Switch to USIF working mode */
+	lantiq_usif_uart_clc_run_mode(port);
+
+	/* XXX, Running time configuration */
+	if (options) {
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	} else {
+		lantiq_usif_console_get_options(port, &baud, &parity, &bits,
+			&flow);
+	}
+
+	uart_set_options(port, co, baud, parity, bits, flow);
+	return 0;
+}
+
+static struct uart_driver lantiq_usif_uart_serial_drv;
+
+static struct console lantiq_usif_uart_console = {
+	.name = LANTIQ_USIF_UART_DEV_NAME,
+	.write = lantiq_usif_uart_console_write,
+	.read = NULL,
+	.device = uart_console_device,
+	.setup = lantiq_usif_uart_console_setup,
+	.flags = CON_PRINTBUFFER,
+	.index = -1,
+	.data = &lantiq_usif_uart_serial_drv,
+};
+
+/**
+ * \fn  static int __init usif_uart_console_init (void)
+ *
+ * \brief  This is module initialization function for USIF as console
+ *
+ * \return 0   OK
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static int __init usif_uart_console_init(void)
+{
+	if (lantiq_usif_uart_hw_initialized == 0)
+		lantiq_usif_uart_hw_init();
+
+	register_console(&lantiq_usif_uart_console);
+	return 0;
+}
+
+console_initcall(usif_uart_console_init);
+
+#endif /* CONFIG_SERIAL_LANTIQ_USIF_UART_CONSOLE */
+
+#ifdef CONFIG_SERIAL_LANTIQ_USIF_UART_CONSOLE
+#define USIF_UART_CONSOLE   (&lantiq_usif_uart_console)
+#else
+#define USIF_UART_CONSOLE   NULL
+#endif /* CONFIG_SERIAL_LANTIQ_USIF_UART_CONSOLE */
+
+/**
+ * This structure gives the information about the TTY device driver, which is
+ * used while registering this driver.
+ * Initialise it with the device name, major number, minor number etc.
+ */
+static struct uart_driver lantiq_usif_uart_serial_drv = {
+	.owner = THIS_MODULE,
+	.driver_name = LANTIQ_USIF_UART_DEV_NAME,
+	.dev_name = LANTIQ_USIF_UART_DEV_NAME,
+	.major = LANTIQ_USIF_UART_MAJOR,
+	.minor = LANTIQ_USIF_UART_MINOR, /* Starting minor number */
+	.nr = LANTIQ_USIF_UART_NR, /* Max number of port */
+	.cons = USIF_UART_CONSOLE,
+	.state = NULL,
+	.tty_driver = NULL,
+};
+
+static inline int lantiq_drv_ver(char *buf, char *module, int major, int mid, int minor)
+{
+    return sprintf(buf, "Lantiq %s driver, version %d.%d.%d, (c) 2001-2013 Lantiq Deutschland GmbH\n",
+	        module, major, mid, minor);
+}
+
+/**
+ * \fn static inline int lantiq_usif_uart_drv_ver(char *buf)
+ * \brief Display USIF/UART driver version after initilazation succeeds
+ *
+ * \return number of bytes will be printed
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static inline int lantiq_usif_uart_drv_ver(char *buf)
+{
+	return lantiq_drv_ver(buf, "USIF-UART", LANTIQ_USIF_UART_VER_MAJOR,
+		LANTIQ_USIF_UART_VER_MID, LANTIQ_USIF_UART_VER_MINOR);
+}
+
+/**
+ * \fn     static int __init lantiq_usif_uart_init (void)
+ *
+ * \brief  This is module initialisation function for USIF UART
+ *
+ * \return -ENOMEM  Failed to register uart driver
+ * \return -EINVAL  Failed to add uart port
+ * \return 0        OK
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static int __init lantiq_usif_uart_init(void)
+{
+	int ret = 0;
+	char ver_str[128] = { 0 };
+	struct uart_port *port;
+
+	port = &lantiq_usif_uart_ports[0].port;
+
+	LANTIQ_USIF_UART_IRQ_LOCK_INIT(port, "USIF-UART");
+
+	if (lantiq_usif_uart_hw_initialized == 0)
+		lantiq_usif_uart_hw_init();
+
+	/*
+	 * Register the USIF module as UART device with TTY driver
+	 * We need to register this, only if the serial driver is
+	 * not registered already
+	 */
+	ret = uart_register_driver(&lantiq_usif_uart_serial_drv);
+	if (ret) {
+		printk(KERN_ERR "%s: uart_register_driver failed\n",
+			__func__);
+		goto err1;
+	}
+	/* Add the USIF hardware with the TTY driver. */
+	ret = uart_add_one_port(&lantiq_usif_uart_serial_drv, port);
+	if (ret) {
+		printk(KERN_ERR "%s: uart_add_one_port failed\n",
+			__func__);
+		goto err2;
+	}
+
+	lantiq_usif_uart_drv_ver(ver_str);
+	printk(KERN_INFO "%s", ver_str);
+	return 0;
+err2:
+	uart_unregister_driver(&lantiq_usif_uart_serial_drv);
+err1:
+	return ret;
+}
+
+module_init(lantiq_usif_uart_init);
+
+/**
+ * \fn     static void __exit lantiq_usif_uart_exit(void)
+ *
+ * \brief  This is module exit function for USIF UART
+ *
+ * \return None
+ *
+ * \ingroup LANTIQ_USIF_UART_INTERNAL
+ */
+static void __exit lantiq_usif_uart_exit(void)
+{
+	struct uart_port *port = &lantiq_usif_uart_ports[0].port;
+
+	LANTIQ_USIF_UART_IRQ_LOCK_DESTROY();
+
+	/* Exit running mode */
+	lantiq_usif_uart_clc_cfg_mode(port);
+
+	uart_remove_one_port(&lantiq_usif_uart_serial_drv, port);
+	uart_unregister_driver(&lantiq_usif_uart_serial_drv);
+
+	lantiq_usif_uart_pm_disable();
+}
+
+module_exit(lantiq_usif_uart_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Lei Chuanhua, Chuanhua.Lei@lantiq.com");
+MODULE_DESCRIPTION("Low level serial driver for USIF UART mode");
+
diff --git a/drivers/tty/serial/lantiq_usif_uart.h b/drivers/tty/serial/lantiq_usif_uart.h
new file mode 100644
--- /dev/null
+++ b/drivers/tty/serial/lantiq_usif_uart.h
@@ -0,0 +1,300 @@
+/******************************************************************************
+**
+** FILE NAME    : ltqmips_usif_uart.h
+** PROJECT      : IFX UEIP
+** MODULES      : Serial driver for USIF
+**
+** DATE         : 06 Aug, 2008
+** AUTHOR       : Lei Chuanhua
+** DESCRIPTION  : USIF module for uart driver
+** COPYRIGHT    :       Copyright (c) 2008 ~ 2009
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+** HISTORY
+** $Date         $Author         $Comment
+** 06 Aug, 2008  Lei Chuanhua    Initial version
+** 26 Jun, 2009  Lei Chuanhua    Code Review modification
+*******************************************************************************/
+
+#ifndef LTQMIPS_USIF_UART_H
+#define LTQMIPS_USIF_UART_H
+
+#include "lantiq_usif_reg.h"
+#include <lantiq_soc.h>
+
+/*!
+ \file ltqmips_usif_uart.h
+ \ingroup LANTIQ_USIF_UART
+ \brief header file for ifx usif uart driver internal definition
+*/
+/*!
+ \addtogroup LANTIQ_USIF_UART_DEFINITIONS
+*/
+/* @{ */
+#if defined(CONFIG_SERIAL_LANTIQ)
+
+/*! \def LANTIQ_USIF_UART_MINOR
+    \brief define the USIF UART minor number
+
+    2nd device, can't use ttyS0/1. Use ttyUSIF instead
+    Major number is the same, USIF minor device number
+    minor 64/65 has been used by ASC
+ */
+#define LANTIQ_USIF_UART_MINOR       66
+/*! \def LANTIQ_USIF_UART_DEV_NAME
+    \brief define the USIF UART device name in /dev/
+
+    2nd device, can't use ttyS0/1. Use ttyUSIF instead
+ */
+#define LANTIQ_USIF_UART_DEV_NAME    "ttyUSIF"
+#else
+/* 1st device, ttyS0, as UART ports are wholy used by USIF */
+#define LANTIQ_USIF_UART_MINOR       64
+#define LANTIQ_USIF_UART_DEV_NAME    "ttyS"
+#endif /* CONFIG_SERIAL_IFX_ASC */
+
+/*! \def LANTIQ_USIF_UART_MAJOR
+    \brief USIF major device number
+ */
+#define LANTIQ_USIF_UART_MAJOR      4
+
+/*! \def LANTIQ_USIF_UART_NR
+    \brief Number of USIF devices in USIF-UART
+ */
+#define LANTIQ_USIF_UART_NR              1
+
+/*! \def LANTIQ_USIF_UART_DEFAULT_RMC
+    \brief Default RMC
+ */
+#define LANTIQ_USIF_UART_DEFAULT_RMC     1
+
+/*! \def LANTIQ_USIF_UART_DEFAULT_ORMC
+    \brief Default ORMC
+ */
+#define LANTIQ_USIF_UART_DEFAULT_ORMC    1
+
+/*! \def LANTIQ_USIF_UART_TX_FIFO_LENGTH
+    \brief  TX FIFO size, update accordingly if changed 32 bytes, 8DWs
+ */
+#define LANTIQ_USIF_UART_TX_FIFO_LENGTH       0x20
+
+/*! \def LANTIQ_USIF_UART_TX_BUSRT_SIZE
+    \brief  TX FIFO burst size is set to 4 words, update accordingly
+    when 'LANTIQ_USIF_UART_TXFIFO_SETUP' changed
+*/
+#define LANTIQ_USIF_UART_TX_BUSRT_SIZE        0x04
+
+/*! \def LANTIQ_USIF_UART_TX_FIFO_CHARS_PER_WORD
+    \brief TX FIFO is byte aligned, so one word contains 4 characters
+     update accordingly when 'LANTIQ_USIF_UART_TXFIFO_SETUP' changed
+*/
+#define LANTIQ_USIF_UART_TX_FIFO_CHARS_PER_WORD   0x04
+
+/*! \def LANTIQ_USIF_UART_RX_BUSRT_SIZE
+    \brief RX FIFO burst size is set to 4 words, update accordingly
+     when 'LANTIQ_USIF_UART_RXFIFO_SETUP' changed
+*/
+#define LANTIQ_USIF_UART_RX_BUSRT_SIZE           0x04
+
+/*! \def LANTIQ_USIF_UART_RX_FIFO_CHARS_PER_WORD
+    \brief  RX FIFO is byte aligned, so one word contains 4 characters,
+     update accordingly when 'LANTIQ_USIF_UART_RXFIFO_SETUP' changed
+*/
+#define LANTIQ_USIF_UART_RX_FIFO_CHARS_PER_WORD   0x04
+
+
+/* The following is used while checking the error for received characters */
+#define LANTIQ_USIF_UART_RX_GOOD_CHAR              0x00
+#define LANTIQ_USIF_UART_RX_IGNORE_CHAR            0x01
+
+/* Macro defintation used while transmit in progress */
+#define LANTIQ_USIF_UART_TX_PROGRESS_ACTIVE        0x01
+#define LANTIQ_USIF_UART_TX_PROGRESS_INACTIVE      0x00
+
+/*! \def LANTIQ_USIF_UART_TXFIFO_SETUP
+    \brief  TX FIFO is setup as flow control mode, with byte alignemnet and
+     busrt size as 4 (half of the FIFO size) words
+*/
+#define LANTIQ_USIF_UART_TXFIFO_SETUP           \
+	(LANTIQ_USIF_FIFO_CFG_TXFC | SM(LANTIQ_USIF_TXFIFO_ALIGN_BYTE,\
+	LANTIQ_USIF_FIFO_CFG_TXFA) | SM(LANTIQ_USIF_TXFIFO_BURST_WORD4,\
+	LANTIQ_USIF_FIFO_CFG_TXBS))
+
+/*! \def LANTIQ_USIF_UART_RXFIFO_SETUP
+    \brief  RX FIFO is setup as flow control mode, with byte alignemnet and
+    busrt size as 4 (half of the FIFO size) words
+*/
+#define LANTIQ_USIF_UART_RXFIFO_SETUP                 \
+	(LANTIQ_USIF_FIFO_CFG_RXFC | SM(LANTIQ_USIF_RXFIFO_ALIGN_BYTE,\
+	LANTIQ_USIF_FIFO_CFG_RXFA) | SM(LANTIQ_USIF_RXFIFO_BURST_WORD4,\
+	LANTIQ_USIF_FIFO_CFG_RXBS))
+
+
+#define LANTIQ_USIF_UART_FIFO_SETUP  (LANTIQ_USIF_UART_TXFIFO_SETUP |\
+	LANTIQ_USIF_UART_RXFIFO_SETUP)
+
+/* Baudrate supported */
+#define LANTIQ_USIF_BAUD_115200    115200
+#define LANTIQ_USIF_BAUD_57600     57600
+#define LANTIQ_USIF_BAUD_38400     38400
+#define LANTIQ_USIF_BAUD_19200     19200
+#define LANTIQ_USIF_BAUD_9600      9600
+#define LANTIQ_USIF_BAUD_4800      4800
+#define LANTIQ_USIF_BAUD_2400      2400
+#define LANTIQ_USIF_BAUD_1200      1200
+#define USIF_BAUD_300       300
+#define LANTIQ_USIF_BAUD_MIN       (USIF_BAUD_300)
+
+/*! \def IFX_PORT_USIF_UART
+    \brief  Identification number for USIF driver in serial core, it has been
+    used till 62 Remember to move the following two lines to
+    linux/serial_core.h
+*/
+#define IFX_PORT_USIF_UART   112
+
+/* baudrates */
+typedef enum {
+	LANTIQ_USIF_HW_BPS_300,
+	LANTIQ_USIF_HW_BPS_1200,
+	LANTIQ_USIF_HW_BPS_2400,
+	LANTIQ_USIF_HW_BPS_4800,
+	LANTIQ_USIF_HW_BPS_9600,
+	LANTIQ_USIF_HW_BPS_19200,
+	LANTIQ_USIF_HW_BPS_38400,
+	LANTIQ_USIF_HW_BPS_57600,
+	LANTIQ_USIF_HW_BPS_115200,
+	LANTIQ_USIF_HW_BPS_NUM_BAUDRATES
+} LANTIQ_USIF_HW_BAUDRATE_IDX_t;
+
+typedef struct lantiq_usif_baudrate_desc {
+	u32 inc;
+	u32 dec;
+	u32 bc;
+	u32 clc_rmc;
+	u8 rtstl; /* flow control ttl level */
+	u32 tmo; /* timeout in shift clock cycles */
+	u32 tm;  /* Configure timer value */
+	u32 tsp;
+} LANTIQ_USIF_BAUDRATE_DESC_t;
+
+typedef struct lantiq_usif_hw_baudtable {
+	unsigned long max_baudrate;
+	LANTIQ_USIF_BAUDRATE_DESC_t fpi[LANTIQ_USIF_HW_BPS_NUM_BAUDRATES];
+} LANTIQ_USIF_HW_BAUDTABLE_t;
+
+#define LANTIQ_USIF_UART_DMA_DB_SHORT_CONST    71
+#define LANTIQ_USIF_HW_SHORT_TIMEOUT_300 (2036 * LANTIQ_USIF_UART_DMA_DB_SHORT_CONST)
+#define LANTIQ_USIF_HW_SHORT_TIMEOUT_1200 (768 * LANTIQ_USIF_UART_DMA_DB_SHORT_CONST)
+#define LANTIQ_USIF_HW_SHORT_TIMEOUT_2400 (384 * LANTIQ_USIF_UART_DMA_DB_SHORT_CONST)
+#define LANTIQ_USIF_HW_SHORT_TIMEOUT_4800 (192 * LANTIQ_USIF_UART_DMA_DB_SHORT_CONST)
+#define LANTIQ_USIF_HW_SHORT_TIMEOUT_9600  (96 * LANTIQ_USIF_UART_DMA_DB_SHORT_CONST)
+#define LANTIQ_USIF_HW_SHORT_TIMEOUT_19200 (48 * LANTIQ_USIF_UART_DMA_DB_SHORT_CONST)
+#define LANTIQ_USIF_HW_SHORT_TIMEOUT_38400 (24 * LANTIQ_USIF_UART_DMA_DB_SHORT_CONST)
+#define LANTIQ_USIF_HW_SHORT_TIMEOUT_57600 (16 * LANTIQ_USIF_UART_DMA_DB_SHORT_CONST)
+#define LANTIQ_USIF_HW_SHORT_TIMEOUT_115200 (8 * LANTIQ_USIF_UART_DMA_DB_SHORT_CONST)
+
+/**
+ * Interrupt type. The SA_INTERRUPT will block all other interrupts till the
+ * calling interrupt is serviced. This is required, as the receive interrupt
+ * will call the 'tty_flip_buffer_push' utility and does not want to service
+ * the transmit interrupt in-between.
+ */
+
+#define LANTIQ_USIF_UART_IRQ_LOCK_INIT(port, _name)
+#define LANTIQ_USIF_UART_IRQ_LOCK_DESTROY(port)
+
+#define LANTIQ_USIF_UART_IRQ_LOCK(port) do {                  \
+	unsigned long __ilockflags;                        \
+	spin_lock_irqsave(&((port)->lock), __ilockflags);
+
+#define LANTIQ_USIF_UART_IRQ_UNLOCK(port)                     \
+	spin_unlock_irqrestore(&((port)->lock), __ilockflags); \
+} while (0)
+
+typedef struct lantiq_usif_uart_proc_stat {
+	__u32 tx_intr_breq;
+	__u32 tx_intr_lbreq;
+	__u32 tx_intr_sreq;
+	__u32 tx_intr_lsreq;
+	__u32 tx_intr_txfin;
+	__u32 tx_start_req;
+	__u32 tx_stop_req;
+	__u32 tx_write_fifo;
+	__u32 tx_bytes;
+	__u32 tx_stopped;
+	__u32 tx_req_fifo_full;
+
+	__u32 rx_intr_breq;
+	__u32 rx_intr_lbreq;
+	__u32 rx_intr_sreq;
+	__u32 rx_intr_lsreq;
+	__u32 rx_read_fifo;
+	__u32 rx_last_rps;
+	__u32 rx_low_latency;
+	__u32 rx_bytes;
+
+	__u32 err_int_rxur;
+	__u32 err_int_txur;
+	__u32 err_int_txof;
+	__u32 err_int_phe;
+	__u32 err_int_bre;
+	__u32 err_int_crc;
+} LANTIQ_USIF_UART_PROC_STAT_t;
+
+/* Wrap usif uart port structure around the generic uart_port */
+typedef struct lantiq_usif_uart_port {
+	struct uart_port port;	/* Must be the first */
+	u32 tx_progress;
+	u32 rx_rps_cnt:13; /* Record the count of data read already */
+	u32 prev_baud;   /* Record the previous baud rate to speed up config */
+	u32 prev_mode_cfg; /* Record the previous mode configration to speed
+			      up config */
+	u32 prev_prtc_cfg; /* Record the previous protocol to speed up config*/
+	u8 tx_irq;   /* TX interrupt */
+	u8 rx_irq;   /* RX interrupt */
+	u8 wakeup_irq; /* Wakeup interrupt */
+	u8 autobaud_irq; /* Autoband interrupt */
+	u8 status_irq; /* Status interrupt for modem */
+	u8 err_irq;    /* Error interrupt */
+	u32 debug;
+	LANTIQ_USIF_UART_PROC_STAT_t usif_proc_data;
+} LANTIQ_USIF_UART_PORT_t;
+
+/* Structure for FDIV_CFG, fractional divider configuration register */
+typedef union lantiq_usif_baudrate_fdiv {
+	struct {
+#if defined(__BIG_ENDIAN)
+		u32 dec:16;
+		u32 dummy:7;
+		u32 inc:9;
+#else
+		u32 inc:9;
+		u32 dummy:7;
+		u32 dec:16;
+#endif /* __BIG_ENDIAN */
+	} fdiv_cfg_bits;
+	u32 fdiv_cfg_word;
+} LANTIQ_USIF_BAUDRATE_FDIV_t;
+
+#define INT_NUM_IM3_IRL3 		   (INT_NUM_IM3_IRL0 + 3)
+#define INT_NUM_IM3_IRL4 		   (INT_NUM_IM3_IRL0 + 4)
+#define INT_NUM_IM3_IRL5 		   (INT_NUM_IM3_IRL0 + 5)
+#define INT_NUM_IM3_IRL6 		   (INT_NUM_IM3_IRL0 + 6)
+#define INT_NUM_IM3_IRL21 		   (INT_NUM_IM3_IRL0 + 21)
+#define INT_NUM_IM0_IRL21 		   (INT_NUM_IM0_IRL0 + 21)
+
+#define LANTIQ_USIF_EIR_INT                INT_NUM_IM3_IRL3
+#define LANTIQ_USIF_STA_INT                INT_NUM_IM3_IRL4
+#define LANTIQ_USIF_AB_INT                 INT_NUM_IM3_IRL5
+#define LANTIQ_USIF_WKP_INT                INT_NUM_IM3_IRL6
+#define LANTIQ_USIF_TX_INT                 INT_NUM_IM0_IRL21
+#define LANTIQ_USIF_RX_INT                 INT_NUM_IM3_IRL21
+
+/* @} */
+#endif /* LTQMIPS_USIF_UART_H */
+
