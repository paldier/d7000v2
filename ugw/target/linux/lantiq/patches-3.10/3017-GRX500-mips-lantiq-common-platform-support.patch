# HG changeset patch
# Parent de78f9a59e6cdfe0f78e92d045e98210979c40a5
imported patch 3017-GRX500-mips-lantiq-common-platform-support.patch

diff --git a/arch/mips/include/asm/processor.h b/arch/mips/include/asm/processor.h
--- a/arch/mips/include/asm/processor.h
+++ b/arch/mips/include/asm/processor.h
@@ -20,6 +20,10 @@
 #include <asm/mipsregs.h>
 #include <asm/prefetch.h>
 
+#ifdef CONFIG_SOC_GRX500
+#define ARCH_LOW_ADDRESS_LIMIT MAX_DMA_ADDRESS
+#endif
+
 /*
  * Return current * instruction pointer ("program counter").
  */
diff --git a/arch/mips/kernel/head.S b/arch/mips/kernel/head.S
--- a/arch/mips/kernel/head.S
+++ b/arch/mips/kernel/head.S
@@ -146,10 +146,17 @@ EXPORT(__image_cmdline)
 	.fill	0x400
 #endif /* CONFIG_IMAGE_CMDLINE_HACK */
 
+#if defined(CONFIG_SOC_GRX500)||defined(CONFIG_SOC_GRX500_BOOTCORE)
+	.ascii  "OWRTDTB:"
+	EXPORT(__image_dtb)
+	.fill   0x8000
+	__REF
+#else
 	.ascii  "OWRTDTB:"
 	EXPORT(__image_dtb)
 	.fill   0x4000
 	__REF
+#endif
 
 #ifdef CONFIG_EVA
 	.align  8
diff --git a/arch/mips/lantiq/LICENSE b/arch/mips/lantiq/LICENSE
new file mode 100644
--- /dev/null
+++ b/arch/mips/lantiq/LICENSE
@@ -0,0 +1,368 @@
+This source code is distributed under a dual license of GPL and BSD (2-clause).
+Please choose the appropriate license for your intended usage.
+
+1. BSD license (2-clause BSD license)
+
+Copyright (c) 2009, Lantiq Deutschland GmbH
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+  * Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+  * Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions and the following disclaimer in the documentation
+	and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+2.		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --git a/arch/mips/lantiq/Platform b/arch/mips/lantiq/Platform
--- a/arch/mips/lantiq/Platform
+++ b/arch/mips/lantiq/Platform
@@ -7,7 +7,12 @@ cflags-$(CONFIG_LANTIQ)		+= -I$(srctree)
 ifndef CONFIG_EVA
 load-$(CONFIG_LANTIQ)		= 0xffffffff80002000
 else
+ifdef CONFIG_USE_EMULATOR
+load-$(CONFIG_LANTIQ)   = 0xffffffff80002000
+else
 load-$(CONFIG_LANTIQ)   = 0xffffffff00002000
 endif
+endif
 cflags-$(CONFIG_SOC_TYPE_XWAY)	+= -I$(srctree)/arch/mips/include/asm/mach-lantiq/xway
 cflags-$(CONFIG_SOC_FALCON)	+= -I$(srctree)/arch/mips/include/asm/mach-lantiq/falcon
+cflags-$(CONFIG_SOC_GRX500)     += -I$(srctree)/arch/mips/include/asm/mach-lantiq/grx500
diff --git a/arch/mips/lantiq/grx500/Makefile b/arch/mips/lantiq/grx500/Makefile
new file mode 100755
--- /dev/null
+++ b/arch/mips/lantiq/grx500/Makefile
@@ -0,0 +1,5 @@
+obj-y := prom.o reset.o sysctrl.o clk.o
+
+obj-$(CONFIG_SOC_GRX500) += irq.o
+
+
diff --git a/arch/mips/lantiq/grx500/prom.c b/arch/mips/lantiq/grx500/prom.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/lantiq/grx500/prom.c
@@ -0,0 +1,339 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ * Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ * Copyright (C) 2014~2015 Lei Chuanhua <Chuanhua.lei@lantiq.com>
+ */
+
+#include <linux/export.h>
+#include <linux/clk.h>
+#include <linux/bootmem.h>
+#include <linux/of_platform.h>
+#include <linux/of_fdt.h>
+
+#include <asm/traps.h>
+#include <asm/bootinfo.h>
+#include <linux/time.h>
+#include <asm/gcmpregs.h>
+#include <asm/mips-cpc.h>
+#include <asm/smp-ops.h>
+#include <lantiq.h>
+#include <asm/dma-coherence.h>
+#include <asm/gic.h>
+#include <asm/gcmpregs.h>
+#include <asm/mach-lantiq/grx500/lantiq_soc.h>
+
+#include "prom.h"
+#include "clk.h"
+
+
+#define SOC_GRX500		"GRX500"
+#define SOC_GRX350		"GRX350"
+
+#ifdef CONFIG_USE_EMULATOR
+#define SOC_ID_PD	0
+#endif
+
+#define COMP_GRX500		"lantiq,grx500"
+
+#define PART_SHIFT		12
+#define PART_MASK		0x0FFFFFFF
+#define REV_SHIFT		28
+#define REV_MASK		0x70000000
+
+/* access to the ebu needs to be locked between different drivers */
+DEFINE_SPINLOCK(ebu_lock);
+EXPORT_SYMBOL_GPL(ebu_lock);
+
+extern struct boot_param_header __image_dtb;
+
+/*
+ * this struct is filled by the soc specific detection code and holds
+ * information about the specific soc type, revision and name
+ */
+static struct ltq_soc_info soc_info;
+#ifdef CONFIG_LTQ_CBM
+void *ltq_cbm_std_buf_base;
+void *ltq_cbm_jbo_buf_base;
+#endif
+unsigned int ltq_get_cpu_id(void)
+{
+	return soc_info.partnum;
+}
+EXPORT_SYMBOL(ltq_get_cpu_id);
+
+unsigned int ltq_get_soc_type(void)
+{
+	return soc_info.type;
+}
+EXPORT_SYMBOL(ltq_get_soc_type);
+
+unsigned int ltq_get_soc_rev(void)
+{
+	return soc_info.rev;
+}
+EXPORT_SYMBOL(ltq_get_soc_rev);
+
+const char *get_system_type(void)
+{
+	return soc_info.sys_type;
+}
+
+void prom_free_prom_memory(void)
+{
+}
+
+static void __init prom_init_cmdline(void)
+{
+	int argc = fw_arg0;
+	char **argv = (char **) KSEG1ADDR(fw_arg1);
+	int i;
+
+	arcs_cmdline[0] = '\0';
+
+	for (i = 0; i < argc; i++) {
+		char *p = (char *) KSEG1ADDR(argv[i]);
+
+#ifdef CONFIG_EVA
+		if (RPHYSADDR(p) && *p) {
+			strlcat(arcs_cmdline, p, sizeof(arcs_cmdline));
+			strlcat(arcs_cmdline, " ", sizeof(arcs_cmdline));
+		}
+#else
+		if (CPHYSADDR(p) && *p) {
+			strlcat(arcs_cmdline, p, sizeof(arcs_cmdline));
+			strlcat(arcs_cmdline, " ", sizeof(arcs_cmdline));
+		}
+#endif
+	}
+}
+
+#ifdef CONFIG_EVA
+extern int gcmp_present;
+void BEV_overlay_segment(void);
+#endif
+
+/* Return the number of IOCU's present */
+int __init gcmp_niocu(void)
+{
+	return gcmp_present ?
+		(GCMPGCB(GC) & GCMP_GCB_GC_NUMIOCU_MSK)
+		>> GCMP_GCB_GC_NUMIOCU_SHF : 0;
+}
+
+/* Set GCMP region attributes */
+void __init gcmp_setregion(int region, unsigned long base,
+			   unsigned long mask, int type)
+{
+	GCMPGCBn(CMxBASE, region) = base;
+	GCMPGCBn(CMxMASK, region) = mask | type;
+}
+
+static int __init plat_enable_iocoherency(void)
+{
+	int supported = 0;
+
+	if (gcmp_niocu() != 0) {
+		/* Nothing special needs to be done to enable coherency */
+		pr_info("CMP IOCU detected\n");
+		/* Second IOCU for MPE or other master access register */
+		gcmp_setregion(0, 0xa0000000, 0xf8000000,
+			GCMP_GCB_GCMPB_CMDEFTGT_IOCU2);
+		supported = 1;
+	}
+
+	/* hw_coherentio = supported; */
+
+	return supported;
+}
+
+static void __init plat_setup_iocoherency(void)
+{
+#if defined(CONFIG_DMA_NONCOHERENT)
+	/*
+	 * Kernel has been configured with software coherency
+	 * but we might choose to turn it off and use hardware
+	 * coherency instead.
+	 */
+	if (plat_enable_iocoherency()) {
+		if (coherentio == 0)
+			pr_info("Hardware DMA cache coherency disabled\n");
+		else
+			pr_info("Hardware DMA cache coherency enabled\n");
+	} else {
+		if (coherentio == 1)
+			pr_info("Hardware DMA cache coherency unsupported, but enabled from command line!\n");
+		else
+			pr_info("Software DMA cache coherency enabled\n");
+	}
+#else
+	if (!plat_enable_iocoherency())
+		panic("Hardware DMA cache coherency not supported!");
+#endif /* CONFIG_DMA_NONCOHERENT || CONFIG_DMA_MAYBE_COHERENT */
+}
+
+void __init plat_mem_setup(void)
+{
+	/* EVA has already been configured in mach-lantiq/kernel-entry-init.h */
+if (config_enabled(CONFIG_EVA))
+#ifdef CONFIG_EVA_2GB
+	pr_info("Enhanced Virtual Addressing (EVA 2GB) activated\n");
+#elif defined(CONFIG_EVA_1GB)
+	pr_info("Enhanced Virtual Addressing (EVA 1GB) activated\n");
+#else
+	pr_info("Enhanced Virtual Addressing (EVA Legacy 512MB) activated\n");
+#endif /* CONFIG_EVA_2GB */
+else
+	pr_info("EVA disabled, Lantiq legacy activiated\n");
+
+#ifdef CONFIG_MIPS_CMP
+	if (gcmp_present)
+		BEV_overlay_segment();
+#endif
+
+	pr_info("segctr0 %x segctr1 %x segctr2 %x\n",
+		read_c0_segctl0(), read_c0_segctl1(), read_c0_segctl2());
+	ioport_resource.start = IOPORT_RESOURCE_START;
+	ioport_resource.end = IOPORT_RESOURCE_END;
+	iomem_resource.start = IOMEM_RESOURCE_START;
+	iomem_resource.end = IOMEM_RESOURCE_END;
+
+	set_io_port_base((unsigned long) KSEG1);
+
+	/*
+	 * Load the builtin devicetree. This causes the chosen node to be
+	 * parsed resulting in our memory appearing
+	 */
+	__dt_setup_arch(&__image_dtb);
+
+	plat_setup_iocoherency();
+
+	board_be_init = grx5xx_be_init;
+	board_be_handler = grx5xx_be_handler;
+}
+
+void __init device_tree_init(void)
+{
+	unsigned long base, size;
+
+	if (!initial_boot_params)
+		return;
+
+	base = virt_to_phys((void *)initial_boot_params);
+	size = be32_to_cpu(initial_boot_params->totalsize);
+
+	/* Before we do anything, lets reserve the dt blob */
+	reserve_bootmem(base, size, BOOTMEM_DEFAULT);
+
+	unflatten_device_tree();
+#ifdef CONFIG_LTQ_CBM
+	ltq_cbm_std_buf_base = alloc_bootmem_low(CONFIG_CBM_STD_BUF_POOL_SIZE);
+	if (!ltq_cbm_std_buf_base)
+		panic("no memory for CBM standard buffers !!");
+	else
+		pr_info("reserving %d bytes @ %x for CBM \n", CONFIG_CBM_STD_BUF_POOL_SIZE, (unsigned int)ltq_cbm_std_buf_base);
+	ltq_cbm_jbo_buf_base = alloc_bootmem_low(CONFIG_CBM_JBO_BUF_SIZE);
+	if (!ltq_cbm_jbo_buf_base)
+		panic("no memory for CBM Jumbo buffers !!");
+	else
+		pr_info("reserving %d bytes @ %x for CBM \n", CONFIG_CBM_JBO_BUF_SIZE, (unsigned int)ltq_cbm_jbo_buf_base);
+#endif
+}
+
+phys_t mips_cpc_default_phys_base(void)
+{
+	return CPC_BASE_ADDR;
+}
+
+void __init prom_init(void)
+{
+	/* call the soc specific detetcion code and get it to fill soc_info */
+	ltq_soc_detect(&soc_info);
+	snprintf(soc_info.sys_type, LTQ_SYS_TYPE_LEN - 1, "%s rev %s",
+		soc_info.name, soc_info.rev_type);
+	soc_info.sys_type[LTQ_SYS_TYPE_LEN - 1] = '\0';
+	pr_info("SoC: %s\n", soc_info.sys_type);
+
+	prom_init_cmdline();
+
+	/* Early detection of CMP support */
+	if (gcmp_probe(GCMP_BASE_ADDR, GCMP_ADDRSPACE_SZ)) {
+
+		mips_cpc_probe();
+
+		if (!register_cmp_smp_ops())
+			return;
+
+		if (!register_cps_smp_ops())
+			return;
+	}
+#if defined(CONFIG_MIPS_MT_SMP)
+	if (!register_vsmp_smp_ops())
+		return;
+#endif
+#ifdef CONFIG_MIPS_MT_SMTC
+	register_smp_ops(&msmtc_smp_ops);
+#endif
+}
+
+void __init ltq_soc_detect(struct ltq_soc_info *i)
+{
+#ifdef CONFIG_USE_EMULATOR
+	i->partnum = SOC_ID_PD;
+	i->rev = SOC_ID_PD;
+#else
+	i->partnum = (ltq_r32(LTQ_MPS_CHIPID) & PART_MASK) >> PART_SHIFT;
+	i->rev = (ltq_r32(LTQ_MPS_CHIPID) & REV_MASK) >> REV_SHIFT;
+#endif
+	sprintf(i->rev_type, "1.%d", i->rev);
+	switch (i->partnum) {
+	case SOC_ID_GRX562:
+	case SOC_ID_GRX582:
+	case SOC_ID_GRX583:
+	case SOC_ID_GRX580:
+	case SOC_ID_GRX584:
+	case SOC_ID_GRX585:
+		i->name = SOC_GRX500;
+		i->type = SOC_TYPE_GRX500;
+		i->compatible = COMP_GRX500;
+		break;
+	case SOC_ID_GRX3506:
+	case SOC_ID_GRX3508:
+		i->name = SOC_GRX350;
+		i->type = SOC_TYPE_GRX500;
+		i->compatible = COMP_GRX500;
+		break;
+#ifdef CONFIG_USE_EMULATOR
+	case SOC_ID_PD:
+		i->name = SOC_GRX500;
+		i->type = SOC_TYPE_GRX500;
+		i->compatible = COMP_GRX500;
+		break;
+#endif
+	default:
+		unreachable();
+		break;
+	}
+}
+
+int __init plat_of_setup(void)
+{
+	static struct of_device_id of_ids[3];
+
+	if (!of_have_populated_dt())
+		panic("device tree not present");
+
+	strncpy(of_ids[0].compatible, soc_info.compatible,
+		sizeof(of_ids[0].compatible));
+	strncpy(of_ids[1].compatible, "simple-bus",
+		sizeof(of_ids[1].compatible));
+	if (of_platform_populate(NULL, of_ids, NULL, NULL))
+		panic("failed to poplate DT");
+	 /* make sure ithat the reset controller is setup early */
+	ltq_rst_init();
+	return 0;
+}
+
+arch_initcall(plat_of_setup);
diff --git a/arch/mips/lantiq/grx500/prom.h b/arch/mips/lantiq/grx500/prom.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/lantiq/grx500/prom.h
@@ -0,0 +1,34 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ * Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ */
+
+#ifndef _LTQ_PROM_H__
+#define _LTQ_PROM_H__
+
+#define LTQ_SYS_TYPE_LEN	0x100
+#define LTQ_SYS_REV_LEN		0x10
+
+struct ltq_soc_info {
+	unsigned char *name;
+	unsigned int rev;
+	unsigned char rev_type[LTQ_SYS_REV_LEN];
+	unsigned int srev;
+	unsigned int partnum;
+	unsigned int type;
+	unsigned char sys_type[LTQ_SYS_TYPE_LEN];
+	unsigned char *compatible;
+};
+
+extern void ltq_soc_detect(struct ltq_soc_info *i);
+extern void ltq_soc_init(void);
+
+extern struct boot_param_header __dtb_start;
+
+extern void grx5xx_be_init(void);
+extern int grx5xx_be_handler(struct pt_regs *regs, int is_fixup);
+
+#endif
diff --git a/arch/mips/lantiq/grx500/reset.c b/arch/mips/lantiq/grx500/reset.c
new file mode 100755
--- /dev/null
+++ b/arch/mips/lantiq/grx500/reset.c
@@ -0,0 +1,331 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ *  Copyright (C) 2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/pm.h>
+#include <linux/export.h>
+#include <linux/delay.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/reset-controller.h>
+
+#include <asm/reboot.h>
+
+#include <lantiq_soc.h>
+
+#include "prom.h"
+
+/* reset request register */
+#define RCU_RST_REQ		0x0010
+/* reset status register */
+#define RCU_RST_STAT		0x0014
+/* vr9 gphy registers */
+#define RCU_GFS_ADD0_XRX200	0x0020
+#define RCU_GFS_ADD1_XRX200	0x0068
+
+#define RCU_AHB_ENDIAN		0x004C
+#define RCU_VR9_BE_AHB1S	0x00000008
+
+/* reboot bit */
+#define RCU_RD_GPHY0_XRX200	BIT(31)
+#define RCU_RD_SRST		BIT(30)
+#define RCU_RD_GPHY1_XRX200	BIT(29)
+
+/* xRX300 bits */
+#define RCU_RD_GPHY0_XRX300	BIT(31)
+#define RCU_RD_GPHY1_XRX300	BIT(29)
+#define RCU_RD_GPHY2_XRX300	BIT(28)
+
+/* xRX330 bits */
+#define RCU_RD_GPHY0_XRX330	BIT(31)
+#define RCU_RD_GPHY1_XRX330	BIT(29)
+#define RCU_RD_GPHY2_XRX330	BIT(28)
+#define RCU_RD_GPHY3_XRX330	BIT(10)
+
+/* xRX300 gphy registers */
+#define RCU_GFS_ADD0_XRX300	0x0020
+#define RCU_GFS_ADD1_XRX300	0x0058
+#define RCU_GFS_ADD2_XRX300	0x00AC
+
+/* xRX330 gphy registers */
+#define RCU_GFS_ADD0_XRX330	0x0020
+#define RCU_GFS_ADD1_XRX330	0x0058
+#define RCU_GFS_ADD2_XRX330	0x00AC
+#define RCU_GFS_ADD3_XRX330	0x0264
+
+/* reset cause */
+#define RCU_STAT_SHIFT		26
+/* boot selection */
+#define RCU_BOOT_SEL(x)		((x >> 18) & 0x7)
+#define RCU_BOOT_SEL_XRX200(x)	(((x >> 17) & 0xf) | ((x >> 8) & 0x10))
+
+/* remapped base addr of the reset control unit */
+static void __iomem *ltq_rcu_membase;
+static struct device_node *ltq_rcu_np;
+static DEFINE_SPINLOCK(ltq_rcu_lock);
+
+/* This function is used by the watchdog driver */
+int ltq_reset_cause(void)
+{
+	u32 val = ltq_rcu_r32(RCU_RST_STAT);
+	return val >> RCU_STAT_SHIFT;
+}
+EXPORT_SYMBOL_GPL(ltq_reset_cause);
+
+/* This function is used by the watchdog driver */
+int ltq_reset_get_status (void)
+{
+	u32 val = ltq_rcu_r32(RCU_RST_REQ);
+	return val;
+}
+EXPORT_SYMBOL_GPL(ltq_reset_get_status);
+
+/* allow platform code to find out what source we booted from */
+unsigned char ltq_boot_select(void)
+{
+	u32 val = ltq_rcu_r32(RCU_RST_STAT);
+
+	if (of_device_is_compatible(ltq_rcu_np, "lantiq,rcu-xrx200"))
+		return RCU_BOOT_SEL_XRX200(val);
+
+	return RCU_BOOT_SEL(val);
+}
+
+/* reset / boot a gphy */
+static struct ltq_xrx200_gphy_reset {
+	u32 rd;
+	u32 addr;
+} xrx200_gphy[] = {
+	{RCU_RD_GPHY0_XRX200, RCU_GFS_ADD0_XRX200},
+	{RCU_RD_GPHY1_XRX200, RCU_GFS_ADD1_XRX200},
+};
+
+/* reset / boot a gphy */
+static struct ltq_xrx300_gphy_reset {
+	u32 rd;
+	u32 addr;
+} xrx300_gphy[] = {
+	{RCU_RD_GPHY0_XRX300, RCU_GFS_ADD0_XRX300},
+	{RCU_RD_GPHY1_XRX300, RCU_GFS_ADD1_XRX300},
+	{RCU_RD_GPHY2_XRX300, RCU_GFS_ADD2_XRX300},
+};
+
+/* reset / boot a gphy */
+static struct ltq_xrx330_gphy_reset {
+	u32 rd;
+	u32 addr;
+} xrx330_gphy[] = {
+	{RCU_RD_GPHY0_XRX330, RCU_GFS_ADD0_XRX330},
+	{RCU_RD_GPHY1_XRX330, RCU_GFS_ADD1_XRX330},
+	{RCU_RD_GPHY2_XRX330, RCU_GFS_ADD2_XRX330},
+	{RCU_RD_GPHY3_XRX330, RCU_GFS_ADD3_XRX330},
+};
+
+/* reset and boot a gphy. these phys only exist on xrx200 SoC */
+int xrx200_gphy_boot(struct device *dev, unsigned int id, dma_addr_t dev_addr)
+{
+
+	if (!of_device_is_compatible(ltq_rcu_np, "lantiq,rcu-xrx200")) {
+		dev_err(dev, "this SoC has no GPHY\n");
+		return -EINVAL;
+	}
+
+	if (of_machine_is_compatible("lantiq,vr9")) {
+		struct clk *clk;
+		clk = clk_get_sys("1f203000.rcu", "gphy");
+		if (IS_ERR(clk))
+			return PTR_ERR(clk);
+		clk_enable(clk);
+	}
+
+	dev_info(dev, "booting GPHY%u firmware at %X\n", id, dev_addr);
+
+	if (of_machine_is_compatible("lantiq,vr9")) {
+		if (id > 1) {
+			dev_err(dev, "%u is an invalid gphy id\n", id);
+			return -EINVAL;
+		}
+		ltq_rcu_w32_mask(0, xrx200_gphy[id].rd, RCU_RST_REQ);
+		ltq_rcu_w32(dev_addr, xrx200_gphy[id].addr);
+		ltq_rcu_w32_mask(xrx200_gphy[id].rd, 0,  RCU_RST_REQ);
+	} else if (of_machine_is_compatible("lantiq,ar10")) {
+		if (id > 2) {
+			dev_err(dev, "%u is an invalid gphy id\n", id);
+			return -EINVAL;
+		}
+		ltq_rcu_w32_mask(0, xrx300_gphy[id].rd, RCU_RST_REQ);
+		ltq_rcu_w32(dev_addr, xrx300_gphy[id].addr);
+		ltq_rcu_w32_mask(xrx300_gphy[id].rd, 0,  RCU_RST_REQ);
+	} else if (of_machine_is_compatible("lantiq,grx390")) {
+		if (id > 3) {
+			dev_err(dev, "%u is an invalid gphy id\n", id);
+			return -EINVAL;
+		}
+		ltq_rcu_w32_mask(0, xrx330_gphy[id].rd, RCU_RST_REQ);
+		ltq_rcu_w32(dev_addr, xrx330_gphy[id].addr);
+		ltq_rcu_w32_mask(xrx330_gphy[id].rd, 0,  RCU_RST_REQ);
+	}
+	return 0;
+}
+
+/* reset a io domain for u micro seconds */
+void ltq_reset_once(unsigned int module, ulong u)
+{
+	ltq_rcu_w32_mask(0, module, RCU_RST_REQ);
+	udelay(u);
+	ltq_rcu_w32_mask(module, 0, RCU_RST_REQ);
+}
+EXPORT_SYMBOL_GPL(ltq_reset_once);
+
+/* reset a io domain by hardware control instead of software control */
+void ltq_hw_reset(unsigned int module)
+{
+	ltq_rcu_w32(module, RCU_RST_REQ);
+	while (!(ltq_rcu_r32(RCU_RST_STAT) & module))
+		;
+}
+EXPORT_SYMBOL_GPL(ltq_hw_reset);
+
+void ltq_rcu_w32(uint32_t val, uint32_t reg_off)
+{
+	ltq_w32(val, ltq_rcu_membase + reg_off);
+}
+EXPORT_SYMBOL_GPL(ltq_rcu_w32);
+
+uint32_t ltq_rcu_r32(uint32_t reg_off)
+{
+	return ltq_r32(ltq_rcu_membase + reg_off);
+}
+EXPORT_SYMBOL_GPL(ltq_rcu_r32);
+
+void ltq_rcu_w32_mask(uint32_t clr, uint32_t set, uint32_t reg_off)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ltq_rcu_lock, flags);
+	ltq_rcu_w32((ltq_rcu_r32(reg_off) & ~(clr)) | (set), reg_off);
+	spin_unlock_irqrestore(&ltq_rcu_lock, flags);
+}
+EXPORT_SYMBOL_GPL(ltq_rcu_w32_mask);
+
+#if 0
+static void ltq_xbar_ahb1s_big_endian(void)
+{
+	ltq_rcu_w32_mask(0, RCU_VR9_BE_AHB1S, RCU_AHB_ENDIAN);
+}
+#endif
+
+static int ltq_assert_device(struct reset_controller_dev *rcdev,
+				unsigned long id)
+{
+	u32 val;
+
+	if (id < 8)
+		return -1;
+
+	val = ltq_rcu_r32(RCU_RST_REQ);
+	val |= BIT(id);
+	ltq_rcu_w32(val, RCU_RST_REQ);
+
+	return 0;
+}
+
+static int ltq_deassert_device(struct reset_controller_dev *rcdev,
+				  unsigned long id)
+{
+	u32 val;
+
+	if (id < 8)
+		return -1;
+
+	val = ltq_rcu_r32(RCU_RST_REQ);
+	val &= ~BIT(id);
+	ltq_rcu_w32(val, RCU_RST_REQ);
+
+	return 0;
+}
+
+static int ltq_reset_device(struct reset_controller_dev *rcdev,
+			       unsigned long id)
+{
+	ltq_assert_device(rcdev, id);
+	return ltq_deassert_device(rcdev, id);
+}
+
+static struct reset_control_ops reset_ops = {
+	.reset = ltq_reset_device,
+	.assert = ltq_assert_device,
+	.deassert = ltq_deassert_device,
+};
+
+static struct reset_controller_dev reset_dev = {
+	.ops			= &reset_ops,
+	.owner			= THIS_MODULE,
+	.nr_resets		= 32,
+	.of_reset_n_cells	= 1,
+};
+
+void ltq_rst_init(void)
+{
+	reset_dev.of_node = of_find_compatible_node(NULL, NULL,
+						"lantiq,xway-reset");
+	if (!reset_dev.of_node)
+		pr_err("Failed to find reset controller node");
+	else
+		reset_controller_register(&reset_dev);
+}
+
+static void ltq_machine_restart(char *command)
+{
+	local_irq_disable();
+	ltq_rcu_w32(ltq_rcu_r32(RCU_RST_REQ) | RCU_RD_SRST, RCU_RST_REQ);
+	unreachable();
+}
+
+static void ltq_machine_halt(void)
+{
+	local_irq_disable();
+	unreachable();
+}
+
+static void ltq_machine_power_off(void)
+{
+	local_irq_disable();
+	unreachable();
+}
+
+static int __init mips_reboot_setup(void)
+{
+	struct resource res;
+
+	ltq_rcu_np = of_find_compatible_node(NULL, NULL, "lantiq,rcu-grx500");
+
+	/* check if all the reset register range is available */
+	if (!ltq_rcu_np)
+		panic("Failed to load reset resources from devicetree");
+
+	if (of_address_to_resource(ltq_rcu_np, 0, &res))
+		panic("Failed to get rcu memory range");
+
+	if (request_mem_region(res.start, resource_size(&res), res.name) < 0)
+		pr_err("Failed to request rcu memory");
+
+	ltq_rcu_membase = ioremap_nocache(res.start, resource_size(&res));
+	if (!ltq_rcu_membase)
+		panic("Failed to remap core memory");
+
+	_machine_restart = ltq_machine_restart;
+	_machine_halt = ltq_machine_halt;
+	pm_power_off = ltq_machine_power_off;
+	return 0;
+}
+
+arch_initcall(mips_reboot_setup);
diff --git a/arch/mips/lantiq/grx500/sysctrl.c b/arch/mips/lantiq/grx500/sysctrl.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/lantiq/grx500/sysctrl.c
@@ -0,0 +1,395 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2011-2012 John Crispin <blogic@openwrt.org>
+ *  Copyright (C) 2015 Lei Chuanhua <Chuanhua.lei@lantiq.com>
+ */
+#include <linux/ioport.h>
+#include <linux/export.h>
+#include <linux/clkdev.h>
+#include <linux/spinlock.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+
+#include <lantiq_soc.h>
+
+#include "clk.h"
+#include "prom.h"
+
+
+/* First register set */
+#define CGU_CLK_SR1	0x120 /* status */
+#define CGU_CLK_CR1_A	0x124 /* Enable */
+#define CGU_CLK_CR1_B	0x128 /* Disable */
+/* Second register set */
+#define CGU_CLK_SR2	0x130 /* status */
+#define CGU_CLK_CR2_A	0x134 /* Enable */
+#define CGU_CLK_CR2_B	0x138 /* Disable */
+
+/* clock gates that we can en/disable */
+/* Register 0 /module 0 */
+#define CGU_VCODEC	BIT(2)
+#define CGU_I2C		BIT(4) /* I2C uses reserved bit 4 */
+#define CGU_DMA		BIT(5)
+#define CGU_USB0	BIT(6)
+#define CGU_SPI1	BIT(7)
+#define CGU_SPI0	BIT(8)
+#define CGU_CBM		BIT(9)
+#define CGU_EBU		BIT(10)
+#define CGU_LEDC	BIT(11)
+#define CGU_GPTC0	BIT(12)
+#define CGU_GPTC1	BIT(13)
+#define CGU_GPTC2	BIT(14)
+#define CGU_ASC0	BIT(17) /* ASC1 enabled by default */
+#define CGU_EIP97	BIT(20)
+#define CGU_EIP123	BIT(21)
+#define CGU_TOE		BIT(22)
+#define CGU_MPE		BIT(23)
+#define CGU_TDM		BIT(25)
+#define CGU_SWITCH_R	BIT(26)
+#define CGU_USB1	BIT(27)
+#define CGU_SWITCH_L	BIT(28)
+
+#define CGU_MODULE0_ALL	0x1EF27FE4
+
+/* Register 1 /module 1*/
+#define CGU_PCIE_CTRL0	BIT(1)
+#define CGU_PCIE_CTRL1	BIT(17)
+#define CGU_PCIE_CTRL2	BIT(25)
+
+#define CGU_MODULE1_ALL	0x02020002
+
+#define CGU_REG_MODULE_0	0
+#define CGU_REG_MODULE_1	1
+
+#define CGU_IF_CLK		0x00C4
+#define GPHY_CLK_MODE_CMOS	BIT(0)
+#define GPHY_CLK_SRC		0x1C
+#define GPHY_CLK_SRC_S		2
+#define GPHY_CLK_SRC_XTAL	1
+#define GPHY_CLK_SRC_EXT	2
+#define CGU_CLK_OUT2		0xC00
+#define CGU_CLK_OUT2_S		10
+#define CGU_CLK_OUT1		0x3000
+#define CGU_CLK_OUT1_S		12
+#define CGU_CLK_OUT0		0xC000
+#define CGU_CLK_OUT0_S		14
+
+void __iomem *ltq_cgu_membase;
+void __iomem *ltq_ebu_membase;
+void __iomem *ltq_dmanand_membase;
+
+/* Status */
+static u32 cgu_clk_sr[] = {
+	CGU_CLK_SR1,
+	CGU_CLK_SR2,
+};
+
+/* Enable */
+static u32 cgu_clk_cr_a[] = {
+	CGU_CLK_CR1_A,
+	CGU_CLK_CR2_A,
+};
+
+/* Disable */
+static u32 cgu_clk_cr_b[] = {
+	CGU_CLK_CR1_B,
+	CGU_CLK_CR2_B,
+};
+
+/* power control register */
+#define CGU_CR_EN_XRX(x)	(cgu_clk_cr_a[(x)])
+#define CGU_CR_DIS_XRX(x)	(cgu_clk_cr_b[(x)])
+/* power status register */
+#define CGU_SR_XRX(x)		(cgu_clk_sr[(x)])
+
+/* enable a clock gate */
+static int cgu_enable(struct clk *clk)
+{
+	int retry = 1000000;
+
+	if (!clk->always_on) {
+		pr_debug("%s module %d position 0x%08x always on\n",
+			__func__, clk->module, clk->bits);
+		return 0;
+	}
+
+	if (atomic_read(&clk->refcount) == 0) {
+		ltq_cgu_w32(clk->bits, CGU_CR_EN_XRX(clk->module));
+		do {} while (--retry
+			&& (!(ltq_cgu_r32(CGU_SR_XRX(clk->module))
+			& clk->bits)));
+		if (!retry)
+			panic("Activating CGU module failed!\n");
+		pr_debug("%s module %d position 0x%08x enabled\n",
+			__func__, clk->module, clk->bits);
+
+	} else {
+		pr_debug("%s module %d position 0x%08x already enabled\n",
+			__func__, clk->module, clk->bits);
+	}
+	atomic_inc(&clk->refcount);
+	return 0;
+}
+
+/* disable a clock gate */
+static void cgu_disable(struct clk *clk)
+{
+	int retry = 1000000;
+
+	if (!clk->always_on) {
+		pr_debug("%s module %d position 0x%08x always on\n",
+			__func__, clk->module, clk->bits);
+		return;
+	}
+
+	/* Consider disabling the module when powering on the system */
+	if (atomic_read(&clk->refcount) > 0)
+		atomic_dec(&clk->refcount);
+
+	if (atomic_read(&clk->refcount) == 0) {
+		ltq_cgu_w32(clk->bits, CGU_CR_DIS_XRX(clk->module));
+		do {} while (--retry
+			&& (ltq_cgu_r32(CGU_SR_XRX(clk->module)) & clk->bits));
+
+		if (!retry)
+			panic("activating CGU module failed!\n");
+		pr_debug("%s module %d position 0x%08x disabled\n",
+			__func__, clk->module, clk->bits);
+	} else {
+		pr_debug("%s module %d position 0x%08x still used\n",
+			__func__, clk->module, clk->bits);
+	}
+}
+
+/* manage the clock gates via CGU */
+static void clkdev_add_pmu(const char *dev, const char *con,
+		bool used, unsigned int module, unsigned int bits)
+{
+	struct clk *clk = kzalloc(sizeof(struct clk), GFP_KERNEL);
+	if (clk == NULL)
+		return;
+	clk->cl.dev_id = dev;
+	clk->cl.con_id = con;
+	clk->cl.clk = clk;
+	clk->always_on = used;
+	clk->enable = cgu_enable;
+	clk->disable = cgu_disable;
+	clk->module = module;
+	clk->bits = bits;
+	atomic_set(&clk->refcount, 0);
+	/* Disable it during the initialitin. Module should enable when used */
+	cgu_disable(clk);
+	clkdev_add(&clk->cl);
+}
+
+/* enable a clockout source */
+static int clkout0_enable(struct clk *clk)
+{
+	u32 val = ltq_cgu_r32(CGU_IF_CLK);
+
+	val &= ~(3 << CGU_CLK_OUT0_S);
+	val |= 2 << CGU_CLK_OUT0_S;
+	ltq_cgu_w32(val, CGU_IF_CLK);
+	return 0;
+}
+
+static void clkout0_disable(struct clk *clk)
+{
+	u32 val = ltq_cgu_r32(CGU_IF_CLK);
+
+	val &= ~(3 << CGU_CLK_OUT0_S);
+	ltq_cgu_w32(val, CGU_IF_CLK);
+}
+
+static void clkdev_add_clkout0(int used)
+{
+	struct clk *clk;
+
+	clk = kzalloc(sizeof(struct clk), GFP_KERNEL);
+	if (clk == NULL)
+		return;
+	clk->cl.dev_id = NULL;
+	clk->cl.con_id = "clkout0";
+	clk->cl.clk = clk;
+	clk->rate = CLOCK_8M_192K;
+	clk->enable = clkout0_enable;
+	clk->disable = clkout0_disable;
+	clk->always_on = used;
+	clk->module = 0;
+	clkout0_disable(clk);
+	clkdev_add(&clk->cl);
+}
+
+#ifdef CONFIG_USE_EMULATOR
+#define		CGU_ON	0
+#else
+#define		CGU_ON	1
+#endif
+/* bring up all register ranges that we need for basic system control */
+void __init ltq_soc_init(void)
+{
+	struct resource res_cgu, res_ebu, res_hsnand;
+	struct device_node *np_cgu =
+		of_find_compatible_node(NULL, NULL, "lantiq,cgu-grx500");
+	struct device_node *np_ebu =
+		of_find_compatible_node(NULL, NULL, "lantiq,ebu-grx500");
+	struct clk *clk = NULL;
+
+
+	/* check if all the core register ranges are available */
+	if (!np_cgu || !np_ebu)
+		panic("Failed to load core nodes from devicetree");
+
+	if (of_address_to_resource(np_cgu, 0, &res_cgu) ||
+	    of_address_to_resource(np_ebu, 0, &res_ebu))
+		panic("Failed to get core resources");
+
+	if (!(request_mem_region(res_cgu.start, resource_size(&res_cgu),
+		res_cgu.name)) ||
+	    !(request_mem_region(res_ebu.start, resource_size(&res_ebu),
+		res_ebu.name)))
+		pr_err("Failed to request core reources");
+
+	ltq_cgu_membase = ioremap_nocache(res_cgu.start,
+		resource_size(&res_cgu));
+	ltq_ebu_membase = ioremap_nocache(res_ebu.start,
+		resource_size(&res_ebu));
+
+	if (!ltq_cgu_membase || !ltq_ebu_membase)
+		panic("Failed to remap core resources");
+
+	if (of_address_to_resource(np_ebu, 1, &res_hsnand))
+			panic("Failed to get hsnand resource");
+
+	/* get mem region for hsnand */
+	if (!request_mem_region(res_hsnand.start, resource_size(&res_hsnand),
+			res_hsnand.name))
+		pr_err("Failed to request hsnand reources");
+
+	ltq_dmanand_membase = ioremap_nocache(res_hsnand.start,
+				resource_size(&res_hsnand));
+
+	if (!ltq_dmanand_membase)
+		panic("Failed to remap hsnand resources");
+
+	ltq_ebu_w32(ltq_ebu_r32(LTQ_EBU_BUSCON0) & ~EBU_WRDIS,
+			LTQ_EBU_BUSCON0);
+	/* add our generic grx500 clocks */
+	clkdev_add_pmu(NULL, "vcodec", CGU_ON, CGU_REG_MODULE_0, CGU_VCODEC);
+	clkdev_add_pmu("16e00000.dma", NULL, CGU_ON, CGU_REG_MODULE_0,
+		CGU_DMA);
+	clkdev_add_pmu("1a300000.usb", NULL, CGU_ON, CGU_REG_MODULE_0,
+		CGU_USB0);
+	clkdev_add_pmu("16900000.spi", NULL, CGU_ON, CGU_REG_MODULE_0,
+		CGU_SPI1);
+	clkdev_add_pmu("16800000.spi", NULL, CGU_ON, CGU_REG_MODULE_0,
+		CGU_SPI0);
+	clkdev_add_pmu("1e700000.cbm", NULL, 0, CGU_REG_MODULE_0, CGU_CBM);
+	clkdev_add_pmu("16f00000.ebu", NULL, 0, CGU_REG_MODULE_0, CGU_EBU);
+
+	clkdev_add_pmu("16d00000.sso", NULL, CGU_ON, CGU_REG_MODULE_0,
+		CGU_LEDC);
+	/* Add dummy I2C clock */	
+	clkdev_add_pmu("16a00000.i2c", NULL, CGU_ON, CGU_REG_MODULE_0,
+		CGU_I2C);
+	clkdev_add_pmu("16b00000.gptu", NULL, CGU_ON, CGU_REG_MODULE_0,
+		CGU_GPTC0);
+	clkdev_add_pmu("16300000.gptu", NULL, CGU_ON, CGU_REG_MODULE_0,
+		CGU_GPTC1);
+	clkdev_add_pmu("16400000.gptu", NULL, CGU_ON, CGU_REG_MODULE_0,
+		CGU_GPTC2);
+	clkdev_add_pmu("16700000.serial", NULL, 0, CGU_REG_MODULE_0,
+		CGU_ASC0);
+	clkdev_add_pmu("1e100000.eip97", NULL, CGU_ON, CGU_REG_MODULE_0,
+		CGU_EIP97);
+	clkdev_add_pmu("1e000000.eip123", NULL, 0, CGU_REG_MODULE_0,
+		CGU_EIP123);
+	/* DMA3/ToE / HWCpy */
+	clkdev_add_pmu("1e300000.dma", NULL, CGU_ON, CGU_REG_MODULE_0, CGU_TOE);
+	clkdev_add_pmu("a0000000.mpe", NULL, CGU_ON, CGU_REG_MODULE_0, CGU_MPE);
+	clkdev_add_pmu("16500000.tdm", NULL, CGU_ON, CGU_REG_MODULE_0, CGU_TDM);
+	clkdev_add_pmu("1a000000.gswitch", NULL, 0, CGU_REG_MODULE_0,
+		CGU_SWITCH_R);
+	clkdev_add_pmu("1a500000.usb", NULL, CGU_ON, CGU_REG_MODULE_0,
+		CGU_USB1);
+	clkdev_add_pmu("1c000000.gswitch", NULL, 0, CGU_REG_MODULE_0,
+		CGU_SWITCH_L);
+
+	clkdev_add_pmu("18900000.pcie", "ctl", 0, CGU_REG_MODULE_1,
+		CGU_PCIE_CTRL0);
+	clkdev_add_pmu("18400000.pcie", "ctl", 0, CGU_REG_MODULE_1,
+		CGU_PCIE_CTRL1);
+	clkdev_add_pmu("18e00000.pcie", "ctl", 0, CGU_REG_MODULE_1,
+		CGU_PCIE_CTRL2);
+
+	clkdev_add_clkout0(CGU_ON);
+
+	clk = kzalloc(sizeof(struct clk), GFP_KERNEL);
+	if (clk) {
+		clk->cl.dev_id = "cpu";
+		clk->cl.con_id = "cpu";
+		clk->cl.clk = clk;
+		clk->rate = ltq_grx500_cpu_hz();
+		clk->set_rate = ltq_grx500_set_cpu_hz;
+		clk->get_rate = ltq_grx500_cpu_hz;
+		clkdev_add(&clk->cl);
+	}
+
+	clk = kzalloc(sizeof(struct clk), GFP_KERNEL);
+	if (clk) {
+		clk->cl.dev_id = "fpi";
+		clk->cl.con_id = "fpi";
+		clk->cl.clk = clk;
+		clk->rate = ltq_grx500_fpi_hz();
+		clk->set_rate = ltq_grx500_set_fpi_hz;
+		clk->get_rate = ltq_grx500_fpi_hz;
+		clkdev_add(&clk->cl);
+	}
+
+	clk = kzalloc(sizeof(struct clk), GFP_KERNEL);
+	if (clk) {
+		clk->cl.dev_id = "io";
+		clk->cl.con_id = "io";
+		clk->cl.clk = clk;
+		clk->rate = ltq_grx500_fpi_hz();
+		clk->set_rate = ltq_grx500_set_fpi_hz;
+		clk->get_rate = ltq_grx500_fpi_hz;
+		clkdev_add(&clk->cl);
+	}
+
+	clk = kzalloc(sizeof(struct clk), GFP_KERNEL);
+	if (clk) {
+		clk->cl.dev_id = "ppe";
+		clk->cl.con_id = "ppe";
+		clk->cl.clk = clk;
+		clk->rate = ltq_grx500_cbm_hz();
+		clk->set_rate = ltq_grx500_set_cbm_hz;
+		clk->get_rate = ltq_grx500_cbm_hz;
+		clkdev_add(&clk->cl);
+	}
+
+	clk = kzalloc(sizeof(struct clk), GFP_KERNEL);
+	if (clk) {
+		clk->cl.dev_id = "ddr";
+		clk->cl.con_id = "ddr";
+		clk->cl.clk = clk;
+		clk->rate = ltq_grx500_ddr_hz();
+		clk->get_rate = ltq_grx500_ddr_hz;
+		clkdev_add(&clk->cl);
+	}
+	clk = kzalloc(sizeof(struct clk), GFP_KERNEL);
+	if (clk) {
+		clk->cl.dev_id = "xbar";
+		clk->cl.con_id = "xbar";
+		clk->cl.clk = clk;
+		clk->rate = ltq_grx500_ngi_hz();
+		clk->set_rate = ltq_grx500_set_ngi_hz;
+		clk->get_rate = ltq_grx500_ngi_hz;
+		clkdev_add(&clk->cl);
+	}
+
+}
diff --git a/arch/mips/mm/cache.c b/arch/mips/mm/cache.c
--- a/arch/mips/mm/cache.c
+++ b/arch/mips/mm/cache.c
@@ -54,6 +54,7 @@ EXPORT_SYMBOL_GPL(local_flush_data_cache
 EXPORT_SYMBOL(flush_data_cache_page);
 EXPORT_SYMBOL(mips_flush_data_cache_range);
 EXPORT_SYMBOL(flush_icache_all);
+EXPORT_SYMBOL(flush_icache_range);
 
 #ifdef CONFIG_DMA_NONCOHERENT
 
