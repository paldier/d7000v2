# HG changeset patch
# Parent 0d37a82346fd1d01e0d81025f8abdd7bb887f9e1

diff --git a/arch/mips/include/asm/mach-lantiq/grx500/lantiq_ssc.h b/arch/mips/include/asm/mach-lantiq/grx500/lantiq_ssc.h
new file mode 100755
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/lantiq_ssc.h
@@ -0,0 +1,275 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2009~2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+
+#ifndef LANTIQ_SSC_H
+#define LANTIQ_SSC_H
+
+/*!
+ \defgroup IFX_SSC SSC bus driver module
+ \brief UEIP Project - SSC bus driver module, support all CPEs.
+*/
+
+/*!
+ \defgroup IFX_SSC_DEFINITIONS Definition and structions
+ \ingroup IFX_SSC
+ \brief definitions for ifx ssc driver
+*/
+
+/*!
+  \defgroup IFX_SSC_FUNCTIONS external APIs
+  \ingroup IFX_SSC
+  \brief IFX ssc external driver functions
+*/
+
+/*!
+  \defgroup IFX_SSC_INTERNAL Internal functions
+  \ingroup IFX_SSC
+  \brief IFX ssc internal driver functions
+*/
+
+/*!
+ \file ifx_ssc.h
+ \ingroup IFX_SSC
+ \brief header file for SSC bus driver external interface
+*/
+
+/*!
+ \addtogroup IFX_SSC_DEFINITIONS
+*/
+/* @{ */
+/*! \enum  IFX_SSC_PRIO_t
+    \brief Set communication priority of SSC connection
+
+    Three priority levels are defined. Low-level priority queue used for
+    applications like FLASH driver (ifx_ssc_prio_low). normal priority
+    queue used for applications like display (ifx_ssc_prio_mid).
+    High priority queue used for applications like RTP packet transfer
+    (ifx_ssc_prio_high).
+ */
+typedef enum {
+	IFX_SSC_PRIO_LOW = 0, /*!< Low Priority queue.
+				   For FLASH driver, etc. */
+	IFX_SSC_PRIO_MID,     /*!< Normal Priority queue.
+				   For LCD, display data, etc. */
+	IFX_SSC_PRIO_HIGH,    /*!< High priority queue.
+				   Ror RTP voice, etc. */
+	IFX_SSC_PRIO_ASYNC,   /*!< Tasklet priority (This is the highest
+				   supported priority) For this priority
+				   level only the asynchronous API set of
+				   the SSC driver can be called. These
+				   funtions stay unblocked and a callback
+				   function is called when the request is
+				   processed. This allows that the APIs are
+				   called from tasklet level. The callback
+				   function is always called on tasklet
+				   level */
+} IFX_SSC_PRIO_t;
+
+#define IFX_SSC_PRIO_MAX IFX_SSC_PRIO_ASYNC
+
+/*! \enum  IFX_SSC_MODE_t
+    \brief Defines the Ssc hardware mode settings supported
+
+    Because there is no official specification, what exactly SPI is and what
+    not, it is necessary to consult the data sheets of the components one
+    wants to use. Important are the permitted clock frequencies and the type
+    of valid transitions. There are no general rules for transitions where
+    data should be latched. Although not specified by Motorola, in practice
+    four modes are used. These four modes are the combinations of CPOL and
+    CPHA. In table 1, the four modes are listed.If the phase of the clock
+    is zero, i.e. CPHA = 0, data is latched at the rising edge of the clock
+    with CPOL = 0, and at the falling edge of the clock with CPOL = 1. If
+    CPHA = 1, the polarities are reversed. CPOL = 0 means falling edge,
+    CPOL = 1 rising edge.The micro controllers from Motorola allow the
+    polarity and the phase of the clock to be adjusted. A positive polarity
+    results in latching data at the rising edge of the clock. However data
+    is put on the data line already at the falling edge in order to stabilize.
+    Most peripherals which can only be slaves, work with this configuration.
+    If it should become necessary to use the other polarity, transitions are
+    reversed.
+  */
+typedef enum {
+	IFX_SSC_MODE_0 = 0, /*!< CPOL=0,CPHA=0 */
+	IFX_SSC_MODE_1, /*!< CPOL=0,CPHA=1 */
+	IFX_SSC_MODE_2, /*!< CPOL=1,CPHA=0 */
+	IFX_SSC_MODE_3, /*!< CPOL=1,CPHA=1 */
+	IFX_SSC_MODE_UNKNOWN, /*!< Unknown SPI mode */
+} IFX_SSC_MODE_t;
+
+/*! \enum  IFX_SSC_HANDL_TYPE_t
+    \brief Defines the SPI handler type supported
+ */
+typedef enum {
+	IFX_SSC_HANDL_TYPE_SYNC = 0, /*!< Only SYNC handler which be used
+					by sync application */
+	IFX_SSC_HANDL_TYPE_ASYNC, /*!< Only ASYNC handler which be used
+					by async application */
+} IFX_SSC_HANDL_TYPE_t;
+
+/*! \enum  IFX_SSC_DLX_t
+    \brief Set communication duplex mode of SSC connection
+
+    The duplex mode is used to notify SSC bus driver by SSC device driver
+    about what kind of communication mode should be used. Which duplex mode
+    will be used depends on the SSC device driver instead of SSC bus driver.
+ */
+typedef enum {
+	IFX_SSC_HALF_DUPLEX = 0,/*!< Half Duplex. Interface is used in half
+				     duplex when calling \ref ifx_sscTxRx or
+				     \ref ifx_sscAsyncTxRx. The TX path is
+				     servered before the RX path. */
+	IFX_SSC_FULL_DUPLEX,	/*!< Full Duplex. Interface is used in full
+				     duplex when calling \ref ifx_sscTxRx or
+				     \ref ifx_sscAsyncTxRx. The TX-and RX-
+				     path is servered simultaneously. */
+} IFX_SSC_DLX_t;
+
+/*!< \typedef IFX_CS_DATA
+     \brief Definition of device specific data for chip select
+ */
+typedef int IFX_CS_DATA;
+enum {
+	IFX_SSC_CS_ON = 0,	IFX_SSC_CS_OFF,
+};
+
+#define IFX_SSC_WHBGPOSTAT_OUT0_POS  0
+#define IFX_SSC_WHBGPOSTAT_OUT1_POS  1
+#define IFX_SSC_WHBGPOSTAT_OUT2_POS  2
+#define IFX_SSC_WHBGPOSTAT_OUT3_POS  3
+#define IFX_SSC_WHBGPOSTAT_OUT4_POS  4
+#define IFX_SSC_WHBGPOSTAT_OUT5_POS  5
+#define IFX_SSC_WHBGPOSTAT_OUT6_POS  6
+#define IFX_SSC_WHBGPOSTAT_OUT7_POS  7
+
+/*! \typedef IFX_SSC_CS_CB_t
+    \brief Chip Select Callback function type declaration
+
+     csq csq=0, i.e. CS low (active). csq=1, i.e.CS high (idle).
+     cs_data This is the device number in case if more than one device is using
+     the same registered driver. E.g. two VINETICs, each with it´s own CS.
+ */
+typedef int (*IFX_SSC_CS_CB_t) (u32 csq, IFX_CS_DATA cs_data);
+
+/*! typedef ifx_ssc_async_fkt_cb_t
+    \brief Callback definition for asynchronous SSC API calls. This callback is
+    called by the SSC driver on tasklet level after the request is completed or
+    exit with an error.
+
+    \param handle Funktion handle that provided for callback registration
+    during the SSC asynchronous API call.
+    \param retvalue This return value describe if the asynchronous request
+    identified an error and worked successfully.
+*/
+typedef void (*ifx_ssc_async_fkt_cb_t) (int handle, int retvalue);
+
+/*! typedef IFX_SSC_ASYNC_CALLBACK_t
+    \brief Parameter to specify the asynchronous callback. It is called
+    by the SSC tasklet after the requested transmission or locking is done.
+*/
+typedef struct {
+	ifx_ssc_async_fkt_cb_t pFunction;/*!< Callback function pointer,
+					  called in the SSC tasklet when
+					 the requested command is executed */
+	int functionHandle;	/*!< Callback function handle. This parameter
+				     is transparently given to the callback
+				     function without any modification by the
+				     SSC driver */
+} IFX_SSC_ASYNC_CALLBACK_t;
+
+/*!  \brief Parameter structure used to configure an SSC connection "ConnId".
+ */
+typedef struct {
+	IFX_SSC_MODE_t ssc_mode; /*!< Defines the hardware setup mode of
+				       the SSC */
+	IFX_SSC_PRIO_t ssc_prio; /*!< The communication priority of SSC
+				      connection. Three priority levels
+				      are defined. Low-level priority
+				      queue used for applications like
+				      FLASH driver (ifx_ssc_prio_low).
+				      Normal priority queue used for
+				      applications like display
+				      (ifx_ssc_prio_mid). High priority
+				      queue used for applications like RTP
+				      packet transfer (ifx_ssc_prio_high).
+				      The here defined SSC priority
+				      corresponds to the priority the SSC
+				      driver application and should be set
+				      just for information when the driver
+				      is registered by the application.
+				 */
+	int baudrate;		/*!< Baudrate used for the ConnId.
+				   This parameter can be later be modified
+				   by a call of ifx_sscSetBaud
+				 */
+	int fragSize;		/*!< All transmitted and received packets
+				     should be fragmented in this fragment
+				     size. Size given in Bytes. A maximum
+				     of 1024 Bytes is allowed. If the client
+				     uses a bigger values here, SSC returns
+				     with error. The client has to take care
+				     of the fragmentation
+				 */
+	int maxFIFOSize;	/*!< Maximum packet size in FIFO mode.
+				   All transmitted and received packets are
+				   transmitted in DMA mode if the packet
+				   size is greater than this value. A value
+				   of 148 is recommended at first.Size given
+				   in Bytes
+				 */
+	IFX_SSC_CS_CB_t csset_cb;	/*!< Function Callback called by SSC
+					     driver when it starts/stops to
+					     receive or transmit */
+	IFX_CS_DATA cs_data;	/*!< Parameter used for the function
+				     call of "csSet_cb". */
+	IFX_SSC_DLX_t duplex_mode;	/*!< Duplex Mode Selector. Connection
+					   used the SSC interface either in
+					   half- or full- duplex mode. */
+} IFX_SSC_CONFIGURE_t;
+
+/*! \typedef IFX_SSC_HANDLE
+    \brief Definition of the connection handle
+
+     as it is used by the client kernel module that use the SSC driver
+     Inside of the SSC driver, this handle is mapped to an internal
+     structure that contains the connection specific parameter
+     (e.g. Baudrate, Chipselect Callbacks, etc.).
+ */
+typedef void *IFX_SSC_HANDLE;
+
+/* @} */
+extern int ifx_ssc_cs_low(u32 pin);
+extern int ifx_ssc_cs_high(u32 pin);
+extern int ifx_ssc_cs_low_port0(u32 pin);
+extern int ifx_ssc_cs_high_port0(u32 pin);
+extern int ifx_ssc_cs_low_port1(u32 pin);
+extern int ifx_ssc_cs_high_port1(u32 pin);
+extern int ifx_sscLock(IFX_SSC_HANDLE handler);
+extern int ifx_sscUnlock(IFX_SSC_HANDLE handler);
+extern int ifx_sscSetBaud(IFX_SSC_HANDLE handler, unsigned int baud);
+extern int ifx_sscTxRx(IFX_SSC_HANDLE handler, char *tx_buf, u32 tx_len,
+			char *rx_buf, u32 rx_len);
+extern int ifx_sscRx(IFX_SSC_HANDLE handler, char *rx_buf, u32 rx_len);
+extern int ifx_sscTx(IFX_SSC_HANDLE handler, char *tx_buf, u32 tx_len);
+extern IFX_SSC_HANDLE ifx_sscAllocConnection(char *dev_name,
+					      IFX_SSC_CONFIGURE_t *connid);
+extern int ifx_sscFreeConnection(IFX_SSC_HANDLE handler);
+extern int ifx_sscAsyncTxRx(IFX_SSC_HANDLE handler,
+			     IFX_SSC_ASYNC_CALLBACK_t *pCallback,
+			      char *txbuf, int txsize, char *rxbuf, int rxsize);
+extern int ifx_sscAsyncTx(IFX_SSC_HANDLE handler,
+			   IFX_SSC_ASYNC_CALLBACK_t *pCallback,
+			    char *txbuf, int txsize);
+extern int ifx_sscAsyncRx(IFX_SSC_HANDLE handler,
+			   IFX_SSC_ASYNC_CALLBACK_t *pCallback,
+			    char *rxbuf, int rxsize);
+extern int ifx_sscAsyncLock(IFX_SSC_HANDLE handler,
+			     IFX_SSC_ASYNC_CALLBACK_t *pCallback);
+extern int ifx_sscAsyncUnLock(IFX_SSC_HANDLE handler);
+
+#endif /* LANTIQ_SSC_H */
+
diff --git a/drivers/spi/ltq_ssc.c b/drivers/spi/ltq_ssc.c
--- a/drivers/spi/ltq_ssc.c
+++ b/drivers/spi/ltq_ssc.c
@@ -29,6 +29,13 @@
 #include <linux/clk.h>
 #include <linux/of.h>
 #include <linux/seq_file.h>
+#include <linux/klogging.h>
+#ifdef CONFIG_SOC_GRX500
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#endif
 
 #include <lantiq.h>
 #include <lantiq_soc.h>
@@ -36,6 +43,19 @@
 #include <lantiq_ssc.h>
 #include "ltq_ssc.h"
 
+/*
+* !<WW: Due to no response from test image, this fix
+* shall be categorized as experimental
+* JIRA: UGW_SW-8578
+* JIRA: UGW_SW-8090
+*/
+#define EXPERIMENTAL_FIX
+
+#if 0
+#undef LTQ_DMA_SUPPORT
+#else
+#define  LTQ_DMA_SUPPORT
+#endif
 #define IFX_SSC_VER_MAJOR          2
 #define IFX_SSC_VER_MID            5
 #define IFX_SSC_VER_MINOR          2
@@ -82,16 +102,61 @@ static void ifx_ssc_debug(struct ifx_ssc
 	}                              \
 } while (0)
 #define IFX_SSC_NAME             "ltq_ssc"
-
+#if 1
+static u32 global_val;
+struct device_port_mapping {
+	char dev_name[IFX_SSC_MAX_DEVNAME];
+	int port;
+};
+static struct device_port_mapping port_map[IFX_SSC_MAX_MAPPING] = {
+	{.dev_name = "ltq_sflash", .port = 0},
+#ifdef CONFIG_SOC_GRX500
+	{.dev_name = "ltq_nand", .port = 1},
+	{.dev_name = "dect_drv", .port = 1},
+	{.dev_name = "", .port = -1},
+#else
+	{.dev_name = "dect_drv", .port = 0},
+	{.dev_name = "", .port = -1},
+#endif
+};
+#endif
 /**
  * This is the per-channel data structure containing pointers, flags
  * and variables for the port.  ifx_ssc_isp is allocated in ifx_ssc_init()
  * based on the chip version.
  */
-static struct ifx_ssc_port *ifx_ssc_isp;
+static struct ifx_ssc_port *ifx_ssc_isp[IFX_SSC_MAX_PORT_NUM];
 
 static struct proc_dir_entry *ifx_ssc_proc;
 
+#ifdef CONFIG_SOC_GRX500
+static u32 legacy_cs_port_num = -1;
+#endif /* CONFIG_SOC_GRX500 */
+
+static int find_port(char *dev_name, int *port)
+{
+	int i;
+	*port = -1;
+
+	if (!dev_name) {
+		LOGF_KLOG_ERROR("dev_name is NULL \r\n");
+		return ENODEV;
+	}
+
+	for (i = 0; i < IFX_SSC_MAX_MAPPING; i++) {
+		if (port_map[i].port == -1)
+			break;
+		if (!strcmp(dev_name, port_map[i].dev_name)) {
+			*port = port_map[i].port;
+			break;
+		}
+	}
+	if (*port == -1) {
+		LOGF_KLOG_ERROR("device not found \r\n");
+		return ENODEV;
+	} else
+		return 0;
+}
 /**
  * \fn static void  ifx_ssc_start_tasklet(struct ifx_ssc_port *port)
  * \brief Trigger different schedule procedures according to different context.
@@ -158,7 +223,7 @@ static void ifx_ssc_debug(struct ifx_ssc
 	vsnprintf(buf, sizeof(buf), fmt, ap);
 	va_end(ap);
 
-	pr_info("%s %s: %s\n", p, port->name, buf);
+	LOGF_KLOG_INFO("%s %s: %s\n", p, port->name, buf);
 }
 #endif /* CONFIG_LANTIQ_SPI_DEBUG */
 
@@ -199,7 +264,7 @@ ifx_ssc_get_kernel_clk(struct ifx_ssc_po
 
 	rmc = IFX_SSC_GET_CLC_RMC(port);
 	if (rmc == 0) {
-		pr_err("%s rmc==0\n", __func__);
+		LOGF_KLOG_ERROR("%s rmc==0\n", __func__);
 		return 0;
 	}
 	return clk_get_rate(port->fpiclk) / rmc;
@@ -229,7 +294,10 @@ static int ifx_ssc_stats_proc(struct seq
 	seq_puts(s,
 		"Statistics for Lantiq Synchronous Serial Controller(SSC)\n\n");
 	for (t = 0; t < IFX_SSC_MAX_PORT_NUM; t++) {
-		port = &ifx_ssc_isp[t];
+		port = ifx_ssc_isp[t];
+
+		if (!port)
+			continue;
 
 		stats = &port->stats;
 
@@ -312,7 +380,9 @@ static int ifx_ssc_reg_read_proc(struct 
 	seq_puts(s,
 		"Register Dump for Lantiq Synchronous Serial Controller(SSC)\n\n");
 	for (t = 0; t < IFX_SSC_MAX_PORT_NUM; t++) {
-		port = &ifx_ssc_isp[t];
+		port = ifx_ssc_isp[t];
+		if (!port)
+			continue;
 		IFX_SSC_IRQ_LOCK(port);
 		stats[0] = IFX_SSC_GET_CLC(port);
 		stats[1] = IFX_SSC_GET_ID(port);
@@ -370,7 +440,6 @@ static const struct file_operations ifx_
 	.llseek         = seq_lseek,
 	.release        = single_release,
 };
-
 /**
  * \fn static void ifx_ssc_dma_setup(struct ifx_ssc_port *port, int dir, int enabled)
  * \brief Setup dma direction and enable/disable
@@ -409,6 +478,7 @@ ifx_ssc_dma_setup(struct ifx_ssc_port *p
 	IFX_SSC_IRQ_UNLOCK(port);
 }
 
+#ifdef LTQ_DMA_SUPPORT
 /**
  * \fn static INLINE void ifx_ssc_dma_irq_finished(struct ifx_ssc_port *port)
  * \brief DMA<TX/RX> interrupt received, this function calls to reschedule or
@@ -526,7 +596,7 @@ ifx_ssc_dma_int_handler(struct dma_devic
 		break;
 
 	default:
-		pr_err("%s unknow interrupt %d\n", __func__,
+		LOGF_KLOG_ERROR("%s unknow interrupt %d\n", __func__,
 			status);
 		break;
 	}
@@ -584,7 +654,7 @@ ifx_ssc_init_dma_device(int line, struct
 {
 	int i;
 
-	dma_dev->priv = &ifx_ssc_isp[line];
+	dma_dev->priv = ifx_ssc_isp[line];
 	dma_dev->num_tx_chan = DEFAULT_SSC_TX_CHANNEL_NUM;
 	dma_dev->num_rx_chan = DEFAULT_SSC_RX_CHANNEL_NUM;
 	dma_dev->tx_burst_len = DEFAULT_SSC_TX_BURST_LEN;
@@ -619,7 +689,7 @@ ifx_ssc_init_dma_device(int line, struct
 	dma_device_register(dma_dev);
 	return 0;
 }
-
+#endif
 /**
  * \fn static INLINE int ifx_ssc_rxtx_mode_set(struct ifx_ssc_port *port,
  *                                             unsigned int val)
@@ -643,11 +713,11 @@ ifx_ssc_rxtx_mode_set(struct ifx_ssc_por
 
 	/* check BUSY and RXCNT */
 	if ((IFX_SSC_GET_STATE(port) & IFX_SSC_STATE_BUSY)) {
-		pr_err("%s state busy\n", __func__);
+		LOGF_KLOG_ERROR("%s state busy\n", __func__);
 		return -EBUSY;
 	}
 	if (IFX_SSC_RX_TO_RECEIVED(port)) {
-		pr_err("%s rx todo busy\n", __func__);
+		LOGF_KLOG_ERROR("%s rx todo busy\n", __func__);
 		return -EBUSY;
 	}
 	IFX_SSC_IRQ_LOCK(port);
@@ -681,7 +751,7 @@ static int ifx_ssc_sethwopts(struct ifx_
 	/* sanity checks */
 	if ((opts->dataWidth < IFX_SSC_MIN_DATA_WIDTH) ||
 	    (opts->dataWidth > IFX_SSC_MAX_DATA_WIDTH)) {
-		pr_err("%s: sanity check failed\n", __func__);
+		LOGF_KLOG_ERROR("%s: sanity check failed\n", __func__);
 		return -EINVAL;
 	}
 	bits = IFX_SSC_ENCODE_DATA_WIDTH(opts->dataWidth);
@@ -755,7 +825,14 @@ int ifx_ssc_cs_low(u32 pin)
 	int ret;
 	u32 reg;
 
-	struct ifx_ssc_port *port = &ifx_ssc_isp[0]; /* XXX */
+
+	struct ifx_ssc_port *port = ifx_ssc_isp[0]; /* XXX */
+
+	#ifdef CONFIG_SOC_GRX500
+	if ( -1  != legacy_cs_port_num &&
+		NULL != ifx_ssc_isp[legacy_cs_port_num] )
+		port  = ifx_ssc_isp[legacy_cs_port_num];
+	#endif /* CONFIG_SOC_GRX500 */
 
 	if (pin > IFX_SSC_MAX_GPO_OUT)
 		ret = -EINVAL;
@@ -786,7 +863,13 @@ int ifx_ssc_cs_high(u32 pin)
 	int ret;
 	u32 reg;
 
-	struct ifx_ssc_port *port = &ifx_ssc_isp[0];/* XXX */
+	struct ifx_ssc_port *port = ifx_ssc_isp[0]; /* XXX */
+
+	#ifdef CONFIG_SOC_GRX500
+	if ( -1  != legacy_cs_port_num &&
+		NULL != ifx_ssc_isp[legacy_cs_port_num] )
+		port  = ifx_ssc_isp[legacy_cs_port_num];
+	#endif /* CONFIG_SOC_GRX500 */
 
 	if (pin > IFX_SSC_MAX_GPO_OUT)
 		ret = -EINVAL;
@@ -805,6 +888,140 @@ int ifx_ssc_cs_high(u32 pin)
 EXPORT_SYMBOL(ifx_ssc_cs_high);
 
 /**
+ * \fn int ifx_ssc_cs_low_port0(u32 pin)
+ * \brief Chip select enable.
+ * This function sets the given chip select for SSC0 to low.
+ *
+ * \param   pin      Selected CS pin
+ * \return  0        OK
+ * \return  -EINVAL  Invalid GPIO pin provided
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int ifx_ssc_cs_low_port0(u32 pin)
+{
+	int ret;
+	u32 reg;
+
+	struct ifx_ssc_port *port = ifx_ssc_isp[0]; /* XXX */
+	if (pin > IFX_SSC_MAX_GPO_OUT)
+		ret = -EINVAL;
+	else {
+		reg = (1 << (pin + IFX_SSC_WHBGPOSTAT_CLROUT0_POS));
+		IFX_SSC_IRQ_LOCK(port);
+		IFX_SSC_SET_FGPO(reg, port);
+		IFX_SSC_IRQ_UNLOCK(port);
+		smp_wmb();
+		ret = 0;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(ifx_ssc_cs_low_port0);
+
+/**
+ * \fn int ifx_ssc_cs_high_port0(u32 pin)
+ * \brief Chip select disable.
+ * This function sets the given chip select for SSC0 to high.
+ *
+ * \param   pin      Selected CS pin
+ * \return  0        OK
+ * \return  -EINVAL  Invalid GPIO pin provided
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int ifx_ssc_cs_high_port0(u32 pin)
+{
+	int ret;
+	u32 reg;
+
+	struct ifx_ssc_port *port = ifx_ssc_isp[0]; /* XXX */
+	if (pin > IFX_SSC_MAX_GPO_OUT)
+		ret = -EINVAL;
+	else {
+		/* XXX, at least half of cycle of baudrate delay is needed */
+		udelay(1);
+		reg = 1 << (pin + IFX_SSC_WHBGPOSTAT_SETOUT0_POS);
+		IFX_SSC_IRQ_LOCK(port);
+		IFX_SSC_SET_FGPO(reg, port);
+		IFX_SSC_IRQ_UNLOCK(port);
+		smp_wmb();
+		ret = 0;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(ifx_ssc_cs_high_port0);
+
+
+/**
+ * \fn int ifx_ssc_cs_low_port1(u32 pin)
+ * \brief Chip select enable.
+ * This function sets the given chip select for SSC0 to low.
+ *
+ * \param   pin      Selected CS pin
+ * \return  0        OK
+ * \return  -EINVAL  Invalid GPIO pin provided
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int ifx_ssc_cs_low_port1(u32 pin)
+{
+	int ret;
+	u32 reg;
+	struct ifx_ssc_port *port = ifx_ssc_isp[1]; /* XXX */
+	#if 0
+	int port_num = (pin + 1) / IFX_SSC_MAX_GPO_OUT;
+	pin = (pin > IFX_SSC_MAX_GPO_OUT) ? (pin - IFX_SSC_MAX_GPO_OUT-1) : pin;
+	struct ifx_ssc_port *port = ifx_ssc_isp[port_num]; /* XXX */
+	#endif
+
+	if (pin > IFX_SSC_MAX_GPO_OUT)
+		ret = -EINVAL;
+	else {
+		reg = (1 << (pin + IFX_SSC_WHBGPOSTAT_CLROUT0_POS));
+		IFX_SSC_IRQ_LOCK(port);
+		IFX_SSC_SET_FGPO(reg, port);
+		IFX_SSC_IRQ_UNLOCK(port);
+		smp_wmb();
+		ret = 0;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(ifx_ssc_cs_low_port1);
+
+/**
+ * \fn int ifx_ssc_cs_high_port1(u32 pin)
+ * \brief Chip select disable.
+ * This function sets the given chip select for SSC0 to high.
+ *
+ * \param   pin      Selected CS pin
+ * \return  0        OK
+ * \return  -EINVAL  Invalid GPIO pin provided
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int ifx_ssc_cs_high_port1(u32 pin)
+{
+	int ret;
+	u32 reg;
+	struct ifx_ssc_port *port = ifx_ssc_isp[1]; /* XXX */
+	#if 0
+	int port_num = (pin + 1) / IFX_SSC_MAX_GPO_OUT;
+	pin = (pin > IFX_SSC_MAX_GPO_OUT) ? (pin - IFX_SSC_MAX_GPO_OUT-1) : pin;
+	struct ifx_ssc_port *port = ifx_ssc_isp[port_num]; /* XXX */
+	#endif
+	if ((pin) > IFX_SSC_MAX_GPO_OUT)
+		ret = -EINVAL;
+	else {
+		/* XXX, at least half of cycle of baudrate delay is needed */
+		udelay(1);
+		reg = 1 << (pin + IFX_SSC_WHBGPOSTAT_SETOUT0_POS);
+		IFX_SSC_IRQ_LOCK(port);
+		IFX_SSC_SET_FGPO(reg, port);
+		IFX_SSC_IRQ_UNLOCK(port);
+		smp_wmb();
+		ret = 0;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(ifx_ssc_cs_high_port1);
+
+/**
  * \fn static int ifx_ssc_set_baudrate (struct ifx_ssc_port *port,
  *                                      unsigned int baudrate)
  * \brief SSC set baudrate.
@@ -840,6 +1057,7 @@ ifx_ssc_set_baudrate(struct ifx_ssc_port
 	if ((port->prev_baudrate == baudrate)
 	    && (port->prev_ssc_clk == ifx_ssc_clock))
 		return 0;
+#if 0
 	if (of_machine_is_compatible("lantiq,vr9")) {
 		if (ltq_get_soc_type() == SOC_TYPE_VR9_2) {
 			/* VR9 A21 high baudrate support */
@@ -859,13 +1077,13 @@ ifx_ssc_set_baudrate(struct ifx_ssc_port
 			IFX_SSC_IRQ_UNLOCK(port);
 		}
 	}
-
+#endif
 	/* Compute divider */
 	br = (((ifx_ssc_clock >> 1) + baudrate / 2) / baudrate) - 1;
 	if (br > 0xffff || ((br == 0) &&
 		(IFX_SSC_GET_STATE(port) &
 		IFX_SSC_STATE_MASTER))) {
-		pr_err("%s: illegal baudrate %u br %d\n",
+		LOGF_KLOG_ERROR("%s: illegal baudrate %u br %d\n",
 			__func__, baudrate, br);
 		return -EINVAL;
 	}
@@ -879,7 +1097,8 @@ ifx_ssc_set_baudrate(struct ifx_ssc_port
 	IFX_SSC_SET_BR(br, port);
 	smp_wmb();
 	if (of_machine_is_compatible("lantiq,ar10")
-		|| of_machine_is_compatible("lantiq,grx390")) {
+		|| of_machine_is_compatible("lantiq,grx390")
+		|| of_machine_is_compatible("lantiq,grx500")) {
 		u32 reg;
 
 		if (baudrate > IFX_SSC_SPLIT_BAUD_RATE) {
@@ -926,12 +1145,12 @@ static int ifx_ssc_hwinit(struct ifx_ssc
 
 	IFX_SSC_CONFIG_MODE(port);
 	if (ifx_ssc_sethwopts(port) < 0) {
-		pr_err("%s: setting the hardware options failed\n", __func__);
+		LOGF_KLOG_ERROR("%s: setting the hardware options failed\n", __func__);
 		return -EINVAL;
 	}
 
 	if (ifx_ssc_set_baudrate(port, port->baudrate) < 0) {
-		pr_err("%s: setting the baud rate failed\n", __func__);
+		LOGF_KLOG_ERROR("%s: setting the baud rate failed\n", __func__);
 		return -EINVAL;
 	}
 	IFX_SSC_IRQ_LOCK(port);
@@ -1053,7 +1272,6 @@ ifx_ssc_start_txfifo(struct ifx_ssc_port
 	u32 tx_cnt;
 	u32 *ptxbuf;
 	int total = txsize;
-
 	ifx_ssc_dma_setup(port, IFX_SSC_DIR_TX, IFX_SSC_DMA_DISABLE);
 	IFX_SSC_IRQ_LOCK(port);
 	while (1) {
@@ -1351,7 +1569,7 @@ static INLINE int ifx_ssc_set_spi_mode(s
 
 	if ((IFX_SSC_GET_STATE(port) & IFX_SSC_STATE_BUSY)
 		|| IFX_SSC_RX_TO_RECEIVED(port) > 0) {
-		pr_err("%s failed to set spi mode\n", __func__);
+		LOGF_KLOG_ERROR("%s failed to set spi mode\n", __func__);
 		return -EBUSY;
 	}
 	switch (ssc_cfg->ssc_mode) {
@@ -1509,7 +1727,7 @@ static void ifx_ssc_cs_lock(ssc_device_t
 
 	port = dev->port;
 	if (port->ssc_cs_locked == true) {
-		pr_err("Fatal error: %s locked already before\n", __func__);
+		LOGF_KLOG_ERROR("Fatal error: %s locked already before\n", __func__);
 		return;
 	}
 	IFX_SSC_PRINT(port, SSC_MSG_LOCK, "%s %s enter\n", __func__,
@@ -1539,7 +1757,7 @@ static INLINE void ifx_ssc_cs_unlock(ssc
 
 	port = dev->port;
 	if (port->ssc_cs_locked == false) {
-		pr_err("Fatal error: %s unlocked already before\n", __func__);
+		LOGF_KLOG_ERROR("Fatal error: %s unlocked already before\n", __func__);
 		return;
 	}
 	ssc_cfg = &dev->conn_id;
@@ -1714,6 +1932,7 @@ int ifx_sscSetBaud(IFX_SSC_HANDLE handle
 }
 EXPORT_SYMBOL(ifx_sscSetBaud);
 
+#ifdef LTQ_DMA_SUPPORT
 /**
  * \fn static int ifx_ssc_txdma(struct ifx_ssc_port *port, char *txbuf,
  *     int txsize)
@@ -1807,7 +2026,7 @@ ifx_ssc_dma_fdx(struct ifx_ssc_port *por
 	 */
 	if (((rxsize & ((dma_dev->rx_burst_len << 2) - 1)) != 0) ||
 	    ((txsize & ((dma_dev->tx_burst_len << 2) - 1)) != 0)) {
-		pr_err("%s data length is not a multiple of DMA burst length %d\n",
+		LOGF_KLOG_ERROR("%s data length is not a multiple of DMA burst length %d\n",
 			__func__, rxsize);
 		return -EINVAL;
 	}
@@ -1934,7 +2153,7 @@ ifx_ssc_rxdma(struct ifx_ssc_port *port,
 
 	return rxsize;
 }
-
+#endif
 /**
  *\fn int ifx_sscTxRx (IFX_SSC_HANDLE handler, char *txbuf, u32 txsize,
  *                     char *rxbuf, u32 rxsize)
@@ -1980,7 +2199,7 @@ ifx_sscTxRx(IFX_SSC_HANDLE handler, char
 
 	if (in_interrupt()) {
 		stats->context_err++;
-		pr_err("%s can't be called in interupt context < irq, softirq, tasklet>\n",
+		LOGF_KLOG_ERROR("%s can't be called in interupt context < irq, softirq, tasklet>\n",
 			__func__);
 		return 0;
 	}
@@ -1989,7 +2208,7 @@ ifx_sscTxRx(IFX_SSC_HANDLE handler, char
 
 	if (txsize > ssc_cfg->fragSize || rxsize > ssc_cfg->fragSize) {
 		stats->frag_err++;
-		pr_err("%s Device driver must do its own fragmentation tx %d rx %d > %d\n",
+		LOGF_KLOG_ERROR("%s Device driver must do its own fragmentation tx %d rx %d > %d\n",
 			__func__, txsize, rxsize, ssc_cfg->fragSize);
 		return 0;
 	}
@@ -1999,7 +2218,7 @@ ifx_sscTxRx(IFX_SSC_HANDLE handler, char
 		if (ssc_cfg->duplex_mode == IFX_SSC_FULL_DUPLEX) {
 			if (txsize != rxsize) {
 				stats->dlx_err++;
-				pr_err("%s full duplex required TX/RX has the same amount of data tx %d rx %d\n",
+				LOGF_KLOG_ERROR("%s full duplex required TX/RX has the same amount of data tx %d rx %d\n",
 					__func__, txsize, rxsize);
 				return 0;
 			}
@@ -2013,7 +2232,7 @@ ifx_sscTxRx(IFX_SSC_HANDLE handler, char
 	 */
 	if (pqueue->handle_type != IFX_SSC_HANDL_TYPE_SYNC) {
 		stats->handler_err++;
-		pr_err("%s must use sync handler\n", __func__);
+		LOGF_KLOG_ERROR("%s must use sync handler\n", __func__);
 		return 0;
 	}
 
@@ -2192,6 +2411,32 @@ static int ifx_ssc_serve_qentry(struct i
 	ssc_cfg = &dev->conn_id;
 	dma_dev = port->dma_dev;
 
+	#ifdef EXPERIMENTAL_FIX
+	/* suspect the tasklet still run after the dect driver is freed */
+	/* check if queue->dev still exist on port->ssc_devs */
+	/* if it doesn't, print out a warning ... and safely return */
+	if (port->ssc_ndevs > 0) {
+		ssc_device_t *q, *next;
+		unsigned int found = 0;
+
+		IFX_SSC_SEM_LOCK(port->dev_sem);
+		TAILQ_FOREACH_SAFE(q, &port->ssc_devq, dev_entry, next) {
+			if (q == dev)
+				found = 1;
+		}
+		IFX_SSC_SEM_UNLOCK(port->dev_sem);
+
+		if (!found) {
+			IFX_SSC_PRINT(port, SSC_MSG_ERROR, "[%s] NO MATCHING DRIVER!!! INVALID QUEUE\n", __func__);
+			return 0;
+		}
+	}
+	else {
+		IFX_SSC_PRINT(port, SSC_MSG_ERROR, "[%s] EMPTY REGISTERED DRIVER FOR PORT!!! INVALID QUEUE!!\n", __func__);
+		return 0;
+	}
+	#endif /* EXPERIMENTAL_FIX */
+
 	if ((ssc_cfg->duplex_mode == IFX_SSC_FULL_DUPLEX)
 		&& (qentry->txbuf != NULL)
 		&& (qentry->rxbuf != NULL)) {
@@ -2204,6 +2449,7 @@ static int ifx_ssc_serve_qentry(struct i
 		ifx_ssc_txrx_setup(port);
 
 		if (port->dma_support) {
+#ifdef LTQ_DMA_SUPPORT
 			int tx_dma_aligned = ((((u32) qentry->txbuf) &
 			 ((dma_dev->tx_burst_len << 2) - 1)) == 0) ? 1 : 0;
 			int rx_dma_aligned = ((((u32) qentry->rxbuf) &
@@ -2245,6 +2491,8 @@ static int ifx_ssc_serve_qentry(struct i
 				return 0;
 			}  else
 				goto fdxfifo;
+
+#endif
 		} else {
 fdxfifo:
 			ifx_ssc_txrx_fifo_fdx(port, qentry->txbuf,
@@ -2282,6 +2530,7 @@ fdxfifo:
 		/* If buffer not aligned on DMA burst length,
 		 * fall back to FIFO */
 		if (port->dma_support) {
+#ifdef LTQ_DMA_SUPPORT
 			int tx_dma_aligned = ((((u32) qentry->txbuf)&
 			((dma_dev->tx_burst_len << 2) - 1)) == 0) ? 1 : 0;
 
@@ -2307,6 +2556,7 @@ fdxfifo:
 				return 0;
 			} else
 				goto txfifo;
+#endif
 		} else {
 txfifo:
 			ifx_ssc_tx_setup(port);
@@ -2339,6 +2589,7 @@ txfifo:
 		/* If buffer not aligned on DMA burst length,
 		 * fall back to FIFO */
 		if (port->dma_support) {
+#ifdef LTQ_DMA_SUPPORT
 			int rx_dma_aligned = ((((u32) qentry->rxbuf) &
 			 ((dma_dev->rx_burst_len << 2) - 1)) == 0) ? 1 : 0;
 
@@ -2368,6 +2619,7 @@ txfifo:
 				return 0;
 			} else
 				goto rxfifo;
+#endif
 		} else {
 rxfifo:
 			ifx_ssc_rx_setup(port);
@@ -2658,7 +2910,7 @@ ifx_sscAsyncTxRx(IFX_SSC_HANDLE handler,
 
 	if (!in_interrupt()) {
 		stats->context_err++;
-		pr_err("%s must be called in interrupt context <irq, softirq, tasklet>\n",
+		LOGF_KLOG_ERROR("%s must be called in interrupt context <irq, softirq, tasklet>\n",
 			__func__);
 		return -1;
 	}
@@ -2668,7 +2920,7 @@ ifx_sscAsyncTxRx(IFX_SSC_HANDLE handler,
 
 	if (txsize > ssc_cfg->fragSize || rxsize > ssc_cfg->fragSize) {
 		stats->frag_err++;
-		pr_err("%s Device driver must do its own fragmentation tx %d rx %d > %d\n",
+		LOGF_KLOG_ERROR("%s Device driver must do its own fragmentation tx %d rx %d > %d\n",
 			__func__, txsize, rxsize, ssc_cfg->fragSize);
 		return -1;
 	}
@@ -2677,7 +2929,7 @@ ifx_sscAsyncTxRx(IFX_SSC_HANDLE handler,
 		if (ssc_cfg->duplex_mode == IFX_SSC_FULL_DUPLEX) {
 			if (txsize != rxsize) {
 				stats->dlx_err++;
-				pr_err("%s full duplex required TX/RX has the same amount of data tx %d rx %d\n",
+				LOGF_KLOG_ERROR("%s full duplex required TX/RX has the same amount of data tx %d rx %d\n",
 					__func__, txsize, rxsize);
 				return -1;
 			}
@@ -2691,7 +2943,7 @@ ifx_sscAsyncTxRx(IFX_SSC_HANDLE handler,
 	 */
 	if (pqueue->handle_type != IFX_SSC_HANDL_TYPE_ASYNC) {
 		stats->handler_err++;
-		pr_err("%s must use async handler\n", __func__);
+		LOGF_KLOG_ERROR("%s must use async handler\n", __func__);
 		return -1;
 	}
 
@@ -2953,35 +3205,32 @@ SSC_SYSCTL_DECL(ssc_sysctl_private, ctl,
 	ssc_device_t *dev = ctl->extra1;
 	IFX_SSC_CONFIGURE_t *ssc_cfg = &dev->conn_id;
 	struct ifx_ssc_port *port;
-	u32 val;
 	int ret;
 
 	port = dev->port;
-	ctl->data = &val;
-	ctl->maxlen = sizeof(val);
 	if (write) {
 		ret = SSC_SYSCTL_PROC_DOINTVEC(ctl, write, filp, buffer,
 				lenp, ppos);
 		if (ret == 0) {
 			switch ((long) ctl->extra2) {
 			case IFX_SSC_PRIV_FRAGMENT_SIZE:
-				if (val < IFX_SSC_MIN_FRAGSIZE
-				    || val > IFX_SSC_MAX_FRAGSIZE)
+				if (global_val < IFX_SSC_MIN_FRAGSIZE
+				    || global_val > IFX_SSC_MAX_FRAGSIZE)
 					return -EINVAL;
-				ssc_cfg->fragSize = val;
-				port->ssc_fragSize = val;
+				ssc_cfg->fragSize = global_val;
+				port->ssc_fragSize = global_val;
 				break;
 
 			case IFX_SSC_PRIV_FIFO_SIZE:
-				if (val < IFX_SSC_FIFO_MIN_THRESHOULD
-				    || val > IFX_SSC_FIFO_MAX_THRESHOULD)
+				if (global_val < IFX_SSC_FIFO_MIN_THRESHOULD
+				    || global_val > IFX_SSC_FIFO_MAX_THRESHOULD)
 					return -EINVAL;
-				ssc_cfg->maxFIFOSize = val;
+				ssc_cfg->maxFIFOSize = global_val;
 				break;
 
 			case IFX_SSC_PRIV_BAUDRATE:
 				/* XXX, sanity check */
-				ssc_cfg->baudrate = val;
+				ssc_cfg->baudrate = global_val;
 				break;
 
 			case IFX_SSC_PRIV_MODE:
@@ -2995,19 +3244,19 @@ SSC_SYSCTL_DECL(ssc_sysctl_private, ctl,
 	} else {
 		switch ((long) ctl->extra2) {
 		case IFX_SSC_PRIV_FRAGMENT_SIZE:
-			val = ssc_cfg->fragSize;
+			global_val = ssc_cfg->fragSize;
 			break;
 
 		case IFX_SSC_PRIV_FIFO_SIZE:
-			val = ssc_cfg->maxFIFOSize;
+			global_val = ssc_cfg->maxFIFOSize;
 			break;
 
 		case IFX_SSC_PRIV_BAUDRATE:
-			val = ssc_cfg->baudrate;
+			global_val = ssc_cfg->baudrate;
 			break;
 
 		case IFX_SSC_PRIV_MODE:
-			val = ssc_cfg->ssc_mode;
+			global_val = ssc_cfg->ssc_mode;
 			break;
 
 		default:
@@ -3024,24 +3273,32 @@ static const ctl_table ssc_sysctl_templa
 	{IFX_INIT_CTL_NAME(CTL_AUTO)
 	 .procname = "fragment_size",
 	 .mode = 0644,
+	 .data = &global_val,
+	 .maxlen = sizeof(global_val),
 	 .proc_handler = ssc_sysctl_private,
 	 .extra2 = (void *) IFX_SSC_PRIV_FRAGMENT_SIZE,
 	 },
 	{IFX_INIT_CTL_NAME(CTL_AUTO)
 	 .procname = "fifosize",
 	 .mode = 0644,
+	 .data = &global_val,
+	 .maxlen = sizeof(global_val),
 	 .proc_handler = ssc_sysctl_private,
 	 .extra2 = (void *) IFX_SSC_PRIV_FIFO_SIZE,
 	 },
 	{IFX_INIT_CTL_NAME(CTL_AUTO)
 	 .procname = "baudrate",
 	 .mode = 0644,
+	 .data = &global_val,
+	 .maxlen = sizeof(global_val),
 	 .proc_handler = ssc_sysctl_private,
 	 .extra2 = (void *) IFX_SSC_PRIV_BAUDRATE,
 	 },
 	{IFX_INIT_CTL_NAME(CTL_AUTO)
 	 .procname = "spimode",
 	 .mode = 0644,
+	 .data = &global_val,
+	 .maxlen = sizeof(global_val),
 	 .proc_handler = ssc_sysctl_private,
 	 .extra2 = (void *) IFX_SSC_PRIV_MODE,
 	 },
@@ -3055,7 +3312,7 @@ static void ifx_ssc_sysctl_attach(ssc_de
 	space = 5 * sizeof(struct ctl_table) + sizeof(ssc_sysctl_template);
 	dev->ssc_sysctls = kmalloc(space, GFP_KERNEL);
 	if (dev->ssc_sysctls == NULL) {
-		pr_err("%s: no memory for sysctl table!\n", __func__);
+		LOGF_KLOG_ERROR("%s: no memory for sysctl table!\n", __func__);
 		return;
 	}
 
@@ -3088,7 +3345,7 @@ static void ifx_ssc_sysctl_attach(ssc_de
 	dev->ssc_sysctl_header =
 		IFX_REGISTER_SYSCTL_TABLE(dev->ssc_sysctls);
 	if (dev->ssc_sysctl_header == NULL) {
-		pr_err("%s: failed to register sysctls!\n", dev->dev_name);
+		LOGF_KLOG_ERROR("%s: failed to register sysctls!\n", dev->dev_name);
 		kfree(dev->ssc_sysctls);
 		dev->ssc_sysctls = NULL;
 	}
@@ -3115,18 +3372,15 @@ static int
 SSC_SYSCTL_DECL(port_sysctl_private, ctl, write, filp, buffer, lenp, ppos)
 {
 	struct ifx_ssc_port *port = ctl->extra1;
-	u32 val;
 	int ret;
 
-	ctl->data = &val;
-	ctl->maxlen = sizeof(val);
 	if (write) {
 		ret = SSC_SYSCTL_PROC_DOINTVEC(ctl, write, filp, buffer,
 					lenp, ppos);
 		if (ret == 0) {
 			switch ((long) ctl->extra2) {
 			case IFX_SSC_PRIV_DEBUG:
-				port->ssc_debug = val;
+				port->ssc_debug = global_val;
 				break;
 
 			default:
@@ -3136,7 +3390,7 @@ SSC_SYSCTL_DECL(port_sysctl_private, ctl
 	} else {
 		switch ((long) ctl->extra2) {
 		case IFX_SSC_PRIV_DEBUG:
-			val = port->ssc_debug;
+			global_val = port->ssc_debug;
 			break;
 
 		default:
@@ -3167,7 +3421,7 @@ static void ifx_ssc_port_sysctl_attach(s
 		sizeof(port_sysctl_template);
 	port->port_sysctls = kmalloc(space, GFP_KERNEL);
 	if (port->port_sysctls == NULL) {
-		pr_err("%s: no memory for sysctl table!\n", __func__);
+		LOGF_KLOG_ERROR("%s: no memory for sysctl table!\n", __func__);
 		return;
 	}
 
@@ -3200,7 +3454,7 @@ static void ifx_ssc_port_sysctl_attach(s
 	port->port_sysctl_header =
 		IFX_REGISTER_SYSCTL_TABLE(port->port_sysctls);
 	if (port->port_sysctl_header == NULL) {
-		pr_err("%s: failed to register sysctls!\n", port->name);
+		LOGF_KLOG_ERROR("%s: failed to register sysctls!\n", port->name);
 		kfree(port->port_sysctls);
 		port->port_sysctls = NULL;
 	}
@@ -3246,15 +3500,19 @@ ifx_sscAllocConnection(char *dev_name, I
 	IFX_SSC_QUEUE_t *queue;
 	char buf[IFX_SSC_MAX_DEVNAME] = { 0 };
 	char *pName;
-
-	/* Sanity check first! */
-	if (ifx_ssc_isp == NULL) {
-		pr_err("%s ssc driver must be loaded first!\n",
+	int port_num, result = 0;
+
+	result = find_port(dev_name, &port_num);
+	if (result == ENODEV) {
+		port_num = 0;
+	}
+	if (ifx_ssc_isp[port_num] == NULL) {
+		LOGF_KLOG_ERROR("%s ssc driver must be loaded first!\n",
 			__func__);
 		return NULL;
 	}
 
-	port = &ifx_ssc_isp[0];	/* XXX */
+	port = ifx_ssc_isp[port_num];	/* XXX */
 
 	if (port->ssc_ndevs >= IFX_SSC_MAX_DEVICE) {
 		IFX_SSC_PRINT(port, SSC_MSG_ERROR,
@@ -3425,6 +3683,18 @@ int ifx_sscFreeConnection(IFX_SSC_HANDLE
 	IFX_SSC_SEM_LOCK(port->dev_sem);
 	TAILQ_FOREACH_SAFE(q, &port->ssc_devq, dev_entry, next) {
 		if (strcmp(q->dev_name, p->dev_name) == 0) {
+			#ifdef EXPERIMENTAL_FIX
+			/* extra check if someone call ifx_sscLock or ifx_sscAsyncLock to */
+			/* force lock the port to his driver but forgot to release it */
+			if (port->lock_qentry != NULL &&
+			    port->lock_qentry == &p->queue) {
+				IFX_SSC_PRINT(port, SSC_MSG_ERROR,
+				"[%s] device hold the queue lock, Force Unlocking... \n",
+				p->dev_name);
+				ifx_sscUnlock(handler);
+				//ifx_sscAsyncUnLock(handler); /* will restart the tasklet as well??? */
+			}
+			#endif /* EXPERIMENTAL_FIX */
 			TAILQ_REMOVE(&port->ssc_devq, q, dev_entry);
 		#ifdef CONFIG_SYSCTL
 			ifx_ssc_sysctl_detach(q);
@@ -3450,11 +3720,12 @@ EXPORT_SYMBOL(ifx_sscFreeConnection);
  * \return  none
  * \ingroup IFX_SSC_INTERNAL
  */
-static int __init ifx_ssc_proc_init(void)
+static int ifx_ssc_proc_init(int port)
 {
 	struct proc_dir_entry *entry;
-
-	ifx_ssc_proc = proc_mkdir("driver/ltq_ssc", NULL);
+	char buf[20];
+	snprintf(buf, sizeof(buf), "%s%d", "driver/ltq_ssc", port);
+	ifx_ssc_proc = proc_mkdir(buf, NULL);
 	if (!ifx_ssc_proc)
 		return -ENOMEM;
 
@@ -3471,7 +3742,7 @@ static int __init ifx_ssc_proc_init(void
 err2:
 	remove_proc_entry("stats", ifx_ssc_proc);
 err1:
-	remove_proc_entry("driver/ltq_ssc", NULL);
+	remove_proc_entry(buf, NULL);
 	return -ENOMEM;
 }
 
@@ -3482,13 +3753,16 @@ err1:
  * \return  none
  * \ingroup IFX_SSC_INTERNAL
  */
-static void ifx_ssc_proc_exit(void)
+static void ifx_ssc_proc_exit(int port)
 {
+
+	char buf[20];
+	snprintf(buf, sizeof(buf), "%s%d", "driver/ltq_ssc", port);
 	remove_proc_entry("stats", ifx_ssc_proc);
 
 	remove_proc_entry("reg", ifx_ssc_proc);
 
-	remove_proc_entry("driver/ltq_ssc", NULL);
+	remove_proc_entry(buf, NULL);
 }
 
 /**
@@ -3506,20 +3780,46 @@ static int ifx_ssc_init(struct platform_
 	struct ifx_ssc_port *port;
 	int j;
 	int ret_val = -ENOMEM;
-	static int ifx_ssc_initialized;
+	/*static int ifx_ssc_initialized;*/
 	struct clk *clk;
 	struct resource *r;
 	u32 id;
-
-	ifx_ssc_isp = kzalloc(sizeof(struct ifx_ssc_port), GFP_KERNEL);
-	if (ifx_ssc_isp == NULL) {
-		pr_err("%s: no memory for isp\n", __func__);
+	static int ifx_ssc_init_count;
+	char buf[16];
+
+#ifdef CONFIG_SOC_GRX500
+	const __be32 *port_num = of_get_property(pdev->dev.of_node, "lantiq,ssc-port", NULL);
+	if (!port_num) {
+		ifx_ssc_init_count = 0;
+		LOGF_KLOG_ERROR("node lantiq,ssc-port not found\r\n");
+	} else
+		ifx_ssc_init_count = *port_num;
+
+	const __be32 *cs_port_num = of_get_property(pdev->dev.of_node, "legacy,cs-api-port", NULL);
+	if ( cs_port_num &&
+		 *cs_port_num <= (IFX_SSC_MAX_PORT_NUM - 1)) {
+		legacy_cs_port_num = ((s32)(*cs_port_num));
+		LOGF_KLOG_INFO("[%s] force ifx_ssc_cs_low to PORT %d\r\n",  __func__, legacy_cs_port_num);
+		LOGF_KLOG_INFO("[%s] force ifx_ssc_cs_high to PORT %d\r\n", __func__, legacy_cs_port_num);
+	}
+
+#endif
+	LOGF_KLOG_INFO("%s ifx_ssc_init_count %d\r\n", __func__, ifx_ssc_init_count);
+
+	if (ifx_ssc_init_count > (IFX_SSC_MAX_PORT_NUM - 1)) {
+		ret_val = -ENODEV;
 		return ret_val;
 	}
-	port = ifx_ssc_isp;
+
+	ifx_ssc_isp[ifx_ssc_init_count] = kzalloc(sizeof(struct ifx_ssc_port), GFP_KERNEL);
+	if (ifx_ssc_isp[ifx_ssc_init_count] == NULL) {
+		LOGF_KLOG_ERROR("%s: no memory for isp\n", __func__);
+		return ret_val;
+	}
+	port = ifx_ssc_isp[ifx_ssc_init_count];
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (r == NULL) {
-		dev_err(&pdev->dev, "platform_get_resource\n");
+		LOGF_KLOG_DEV_ERROR(&pdev->dev, "platform_get_resource\n");
 		ret_val = -ENOENT;
 		return ret_val;
 	}
@@ -3527,23 +3827,24 @@ static int ifx_ssc_init(struct platform_
 	r = devm_request_mem_region(&pdev->dev, r->start, resource_size(r),
 			pdev->name);
 	if (!r) {
-		dev_err(&pdev->dev, "failed to request memory region\n");
+		LOGF_KLOG_DEV_ERROR(&pdev->dev, "failed to request memory region\n");
 		ret_val = -ENXIO;
 		return ret_val;
 	}
 	port->membase = devm_ioremap_nocache(&pdev->dev,
 		r->start, resource_size(r));
 	if (!port->membase) {
-		dev_err(&pdev->dev, "failed to remap memory region\n");
+		LOGF_KLOG_DEV_ERROR(&pdev->dev, "failed to remap memory region\n");
 		ret_val = -ENXIO;
 		return ret_val;
 	}
+	#if 0
 	if (ifx_ssc_initialized == 1)
 		return 0;
 	else
 		ifx_ssc_initialized = 1;
-
-	port->port_idx = 0;
+	#endif
+	port->port_idx = ifx_ssc_init_count;
 	/* default values for the HwOpts */
 	port->opts.abortErrDetect = IFX_SSC_DEF_ABRT_ERR_DETECT;
 	port->opts.rxOvErrDetect = IFX_SSC_DEF_RO_ERR_DETECT;
@@ -3569,13 +3870,21 @@ static int ifx_ssc_init(struct platform_
 	port->ssc_fragSize = DEFAULT_SSC_FRAGMENT_SIZE;
 	port->fpiclk = clk_get_fpi();
 	if (IS_ERR(port->fpiclk)) {
-		pr_err("%s Failed to get fpi clock\n", __func__);
+		LOGF_KLOG_ERROR("%s Failed to get fpi clock\n", __func__);
 		ret_val = PTR_ERR(port->fpiclk);
 		goto err_clk;
 	}
 
 	/* Activate SSC */
+	#if 0
 	clk = clk_get_sys("1e100800.spi", NULL);
+	#endif
+
+	clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(clk)) {
+		LOGF_KLOG_DEV_ERROR(&pdev->dev, "Failed to get clock\n");
+		return PTR_ERR(clk);
+	}
 	clk_enable(clk);
 
 	reg = IFX_SSC_GET_CLC(port);
@@ -3595,21 +3904,30 @@ static int ifx_ssc_init(struct platform_
 	ifx_ssc_tasklet_init(port);
 #else
 	if (ifx_ssc_thread_init(port)) {
-		pr_err("%s: unable to start ssc_kthread\n", __func__);
+		LOGF_KLOG_ERROR("%s: unable to start ssc_kthread\n", __func__);
 		goto errout1;
 	}
 #endif /* CONFIG_LANTIQ_SPI_ASYNCHRONOUS */
 	if (port->dma_support) {
+#ifdef LTQ_DMA_SUPPORT
+		char spi_name[16] = {0};
+		if (port->port_idx == 0)
+			sprintf(spi_name, "SPI");
+		else
+			sprintf(spi_name, "SPI%d", port->port_idx);
 		/* Register with DMA engine */
-		port->dma_dev = dma_device_reserve("SPI");
+		port->dma_dev = dma_device_reserve(spi_name);
 		if (port->dma_dev == NULL) {
-			pr_err("%s: Failed to reserve dma device!\n", __func__);
+			LOGF_KLOG_ERROR("%s: Failed to reserve dma device!\n", __func__);
 			goto errout1;
 		}
-		ifx_ssc_init_dma_device(0, port->dma_dev);
+		ifx_ssc_init_dma_device(port->port_idx, port->dma_dev);
+#endif
 	}
 
-	strcpy(port->name, IFX_SSC_NAME);
+	snprintf(buf, sizeof(buf), "%s%d", IFX_SSC_NAME, ifx_ssc_init_count);
+	strcpy(port->name, buf);
+	LOGF_KLOG_INFO("port name %s", port->name);
 	port->ssc_cs_locked = false;
 	port->lock_qentry = NULL;
 	port->serve_qentry = NULL;
@@ -3622,6 +3940,7 @@ static int ifx_ssc_init(struct platform_
 	atomic_set(&port->dma_wait_state, 0);
 
 	if (port->dma_support) {
+#ifdef LTQ_DMA_SUPPORT
 		/* The following buffer allocation for HW WAR, last 1~3 bytes
 		 * in DMA, It will make sure buffer will align on dma
 		 * burst length
@@ -3630,7 +3949,7 @@ static int ifx_ssc_init(struct platform_
 			+ ((port->dma_dev->tx_burst_len << 2) - 1),
 			GFP_KERNEL);
 		if (port->dma_orig_txbuf == NULL) {
-			pr_err("%s: no memory for dma_orig_txbuf\n", __func__);
+			LOGF_KLOG_ERROR("%s: no memory for dma_orig_txbuf\n", __func__);
 			goto errout2;
 		}
 		port->dma_txbuf = (char *) (((u32) (port->dma_orig_txbuf +
@@ -3641,12 +3960,13 @@ static int ifx_ssc_init(struct platform_
 		port->dma_orig_rxbuf = kmalloc(DEFAULT_SSC_FRAGMENT_SIZE
 			+ ((port->dma_dev->rx_burst_len << 2) - 1), GFP_KERNEL);
 		if (port->dma_orig_rxbuf == NULL) {
-			pr_err("%s: no memory for dma_orig_rxbuf\n", __func__);
+			LOGF_KLOG_ERROR("%s: no memory for dma_orig_rxbuf\n", __func__);
 			goto errout3;
 		}
 		port->dma_rxbuf = (char *) (((u32) (port->dma_orig_rxbuf +
 			((port->dma_dev->rx_burst_len << 2) - 1)))&~
 			((port->dma_dev->rx_burst_len << 2) - 1));
+#endif
 	}
 
 	/* Queue initialization */
@@ -3667,7 +3987,7 @@ static int ifx_ssc_init(struct platform_
 	IFX_SSC_SET_FRAMING_CON(IFX_SSC_DEF_SFCON, port);
 
 	if (ifx_ssc_hwinit(port) < 0) {
-		pr_err("%s: hardware init failed\n", __func__);
+		LOGF_KLOG_ERROR("%s: hardware init failed\n", __func__);
 		goto errout4;
 	}
 #ifdef CONFIG_SYSCTL
@@ -3676,11 +3996,13 @@ static int ifx_ssc_init(struct platform_
 	goto out;
 errout4:
 	if (port->dma_support) {
+#ifdef LTQ_DMA_SUPPORT
 		kfree(port->dma_orig_rxbuf);
 errout3:
 		kfree(port->dma_orig_txbuf);
 		dma_device_unregister(port->dma_dev);
 		dma_device_release(port->dma_dev);
+#endif
 	}
 
 	kthread_stop(port->ssc_tsk);
@@ -3693,15 +4015,16 @@ errout1:
 	if (port->fpiclk)
 		clk_put(port->fpiclk);
 err_clk:
-	kfree(ifx_ssc_isp);
+	kfree(ifx_ssc_isp[ifx_ssc_init_count]);
 	return ret_val;
 
 out:
-	ifx_ssc_proc_init();
-
-	pr_info("Lantiq SoC SSC controller rev %u (TXFS %u, RXFS %u, DMA %u)\n",
+	ifx_ssc_proc_init(ifx_ssc_init_count);
+
+	LOGF_KLOG_INFO("Lantiq SoC SSC controller rev %u (TXFS %u, RXFS %u, DMA %u)\n",
 		id & IFX_SSC_ID_REV, port->tx_fifo_size_words,
 		port->rx_fifo_size_words, port->dma_support);
+	ifx_ssc_init_count++;
 
 	return 0;
 }
@@ -3719,17 +4042,20 @@ static int ifx_ssc_exit(struct platform_
 {
 	struct ifx_ssc_port *port;
 	struct clk *clk;
+	static int ifx_ssc_exit_count;
 
 	/* free up any allocated memory */
-
-	port = &ifx_ssc_isp[0];
+	if (ifx_ssc_exit_count > (IFX_SSC_MAX_PORT_NUM - 1)) {
+		return -ENODEV;
+	}
+	port = ifx_ssc_isp[ifx_ssc_exit_count];
 	/* Disable the SSC */
 	IFX_SSC_CONFIG_MODE(port);
 
 	IFX_SSC_SEM_LOCK(port->dev_sem);
 	if (!TAILQ_EMPTY(&port->ssc_devq)) {
 		IFX_SSC_SEM_UNLOCK(port->dev_sem);
-		pr_err("%s SSC devices still attached, please release them first\n",
+		LOGF_KLOG_ERROR("%s SSC devices still attached, please release them first\n",
 			__func__);
 		return -1;
 	}
@@ -3746,28 +4072,33 @@ static int ifx_ssc_exit(struct platform_
 	IFX_SSC_IRQ_LOCK_DESTROY(port);
 	IFX_SSC_Q_LOCK_DESTROY(port);
 	if (port->dma_support) {
+#ifdef LTQ_DMA_SUPPORT
 		struct dma_device_info *dma_dev;
 		dma_dev = port->dma_dev;
 		if (dma_dev != NULL) {
 			dma_device_unregister(dma_dev);
 			dma_device_release(dma_dev);
 		}
+#endif
 	}
 #ifdef CONFIG_SYSCTL
 	ifx_ssc_port_sysctl_detach(port);
 #endif /* CONFIG_SYSCTL */
 
 	if (port->dma_support) {
+#ifdef LTQ_DMA_SUPPORT
 		kfree(port->dma_orig_rxbuf);
 		kfree(port->dma_orig_txbuf);
+#endif
 	}
 	iounmap(port->membase);
 
-	kfree(ifx_ssc_isp);
-	ifx_ssc_proc_exit();
+	kfree(ifx_ssc_isp[ifx_ssc_exit_count]);
+	ifx_ssc_proc_exit(ifx_ssc_exit_count);
 	clk = clk_get_sys("1e100800.spi", NULL);
 	clk_disable(clk);
 	clk_put(clk);
+	ifx_ssc_exit_count++;
 	return 0;
 }
 
diff --git a/drivers/spi/ltq_ssc.h b/drivers/spi/ltq_ssc.h
--- a/drivers/spi/ltq_ssc.h
+++ b/drivers/spi/ltq_ssc.h
@@ -62,7 +62,7 @@
 /* DMA case, RX info must be even number */
 #define IFX_SSC_DEF_RXFIFO_FL       4
 
-#define IFX_SSC_DEF_GPO_CS      0x3 /* no chip select */
+#define IFX_SSC_DEF_GPO_CS      0xFF /* no chip select */
 #define IFX_SSC_DEF_GPO_INV     0   /* no chip select */
 #define IFX_SSC_DEF_SFCON       0   /* no serial framing */
 #define IFX_SSC_DEF_IRNEN       \
@@ -535,7 +535,8 @@
 
 /* TX Buffer Get/Set */
 #define IFX_SSC_TX_WORD(_v, _p)        \
-	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_TB))
+	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_TB));\
+	udelay(1);
 #define IFX_SSC_GET_TX_WORD(_p)        \
 	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_TB))
 #define IFX_SSC_TX_HALFWORD(_v, _p)    \
@@ -785,11 +786,11 @@ do {                                    
 
 #define IFX_REGISTER_SYSCTL_TABLE(t) register_sysctl_table(t)
 
-#define IFX_SSC_MAX_PORT_NUM        1  /* assume default value */
+#define IFX_SSC_MAX_PORT_NUM        2  /* assume default value */
 
 #define IFX_SSC_MAX_DEVNAME         16
 #define IFX_SSC_MAX_DEVICE          8  /* XXX */
-
+#define IFX_SSC_MAX_MAPPING			IFX_SSC_MAX_PORT_NUM*IFX_SSC_MAX_DEVICE
 /* Parameters for SSC DMA device */
 
 #define DEFAULT_SSC_TX_CHANNEL_CLASS 3
