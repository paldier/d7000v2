# HG changeset patch
# Parent bd8f8eca33fa5fe07e42a03138c7ff8cc7e12ddb
diff --git a/arch/mips/include/asm/mach-lantiq/xway/lantiq_usif_spi.h b/arch/mips/include/asm/mach-lantiq/xway/lantiq_usif_spi.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/xway/lantiq_usif_spi.h
@@ -0,0 +1,282 @@
+/******************************************************************************
+**
+** FILE NAME    : ltq_usif_spi.h
+** PROJECT      : IFX UEIP for VRX200
+** MODULES      : USIF for SPI Mode
+**
+** DATE         : 03 Jun 2009
+** AUTHOR       : Lei Chuanhua
+** DESCRIPTION  : USIF SPI mode for counterpart API
+** COPYRIGHT    :       Copyright (c) 2009
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+** HISTORY
+** $Date        $Author         $Comment
+** 03 Jun,2009  Lei Chuanhua    Initial version
+*******************************************************************************/
+
+#ifndef LTQ_USIF_SPI_H
+#define LTQ_USIF_SPI_H
+
+/*!
+  \defgroup LANTIQ_USIF_SPI IFX USIF SPI mode module
+  \brief ifx usif spi mode driver module
+*/
+
+/*!
+  \defgroup LANTIQ_USIF_SPI_DEFINITIONS Defintion and structures
+  \ingroup LANTIQ_USIF_SPI
+  \brief definitions for ifx usif spi mode driver
+*/
+
+/*!
+  \defgroup LANTIQ_USIF_SPI_FUNCTIONS External APIs
+  \ingroup LANTIQ_USIF_SPI
+  \brief usif spi external driver functions
+*/
+
+/*!
+  \defgroup LANTIQ_USIF_SPI_INTERNAL Internal functions
+  \ingroup LANTIQ_USIF_SPI
+  \brief usif spi internal driver functions
+*/
+
+/*!
+  \file ltq_usif_spi.h
+  \brief header file for usif spi driver
+*/
+
+/* @{ */
+/*!
+ \addtogroup LANTIQ_USIF_SPI_DEFINITIONS
+*/
+/*! \enum  LANTIQ_USIF_SPI_PRIO_t
+    \brief Set communication priority of USIF_SPI connection
+
+    Three priority levels are defined. Low-level priority queue used for
+    applications like FLASH driver (lantiq_usif_spi_prio_low). normal
+    priority queue used for applications like display
+    (lantiq_usif_spi_prio_mid). High priority queue used for applications
+    like RTP packet transfer (lantiq_usif_spi_prio_high).
+ */
+typedef enum {
+	/*!< Low Priority queue. For FLASH driver, etc. */
+	LANTIQ_USIF_SPI_PRIO_LOW = 0,
+	/*!< Normal Priority queue. For LCD, display data, etc. */
+	LANTIQ_USIF_SPI_PRIO_MID,
+	/*!< High priority queue. Ror RTP voice, etc. */
+	LANTIQ_USIF_SPI_PRIO_HIGH,
+	/*!< Tasklet priority (This is the highest supported priority). For
+	     this priority level only the asynchronous API set of the USIF
+	     driver can be called. These funtions stay unblocked and a
+	     callback function is called when the request is processed.
+	     This allows that the APIs are called from tasklet level.
+	     The callback function is always called on tasklet level */
+	LANTIQ_USIF_SPI_PRIO_ASYNC,
+} LANTIQ_USIF_SPI_PRIO_t;
+
+#define LANTIQ_USIF_SPI_PRIO_MAX LANTIQ_USIF_SPI_PRIO_ASYNC
+
+
+/*! \enum  LANTIQ_USIF_SPI_MODE_t
+    \brief Defines the Ssc hardware mode settings supported
+
+    Because there is no official specification, what exactly SPI is and what
+    not, it is necessary to consult the data sheets of the components one
+    wants to use. Important are the permitted clock frequencies and the type
+    of valid transitions. There are no general rules for transitions where
+    data should be latched. Although not specified by Motorola, in practice
+    four modes are used. These four modes are the combinations of CPOL and
+    CPHA. In table 1, the four modes are listed.If the phase of the clock is
+    zero, i.e. CPHA = 0, data is latched at the rising edge of the clock with
+    CPOL = 0, and at the falling edge of the clock with CPOL = 1. If CPHA = 1,
+    the polarities are reversed. CPOL = 0 means falling edge, CPOL = 1 rising
+    edge.The micro controllers from Motorola allow the polarity and the phase
+    of the clock to be adjusted. A positive polarity results in latching data
+    at the rising edge of the clock. However data is put on the data line
+    already at the falling edge in order to stabilize. Most peripherals which
+    can only be slaves, work with this configuration. If it should become
+    necessary to use the other polarity, transitions are reversed.
+  */
+typedef enum {
+	LANTIQ_USIF_SPI_MODE_0 = 0, /*!< CPOL=0,CPHA=0 */
+	LANTIQ_USIF_SPI_MODE_1, /*!< CPOL=0,CPHA=1 */
+	LANTIQ_USIF_SPI_MODE_2, /*!< CPOL=1,CPHA=0 */
+	LANTIQ_USIF_SPI_MODE_3, /*!< CPOL=1,CPHA=1 */
+	LANTIQ_USIF_SPI_MODE_UNKNOWN, /*!< Unknown SPI mode */
+} LANTIQ_USIF_SPI_MODE_t;
+
+/*! \enum  LANTIQ_USIF_SPI_HANDL_TYPE_t
+    \brief Defines the USIF SPI handler type supported
+  */
+typedef enum {
+	/*!< Only SYNC handler which be used by sync application */
+	LANTIQ_USIF_SPI_HANDL_TYPE_SYNC = 0,
+	/*!< Only ASYNC handler which be used by async application */
+	LANTIQ_USIF_SPI_HANDL_TYPE_ASYNC,
+} LANTIQ_USIF_SPI_HANDL_TYPE_t;
+
+/*! \enum  LANTIQ_USIF_SPI_DLX_t
+    \brief Set communication duplex mode of USIF SPI connection
+
+    The duplex mode is used to notify USIF SPI bus driver by USIF SPI device
+    driver about what kind of communication mode should be used. Which duplex
+    mode will be used depends on the USIF SPI device driver instead of USIF
+    SPI bus driver.
+ */
+typedef enum {
+	/*!< Half Duplex. Interface is used in half duplex when calling
+	    \ref lantiq_usif_spiTxRx or \ref lantiq_usif_spiAsyncTxRx The TX path
+	     is servered before the RX path. */
+	LANTIQ_USIF_SPI_HALF_DUPLEX = 0,
+	/*!< Full Duplex. Interface is used in full duplex when calling
+	     \ref lantiq_usif_spiTxRx or \ref lantiq_usif_spiAsyncTxRx. The TX
+	     -and RX- path is servered simultaneously. */
+
+	LANTIQ_USIF_SPI_FULL_DUPLEX,
+} LANTIQ_USIF_SPI_DLX_t;
+
+/*!< \typedef LANTIQ_USIF_SPI_CS_DATA_t
+     \brief Definition of device specific data for chip select
+ */
+typedef int LANTIQ_USIF_SPI_CS_DATA_t;
+
+/* chip select number */
+#define LANTIQ_USIF_SPI_CS0    0
+#define LANTIQ_USIF_SPI_CS1    1
+#define LANTIQ_USIF_SPI_CS2    2
+#define LANTIQ_USIF_SPI_CS3    3
+#define LANTIQ_USIF_SPI_CS4    4
+#define LANTIQ_USIF_SPI_CS5    5
+#define LANTIQ_USIF_SPI_CS6    6
+#define LANTIQ_USIF_SPI_CS7    7
+
+enum {
+	LANTIQ_USIF_SPI_CS_ON = 0,
+	LANTIQ_USIF_SPI_CS_OFF,
+};
+
+/*! \typedef LANTIQ_USIF_SPI_CS_CB_t
+    \brief Chip Select Callback function type declaration
+
+     csq csq=0, i.e. CS low (active). csq=1, i.e.CS high (idle).
+     cs_data This is the device number in case if more than one device is
+     using the same registered driver. E.g. two VINETICs, each with it´s own CS.
+ */
+typedef int (*LANTIQ_USIF_SPI_CS_CB_t) (u32 csq,
+	LANTIQ_USIF_SPI_CS_DATA_t cs_data);
+
+/*! typedef lantiq_usif_spi_async_fkt_cb_t
+    \brief Callback definition for asynchronous USIF API calls. This callback
+    is called by the USIF driver on tasklet level after the request is
+    completed or exit with an error.
+
+    \param handle Funktion handle that provided for callback registration
+     during the SSC asynchronous API call.
+    \param retvalue This return value describe if the asynchronous request
+     identified an error and worked successfully.
+*/
+typedef void (*lantiq_usif_spi_async_fkt_cb_t) (int handle, int retvalue);
+
+/*! typedef LANTIQ_SSC_ASYNC_CALLBACK_t
+    \brief Parameter to specify the asynchronous callback. It is called by the
+    USIF tasklet after the requested transmission or locking is done.
+*/
+typedef struct {
+	/*!< Callback function pointer, called in the USIF tasklet
+	     when the requested command is executed */
+	lantiq_usif_spi_async_fkt_cb_t pFunction;
+	/*!< Callback function handle. This parameter is transparently
+	     given to the callback function without any modification
+	     by the USIF driver */
+	int functionHandle;
+} LANTIQ_USIF_SPI_ASYNC_CALLBACK_t;
+
+/*!  \brief Parameter structure used to configure an USIF_SPI connection
+ * "ConnId".
+ */
+typedef struct {
+	/*!< Defines the hardware setup mode of the USIF_SPI */
+	LANTIQ_USIF_SPI_MODE_t spi_mode;
+	/*!< The communication priority of USIF_SPI connection. Three priority
+	     levels are defined. Low-level priority queue used for applications
+	     like FLASH driver (lantiq_usif_spi_prio_low). Normal priority queue
+	     used for applications like display (lantiq_usif_spi_prio_mid). High
+	     priority queue used for applications like RTP packet transfer
+	     (lantiq_usif_spi_prio_high). The here defined USIF_SPI priority
+	     corresponds to the priority the USIF_SPI driver application and
+	     should be set just for information when the driver is registered
+	     by the application. */
+	LANTIQ_USIF_SPI_PRIO_t spi_prio;
+	/*!< Baudrate used for the ConnId. This parameter can be later be
+	     modified by a call of lantiq_usif_spiSetBaud */
+	int baudrate;
+
+	/*!< All transmitted and received packets should be fragmented in this
+	     fragment size. Size given in Bytes. A maximum of 1024 Bytes is
+	     allowed. If the client uses a bigger values here, USIF_SPI returns
+	     with error. The client has to take care of the fragmentation */
+	int fragSize;
+	/*!< Maximum packet size in FIFO mode. All transmitted and received
+	     packets are transmitted in DMA mode if the packet size is greater
+	     than this value. A value of 148 is recommended at first. Size
+	     given in Bytes */
+	int maxFIFOSize;
+	/*!< Function Callback called by USIF_SPI driver when it starts/stops
+	     to receive or transmit */
+	LANTIQ_USIF_SPI_CS_CB_t csset_cb;
+	/*!< Parameter used for the function call of "csSet_cb". */
+	LANTIQ_USIF_SPI_CS_DATA_t cs_data;
+	/*!< Duplex Mode Selector. Connection used the USIF SPI interface
+	     either in half- or full- duplex mode. */
+	LANTIQ_USIF_SPI_DLX_t duplex_mode;
+
+} LANTIQ_USIF_SPI_CONFIGURE_t;
+
+/*! \typedef LANTIQ_USIF_SPI_HANDLE_t
+    \brief Definition of the connection handle
+
+     as it is used by the client kernel module that use the USIF_SPI driver
+     Inside of the USIF_SPI driver, this handle is mapped to an internal
+     structure that contains the connection specific parameter (e.g.
+     Baudrate, Chipselect Callbacks, etc.).
+ */
+typedef void *LANTIQ_USIF_SPI_HANDLE_t;
+/* @} */
+
+extern int lantiq_usif_spi_cs_low(u32 pin);
+extern int lantiq_usif_spi_cs_high(u32 pin);
+extern int lantiq_usif_spiLock(LANTIQ_USIF_SPI_HANDLE_t handler);
+extern int lantiq_usif_spiUnlock(LANTIQ_USIF_SPI_HANDLE_t handler);
+extern int lantiq_usif_spiSetBaud(LANTIQ_USIF_SPI_HANDLE_t handler,
+			unsigned int baud);
+extern int lantiq_usif_spiTxRx(LANTIQ_USIF_SPI_HANDLE_t handler, char *txbuf,
+			u32 txlen, char *rxbuf, u32 rxlen);
+extern int lantiq_usif_spiRx(LANTIQ_USIF_SPI_HANDLE_t handler, char *rxbuf,
+			u32 rxlen);
+extern int lantiq_usif_spiTx(LANTIQ_USIF_SPI_HANDLE_t handler, char *txbuf,
+			u32 txlen);
+extern LANTIQ_USIF_SPI_HANDLE_t lantiq_usif_spiAllocConnection(char *dev_name,
+		 LANTIQ_USIF_SPI_CONFIGURE_t *connid);
+extern int lantiq_usif_spiFreeConnection(LANTIQ_USIF_SPI_HANDLE_t handler);
+extern int lantiq_usif_spiAsyncTxRx(LANTIQ_USIF_SPI_HANDLE_t handler,
+	LANTIQ_USIF_SPI_ASYNC_CALLBACK_t *pCallback,
+	char *txbuf, int txsize, char *rxbuf, int rxsize);
+extern int lantiq_usif_spiAsyncTx(LANTIQ_USIF_SPI_HANDLE_t handler,
+		LANTIQ_USIF_SPI_ASYNC_CALLBACK_t *pCallback,
+		char *txbuf, int txsize);
+extern int lantiq_usif_spiAsyncRx(LANTIQ_USIF_SPI_HANDLE_t handler,
+		LANTIQ_USIF_SPI_ASYNC_CALLBACK_t *pCallback,
+		char *rxbuf, int rxsize);
+
+extern int lantiq_usif_spiAsyncLock(LANTIQ_USIF_SPI_HANDLE_t handler,
+	LANTIQ_USIF_SPI_ASYNC_CALLBACK_t *pCallback);
+extern int lantiq_usif_spiAsyncUnLock(LANTIQ_USIF_SPI_HANDLE_t handler);
+
+#endif /* LTQ_USIF_SPI_H */
+
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -414,7 +414,44 @@
 	depends on LANTIQ_SPI
 	default n
 
+config LANTIQ_USIF_SPI
+	tristate "Lantiq USIF SPI driver"
+	depends on SPI_MASTER && (SOC_XWAY)
+	default n
 
+config LANTIQ_USIF_SPI_DEBUG
+    bool "Lantiq USIF SPI runtime debug support"
+    depends on LANTIQ_USIF_SPI
+    default n
+    ----help---
+    Choose this option to enable USIF SPI runtime debug options. This can be enabled by writing debug options into /proc/sys/dev/ifx_usif_spi/debug.
+
+config LANTIQ_USIF_SPI_ASYNCHRONOUS
+    bool "Lantiq USIF SPI tasklet support"
+    depends on LANTIQ_USIF_SPI
+    default y
+    ---help---
+    Choose this option to support synchronous and asynchronous APIs at the same time. USIF SPI itself will run in tasklet. If not, only synchronous API is supported. SPI context will in kernel thread mode and belong to caller's context.
+
+config USIF_SPI_XRX200
+	bool "Lantiq USIF support for XRX200 family of SoCs"
+	depends on LANTIQ_USIF_SPI
+	default n
+
+config USIF_SPI_XRX300
+	bool "Lantiq USIF support for XRX300 family of SoCs"
+	depends on LANTIQ_USIF_SPI
+	default n
+
+config LANTIQ_USIF_SPI_FLASH
+	tristate "Lantiq USIF SPI 25 types of serial flash driver"
+	depends on LANTIQ_USIF_SPI
+	default n
+	
+config LANTIQ_USIF_AT45_FLASH
+    tristate "Lantiq atmel45xxx flash driver"
+    depends on LANTIQ_USIF_SPI
+    default n
 
 config SPI_SH_MSIOF
 	tristate "SuperH MSIOF SPI controller"
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -79,3 +79,7 @@
 
 obj-$(CONFIG_LANTIQ_SPI)               += ltq_ssc.o
 obj-$(CONFIG_LANTIQ_SPI_FLASH)         += ltq_sflash.o
+
+obj-$(CONFIG_LANTIQ_USIF_SPI)          += lantiq_usif_spi.o
+obj-$(CONFIG_LANTIQ_USIF_SPI_FLASH)    += lantiq_usif_sflash.o
+obj-$(CONFIG_LANTIQ_USIF_AT45_FLASH)   += ltqmips_usif_at45.o
diff --git a/drivers/spi/lantiq_usif_reg.h b/drivers/spi/lantiq_usif_reg.h
new file mode 100644
--- /dev/null
+++ b/drivers/spi/lantiq_usif_reg.h
@@ -0,0 +1,849 @@
+/******************************************************************************
+**
+** FILE NAME    : ltqmips_usif_reg.h
+** PROJECT      : IFX UEIP
+** MODULES      : USIF for UART and SPI
+**
+** DATE         : 21 Aug 2008
+** AUTHOR       : Lei Chuanhua
+** DESCRIPTION  : USIF module register definitioin
+** COPYRIGHT    :       Copyright (c) 2008 ~ 2009
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+** HISTORY
+** $Date         $Author         $Comment
+** 21 Aug, 2009  Lei Chuanhua    Initial version
+** 26 Jun, 2009  Lei Chuanhua    Code review modification
+*******************************************************************************/
+
+#ifndef LTQMIPS_USIF_REG_H
+#define LTQMIPS_USIF_REG_H
+
+/*!
+ \file ltqmips_usif_reg.h
+ \ingroup LANTIQ_USIF_SPI
+ \brief ifx usif module register definition
+*/
+#include <asm/io.h>
+
+#define LANTIQ_USIF_PHY_BASE    0x1DA00000
+#define LANTIQ_USIF_VIRT_BASE  (LANTIQ_USIF_PHY_BASE + KSEG1)
+#define LANTIQ_USIF_SIZE       0x100000 /* 1MB */
+
+/* USIF System Registers */
+#define LANTIQ_USIF_CLC             0x00 /* Clock Control Register */
+
+#define LANTIQ_USIF_CLC_RUN_STAT    0x00000001
+#define LANTIQ_USIF_CLC_CFG_STAT    0x00000002
+#define LANTIQ_USIF_CLC_STAT_M      0x00000003
+#define LANTIQ_USIF_CLC_MOD_EN      0x00000004
+#define LANTIQ_USIF_CLC_MOD_DIS     0x00000008
+#define LANTIQ_USIF_CLC_SPEN_EN     0x00000010
+#define LANTIQ_USIF_CLC_SPEN_DIS    0x00000020
+#define LANTIQ_USIF_CLC_FSOE_EN     0x00000040
+#define LANTIQ_USIF_CLC_FSOE_DIS    0x00000080
+#define LANTIQ_USIF_CLC_EDR_EN      0x00000100
+#define LANTIQ_USIF_CLC_EDR_DIS     0x00000200
+#define LANTIQ_USIF_CLC_IDR_EN      0x00000400
+#define LANTIQ_USIF_CLC_IDR_DIS     0x00000800
+
+#define LANTIQ_USIF_CLC_CNT         0x04 /* Clock Control Counter Register */
+
+#define LANTIQ_USIF_CLC_CNT_RMC     0x000000ff
+#define LANTIQ_USIF_CLC_CNT_RMC_S   0
+#define LANTIQ_USIF_CLC_CNT_ORMC    0x0000ff00
+#define LANTIQ_USIF_CLC_CNT_ORMC_S  8
+
+#define LANTIQ_USIF_CLC_STAT        0x08 /* Clock Control Status Register */
+
+#define LANTIQ_USIF_CLC_STAT_RUN              0x00000001
+#define LANTIQ_USIF_CLC_STAT_MODEN            0x00000002
+#define LANTIQ_USIF_CLC_STAT_SPEN             0x00000004
+#define LANTIQ_USIF_CLC_STAT_FSOE             0x00000008
+#define LANTIQ_USIF_CLC_STAT_EDRE             0x00000010
+#define LANTIQ_USIF_CLC_STAT_IDRE             0x00000020
+#define LANTIQ_USIF_CLC_STAT_CNT_UPDATE_DONE  0x00000040
+#define LANTIQ_USIF_CLC_STAT_KERN_IDL         0x00000080
+#define LANTIQ_USIF_CLC_STAT_FIFO_IDL         0x00000100
+
+#define LANTIQ_USIF_CLC_STAT_CFG_UPDATE_DONE  (LANTIQ_USIF_CLC_STAT_MODEN |\
+	LANTIQ_USIF_CLC_STAT_CNT_UPDATE_DONE | LANTIQ_USIF_CLC_STAT_KERN_IDL\
+	| LANTIQ_USIF_CLC_STAT_FIFO_IDL)
+
+#define LANTIQ_USIF_CLC_STAT_RUN_UPDATE_DONE  (LANTIQ_USIF_CLC_STAT_MODEN |\
+	LANTIQ_USIF_CLC_STAT_CNT_UPDATE_DONE | LANTIQ_USIF_CLC_STAT_KERN_IDL\
+	| LANTIQ_USIF_CLC_STAT_RUN | LANTIQ_USIF_CLC_STAT_FIFO_IDL)
+
+#define LANTIQ_USIF_ID                        0x0c
+
+#define LANTIQ_USIF_ID_TS_VER_NR              0xffff0000
+#define LANTIQ_USIF_ID_TS_VER_NR_S            16
+#define LANTIQ_USIF_ID_MOD_ID                 0x0000ff00
+#define LANTIQ_USIF_ID_MOD_ID_S               8
+#define LANTIQ_USIF_ID_REV_NR                 0x000000ff
+#define LANTIQ_USIF_ID_REV_NR_S               0
+
+#define LANTIQ_USIF_FIFO_ID                   0x10
+
+#define LANTIQ_USIF_FIFO_ID_TX                0x000000ff
+#define LANTIQ_USIF_FIFO_ID_TX_S              0
+#define LANTIQ_USIF_FIFO_ID_RX                0x0000ff00
+#define LANTIQ_USIF_FIFO_ID_RX_S              8
+#define LANTIQ_USIF_FIFO_ID_RPS               0x003f0000
+#define LANTIQ_USIF_FIFO_ID_RPS_S             16
+#define LANTIQ_USIF_FIFO_ID_DPLUS_CLS_ID      0x07000000
+#define LANTIQ_USIF_FIFO_ID_DPLUS_CLS_ID_S    24
+
+enum {
+	LANTIQ_USIF_FIFO_ID_DPLUS_CLS_WIDTH0 = 0, /* Dplus disabled */
+	LANTIQ_USIF_FIFO_ID_DPLUS_CLS_WIDTH2,
+	LANTIQ_USIF_FIFO_ID_DPLUS_CLS_WIDTH4,
+	LANTIQ_USIF_FIFO_ID_DPLUS_CLS_WIDTH8,
+};
+
+#define LANTIQ_USIF_SRB_MSCONF_ID      0x14
+
+#define LANTIQ_USIF_SRB_ERRCONF_ID     0x18
+
+#define LANTIQ_USIF_SWCID           0x1c /* USIF sw check identity */
+
+/* USIF Special Function Registers */
+#define LANTIQ_USIF_MSS_SET         0x100 /* Modemstatus Set Register */
+
+#define LANTIQ_USIF_MSS_SET_FCO     0x00000001
+#define LANTIQ_USIF_MSS_SET_DTR     0x00000004
+#define LANTIQ_USIF_MSS_SET_DSR     0x00000008
+#define LANTIQ_USIF_MSS_SET_DCD     0x00000010
+#define LANTIQ_USIF_MSS_SET_RI      0x00000020
+
+#define LANTIQ_USIF_MSS_CLR         0x104
+
+#define LANTIQ_USIF_MSS_CLR_FCO     0x00000001
+#define LANTIQ_USIF_MSS_CLR_DTR     0x00000004
+#define LANTIQ_USIF_MSS_CLR_DSR     0x00000008
+#define LANTIQ_USIF_MSS_CLR_DCD     0x00000010
+#define LANTIQ_USIF_MSS_CLR_RI      0x00000020
+
+#define LANTIQ_USIF_MSS_STAT        0x108
+
+#define LANTIQ_USIF_MSS_STAT_FCO    0x00000001
+#define LANTIQ_USIF_MSS_STAT_FCI    0x00000002
+#define LANTIQ_USIF_MSS_STAT_DTR    0x00000004
+#define LANTIQ_USIF_MSS_STAT_DSR    0x00000008
+#define LANTIQ_USIF_MSS_STAT_DCD    0x00000010
+#define LANTIQ_USIF_MSS_STAT_RI     0x00000020
+
+#define LANTIQ_USIF_MSS_CTRL         0x10c
+
+#define LANTIQ_USIF_MSS_CTRL_FCIEN   0x00000001
+#define LANTIQ_USIF_MSS_CTRL_FCOEN   0x00000002
+
+#define LANTIQ_USIF_MODE_CFG         0x110
+
+#define LANTIQ_USIF_MODE_CFG_SYNC    0x00000001
+#define LANTIQ_USIF_MODE_CFG_MA      0x00000002
+#define LANTIQ_USIF_MODE_CFG_RX_EN   0x00000004
+#define LANTIQ_USIF_MODE_CFG_FC_EN   0x00000008
+#define LANTIQ_USIF_MODE_CFG_LB      0x00000010
+#define LANTIQ_USIF_MODE_CFG_ECH     0x00000020
+#define LANTIQ_USIF_MODE_CFG_TX_INV  0x00000040
+#define LANTIQ_USIF_MODE_CFG_RX_INV  0x00000080
+#define LANTIQ_USIF_MODE_CFG_SC_FRC  0x00000100
+#define LANTIQ_USIF_MODE_CFG_SC_POL  0x00000200
+#define LANTIQ_USIF_MODE_CFG_SC_PH   0x00000400
+#define LANTIQ_USIF_MODE_CFG_TX_IDLE 0x00000800
+#define LANTIQ_USIF_MODE_CFG_AB_EN   0x00001000
+#define LANTIQ_USIF_MODE_CFG_EC_EN   0x00002000
+#define LANTIQ_USIF_MODE_CFG_EQA     0x00004000
+#define LANTIQ_USIF_MODE_CFG_HDEN    0x00008000
+#define LANTIQ_USIF_MODE_CFG_TX_EN   0x00010000
+
+#define LANTIQ_USIF_MODE_CFG_SC_MODE_MASK  (LANTIQ_USIF_MODE_CFG_SC_POL |\
+	LANTIQ_USIF_MODE_CFG_SC_PH)
+
+#define LANTIQ_USIF_MODE_CFG_TXRX_EN       (LANTIQ_USIF_MODE_CFG_RX_EN |\
+	LANTIQ_USIF_MODE_CFG_TX_EN)
+
+#define LANTIQ_USIF_MODE_CFG_TXRX_MASK      LANTIQ_USIF_MODE_CFG_TXRX_EN
+
+#define LANTIQ_USIF_PRTC_CFG          0x114 /* Protocol Configuration Register */
+
+#define LANTIQ_USIF_PRTC_CFG_CLEN5    0x05
+#define LANTIQ_USIF_PRTC_CFG_CLEN6    0x06
+#define LANTIQ_USIF_PRTC_CFG_CLEN7    0x07
+#define LANTIQ_USIF_PRTC_CFG_CLEN8    0x08
+#define LANTIQ_USIF_PRTC_CFG_CLEN16   0x10
+#define LANTIQ_USIF_PRTC_CFG_CLEN32   0x00
+#define LANTIQ_USIF_PRTC_CFG_CLEN     0x0000001f
+#define LANTIQ_USIF_PRTC_CFG_CLEN_S   0
+#define LANTIQ_USIF_PRTC_CFG_HD_MSB   0x00000080
+#define LANTIQ_USIF_PRTC_CFG_PAR      0x00000100
+#define LANTIQ_USIF_PRTC_CFG_ODD      0x00000200
+#define LANTIQ_USIF_PRTC_CFG_ERR_FE   0x00000400
+#define LANTIQ_USIF_PRTC_CFG_STP2     0x00001000
+#define LANTIQ_USIF_PRTC_CFG_WK_UP    0x00002000
+#define LANTIQ_USIF_PRTC_CFG_FCS_INV  0x00040000
+#define LANTIQ_USIF_PRTC_CFG_FCO_TL   0x03F00000
+#define LANTIQ_USIF_PRTC_CFG_FCO_TL_S 20
+#define LANTIQ_USIF_PRTC_CFG_SFCO_EN  0x04000000
+#define LANTIQ_USIF_PRTC_CFG_SFCI_EN  0x08000000
+#define LANTIQ_USIF_PRTC_CFG_SLIP_EN  0x10000000
+#define LANTIQ_USIF_PRTC_CFG_SLIP_EXT 0x20000000
+#define LANTIQ_USIF_PRTC_CFG_HDLC     0x40000000
+
+#define LANTIQ_USIF_PRTC_STAT         0x118 /* Protocol Status Register */
+
+#define LANTIQ_USIF_PRTC_STAT_CLEN    0x0000001f
+#define LANTIQ_USIF_PRTC_STAT_CLEN_S  0
+#define LANTIQ_USIF_PRTC_STAT_PAR     0x00000100
+#define LANTIQ_USIF_PRTC_STAT_ODD     0x00000200
+#define LANTIQ_USIF_PRTC_STAT_AB_DONE 0x00008000
+#define LANTIQ_USIF_PRTC_STAT_BCRV    0x0fff0000
+#define LANTIQ_USIF_PRTC_STAT_BRCV_S  16
+#define LANTIQ_USIF_PRTC_STAT_TXACT   0x80000000
+
+#define LANTIQ_USIF_FRM_CTRL          0x11c /* Frame Control Register */
+
+#define LANTIQ_USIF_FRM_CTRL_SFEN     0x00000001
+#define LANTIQ_USIF_FRM_CTRL_IBEN     0x00000004
+#define LANTIQ_USIF_FRM_CTRL_IAEN     0x00000008
+#define LANTIQ_USIF_FRM_CTRL_DLEN     0x0000fff0
+#define LANTIQ_USIF_FRM_CTRL_DLEN_S   4
+#define LANTIQ_USIF_FRM_CTRL_ICLK     0x00040000
+#define LANTIQ_USIF_FRM_CTRL_STOP     0x00100000
+#define LANTIQ_USIF_FRM_CTRL_PLEN     0xffc00000
+#define LANTIQ_USIF_FRM_CTRL_PLEN_S   22
+
+#define LANTIQ_USIF_FRM_STAT          0x120 /* Frame Status Register */
+
+#define LANTIQ_USIF_FRM_STAT_SFEN     0x00000001
+#define LANTIQ_USIF_FRM_STAT_DBSY     0x00000002
+#define LANTIQ_USIF_FRM_STAT_PBSY     0x00000004
+#define LANTIQ_USIF_FRM_STAT_DCNT     0x0000fff0
+#define LANTIQ_USIF_FRM_STAT_DCNT_S   4
+#define LANTIQ_USIF_FRM_STAT_PCNT     0xffc00000
+#define LANTIQ_USIF_FRM_STAT_PCNT_S   22
+
+#define LANTIQ_USIF_CRC_CFG           0x124 /* CRC Configuration Register */
+
+#define LANTIQ_USIF_CRC_CFG_GRADE8    0x00000008
+#define LANTIQ_USIF_CRC_CFG_GRADE16   0x00000010
+#define LANTIQ_USIF_CRC_CFG_GRADE32   0x00
+#define LANTIQ_USIF_CRC_CFG_INIT      0x00000100
+#define LANTIQ_USIF_CRC_CFG_HD_MSB    0x00000200
+#define LANTIQ_USIF_CRC_CFG_REFO      0x00000400
+#define LANTIQ_USIF_CRC_CFG_FIN_XOR   0x00000800
+#define LANTIQ_USIF_CRC_CFG_ENDIAN    0x00001000
+
+#define LANTIQ_USIF_CRCPOLY_CFG       0x128
+
+#define LANTIQ_USIF_CRC_CTRL          0x12c
+
+#define LANTIQ_USIF_CRC_CTRL_RX_EN    0x00000001
+#define LANTIQ_USIF_CRC_CTRL_TX_EN    0x00000002
+
+#define LANTIQ_USIF_CS_CFG            0x130
+
+#define LANTIQ_USIF_CS_CFG_EN         0x00000001
+#define LANTIQ_USIF_CS_CFG_EACS       0x00000002
+#define LANTIQ_USIF_CS_CFG_INV        0x00000010
+#define LANTIQ_USIF_CS_CFG_CS0_HI     0x00000100
+#define LANTIQ_USIF_CS_CFG_CS1_HI     0x00000200
+#define LANTIQ_USIF_CS_CFG_CS2_HI     0x00000400
+#define LANTIQ_USIF_CS_CFG_CS3_HI     0x00000800
+#define LANTIQ_USIF_CS_CFG_CS4_HI     0x00001000
+#define LANTIQ_USIF_CS_CFG_CS5_HI     0x00002000
+#define LANTIQ_USIF_CS_CFG_CS6_HI     0x00004000
+#define LANTIQ_USIF_CS_CFG_CS7_HI     0x00008000
+#define LANTIQ_USIF_CS_CFG_CSO_CLK    0x000f0000
+#define LANTIQ_USIF_CS_CFG_CS0_CLK_S  16
+#define LANTIQ_USIF_CS_CFG_CS0_FRM    0x00f00000
+#define LANTIQ_USIF_CS_CFG_CS0_FRM_S  20
+#define LANTIQ_USIF_CS_CFG_CSO_INV    0xFF000000
+#define LANTIQ_USIF_CS_CFG_CSO_INV_S  24
+#define LANTIQ_USIF_CS_CFG_CSX_DEFAULT 0xFF000000
+
+#define LANTIQ_USIF_CS_OFFSET         8
+#define LANTIQ_USIF_CS_INV_OFFSET     24
+
+#define LANTIQ_USIF_FDIV_CFG          0x140
+
+#define LANTIQ_USIF_FDIV_CFG_INC      0x0001ff
+#define LANTIQ_USIF_FDIV_CFG_INC_S    0
+#define LANTIQ_USIF_FDIV_CFG_DEC      0xffff0000
+#define LANTIQ_USIF_FDIV_CFG_DEC_S    16
+
+#define LANTIQ_USIF_BC_CFG            0x144
+
+#define LANTIQ_USIF_BC_CFG_BCRV       0x00001fff
+#define LANTIQ_USIF_BC_CFG_BCRV_S     0
+#define LANTIQ_USIF_BC_CFG_SCDIV_HALF 0x01000000
+
+#define LANTIQ_USIF_ICTMO_CFG         0x148
+
+#define LANTIQ_USIF_ICTMO_CFG_TMO     0x0000ffff
+#define LANTIQ_USIF_ICTMO_CFG_TMO_S   0
+
+#define LANTIQ_USIF_ICTM_CFG          0x14c
+
+#define LANTIQ_USIF_ICTM_CFG_TM       0x00003fff
+#define LANTIQ_USIF_ICTM_CFG_TM_S     0
+
+#define LANTIQ_USIF_ECTM_CFG          0x150
+
+#define LANTIQ_USIF_ECTM_CFG_ECTM     0x000003ff
+#define LANTIQ_USIF_ECTM_CFG_ECTM_S   0
+
+/* USIF Chip Select Timing Configuration */
+#define LANTIQ_USIF_CS_TIM0_CFG       0x154
+#define LANTIQ_USIF_CS_TIM1_CFG       0x158
+#define LANTIQ_USIF_CS_TIM2_CFG       0x15C
+#define LANTIQ_USIF_CS_TIM3_CFG       0x160
+#define LANTIQ_USIF_CS_TIM4_CFG       0x164
+#define LANTIQ_USIF_CS_TIM5_CFG       0x168
+#define LANTIQ_USIF_CS_TIM6_CFG       0x16C
+#define LANTIQ_USIF_CS_TIM7_CFG       0x170
+#define LANTIQ_USIF_CS_TIMX_CFG(cs)   (LANTIQ_USIF_CS_TIM0_CFG + (cs << 2))
+
+/* Setup/Hold/Idle defintion in CS timing configuration */
+#define LANTIQ_USIF_CS_TIM_CFG_IDLE    0x000000FF
+#define LANTIQ_USIF_CS_TIM_CFG_IDLE_S  0
+#define LANTIQ_USIF_CS_TIM_CFG_HOLD    0x0000FF00
+#define LANTIQ_USIF_CS_TIM_CFG_HOLD_S  8
+#define LANTIQ_USIF_CS_TIM_CFG_SETUP   0x00FF0000
+#define LANTIQ_USIF_CS_TIM_CFG_SETUP_S 16
+
+/* USIF Data Buffer Registers */
+#define LANTIQ_USIF_FIFO_CFG          0x30 /* FIFO configuration register */
+
+#define LANTIQ_USIF_FIFO_CFG_RXBS     0x00000007
+#define LANTIQ_USIF_FIFO_CFG_RXBS_S   0
+#define LANTIQ_USIF_FIFO_CFG_RXFC     0x00000008
+#define LANTIQ_USIF_FIFO_CFG_TXBS     0x00000070
+#define LANTIQ_USIF_FIFO_CFG_TXBS_S   4
+#define LANTIQ_USIF_FIFO_CFG_TXFC     0x00000080
+#define LANTIQ_USIF_FIFO_CFG_RXFA     0x00000700
+#define LANTIQ_USIF_FIFO_CFG_RX_SWAP  0x00000800
+#define LANTIQ_USIF_FIFO_CFG_RXFA_S   8
+#define LANTIQ_USIF_FIFO_CFG_TXFA     0x00007000
+#define LANTIQ_USIF_FIFO_CFG_TXFA_S   12
+#define LANTIQ_USIF_FIFO_CFG_TX_SWAP  0x00008000
+enum {
+	LANTIQ_USIF_RXFIFO_BURST_WORD1 = 0,
+	LANTIQ_USIF_RXFIFO_BURST_WORD2,
+	LANTIQ_USIF_RXFIFO_BURST_WORD4,
+	LANTIQ_USIF_RXFIFO_BURST_WORD8,
+	LANTIQ_USIF_RXFIFO_BURST_WORD16,
+};
+
+enum {
+	LANTIQ_USIF_TXFIFO_BURST_WORD1 = 0,
+	LANTIQ_USIF_TXFIFO_BURST_WORD2,
+	LANTIQ_USIF_TXFIFO_BURST_WORD4,
+	LANTIQ_USIF_TXFIFO_BURST_WORD8,
+	LANTIQ_USIF_TXFIFO_BURST_WORD16,
+};
+
+enum {
+	LANTIQ_USIF_RXFIFO_ALIGN_BYTE = 0,
+	LANTIQ_USIF_RXFIFO_ALIGN_HALFWORD,
+	LANTIQ_USIF_RXFIFO_ALIGN_WORD,
+	LANTIQ_USIF_RXFIFO_ALIGN_DWORD,
+};
+
+enum {
+	LANTIQ_USIF_TXFIFO_ALIGN_BYTE = 0,
+	LANTIQ_USIF_TXFIFO_ALIGN_HALFWORD,
+	LANTIQ_USIF_TXFIFO_ALIGN_WORD,
+	LANTIQ_USIF_TXFIFO_ALIGN_DWORD,
+};
+
+#define LANTIQ_USIF_FIFO_CTRL              0x34
+
+#define LANTIQ_USIF_FIFO_CTRL_TX_START     0x00000001
+#define LANTIQ_USIF_FIFO_CTRL_TX_ABORT     0x00000002
+#define LANTIQ_USIF_FIFO_CTRL_TX_SETEOP    0x00000004
+#define LANTIQ_USIF_FIFO_CTRL_RX_START     0x00000010
+#define LANTIQ_USIF_FIFO_CTRL_RX_ABORT     0x00000020
+#define LANTIQ_USIF_FIFO_CTRL_RX_AR_ON     0x00000040
+#define LANTIQ_USIF_FIFO_CTRL_RX_AR_OFF    0x00000080
+
+#define LANTIQ_USIF_MRPS_CTRL            0x38
+
+#define LANTIQ_USIF_MRPS_CTRL_MRPS       0x00003fff
+#define LANTIQ_USIF_MRPS_CTRL_MRPS_S     0
+
+#define LANTIQ_USIF_MRPS_MIN             1
+#define LANTIQ_USIF_MRPS_MAX             16383
+
+#define LANTIQ_USIF_FIFO_STAT              0x44
+
+#define LANTIQ_USIF_FIFO_STAT_RX_FFS       0x000000ff
+#define LANTIQ_USIF_FIFO_STAT_RX_FFS_S     0
+#define LANTIQ_USIF_FIFO_STAT_RX_AR_ON     0x00010000
+#define LANTIQ_USIF_FIFO_STAT_RX_EOP       0x00020000
+#define LANTIQ_USIF_FIFO_STAT_RX_THR_EXC   0x00040000
+#define LANTIQ_USIF_FIFO_STAT_MRPS_WE      0x00080000
+#define LANTIQ_USIF_FIFO_STAT_TX_FFS       0x00ff0000
+#define LANTIQ_USIF_FIFO_STAT_TX_FFS_S     16
+#define LANTIQ_USIF_FIFO_STAT_TX_THR_EXC   0x40000000
+#define LANTIQ_USIF_FIFO_STAT_TPS_WE       0x80000000
+
+#define LANTIQ_USIF_FIFO_STAT_TXRX_FFS_MASK (LANTIQ_USIF_FIFO_STAT_RX_FFS |\
+	LANTIQ_USIF_FIFO_STAT_TX_FFS)
+
+#define LANTIQ_USIF_TXD_SB                 0x48
+
+#define LANTIQ_USIF_TXD_SB_TX_CLS          0x00000007
+#define LANTIQ_USIF_TXD_SB_TX_CLS_S        0
+#define LANTIQ_USIF_TXD_SB_TX_BE           0x00000030
+#define LANTIQ_USIF_TXD_SB_TX_BE_S         4
+#define LANTIQ_USIF_TXD_SB_XME             0x00000080
+
+/* TX class number */
+enum {
+	LANTIQ_USIF_TXD_CLASS0 = 0,
+	LANTIQ_USIF_TXD_CLASS1,
+	LANTIQ_USIF_TXD_CLASS2,
+	LANTIQ_USIF_TXD_CLASS3,
+	LANTIQ_USIF_TXD_CLASS4,
+	LANTIQ_USIF_TXD_CLASS5,
+	LANTIQ_USIF_TXD_CLASS6,
+	LANTIQ_USIF_TXD_CLASS7,
+};
+
+/* BPI byte enable */
+enum {
+	LANTIQ_USIF_TXD_BE4 = 0,
+	LANTIQ_USIF_TXD_BE1,
+	LANTIQ_USIF_TXD_BE2,
+	LANTIQ_USIF_TXD_BE3,
+};
+
+#define LANTIQ_USIF_DPLUS_CTRL                 0x2c /* DPLUS control register */
+
+#define LANTIQ_USIF_DPLUS_CTRL_SET_MASK        0x00000080
+#define LANTIQ_USIF_DPLUS_CTRL_RX_MASK         0x0000ff00
+#define LANTIQ_USIF_DPLUS_CTRL_RX_MASK_S       8
+#define LANTIQ_USIF_DPLUS_CTRL_RX_MASK_OFFSET  LANTIQ_USIF_DPLUS_CTRL_RX_MASK_S
+#define LANTIQ_USIF_DPLUS_CTRL_TX_EN           0x00400000
+#define LANTIQ_USIF_DPLUS_CTRL_TX_DIS          0x00800000
+
+#define LANTIQ_USIF_DPLUS_STAT                 0x4c /* DPLUS Status register */
+
+#define LANTIQ_USIF_DPLUS_STAT_RX_CLS          0x00000007
+#define LANTIQ_USIF_DPLUS_STAT_RX_CLS_S        0
+#define LANTIQ_USIF_DPLUS_STAT_RX_BE           0x00000030
+#define LANTIQ_USIF_DPLUS_STAT_RX_BE_S         4
+#define LANTIQ_USIF_DPLUS_STAT_RME             0x00000080
+#define LANTIQ_USIF_DPLUS_STAT_RX_MASK         0x0000ff00
+#define LANTIQ_USIF_DPLUS_STAT_RX_MASK_S       8
+#define LANTIQ_USIF_DPLUS_STAT_TX_EN           0x00400000
+#define LANTIQ_USIF_DPLUS_STAT_TX_ACT          0x00800000
+#define LANTIQ_USIF_DPLUS_STAT_RX_EN           0x01000000
+#define LANTIQ_USIF_DPLUS_STAT_RX_FIFO_EMPTY   0x80000000
+
+/* Transmit Data Register, range 0x4000-0x7FFF */
+#define LANTIQ_USIF_TXD                  0x40000
+/* Receive Data Register, range 0x8000-0xBFFF */
+#define LANTIQ_USIF_RXD                  0x80000
+
+/* USIF Interrupt, DMA and CRC Registers */
+
+/* Raw Interrupt Status Register for debug */
+#define LANTIQ_USIF_RIS                  0x80
+/* Interrupt Mask Control Register, enable/disable */
+#define LANTIQ_USIF_IMSC                 0x84
+/* Masked Interrupt Status Register, status */
+#define LANTIQ_USIF_MIS                  0x88
+/* Interrupt Clear Register, clear */
+#define LANTIQ_USIF_ICR                  0x98
+/* Interrupt Set Register for debug */
+#define LANTIQ_USIF_ISR                  0x90
+
+/* Interrupt flags (Register: IMSC, MIS, RIS, ICR and ISR) */
+#define LANTIQ_USIF_INT_RX_LSREQ         0x00000001
+#define LANTIQ_USIF_INT_RX_SREQ          0x00000002
+#define LANTIQ_USIF_INT_RX_LBREQ         0x00000004
+#define LANTIQ_USIF_INT_RX_BREQ          0x00000008
+#define LANTIQ_USIF_INT_TX_LSREQ         0x00000010
+#define LANTIQ_USIF_INT_TX_SREQ          0x00000020
+#define LANTIQ_USIF_INT_TX_LBREQ         0x00000040
+#define LANTIQ_USIF_INT_TX_BREQ          0x00000080
+#define LANTIQ_USIF_INT_TX_REQ           (LANTIQ_USIF_INT_TX_BREQ |\
+	LANTIQ_USIF_INT_TX_SREQ)
+#define LANTIQ_USIF_INT_AB               0x00000100
+#define LANTIQ_USIF_INT_WKP              0x00000200
+#define LANTIQ_USIF_INT_DATA_ALL         0x000000af
+#define LANTIQ_USIF_INT_DATA_ALL_S       0
+
+
+/* Error interrupt flags */
+#define LANTIQ_USIF_INT_RXUR             0x00000800
+#define LANTIQ_USIF_INT_RXOF             0x00001000
+#define LANTIQ_USIF_INT_TXUR             0x00002000
+#define LANTIQ_USIF_INT_TXOF             0x00004000
+#define LANTIQ_USIF_INT_PE               0x00008000
+#define LANTIQ_USIF_INT_FE               0x00010000
+#define LANTIQ_USIF_INT_PHE              0x00020000
+#define LANTIQ_USIF_INT_CRC              0x00080000
+#define LANTIQ_USIF_INT_SLIP             0x00100000
+#define LANTIQ_USIF_INT_MC               0x00200000
+#define LANTIQ_USIF_INT_ERR_ALL          0x003BF800
+#define LANTIQ_USIF_INT_ERR_ALL_s        11
+
+/* Status interrupt flags */
+#define LANTIQ_USIF_INT_FCO             0x00800000
+#define LANTIQ_USIF_INT_FCI             0x01000000
+#define LANTIQ_USIF_INT_DTR             0x02000000
+#define LANTIQ_USIF_INT_DSR             0x04000000
+#define LANTIQ_USIF_INT_DCD             0x08000000
+#define LANTIQ_USIF_INT_RI              0x10000000
+#define LANTIQ_USIF_INT_TX_FIN          0x20000000
+#define LANTIQ_USIF_INT_FRM_PAUSE       0x40000000
+#define LANTIQ_USIF_INT_TMO             0x80000000
+#define LANTIQ_USIF_INT_STA_ALL         0xff800000
+#define LANTIQ_USIF_INT_STA_ALL_S       23
+#define LANTIQ_USIF_INT_STA_CLR_ALL     0xff800000
+
+#define LANTIQ_USIF_INT_ALL       \
+	(LANTIQ_USIF_INT_DATA_ALL | LANTIQ_USIF_INT_ERR_ALL |\
+	LANTIQ_USIF_INT_STA_ALL | LANTIQ_USIF_INT_AB | LANTIQ_USIF_INT_WKP)
+
+#define LANTIQ_USIF_INT_CLR_ALL  LANTIQ_USIF_INT_ALL
+
+/* Interrupt setup flags for USIF TX */
+#define LANTIQ_USIF_INT_TRANSMIT                  \
+	(LANTIQ_USIF_INT_TX_BREQ | LANTIQ_USIF_INT_TX_SREQ)
+
+/* Interrupt setup flags for USIF RX */
+#define LANTIQ_USIF_INT_RECEIVE                   \
+	(LANTIQ_USIF_INT_RX_BREQ | LANTIQ_USIF_INT_RX_LBREQ | \
+	LANTIQ_USIF_INT_RX_SREQ | LANTIQ_USIF_INT_RX_LSREQ)
+
+/* Interrupt mask for the error interrupt */
+#define LANTIQ_USIF_INT_ERR_MASK                   \
+	(LANTIQ_USIF_INT_RXUR | LANTIQ_USIF_INT_TXUR |\
+	LANTIQ_USIF_INT_TXOF | LANTIQ_USIF_INT_PHE  |\
+	LANTIQ_USIF_INT_CRC)
+
+/**
+ * The following recieve interrupt source need to be checked but it
+ * need not generate any interrupts. These are processed in the error
+ * handling function for received characters
+ */
+#define LANTIQ_USIF_RX_ERR                        \
+	(LANTIQ_USIF_INT_RXOF | LANTIQ_USIF_INT_PE | LANTIQ_USIF_INT_FE)
+
+/* Macro definitions, used for reading and writing to the ports */
+
+/* Get USIF idenitifcation register */
+#define LANTIQ_USIF_GET_ID(_p)                 \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_ID))
+
+/* Set clock Control Register */
+#define LANTIQ_USIF_SET_RUN_CONTROL(_v, _p)      \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_CLC))
+
+#define LANTIQ_USIF_CLC_CONFIG_MODE(_p)  \
+	LANTIQ_USIF_SET_RUN_CONTROL((LANTIQ_USIF_CLC_CFG_STAT), (_p))
+
+#define LANTIQ_USIF_CLC_RUN_MODE(_p)  \
+	LANTIQ_USIF_SET_RUN_CONTROL((LANTIQ_USIF_CLC_RUN_STAT), (_p))
+
+/* Clock Control Counter Set */
+#define LANTIQ_USIF_SET_CLOCK_COUNTER(_v, _p)    \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_CLC_CNT))
+
+/* Get Clock Control Counter */
+#define LANTIQ_USIF_GET_CLOCK_COUNTER(p)      \
+	LANTIQ_REG_R32((volatile u32 *)((p)->membase + LANTIQ_USIF_CLC_CNT))
+
+/* Get Clock Control Status */
+#define LANTIQ_USIG_GET_CLOCK_STATUS(_p)       \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_CLC_STAT))
+
+/* Modem Status Set */
+#define LANTIQ_USIF_SET_MODEM_STATUS(_v, _p)     \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_MSS_SET))
+
+/* Modemstatus Clear */
+#define LANTIQ_USIF_CLR_MODEM_STATUS(_v, _p)     \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_MSS_CLR))
+
+/* Get Modem status */
+#define LANTIQ_USIF_GET_MODEM_STATUS(_p)       \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_MSS_STAT))
+
+/* Modem Status Control */
+#define LANTIQ_USIF_MODEM_FLOW_CTRL(_v, _p)      \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_MSS_CTRL))
+
+/* Updated the mode configuration register */
+#define LANTIQ_USIF_SET_MODE_CONFIG(_v, _p)      \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_MODE_CFG))
+
+/* Get the mode configuration register */
+#define LANTIQ_USIF_GET_MODE_CONFIG(p)        \
+	LANTIQ_REG_R32((volatile u32 *)((p)->membase + LANTIQ_USIF_MODE_CFG))
+
+/* Update the protocol configuration register */
+#define LANTIQ_USIF_SET_PROTOCOL_CONFIG(_v, _p)  \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_PRTC_CFG))
+
+/* Get the protocol configuration register */
+#define LANTIQ_USIF_GET_PROTOCOL_CONFIG(_p)   \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_PRTC_CFG))
+
+/* Get the protocol status */
+#define LANTIQ_USIF_GET_PROTOCOL_STATUS(_p)   \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_PRTC_STAT))
+
+/* Set the chip select configuration register */
+#define LANTIQ_USIF_SET_CHIPSELECT_CONFIG(_v, _p)  \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_CS_CFG))
+
+/* Get the chip select configuration register */
+#define LANTIQ_USIF_GET_CHIPSELECT_CONFIG(_p)  \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_CS_CFG))
+
+/* Update the fractional divider configuration register */
+#define LANTIQ_USIF_FRAC_DIV_CONFIG(_v, _p)      \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_FDIV_CFG))
+
+/* Get the fractional divider configuration register */
+#define LANTIQ_USIF_GET_FRAC_DIV(_p)           \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_FDIV_CFG))
+
+/* Update the baudrate counter configuration register */
+#define LANTIQ_USIF_BAUDRATE_COUNTER_CONFIG(_v, _p)    \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_BC_CFG))
+
+/* Get the baudrate counter configuration register */
+#define LANTIQ_USIF_GET_BAUDRATE_COUNTER(_p)      \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_BC_CFG))
+
+/* Update the intercharacter timeout  configuration register */
+#define LANTIQ_USIF_INTERCHARACTER_TIMEOUT_CONFIG(_v, _p)  \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_ICTMO_CFG))
+
+/* Get the intercharacter timeout */
+#define LANTIQ_USIF_GET_INTERCHARACTER_TIMEOUT(_p)   \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_ICTMO_CFG))
+
+/* Update the chip select timing configuration */
+#define LANTIQ_USIF_SET_CS_TIMING_CONFIG(_v, _cs, _p)    \
+	LANTIQ_REG_W32((_v), (volatile u32 *)  \
+	((_p)->membase + LANTIQ_USIF_CS_TIMX_CFG((_cs))))
+
+/* Get the chip select timing configuration */
+#define LANTIQ_USIF_GET_CS_TIMING_CONFIG(_p, _cs)      \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_CS_TIMX_CFG(_cs)))
+
+/* Update the fifo configuration register */
+#define LANTIQ_USIF_SET_FIFO_CONFIG(_v, _p)      \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_FIFO_CFG))
+
+/* Get the fifo configuration */
+#define LANTIQ_USIF_GET_FIFO_CONFIG(_p)        \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_FIFO_CFG))
+
+/* Get the fifo status */
+#define LANTIQ_USIF_GET_FIFO_STATUS(_p)        \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_FIFO_STAT))
+
+/* Get RX filling level */
+#define LANTIQ_USIF_GET_RX_FILL_FIFO(_p)       \
+	MS(LANTIQ_USIF_GET_FIFO_STATUS((_p)), LANTIQ_USIF_FIFO_STAT_RX_FFS)
+
+/* Get TX filling level */
+#define LANTIQ_USIF_GET_TX_FILL_FIFO(_p)       \
+	MS(LANTIQ_USIF_GET_FIFO_STATUS((_p)), LANTIQ_USIF_FIFO_STAT_TX_FFS)
+
+/* Get FIFO ID <Size> */
+#define LANTIQ_USIF_GET_FIFO_ID(_p)           \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_FIFO_ID))
+
+/* Get SW control id */
+#define LANTIQ_USIF_GET_SWC_ID(_p)           \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_SWCID))
+
+/* Get TX/RX  fifo size */
+#define LANTIQ_USIF_GET_TX_FIFO_SIZE(_p)      \
+	((MS(LANTIQ_USIF_GET_FIFO_ID((_p)), LANTIQ_USIF_FIFO_ID_TX)))
+
+#define LANTIQ_USIF_GET_RX_FIFO_SIZE(_p)      \
+	((MS(LANTIQ_USIF_GET_FIFO_ID((_p)), LANTIQ_USIF_FIFO_ID_RX)))
+
+/* Get the character from receive buffer */
+#define LANTIQ_USIF_GET_RX_WORD(_p)           \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_RXD))
+
+#define LANTIQ_USIF_GET_RX_CHAR(_p)          \
+	((u8)LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_RXD)))
+
+/* Update transmission data sideband register */
+#define LANTIQ_USIF_CONFIG_TXD_SIDEBAND(_v, _p) \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_TXD_SB))
+
+/* Get transmission data sideband register */
+#define LANTIQ_USIF_GET_TXD_SIDEBAND_CONFIG(_p) \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_TXD_SB))
+
+/* Put one word to transmit buffer */
+#define LANTIQ_USIF_PUT_TX_WORD(_v, _p)          \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_TXD))
+
+/* Get one word from transmit buffer */
+#define LANTIQ_USIF_GET_TX_WORD(_p)          \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_TXD))
+
+#define LANTIQ_USIF_TXD_SIDEBAND_LAST_WORD_CONFIG(_x, _p) do {               \
+	LANTIQ_USIF_CONFIG_TXD_SIDEBAND(                                 \
+	(LANTIQ_USIF_TXD_SB_XME | SM(LANTIQ_USIF_TXD_CLASS0, LANTIQ_USIF_TXD_SB_TX_CLS)\
+	| SM((_x), LANTIQ_USIF_TXD_SB_TX_BE)), (_p));                            \
+} while (0)
+
+/* Put one byte to transmit buffer */
+#define LANTIQ_USIF_PUT_TX_CHAR(_v, _p)   do {                              \
+	LANTIQ_USIF_TXD_SIDEBAND_LAST_WORD_CONFIG(LANTIQ_USIF_TXD_BE1, (_p));     \
+	LANTIQ_USIF_PUT_TX_WORD((u32)(_v), (_p));                               \
+} while (0)
+
+
+/* Put last word to transmit buffer */
+#define LANTIQ_USIF_PUT_TX_LAST_WORD(_x, _v, _p)   do {                      \
+	LANTIQ_USIF_TXD_SIDEBAND_LAST_WORD_CONFIG((_x), (_p));                 \
+	LANTIQ_USIF_PUT_TX_WORD((u32)(_v), (_p));                              \
+} while (0)
+
+#define LANTIQ_USIF_TXD_SIDEBAND_CLS_LAST_WORD_CONFIG(_x, _y, _p) do {         \
+	LANTIQ_USIF_CONFIG_TXD_SIDEBAND(                                   \
+	(LANTIQ_USIF_TXD_SB_XME | SM((_x), LANTIQ_USIF_TXD_SB_TX_CLS)       \
+	| SM((_y), LANTIQ_USIF_TXD_SB_TX_BE)), (_p));                         \
+} while (0)
+
+/* Put one byte to transmit buffer */
+#define LANTIQ_USIF_PUT_TX_CLS_CHAR(_x, _v, _p)   do {                       \
+	LANTIQ_USIF_TXD_SIDEBAND_CLS_LAST_WORD_CONFIG   \
+	((_x), (LANTIQ_USIF_TXD_BE1), (_p));            \
+	LANTIQ_USIF_PUT_TX_WORD((u32)(_v), (_p));                          \
+} while (0)
+
+/* Put last word to transmit buffer */
+#define LANTIQ_USIF_PUT_TX_CLS_LAST_WORD(_x, _y, _v, _p)   do {         \
+	LANTIQ_USIF_TXD_SIDEBAND_CLS_LAST_WORD_CONFIG((_x), (_y), (_p));  \
+	LANTIQ_USIF_PUT_TX_WORD((u32)(_v), (_p));                        \
+} while (0)
+
+#define LANTIQ_USIF_SET_FIFO_CTRL(_v, _p)                  \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_FIFO_CTRL))
+
+/* Config the Maximum Received Packet Size Register */
+#define LANTIQ_USIF_CONFIG_RX_MRPS(_v, _p)       \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_MRPS_CTRL))
+
+/* Read the Maximum Received Packet Size Register */
+#define LANTIQ_USIF_GET_RX_MRPS(_p)            \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_MRPS_CTRL))
+
+/* Set DPLUS control register, write only */
+#define LANTIQ_USIF_CONFIG_DPLUS_CONTROL(_v, _p)  \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_DPLUS_CTRL))
+
+/* Get DPLUS status */
+#define LANTIQ_USIF_GET_DPLUS_STATUS(_p) \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_DPLUS_STAT))
+
+/* Get RX byte enable */
+#define LANTIQ_USIF_GET_DPLUS_RXBE(_p)         \
+	MS(LANTIQ_USIF_GET_DPLUS_STATUS((_p)), LANTIQ_USIF_DPLUS_STAT_RX_BE)
+
+/* Set Interrupt Mask Control Register */
+#define LANTIQ_USIF_SET_INT_MASK(_v, _p)         \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_IMSC))
+
+/* Get Interrupt Mask Control Register */
+#define LANTIQ_USIF_GET_INT_MASK(_p)           \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_IMSC))
+
+/* Clear Interrupt Mask Control Register */
+#define LANTIQ_USIF_CLR_INT_MASK(_v, _p)           \
+	LANTIQ_REG_CLR_BIT((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_IMSC))
+
+/* Get Raw Interrupt Status, from RIS register < debug only> */
+#define LANTIQ_USIF_GET_RAW_INT_STATUS(_p)     \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_RIS))
+
+/* Get Interrupt status, from MIS Register */
+#define LANTIQ_USIF_GET_INT_STATUS(_p)         \
+	LANTIQ_REG_R32((volatile u32 *)((_p)->membase + LANTIQ_USIF_MIS))
+
+/* Set Interrupt Register <debug only> */
+#define LANTIQ_USIF_SET_INT(_v, _p)              \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_ISR))
+
+/* Clear Interrupt Register */
+#define LANTIQ_USIF_CLR_INT(_v, _p)              \
+	LANTIQ_REG_W32((_v), (volatile u32 *)((_p)->membase + LANTIQ_USIF_ICR))
+
+/* Structure for transmit word */
+typedef union lantiq_usif_txd {
+	struct {
+		u8 byte[4];
+	} txd_byte;
+	u32 txd_word;
+} LANTIQ_USIF_TXD_t;
+
+/* Structure for receive word */
+typedef union lantiq_usif_rxd {
+	struct {
+		u8 byte[4];
+	} rxd_byte;
+	u32 rxd_word;
+} LANTIQ_USIF_RXD_t;
+
+
+/* Helper Macros */
+
+/*
+*  Register Operation
+*/
+#define LANTIQ_REG_R32(_r)                    __raw_readl((volatile unsigned int *)(_r))
+#define LANTIQ_REG_W32(_v, _r)               __raw_writel((_v), (volatile unsigned int *)(_r))
+#define LANTIQ_REG_W32_MASK(_clr, _set, _r)   LANTIQ_REG_W32((LANTIQ_REG_R32((_r)) & ~(_clr)) | (_set), (_r)) 
+#define LANTIQ_REG_R16(_r)                    __raw_readw((_r)) 
+#define LANTIQ_REG_W16(_v, _r)               __raw_writew((_v), (_r)) 
+#define LANTIQ_REG_W16_MASK(_clr, _set, _r)   LANTIQ_REG_W16((LANTIQ_REG_R16((_r)) & ~(_clr)) | (_set), (_r))
+#define LANTIQ_REG_R8(_r)                     __raw_readb((_r))
+#define LANTIQ_REG_W8(_v, _r)                __raw_writeb((_v), (_r))
+#define LANTIQ_REG_W8_MASK(_clr, _set, _r)    LANTIQ_REG_W8((LANTIQ_REG_R8((_r)) & ~(_clr)) | (_set), (_r))
+
+/*
+* Register manipulation macros that expect bit field defines
+* to follow the convention that an _S suffix is appended for
+* a shift count, while the field mask has no suffix. Or can use
+* _M as suffix
+*/
+
+/* Shift first, then mask, usually for write operation */
+#define SM(_v, _f)  (((_v) << _f##_S) & (_f))
+
+/* Mask first , then shift, usually for read operation */
+#define MS(_v, _f)  (((_v) & (_f)) >> _f##_S)
+
+/* Always report fatal error */
+#define LANTIQ_KASSERT(exp, msg) do {    \
+    if (unlikely(!(exp))) {      \
+	        printk msg;               \
+			BUG();                    \
+	}                             \
+} while (0)
+
+#endif /* LTQMIPS_USIF_REG_H */
+
diff --git a/drivers/spi/lantiq_usif_sflash.c b/drivers/spi/lantiq_usif_sflash.c
new file mode 100644
--- /dev/null
+++ b/drivers/spi/lantiq_usif_sflash.c
@@ -0,0 +1,1184 @@
+/******************************************************************************
+**
+** FILE NAME    : ltqmips_usif_sflash.c
+** PROJECT      : IFX UEIP
+** MODULES      : 25 types of Serial Flash
+**
+** DATE         : 16 Oct 2009
+** AUTHOR       : Lei Chuanhua
+** DESCRIPTION  : SPI Flash MTD Driver
+** COPYRIGHT    :       Copyright (c) 2009
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 16,Oct 2009 Lei Chuanhua    Initial UEIP release
+*******************************************************************************/
+/*!
+  \defgroup LANTIQ_USIF_SFLASH IFX USIF SPI flash module
+  \brief ifx usif spi serial flash driver module
+*/
+
+/*!
+  \defgroup LANTIQ_USIF_SFLASH_OS OS APIs
+  \ingroup LANTIQ_USIF_SFLASH
+  \brief IFX serial flash driver OS interface functions
+*/
+
+/*!
+  \defgroup LANTIQ_USIF_SFLASH_INTERNAL Internal functions
+  \ingroup LANTIQ_USIF_SFLASH
+  \brief IFX serial flash driver functions
+*/
+
+/*!
+  \file ltqmips_usif_sflash.c
+  \ingroup LANTIQ_USIF_SFLASH
+  \brief ifx serial flash driver file
+*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/mtd/mtd.h>
+#include <../drivers/mtd/mtdcore.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ctype.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/semaphore.h>
+#include <linux/math64.h>
+/* Project header */
+#include <lantiq_soc.h>
+#include "lantiq_usif_sflash.h"
+
+#define LANTIQ_USIF_SFLASH_VER_MAJOR          1
+#define LANTIQ_USIF_SFLASH_VER_MID            0
+#define LANTIQ_USIF_SFLASH_VER_MINOR          5
+
+#define LANTIQ_USIF_SFLASH_NAME               "ltq_usif_flash"
+
+#define LANTIQ_SFLASH_ADDR_CYCLES              3	/* 24bit address */
+
+/* #define LANTIQ_SPI_FLASH_DBG */
+
+#if defined(LANTIQ_SPI_FLASH_DBG)
+#define LANTIQ_SFLASH_PRINT(format, arg...)   \
+	printk(KERN_INFO "%s: " format, __func__, ##arg)
+#define INLINE
+#else
+#define LANTIQ_SFLASH_PRINT(format, arg...)   \
+	do {} while (0)
+#define INLINE inline
+#endif
+
+#undef CONFIG_MTD_CMDLINE_PARTS
+
+#define LANTIQ_MTD_SPI_PARTITION_2MB_SIZE    0x001B0000
+#define LANTIQ_MTD_SPI_PARTITION_4MB_SIZE    0x003A0000
+#define LANTIQ_MTD_SPI_PARTITION_8MB_SIZE    0x007A0000
+#define LANTIQ_MTD_SPI_PARTITION_16MB_SIZE   0x00FA0000
+#define LANTIQ_MTD_SPI_PARTITION_32MB_SIZE   0x01FA0000
+
+#define LANTIQ_MTD_SPI_PART_NB               3
+#define LANTIQ_SPI_FLASH_MAX                 9
+
+static const struct mtd_partition
+g_lantiq_mtd_spi_partitions[LANTIQ_SPI_FLASH_MAX][LANTIQ_MTD_SPI_PART_NB] = {
+	{ { 0, 0, 0 } },
+
+/* 256K Byte */
+	{ {
+		.name   =      "spi-boot",      /* U-Boot firmware */
+		.offset =      0x00000000,
+		.size   =      0x00040000,         /* 256 */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	}, {0}, {0},
+	},
+
+/* 512K Byte */
+	{ { 0, 0, 0 } },
+
+/* 1M Byte */
+	{ {
+		.name   =       "spi-boot",     /* U-Boot firmware */
+		.offset =       0x00000000,
+		.size   =       0x00010000,        /* 64K */
+		/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-firmware", /* firmware */
+		.offset =       0x00010000,
+		.size   =       0x00030000,        /* 64K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-rootfs,kernel,Data,Environment",
+		.offset =       0x00030000,
+		.size   =       0x000C0000,
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	} },
+
+/* 2M Byte */
+	{ {
+		.name   =       "spi-boot",     /* U-Boot firmware */
+		.offset =       0x00000000,
+		.size   =       0x00020000,        /* 128K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-firmware", /* firmware */
+		.offset =       0x00020000,
+		.size   =       0x00030000,        /* 192K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-rootfs,kernel,Data,Environment",
+		.offset =       0x00050000,
+		.size   =       LANTIQ_MTD_SPI_PARTITION_2MB_SIZE,
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	} },
+
+/* 4M Byte */
+	{ {
+		.name   =       "spi-boot",     /* U-Boot firmware */
+		.offset =       0x00000000,
+		.size   =       0x00020000,        /* 128K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-firmware", /* firmware */
+		.offset =       0x00020000,
+		.size   =       0x00040000,        /* 256K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-rootfs,kernel,Data,Environment",
+		.offset =       0x00060000,
+		.size   =       LANTIQ_MTD_SPI_PARTITION_4MB_SIZE,
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	} },
+
+/* 8M Byte */
+	{ {
+		.name   =       "spi-boot",     /* U-Boot firmware */
+		.offset =       0x00000000,
+		.size   =       0x00020000,        /* 128K */
+		/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =      "spi-firmware",  /* firmware */
+		.offset =      0x00020000,
+		.size   =      0x00030000,         /* 192K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-rootfs,kernel,Data,Environment",
+		.offset =       0x00050000,
+		.size   =       LANTIQ_MTD_SPI_PARTITION_8MB_SIZE,
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	} },
+
+/* 16M Byte */
+	{ {
+		.name   =       "spi-boot",     /* U-Boot firmware */
+		.offset =       0x00000000,
+		.size   =       0x00020000,        /* 128K */
+		/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =      "spi-firmware",  /* firmware */
+		.offset =      0x00020000,
+		.size   =      0x00030000,         /* 192K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-rootfs,kernel,Data,Environment",
+		.offset =       0x00050000,
+		.size   =       LANTIQ_MTD_SPI_PARTITION_16MB_SIZE,
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	} },
+/* 32M Byte */
+	{ {
+		.name   =       "spi-boot",     /* U-Boot firmware */
+		.offset =       0x00000000,
+		.size   =       0x00020000,        /* 128K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =      "spi-firmware",  /* firmware */
+		.offset =      0x00020000,
+		.size   =      0x00030000,         /* 192K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-rootfs,kernel,Data,Environment",
+		.offset =       0x00050000,
+		.size   =       LANTIQ_MTD_SPI_PARTITION_32MB_SIZE,
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	} },
+};
+
+static struct semaphore lantiq_sflash_sem;
+
+static lantiq_usif_spi_dev_t *spi_sflash;
+
+/*
+ * NOTE: double check command sets and memory organization when you add
+ * more flash chips.  This current list focusses on newer chips, which
+ * have been converging on command sets which including JEDEC ID.
+ */
+static const struct lantiq_usif_sflash_manufacturer_info
+	flash_manufacturers[] = {
+	{
+	 /* Spansion -- single (large) sector size only, at least
+	  * for the chips listed here (without boot sectors).
+	  */
+	 .name = "Spansion",
+	 .id = JED_MANU_SPANSION,
+	 .flashes = {
+		{"S25Sl004", 0x0212, 64 * 1024, 8,},
+		{"S25Sl008", 0x0213, 64 * 1024, 16,},
+		{"S25LF016", 0x0214, 64 * 1024, 32,},
+		{"S25LF032", 0x0215, 64 * 1024, 64,},
+		{"S25LF064", 0x0216, 64 * 1024, 128,},
+		{"", 0x0, 0, 0},
+		{"S25LF0128", 0x0218, 256 * 1024, 64,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		},
+	 },
+	{ /* ST Microelectronics -- newer production may have feature updates */
+	 .name = "ST",
+	 .id = JED_MANU_ST,
+	 .flashes = {
+		{"m25p05", 0x2010, 32 * 1024, 2,},
+		{"m25p10", 0x2011, 32 * 1024, 4,},
+		{"m25p20", 0x2012, 64 * 1024, 4,},
+		{"m25p40", 0x2013, 64 * 1024, 8,},
+		{"m25p16", 0x2015, 64 * 1024, 32,},
+		{"m25px16", 0x7115, 64 * 1024, 32, SECT_4K,},
+		{"m25p32", 0x2016, 64 * 1024, 64,},
+		{"m25px32", 0x7116, 64 * 1024, 64, SECT_4K,},
+		{"m25p64", 0x2017, 64 * 1024, 128,},
+		{"m25px64", 0x7117, 64 * 1024, 128, SECT_4K,},
+		{"m25p128", 0x2018, 256 * 1024, 64,},
+		{"m45pe80", 0x4014, 64 * 1024, 16,},
+		{"m45pe16", 0x4015, 64 * 1024, 32,},
+		{"m25pe80", 0x8014, 64 * 1024, 16,},
+		{"m25pe16", 0x8015, 64 * 1024, 32, SECT_4K,},
+
+		},
+	 },
+	{ /* SST -- large erase sizes are "overlays", "sectors" are 4K */
+	 .name = "SST",
+	 .id = JED_MANU_SST,
+	 .flashes = {
+		{"sst25vf040b", 0x258d, 64 * 1024, 8, SECT_4K,},
+		{"sst25vf080b", 0x258e, 64 * 1024, 16, SECT_4K,},
+		{"sst25vf016b", 0x2541, 64 * 1024, 32, SECT_4K,},
+		{"sst25vf032b", 0x254a, 64 * 1024, 64, SECT_4K,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		},
+	 },
+	{
+	 .name = "Atmel",
+	 .id = JED_MANU_ATMEL,
+	 .flashes = {
+		{"at25fs010", 0x6601, 32 * 1024, 4, SECT_4K,},
+		{"at25fs040", 0x6604, 64 * 1024, 8, SECT_4K,},
+		{"at25df041a", 0x4401, 64 * 1024, 8, SECT_4K,},
+		{"at25df641", 0x4800, 64 * 1024, 128, SECT_4K,},
+		{"at26f004", 0x0400, 64 * 1024, 8, SECT_4K,},
+		{"at26df081a", 0x4501, 64 * 1024, 16, SECT_4K,},
+		{"at26df161a", 0x4601, 64 * 1024, 32, SECT_4K,},
+		{"at26df321", 0x4701, 64 * 1024, 64, SECT_4K,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		},
+
+	 },
+	{ /* Winbond -- w25x "blocks" are 64K, "sectors" are 4KiB */
+	 .name = "Winbond",
+	 .id = JED_MANU_WINBOND,
+	 .flashes = {
+		{"w25x10", 0x3011, 64 * 1024, 2, SECT_4K,},
+		{"w25x20", 0x3012, 64 * 1024, 4, SECT_4K,},
+		{"w25x40", 0x3013, 64 * 1024, 8, SECT_4K,},
+		{"w25x80", 0x3014, 64 * 1024, 16, SECT_4K,},
+		{"w25x16", 0x3015, 64 * 1024, 32, SECT_4K,},
+		{"w25x32", 0x3016, 64 * 1024, 64, SECT_4K,},
+		{"w25x64", 0x3017, 64 * 1024, 128, SECT_4K,},
+		{"W25P80", 0x2014, 256 * 256, 16,},
+		{"W25P16", 0x2015, 256 * 256, 32,},
+		{"W25P32", 0x2016, 256 * 256, 64,},
+		{"W25P64", 0x2017, 256 * 256, 128,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		},
+
+	 },
+	{
+	 .name = "MX",
+	 .id = JED_MANU_MX,
+	 .flashes = {
+		{"MX25P2005", 0x2012, 16 * 256, 64,},
+		{"MX25P4005", 0x2013, 16 * 256, 128,},
+		{"MX25P8005", 0x2014, 16 * 256, 256,},
+		{"MX25P1605", 0x2015, 256 * 256, 32,},
+		{"MX25P3205", 0x2016, 256 * 256, 64,},
+		{"MX25P6405", 0x2017, 256 * 256, 128,},
+		{"MX25L12835", 0x2018, 256 * 256, 128, SECT_4K,},
+            	{ "MX25P12855", 0x2618, 64 * 1024, 256, },
+            	{ "MX25L25635", 0x2019, 64 * 1024, 512, },
+            	{ "MX25P25655", 0x2619, 64 * 1024, 512, },
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		},
+	 },
+};
+
+static inline int lantiq_drv_ver(char *buf, char *module, int major, int mid, int minor)
+{
+    return sprintf(buf, "Lantiq %s driver, version %d.%d.%d, (c) 2001-2013 Lantiq Deutschland GmbH\n",
+	        module, major, mid, minor);
+}
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+static const char * part_probes[] = { "cmdlinepart", NULL };
+#endif
+
+#ifdef LANTIQ_SPI_FLASH_DBG
+static void flash_dump(const char *title, const u8 *buf, size_t len)
+{
+	int i, llen, lenlab = 0;
+	const u8 *pos = buf;
+	const int line_len = 16;
+
+	printk(KERN_INFO "%s - hex_ascii(len=%lu):\n",
+		title, (unsigned long) len);
+	while (len) {
+		llen = len > line_len ? line_len : len;
+		printk(KERN_INFO "%08x: ", lenlab);
+		for (i = 0; i < llen; i++)
+			printk(KERN_INFO " %02x", pos[i]);
+		for (i = llen; i < line_len; i++)
+			printk(KERN_INFO "   ");
+		printk(KERN_INFO "   ");
+		for (i = 0; i < llen; i++) {
+			if (isprint(pos[i]))
+				printk(KERN_INFO "%c", pos[i]);
+			else
+				printk(KERN_INFO ".");
+		}
+		for (i = llen; i < line_len; i++)
+			printk(KERN_INFO " ");
+		printk(KERN_INFO "\n");
+		pos += llen;
+		len -= llen;
+		lenlab += line_len;
+	}
+}
+#endif /* LANTIQ_SPI_FLASH_DBG */
+
+/**
+ * \fn static INLINE void  u32_to_u8_addr(u32 address, u8* addr)
+ * \brief  convert address from u32 to u8 array
+ *
+ * \param[in]  address the address to be converted, maximum 32 bit
+ * \param[out] addr array that holds the results, maximum 4 elemets
+ * \ingroup LANTIQ_USIF_SFLASH_INTERNAL
+ */
+static INLINE void u32_to_u8_addr(u32 address, u8 *addr)
+{
+	addr[0] = (u8) ((address >> 16) & 0xff);
+	addr[1] = (u8) ((address >> 8) & 0xff);
+	addr[2] = (u8) (address & 0xff);
+}
+
+/**
+ * \fn static int lantiq_usif_sflash_rdsr(lantiq_usif_spi_dev_t *dev, u8 *status)
+ * \brief Return the status of the serial flash device.
+ *
+ * \param[in]  dev   Pointer to lantiq_usif_spi_dev_t
+ * \param[out] status Pointer to return status
+ * \return   -l  Failed to read status
+ * \return    0  OK
+ * \ingroup LANTIQ_USIF_SFLASH_INTERNAL
+ */
+static int lantiq_usif_sflash_rdsr(lantiq_usif_spi_dev_t *dev, u8 *status)
+{
+	int ret;
+	u8 cmd = LANTIQ_OPCODE_RDSR;
+
+	ret = lantiq_usif_spiTxRx(dev->sflash_handler, (char *) &cmd,
+		sizeof(u8), status, sizeof(u8));
+	if (ret != 2) {
+		LANTIQ_SFLASH_PRINT("line %d lantiq_usif_spiTxRx fails %d\n",
+			__LINE__, ret);
+		return -1;
+	}
+	return 0;
+}
+
+/**
+ * \fn static int lantiq_usif_sflash_sync(lantiq_usif_spi_dev_t *dev)
+ * \brief Poll the serial flash device until it is READY
+ *
+ * \param[in]  dev   Pointer to lantiq_usif_spi_dev_t
+ * \return     -l  Failed to read status
+ * \return     0  OK
+ * \ingroup LANTIQ_USIF_SFLASH_INTERNAL
+ */
+static int lantiq_usif_sflash_sync(lantiq_usif_spi_dev_t *dev)
+{
+	int ret = 0;
+	u8 status;
+	int count = 0;
+	unsigned long deadline;
+
+	deadline = jiffies + LANTIQ_MAX_READY_WAIT_JIFFIES;
+	do {
+		ret = lantiq_usif_sflash_rdsr(dev, &status);
+		if (ret < 0) {
+			LANTIQ_SFLASH_PRINT("Read back status fails %d\n", ret);
+			break;
+		}
+
+		if (!(status & LANTIQ_SR_WIP))
+			return 0;
+
+		cond_resched();
+
+		/* This is mainly for detecting serial flash */
+		if (++count > LANTIQ_SFLASH_DETECT_COUNTER) {
+			LANTIQ_SFLASH_PRINT
+				("Detct counter out of range!!!\n");
+			break;
+		}
+
+	} while (!time_after_eq(jiffies, deadline));
+
+	return -1;
+}
+
+/**
+ * \fn static int lantiq_usif_sflash_session(lantiq_usif_spi_dev_t *dev, u8 cmd, u8 *addr, u8 dummy_cycles,
+ *                u8 * wbuf, u32 wcnt, u8 * rbuf, u32 rcnt)
+ * \brief Handle serial flash read/write/erase in one central function
+ *
+ * \param[in]  dev   Pointer to lantiq_usif_spi_dev_t
+ * \param[in]  cmd   Serial flash command code
+ * \param[in]  addr  Flash address offset
+ * \param[in]  dummy_cycles Dummy cycles for some serial flash
+ * \param[in]  wbuf     Pointer to the data packet to write.
+ * \param[in]  wcnt     Amount of Bytes to write.
+ * \param[out] rbuf     Pointer to store the read data.
+ * \param[in]  rcnt     Amount of Bytes to read.
+ * \return     -EINVAL  Invalid read data length
+ * \return     -EBUSY   Serial flash device is busy
+ * \return     0        OK
+ * \ingroup LANTIQ_USIF_SFLASH_INTERNAL
+ */
+static int
+lantiq_usif_sflash_session(lantiq_usif_spi_dev_t *dev, u8 cmd, u8 *addr,
+	u8 dummy_cycles, u8 *wbuf, u32 wcnt, u8 *rbuf, u32 rcnt)
+{
+	int i;
+	int ret = 0;
+	int err = 0;
+	int start = 0;
+	int total = 0;
+	char *buf = dev->flash_tx_buf;
+	char *tbuf;
+
+	/* Sanity check */
+	if (unlikely(rcnt >= LANTIQ_SFLASH_MAX_READ_SIZE)) {
+		printk(KERN_ERR "%s: please increase read buffer size\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	/* CMD */
+	buf[0] = cmd;
+	start = 1;
+
+	/* Address */
+	if (addr != NULL) {
+		for (i = 0; i < dev->addr_cycles; i++)
+			buf[start + i] = addr[i];
+
+		start += dev->addr_cycles;
+	}
+
+	/* Dummy cycles */
+	if (dummy_cycles > 0 && dummy_cycles < LANTIQ_MAX_DUMMY_CYCLES) {
+		for (i = 0; i < dummy_cycles; i++)
+			buf[start + i] = 0;
+
+		start += dummy_cycles;
+	}
+
+	/* Possibly, there is no flash mounted */
+	if (lantiq_usif_sflash_sync(dev) == -1)
+		return -EBUSY;
+
+	if ((wcnt == 0) && (rcnt == 0)) { /* Cmd + Addr + Dummy cycles */
+		ret = lantiq_usif_spiTx(dev->sflash_handler, buf, start);
+		if (ret != start) {
+			err++;
+			LANTIQ_SFLASH_PRINT
+				("line %d lantiq_usif_spiTx fails %d\n",
+				 __LINE__, ret);
+			goto sflash_session_out;
+		}
+	} else if (wcnt > 0) { /* Cmd + Addr +  Dummy cycles + Write data */
+		total = start + wcnt;
+		memcpy(buf + start, wbuf, wcnt);
+		ret = lantiq_usif_spiTx(dev->sflash_handler, buf, total);
+		if (ret != total) {
+			err++;
+			LANTIQ_SFLASH_PRINT
+				("line %d lantiq_usif_spiTx fails %d\n",
+				 __LINE__, ret);
+			goto sflash_session_out;
+		}
+	} else if (rcnt > 0) { /* Cmd + Addr +  Dummy cycles + Read data */
+		int rx_aligned = 0;
+
+		total = start + rcnt;
+		rx_aligned =
+			(((u32) rbuf) & (LANTIQ_SFLASH_DMA_MAX_BURST_LEN - 1))
+			== 0 ? 1 : 0;
+		if (rx_aligned == 0)
+			tbuf = dev->flash_rx_buf;
+		else
+			tbuf = rbuf;
+		ret = lantiq_usif_spiTxRx(dev->sflash_handler, buf, start,
+			tbuf, rcnt);
+		if (ret != total) {
+			err++;
+			LANTIQ_SFLASH_PRINT
+				("line %d lantiq_usif_spiTxRx fails %d\n",
+				 __LINE__, ret);
+			goto sflash_session_out;
+		}
+
+		if (rx_aligned == 0)
+			memcpy(rbuf, tbuf, rcnt);
+
+	} else
+		printk(KERN_ERR "%s should never happen\n", __func__);
+
+sflash_session_out:
+	return err;
+}
+
+static INLINE int lantiq_sflash_wren(void)
+{
+	u8 cmd = LANTIQ_OPCODE_WREN;
+	return lantiq_usif_sflash_session(spi_sflash,
+		cmd, NULL, 0, NULL, 0, NULL, 0);
+}
+
+static INLINE int lantiq_sflash_se(u8 *addr)
+{
+	return lantiq_usif_sflash_session(spi_sflash,
+		spi_sflash->erase_opcode, addr, 0, NULL, 0, NULL, 0);
+}
+
+static INLINE int lantiq_sflash_pp(u8 *addr, u8 *buf, u32 len)
+{
+	u8 cmd = LANTIQ_OPCODE_PP;
+	return lantiq_usif_sflash_session(spi_sflash,
+		cmd, addr, 0, buf, len, NULL, 0);
+}
+
+static INLINE int lantiq_sflash_rd(u8 *addr, u8 *buf, u32 len)
+{
+	u8 cmd = LANTIQ_OPCODE_READ;
+	return lantiq_usif_sflash_session(spi_sflash, cmd, addr,
+		spi_sflash->dummy_cycles, NULL, 0, buf, len);
+}
+
+static INLINE int lantiq_spi_read(u32 saddr, u8 *buf, u32 len)
+{
+	int ret;
+	u8 addr[LANTIQ_MAX_ADDRESS_NUM] = { 0 };
+
+	u32_to_u8_addr(saddr, addr);
+	ret = lantiq_sflash_rd(addr, buf, len);
+	return ret;
+}
+
+static INLINE int lantiq_spi_write(u32 saddr, u8 *buf, u32 len)
+{
+	int ret;
+	u8 addr[LANTIQ_MAX_ADDRESS_NUM] = { 0 };
+
+	u32_to_u8_addr(saddr, addr);
+	lantiq_sflash_wren();
+	ret = lantiq_sflash_pp(addr, buf, len);
+	return ret;
+}
+
+static INLINE int lantiq_spi_sector_erase(u32 saddr)
+{
+	u8 addr[LANTIQ_MAX_ADDRESS_NUM] = { 0 };
+
+	u32_to_u8_addr(saddr, addr);
+	lantiq_sflash_wren();
+	return lantiq_sflash_se(addr);
+}
+
+static INLINE int lantiq_spi_chip_erase(void)
+{
+	u8 cmd = LANTIQ_OPCODE_CHIP_ERASE;
+
+	lantiq_sflash_wren();
+	return lantiq_usif_sflash_session(spi_sflash, cmd, NULL, 0, NULL, 0,
+		NULL, 0);
+}
+
+/**
+ * \fn static int lantiq_usif_flash_probe(lantiq_usif_spi_dev_t *pdev)
+ * \brief Detect serial flash device
+ *
+ * \param[in]  pdev   Pointer to lantiq_usif_spi_dev_t
+ * \return   -l  Failed to detect device
+ * \return    0  OK
+ * \ingroup LANTIQ_USIF_SFLASH_INTERNAL
+ */
+static int __init lantiq_usif_flash_probe(lantiq_usif_spi_dev_t *pdev)
+{
+	int i;
+	u16 dev_id;
+	u8 cmd = LANTIQ_OPCODE_RDID;
+
+	lantiq_usif_spiLock(pdev->sflash_handler);
+	/* Send the request for the part identification */
+	lantiq_usif_spiTx(pdev->sflash_handler, &cmd, sizeof(cmd));
+	/* Now read in the manufacturer id bytes */
+	do {
+		lantiq_usif_spiRx(pdev->sflash_handler, &pdev->manufacturer_id, 1);
+		if (pdev->manufacturer_id == 0x7F)
+			printk(KERN_WARNING
+			"Warning: unhandled manufacturer continuation byte!\n");
+
+	} while (pdev->manufacturer_id == 0x7F);
+
+	/* Now read in the first device id byte */
+	lantiq_usif_spiRx(pdev->sflash_handler, &pdev->device_id1, 1);
+	/* Now read in the second device id byte */
+	lantiq_usif_spiRx(pdev->sflash_handler, &pdev->device_id2, 1);
+	lantiq_usif_spiUnlock(pdev->sflash_handler);
+	dev_id = (pdev->device_id1 << 8) | pdev->device_id2;
+	LANTIQ_SFLASH_PRINT("Vendor %02x Type %02x sig %02x\n",
+		 pdev->manufacturer_id, pdev->device_id1,
+		 pdev->device_id2);
+	for (i = 0; i < ARRAY_SIZE(flash_manufacturers); ++i) {
+		if (pdev->manufacturer_id == flash_manufacturers[i].id)
+			break;
+
+	}
+	if (i == ARRAY_SIZE(flash_manufacturers))
+		goto unknown;
+
+	pdev->manufacturer =
+		(struct lantiq_usif_sflash_manufacturer_info *)
+		&flash_manufacturers[i];
+	for (i = 0; pdev->manufacturer->flashes[i].id; ++i) {
+		if (dev_id == pdev->manufacturer->flashes[i].id)
+			break;
+
+	}
+	if (!pdev->manufacturer->flashes[i].id)
+		goto unknown;
+
+
+	pdev->flash = &pdev->manufacturer->flashes[i];
+	pdev->sector_size = pdev->flash->sector_size;
+	pdev->num_sectors = pdev->flash->num_sectors;
+	pdev->dummy_cycles = LANTIQ_FAST_READ_DUMMY_BYTE;
+	pdev->write_length = LANTIQ_FLASH_PAGESIZE;
+
+	pdev->size = pdev->sector_size * pdev->num_sectors;
+
+	LANTIQ_SFLASH_PRINT("SPI Device: %s 0x%02X (%s) 0x%02X 0x%02X\n"
+		 "Parameters: num sectors = %lu, sector size = %lu,"
+		 " write size = %u\n",
+		 pdev->flash->name, pdev->manufacturer_id,
+		 pdev->manufacturer->name, pdev->device_id1,
+		 pdev->device_id2, pdev->num_sectors,
+		 pdev->sector_size, pdev->write_length);
+	return 0;
+unknown:
+	printk(KERN_INFO "Unknown SPI device: 0x%02X 0x%02X 0x%02X\n",
+		pdev->manufacturer_id, pdev->device_id1, pdev->device_id2);
+	return -1;
+}
+
+static INLINE int
+lantiq_spi_flash_cs_handler(u32 csq, LANTIQ_USIF_SPI_CS_DATA_t cs_data)
+{
+	if (csq == LANTIQ_USIF_SPI_CS_ON)
+		return lantiq_usif_spi_cs_low(cs_data);
+	else
+		return lantiq_usif_spi_cs_high(cs_data);
+
+}
+
+static INLINE void lantiq_spi_flash_version(void)
+{
+	char ver_str[128] = { 0 };
+
+	lantiq_drv_ver(ver_str, "USIF SPI flash", LANTIQ_USIF_SFLASH_VER_MAJOR,
+		LANTIQ_USIF_SFLASH_VER_MID, LANTIQ_USIF_SFLASH_VER_MINOR);
+	printk(KERN_INFO "%s", ver_str);
+}
+
+/**
+ * \fn static int lantiq_usif_flash_read(struct mtd_info *mtd, loff_t from,
+ *       size_t len, size_t *retlen ,u_char *buf)
+ * \brief Read from the serial flash device.
+ *
+ * \param[in]  mtd    Pointer to struct mtd_info
+ * \param[in]  from   Start offset in flash device
+ * \param[in]  len    Amount to read
+ * \param[out] retlen About of data actually read
+ * \param[out] buf    Buffer containing the data
+ * \return     0      No need to read actually or read successfully
+ * \return     -EINVAL invalid read length
+ * \ingroup LANTIQ_USIF_SFLASH_OS
+ */
+static int
+lantiq_usif_flash_read(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	int total = 0;
+	int len_this_lp;
+	u32 addr;
+	u8 *mem;
+
+	LANTIQ_SFLASH_PRINT("(from = 0x%.8x, len = %d)\n", (u32) from,
+			 (int) len);
+	if (!len)
+		return 0;
+	if ((from + len) > mtd->size)
+		return -EINVAL;
+	down(&lantiq_sflash_sem);
+	/* Fragment support */
+	while (total < len) {
+		mem = (u8 *) (buf + total);
+		addr = from + total;
+		len_this_lp =
+			min((len - total),
+			(size_t) LANTIQ_USIF_SFLASH_FRAGSIZE);
+		lantiq_spi_read(addr, mem, len_this_lp);
+		total += len_this_lp;
+	}
+
+	*retlen = len;
+	up(&lantiq_sflash_sem);
+	return 0;
+}
+
+/**
+ * \fn static int lantiq_usif_flash_write(struct mtd_info *mtd, loff_t to, size_t len,
+ *                   size_t *retlen, const u_char *buf)
+ * \brief Read from the serial flash device.
+ *
+ * \param[in]  mtd    Pointer to struct mtd_info
+ * \param[in]  to   Start offset in flash device
+ * \param[in]  len    Amount to write
+ * \param[out] retlen Amount of data actually written
+ * \param[out] buf    Buffer containing the data
+ * \return     0      No need to read actually or read successfully
+ * \return      -EINVAL invalid read length
+ * \ingroup LANTIQ_USIF_SFLASH_OS
+ */
+static int
+lantiq_usif_flash_write(struct mtd_info *mtd, loff_t to, size_t len,
+		     size_t *retlen, const u_char *buf)
+{
+	int total = 0, len_this_lp, bytes_this_page;
+	u32 addr = 0;
+	u8 *mem;
+
+	LANTIQ_SFLASH_PRINT("(to = 0x%.8x, len = %d)\n", (u32) to, len);
+
+	if (retlen)
+		*retlen = 0;
+
+	/* sanity check */
+	if (len == 0)
+		return 0;
+
+
+	if ((to + len) > mtd->size)
+		return -1;
+
+	down(&lantiq_sflash_sem);
+	while (total < len) {
+		mem = (u8 *) (buf + total);
+		addr = to + total;
+		bytes_this_page =
+			spi_sflash->write_length -
+			(addr % spi_sflash->write_length);
+		len_this_lp = min((len - total), (size_t) bytes_this_page);
+		lantiq_spi_write(addr, mem, len_this_lp);
+		total += len_this_lp;
+	}
+	*retlen = len;
+	up(&lantiq_sflash_sem);
+	return 0;
+}
+
+/**
+ * \fn static int lantiq_usif_flash_erase(struct mtd_info *mtd,struct erase_info *instr)
+ * \brief Erase pages of serial flash device.
+ *
+ * \param[in]  mtd    Pointer to struct mtd_info
+ * \param[in]  instr  Pointer to struct erase_info
+ * \return     0      OK
+ * \return     -EINVAL invalid erase size
+ * \ingroup LANTIQ_USIF_SFLASH_OS
+ */
+static int
+lantiq_usif_flash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	u32 addr, len;
+	uint32_t rem;
+
+	LANTIQ_SFLASH_PRINT("(addr = 0x%llx, len = %lld)\n",
+		(long long) instr->addr, (long long) instr->len);
+
+	if ((instr->addr + instr->len) > mtd->size)
+		return -EINVAL;
+
+	div_u64_rem(instr->len, mtd->erasesize, &rem);
+	if (rem)
+		return -EINVAL;
+
+	addr = instr->addr;
+	len = instr->len;
+
+	down(&lantiq_sflash_sem);
+	/* whole-chip erase? */
+	if (len == mtd->size) {
+		LANTIQ_SFLASH_PRINT("%lldKiB\n", (long long) (mtd->size >> 10));
+
+		if (lantiq_spi_chip_erase() != 0) {
+			instr->state = MTD_ERASE_FAILED;
+			up(&lantiq_sflash_sem);
+			return -EIO;
+		}
+	} else {
+		/* REVISIT in some cases we could speed up erasing large regions
+		 * by using OPCODE_SE instead of OPCODE_BE_4K.  We may have set
+		 * up to use "small sector erase", but that's not always optimal
+		 */
+		while (len) {
+			if (lantiq_spi_sector_erase(addr) != 0) {
+				instr->state = MTD_ERASE_FAILED;
+				up(&lantiq_sflash_sem);
+				return -EIO;
+			}
+			addr += mtd->erasesize;
+			len -= mtd->erasesize;
+		}
+	}
+	up(&lantiq_sflash_sem);
+
+	/* Inform MTD subsystem that erase is complete */
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+	LANTIQ_SFLASH_PRINT("return\n");
+	return 0;
+}
+
+static INLINE LANTIQ_USIF_SPI_HANDLE_t lantiq_spi_flash_register(char *dev_name)
+{
+	LANTIQ_USIF_SPI_CONFIGURE_t usif_cfg = { 0 };
+
+	usif_cfg.baudrate = LANTIQ_USIF_SFLASH_BAUDRATE;
+	usif_cfg.csset_cb = lantiq_spi_flash_cs_handler;
+	usif_cfg.cs_data = LANTIQ_USIF_SFLASH_CS;
+	usif_cfg.fragSize = LANTIQ_USIF_SFLASH_FRAGSIZE;
+	usif_cfg.maxFIFOSize = LANTIQ_USIF_SFLASH_MAXFIFOSIZE;
+	usif_cfg.spi_mode = LANTIQ_USIF_SFLASH_MODE;
+	usif_cfg.spi_prio = LANTIQ_USIF_SFLASH_PRIORITY;
+	usif_cfg.duplex_mode = LANTIQ_USIF_SPI_HALF_DUPLEX;
+	return lantiq_usif_spiAllocConnection(dev_name, &usif_cfg);
+}
+
+static INLINE int lantiq_spi_flash_size_to_index(u32 size)
+{
+	int i;
+	int index = LANTIQ_FLASH_128KB;
+
+	i = (size >> 17); /* 128 KB minimum */
+	if (i <= 1)
+		index = LANTIQ_FLASH_128KB;
+	else if (i <= 2)
+		index = LANTIQ_FLASH_256KB;
+	else if (i <= 4)
+		index = LANTIQ_FLASH_512KB;
+	else if (i <= 8)
+		index = LANTIQ_FLASH_1MB;
+	else if (i <= 16)
+		index = LANTIQ_FLASH_2MB;
+	else if (i <= 32)
+		index = LANTIQ_FLASH_4MB;
+	else if (i <= 64)
+		index = LANTIQ_FLASH_8MB;
+	else if (i <= 128)
+		index = LANTIQ_FLASH_16MB;
+	else
+		index = LANTIQ_SPI_MAX_FLASH;
+
+	return index;
+}
+
+static INLINE void lantiq_spi_flash_gpio_init(void)
+{
+	//lantiq_gpio_register(LANTIQ_GPIO_MODULE_USIF_SPI_SFLASH);
+}
+
+static INLINE void lantiq_spi_flash_gpio_release(void)
+{
+	//lantiq_gpio_deregister(LANTIQ_GPIO_MODULE_USIF_SPI_SFLASH);
+}
+
+static int __init lantiq_usif_spi_flash_init(void)
+{
+	LANTIQ_USIF_SPI_HANDLE_t *sflash_handler;
+	struct mtd_info *mtd;
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	int np;
+#endif /* CONFIG_MTD_CMDLINE_PARTS */
+	int ret = 0;
+	int index;
+
+	sema_init(&lantiq_sflash_sem, 1);
+	lantiq_spi_flash_gpio_init();
+	spi_sflash = kmalloc(sizeof(lantiq_usif_spi_dev_t), GFP_KERNEL);
+	if (spi_sflash == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	memset(spi_sflash, 0, sizeof(lantiq_usif_spi_dev_t));
+	/*
+	 * Make sure tx buffer address is DMA burst length aligned and
+	 * 2 page size< 512> should be enouhg for serial flash. In this
+	 * way, host cpu can make good use of DMA operation.
+	 */
+	spi_sflash->flash_tx_org_buf =
+		kmalloc(LANTIQ_SFLASH_MAX_WRITE_SIZE +
+			LANTIQ_SFLASH_DMA_MAX_BURST_LEN - 1, GFP_KERNEL);
+	if (spi_sflash->flash_tx_org_buf == NULL) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+	spi_sflash->flash_tx_buf =
+		(char *) (((u32) (spi_sflash->flash_tx_org_buf +
+			LANTIQ_SFLASH_DMA_MAX_BURST_LEN - 1))
+			& ~(LANTIQ_SFLASH_DMA_MAX_BURST_LEN - 1));
+
+	/*
+	 * Make sure rx buffer address is DMA burst length aligned and 8 page
+	 * size< 2KB> should be enouhg for serial flash. In this way,
+	 * host cpu can make good use of DMA operation.
+	 */
+	spi_sflash->flash_rx_org_buf =
+		kmalloc(LANTIQ_SFLASH_MAX_READ_SIZE +
+			LANTIQ_SFLASH_DMA_MAX_BURST_LEN - 1, GFP_KERNEL);
+	if (spi_sflash->flash_rx_org_buf == NULL) {
+		ret = -ENOMEM;
+		goto err2;
+	}
+	spi_sflash->flash_rx_buf =
+		(char *) (((u32) (spi_sflash->flash_rx_org_buf +
+			LANTIQ_SFLASH_DMA_MAX_BURST_LEN - 1))
+			& ~(LANTIQ_SFLASH_DMA_MAX_BURST_LEN - 1));
+
+	spi_sflash->addr_cycles = LANTIQ_SFLASH_ADDR_CYCLES;
+
+	mtd = kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
+	if (mtd == NULL) {
+		printk(KERN_WARNING "%s Cant allocate mtd stuff\n",
+			__func__);
+		ret = -ENOMEM;
+		goto err3;
+	}
+	memset(mtd, 0, sizeof(struct mtd_info));
+
+	sflash_handler = lantiq_spi_flash_register(LANTIQ_USIF_SFLASH_NAME);
+	if (sflash_handler == NULL) {
+		printk(KERN_WARNING "%s: failed to register sflash\n",
+			__func__);
+		ret = -ENOMEM;
+		goto err4;
+	}
+
+	spi_sflash->sflash_handler = sflash_handler;
+	if (lantiq_usif_flash_probe(spi_sflash) != 0) {
+		printk(KERN_WARNING "%s: Found no serial flash device\n",
+			__func__);
+		ret = -ENXIO;
+		goto err5;
+	}
+
+	mtd->name = LANTIQ_USIF_SFLASH_NAME;
+	mtd->type = MTD_NORFLASH;
+	mtd->flags = (MTD_CAP_NORFLASH | MTD_WRITEABLE);
+	mtd->size = spi_sflash->size;
+	/* Prefer "small sector" erase if possible */
+	if (spi_sflash->flash->flags & SECT_4K) {
+		spi_sflash->erase_opcode = LANTIQ_OPCODE_BE_4K;
+		mtd->erasesize = 4096;
+	} else {
+		spi_sflash->erase_opcode = LANTIQ_OPCODE_SE;
+		mtd->erasesize = spi_sflash->sector_size;
+	}
+
+	mtd->numeraseregions = 0;
+	mtd->eraseregions = NULL;
+
+	mtd->owner = THIS_MODULE;
+
+	mtd->writesize = 1; /* like NOR flash, should be 1 */
+
+
+	mtd->_erase = lantiq_usif_flash_erase;
+	mtd->_read = lantiq_usif_flash_read;
+	mtd->_write = lantiq_usif_flash_write;
+
+	index = lantiq_spi_flash_size_to_index(spi_sflash->size);
+	if (index > LANTIQ_SPI_MAX_FLASH) {
+		printk(KERN_WARNING
+			"%s: flash size is too big to support\n", __func__);
+		ret = -EINVAL;
+		goto err5;
+	}
+#ifdef LANTIQ_SPI_FLASH_DBG
+	printk(KERN_DEBUG
+		"mtd->name = %s\n"
+		"mtd->size = 0x%.8x (%uM)\n"
+		"mtd->erasesize = 0x%.8x (%uK)\n"
+		"mtd->numeraseregions = %d\n"
+		"mtd index %d\n",
+		mtd->name,
+		mtd->size, mtd->size / (1024 * 1024),
+		mtd->erasesize, mtd->erasesize / 1024,
+		mtd->numeraseregions, index);
+
+	if (mtd->numeraseregions) {
+		int result;
+
+		for (result = 0; result < mtd->numeraseregions; result++) {
+			printk(KERN_DEBUG
+				"\n\n"
+				"mtd->eraseregions[%d].offset = 0x%.8x\n"
+				"mtd->eraseregions[%d].erasesize = 0x%.8x (%uK)\n"
+				"mtd->eraseregions[%d].numblocks = %d\n",
+				result, mtd->eraseregions[result].offset,
+				result, mtd->eraseregions[result].erasesize,
+				mtd->eraseregions[result].erasesize / 1024,
+				result,
+				mtd->eraseregions[result].numblocks);
+		}
+	}
+#endif /* LANTIQ_SPI_FLASH_DBG */
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	np = parse_mtd_partitions(mtd, part_probes,
+		&spi_sflash->parsed_parts, 0);
+	if (np > 0) {
+		add_mtd_partitions(mtd, spi_sflash->parsed_parts, np);
+	} else {
+		printk(KERN_ERR
+			"%s: No valid partition table found in command line\n",
+			__func__);
+		goto err5;
+	}
+#else
+	add_mtd_partitions(mtd, g_lantiq_mtd_spi_partitions[index],
+		ARRAY_SIZE(g_lantiq_mtd_spi_partitions[index]));
+#endif /* CONFIG_MTD_CMDLINE_PARTS */
+
+	spi_sflash->mtd = mtd;
+	lantiq_spi_flash_version();
+	return ret;
+err5:
+	lantiq_usif_spiFreeConnection(spi_sflash->sflash_handler);
+err4:
+	kfree(mtd);
+err3:
+	kfree(spi_sflash->flash_rx_org_buf);
+err2:
+	kfree(spi_sflash->flash_tx_org_buf);
+err1:
+	kfree(spi_sflash);
+done:
+	lantiq_spi_flash_gpio_release();
+	return ret;
+}
+
+static void __exit lantiq_usif_spi_flash_exit(void)
+{
+	if (spi_sflash != NULL) {
+		if (spi_sflash->parsed_parts != NULL)
+			del_mtd_partitions(spi_sflash->mtd);
+
+		kfree(spi_sflash->mtd);
+		lantiq_usif_spiFreeConnection(spi_sflash->sflash_handler);
+		kfree(spi_sflash->flash_rx_org_buf);
+		kfree(spi_sflash->flash_tx_org_buf);
+		kfree(spi_sflash);
+	}
+	lantiq_spi_flash_gpio_release();
+}
+
+module_init(lantiq_usif_spi_flash_init);
+module_exit(lantiq_usif_spi_flash_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Chuanhua.Lei@infineon.com");
+MODULE_SUPPORTED_DEVICE("Serial flash 25 types generic driver");
+MODULE_DESCRIPTION("IFAP USIF SPI flash device driver");
diff --git a/drivers/spi/lantiq_usif_sflash.h b/drivers/spi/lantiq_usif_sflash.h
new file mode 100644
--- /dev/null
+++ b/drivers/spi/lantiq_usif_sflash.h
@@ -0,0 +1,158 @@
+/******************************************************************************
+**
+** FILE NAME    : ltqmips_usif_sflash.h
+** PROJECT      : IFX UEIP
+** MODULES      : Serial Flash
+**
+** DATE         : 16 Oct 2009
+** AUTHOR       : Lei Chuanhua
+** DESCRIPTION  : SPI Flash MTD Driver
+** COPYRIGHT    :       Copyright (c) 2009
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+**  16,Oct,2009 Lei Chuanhua   Initial UEIP release
+*******************************************************************************/
+/*!
+  \file ltqmips_usif_sflash.h
+  \ingroup LANTIQ_USIF_SFLASH
+  \brief ifx usif serial flash driver header
+*/
+#ifndef LTQMIPS_USIF_SFLASH_H
+#define LTQMIPS_USIF_SFLASH_H
+
+#include <lantiq_usif_spi.h>
+
+/* Flash related definition */
+#define LANTIQ_FLASH_128KB   0
+#define LANTIQ_FLASH_256KB   1
+#define LANTIQ_FLASH_512KB   2
+#define LANTIQ_FLASH_1MB     3
+#define LANTIQ_FLASH_2MB     4
+#define LANTIQ_FLASH_4MB     5
+#define LANTIQ_FLASH_8MB     6
+#define LANTIQ_FLASH_16MB    7
+#define LANTIQ_SPI_MAX_FLASH 8
+#define LANTIQ_FLASH_INVALID_SIZE -1
+
+#define LANTIQ_FLASH_PAGESIZE      256
+
+/* Flash opcodes. */
+#define LANTIQ_OPCODE_WREN         0x06 /* Write enable */
+#define LANTIQ_OPCODE_RDSR         0x05 /* Read status register */
+#define LANTIQ_OPCODE_NORM_READ    0x03 /* Read data bytes (low frequency) */
+#define LANTIQ_OPCODE_FAST_READ    0x0b /* Read data bytes (high frequency) */
+#define LANTIQ_OPCODE_PP           0x02 /* Page program (up to 256 bytes) */
+#define LANTIQ_OPCODE_BE_4K        0x20 /* Erase 4KiB block */
+#define LANTIQ_OPCODE_BE_32K       0x52 /* Erase 32KiB block */
+#define LANTIQ_OPCODE_CHIP_ERASE   0xc7 /* Erase whole flash chip */
+#define LANTIQ_OPCODE_SE           0xd8 /* Sector erase (usually 64KiB) */
+#define LANTIQ_OPCODE_RDID         0x9f /* Read JEDEC ID */
+
+#define LANTIQ_MAX_ADDRESS_NUM     5
+#define LANTIQ_MAX_DUMMY_CYCLES    10
+
+/* Status Register bits. */
+#define LANTIQ_SR_WIP          1 /* Write in progress */
+#define LANTIQ_SR_WEL          2 /* Write enable latch */
+/* meaning of other SR_* bits may differ between vendors */
+#define LANTIQ_SR_BP0          4 /* Block protect 0 */
+#define LANTIQ_SR_BP1          8 /* Block protect 1 */
+#define LANTIQ_SR_BP2          0x10 /* Block protect 2 */
+#define LANTIQ_SR_SRWD         0x80 /* SR write protect */
+
+#define LANTIQ_SFLASH_DETECT_COUNTER   100000
+
+/* Define max times to check status register before we give up. */
+#define	LANTIQ_MAX_READY_WAIT_JIFFIES (10 * HZ)
+
+/*
+ * 32 should be maximum requirement for DMA alignment at the low level,
+ * keep it here for future change
+ */
+#define LANTIQ_SFLASH_DMA_MAX_BURST_LEN    32
+#define LANTIQ_SFLASH_MAX_WRITE_SIZE      (LANTIQ_FLASH_PAGESIZE * 2)
+#define LANTIQ_SFLASH_MAX_READ_SIZE       (LANTIQ_FLASH_PAGESIZE * 8)
+
+#define LANTIQ_SFLASH_MAX_FLASH_TYPE 15 /* Per Vendor */
+
+/* Define fast read/normal read, fast read for higher frequence*/
+#define CONFIG_SPI_FLASH_SLOW_READ
+
+
+#ifdef CONFIG_SPI_FLASH_SLOW_READ
+#define LANTIQ_OPCODE_READ  LANTIQ_OPCODE_NORM_READ
+#define LANTIQ_FAST_READ_DUMMY_BYTE  0
+#else
+#define LANTIQ_OPCODE_READ  LANTIQ_OPCODE_FAST_READ
+#define LANTIQ_FAST_READ_DUMMY_BYTE  1
+#endif
+
+struct lantiq_usif_sflash_info {
+	char *name;
+
+	/* JEDEC id zero means "no ID" (most older chips); otherwise it has
+	 * a high byte of zero plus three data bytes: the manufacturer id,
+	 * then a two byte device id.
+	 */
+	u16 id;
+	/* The size listed here is what works with LANTIQ_OPCODE_SE, which isn't
+	 * necessarily called a "sector" by the vendor.
+	 */
+	unsigned int sector_size;
+	u16 num_sectors;
+	u16 flags;
+#define SECT_4K     0x01 /* LANTIQ_OPCODE_BE_4K works uniformly */
+};
+
+struct lantiq_usif_sflash_manufacturer_info {
+	char *name;
+	u8 id;
+	struct lantiq_usif_sflash_info flashes[LANTIQ_SFLASH_MAX_FLASH_TYPE];
+};
+
+enum {
+	JED_MANU_SPANSION = 0x01,
+	JED_MANU_ST = 0x20,
+	JED_MANU_SST = 0xBF,
+	JED_MANU_ATMEL = 0x1F,
+	JED_MANU_WINBOND = 0xEF,
+	JED_MANU_MX = 0xC2,
+};
+
+/* Driver private data */
+typedef struct {
+	struct mtd_info *mtd;
+	struct mtd_partition *parsed_parts;	/* parsed partitions */
+	char *flash_tx_org_buf;	/* Original write buffer */
+	char *flash_tx_buf;	/* Aligned write buffer */
+	char *flash_rx_org_buf;	/* Orignal read buffer */
+	char *flash_rx_buf;	/* Aligned read buffer */
+	u8 addr_cycles;
+	LANTIQ_USIF_SPI_HANDLE_t sflash_handler;
+	struct lantiq_usif_sflash_manufacturer_info *manufacturer;
+	struct lantiq_usif_sflash_info *flash;
+	u8 erase_opcode;
+	u8 manufacturer_id, device_id1, device_id2;
+	unsigned int write_length;
+	unsigned long sector_size, num_sectors, size;
+	int dummy_cycles;
+} lantiq_usif_spi_dev_t;
+
+#ifdef CONFIG_USIF_SPI_XRX200
+#include "lantiq_usif_sflash_vr9.h"
+#elif defined CONFIG_USIF_SPI_XRX300
+#include "lantiq_usif_sflash_ar10.h"
+#else
+#error "Platform not specified!"
+#endif
+
+#endif /* LTQMIPS_USIF_SFLASH_H */
+
diff --git a/drivers/spi/lantiq_usif_sflash_ar10.h b/drivers/spi/lantiq_usif_sflash_ar10.h
new file mode 100644
--- /dev/null
+++ b/drivers/spi/lantiq_usif_sflash_ar10.h
@@ -0,0 +1,35 @@
+/****************************************************************************
+*                             Copyright (c) 2010
+*                           Lantiq Deutschland GmbH
+&                    Am Campeon 3; 85579 Neubiberg, Germany
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+ *****************************************************************************/
+/*!
+  \file ltqmips_usif_sflash_ar10.h
+  \ingroup LANTIQ_USIF_SFLASH
+  \brief ifx usif serial flash driver AR10 specific file
+*/
+
+#ifndef LTQMIPS_USIF_SFLASH_AR10_H
+#define LTQMIPS_USIF_SFLASH_AR10_H
+
+#define LANTIQ_USIF_SFLASH_MODE                LANTIQ_USIF_SPI_MODE_0
+#define LANTIQ_USIF_SFLASH_PRIORITY            LANTIQ_USIF_SPI_PRIO_LOW
+#define LANTIQ_USIF_SFLASH_FRAGSIZE            264
+
+#define LANTIQ_USIF_SFLASH_MAXFIFOSIZE         32
+
+#ifdef CONFIG_USE_EMULATOR
+#define LANTIQ_USIF_SFLASH_BAUDRATE            10000 /*  10K Hz */
+/* MXIC */
+#define LANTIQ_USIF_SFLASH_CS                  LANTIQ_USIF_SPI_CS0
+#else
+#define LANTIQ_USIF_SFLASH_BAUDRATE            20000000 /*  20 MHz */
+#define LANTIQ_USIF_SFLASH_CS                  LANTIQ_USIF_SPI_CS0
+#endif /* CONFIG_USE_EMULATOR */
+
+#endif /* LTQMIPS_USIF_SFLASH_AR10_H */
+
diff --git a/drivers/spi/lantiq_usif_sflash_vr9.h b/drivers/spi/lantiq_usif_sflash_vr9.h
new file mode 100644
--- /dev/null
+++ b/drivers/spi/lantiq_usif_sflash_vr9.h
@@ -0,0 +1,49 @@
+/******************************************************************************
+**
+** FILE NAME    : ltqmips_usif_sflash_vr9.h
+** PROJECT      : IFX UEIP
+** MODULES      : Serial Flash
+**
+** DATE         : 16 Oct 2009
+** AUTHOR       : Lei Chuanhua
+** DESCRIPTION  : SPI Flash vr9 specific configuration
+** COPYRIGHT    :       Copyright (c) 2009
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+**  03,July,2009 Lei Chuanhua   Initial UEIP release
+*******************************************************************************/
+/*!
+  \file ltqmips_usif_sflash_vr9.h
+  \ingroup LANTIQ_USIF_SFLASH
+  \brief ifx usif serial flash driver VRX specific file
+*/
+
+#ifndef LTQMIPS_USIF_SFLASH_VR9_H
+#define LTQMIPS_USIF_SFLASH_VR9_H
+
+#define LANTIQ_USIF_SFLASH_MODE                LANTIQ_USIF_SPI_MODE_0
+#define LANTIQ_USIF_SFLASH_PRIORITY            LANTIQ_USIF_SPI_PRIO_LOW
+#define LANTIQ_USIF_SFLASH_FRAGSIZE            264
+#define LANTIQ_USIF_SFLASH_MAXFIFOSIZE         32
+
+#ifdef CONFIG_USE_EMULATOR
+#define LANTIQ_USIF_SFLASH_BAUDRATE            10000/*  10K Hz */
+/* MXIC */
+#define LANTIQ_USIF_SFLASH_CS                  LANTIQ_USIF_SPI_CS0
+
+#else
+#define LANTIQ_USIF_SFLASH_BAUDRATE            20000000 /*  20 MHz */
+
+#define LANTIQ_USIF_SFLASH_CS                  LANTIQ_USIF_SPI_CS2
+#endif /* CONFIG_USE_EMULATOR */
+
+#endif /* LTQMIPS_USIF_SFLASH_VR9_H */
+
diff --git a/drivers/spi/lantiq_usif_spi.c b/drivers/spi/lantiq_usif_spi.c
new file mode 100644
--- /dev/null
+++ b/drivers/spi/lantiq_usif_spi.c
@@ -0,0 +1,4141 @@
+/******************************************************************************
+**
+** FILE NAME    : ltqmips_usif_spi.c
+** PROJECT      : IFX UEIP
+** MODULES      : USIF for SPI
+**
+** DATE         : 03 June 2009
+** AUTHOR       : Lei Chuanhua
+** DESCRIPTION  : USIF for SPI Master/Slave
+** COPYRIGHT    :       Copyright (c) 2009
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+** HISTORY
+** $Date        $Author         $Comment
+** 03 Jun,2009  Lei Chuanhua    Initial version
+*******************************************************************************/
+/*!
+  \file ltqmips_usif_spi.c
+  \ingroup LANTIQ_USIF_SPI
+  \brief usif spi driver source file
+*/
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <asm/div64.h>
+
+/* Project header */
+#include <lantiq_soc.h>
+#include <lantiq_dma.h>
+
+#include "lantiq_usif_spi_intern.h"
+
+#undef CONFIG_PROC_FS
+
+#define LANTIQ_USIF_SPI_VER_MAJOR          1
+#define LANTIQ_USIF_SPI_VER_MID            3
+#define LANTIQ_USIF_SPI_VER_MINOR          2
+
+#define LANTIQ_USIF_SPI_NAME             "lantiq_usif_spi"
+
+#define LANTIQ_USIF_SPI_MAX_BAUD          50000000
+#define LANTIQ_USIF_SPI_HALF_BAUD         25000000
+#define LANTIQ_USIF_SPI_1MHZ_BAUD         1000000
+
+#ifdef CONFIG_LANTIQ_USIF_SPI_DEBUG
+#define INLINE
+enum {
+	USIF_MSG_TX_FIFO = 0x00000001,
+	USIF_MSG_TX_DMA = 0x00000002,
+	USIF_MSG_RX_FIFO = 0x00000004,
+	USIF_MSG_RX_DMA = 0x00000008,
+	USIF_MSG_INT = 0x00000010, /* Interrupt msg */
+	USIF_MSG_CFG = 0x00000020,
+	USIF_MSG_THREAD = 0x00000040,
+	USIF_MSG_TASKLET = 0x00000080,
+	USIF_MSG_DEBUG = 0x00000100,
+	USIF_MSG_ERROR = 0x00000200,
+	USIF_MSG_INIT = 0x00000400, /* Initialization msg */
+	USIF_MSG_QUEUE = 0x00000800,
+	USIF_MSG_LOCK = 0x00001000,
+	USIF_MSG_CALLBACK = 0x00002000,
+	USIF_MSG_DUPLEX = 0x00004000,
+	USIF_MSG_ANY = 0xffffffff, /* anything */
+};
+static void lantiq_usif_spi_debug(struct lantiq_usif_port *port, const char *fmt,
+		...);
+
+#define LANTIQ_USIF_PRINT(_port, _m, _fmt, args...) do { \
+	if ((_port)->usif_debug & (_m)) {              \
+		lantiq_usif_spi_debug((_port), (_fmt), ##args);\
+	} \
+} while (0)
+
+#else
+#define INLINE inline
+#define LANTIQ_USIF_PRINT(_port, _m, _fmt, ...)
+#endif /* CONFIG_LANTIQ_USIF_SPI_DEBUG */
+
+static unsigned int lantiq_get_usif_hz(void);
+
+static struct lantiq_usif_port lantiq_usif_spi_port;
+
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry *lantiq_usif_spi_proc = NULL;
+static const char lantiq_usif_spi_proc_node_name[] = "driver/lantiq_usif_spi";
+#endif
+
+/**
+ * \fn static void lantiq_usif_spi_start_tasklet(struct lantiq_usif_port *port)
+ * \brief Trigger different schedule procedures according to different
+ *  context. if caller is already in tasklet, it will be done in caller's
+ *  tasklet
+ *
+ * \param   port       Pointer to structure #lantiq_usif_port
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static void lantiq_usif_spi_start_tasklet(struct lantiq_usif_port *port)
+{
+	struct tasklet_struct *ptasklet;
+
+	/*
+	 * Calls the internal process to serve the queue. This routine would
+	 * immediately return in case the USIF hardware is currently used to
+	 * serve another request.
+	 */
+	ptasklet = &port->usif_txrxq;
+	if (in_irq()) { /* Hardware irq */
+		LANTIQ_USIF_PRINT(port, USIF_MSG_INT,
+			"%s hardware irq schedule\n", __func__);
+		tasklet_hi_schedule(ptasklet);
+	} else if (in_softirq()) { /* Softirq or tasklet */
+		LANTIQ_USIF_PRINT(port, USIF_MSG_TASKLET,
+			"%s softirq schedule\n", __func__);
+		if (tasklet_trylock(ptasklet)) { /* tasklet_trylock for SMP */
+			ptasklet->func(ptasklet->data);
+			tasklet_unlock(ptasklet);
+		} else {
+			LANTIQ_USIF_PRINT(port, USIF_MSG_TASKLET,
+				"%s should never happen\n", __func__);
+		}
+	} else { /* Process  context */
+		LANTIQ_USIF_PRINT(port, USIF_MSG_THREAD,
+			"%s process schedule\n", __func__);
+		tasklet_schedule(ptasklet);
+	}
+}
+
+
+#ifdef CONFIG_LANTIQ_USIF_SPI_DEBUG
+/**
+ * \fn static void lantiq_usif_spi_debug(struct lantiq_usif_port *port,
+ *     const char *fmt, ...)
+ * \brief Debug all kinds of level message
+ *
+ * \param   port    Pointer to structure #lantiq_usif_port
+ * \param   fmt     debug output format
+ *
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static void
+lantiq_usif_spi_debug(struct lantiq_usif_port *port, const char *fmt, ...)
+{
+	static char buf[256] = { 0 }; /* XXX */
+	va_list ap;
+#ifdef CONFIG_LANTIQ_USIF_SPI_ASYNCHRONOUS
+	static const char *p = "tasklet";
+#else
+	static const char *p = "kthread";
+#endif /* CONFIG_LANTIQ_USIF_SPI_ASYNCHRONOUS */
+	va_start(ap, fmt);
+	vsnprintf(buf, sizeof(buf), fmt, ap);
+	va_end(ap);
+
+	printk(KERN_INFO "%s %s: %s\n", p, port->name, buf);
+}
+#endif /* CONFIG_LANTIQ_USIF_SPI_DEBUG */
+
+/**
+ * \fn static INLINE void lantiq_usif_spi_wait_tx_finished
+ *     (struct lantiq_usif_port *port)
+ * \brief Wait for SPI bus becomes idle, FIFO empty doesn't means spi bus idle.
+ *        to start another transaction, need to make sure bus is idle
+ *
+ * \param   port    Pointer to structure #lantiq_usif_port
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE void
+lantiq_usif_spi_wait_tx_finished(struct lantiq_usif_port *port)
+{
+	/* Only TX_FIN can make sure that there is no activity in serial bus */
+	while ((LANTIQ_USIF_GET_RAW_INT_STATUS(port)
+		& LANTIQ_USIF_INT_TX_FIN) == 0)
+	LANTIQ_USIF_PRINT(port, USIF_MSG_TX_FIFO,
+				"%s TX FIFO Poll\n", __func__);
+
+	/* Prepare for the next transaction */
+	LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_TX_FIN, port);
+}
+
+#if 0
+#define BASIC_INPUT_CLOCK_FREQUENCY     36000000
+#define CGU_PLL0_CFG 0x4
+#define GET_BITS(x, msb, lsb)               \
+    (((x) >> (lsb)) & ((1 << ((msb) + 1 - (lsb))) - 1))
+#define CGU_PLL0_CFG_PLLN GET_BITS(ltq_cgu_r32(CGU_PLL0_CFG), 13, 6)
+#define CGU_PLL0_CFG_PLLM GET_BITS(ltq_cgu_r32(CGU_PLL0_CFG), 5, 2)
+
+static inline u32 cal_dsm(int pll, u32 num, u32 den)
+{
+    u64 res;
+
+    res =  BASIC_INPUT_CLOCK_FREQUENCY * num;
+    do_div(res, den);
+
+    return res;
+}
+
+static unsigned int lantiq_get_usif_hz(void)
+{
+	unsigned int pll0_fosc = 0;
+	unsigned int cgu_pll0_cfg, plln, pllm;
+
+	cgu_pll0_cfg = ltq_cgu_r32(CGU_PLL0_CFG);
+
+	printk ("cgu_pll0_cfg = %x\n", cgu_pll0_cfg);
+
+	if (!(cgu_pll0_cfg & (1 << 0)))
+		return 0;
+	if (ltq_cgu_r32(CGU_PLL0_CFG) & (1 << 30))
+		pll0_fosc = BASIC_INPUT_CLOCK_FREQUENCY;
+	else
+	{
+		plln = CGU_PLL0_CFG_PLLN;
+		pllm = CGU_PLL0_CFG_PLLM;
+		printk ("plln = %u pllm = %u\n", plln, pllm);
+		pll0_fosc = cal_dsm(0, 2*(plln + 1), pllm + 1);
+	}
+
+	printk ("pll0_fosc = %u\n", pll0_fosc);
+    return (pll0_fosc / 10);
+	//return (100000000);
+}
+#endif
+
+#if 1
+static unsigned int lantiq_get_usif_hz(void)
+{
+	return (100000000);
+}
+#endif
+
+/**
+ * \fn static INLINE unsigned int lantiq_usif_spi_get_kernel_clk
+ *     (struct lantiq_usif_port *port)
+ * \brief Get USIF SPI clock speed.
+ * Returns the current operating speed of the USIF peripheral,
+ * depending on chip
+ * specific bus speed and RMC setting in CLC register.
+ *
+ * \param   port     Pointer to structure #lantiq_usif_port
+ * \return  >0       Peripheral speed in HZ
+ * \return  0        Error
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE unsigned int
+lantiq_usif_spi_get_kernel_clk(struct lantiq_usif_port *port)
+{
+	/* This function assumes that the CLC register is set with the
+	 * appropriate value for RMC.
+	 */
+	unsigned int rmc;
+
+	rmc = MS(LANTIQ_USIF_GET_CLOCK_COUNTER(port), LANTIQ_USIF_CLC_CNT_RMC);
+	if (rmc == 0) {
+		printk(KERN_ERR "%s rmc==0\n", __func__);
+		return 0;
+	}
+	printk ("USIF: ifx_get_usif_hz returned: %u and rmc: %u\n", (unsigned int) lantiq_get_usif_hz (), rmc);
+	return (unsigned int) (lantiq_get_usif_hz() / rmc);
+}
+
+#ifdef CONFIG_PROC_FS
+/**
+ * \fn static int lantiq_usif_spi_stats_read(char *page, char **start,
+ *     off_t offset, int count, int *eof, void *data)
+ * \brief USIF SPI proc file read.
+ * This function creates the proc file output for the USIF SPI statistics.
+ *
+ * \param   page     Buffer to write the string to
+ * \param   start    not used (Linux internal)
+ * \param   offset   not used (Linux internal)
+ * \param   count    not used (Linux internal)
+ * \param   eof      Set to 1 when all data is stored in buffer
+ * \param   data     not used (Linux internal)
+ * \return  len      Lenght of data in buffer
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static int
+lantiq_usif_spi_stats_read(char *page, char **start, off_t offset, int count,
+			int *eof, void *data)
+{
+	int off = 0;
+	lantiq_usif_port_t *port;
+	lantiq_usif_device_t *dev;
+	LANTIQ_USIF_SPI_STAT_t *stats;
+
+	port = &lantiq_usif_spi_port;
+	stats = &port->stats;
+
+	off += sprintf(page + off, "Statistics for USIF SPI\n\n");
+	off += sprintf(page + off, "USIF%d\n", port->port_idx);
+	off += sprintf(page + off, "RX overflow errors %d\n",
+		stats->rxOvErr);
+	off += sprintf(page + off, "RX underflow errors %d\n",
+		stats->rxUnErr);
+	off += sprintf(page + off, "TX overflow errors %d\n",
+		stats->txOvErr);
+	off += sprintf(page + off, "TX underflow errors %d\n",
+		stats->txUnErr);
+	off += sprintf(page + off, "Abort errors %d\n", stats->abortErr);
+	off += sprintf(page + off, "Mode errors %d\n", stats->modeErr);
+	off += sprintf(page + off, "RX Bytes %llu\n", stats->rxBytes);
+	off += sprintf(page + off, "TX Bytes %llu\n", stats->txBytes);
+	off += sprintf(page + off, "TX FIFO transaction %llu\n",
+		stats->txFifo);
+	off += sprintf(page + off, "TX DMA transaction %llu\n",
+		stats->txDma);
+	off += sprintf(page + off, "TX DMA bytes %llu\n",
+		stats->txDmaBytes);
+	off += sprintf(page + off, "RX FIFO transaction %llu\n",
+		stats->rxFifo);
+	off += sprintf(page + off, "RX DMA transaction %llu\n",
+		stats->rxDma);
+	off += sprintf(page + off, "RX DMA bytes %llu\n",
+		stats->rxDmaBytes);
+	off += sprintf(page + off, "USIF bus status %s\n",
+		port->usif_cs_locked ? "locked" : "unlocked");
+	off += sprintf(page + off, "\n");
+
+	/* Per device statistics */
+	LANTIQ_USIF_SPI_SEM_LOCK(port->dev_sem);
+	TAILQ_FOREACH(dev, &port->usif_devq, dev_entry) {
+		off += sprintf(page + off, "Device %s duplex %s:\n",
+			dev->dev_name, (dev->duplex ==
+			LANTIQ_USIF_SPI_HALF_DUPLEX) ? "Half" : "Full");
+		off += sprintf(page + off, "Rx Bytes %llu\n",
+			dev->stats.rxBytes);
+		off += sprintf(page + off, "Tx Bytes %llu\n",
+			dev->stats.txBytes);
+		off += sprintf(page + off, "Context errors %d\n",
+			dev->stats.context_err);
+		off += sprintf(page + off, "Duplicated qentry errors %d\n",
+			dev->stats.dup_qentries);
+		off += sprintf(page + off, "Fragment errors %d\n",
+			dev->stats.frag_err);
+		off += sprintf(page + off, "Handler errors %d\n",
+			dev->stats.handler_err);
+		off += sprintf(page + off, "Duplex errors %d\n",
+			dev->stats.dlx_err);
+		off += sprintf(page + off, "Enqueue %llu\n",
+			       dev->stats.enqueue);
+		off += sprintf(page + off, "Dequeue %llu\n",
+			dev->stats.dequeue);
+	}
+	LANTIQ_USIF_SPI_SEM_UNLOCK(port->dev_sem);
+	*eof = 1;
+	return off;
+}
+
+/**
+ * \fn static int lantiq_usif_spi_reg_read(char *page, char **start,
+ *     off_t offset, int count, int *eof, void *data)
+ * \brief USIF SPI proc file read.
+ * This function creates the proc file output for the USIF SPI register dump.
+ *
+ * \param   page     Buffer to write the string to
+ * \param   start    not used (Linux internal)
+ * \param   offset   not used (Linux internal)
+ * \param   count    not used (Linux internal)
+ * \param   eof      Set to 1 when all data is stored in buffer
+ * \param   data     not used (Linux internal)
+ * \return  len      Lenght of data in buffer
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static int
+lantiq_usif_spi_reg_read(char *page, char **start, off_t offset, int count,
+		  int *eof, void *data)
+{
+	int off = 0;
+	lantiq_usif_port_t *port;
+#define LANTIQ_USIF_SPI_REG_MAX  24
+	u32 stats[LANTIQ_USIF_SPI_REG_MAX] = { 0 };
+
+	port = &lantiq_usif_spi_port;
+
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+	stats[0] = LANTIQ_USIF_GET_ID(port);
+	stats[1] = LANTIQ_USIF_GET_SWC_ID(port);
+	stats[2] = LANTIQ_USIF_GET_FIFO_ID(port);
+	stats[3] = LANTIQ_USIF_GET_CLOCK_COUNTER(port);
+	stats[4] = LANTIQ_USIG_GET_CLOCK_STATUS(port);
+	stats[5] = LANTIQ_USIF_GET_MODE_CONFIG(port);
+	stats[6] = LANTIQ_USIF_GET_PROTOCOL_CONFIG(port);
+	stats[7] = LANTIQ_USIF_GET_PROTOCOL_STATUS(port);
+	stats[8] = LANTIQ_USIF_GET_CHIPSELECT_CONFIG(port);
+	stats[9] = LANTIQ_USIF_GET_FRAC_DIV(port);
+	stats[10] = LANTIQ_USIF_GET_BAUDRATE_COUNTER(port);
+	stats[11] = LANTIQ_USIF_GET_INTERCHARACTER_TIMEOUT(port);
+	stats[12] = LANTIQ_USIF_GET_FIFO_CONFIG(port);
+	stats[13] = LANTIQ_USIF_GET_FIFO_STATUS(port);
+	stats[14] = LANTIQ_USIF_GET_TXD_SIDEBAND_CONFIG(port);
+	stats[15] = LANTIQ_USIF_GET_DPLUS_STATUS(port);
+	stats[16] = LANTIQ_USIF_GET_TX_WORD(port);
+	if (LANTIQ_USIG_GET_CLOCK_STATUS(port) & LANTIQ_USIF_CLC_STAT_RUN)
+		stats[17] = LANTIQ_USIF_GET_RX_WORD(port);
+
+	stats[18] = LANTIQ_USIF_GET_RX_MRPS(port);
+	stats[19] = LANTIQ_USIF_GET_RAW_INT_STATUS(port);
+	stats[20] = LANTIQ_USIF_GET_INT_MASK(port);
+	stats[21] = LANTIQ_USIF_GET_INT_STATUS(port);
+
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+
+	off += sprintf(page + off, "Register dump for USIF SPI\n\n");
+	off += sprintf(page + off, "USIF_ID           0x%08x\n", stats[0]);
+	off += sprintf(page + off, "USIF_SWCID        0x%08x\n", stats[1]);
+	off += sprintf(page + off, "USIF_FIFO_ID      0x%08x\n", stats[2]);
+
+	off += sprintf(page + off, "USIF_CLC_CNT      0x%08x\n", stats[3]);
+	off += sprintf(page + off, "USIF_CLC_STAT     0x%08x\n", stats[4]);
+
+	off += sprintf(page + off, "USIF_MODE_CFG     0x%08x\n", stats[5]);
+	off += sprintf(page + off, "USIF_PRTC_CFG     0x%08x\n", stats[6]);
+	off += sprintf(page + off, "USIF_PRTC_STAT    0x%08x\n", stats[7]);
+
+	off += sprintf(page + off, "USIF_CS_CFG       0x%08x\n", stats[8]);
+	off += sprintf(page + off, "USIF_FDIV_CFG     0x%08x\n", stats[9]);
+	off += sprintf(page + off, "USIF_BC_CFG       0x%08x\n",
+		       stats[10]);
+	off += sprintf(page + off, "USIF_ICTMO_CFG    0x%08x\n",
+		       stats[11]);
+	off += sprintf(page + off, "USIF_FIFO_CFG     0x%08x\n",
+		       stats[12]);
+	off += sprintf(page + off, "USIF_FIFO_STAT    0x%08x\n",
+		       stats[13]);
+	off += sprintf(page + off, "USIF_TXD_SB       0x%08x\n",
+		       stats[14]);
+	off += sprintf(page + off, "USIF_DPLUS_STAT   0x%08x\n",
+		       stats[15]);
+	off += sprintf(page + off, "USIF_TXD          0x%08x\n",
+		       stats[16]);
+	off += sprintf(page + off, "USIF_RXD          0x%08x\n",
+		       stats[17]);
+	off += sprintf(page + off, "USIF_MRPS_CTRL    0x%08x\n",
+		       stats[18]);
+	off += sprintf(page + off, "USIF_RIS          0x%08x\n",
+		       stats[19]);
+	off += sprintf(page + off, "USIF_IMSC         0x%08x\n",
+		       stats[20]);
+	off += sprintf(page + off, "USIF_MIS          0x%08x\n",
+		       stats[21]);
+	off += sprintf(page + off, "\n");
+
+	*eof = 1;
+	return off;
+#undef LANTIQ_USIF_SPI_REG_MAX
+}
+
+/**
+ * \fn static inline int lantiq_usif_spi_proc_version(char *page,
+ *     char **start, off_t offset, int count, int *eof, void *data)
+ * \brief USIF SPI proc version.
+ * This function creates the proc file output for the USIF SPI driver.
+ *
+ * \param   page     Buffer to write the string to
+ * \param   start    not used (Linux internal)
+ * \param   offset   not used (Linux internal)
+ * \param   count    not used (Linux internal)
+ * \param   eof      Set to 1 when all data is stored in buffer
+ * \param   data     not used (Linux internal)
+ * \return  len      Lenght of data in buffer
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static inline int
+lantiq_usif_spi_proc_version(char *page, char **start, off_t offset,
+		     int count, int *eof, void *data)
+{
+	int len = 0;
+
+	/* No sanity check because length is smaller than one page */
+	len += lantiq_usif_spi_drv_ver(page + len);
+	*eof = 1;
+	return len;
+}
+
+/**
+ * \fn static int lantiq_usif_spi_proc_create(void)
+ * \brief Create USIF SPI proc/drivers node
+ *
+ * \return  -EFAULT Failed to create proc node
+ * \return  0       Create proc node successfully
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static int lantiq_usif_spi_proc_create(void)
+{
+	int ret = 0;
+	struct proc_dir_entry *entry;
+
+	lantiq_usif_spi_proc = proc_mkdir(lantiq_usif_spi_proc_node_name, NULL);
+	if (lantiq_usif_spi_proc == NULL) {
+		printk(KERN_ERR
+			"%s:  Unable to create proc entry for %s\n",
+			__func__, lantiq_usif_spi_proc_node_name);
+		ret = -EFAULT;
+		goto done;
+	}
+	entry = create_proc_read_entry("version",
+		0, lantiq_usif_spi_proc, lantiq_usif_spi_proc_version, NULL);
+	if (entry == NULL) {
+		ret = -EFAULT;
+		goto err1;
+	}
+
+	entry = create_proc_read_entry("stats",
+		0, lantiq_usif_spi_proc, lantiq_usif_spi_stats_read, NULL);
+	if (entry == NULL) {
+		ret = -EFAULT;
+		goto err2;
+	}
+	entry = create_proc_read_entry("reg",
+		0, lantiq_usif_spi_proc, lantiq_usif_spi_reg_read, NULL);
+	if (entry == NULL) {
+		ret = -EFAULT;
+		goto err3;
+	}
+	return ret;
+
+err3:
+	remove_proc_entry("stats", lantiq_usif_spi_proc);
+err2:
+	remove_proc_entry("version", lantiq_usif_spi_proc);
+err1:
+	remove_proc_entry(lantiq_usif_spi_proc_node_name, NULL);
+done:
+	return ret;
+}
+
+/**
+ * \fn static void lantiq_usif_spi_proc_delete(void)
+ * \brief Delete USIF SPI proc/drivers node
+ *
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static void lantiq_usif_spi_proc_delete(void)
+{
+	remove_proc_entry("version", lantiq_usif_spi_proc);
+
+	remove_proc_entry("stats", lantiq_usif_spi_proc);
+
+	remove_proc_entry("reg", lantiq_usif_spi_proc);
+
+	remove_proc_entry(lantiq_usif_spi_proc_node_name, NULL);
+}
+#endif
+
+static inline int lantiq_drv_ver(char *buf, char *module, int major, int mid, int minor)
+{
+    return sprintf(buf, "Lantiq %s driver, version %d.%d.%d, (c) 2001-2013 Lantiq Deutschland GmbH\n",
+	        module, major, mid, minor);
+}
+
+/**
+ * \fn static INLINE int lantiq_usif_spi_drv_ver(char *buf)
+ * \brief Display USPI SPI driver version after initilazation succeeds
+ *
+ * \return number of bytes will be printed
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE int lantiq_usif_spi_drv_ver(char *buf)
+{
+
+	return lantiq_drv_ver(buf, "USIF-SPI", LANTIQ_USIF_SPI_VER_MAJOR,
+		LANTIQ_USIF_SPI_VER_MID, LANTIQ_USIF_SPI_VER_MINOR);
+}
+
+/**
+ * \fn static void lantiq_usif_spi_dma_setup(struct lantiq_usif_port *port,
+ *     int dir, int enabled)
+ *
+ * \brief Setup dma direction and enable/disable
+ *
+ * \param   port        Pointer to structure #lantiq_usif_port
+ * \param   dir         DMA Direction, tx/rx, tx&rx
+ * \param   enabled     DMA enable/disable
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static void
+lantiq_usif_spi_dma_setup(struct lantiq_usif_port *port, int dir, int enabled)
+{
+	u32 reg = 0;
+	LANTIQ_USIF_SPI_CONFIGURE_t *usif_cfg;
+	lantiq_usif_device_t *current_dev = port->current_dev;
+	struct dma_device_info *dma_dev = port->dma_dev;
+	static const u32 dplus_def_setting = LANTIQ_USIF_DPLUS_CTRL_TX_DIS
+		| LANTIQ_USIF_DPLUS_CTRL_RX_MASK |
+		LANTIQ_USIF_DPLUS_CTRL_SET_MASK;
+
+	usif_cfg = &current_dev->conn_id;
+
+	reg = dplus_def_setting;
+
+	if (dir == LANTIQ_USIF_SPI_DIR_RX) { /* RX */
+		if (enabled) {
+			/* CSX<0~2> mapping to RX Class, this class must
+			  go to D+ interface */
+			reg &= ~(1 << (usif_cfg->cs_data +
+				 LANTIQ_USIF_DPLUS_CTRL_RX_MASK_OFFSET));
+			/* Change USIF SPI RX DMA channel class according
+			   to CSX<0~2> */
+			dma_device_setup_class_val(
+				dma_dev->rx_chan[dma_dev->current_rx_chan],
+					usif_cfg->cs_data);
+		} else { /* BPI interface */
+			reg |= (1 << (usif_cfg->cs_data +
+				 LANTIQ_USIF_DPLUS_CTRL_RX_MASK_OFFSET));
+			/* Change USIF SPI RX DMA channel class according
+			   to CSX<0~2> */
+			dma_device_setup_class_val(
+				dma_dev->rx_chan[dma_dev->current_rx_chan], 0);
+		}
+	} else if (dir == LANTIQ_USIF_SPI_DIR_TX) {/* TX */
+		if (enabled) {
+			reg &= ~LANTIQ_USIF_DPLUS_CTRL_TX_DIS;
+			reg |= LANTIQ_USIF_DPLUS_CTRL_TX_EN;
+		} else {
+			reg &= ~LANTIQ_USIF_DPLUS_CTRL_TX_EN;
+			reg |= LANTIQ_USIF_DPLUS_CTRL_TX_DIS;
+		}
+		/*
+		 * XXX, auto chipselect, tx class information
+		 * At present, auto chipselection disabled,
+		 * TX Class will always use CLASS0
+		 */
+	} else { /* TXRX */
+		if (enabled) {
+			/* CSX<0~2> mapping to RX Class, this class must
+			   go to D+ interface */
+			reg &= ~(1 << (usif_cfg->cs_data +
+				LANTIQ_USIF_DPLUS_CTRL_RX_MASK_OFFSET));
+			/* Change USIF SPI RX DMA channel class
+			   according to CSX<0~2> */
+			dma_device_setup_class_val(
+				dma_dev->rx_chan[dma_dev->current_rx_chan],
+				usif_cfg->cs_data);
+			reg &= ~LANTIQ_USIF_DPLUS_CTRL_TX_DIS;
+			reg |= LANTIQ_USIF_DPLUS_CTRL_TX_EN;
+		} else {
+			reg |= (1 << (usif_cfg->cs_data +
+				 LANTIQ_USIF_DPLUS_CTRL_RX_MASK_OFFSET));
+			/* Change USIF SPI RX DMA channel class according
+			*  to CSX<0~2> */
+			dma_device_setup_class_val(
+				dma_dev->rx_chan[dma_dev->current_rx_chan], 0);
+			reg &= ~LANTIQ_USIF_DPLUS_CTRL_TX_EN;
+			reg |= LANTIQ_USIF_DPLUS_CTRL_TX_DIS;
+		}
+	}
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+	LANTIQ_USIF_CONFIG_DPLUS_CONTROL(reg, port);
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+	/* Ensure D+ TX activity finished */
+	if ((dir == LANTIQ_USIF_SPI_DIR_TX)
+		&& (enabled == LANTIQ_USIF_SPI_DMA_DISABLE)) {
+		while ((LANTIQ_USIF_GET_DPLUS_STATUS(port) &
+			LANTIQ_USIF_DPLUS_STAT_TX_ACT)) {
+			;
+		}
+	}
+}
+
+/**
+ * \fn static INLINE void lantiq_usif_spi_dma_irq_finished(struct lantiq_usif_port
+ *     *port)
+ * \brief DMA<TX/RX> interrupt received, this function calls to reschedule
+ * or wake up sleep kernel thread
+ *
+ * \param   port        Pointer to structure #lantiq_usif_port
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE void
+lantiq_usif_spi_dma_irq_finished(struct lantiq_usif_port *port)
+{
+	/*
+	 * Reset the flag that we are waiting for the DMA to complete
+	 * This flag should be reset before the following stuff, otherwise
+	 * start_tasklet will stop
+	 */
+	atomic_set(&port->dma_wait_state, 0);
+	smp_wmb();
+#ifdef CONFIG_LANTIQ_USIF_SPI_ASYNCHRONOUS
+	lantiq_usif_spi_start_tasklet(port);
+#else
+	LANTIQ_USIF_SPI_WAKEUP_EVENT(port->usif_thread_wait,
+		LANTIQ_USIF_SPI_THREAD_EVENT, port->event_flags);
+#endif /* CONFIG_LANTIQ_USIF_SPI_ASYNCHRONOUS */
+}
+
+/**
+ * \fn static int lantiq_usif_spi_dma_int_handler(struct dma_device_info* dma_dev,
+ *     int status)
+ *
+ * \brief Pseudo Interrupt handler for DMA.
+ * This function processes DMA interrupts notified to the USIF device driver.
+ * It is installed at the DMA core as interrupt handler for the USIF SPI DMA
+ * device and handles the following DMA interrupts:
+ * - In case of a DMA receive interrupt the received data is passed to the
+ *   upper layer.
+ *
+ * \param   dma_dev pointer to DMA device structure
+ * \param   status  type of interrupt being notified (RCV_INT: DMA receive
+ *                  interrupt, TX_BUF_FULL_INT: transmit buffer full interrupt,
+ *                  TRANSMIT_CPT_INT: transmission complete interrupt)
+ * \return  OK      In case of successful data reception from DMA
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static int
+lantiq_usif_spi_dma_int_handler(struct dma_device_info *dma_dev, int status)
+{
+	int i;
+	struct lantiq_usif_port *port;
+	u32 dma_burst_len;
+	u32 dma_burst_len_mask;
+
+	port = (struct lantiq_usif_port *) dma_dev->priv;
+	LANTIQ_USIF_PRINT(port, USIF_MSG_INT, "Interrupt status %d\n", status);
+	switch (status) {
+	case RCV_INT:
+		LANTIQ_USIF_PRINT(port, USIF_MSG_INT, "RCV_INT\n");
+		dma_burst_len = (dma_dev->rx_burst_len << 2);
+		dma_burst_len_mask = dma_burst_len - 1;
+		lantiq_usif_spi_dma_setup(port, LANTIQ_USIF_SPI_DIR_TXRX,
+				LANTIQ_USIF_SPI_DMA_DISABLE);
+
+		/* Reset USIF-SPI DMA RX channel */
+		(dma_dev->rx_chan[dma_dev->current_rx_chan])->reset(
+			dma_dev->rx_chan[dma_dev->current_rx_chan]);
+
+		/* HW WAR, if packet length is indivisible by burst length,
+		   memory copy must be used */
+		if ((port->rx_len & dma_burst_len_mask)) {
+			memcpy((char *) port->rxbuf_ptr, port->dma_rxbuf,
+				port->rx_len);
+			/* Reset these for FIFO usage */
+			port->rxbuf_ptr = NULL;
+			port->rx_len = 0;
+		}
+
+		lantiq_usif_spi_dma_irq_finished(port);
+		break;
+
+	case TX_BUF_FULL_INT:
+		for (i = 0; i < dma_dev->max_tx_chan_num; i++) {
+			if ((dma_dev->tx_chan[i])->control ==
+				IFX_DMA_CH_ON) {
+				dma_dev->tx_chan[i]->enable_irq(
+					dma_dev->tx_chan[i]);
+			}
+		}
+		LANTIQ_USIF_PRINT(port, USIF_MSG_INT, "TX_BUF_FULL_INT\n");
+		break;
+
+	case TRANSMIT_CPT_INT:
+		for (i = 0; i < dma_dev->max_tx_chan_num; i++)
+			dma_dev->tx_chan[i]->disable_irq(dma_dev->tx_chan[i]);
+
+		LANTIQ_USIF_PRINT(port, USIF_MSG_INT, "TRANSMIT_CPT_INT\n");
+
+		/*
+		 * 1. NB, Make sure data has been sent out. TX_FIN interrupt
+		 * may take longer time to receive. Polling is better here
+		 * 2. If FDX is used, only RCV_INT will schedule the proccess
+		 * /tasklet.
+		 * HDX device may use FDX mode for RX operation. However,
+		 * for TX, only HDX can be used for HDX device.
+		 */
+		lantiq_usif_spi_wait_tx_finished(port); /* Still needed? */
+		if (port->dma_is_in_half_duplex == 1)
+			lantiq_usif_spi_dma_irq_finished(port);
+
+		break;
+
+	default:
+		printk(KERN_ERR "%s unknow interrupt %d\n", __func__,
+			status);
+		break;
+	}
+	return 0;
+}
+
+/**
+ * \fn static u8* lantiq_usif_spi_dma_buffer_alloc(int len, int* byte_offset,
+ *     void** opt)
+ * \brief Allocates buffer for USIF SPI DMA.
+ * This function is installed as DMA callback function to be called when
+ * the DMA needs to allocate a new buffer.
+ *
+ * \param   len          Length of packet
+ * \param   *byte_offset Pointer to byte offset
+ * \param   **opt        unused
+ * \return  NULL         In case of buffer allocation fails
+ * \return  buffer       Pointer to allocated memory
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static u8 *lantiq_usif_spi_dma_buffer_alloc(int len, int *byte_offset,
+	void **opt)
+{
+	return NULL;
+}
+
+/**
+ * \fn static int lantiq_usif_spi_dma_buffer_free(u8 *dataptr, void *opt)
+ * \brief Free DMA buffer.
+ * This function frees a buffer previously allocated by the DMA.
+ *
+ * \param   *dataptr Pointer to data buffer
+ * \param   *opt     unused
+ * \return  0        OK
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static int lantiq_usif_spi_dma_buffer_free(u8 *dataptr, void *opt)
+{
+	/* SPI will be in charge of memory free if necessary */
+	return 0;
+}
+
+/**
+ * \fn static int lantiq_usif_spi_init_dma_device(struct dma_device_info *dma_dev)
+ * \brief Initialize USIF SPI DMA device.
+ * This function initializes the passed DMA device structure for usage as
+ * USIF SPI DMA device.
+ *
+ * \param   *dma_dev Pointer to dma device structure to be initialized
+ * \return  0        OK
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static int lantiq_usif_spi_init_dma_device(struct dma_device_info *dma_dev)
+{
+	int i;
+
+	dma_dev->priv = &lantiq_usif_spi_port;
+	dma_dev->num_tx_chan = DEFAULT_USIF_SPI_TX_CHANNEL_NUM;
+	dma_dev->num_rx_chan = DEFAULT_USIF_SPI_RX_CHANNEL_NUM;
+	dma_dev->tx_burst_len = DEFAULT_USIF_SPI_TX_BURST_LEN;
+	dma_dev->rx_burst_len = DEFAULT_USIF_SPI_RX_BURST_LEN;
+	dma_dev->port_tx_weight = 1;
+	/* Combined with FIFO TX/RX SWAP */
+	dma_dev->tx_endianness_mode = IFX_DMA_ENDIAN_TYPE3;
+	dma_dev->rx_endianness_mode = IFX_DMA_ENDIAN_TYPE3;
+	dma_dev->port_packet_drop_enable = 0;
+	for (i = 0; i < dma_dev->num_tx_chan; i++) {
+		dma_dev->tx_chan[i]->desc_len =
+			DEFAULT_USIF_SPI_TX_CHANNEL_DESC_NUM;
+		dma_dev->tx_chan[i]->control = IFX_DMA_CH_ON;
+		dma_dev->tx_chan[i]->packet_size =
+			DEFAULT_USIF_SPI_FRAGMENT_SIZE;
+	}
+	for (i = 0; i < dma_dev->num_rx_chan; i++) {
+		dma_dev->rx_chan[i]->desc_len =
+			DEFAULT_USIF_SPI_RX_CHANNEL_DESC_NUM;
+		dma_dev->rx_chan[i]->packet_size =
+			DEFAULT_USIF_SPI_FRAGMENT_SIZE;
+		dma_dev->rx_chan[i]->control = IFX_DMA_CH_ON;
+		dma_dev->rx_chan[i]->byte_offset = 0;
+	}
+	dma_dev->current_tx_chan = 0;
+	dma_dev->current_rx_chan = 0;
+	/*
+	 * set DMA handler functions for rx-interrupts,
+	 * buffer allocation and release
+	 */
+	dma_dev->intr_handler = lantiq_usif_spi_dma_int_handler;
+	dma_dev->buffer_alloc = lantiq_usif_spi_dma_buffer_alloc;
+	dma_dev->buffer_free = lantiq_usif_spi_dma_buffer_free;
+	dma_device_register(dma_dev);
+	return 0;
+}
+
+/**
+ * \fn static INLINE void lantiq_usif_spi_gpio_init(void)
+ * \brief Reserve and initialize GPIO for USIF-SPI.
+ *
+ * Initialize MUX settings to enable SPI interface
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE void lantiq_usif_spi_gpio_init(void)
+{
+	//lantiq_gpio_register(LANTIQ_GPIO_MODULE_USIF_SPI);
+}
+
+/**
+ * \fn static INLINE void lantiq_usif_spi_gpio_release(void)
+ * \brief GPIO release.
+ *
+ * Release reserverd gpio resource so that other module could use it
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE void lantiq_usif_spi_gpio_release(void)
+{
+	//lantiq_gpio_deregister(LANTIQ_GPIO_MODULE_USIF_SPI);
+}
+
+/**
+ * \fn static INLINE void lantiq_usif_spi_clc_cfg_mode(struct lantiq_usif_port *port)
+ * \brief enter configuration mode.
+ *
+ * \param   port    Pointer to structure #lantiq_usif_port
+ *
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE void lantiq_usif_spi_clc_cfg_mode(struct lantiq_usif_port *port)
+{
+	int i;
+#define LANTIQ_USIF_SPI_CLC_CFG_TIMEOUT  10
+	/*
+	 * WAR, read back to make sure the previous write/read to take effect
+	 * before we enter config mode.
+	 * Please note, must be a config register, instead of status register
+	 * Unfortunately, it will not work on emulation platform
+	 */
+#ifndef CONFIG_USE_EMULATOR
+	LANTIQ_USIF_GET_MODE_CONFIG(port);
+#endif /* CONFIG_USE_EMULATOR */
+	LANTIQ_USIF_CLC_CONFIG_MODE(port);
+	for (i = 0; i < LANTIQ_USIF_SPI_CLC_CFG_TIMEOUT; i++) {
+		if ((LANTIQ_USIG_GET_CLOCK_STATUS(port) &
+			LANTIQ_USIF_CLC_STAT_CFG_UPDATE_DONE)
+			== LANTIQ_USIF_CLC_STAT_CFG_UPDATE_DONE) {
+			break;
+		}
+	}
+	if (i >= LANTIQ_USIF_SPI_CLC_CFG_TIMEOUT)
+		printk(KERN_ERR "%s timeout\n", __func__);
+
+#undef LANTIQ_USIF_SPI_CLC_CFG_TIMEOUT
+}
+
+/**
+ * \fn static INLINE void lantiq_usif_spi_clc_run_mode(struct lantiq_usif_port *port)
+ * \brief enter running mode.
+ *
+ * \param   port    Pointer to structure #lantiq_usif_port
+ *
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE void lantiq_usif_spi_clc_run_mode(struct lantiq_usif_port *port)
+{
+	int i;
+#define LANTIQ_USIF_SPI_CLC_RUN_TIMEOUT  10
+
+	/*
+	 * WAR, dummy read back to make sure the previous write/read to take
+	 * effect  before we enter run mode.
+	 * Please note, must be a config register, instead of status register.
+	 * Unfortunately, it will not work on emulation platform
+	 */
+#ifndef CONFIG_USE_EMULATOR
+	LANTIQ_USIF_GET_MODE_CONFIG(port);
+#endif /* CONFIG_USE_EMULATOR */
+	LANTIQ_USIF_CLC_RUN_MODE(port);
+	for (i = 0; i < LANTIQ_USIF_SPI_CLC_RUN_TIMEOUT; i++) {
+		if ((LANTIQ_USIG_GET_CLOCK_STATUS(port) &
+			LANTIQ_USIF_CLC_STAT_RUN_UPDATE_DONE)
+			== LANTIQ_USIF_CLC_STAT_RUN_UPDATE_DONE) {
+			break;
+		}
+	}
+	if (i >= LANTIQ_USIF_SPI_CLC_RUN_TIMEOUT)
+		printk(KERN_ERR "%s timeout\n", __func__);
+
+	/* WAR, for lower baudrate, it still takes some time to
+	*  make configuration to take effect */
+	if (port->baudrate < 1000000)
+		udelay(1000000 / port->baudrate);
+
+#undef LANTIQ_USIF_SPI_CLC_RUN_TIMEOUT
+}
+
+/**
+ * \fn static INLINE int lantiq_usif_spi_rxtx_mode_set(struct lantiq_usif_port *port,
+ *     unsigned int val)
+ * \brief Rx/Tx mode set.
+ * Set the transmission mode while USIF SPI is idle
+ *
+ * \param   port    Pointer to structure #lantiq_usif_port
+ * \param   val     Rx/Tx mode
+ * \return  0       OK
+ * \return  -EINVAL Invalid parameters supplied
+ * \return  -EBUSY  Transmission or reception ongoing
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE int
+lantiq_usif_spi_rxtx_mode_set(struct lantiq_usif_port *port, unsigned int val)
+{
+	u32 bits = 0;
+	u32 reg;
+	int enabled = 0;
+	int force_clk;
+
+	LANTIQ_USIF_PRINT(port, USIF_MSG_DUPLEX,
+				"%s rxtx mode set..\n", __func__);
+	if (unlikely(port == NULL)
+		|| unlikely((val & (LANTIQ_USIF_SPI_MODE_RXTX_MASK)) ==
+			LANTIQ_USIF_SPI_MODE_OFF)) {
+		return -EINVAL;
+	}
+
+	/* Check if there is activity in USIF bus */
+	if (((LANTIQ_USIF_GET_FIFO_STATUS(port) &
+		LANTIQ_USIF_FIFO_STAT_TXRX_FFS_MASK) != 0x00)) {
+		printk(KERN_ERR "%s busy fifo status 0x%08x\n", __func__,
+			LANTIQ_USIF_GET_FIFO_STATUS(port));
+		return -EBUSY;
+	}
+
+	switch (val) {
+	case LANTIQ_USIF_SPI_MODE_RX:
+		bits = LANTIQ_USIF_MODE_CFG_RX_EN;
+		force_clk = 1; /* Force shift clock for RX only */
+		break;
+
+	case LANTIQ_USIF_SPI_MODE_TX:
+		bits = LANTIQ_USIF_MODE_CFG_TX_EN;
+		force_clk = 0;
+		break;
+
+	case LANTIQ_USIF_SPI_MODE_RXTX: /* Fall through */
+	default:
+		bits = LANTIQ_USIF_MODE_CFG_TXRX_EN;
+		force_clk = 0;
+		break;
+	}
+
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+	enabled = LANTIQ_USIG_GET_CLOCK_STATUS(port) & LANTIQ_USIF_CLC_STAT_RUN;
+	if (enabled)
+		lantiq_usif_spi_clc_cfg_mode(port);
+
+	reg = LANTIQ_USIF_GET_MODE_CONFIG(port);
+	reg &= ~LANTIQ_USIF_MODE_CFG_TXRX_MASK;
+
+	reg |= bits;
+
+	if (force_clk == 1)
+		reg |= LANTIQ_USIF_MODE_CFG_SC_FRC;
+	else
+		reg &= ~LANTIQ_USIF_MODE_CFG_SC_FRC;
+	LANTIQ_USIF_SET_MODE_CONFIG(reg, port);
+	if (enabled)
+		lantiq_usif_spi_clc_run_mode(port);
+
+	port->opts.modeRxTx = val;
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+
+	LANTIQ_USIF_PRINT(port, USIF_MSG_DUPLEX,
+				"%s rxtx mode set finished..\n", __func__);
+	return 0;
+}
+
+/**
+ * \fn static int lantiq_usif_spi_sethwopts(struct lantiq_usif_port *port)
+ * \brief USIF SPI set hardware options.
+ * This routine intializes the USIF SPI appropriately depending on
+ * slave/master and full-/half-duplex mode. It assumes that the USIF SPI
+ * is disabled and the fifo's and buffers are flushed later on.
+ *
+ * \param   port    Pointer to structure #lantiq_usif_port
+ * \return  0       OK
+ * \return  -EINVAL Invalid hardware options supplied
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static int lantiq_usif_spi_sethwopts(struct lantiq_usif_port *port)
+{
+	u32 reg;
+	u32 mode = 0;
+	u32 prtc = 0;
+	struct lantiq_usif_hwopts *opts = &port->opts;
+
+	if (opts->sync)
+		mode |= LANTIQ_USIF_MODE_CFG_SYNC;
+
+	if (opts->master)
+		mode |= LANTIQ_USIF_MODE_CFG_MA;
+
+	if (opts->frmctl)
+		mode |= LANTIQ_USIF_MODE_CFG_FC_EN;
+
+	if (opts->loopBack)
+		mode |= LANTIQ_USIF_MODE_CFG_LB;
+
+	if (opts->echoMode)
+		mode |= LANTIQ_USIF_MODE_CFG_ECH;
+
+	if (opts->txInvert)
+		mode |= LANTIQ_USIF_MODE_CFG_TX_INV;
+
+	if (opts->rxInvert)
+		mode |= LANTIQ_USIF_MODE_CFG_RX_INV;
+
+	if (opts->shiftClk)
+		mode |= LANTIQ_USIF_MODE_CFG_SC_FRC;
+
+	if (opts->clkPO)
+		mode |= LANTIQ_USIF_MODE_CFG_SC_POL;
+
+	if (opts->clkPH)
+		mode |= LANTIQ_USIF_MODE_CFG_SC_PH;
+
+	if (opts->txIdleValue)
+		mode |= LANTIQ_USIF_MODE_CFG_TX_IDLE;
+
+	switch (opts->modeRxTx) {
+	case LANTIQ_USIF_SPI_MODE_TX:
+		mode |= LANTIQ_USIF_MODE_CFG_TX_EN;
+		break;
+	case LANTIQ_USIF_SPI_MODE_RX:
+		mode |= LANTIQ_USIF_MODE_CFG_RX_EN;
+		break;
+	case LANTIQ_USIF_SPI_MODE_RXTX:
+		mode |= LANTIQ_USIF_MODE_CFG_TXRX_EN;
+		break;
+	default:
+		mode |= LANTIQ_USIF_MODE_CFG_TXRX_EN;
+		break;
+	}
+
+	switch (opts->charLen) {
+	case LANTIQ_USIF_PRTC_CFG_CLEN8:
+		prtc |= LANTIQ_USIF_PRTC_CFG_CLEN8;
+		break;
+	case LANTIQ_USIF_PRTC_CFG_CLEN16:
+		prtc |= LANTIQ_USIF_PRTC_CFG_CLEN16;
+		break;
+	case LANTIQ_USIF_PRTC_CFG_CLEN32:
+		prtc |= LANTIQ_USIF_PRTC_CFG_CLEN32;
+		break;
+	default:
+		prtc |= LANTIQ_USIF_PRTC_CFG_CLEN32;
+		break;
+	}
+
+	if (opts->hdrCtrl)
+		prtc |= LANTIQ_USIF_PRTC_CFG_HD_MSB;
+
+	if (opts->wakeUp)
+		prtc |= LANTIQ_USIF_PRTC_CFG_WK_UP;
+
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+
+	/* Mode configration register, master, sync, mode 0, tx/rx enable  */
+	LANTIQ_USIF_SET_MODE_CONFIG(mode, port);
+
+	/* Protocol configuration register, 4 bytes per character, MSB first */
+	LANTIQ_USIF_SET_PROTOCOL_CONFIG(prtc, port);
+
+	/* Default CS, no auto chip select. Initial value as high */
+	reg = LANTIQ_USIF_CS_CFG_EN;
+	reg |= LANTIQ_USIF_CS_CFG_CSX_DEFAULT;
+	LANTIQ_USIF_SET_CHIPSELECT_CONFIG(reg, port);
+
+	/* Class 0 only, disable D+ TX */
+	LANTIQ_USIF_CONFIG_DPLUS_CONTROL(LANTIQ_USIF_DPLUS_CTRL_TX_DIS |
+		LANTIQ_USIF_DPLUS_CTRL_RX_MASK |
+		LANTIQ_USIF_DPLUS_CTRL_SET_MASK, port);
+
+	/* TX Class information */
+	LANTIQ_USIF_CONFIG_TXD_SIDEBAND(SM(LANTIQ_USIF_TXD_CLASS0,
+		LANTIQ_USIF_TXD_SB_TX_CLS), port);
+
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+	return 0;
+}
+
+/**
+ * \fn int lantiq_usif_spi_cs_low(u32 cs)
+ * \brief Chip select enable.
+ * This function sets the given chip select for USIF SPI to low.
+ *
+ * \param   cs       Selected CS pin
+ * \return  0        OK
+ * \return  -EINVAL  Invalid GPIO pin provided
+ * \ingroup LANTIQ_USIF_SPI_FUNCTIONS
+ */
+int lantiq_usif_spi_cs_low(u32 cs)
+{
+	int ret;
+	u32 reg;
+	int enabled;
+	struct lantiq_usif_port *port = &lantiq_usif_spi_port;
+
+	if (cs > LANTIQ_USIF_SPI_CS_MAX)
+		ret = -EINVAL;
+	else {
+		/* Check if there is activity in USIF bus */
+		if (((LANTIQ_USIF_GET_FIFO_STATUS(port) &
+			LANTIQ_USIF_FIFO_STAT_TXRX_FFS_MASK) != 0x00)) {
+			printk(KERN_ERR "%s is busy\n", __func__);
+			return -EBUSY;
+		}
+		LANTIQ_USIF_SPI_IRQ_LOCK(port);
+		enabled =
+			LANTIQ_USIG_GET_CLOCK_STATUS(port) &
+			LANTIQ_USIF_CLC_STAT_RUN;
+		if (enabled)
+			lantiq_usif_spi_clc_cfg_mode(port);
+
+		reg = LANTIQ_USIF_GET_CHIPSELECT_CONFIG(port);
+		/* Chipboudary CSO = CSO XOR CSOINV, CSOINV is
+		   initialized to 0xff */
+		reg |= (1 << (cs + LANTIQ_USIF_CS_OFFSET));
+		LANTIQ_USIF_SET_CHIPSELECT_CONFIG(reg, port);
+
+		if (enabled)
+			lantiq_usif_spi_clc_run_mode(port);
+		LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+		ret = 0;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(lantiq_usif_spi_cs_low);
+
+/**
+ * \fn int lantiq_usif_spi_cs_high(u32 cs)
+ * \brief Chip select disable.
+ * This function sets the given chip select for USIF SPI to high.
+ *
+ * \param   cs       Selected CS pin
+ * \return  0        OK
+ * \return  -EINVAL  Invalid GPIO pin provided
+ * \ingroup LANTIQ_USIF_SPI_FUNCTIONS
+ */
+int lantiq_usif_spi_cs_high(u32 cs)
+{
+	int ret;
+	int enabled;
+	u32 reg;
+	struct lantiq_usif_port *port = &lantiq_usif_spi_port;
+
+	if (cs > LANTIQ_USIF_SPI_CS_MAX)
+		ret = -EINVAL;
+	else {
+		/* Check if there is activity in USIF bus */
+		if (((LANTIQ_USIF_GET_FIFO_STATUS(port) &
+			LANTIQ_USIF_FIFO_STAT_TXRX_FFS_MASK) != 0x00)) {
+			printk(KERN_ERR "%s is busy\n", __func__);
+			return -EBUSY;
+		}
+		LANTIQ_USIF_SPI_IRQ_LOCK(port);
+		enabled =
+			LANTIQ_USIG_GET_CLOCK_STATUS(port) &
+			LANTIQ_USIF_CLC_STAT_RUN;
+		if (enabled)
+			lantiq_usif_spi_clc_cfg_mode(port);
+
+		reg = LANTIQ_USIF_GET_CHIPSELECT_CONFIG(port);
+		/* Chipboudary CSO = CSO XOR CSOINV, CSOINV
+		*  is initialized to 0xff */
+		reg &= ~(1 << (cs + LANTIQ_USIF_CS_OFFSET));
+		LANTIQ_USIF_SET_CHIPSELECT_CONFIG(reg, port);
+
+		if (enabled)
+			lantiq_usif_spi_clc_run_mode(port);
+
+		LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+		ret = 0;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(lantiq_usif_spi_cs_high);
+
+/**
+ * \fn static void lantiq_usif_spi_start_txfifo(struct lantiq_usif_port *port,
+ *     char *txbuf, u32 txsize)
+ * \brief Start FIFO data transmisssion .
+ * This function copies remaining data in the transmit buffer into the FIFO
+ *
+ * \param   port     Pointer to structure #lantiq_usif_port
+ * \param   txbuf    Pointer to the data packet to transmit
+ * \param   txsize   Amount of Bytes to transmit
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static void
+lantiq_usif_spi_start_txfifo(struct lantiq_usif_port *port, char *txbuf,
+		    u32 txsize)
+{
+	int i;
+	char *p;
+	u32 eff_bytes, eff_word;
+	u32 tx_cnt;
+	u32 *ptxbuf;
+	LANTIQ_USIF_TXD_t txd_data;
+	int total = txsize;
+
+	while (1) {
+
+		/* Wait for TX FIFO empty */
+		while (LANTIQ_USIF_GET_TX_FILL_FIFO(port) != 0x00)
+			;
+
+		/* Optimized the frequest two cases */
+		/* Last one incomlete or complete word */
+		if (total <= LANTIQ_USIF_SPI_TX_FIFO_CHARS_PER_WORD) {
+			eff_bytes = total;
+			for (i = 0, p = txbuf; i < eff_bytes; i++, p++)
+				txd_data.txd_byte.byte[i] = *(u8 *) p;
+
+			LANTIQ_USIF_PUT_TX_LAST_WORD(((eff_bytes ==
+				LANTIQ_USIF_SPI_TX_FIFO_CHARS_PER_WORD) ?
+				LANTIQ_USIF_TXD_BE4 : eff_bytes),
+				txd_data.txd_word, port);
+		/* More than fifo bytes */
+		} else if (total > port->tx_fifo_size_bytes) {
+			eff_bytes = port->tx_fifo_size_bytes;
+			eff_word = port->tx_fifo_size_words;
+			for (i = 0, ptxbuf = (u32 *) txbuf; i < eff_word;
+			     i++, ptxbuf++) {
+				LANTIQ_USIF_PUT_TX_WORD(*ptxbuf, port);
+			}
+		} else { /* 5 ~ 32 bytes */
+			eff_bytes = total;
+			eff_word = (eff_bytes >> 2)
+				+ ((eff_bytes & 0x3) > 0 ? 1 : 0);
+
+			/* Transmit the complete word */
+			for (i = 0, ptxbuf = (u32 *) txbuf;
+			     i < eff_word - 1; i++, ptxbuf++) {
+				LANTIQ_USIF_PUT_TX_WORD(*ptxbuf, port);
+			}
+			tx_cnt = (eff_bytes & 0x3);
+			/* Still one complete word */
+			if (tx_cnt == 0) {
+				/* 4 bytes for one complete word */
+				tx_cnt = LANTIQ_USIF_SPI_TX_FIFO_CHARS_PER_WORD;
+			}
+
+			/* Transmit the last complete or incomplete word */
+			for (i = 0, p = (char *) ptxbuf; i < tx_cnt;
+			     i++, p++) {
+				txd_data.txd_byte.byte[i] = *(u8 *) p;
+			}
+			LANTIQ_USIF_PUT_TX_LAST_WORD((tx_cnt ==
+				LANTIQ_USIF_SPI_TX_FIFO_CHARS_PER_WORD ?
+				LANTIQ_USIF_TXD_BE4 : tx_cnt),
+				txd_data.txd_word, port);
+		}
+
+		txbuf += eff_bytes;
+		total -= eff_bytes;
+		if (total == 0)
+			break;
+
+	}
+}
+
+/**
+ * \fn static void lantiq_usif_spi_start_rxfifo(struct lantiq_usif_port *port,
+ *     char *rxbuf, u32 rxsize)
+ * \brief Start FIFO data reception.
+ * This function processes received data. It will read data from the FIFO and
+ * copy it to the receive buffer.
+ *
+ * \param   port     Pointer to structure #lantiq_usif_port
+ * \param   rxbuf    Pointer to store the received data packet
+ * \param   rxsize   Amount of Bytes to receive.
+ * XXX, RME or calculate the length from the total length
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static void
+lantiq_usif_spi_start_rxfifo(struct lantiq_usif_port *port, char *rxbuf,
+		    u32 rxsize)
+{
+	int i;
+	char *p;
+	u32 eff_bytes, eff_word;
+	int rx_cnt;
+	u32 *prxbuf;
+	LANTIQ_USIF_RXD_t rxd_data;
+	int total = rxsize;
+
+	while (1) {
+		/* In this case, no need to check last complete or
+		   incomplete word */
+		if (total >= port->rx_fifo_size_bytes) {
+			eff_bytes = port->rx_fifo_size_bytes;
+			eff_word = port->rx_fifo_size_words;
+
+			LANTIQ_USIF_CONFIG_RX_MRPS(SM(eff_bytes,
+				LANTIQ_USIF_MRPS_CTRL_MRPS), port);
+			/* Wait for data whose length is equal to FIFO size */
+			while (LANTIQ_USIF_GET_RX_FILL_FIFO(port) != eff_word)
+				LANTIQ_USIF_PRINT(port, USIF_MSG_ERROR,
+					"%s trying to receive eff_words..\n",
+					__func__);
+
+			LANTIQ_USIF_PRINT(port, USIF_MSG_ERROR,
+				"%s received eff_words..\n",
+				__func__);
+			for (i = 0, prxbuf = (u32 *) rxbuf; i < eff_word;
+			     i++, prxbuf++) {
+				*prxbuf = LANTIQ_USIF_GET_RX_WORD(port);
+			}
+		} else {
+			eff_bytes = total;
+			eff_word = (eff_bytes >> 2)
+				+ ((eff_bytes & 0x3) > 0 ? 1 : 0);
+
+			LANTIQ_USIF_CONFIG_RX_MRPS(SM(eff_bytes,
+				LANTIQ_USIF_MRPS_CTRL_MRPS), port);
+			while (LANTIQ_USIF_GET_RX_FILL_FIFO(port) != eff_word)
+				;
+
+			/* Receive complete word */
+			for (i = 0, prxbuf = (u32 *) rxbuf;
+			     i < eff_word - 1; i++, prxbuf++) {
+				*prxbuf = LANTIQ_USIF_GET_RX_WORD(port);
+			}
+
+			/*
+			 * SPI Master know how many bytes to be received
+			 * XXX, a better way to use RME and DPLUS status
+			 * register, but it involves interrupt handling.
+			 */
+			rx_cnt = total - ((eff_word - 1) << 2);
+			/* Last complete word or in complete word */
+			rxd_data.rxd_word = LANTIQ_USIF_GET_RX_WORD(port);
+			for (i = 0, p = (char *) prxbuf; i < rx_cnt;
+			     i++, p++) {
+				*(u8 *) p = rxd_data.rxd_byte.byte[i];
+			}
+		}
+		rxbuf += eff_bytes;
+		total -= eff_bytes;
+		if (total == 0)
+			break;
+	}
+}
+
+/**
+ * \fn static int lantiq_usif_spi_txrx_fifo_fdx(struct lantiq_usif_port *port,
+ *     char *txbuf, u32 txsize, char *rxbuf, u32 rxsize)
+ * \brief Called to transmit/receive to/from USIF SPI in one step using
+ *  FIFO mode.
+ *
+ * \param   port      Pointer to structure #lantiq_usif_port
+ * \param   txbuf     Pointer to the data packet to transmit
+ * \param   txsize    Amount of Bytes to transmit
+ * \param   rxbuf     Pointer to store the received data packet
+ * \param   rxsize    Amount of Bytes to receive.
+ * \return  >= 0      Number of bytes received (if rxbuf != 0) or
+ *                    transmitted
+ * \return  < 0       error number
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static int
+lantiq_usif_spi_txrx_fifo_fdx(struct lantiq_usif_port *port, char *txbuf,
+		     u32 txsize, char *rxbuf, u32 rxsize)
+{
+	int i;
+	char *p;
+	int tx_fifo_space;
+	int rx_fill_space;
+	u32 txtotal = txsize;
+	u32 rxtotal = rxsize;
+	u32 eff_bytes, eff_word;
+	int tx_cnt, rx_cnt;
+	u32 *ptxbuf;
+	u32 *prxbuf;
+	LANTIQ_USIF_TXD_t txd_data;
+	LANTIQ_USIF_RXD_t rxd_data;
+
+	lantiq_usif_spi_dma_setup(port, LANTIQ_USIF_SPI_DIR_TXRX,
+		LANTIQ_USIF_SPI_DMA_DISABLE);
+
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+	while (1) {
+		tx_fifo_space = port->tx_fifo_size_words -
+			LANTIQ_USIF_GET_TX_FILL_FIFO(port);
+		/* No space, wait */
+		if (tx_fifo_space == 0)
+			continue;
+
+		/* Still have more data to transmit, whole words */
+		if (txtotal > (tx_fifo_space << 2)) {
+			eff_bytes = (tx_fifo_space << 2);
+			eff_word = tx_fifo_space;
+
+			LANTIQ_USIF_CONFIG_RX_MRPS(SM(eff_bytes,
+				LANTIQ_USIF_MRPS_CTRL_MRPS), port);
+
+			for (i = 0, ptxbuf = (u32 *) txbuf; i < eff_word;
+			     i++, ptxbuf++) {
+				LANTIQ_USIF_PUT_TX_WORD(*ptxbuf, port);
+			}
+		} else {
+			eff_bytes = txtotal;
+			eff_word = (eff_bytes >> 2)
+				+ ((eff_bytes & 0x3) > 0 ? 1 : 0);
+
+			LANTIQ_USIF_CONFIG_RX_MRPS(SM(eff_bytes,
+				LANTIQ_USIF_MRPS_CTRL_MRPS), port);
+
+			/* Transmit the complete word */
+			for (i = 0, ptxbuf = (u32 *) txbuf;
+			     i < eff_word - 1; i++, ptxbuf++) {
+				LANTIQ_USIF_PUT_TX_WORD(*ptxbuf, port);
+			}
+
+			tx_cnt = (eff_bytes & 0x3);
+
+			/* Still one complete word */
+			if (tx_cnt == 0)
+				tx_cnt = LANTIQ_USIF_SPI_TX_FIFO_CHARS_PER_WORD;
+
+			/* Transmit the last complete or incomplete word */
+			for (i = 0, p = (char *) ptxbuf; i < tx_cnt;
+			     i++, p++) {
+				txd_data.txd_byte.byte[i] = *(u8 *) p;
+			}
+			LANTIQ_USIF_PUT_TX_LAST_WORD((tx_cnt ==
+				LANTIQ_USIF_SPI_TX_FIFO_CHARS_PER_WORD
+				? LANTIQ_USIF_TXD_BE4 : tx_cnt),
+				txd_data.txd_word, port);
+		}
+		txbuf += eff_bytes;
+		txtotal -= eff_bytes;
+
+		/* NB, wait for data to come in, not efficient,
+		   but no RX overrun issue */
+		while (LANTIQ_USIF_GET_RX_FILL_FIFO(port) != eff_word)
+			;
+
+		rx_fill_space = LANTIQ_USIF_GET_RX_FILL_FIFO(port);
+
+		if (rxtotal > (rx_fill_space << 2)) {
+			eff_bytes = (rx_fill_space << 2);
+			eff_word = rx_fill_space;
+			for (i = 0, prxbuf = (u32 *) rxbuf; i < eff_word;
+			     i++, prxbuf++) {
+				*prxbuf = LANTIQ_USIF_GET_RX_WORD(port);
+			}
+		} else { /* At least one word */
+			eff_bytes = rxtotal;
+			eff_word = (eff_bytes >> 2)
+				+ ((eff_bytes & 0x3) > 0 ? 1 : 0);
+			/* Receive complete word */
+			for (i = 0, prxbuf = (u32 *) rxbuf;
+			     i < eff_word - 1; i++, prxbuf++) {
+				*prxbuf = LANTIQ_USIF_GET_RX_WORD(port);
+			}
+			/* SPI Master know how many bytes to be received */
+			rx_cnt = rxtotal - ((eff_word - 1) << 2);
+			rxd_data.rxd_word = LANTIQ_USIF_GET_RX_WORD(port);
+			for (i = 0, p = (char *) prxbuf; i < rx_cnt;
+			     i++, p++) {
+				*(u8 *) p = rxd_data.rxd_byte.byte[i];
+			}
+		}
+		rxbuf += eff_bytes;
+		rxtotal -= eff_bytes;
+
+		/* Both RX/TX finished, break */
+		if ((txtotal == 0) && (rxtotal == 0))
+			break;
+	}
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+	return txsize;
+}
+
+/**
+ * \fn static int lantiq_usif_spi_set_baudrate(struct lantiq_usif_port *port,
+ *     unsigned int baudrate)
+ * \brief USIF SPI set baudrate.
+ * Sets the baudrate of the corresponding port according to the passed
+ * rate after reading out the current module speed.
+ *
+ * \param   port      Pointer to structure #lantiq_usif_port
+ * \param   baudrate  Desired baudrate
+ * \return  0         OK
+ * \return  -EINVAL   Could not retrieve system clock or invalid
+ *                    baudrate setting
+ * \return  -EBUSY    Serial bus still busy
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static int
+lantiq_usif_spi_set_baudrate(struct lantiq_usif_port *port,
+		     unsigned int baudrate)
+{
+	int enabled;
+	unsigned int spi_clock;
+	unsigned int bc = 0;
+
+	if (port->prev_baudrate == baudrate)
+		return 0;
+
+	if ((baudrate > LANTIQ_USIF_SPI_HALF_BAUD)
+		&& (baudrate < LANTIQ_USIF_SPI_MAX_BAUD)) {
+		printk(KERN_ERR "%s: clock < %d ~ %d >not supported\n",
+			__func__, LANTIQ_USIF_SPI_HALF_BAUD,
+			LANTIQ_USIF_SPI_MAX_BAUD);
+		return -EINVAL;
+	}
+
+	spi_clock = lantiq_usif_spi_get_kernel_clk(port);
+	printk ("USIF: spi_clock : %u\n", spi_clock);
+	if (spi_clock == 0)
+		return -EINVAL;
+
+	if ((baudrate != LANTIQ_USIF_SPI_MAX_BAUD)
+		&& (spi_clock >> 2) < baudrate) {
+		printk(KERN_ERR "%s: illegal baudrate %u\n", __func__,
+			baudrate);
+		return -EINVAL;
+	}
+
+	if (baudrate != LANTIQ_USIF_SPI_MAX_BAUD) {
+		/*
+		 * Compute the baud counter
+		 * bc = fkernel/(4 * fbaud) -1 ; not so accurate
+		 * Only half kernel clock is different.
+		 */
+		bc = (((spi_clock >> 2) + baudrate / 2) / baudrate) - 1;
+	}
+	if (bc > 0x1fff || ((bc == 0) &&
+		((LANTIQ_USIF_GET_MODE_CONFIG(port) &
+		LANTIQ_USIF_MODE_CFG_MA) == 0))) {
+		printk(KERN_ERR "%s: illegal baudrate %u br %d\n",
+			__func__, baudrate, bc);
+		return -EINVAL;
+	}
+
+	/* Check if there is activity in USIF bus */
+	if ((LANTIQ_USIF_GET_FIFO_STATUS(port) &
+		LANTIQ_USIF_FIFO_STAT_TXRX_FFS_MASK) != 0x00) {
+		printk(KERN_ERR "%s is busy\n", __func__);
+		return -EBUSY;
+	}
+	port->baudrate = baudrate;
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+	/* Has to be in cfg mode */
+	enabled = LANTIQ_USIG_GET_CLOCK_STATUS(port) & LANTIQ_USIF_CLC_STAT_RUN;
+	if (enabled)
+		lantiq_usif_spi_clc_cfg_mode(port);
+
+
+	/* NB, SPI mode should not use fraction divider */
+	LANTIQ_USIF_FRAC_DIV_CONFIG(0, port);
+
+	/* Half kernel clock, SCDIV = 1, BCRV = 0, fraction divider
+	   must not be used */
+	if (baudrate == LANTIQ_USIF_SPI_MAX_BAUD) {
+		bc = 0;
+		bc |= LANTIQ_USIF_BC_CFG_SCDIV_HALF;
+	}
+	LANTIQ_USIF_BAUDRATE_COUNTER_CONFIG(bc, port);
+
+	if (enabled)
+		lantiq_usif_spi_clc_run_mode(port);
+
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+
+	printk ("USIF: setting baud rate to: %u\n", baudrate);
+	port->prev_baudrate = baudrate;
+	return 0;
+}
+
+/**
+ * \fn static int lantiq_usif_spi_hwinit(struct lantiq_usif_port *port)
+ * \brief USIF SPI hardware initialization.
+ * Initializes the USIF SPI port hardware with the desired baudrate and
+ * transmission options.
+ *
+ * \param   port    Pointer to structure #lantiq_usif_port
+ * \return  0       OK
+ * \return  -EINVAL Error during initialization
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static int lantiq_usif_spi_hwinit(struct lantiq_usif_port *port)
+{
+	u32 reg = 0;
+
+	lantiq_usif_spi_gpio_init();
+
+	/* Enable USIF /AHBS */
+	lantiq_usif_spi_pm_enable();
+
+	/* RMC first */
+	LANTIQ_USIF_SET_CLOCK_COUNTER(
+		SM(LANTIQ_USIF_SPI_DEF_RMC, LANTIQ_USIF_CLC_CNT_RMC) |
+		SM(LANTIQ_USIF_SPI_DEF_ORMC, LANTIQ_USIF_CLC_CNT_ORMC), port);
+
+	/* Switch to USIF configuration mode, module enabled onece  */
+	reg = LANTIQ_USIF_CLC_MOD_EN;
+	LANTIQ_USIF_SET_RUN_CONTROL(reg, port);
+
+	lantiq_usif_spi_clc_cfg_mode(port);
+
+	/* Disable all interrupts. No interrupts at all except DMA */
+	LANTIQ_USIF_SET_INT_MASK(0, port);
+	LANTIQ_USIF_CLR_INT(LANTIQ_USIF_INT_ALL, port);
+
+	if (lantiq_usif_spi_sethwopts(port) < 0) {
+		printk(KERN_ERR
+			"%s: setting the hardware options failed\n",
+		__func__);
+		return -EINVAL;
+	}
+
+	if (lantiq_usif_spi_set_baudrate(port, port->baudrate) < 0) {
+		printk(KERN_ERR "%s: setting the baud rate failed\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+
+	reg = LANTIQ_USIF_SPI_FIFO_SETUP;
+
+	/*
+	 * Enable TX swap and RX swap, must be set so that it is
+	 * compatible with old SSC module.
+	 */
+	reg |= LANTIQ_USIF_FIFO_CFG_TX_SWAP | LANTIQ_USIF_FIFO_CFG_RX_SWAP;
+	/* Configure the TX/RX FIFO */
+	LANTIQ_USIF_SET_FIFO_CONFIG(reg, port);
+
+	/* Switch to USIF working mode */
+	lantiq_usif_spi_clc_run_mode(port);
+
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+
+	/* FIFO information for later use */
+	port->tx_fifo_size_words = LANTIQ_USIF_GET_TX_FIFO_SIZE(port);
+	port->tx_fifo_size_bytes = (port->tx_fifo_size_words << 2);
+	port->rx_fifo_size_words = LANTIQ_USIF_GET_RX_FIFO_SIZE(port);
+	port->rx_fifo_size_bytes = (port->rx_fifo_size_words << 2);
+	return 0;
+#undef LANTIQ_USIF_CLC_MAX_CNT
+}
+
+/**
+ * \fn static INLINE int lantiq_usif_spi_txfifo(struct lantiq_usif_port *port,
+ *     char *txbuf, u32 txsize)
+ * \brief Called to transmit data to USIF SPI using FIFO mode .
+ * \param   port       Pointer to structure #lantiq_usif_port
+ * \param   txbuf      Pointer to the data packet to transmit
+ * \param   txsize     Amount of Bytes to transmit
+ * \return  >= 0       Number of bytes transmitted
+ *          < 0        error number
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE int
+lantiq_usif_spi_txfifo(struct lantiq_usif_port *port, char *txbuf, u32 txsize)
+{
+	LANTIQ_KASSERT(port->opts.modeRxTx == LANTIQ_USIF_SPI_MODE_TX,
+		("%s invalid txrx mode\n", __func__));
+
+	lantiq_usif_spi_dma_setup(port, LANTIQ_USIF_SPI_DIR_TXRX,
+		LANTIQ_USIF_SPI_DMA_DISABLE);
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+	/* Start the transmission */
+	lantiq_usif_spi_start_txfifo(port, txbuf, txsize);
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+
+	return txsize;
+}
+
+/**
+ * \fn static INLINE int lantiq_usif_spi_rxfifo(struct lantiq_usif_port *port,
+ *     char *rxbuf, u32 rxsize)
+ * \brief Called to receive from USIF SPI using FIFO mode .
+ * \param   port       Pointer to structure #lantiq_usif_port
+ * \param   rxbuf      Pointer to store the received data packet
+ * \param   rxsize     Amount of Bytes to receive.
+ * \return  >= 0       Number of bytes received
+ *          < 0        error number
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE int
+lantiq_usif_spi_rxfifo(struct lantiq_usif_port *port, char *rxbuf, u32 rxsize)
+{
+	LANTIQ_KASSERT(port->opts.modeRxTx == LANTIQ_USIF_SPI_MODE_RX,
+		("%s invalid txrx mode\n", __func__));
+
+	lantiq_usif_spi_dma_setup(port, LANTIQ_USIF_SPI_DIR_TXRX,
+		LANTIQ_USIF_SPI_DMA_DISABLE);
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+	lantiq_usif_spi_start_rxfifo(port, rxbuf, rxsize);
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+
+	return rxsize;
+}
+
+/**
+ * \fn static INLINE int lantiq_usif_spi_set_spi_mode(lantiq_usif_device_t *dev)
+ * \brief Sets the spi mode of the corresponding device. USIF SPI mode is
+ * per device parameter. It is initialized during registeration
+ *
+ * \param   dev     Pointer to device
+ * \return  0       OK
+ * \return  -EBUSY  could not set usif spi mode because serial bus is busy
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE int lantiq_usif_spi_set_spi_mode(lantiq_usif_device_t *dev)
+{
+	u32 reg;
+	int val = 0;
+	int enabled = 0;
+	LANTIQ_USIF_SPI_CONFIGURE_t *usif_cfg;
+	struct lantiq_usif_port *port;
+
+	usif_cfg = &dev->conn_id;
+	port = dev->port;
+
+	if (port->prev_spi_mode == usif_cfg->spi_mode)
+		return 0;
+
+
+	/* Check if there is activity in USIF bus */
+	if ((LANTIQ_USIF_GET_FIFO_STATUS(port) &
+		LANTIQ_USIF_FIFO_STAT_TXRX_FFS_MASK) != 0x00) {
+		printk(KERN_ERR "%s is busy\n", __func__);
+		return -EBUSY;
+	}
+
+	switch (usif_cfg->spi_mode) {
+	case LANTIQ_USIF_SPI_MODE_0:
+		val = LANTIQ_USIF_MODE_CFG_SC_PH;
+		break;
+	case LANTIQ_USIF_SPI_MODE_1:
+		val = 0;
+		break;
+	case LANTIQ_USIF_SPI_MODE_2:
+		val = LANTIQ_USIF_MODE_CFG_SC_POL | LANTIQ_USIF_MODE_CFG_SC_PH;
+		break;
+	case LANTIQ_USIF_SPI_MODE_3:
+		val = LANTIQ_USIF_MODE_CFG_SC_POL;
+		break;
+	default:		/* Mode 0 */
+		val = LANTIQ_USIF_MODE_CFG_SC_PH;
+		break;
+	}
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+
+	enabled = LANTIQ_USIG_GET_CLOCK_STATUS(port) & LANTIQ_USIF_CLC_STAT_RUN;
+	if (enabled)
+		lantiq_usif_spi_clc_cfg_mode(port);
+
+	reg = LANTIQ_USIF_GET_MODE_CONFIG(port);
+
+	reg &= ~LANTIQ_USIF_MODE_CFG_SC_MODE_MASK;
+
+	reg |= val;
+	LANTIQ_USIF_SET_MODE_CONFIG(reg, port);
+
+	if (enabled)
+		lantiq_usif_spi_clc_run_mode(port);
+
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+	port->prev_spi_mode = usif_cfg->spi_mode;
+	return 0;
+}
+
+/**
+ * \fn static INLINE void lantiq_usif_spi_tx_setup(struct lantiq_usif_port *port)
+ * \brief USIF SPI set TX mode
+ *
+ * \param   port    Pointer to structure #lantiq_usif_port
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE void lantiq_usif_spi_tx_setup(struct lantiq_usif_port *port)
+{
+	if (port->opts.modeRxTx != LANTIQ_USIF_SPI_MODE_TX)
+		lantiq_usif_spi_rxtx_mode_set(port, LANTIQ_USIF_SPI_MODE_TX);
+}
+
+/**
+ * \fn static INLINE void lantiq_usif_spi_rx_setup(struct lantiq_usif_port *port)
+ * \brief  USIF SPI set RX mode
+ *
+ * \param   port    Pointer to structure #lantiq_usif_port
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE void lantiq_usif_spi_rx_setup(struct lantiq_usif_port *port)
+{
+	if (port->opts.modeRxTx != LANTIQ_USIF_SPI_MODE_RX)
+		lantiq_usif_spi_rxtx_mode_set(port, LANTIQ_USIF_SPI_MODE_RX);
+}
+
+/**
+ * \fn static INLINE void lantiq_usif_spi_txrx_setup(struct lantiq_usif_port *port)
+ * \brief  USIF SPI set TXRX mode/full duplex
+ *
+ * \param   port    Pointer to structure #lantiq_usif_port
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE void lantiq_usif_spi_txrx_setup(struct lantiq_usif_port *port)
+{
+	if (port->opts.modeRxTx != LANTIQ_USIF_SPI_MODE_RXTX)
+		lantiq_usif_spi_rxtx_mode_set(port, LANTIQ_USIF_SPI_MODE_RXTX);
+}
+
+/**
+ * \fn static void lantiq_usif_spi_enqueue(LANTIQ_USIF_QUEUE_t *queue)
+ * \brief USIF add queue entry to priority queue
+ *
+ * \param   queue    Pointer to structure #LANTIQ_USIF_QUEUE_t
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static void lantiq_usif_spi_enqueue(LANTIQ_USIF_QUEUE_t *queue)
+{
+	lantiq_usif_device_t *dev;
+	struct lantiq_usif_port *port;
+
+	LANTIQ_KASSERT((queue != NULL),
+		("%s should never happen\n", __func__));
+	dev = queue->dev;
+	port = dev->port;
+	LANTIQ_USIF_PRINT(port, USIF_MSG_QUEUE,
+		"%s dev %s prio %d enqueued\n", __func__,
+		dev->dev_name, dev->dev_prio);
+
+	LANTIQ_USIF_SPI_Q_LOCK_BH(port);
+	if (dev->dev_prio == LANTIQ_USIF_SPI_PRIO_ASYNC) {
+		TAILQ_INSERT_TAIL(&port->usif_asyncq, queue, q_next);
+	} else {
+		TAILQ_INSERT_TAIL(&port->usif_syncq[dev->dev_prio],
+			queue, q_next);
+	}
+	dev->stats.enqueue++;
+	LANTIQ_USIF_SPI_Q_UNLOCK_BH(port);
+}
+
+/**
+ * \fn static void lantiq_usif_spi_dequeue(LANTIQ_USIF_QUEUE_t *queue)
+ * \brief USIF remove queue entry from priority queue
+ *
+ * \param   queue    Pointer to structure #LANTIQ_USIF_QUEUE_t
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static void lantiq_usif_spi_dequeue(LANTIQ_USIF_QUEUE_t *queue)
+{
+	lantiq_usif_device_t *dev;
+	struct lantiq_usif_port *port;
+
+	LANTIQ_KASSERT((queue != NULL),
+		("%s should never happen\n", __func__));
+	dev = queue->dev;
+	port = dev->port;
+	LANTIQ_USIF_PRINT(port, USIF_MSG_QUEUE,
+		"%s dev %s prio %d dequeued\n", __func__,
+		dev->dev_name, dev->dev_prio);
+
+	LANTIQ_USIF_SPI_Q_LOCK_BH(port);
+	if (dev->dev_prio == LANTIQ_USIF_SPI_PRIO_ASYNC) {
+		if (!TAILQ_EMPTY(&port->usif_asyncq))
+			TAILQ_REMOVE(&port->usif_asyncq, queue, q_next);
+
+	} else {
+		if (!TAILQ_EMPTY(&port->usif_syncq[dev->dev_prio])) {
+			TAILQ_REMOVE(&port->usif_syncq[dev->dev_prio],
+				queue, q_next);
+		}
+	}
+	dev->stats.dequeue++;
+	LANTIQ_USIF_SPI_Q_UNLOCK_BH(port);
+}
+
+/**
+ * \fn static void lantiq_usif_spi_cs_lock(lantiq_usif_device_t *dev)
+ * \brief USIF chip select function, set spi mode, baudrate, call
+ *  registered device-specific cs set function.
+ *
+ * \param   dev    Pointer to structure #lantiq_usif_device_t
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static void lantiq_usif_spi_cs_lock(lantiq_usif_device_t *dev)
+{
+	LANTIQ_USIF_SPI_CONFIGURE_t *usif_cfg;
+	struct lantiq_usif_port *port;
+
+	port = dev->port;
+	if (port->usif_cs_locked == true) {
+		printk(KERN_ERR "Fatal error: %s locked already before\n",
+			__func__);
+		return;
+	}
+	LANTIQ_USIF_PRINT(dev->port, USIF_MSG_LOCK, "%s %s enter\n", __func__,
+		dev->dev_name);
+
+	port->usif_cs_locked = true;
+
+	usif_cfg = &dev->conn_id;
+	lantiq_usif_spi_set_spi_mode(dev);
+	lantiq_usif_spi_set_baudrate(port, usif_cfg->baudrate);
+	if (usif_cfg->csset_cb != NULL)
+		usif_cfg->csset_cb(LANTIQ_USIF_SPI_CS_ON, usif_cfg->cs_data);
+
+}
+
+/**
+ * \fn static INLINE void lantiq_usif_spi_cs_unlock(lantiq_usif_device_t *dev)
+ * \brief USIF chip unselect function,  call registered device-specific
+ *  cs reset function.
+ *
+ * \param   dev    Pointer to structure #lantiq_usif_device_t
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE void lantiq_usif_spi_cs_unlock(lantiq_usif_device_t *dev)
+{
+	LANTIQ_USIF_SPI_CONFIGURE_t *usif_cfg;
+	struct lantiq_usif_port *port;
+
+	port = dev->port;
+	if (port->usif_cs_locked == false) {
+		printk(KERN_ERR
+			"Fatal error: %s unlocked already before\n",
+			__func__);
+		return;
+	}
+	usif_cfg = &dev->conn_id;
+	if (usif_cfg->csset_cb != NULL)
+		usif_cfg->csset_cb(LANTIQ_USIF_SPI_CS_OFF, usif_cfg->cs_data);
+
+	port->usif_cs_locked = false;
+	LANTIQ_USIF_PRINT(port, USIF_MSG_LOCK, "%s %s exit\n", __func__,
+		dev->dev_name);
+}
+
+/**
+ *\fn int lantiq_usif_spiLock(LANTIQ_USIF_SPI_HANDLE_t handler)
+ *\brief  Called to lock and reserve the whole USIF SPI interface
+ * for the given 'handler'
+ *
+ * The chipselect, belonging to this USIF SPI session is already
+ * activated. This means the chipselect callback is called.
+ * After complete data transmission and reception, lantiq_usif_spiUnLock
+ * has to be called to release the USIF SPI interface again for
+ * other clients.
+ *
+ * \param   handler    Handle of the connection where to make the
+ *                     configuration on
+ * \return  = 0
+ * \ingroup LANTIQ_USIF_SPI_FUNCTIONS
+ */
+int lantiq_usif_spiLock(LANTIQ_USIF_SPI_HANDLE_t handler)
+{
+	lantiq_usif_device_t *dev;
+	LANTIQ_USIF_SPI_CONFIGURE_t *usif_cfg;
+	struct lantiq_usif_port *port;
+	LANTIQ_USIF_QUEUE_t *pqueue;
+
+	LANTIQ_KASSERT((handler != NULL),
+		("%s Invalid parameter\n", __func__));
+
+	dev = (lantiq_usif_device_t *) handler;
+	pqueue = &dev->queue;
+	usif_cfg = &dev->conn_id;
+	port = dev->port;
+
+	if (port->lock_qentry == pqueue) {
+		/* We hold the lock already -> nothing to request here! */
+		return -1;
+	}
+
+	/*
+	 * Check if the queue entry of the ConnId is already queued with
+	 * a request but this request is not served yet. Every ConnId can
+	 * only queue up one request at one time.
+	 */
+	if (atomic_read(&pqueue->isqueued) == 1)
+		return -1;
+
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+	/* Initialize unused variable */
+	pqueue->txbuf = NULL;
+	pqueue->txsize = 0;
+	pqueue->rxbuf = NULL;
+	pqueue->rxsize = 0;
+
+	/* Place a lock request in the queue */
+	pqueue->request_lock = true;
+	
+	atomic_set(&pqueue->isqueued, 1);
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+	/* Add queue entry to priority queue */
+	lantiq_usif_spi_enqueue(pqueue);
+
+	/*
+	 * If no async support is avaiable, trigger the USIF kernel thread and
+	 * wait pending till job is done.
+	 */
+#ifdef CONFIG_LANTIQ_USIF_SPI_ASYNCHRONOUS
+	LANTIQ_USIF_PRINT(port, USIF_MSG_TASKLET, "%s raise fake interrupt\n",
+		__func__);
+	lantiq_usif_spi_start_tasklet(port);
+#else
+	LANTIQ_USIF_PRINT(port, USIF_MSG_THREAD,
+		"%s wake up usif kernel thread\n", __func__);
+	/* Kick off USIF kernel thread */
+	LANTIQ_USIF_SPI_WAKEUP_EVENT(port->usif_thread_wait,
+		LANTIQ_USIF_SPI_THREAD_EVENT, port->event_flags);
+#endif /* CONFIG_LANTIQ_USIF_SPI_ASYNCHRONOUS */
+	/* Wait till wake up from USIF kernel thread */
+	LANTIQ_USIF_SPI_WAIT_EVENT(dev->dev_thread_wait,
+		LANTIQ_USIF_SPI_DEV_THREAD_EVENT, dev->event_flags);
+	LANTIQ_USIF_PRINT(port, USIF_MSG_THREAD,
+		"%s wakeup received from usif kernel thread\n", __func__);
+	return 0;
+}
+EXPORT_SYMBOL(lantiq_usif_spiLock);
+
+/**
+ *\fn int lantiq_usif_spiUnlock(LANTIQ_USIF_SPI_HANDLE_t handler)
+ * \brief  This function releases the USIF SPI lock that was placed before by
+ * calling lantiq_usif_spiLock.
+ *
+ * This function also inactivate the chipselect signal, which was set in
+ * lantiq_usif_spiLock.
+ *
+ * \param   handler    Handle of the connection where to make the
+ *                     configuration on
+ * \return  = 0
+ * \ingroup LANTIQ_USIF_SPI_FUNCTIONS
+ */
+int lantiq_usif_spiUnlock(LANTIQ_USIF_SPI_HANDLE_t handler)
+{
+	lantiq_usif_device_t *dev;
+	LANTIQ_USIF_SPI_CONFIGURE_t *usif_cfg = NULL;
+	struct lantiq_usif_port *port = NULL;
+	LANTIQ_USIF_QUEUE_t *pqueue;
+
+	LANTIQ_KASSERT((handler != NULL),
+		("%s Invalid parameter\n", __func__));
+
+	dev = (lantiq_usif_device_t *) handler;
+	pqueue = &dev->queue;
+	usif_cfg = &dev->conn_id;
+	port = dev->port;
+
+	if (port->lock_qentry != &dev->queue) {
+		/* We do not hold the lock, therefore we can not release it! */
+		return -1;
+	}
+
+	/* Just forget about the lock, then the USIF driver would just take it
+	 * as a normel queue entry
+	 */
+	lantiq_usif_spi_cs_unlock(dev);
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+	port->lock_qentry = NULL;
+	pqueue->txbuf = NULL;
+	pqueue->txsize = 0;
+	pqueue->rxbuf = NULL;
+	pqueue->rxsize = 0;
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+	return 0;
+}
+EXPORT_SYMBOL(lantiq_usif_spiUnlock);
+
+/**
+ * \fn int lantiq_usif_spiSetBaud(LANTIQ_USIF_SPI_HANDLE_t handler,
+ *     unsigned int baud)
+ * \brief Configures the Baudrate of a given connection.
+ *
+ * The baudrate can also be change multiple times
+ * for a single connection. The baudrate change
+ * will take place for the next call of lantiq_usif_spiTx,
+ * lantiq_usif_spiRx or lantiq_usif_spiTxRx.
+ *
+ * \param   handler    Handle of the connection where to make the
+ *                     configuration on
+ * \param   baud       Baudrate to configure. This value can be rounded
+ *                     during the calculation of the USIF SPI clock divider
+ *
+ * \return  = 0        OK
+ *          < 0        error number
+ * \ingroup LANTIQ_USIF_SPI_FUNCTIONS
+ */
+int lantiq_usif_spiSetBaud(LANTIQ_USIF_SPI_HANDLE_t handler, unsigned int baud)
+{
+	lantiq_usif_device_t *dev;
+	LANTIQ_USIF_SPI_CONFIGURE_t *usif_cfg;
+
+	/* Sanity check */
+	LANTIQ_KASSERT((handler != NULL),
+		("%s Invalid parameter\n", __func__));
+
+	dev = (lantiq_usif_device_t *) handler;
+	usif_cfg = &dev->conn_id;
+	/* XXX, protection because of being used in other places */
+	usif_cfg->baudrate = baud;
+	return 0;
+}
+EXPORT_SYMBOL(lantiq_usif_spiSetBaud);
+
+/**
+ * \fn static int lantiq_usif_spi_txdma(struct lantiq_usif_port *port,
+ *     char *txbuf, int txsize)
+ * \brief Called to transmit the data using DMA mode .
+ *
+ * \param   port       Pointer to structure #lantiq_usif_port
+ * \param   txbuf     Pointer to the data packet to transmit
+ * \param   txsize     Amount of Bytes to transmit
+ * \return  >= 0       Number of bytes transmitted
+ *          < 0        error number
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static int
+lantiq_usif_spi_txdma(struct lantiq_usif_port *port, char *txbuf, int txsize)
+{
+	int retval = 0;
+	struct dma_device_info *dma_dev;
+
+	dma_dev = port->dma_dev;
+
+	/**
+	* Set a flag that we are waiting for the DMA to complete. This flag
+	* will be reseted again in the DMA interrupt.
+	* NB, it must be ahead of the following stuff, because once descriptor
+	* is prepared, interrupt may come back immediately
+	*/
+	atomic_set(&port->dma_wait_state, 1);
+
+	lantiq_usif_spi_dma_setup(port, LANTIQ_USIF_SPI_DIR_TX,
+		LANTIQ_USIF_SPI_DMA_ENABLE);
+	/* TX DMA only half duplex is used */
+	port->dma_is_in_half_duplex = 1;
+	/**
+	* Run in tasklet or kernel thread, DMA tasklet may run the same
+	* function Lock must be used.
+	* Although descriptor length field requires multiple of dma burst
+	* length, The real size should be set up, otherwise, more clocks
+	* than expected will be transmitted to the serial line.
+	*/
+	retval = dma_device_write(dma_dev, txbuf, txsize, NULL);
+
+	LANTIQ_KASSERT(retval == txsize, ("%s retval %d != txsize %d\n",
+		__func__, retval, txsize));
+
+	return retval;
+}
+
+/**
+ * \fn static int lantiq_usif_spi_dma_fdx(struct lantiq_usif_port *port,
+ *     char *txbuf, int txsize, char *rxbuf, int rxsize)
+ * \brief Called to transmit/receive the data using DMA mode .
+ *
+ * \param   port       Pointer to structure #lantiq_usif_port
+ * \param   txbuf      Pointer to the data packet to transmit
+ * \param   txsize     Amount of Bytes to transmit
+ * \param   rxbuf      Pointer to the data packet to be received
+ * \param   rxsize     Amount of Bytes to be received
+ * \return  >= 0       Number of bytes transmitted/received
+ *          < 0        error number
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static int
+lantiq_usif_spi_dma_fdx(struct lantiq_usif_port *port, char *txbuf, int txsize,
+		  char *rxbuf, int rxsize)
+{
+	int retval = 0;
+	struct dma_device_info *dma_dev;
+	dma_dev = port->dma_dev;
+
+	/*
+	 * FDX required TX/RX has the same amount of data and they must
+	 * be a multiple of  of DMA burst length
+	 */
+	if (((rxsize & ((dma_dev->rx_burst_len << 2) - 1)) != 0) ||
+	    ((txsize & ((dma_dev->tx_burst_len << 2) - 1)) != 0)) {
+		printk(KERN_ERR "%s data length is not a multiple of DMA"
+			" burst length %d\n", __func__, rxsize);
+		return -EINVAL;
+	}
+
+	/* Backup original buffer, so that later we can find it
+	   in dma handler */
+	port->rxbuf_ptr = rxbuf;
+	port->rx_len = rxsize;
+
+	/* Disable interrupt */
+	LANTIQ_USIF_SET_INT_MASK(0, port);
+
+	dma_device_desc_setup(dma_dev, rxbuf, rxsize);
+
+	/* D+ RX always enabled, RX Class MASK */
+	lantiq_usif_spi_dma_setup(port, LANTIQ_USIF_SPI_DIR_TXRX,
+		LANTIQ_USIF_SPI_DMA_ENABLE);
+
+	/* Enable SPI DMA channel */
+	(dma_dev->rx_chan[dma_dev->current_rx_chan])
+		->open(dma_dev->rx_chan[dma_dev->current_rx_chan]);
+
+	/*
+	 * Set a flag that we are waiting for the DMA to complete. This flag
+	 * will be reseted again in the DMA interrupt.
+	 */
+	atomic_set(&port->dma_wait_state, 1);
+
+	port->dma_is_in_half_duplex = 0;
+
+	/* TX/RX mode also should program MRPS to trigger RX operation */
+	LANTIQ_USIF_CONFIG_RX_MRPS(SM(rxsize, LANTIQ_USIF_MRPS_CTRL_MRPS), port);
+
+	/* TX real data sent and it will drive clock out at the same time */
+
+	retval = dma_device_write(dma_dev, txbuf, txsize, NULL);
+
+	LANTIQ_KASSERT(retval == txsize, ("%s retval %d != txsize %d\n",
+		__func__, retval, txsize));
+
+	return retval;
+}
+
+/**
+ * \fn static int lantiq_usif_spi_rxdma(struct lantiq_usif_port *port,
+ *     char *rxbuf, int rxsize)
+ * \brief Called to receive the data using DMA mode .
+ *
+ * \param   port       Pointer to structure #lantiq_usif_port
+ * \param   rxbuf      Pointer to the data packet to be received
+ * \param   rxsize     Amount of Bytes to be received
+ * \return  >= 0       Number of bytes received
+ *          < 0        error number
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static int
+lantiq_usif_spi_rxdma(struct lantiq_usif_port *port, char *rxbuf, int rxsize)
+{
+	char *pbuf;
+	int dma_rxsize;
+	int retval = 0;
+	u32 dma_burst_len;
+	u32 dma_burst_len_mask;
+	struct dma_device_info *dma_dev;
+
+	dma_dev = port->dma_dev;
+	dma_burst_len = (dma_dev->rx_burst_len << 2);
+	dma_burst_len_mask = dma_burst_len - 1;
+
+	/* Backup original buffer, so that later we can find it
+	   in dma handler */
+	port->rxbuf_ptr = rxbuf;
+	port->rx_len = rxsize;
+	/* Can't be divisible by burst length  */
+	if ((rxsize & dma_burst_len_mask)) {
+		pbuf = port->dma_rxbuf;
+		 /* Round up burst length to make sure enough space */
+		dma_rxsize = (rxsize & ~dma_burst_len_mask) + dma_burst_len;
+		LANTIQ_KASSERT(dma_rxsize <= DEFAULT_USIF_SPI_FRAGMENT_SIZE,
+			("%s fragment %d out of range\n", __func__,
+			dma_rxsize));
+	} else {
+		pbuf = rxbuf;
+		dma_rxsize = rxsize;
+	}
+
+	/* Disable interrupt */
+	LANTIQ_USIF_SET_INT_MASK(0, port);
+
+	dma_device_desc_setup(dma_dev, pbuf, dma_rxsize);
+
+	/* D+ RX always enabled, RX Class MASK */
+	lantiq_usif_spi_dma_setup(port, LANTIQ_USIF_SPI_DIR_TXRX,
+		LANTIQ_USIF_SPI_DMA_ENABLE);
+
+	/* Enable SPI DMA channel */
+	(dma_dev->rx_chan[dma_dev->current_rx_chan])
+		->open(dma_dev->rx_chan[dma_dev->current_rx_chan]);
+
+	/*
+	 * Set a flag that we are waiting for the DMA to complete. This flag
+	 * will be reseted again in the DMA interrupt.
+	 */
+	atomic_set(&port->dma_wait_state, 1);
+
+	port->dma_is_in_half_duplex = 0;
+
+	/* TX/RX mode also should program MRPS to trigger RX operation */
+	LANTIQ_USIF_CONFIG_RX_MRPS(SM(dma_rxsize, LANTIQ_USIF_MRPS_CTRL_MRPS), port);
+
+	/* TX dummy data sent */
+
+	retval = dma_device_write(dma_dev, port->dma_txbuf, dma_rxsize, NULL);
+
+	LANTIQ_KASSERT(retval == dma_rxsize, ("%s retval %d != txsize %d\n",
+		__func__, retval, dma_rxsize));
+
+	return rxsize;
+}
+
+/**
+ *\fn int lantiq_usif_spiTxRx (LANTIQ_USIF_SPI_HANDLE_t handler, char *txbuf,
+ *        u32 txsize, char *rxbuf, u32 rxsize)
+ *\brief Called to transmit/receive to/from USIF SPI in one step.
+
+ * This means that the data transmission and reception is done in parallel.
+ * No DMA is possible here. The USIF SPI driver sets the chipselect when the
+ * data transmission starts and resets it when the transmission is
+ * completed. The transmit and receive buffer memory allocation and
+ * de-allocation is done by the USIF SPI client.
+ *
+ * \param   handler    Handle of the connection where to make the
+ *                     configuration on
+ * \param   txbuf     Pointer to the data packet to transmit
+ * \param   txsize    Amount of Bytes to transmit
+ * \param   rxbuf     Pointer to store the received data packet
+ * \param   rxsize    Amount of Bytes to receive.
+ * \return  >= 0      Number of bytes received (if rx_buf != 0) or transmitted
+ * \return  < 0       error number
+ * \ingroup LANTIQ_USIF_SPI_FUNCTIONS
+ */
+int
+lantiq_usif_spiTxRx(LANTIQ_USIF_SPI_HANDLE_t handler, char *txbuf, u32 txsize,
+		 char *rxbuf, u32 rxsize)
+{
+	lantiq_usif_device_t *dev;
+	LANTIQ_USIF_SPI_CONFIGURE_t *usif_cfg;
+	LANTIQ_USIF_QUEUE_t *pqueue;
+	struct lantiq_usif_port *port;
+	struct usif_device_stats *stats;
+
+	/* Sanity check */
+	LANTIQ_KASSERT((handler != NULL),
+		("%s Invalid parameter\n", __func__));
+
+	LANTIQ_KASSERT(!((rxbuf == NULL) && (rxsize == 0)
+		&& (txbuf == NULL) && (txsize == 0)),
+		("%s Invalid parameter\n", __func__));
+
+	dev = (lantiq_usif_device_t *) handler;
+	stats = &dev->stats;
+	port = dev->port;
+
+	if (in_interrupt()) {
+		stats->context_err++;
+		printk(KERN_ERR "%s can't be called in interupt context"
+			"< irq, softirq, tasklet>\n", __func__);
+		return 0;
+	}
+	usif_cfg = &dev->conn_id;
+	pqueue = &dev->queue;
+
+	if ((txsize > usif_cfg->fragSize) || (rxsize > usif_cfg->fragSize)) {
+		stats->frag_err++;
+		printk(KERN_ERR "%s Device driver must do its own fragmentation"
+			" tx %d, rx %d > %d\n", __func__, txsize, rxsize,
+			usif_cfg->fragSize);
+		return 0;
+	}
+
+	if ((txsize != 0) && (rxsize != 0)) {
+		if (usif_cfg->duplex_mode == LANTIQ_USIF_SPI_FULL_DUPLEX) {
+			if (txsize != rxsize) {
+				stats->dlx_err++;
+				printk(KERN_ERR "%s full duplex required TX/RX"
+					" has the same amount of data tx %d"
+					" rx %d\n", __func__, txsize, rxsize);
+				return 0;
+			}
+		}
+	}
+	/*
+	 * Ensure that only asynchronous USIF Handles could enqueue a
+	 * synchronous request. The parameter 'handle_type' is set during the
+	 * ConnId allocation process.
+	 */
+	if (pqueue->handle_type != LANTIQ_USIF_SPI_HANDL_TYPE_SYNC) {
+		stats->handler_err++;
+		printk(KERN_ERR "%s must use sync handler\n", __func__);
+		return 0;
+	}
+
+	/*
+	 * Check if the queue entry of the ConnId is already queued with
+	 * a request but this request is not served yet. Every ConnId can
+	 * only queue up one request at one time.
+	 */
+	if (atomic_read(&pqueue->isqueued) == 1) {
+		stats->dup_qentries++;
+		LANTIQ_USIF_PRINT(port, USIF_MSG_ERROR,
+			"%s same queue has queued more than once\n",
+			__func__);
+		return 0;
+	}
+	/* Add pointer and sizes to the queue entry of this USIF handle. */
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+	pqueue->txbuf = txbuf;
+	pqueue->txsize = txsize;
+	pqueue->rxbuf = rxbuf;
+	pqueue->rxsize = rxsize;
+	atomic_set(&pqueue->isqueued, 1);
+	pqueue->exchange_bytes = 0;
+	pqueue->request_lock = false;
+	memset(&pqueue->callback, 0,
+		sizeof(LANTIQ_USIF_SPI_ASYNC_CALLBACK_t));
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+	/* Add queue entry to priority queue */
+	lantiq_usif_spi_enqueue(pqueue);
+
+	/* If no async support is avaiable, trigger the USIF kernel thread and
+	 * wait pending till job is done.
+	 */
+#ifdef CONFIG_LANTIQ_USIF_SPI_ASYNCHRONOUS
+	LANTIQ_USIF_PRINT(port, USIF_MSG_TASKLET, "%s raise fake interrupt\n",
+		__func__);
+	lantiq_usif_spi_start_tasklet(port);
+#else
+	LANTIQ_USIF_PRINT(port, USIF_MSG_THREAD,
+		"%s wake up usif kernel thread\n", __func__);
+	/* Kick off USIF kernel thread */
+	LANTIQ_USIF_SPI_WAKEUP_EVENT(port->usif_thread_wait,
+		LANTIQ_USIF_SPI_THREAD_EVENT, port->event_flags);
+#endif /* CONFIG_LANTIQ_USIF_SPI_ASYNCHRONOUS */
+	/* Wait till wakeup from USIF kernel thread */
+	LANTIQ_USIF_SPI_WAIT_EVENT(dev->dev_thread_wait,
+		LANTIQ_USIF_SPI_DEV_THREAD_EVENT, dev->event_flags);
+	LANTIQ_USIF_PRINT(port, USIF_MSG_THREAD,
+		"%s wakeup event received from usif kernel thread\n",
+		__func__);
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+	/* Reset queue pointer */
+	pqueue->txbuf = NULL;
+	pqueue->rxbuf = NULL;
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+	return pqueue->txsize + pqueue->rxsize;
+}
+EXPORT_SYMBOL(lantiq_usif_spiTxRx);
+
+/**
+ *\fn int lantiq_usif_spiTx(LANTIQ_USIF_SPI_HANDLE_t handler, char *txbuf, u32 txsize)
+ *\brief Called to transmit the data.
+
+ * transmission starts and resets it when the transmission
+ * the transmit buffer is done by the USIF SPI client.
+ *
+ * \param   handler    Handle of the connection where to make the
+ *                     configuration on
+ * \param   txbuf      Pointer to the data packet to transmit
+ * \param   txsize     Amount of Bytes to transmit
+ * \return  >= 0       Number of bytes transmitted
+ * \return  < 0        error number
+ * \ingroup LANTIQ_USIF_SPI_FUNCTIONS
+ */
+int lantiq_usif_spiTx(LANTIQ_USIF_SPI_HANDLE_t handler, char *txbuf, u32 txsize)
+{
+	return lantiq_usif_spiTxRx(handler, txbuf, txsize, NULL, 0);
+}
+EXPORT_SYMBOL(lantiq_usif_spiTx);
+
+/**
+ *\fn int lantiq_usif_spiRx(LANTIQ_USIF_SPI_HANDLE_t handler, char *rxbuf, u32 rxsize)
+ *\brief Called to receive the data.
+
+ * The USIF SPI driver sets the chipselect when the data reception starts and
+ * resets it when the reception is completed. The memory allocation and
+ * de-allocation of the receive buffer is done by the USIF SPI client.
+ *
+ * \param   handler    Handle of the connection where to make the
+ *                     configuration on
+ * \param   rxbuf      Pointer to the data packet to be received
+ * \param   rxsize     Amount of Bytes to be received
+ * \return  >= 0       Number of bytes received
+ * \return  < 0        error number
+ * \ingroup LANTIQ_USIF_SPI_FUNCTIONS
+ */
+int lantiq_usif_spiRx(LANTIQ_USIF_SPI_HANDLE_t handler, char *rxbuf, u32 rxsize)
+{
+	return lantiq_usif_spiTxRx(handler, NULL, 0, rxbuf, rxsize);
+}
+EXPORT_SYMBOL(lantiq_usif_spiRx);
+
+/**
+ * \fn static int lantiq_usif_spi_serve_qentry(struct lantiq_usif_port *port)
+ * \brief Called to serve every queue entry and it is a common function for
+ * USIF kernel thread and tasklet
+ *
+ * \param   port       Pointer to structure #lantiq_usif_port
+ * \return  1          Continue to loop this function until return 0
+ * \return  0          Immediately exit this function. For kernel thread,
+ *                     it will sleep, for tasklet, it will exit dynamically
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static int lantiq_usif_spi_serve_qentry(struct lantiq_usif_port *port)
+{
+	LANTIQ_USIF_QUEUE_t *qentry = NULL;
+	lantiq_usif_device_t *dev;
+	LANTIQ_USIF_SPI_CONFIGURE_t *usif_cfg = NULL;
+	struct dma_device_info *dma_dev;
+
+	/*
+	 * Don't serve the current or next queue entry in case we are currently
+	 * waiting for the DMA interrupt to report the transmission completion.
+	 */
+	if (atomic_read(&port->dma_wait_state) == 1) {
+		/*
+		 * DMA interrupt will spawn tasklet or wake up kernel thread
+		 * in order to continue.
+		 */
+		return 0;
+	}
+
+	/* Identify the queue entry to serve */
+	if (port->serve_qentry != NULL) {
+		/* Continues serving the queue that was served before */
+		qentry = port->serve_qentry;
+	} else if (port->lock_qentry != NULL) {
+		/*
+		 * If one queue holds the lock, only serve this one element and
+		 * ignore all others.
+		 */
+		qentry = port->lock_qentry;
+		port->serve_qentry = qentry;
+	} else {
+		LANTIQ_USIF_PRINT(port, USIF_MSG_DUPLEX,
+				"%s Locking SPI Q BH..\n", __func__);
+		LANTIQ_USIF_SPI_Q_LOCK_BH(port);
+		if (!TAILQ_EMPTY(&port->usif_asyncq)) {
+			qentry = TAILQ_FIRST(&port->usif_asyncq);
+		} else {
+			int i;
+
+			/* Choose the highest queue entry first */
+			for (i = LANTIQ_USIF_SPI_PRIO_HIGH;
+				i >= LANTIQ_USIF_SPI_PRIO_LOW; i--) {
+				if (!TAILQ_EMPTY(&port->usif_syncq[i])) {
+					qentry = TAILQ_FIRST
+						(&port->usif_syncq[i]);
+					break;
+				}
+			}
+		}
+		LANTIQ_USIF_SPI_Q_UNLOCK_BH(port);
+
+		/* Remember that we are working on this queue now */
+		port->serve_qentry = qentry;
+
+		/*
+		 * NB, Don't remove the qentry here since we may never come
+		 * here once callers called sequence. It may cause
+		 * enqueue/dequeue mismatch
+		 */
+	}
+
+	/* No queue found that should be served */
+	if (qentry == NULL)
+		return 0;
+
+	/* Get connection handle */
+	dev = qentry->dev;
+	usif_cfg = &dev->conn_id;
+	dma_dev = port->dma_dev;
+	/* This will pass cs to port for class information per queue entry */
+	port->current_dev = dev;
+
+	if ((usif_cfg->duplex_mode == LANTIQ_USIF_SPI_FULL_DUPLEX)
+	    && (qentry->txbuf != NULL)
+	    && (qentry->rxbuf != NULL)) {
+		int tx_dma_aligned =
+			((((u32) qentry->txbuf)
+			& ((dma_dev->tx_burst_len << 2) - 1)) == 0) ? 1 : 0;
+		int rx_dma_aligned =
+			((((u32) qentry->rxbuf)
+			& ((dma_dev->rx_burst_len << 2) - 1)) == 0) ? 1 : 0;
+		if ((port->usif_cs_locked == false)
+			&& (port->lock_qentry == NULL)) {
+			LANTIQ_USIF_PRINT(port, USIF_MSG_DUPLEX,
+				"%s Locking SPI CS..\n", __func__);
+			lantiq_usif_spi_cs_lock(dev);
+		}
+		lantiq_usif_spi_txrx_setup(port);
+
+		/* If buffer not aligned on DMA burst length,
+		fall back to FIFO */
+		if ((qentry->txsize > usif_cfg->maxFIFOSize)
+		    && (tx_dma_aligned == 1)
+		    && (qentry->rxsize > usif_cfg->maxFIFOSize)
+		    && (rx_dma_aligned == 1)) {
+
+			LANTIQ_USIF_PRINT(port, USIF_MSG_DUPLEX,
+				"%s TX/RX DMA enter\n", __func__);
+			lantiq_usif_spi_dma_fdx(port, qentry->txbuf,
+				qentry->txsize, qentry->rxbuf,
+				qentry->rxsize);
+
+			port->stats.txDma++;
+			port->stats.rxDma++;
+			qentry->txbuf = NULL;
+			qentry->exchange_bytes = qentry->txsize;
+
+			qentry->rxbuf = NULL;
+			qentry->exchange_bytes += qentry->rxsize;
+
+			dev->stats.txBytes += qentry->txsize;
+			port->stats.txBytes += qentry->txsize;
+			port->stats.txDmaBytes += qentry->txsize;
+			dev->stats.rxBytes += qentry->rxsize;
+			port->stats.rxBytes += qentry->rxsize;
+			port->stats.rxDmaBytes += qentry->rxsize;
+			return 0;
+		} else {
+			LANTIQ_USIF_PRINT(port, USIF_MSG_DUPLEX,
+				"%s TX/RX FIFO enter\n", __func__);
+			lantiq_usif_spi_txrx_fifo_fdx(port, qentry->txbuf,
+				qentry->txsize, qentry->rxbuf, qentry->rxsize);
+			port->stats.txFifo++;
+			port->stats.rxFifo++;
+
+			qentry->txbuf = NULL;
+			qentry->exchange_bytes = qentry->txsize;
+
+			qentry->rxbuf = NULL;
+			qentry->exchange_bytes += qentry->rxsize;
+
+			dev->stats.txBytes += qentry->txsize;
+			port->stats.txBytes += qentry->txsize;
+			dev->stats.rxBytes += qentry->rxsize;
+			port->stats.rxBytes += qentry->rxsize;
+			return 1;
+		}
+
+	} else if (qentry->txbuf != NULL) {
+		int tx_dma_aligned =
+			((((u32) qentry->txbuf)
+			& ((dma_dev->tx_burst_len << 2) - 1)) == 0) ? 1 : 0;
+
+		LANTIQ_USIF_PRINT(port, USIF_MSG_TX_DMA,
+				       "%s TX DMA enter\n", __func__);
+
+		if ((port->usif_cs_locked == false)
+			&& (port->lock_qentry == NULL)) {
+			lantiq_usif_spi_cs_lock(dev);
+		}
+
+		lantiq_usif_spi_tx_setup(port);
+		/* If buffer not aligned on DMA burst length,
+		   fall back to FIFO */
+		if ((qentry->txsize > usif_cfg->maxFIFOSize)
+		    && (tx_dma_aligned == 1)) {
+			lantiq_usif_spi_txdma(port, qentry->txbuf,
+					   qentry->txsize);
+			port->stats.txDma++;
+
+			qentry->txbuf = NULL;
+
+			qentry->exchange_bytes = qentry->txsize;
+			dev->stats.txBytes += qentry->txsize;
+			port->stats.txBytes += qentry->txsize;
+			port->stats.txDmaBytes += qentry->txsize;
+			return 0;
+		} else {
+			lantiq_usif_spi_txfifo(port, qentry->txbuf,
+				qentry->txsize);
+			port->stats.txFifo++;
+			LANTIQ_USIF_PRINT(port, USIF_MSG_TX_FIFO,
+				"%s TX FIFO enter\n", __func__);
+
+			qentry->txbuf = NULL;
+
+			qentry->exchange_bytes = qentry->txsize;
+			dev->stats.txBytes += qentry->txsize;
+			port->stats.txBytes += qentry->txsize;
+			/*
+			 * NB, Make sure data has been sent out
+			 * XXX, remove polling by checking TX_FIN
+			 */
+			lantiq_usif_spi_wait_tx_finished(port);
+			return 1;
+		}
+	} else if (qentry->rxbuf != NULL) {
+		int rx_dma_aligned =
+			((((u32) qentry->rxbuf)
+			& ((dma_dev->rx_burst_len << 2) - 1)) == 0) ? 1 : 0;
+
+		LANTIQ_USIF_PRINT(port, USIF_MSG_RX_DMA,
+				"%s RX DMA enter\n", __func__);
+
+		if ((port->usif_cs_locked == false)
+		    && (port->lock_qentry == NULL)) {
+			lantiq_usif_spi_cs_lock(dev);
+		}
+
+		/* If buffer not aligned on DMA burst length,
+		   fall back to FIFO */
+		if ((qentry->rxsize > usif_cfg->maxFIFOSize)
+		    && (rx_dma_aligned == 1)) {
+			lantiq_usif_spi_txrx_setup(port);
+			lantiq_usif_spi_rxdma(port, qentry->rxbuf,
+				qentry->rxsize);
+			port->stats.rxDma++;
+			port->stats.txDma++;
+
+			qentry->rxbuf = NULL;
+			qentry->exchange_bytes += qentry->rxsize;
+			dev->stats.rxBytes += qentry->rxsize;
+			port->stats.rxBytes += qentry->rxsize;
+			port->stats.rxDmaBytes += qentry->rxsize;
+			dev->stats.txBytes += qentry->rxsize;
+			port->stats.txBytes += qentry->rxsize;
+			port->stats.txDmaBytes += qentry->rxsize;
+			return 0;
+		} else {
+			LANTIQ_USIF_PRINT(port, USIF_MSG_RX_FIFO,
+				"%s RX FIFO enter\n", __func__);
+			lantiq_usif_spi_rx_setup(port);
+			lantiq_usif_spi_rxfifo(port, qentry->rxbuf,
+				qentry->rxsize);
+			port->stats.rxFifo++;
+
+			qentry->rxbuf = NULL;
+			qentry->exchange_bytes += qentry->rxsize;
+			dev->stats.rxBytes += qentry->rxsize;
+			port->stats.rxBytes += qentry->rxsize;
+			return 1;
+		}
+	} else if (qentry->request_lock) {
+		/* A lock request found */
+		LANTIQ_USIF_PRINT(port, USIF_MSG_LOCK,
+			"%s request lock enter\n", __func__);
+		port->lock_qentry = qentry;
+		qentry->request_lock = false;
+
+		/* Serving the current queue entry is done */
+		port->serve_qentry = NULL;
+
+		/* Reset current device */
+		port->current_dev = NULL;
+		/*
+		 * Reset the flag in the queue element that this one is queued
+		 * with a request to be served.
+		 */
+		atomic_set(&qentry->isqueued, 0);
+
+		/* syncAPI has the last watchdog branch but nested
+		   callback has to dequeue it */
+		if (qentry->handle_type == LANTIQ_USIF_SPI_HANDL_TYPE_ASYNC)
+			lantiq_usif_spi_dequeue(qentry);
+
+		/* Call the Chipselect set callback of the USIF-Handle */
+		lantiq_usif_spi_cs_lock(dev);
+
+		if (qentry->callback.pFunction) {
+			/*
+			 * Store the callback parameter local to cleanup
+			 * the queue entry before calling the callback.
+			 */
+			LANTIQ_USIF_SPI_ASYNC_CALLBACK_t callback =
+				qentry->callback;
+
+			qentry->callback.pFunction = NULL;
+			LANTIQ_USIF_PRINT(port, USIF_MSG_CALLBACK,
+				"%s line%d request callback\n",
+				__func__, __LINE__);
+			/* Callback to call */
+			callback.pFunction(callback.functionHandle, 0);
+		}
+		return 1;
+	} else if (qentry->callback.pFunction != NULL) {
+
+		LANTIQ_USIF_PRINT(port, USIF_MSG_CALLBACK,
+			"%s line%d direct callback\n", __func__, __LINE__);
+		/*
+		 * Store the callback parameter local to cleanup the queue
+		 * entry before calling the callback.
+		 */
+		LANTIQ_USIF_SPI_ASYNC_CALLBACK_t callback = qentry->callback;
+
+		qentry->callback.pFunction = NULL;
+
+		/* Serving the current queue entry is done */
+		port->serve_qentry = NULL;
+
+		/* Reset current device */
+		port->current_dev = NULL;
+		/*
+		 * Reset the flag in the queue element that this one is queued
+		 * with a request to be served.
+		 */
+		atomic_set(&qentry->isqueued, 0);
+		lantiq_usif_spi_dequeue(qentry);
+
+		if ((port->usif_cs_locked == true)
+			&& (port->lock_qentry == NULL)) {
+
+			lantiq_usif_spi_cs_unlock(dev);
+		}
+
+		/* Callback to call */
+		callback.pFunction(callback.functionHandle,
+			qentry->exchange_bytes);
+
+		return 1;
+	} else if (qentry->handle_type == LANTIQ_USIF_SPI_HANDL_TYPE_SYNC) {
+		LANTIQ_USIF_PRINT(port, USIF_MSG_CALLBACK,
+				"%s SPI_HANDLTYPE_SYNC enter\n", __func__);
+		if ((port->usif_cs_locked == true)
+		    && (port->lock_qentry == NULL)) {
+			LANTIQ_USIF_PRINT(port, USIF_MSG_CALLBACK,
+				"%s cs_unlock \n", __func__);
+			lantiq_usif_spi_cs_unlock(dev);
+		}
+		/* Serving the current queue entry is done */
+		port->serve_qentry = NULL;
+		/* Reset current device */
+		port->current_dev = NULL;
+		/*
+		 * Reset the flag in the queue element that this one is queued
+		 * with a request to be served.
+		 */
+		atomic_set(&qentry->isqueued, 0);
+
+		LANTIQ_USIF_PRINT(port, USIF_MSG_THREAD,
+			"%s spi dequeue.. \n", __func__);
+		lantiq_usif_spi_dequeue(qentry);
+
+		/* Wake up the pending thread */
+		LANTIQ_USIF_SPI_WAKEUP_EVENT(dev->dev_thread_wait,
+			LANTIQ_USIF_SPI_DEV_THREAD_EVENT, dev->event_flags);
+		LANTIQ_USIF_PRINT(port, USIF_MSG_THREAD,
+			"%s wakeup USIF client kernel thread\n", __func__);
+		/* syncAPI has no callback, we have to differentiate it */
+		if (port->usif_cs_locked == true)
+			return 0;
+		else
+			return 1;
+	} else if ((qentry->handle_type == LANTIQ_USIF_SPI_HANDL_TYPE_ASYNC)
+		   && (port->usif_cs_locked == true)) {
+		/* Serving the current queue entry is done */
+		port->serve_qentry = NULL;
+		/* Don't let it continue,  but must restart tasklet
+		   in somewhere else */
+		return 0;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_LANTIQ_USIF_SPI_ASYNCHRONOUS
+/**
+ * \fn static INLINE void lantiq_usif_spi_tasklet_serve_queue
+ * (struct lantiq_usif_port *port)
+ * \brief Called to serve every queue entry in tasklet
+ *
+ * \param   port       Pointer to structure #lantiq_usif_port
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE void
+lantiq_usif_spi_tasklet_serve_queue(struct lantiq_usif_port *port)
+{
+	/*
+	 * Serve queue entries till no queue entry anymore to serve,
+	 * we wait for DMA or the lock entry is not in the queue.
+	 */
+	while (lantiq_usif_spi_serve_qentry(port))
+		;
+}
+
+/**
+ * \fn static INLINE void lantiq_usif_spi_tasklet(unsigned long arg)
+ * \brief USIF tasklet implementation
+ *
+ * \param   arg       cast to structure #lantiq_usif_port
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE void lantiq_usif_spi_tasklet(unsigned long arg)
+{
+	struct lantiq_usif_port *port = (struct lantiq_usif_port *) arg;
+
+	LANTIQ_USIF_PRINT(port, USIF_MSG_TASKLET, "%s enter\n", __func__);
+	lantiq_usif_spi_tasklet_serve_queue(port);
+}
+
+/**
+ * \fn static INLINE void lantiq_usif_spi_tasklet_init(struct lantiq_usif_port *port)
+ * \brief USIF tasklet initialization
+ *
+ * \param   port       Pointer to structure #lantiq_usif_port
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE void lantiq_usif_spi_tasklet_init(struct lantiq_usif_port *port)
+{
+	tasklet_init(&port->usif_txrxq, lantiq_usif_spi_tasklet,
+		(unsigned long) port);
+}
+
+#else
+#define LANTIQ_USIF_THREAD_OPTIONS   (CLONE_FS | CLONE_FILES | CLONE_SIGHAND)
+
+/**
+ * \fn static int lantiq_usif_spi_kthread(void *arg)
+ * \brief USIF kernel thread implementation function
+ *
+ * \param   arg       cast to structure #lantiq_usif_port
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static int lantiq_usif_spi_kthread(void *arg)
+{
+	struct lantiq_usif_port *port = (struct lantiq_usif_port *) arg;
+
+	set_current_state(TASK_INTERRUPTIBLE);
+	while (!kthread_should_stop()) {
+		/* Wait for DMA interrupt or sync queue to wakes us up */
+		LANTIQ_USIF_SPI_WAIT_EVENT(port->usif_thread_wait,
+			LANTIQ_USIF_SPI_THREAD_EVENT, port->event_flags);
+		LANTIQ_USIF_PRINT(port, USIF_MSG_THREAD,
+			"%s DMA or sync queue event received\n",
+			__func__);
+		__set_current_state(TASK_RUNNING);
+
+		/* Serve queue entries till no more queue entry to serve */
+		while (lantiq_usif_spi_serve_qentry(port))
+			;
+		set_current_state(TASK_INTERRUPTIBLE);
+	}
+
+	return 0;
+}
+
+/**
+ * \fn static INLINE int lantiq_usif_spi_thread_init(struct lantiq_usif_port *port)
+ * \brief USIF kernel thread initialization
+ *
+ * \param   port       Pointer to structure #lantiq_usif_port
+ * \return  none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static INLINE int lantiq_usif_spi_thread_init(struct lantiq_usif_port *port)
+{
+	struct task_struct *p;
+	int error = 0;
+	
+	p = kthread_run(lantiq_usif_spi_kthread, (void *) port, "usif_kthread");
+	if (IS_ERR(p))
+		error = PTR_ERR(p);
+	else
+		port->usif_tsk = p;
+	return error;
+}
+#endif /* CONFIG_LANTIQ_USIF_SPI_ASYNCHRONOUS */
+
+/**
+ * \fn int lantiq_usif_spiAsyncTxRx(LANTIQ_USIF_SPI_HANDLE_t handler,
+ *  LANTIQ_USIF_SPI_ASYNC_CALLBACK_t *pCallback, char *txbuf,
+ *  int txsize, char *rxbuf, int rxsize)
+ * \brief Transmit/receive to/from USIF in one step. It performs the data
+ *  transmission and then the data reception.
+
+ * The USIF driver sets the chipselect when the data transmission starts
+ * and resets it when the transmission is completed.
+ * This routine is called to start an asynchronous data transmission.
+ * The provided callback routine is called after the transmission is done.
+ *
+ * \param   handler    Handle of the connection where to make the
+ *                     configuration on
+ * \param   pCallback  Function callback that is called after the request
+ *                     is performed.
+ * \param   txbuf      Pointer to the data packet to transmit.
+ * \param   txsize     Amount of Bytes to transmit.
+ * \param   rxbuf      Pointer to store the received data packet.
+ * \param   rxsize     Amount of Bytes to receive.
+
+ * \return Returns the amount of bytes that are transmitted in case of
+ *  successful transmission. In case of an error the function returns -1
+ *
+ * \remarks This function activates the chipselect before data transmission
+ *  and deactivates it after transmission (when function returns). This is
+ * done with the callback function. The chipselect is not modified in case
+ * \ingroup LANTIQ_USIF_SPI_FUNCTIONS
+ */
+int
+lantiq_usif_spiAsyncTxRx(LANTIQ_USIF_SPI_HANDLE_t handler,
+		LANTIQ_USIF_SPI_ASYNC_CALLBACK_t *pCallback,
+		char *txbuf, int txsize, char *rxbuf, int rxsize)
+{
+	lantiq_usif_device_t *dev;
+	LANTIQ_USIF_SPI_CONFIGURE_t *usif_cfg;
+	LANTIQ_USIF_QUEUE_t *pqueue;
+	struct lantiq_usif_port *port;
+	struct usif_device_stats *stats;
+
+	/* Sanity check */
+	LANTIQ_KASSERT((handler != NULL),
+		("%s Invalid parameter\n", __func__));
+
+	LANTIQ_KASSERT(!((rxbuf == NULL) && (rxsize == 0)
+		&& (txbuf == NULL) && (txsize == 0)),
+		("%s Invalid parameter\n", __func__));
+
+	dev = (lantiq_usif_device_t *) handler;
+	stats = &dev->stats;
+	port = dev->port;
+
+	if (!in_interrupt()) {
+		stats->context_err++;
+		printk(KERN_ERR
+			"%s must be called in interrupt context<irq, softirq, tasklet>\n",
+			__func__);
+		return -1;
+	}
+
+	usif_cfg = &dev->conn_id;
+	pqueue = &dev->queue;
+
+	if ((txsize > usif_cfg->fragSize) || (rxsize > usif_cfg->fragSize)) {
+		stats->frag_err++;
+		printk(KERN_ERR
+			"%s Device driver must do its own fragmentation\n",
+			__func__);
+		return -1;
+	}
+
+	if ((txsize != 0) && (rxsize != 0)) {
+		if (usif_cfg->duplex_mode == LANTIQ_USIF_SPI_FULL_DUPLEX) {
+			if (txsize != rxsize) {
+				stats->dlx_err++;
+				printk(KERN_ERR
+					"%s full duplex required TX/RX has"
+					" the same amount of data tx %d rx %d\n",
+					__func__, txsize, rxsize);
+				return -1;
+			}
+		}
+	}
+
+	/*
+	 * Ensure that only asynchronous USIF Handles could enqueue an
+	 * asynchronous request. The parameter 'usifHandleType' is set
+	 * during the ConnId allocation process.
+	 */
+	if (pqueue->handle_type != LANTIQ_USIF_SPI_HANDL_TYPE_ASYNC) {
+		stats->handler_err++;
+		printk(KERN_ERR "%s must use async handler\n", __func__);
+		return -1;
+	}
+
+	/*
+	 * Check if the queue entry of the ConnId is already queued with
+	 * a request but this request is not served yet. Every ConnId can
+	 * only queue up one request at the time.
+	 */
+	if (atomic_read(&pqueue->isqueued) == 1) {
+		stats->dup_qentries++;
+		LANTIQ_USIF_PRINT(port, USIF_MSG_ERROR,
+			"%s same queue has queued more than once\n", __func__);
+		return -1;
+	}
+
+	/* Add pointer and sizes to the queue entry of this USIF handle. */
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+	pqueue->txbuf = txbuf;
+	pqueue->txsize = txsize;
+	pqueue->rxbuf = rxbuf;
+	pqueue->rxsize = rxsize;
+	if (pCallback != NULL)
+		pqueue->callback = *pCallback;
+
+	pqueue->request_lock = false;
+	pqueue->exchange_bytes = 0;
+	atomic_set(&pqueue->isqueued, 1);
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+	/* Add queue entry to priority synchronous queue */
+	lantiq_usif_spi_enqueue(pqueue);
+	/*
+	 * Trigger schedule or tasklet or fake interrupt according to different
+	 * cases.
+	 */
+	lantiq_usif_spi_start_tasklet(port);
+	return 0;
+}
+EXPORT_SYMBOL(lantiq_usif_spiAsyncTxRx);
+
+/**
+ * \fn int lantiq_usif_spiAsyncTx(LANTIQ_USIF_SPI_HANDLE_t handler,
+ *	LANTIQ_USIF_SPI_ASYNC_CALLBACK_t *pCallback, char *txbuf, int txsize)
+ * \brief transmit the data, located at "txbuf". The "txsize" amount of
+ * bytes is transmitted over USIF.
+
+ * The USIF driver sets the chipselect when the data transmission starts and
+ * resets it when the transmission is completed.
+ * This routine is called to start an asynchronous data transmission.
+ * The provided callback routine is called after the transmission is done.
+ *
+ * \param   handler    Handle of the connection where to make the configuration
+ *                     on
+ * \param   pCallback  Function callback that is called after the request is
+ *                     performed.
+ * \param   txbuf      Pointer to the data packet to transmit.
+ * \param   txsize     Amount of Bytes to transmit.
+
+ * \return Returns the amount of bytes that are transmitted in case of
+ *  successful transmission. In case of an error the function returns (-1).
+ *
+ * \remarks This function activates the chipselect before data transmission and
+ *  deactivates it after transmission (when function returns). This is done
+ *  with the callback function. The chipselect is not modified in case
+ * \ingroup LANTIQ_USIF_SPI_FUNCTIONS
+ */
+int
+lantiq_usif_spiAsyncTx(LANTIQ_USIF_SPI_HANDLE_t handler,
+		LANTIQ_USIF_SPI_ASYNC_CALLBACK_t *pCallback, char *txbuf,
+		int txsize)
+{
+	return lantiq_usif_spiAsyncTxRx(handler,
+		pCallback, txbuf, txsize, NULL, 0);
+}
+EXPORT_SYMBOL(lantiq_usif_spiAsyncTx);
+
+/**
+ * \fn int lantiq_usif_spiAsyncRx(LANTIQ_USIF_SPI_HANDLE_t handler,
+ * LANTIQ_USIF_SPI_ASYNC_CALLBACK_t *pCallback, char *rxbuf, int rxsize)
+ * \brief Receive from USIF. The received data are stored at "rxbuf".
+ * The "rxsize" describes the amount of bytes to receive from USIF.
+
+ * The USIF driver sets the chipselect when the data reception starts and
+ * resets it when the reception is completed.
+ *
+ * \param   handler    Handle of the connection where to make the
+ *                     configuration on
+ * \param   pCallback  Function callback that is called after the request
+ *                     is performed.
+ * \param   rxbuf      Pointer to store the received data packet.
+ * \param   rxsize     Amount of Bytes to receive.
+
+ * \return  Returns the amount of bytes that are received in case of
+ * successful transmission. In case of an error the function returns (-1).
+ *
+ * \remarks This function activates the chipselect before data transmission
+ * and deactivates it after transmission (when function returns). This is
+ * done with the callback function. The chipselect is not modified in case
+ * \ingroup LANTIQ_USIF_SPI_FUNCTIONS
+ */
+int
+lantiq_usif_spiAsyncRx(LANTIQ_USIF_SPI_HANDLE_t handler,
+	LANTIQ_USIF_SPI_ASYNC_CALLBACK_t *pCallback, char *rxbuf,
+	int rxsize)
+{
+	return lantiq_usif_spiAsyncTxRx(handler,
+		pCallback, NULL, 0, rxbuf, rxsize);
+}
+EXPORT_SYMBOL(lantiq_usif_spiAsyncRx);
+
+/**
+ * \fn int lantiq_usif_spiAsyncLock(LANTIQ_USIF_SPI_HANDLE_t handler,
+ * LANTIQ_USIF_SPI_ASYNC_CALLBACK_t *pCallback)
+ *
+ * \brief This function locks and reserves the whole USIF interface
+ * for the given 'handler'.
+
+ *  The chipselect, belonging to this USIF session is already
+ *  activated. This means the chipselect callback is called.
+ *  After complete data transmission and reception,
+ *  This routine is called to get the lock on tasklet level.
+ *  The provided callback routine is called after the lock is set.
+ *
+ * \param handler Handle of the connection.
+ * \param pCallback Function callback that is called after the request is
+ *  performed.
+ *
+ * \return Return (0) in case of success, otherwise (-1) in case of errors.
+ *
+ * \remarks This function actives the USIF chipselect of this 'handler'
+ * by calling the callback function.
+ * \ingroup LANTIQ_USIF_SPI_FUNCTIONS
+ */
+int
+lantiq_usif_spiAsyncLock(LANTIQ_USIF_SPI_HANDLE_t handler,
+		   LANTIQ_USIF_SPI_ASYNC_CALLBACK_t *pCallback)
+{
+	lantiq_usif_device_t *dev;
+	LANTIQ_USIF_SPI_CONFIGURE_t *usif_cfg;
+	struct lantiq_usif_port *port;
+	LANTIQ_USIF_QUEUE_t *pqueue;
+
+	LANTIQ_KASSERT((handler != NULL),
+		("%s Invalid parameter\n", __func__));
+	LANTIQ_KASSERT((pCallback != NULL),
+		("%s Invalid parameter\n", __func__));
+
+	dev = (lantiq_usif_device_t *) handler;
+	pqueue = &dev->queue;
+	usif_cfg = &dev->conn_id;
+	port = dev->port;
+
+	if (port->lock_qentry == pqueue) {
+		/* We hold the lock already -> nothing to request here! */
+		return -1;
+	}
+
+	/*
+	 * Check if the queue entry of the ConnId is already queued with
+	 * a request  but this request is not served yet. Every ConnId can
+	 * only queue up one  request at the time.
+	 */
+	if (atomic_read(&pqueue->isqueued) == 1)
+		return -1;
+
+	/* Initialize unused variable */
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+	pqueue->txbuf = NULL;
+	pqueue->txsize = 0;
+	pqueue->rxbuf = NULL;
+	pqueue->rxsize = 0;
+
+	/* Place a lock request in the queue */
+	pqueue->request_lock = true;
+	pqueue->callback = *pCallback;
+
+	pqueue->exchange_bytes = 0;
+	atomic_set(&pqueue->isqueued, 1);
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+	/* Add queue entry to priority synchronous queue */
+	lantiq_usif_spi_enqueue(pqueue);
+
+	/*
+	 * Calls the internal process to serve the queue. This routine would
+	 * immediately return in case  the USIF hardware is currently used
+	 * to serve another request.
+	 */
+	lantiq_usif_spi_start_tasklet(port);
+	return 0;
+}
+EXPORT_SYMBOL(lantiq_usif_spiAsyncLock);
+/**
+ * \fn int lantiq_usif_spiAsyncUnLock(LANTIQ_USIF_SPI_HANDLE_t handler)
+ * \brief This function releases the USIF lock that was placed before
+ * by calling
+ * \ref lantiq_usif_spiAsyncLock. This function also inactivate the chipselect
+ * signal, which was set in \ref lantiq_usif_spiAsyncLock.
+
+ * \param handler Handle of the connection.
+ *
+ * \return Return (0) in case of success, otherwise (-1) in case of errors.
+ * \ingroup LANTIQ_USIF_SPI_FUNCTIONS
+ */
+int lantiq_usif_spiAsyncUnLock(LANTIQ_USIF_SPI_HANDLE_t handler)
+{
+	lantiq_usif_device_t *dev;
+	LANTIQ_USIF_SPI_CONFIGURE_t *usif_cfg = NULL;
+	struct lantiq_usif_port *port = NULL;
+	LANTIQ_USIF_QUEUE_t *pqueue;
+
+	LANTIQ_KASSERT((handler != NULL),
+		("%s Invalid parameter\n", __func__));
+
+	dev = (lantiq_usif_device_t *) handler;
+	pqueue = &dev->queue;
+	usif_cfg = &dev->conn_id;
+	port = dev->port;
+
+	if (port->lock_qentry != pqueue) {
+		/* We do not hold the lock, therefore we can not release it! */
+		return -1;
+	}
+
+	/* Just forget about the lock, then the USIF driver would just take it
+	 * as a normel queue entry
+	 */
+	lantiq_usif_spi_cs_unlock(dev);
+
+	/* Reset to the default value */
+	LANTIQ_USIF_SPI_IRQ_LOCK(port);
+	pqueue->txbuf = NULL;
+	pqueue->txsize = 0;
+	pqueue->rxbuf = NULL;
+	pqueue->rxsize = 0;
+	pqueue->exchange_bytes = 0;
+	memset(&pqueue->callback, 0,
+		sizeof(LANTIQ_USIF_SPI_ASYNC_CALLBACK_t));
+
+	port->lock_qentry = NULL;
+	LANTIQ_USIF_SPI_IRQ_UNLOCK(port);
+	/* Restart tasklet since we are async release SPI bus */
+	lantiq_usif_spi_start_tasklet(port);
+	return 0;
+}
+EXPORT_SYMBOL(lantiq_usif_spiAsyncUnLock);
+
+#ifdef CONFIG_SYSCTL
+/*
+ * Deal with the sysctl handler api changing.
+ */
+
+#define USIF_SYSCTL_DECL(f, ctl, write, filp, buffer, lenp, ppos) \
+	f(ctl_table * ctl, int write, \
+	void __user *buffer, size_t *lenp, loff_t *ppos)
+
+#define USIF_SYSCTL_PROC_DOINTVEC(ctl, write, filp, buffer, lenp, ppos) \
+	proc_dointvec(ctl, write, buffer, lenp, ppos)
+
+enum {
+	USIF_SPI_PRIV_FRAGMENT_SIZE = 1,
+	USIF_SPI_PRIV_FIFO_SIZE = 2,
+	USIF_SPI_PRIV_BAUDRATE = 3,
+	USIF_SPI_PRIV_MODE = 4,
+};
+
+static int
+USIF_SYSCTL_DECL(usif_sysctl_private, ctl, write, filp, buffer, lenp, ppos)
+{
+	lantiq_usif_device_t *dev = ctl->extra1;
+	LANTIQ_USIF_SPI_CONFIGURE_t *usif_cfg = &dev->conn_id;
+	struct lantiq_usif_port *port;
+	u32 val;
+	int ret;
+
+	port = dev->port;
+	ctl->data = &val;
+	ctl->maxlen = sizeof(val);
+	if (write) {
+		ret = USIF_SYSCTL_PROC_DOINTVEC(ctl, write, filp, buffer,
+			lenp, ppos);
+		if (ret == 0) {
+			switch ((long) ctl->extra2) {
+			case USIF_SPI_PRIV_FRAGMENT_SIZE:
+				if (val < LANTIQ_USIF_SPI_MIN_FRAGSIZE
+				    || val > LANTIQ_USIF_SPI_MAX_FRAGSIZE)
+					return -EINVAL;
+				usif_cfg->fragSize = val;
+				port->usif_frag_size = val;
+				break;
+
+			case USIF_SPI_PRIV_FIFO_SIZE:
+				if (val < LANTIQ_USIF_SPI_FIFO_MIN_THRESHOULD
+				    || val >
+				    LANTIQ_USIF_SPI_FIFO_MAX_THRESHOULD)
+					return -EINVAL;
+				usif_cfg->maxFIFOSize = val;
+				break;
+
+			case USIF_SPI_PRIV_BAUDRATE:
+				/* XXX, sanity check */
+				usif_cfg->baudrate = val;
+				break;
+
+			case USIF_SPI_PRIV_MODE:
+				ret = -EINVAL;
+				break;
+
+			default:
+				return -EINVAL;
+			}
+		}
+	} else {
+		switch ((long) ctl->extra2) {
+		case USIF_SPI_PRIV_FRAGMENT_SIZE:
+			val = usif_cfg->fragSize;
+			break;
+
+		case USIF_SPI_PRIV_FIFO_SIZE:
+			val = usif_cfg->maxFIFOSize;
+			break;
+
+		case USIF_SPI_PRIV_BAUDRATE:
+			val = usif_cfg->baudrate;
+			break;
+
+		case USIF_SPI_PRIV_MODE:
+			val = usif_cfg->spi_mode;
+			break;
+
+		default:
+			return -EINVAL;
+		}
+		ret = USIF_SYSCTL_PROC_DOINTVEC(ctl, write, filp, buffer,
+			lenp, ppos);
+	}
+	return ret;
+}
+
+static const ctl_table usif_sysctl_template[] = {
+	/* NB: must be last entry before NULL */
+	{LANTIQ_INIT_CTL_NAME(CTL_AUTO)
+	 .procname = "fragment_size",
+	 .mode = 0644,
+	 .proc_handler = usif_sysctl_private,
+	 .extra2 = (void *) USIF_SPI_PRIV_FRAGMENT_SIZE,
+	 },
+	{LANTIQ_INIT_CTL_NAME(CTL_AUTO)
+	 .procname = "fifosize",
+	 .mode = 0644,
+	 .proc_handler = usif_sysctl_private,
+	 .extra2 = (void *) USIF_SPI_PRIV_FIFO_SIZE,
+	 },
+	{LANTIQ_INIT_CTL_NAME(CTL_AUTO)
+	 .procname = "baudrate",
+	 .mode = 0644,
+	 .proc_handler = usif_sysctl_private,
+	 .extra2 = (void *) USIF_SPI_PRIV_BAUDRATE,
+	 },
+	{LANTIQ_INIT_CTL_NAME(CTL_AUTO)
+	 .procname = "spimode",
+	 .mode = 0644,
+	 .proc_handler = usif_sysctl_private,
+	 .extra2 = (void *) USIF_SPI_PRIV_MODE,
+	 },
+	{0}
+};
+
+static void lantiq_usif_spi_sysctl_attach(lantiq_usif_device_t *dev)
+{
+	int i, space;
+
+	space = 5 * sizeof(struct ctl_table) +
+		sizeof(usif_sysctl_template);
+	dev->usif_sysctls = kmalloc(space, GFP_KERNEL);
+	if (dev->usif_sysctls == NULL) {
+		printk(KERN_ERR "%s: no memory for sysctl table!\n", __func__);
+		return;
+	}
+
+	/* setup the table */
+	memset(dev->usif_sysctls, 0, space);
+	LANTIQ_SET_CTL_NAME(dev->usif_sysctls[0], CTL_DEV);
+	dev->usif_sysctls[0].procname = "dev";
+	dev->usif_sysctls[0].mode = 0555;
+	dev->usif_sysctls[0].child = &dev->usif_sysctls[2];
+	/* [1] is NULL terminator */
+	LANTIQ_SET_CTL_NAME(dev->usif_sysctls[2], CTL_AUTO);
+	dev->usif_sysctls[2].procname = dev->dev_name;
+	dev->usif_sysctls[2].mode = 0555;
+	dev->usif_sysctls[2].child = &dev->usif_sysctls[4];
+	/* [3] is NULL terminator */
+	/* copy in pre-defined data */
+	memcpy(&dev->usif_sysctls[4], usif_sysctl_template,
+		sizeof(usif_sysctl_template));
+
+	/* add in dynamic data references */
+	for (i = 4; dev->usif_sysctls[i].procname; i++) {
+		if (dev->usif_sysctls[i].extra1 == NULL)
+			dev->usif_sysctls[i].extra1 = dev;
+
+	}
+
+	/* tack on back-pointer to parent device */
+	dev->usif_sysctls[i - 1].data = dev->dev_name;
+
+	/* and register everything */
+	dev->usif_sysctl_header =
+		LANTIQ_REGISTER_SYSCTL_TABLE(dev->usif_sysctls);
+	if (!dev->usif_sysctl_header) {
+		printk(KERN_WARNING "%s: failed to register sysctls!\n",
+			dev->dev_name);
+		kfree(dev->usif_sysctls);
+		dev->usif_sysctls = NULL;
+	}
+}
+
+static void lantiq_usif_spi_sysctl_detach(lantiq_usif_device_t *dev)
+{
+	if (dev->usif_sysctl_header) {
+		unregister_sysctl_table(dev->usif_sysctl_header);
+		dev->usif_sysctl_header = NULL;
+	}
+	if (dev->usif_sysctls) {
+		kfree(dev->usif_sysctls);
+		dev->usif_sysctls = NULL;
+	}
+}
+
+/* USIF Driver itself proc support for debug and future configuration */
+enum {
+	USIF_SPI_PRIV_DEBUG = 1,
+};
+
+static int
+USIF_SYSCTL_DECL(port_sysctl_private, ctl, write, filp, buffer, lenp, ppos)
+{
+	struct lantiq_usif_port *port = ctl->extra1;
+	u32 val;
+	int ret;
+
+	ctl->data = &val;
+	ctl->maxlen = sizeof(val);
+	if (write) {
+		ret = USIF_SYSCTL_PROC_DOINTVEC(ctl, write, filp, buffer,
+			lenp, ppos);
+		if (ret == 0) {
+			switch ((long) ctl->extra2) {
+			case USIF_SPI_PRIV_DEBUG:
+				port->usif_debug = val;
+				break;
+
+			default:
+				return -EINVAL;
+			}
+		}
+	} else {
+		switch ((long) ctl->extra2) {
+		case USIF_SPI_PRIV_DEBUG:
+			val = port->usif_debug;
+			break;
+
+		default:
+			return -EINVAL;
+		}
+		ret = USIF_SYSCTL_PROC_DOINTVEC(ctl, write, filp, buffer,
+			lenp, ppos);
+	}
+	return ret;
+}
+
+static const ctl_table port_sysctl_template[] = {
+	/* NB: must be last entry before NULL */
+	{LANTIQ_INIT_CTL_NAME(CTL_AUTO)
+	 .procname = "debug",
+	 .mode = 0644,
+	 .proc_handler = port_sysctl_private,
+	 .extra2 = (void *) USIF_SPI_PRIV_DEBUG,
+	 },
+	{0}
+};
+
+static void lantiq_usif_spi_port_sysctl_attach(struct lantiq_usif_port *port)
+{
+	int i, space;
+
+	space = 5 * sizeof(struct ctl_table) +
+		sizeof(port_sysctl_template);
+	port->port_sysctls = kmalloc(space, GFP_KERNEL);
+	if (port->port_sysctls == NULL) {
+		printk(KERN_ERR "%s: no memory for sysctl table!\n", __func__);
+		return;
+	}
+
+	/* setup the table */
+	memset(port->port_sysctls, 0, space);
+	LANTIQ_SET_CTL_NAME(port->port_sysctls[0], CTL_DEV);
+	port->port_sysctls[0].procname = "dev";
+	port->port_sysctls[0].mode = 0555;
+	port->port_sysctls[0].child = &port->port_sysctls[2];
+	/* [1] is NULL terminator */
+	LANTIQ_SET_CTL_NAME(port->port_sysctls[2], CTL_AUTO);
+	port->port_sysctls[2].procname = port->name;
+	port->port_sysctls[2].mode = 0555;
+	port->port_sysctls[2].child = &port->port_sysctls[4];
+	/* [3] is NULL terminator */
+	/* copy in pre-defined data */
+	memcpy(&port->port_sysctls[4], port_sysctl_template,
+		sizeof(port_sysctl_template));
+
+	/* add in dynamic data references */
+	for (i = 4; port->port_sysctls[i].procname; i++) {
+		if (port->port_sysctls[i].extra1 == NULL)
+			port->port_sysctls[i].extra1 = port;
+	}
+
+	/* tack on back-pointer to parent device */
+	port->port_sysctls[i - 1].data = port->name;
+
+	/* and register everything */
+	port->port_sysctl_header =
+		LANTIQ_REGISTER_SYSCTL_TABLE(port->port_sysctls);
+	if (port->port_sysctl_header == NULL) {
+		printk(KERN_WARNING "%s: failed to register sysctls!\n",
+			port->name);
+		kfree(port->port_sysctls);
+		port->port_sysctls = NULL;
+	}
+}
+
+static void lantiq_usif_spi_port_sysctl_detach(struct lantiq_usif_port *port)
+{
+	if (port->port_sysctl_header != NULL) {
+		unregister_sysctl_table(port->port_sysctl_header);
+		port->port_sysctl_header = NULL;
+	}
+	if (port->port_sysctls != NULL) {
+		kfree(port->port_sysctls);
+		port->port_sysctls = NULL;
+	}
+}
+#endif /* CONFIG_SYSCTL */
+
+/**
+ *\fn LANTIQ_USIF_SPI_HANDLE_t lantiq_usif_spiAllocConnection
+ * (char *dev_name, LANTIQ_USIF_SPI_CONFIGURE_t *connid)
+ *\brief Allocate and create a Connection ID "ConnId"
+ *
+ * Allocate and create a Connection ID "ConnId" to communicate over USIF SPI.
+ * This ConnId is needed for all remaining USIF SPI driver API calls. This
+ * ConnId is a handle that helps the USIF SPI driver to find the configuration
+ * that belongs to the connection. ConnId specific parameters are e.g.
+ * Baudrate, Priority, Chipselect Callback, etc.
+ *
+ * \param   dev_name    unique name for this connection. If null, will alloc
+ *                      one unique name automatically
+ * \param   connid      Connectin id
+ * \return  a handle "LANTIQ_USIF_SPI_HANDLE_t" in case the allocation was
+ * successful. In case of an error, the return handle is zero (NULL).
+ * \ingroup LANTIQ_USIF_SPI_FUNCTIONS
+ */
+LANTIQ_USIF_SPI_HANDLE_t
+lantiq_usif_spiAllocConnection(char *dev_name, LANTIQ_USIF_SPI_CONFIGURE_t *connid)
+{
+	struct lantiq_usif_port *port;
+	lantiq_usif_device_t *p;
+	lantiq_usif_device_t *q;
+	LANTIQ_USIF_QUEUE_t *queue;
+	char buf[LANTIQ_USIF_SPI_MAX_DEVNAME] = { 0 };
+	char *pname;
+
+	port = &lantiq_usif_spi_port;
+
+	if (port->usif_ndevs >= LANTIQ_USIF_SPI_MAX_DEVICE) {
+		LANTIQ_USIF_PRINT(port, USIF_MSG_ERROR,
+			"%s device number out of range\n",
+			__func__);
+		return NULL;
+	}
+
+	if (connid == NULL) {
+		LANTIQ_USIF_PRINT(port, USIF_MSG_ERROR,
+			"%s must provide connection portrmation!\n",
+			__func__);
+		return NULL;
+	}
+
+	if ((connid->spi_mode < LANTIQ_USIF_SPI_MODE_0)
+	    || (connid->spi_mode > LANTIQ_USIF_SPI_MODE_3)) {
+		LANTIQ_USIF_PRINT(port, USIF_MSG_ERROR,
+			"%s invalid spi mode <%d~%d>!\n", __func__,
+			LANTIQ_USIF_SPI_MODE_0, LANTIQ_USIF_SPI_MODE_3);
+		return NULL;
+	}
+
+	if (connid->spi_prio < LANTIQ_USIF_SPI_PRIO_LOW
+	    || (connid->spi_prio > LANTIQ_USIF_SPI_PRIO_MAX)) {
+		LANTIQ_USIF_PRINT(port, USIF_MSG_ERROR,
+			"%s invalid priority <%d~%d>!\n", __func__,
+			LANTIQ_USIF_SPI_PRIO_LOW,
+			LANTIQ_USIF_SPI_PRIO_MAX);
+	}
+
+	if (connid->csset_cb == NULL) {
+		LANTIQ_USIF_PRINT(port, USIF_MSG_ERROR,
+			"%s must provide cs function\n", __func__);
+		return NULL;
+	}
+
+	if (connid->fragSize < LANTIQ_USIF_SPI_MIN_FRAGSIZE
+	    || connid->fragSize > LANTIQ_USIF_SPI_MAX_FRAGSIZE) {
+		LANTIQ_USIF_PRINT(port, USIF_MSG_ERROR,
+			"%s invalid fragment size <%d~%d>!\n",
+			__func__, LANTIQ_USIF_SPI_MIN_FRAGSIZE,
+			LANTIQ_USIF_SPI_MAX_FRAGSIZE);
+		return NULL;
+	}
+
+	if (connid->maxFIFOSize < LANTIQ_USIF_SPI_FIFO_MIN_THRESHOULD
+	    || connid->maxFIFOSize > LANTIQ_USIF_SPI_FIFO_MAX_THRESHOULD) {
+		LANTIQ_USIF_PRINT(port, USIF_MSG_ERROR,
+			"%s invalid fifo size <%d~%d>!\n", __func__,
+			LANTIQ_USIF_SPI_FIFO_MIN_THRESHOULD,
+			LANTIQ_USIF_SPI_FIFO_MAX_THRESHOULD);
+		return NULL;
+	}
+
+	if (connid->duplex_mode != LANTIQ_USIF_SPI_FULL_DUPLEX
+	    && connid->duplex_mode != LANTIQ_USIF_SPI_HALF_DUPLEX) {
+		LANTIQ_USIF_PRINT(port, USIF_MSG_ERROR,
+			"%s %d invalid duplex mode <%d~%d>!\n",
+			__func__, connid->duplex_mode,
+			LANTIQ_USIF_SPI_FULL_DUPLEX,
+			LANTIQ_USIF_SPI_HALF_DUPLEX);
+		return NULL;
+	}
+
+	/* If no name specified, will assign one name for identification */
+	if (dev_name == NULL) {
+		sprintf(buf, "usif%d", port->usif_ndevs);
+		pname = buf;
+	} else {
+		if (strlen(dev_name) > (LANTIQ_USIF_SPI_MAX_DEVNAME - 1)) {
+			LANTIQ_USIF_PRINT(port, USIF_MSG_ERROR,
+				"%s device name is too long\n", __func__);
+			return NULL;
+		}
+		pname = dev_name;
+	}
+
+	p = kmalloc(sizeof(lantiq_usif_device_t), GFP_KERNEL);
+	if (p == NULL) {
+		LANTIQ_USIF_PRINT(port, USIF_MSG_ERROR,
+			"%s failed to allocate memory\n", __func__);
+		return NULL;
+	}
+	memset(p, 0, sizeof(lantiq_usif_device_t));
+
+	LANTIQ_USIF_SPI_SEM_LOCK(port->dev_sem);
+	TAILQ_FOREACH(q, &port->usif_devq, dev_entry) {
+		if (strcmp(q->dev_name, pname) == 0) {
+			kfree(p);
+			LANTIQ_USIF_SPI_SEM_UNLOCK(port->dev_sem);
+			LANTIQ_USIF_PRINT(port, USIF_MSG_ERROR,
+				"%s device registered already!\n", __func__);
+			return NULL;
+		}
+	}
+	LANTIQ_USIF_SPI_SEM_UNLOCK(port->dev_sem);
+
+	/* Follow net device driver name rule */
+	memcpy(p->dev_name, pname, LANTIQ_USIF_SPI_MAX_DEVNAME);
+	p->duplex = connid->duplex_mode;
+	memcpy((char *) &p->conn_id, (char *) connid,
+		sizeof(LANTIQ_USIF_SPI_CONFIGURE_t));
+
+	queue = &p->queue;
+	/* Queue handler type converted from priority */
+	if (connid->spi_prio == LANTIQ_USIF_SPI_PRIO_ASYNC)
+		queue->handle_type = LANTIQ_USIF_SPI_HANDL_TYPE_ASYNC;
+	else
+		queue->handle_type = LANTIQ_USIF_SPI_HANDL_TYPE_SYNC;
+
+	/* Back pointer to later usage */
+	queue->dev = p;
+	atomic_set(&queue->isqueued, 0);
+	queue->request_lock = false;
+	/*
+	 * Just for fast access, priority based on device, instead of packet
+	 * Still keep per packet priority there for future change.
+	 */
+	p->dev_prio = connid->spi_prio;
+
+	LANTIQ_USIF_SPI_WAKELIST_INIT(p->dev_thread_wait);
+
+	p->port = port; /* back pointer to port for easy reference later */
+	port->usif_ndevs++;
+#ifdef CONFIG_SYSCTL
+	lantiq_usif_spi_sysctl_attach(p);
+#endif /* CONFIG_SYSCTL */
+	LANTIQ_USIF_SPI_SEM_LOCK(port->dev_sem);
+	TAILQ_INSERT_TAIL(&port->usif_devq, p, dev_entry);
+	LANTIQ_USIF_SPI_SEM_UNLOCK(port->dev_sem);
+
+	LANTIQ_USIF_PRINT(port, USIF_MSG_INIT,
+		"%s: device %s register sucessfully!\n", __func__,
+		p->dev_name);
+	return (LANTIQ_USIF_SPI_HANDLE_t) p;
+}
+EXPORT_SYMBOL(lantiq_usif_spiAllocConnection);
+
+/*!
+ *\fn int lantiq_usif_spiFreeConnection(LANTIQ_USIF_SPI_HANDLE_t handler)
+ *\brief Release usif spi connnection
+ *
+ * Release a ConnId handle that was allocated by the function
+ * lantiq_usif_spiAllocConnection before. An allocated ConnId has
+ * to be released by the client driver module when the USIF SPI
+ * driver is not used anymore. Note that all allocated ConnId's should
+ * be released before the USIF SPI driver is unloaded from the kernel.
+ *
+ * \param   handler    ConnId handle allocated by lantiq_usif_spiAllocConnection
+ * \returns (0) in case of success, otherwise (-1) in case of errors.
+ * \ingroup LANTIQ_USIF_SPI_FUNCTIONS
+ */
+int lantiq_usif_spiFreeConnection(LANTIQ_USIF_SPI_HANDLE_t handler)
+{
+	lantiq_usif_device_t *p;
+	struct lantiq_usif_port *port;
+	lantiq_usif_device_t *q, *next;
+
+	LANTIQ_KASSERT((handler != NULL),
+		("%s Invalid parameter\n", __func__));
+
+	p = (lantiq_usif_device_t *) handler;
+	port = p->port;
+	LANTIQ_USIF_SPI_SEM_LOCK(port->dev_sem);
+	TAILQ_FOREACH_SAFE(q, &port->usif_devq, dev_entry, next) {
+		if (strcmp(q->dev_name, p->dev_name) == 0) {
+			TAILQ_REMOVE(&port->usif_devq, q, dev_entry);
+		#ifdef CONFIG_SYSCTL
+			lantiq_usif_spi_sysctl_detach(q);
+		#endif /* CONFIG_SYSCTL */
+			kfree(q);
+			port->usif_ndevs--;
+			LANTIQ_USIF_SPI_SEM_UNLOCK(port->dev_sem);
+			LANTIQ_USIF_PRINT(port, USIF_MSG_INIT,
+				"%s device %s unregistered\n",
+				__func__, p->dev_name);
+			return 0;
+		}
+	}
+	LANTIQ_USIF_SPI_SEM_UNLOCK(port->dev_sem);
+	return -1;
+}
+EXPORT_SYMBOL(lantiq_usif_spiFreeConnection);
+
+/**
+ * \fn static int __init lantiq_usif_spi_init (void)
+ * \brief USIF-SPI module Initialization.
+ *
+ * \return -ENOMEM  Failed to allocate memory
+ *         -EBUSY   Failed to iomap register space
+ *         0        OK
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static int __init lantiq_usif_spi_init(void)
+{
+	struct lantiq_usif_port *port;
+	int i;
+	int ret_val = -ENOMEM;
+	char ver_str[128] = { 0 };
+	static int lantiq_usif_spi_initialized;
+
+	if (lantiq_usif_spi_initialized == 1)
+		return 0;
+	else
+		lantiq_usif_spi_initialized = 1;
+
+	memset(&lantiq_usif_spi_port, 0, sizeof(struct lantiq_usif_port));
+
+	/* Set default values in lantiq_usif_port */
+	port = &lantiq_usif_spi_port;
+
+	port->port_idx = 0;
+
+	/* default values for the HwOpts */
+	port->opts.sync = LANTIQ_USIF_SPI_DEF_SYNC;
+	port->opts.master = LANTIQ_USIF_SPI_DEF_MASTERSLAVE;
+	port->opts.frmctl = LANTIQ_USIF_SPI_DEF_FRMCTL;
+	port->opts.loopBack = LANTIQ_USIF_SPI_DEF_LOOP_BACK;
+	port->opts.echoMode = LANTIQ_USIF_SPI_DEF_ECHO_MODE;
+	port->opts.txInvert = LANTIQ_USIF_SPI_DEF_TX_INVERT;
+	port->opts.rxInvert = LANTIQ_USIF_SPI_DEF_RX_INVERT;
+	port->opts.shiftClk = LANTIQ_USIF_SPI_DEF_SHIFT_CLK;
+	port->opts.clkPO = LANTIQ_USIF_SPI_DEF_CLK_PO;
+	port->opts.clkPH = LANTIQ_USIF_SPI_DEF_CLK_PH;
+	port->opts.txIdleValue = LANTIQ_USIF_SPI_DEF_TX_IDLE_STATE;
+	port->opts.modeRxTx = LANTIQ_USIF_SPI_DEF_MODE_RXTX;
+
+	port->opts.charLen = LANTIQ_USIF_SPI_DEF_CHAR_LEN;
+	port->opts.hdrCtrl = LANTIQ_USIF_SPI_DEF_HDR_CTRL;
+	port->opts.wakeUp = LANTIQ_USIF_SPI_DEF_WAKEUP;
+
+	port->baudrate = LANTIQ_USIF_SPI_DEF_BAUDRATE;
+	port->prev_baudrate = 0;
+	port->prev_spi_mode = LANTIQ_USIF_SPI_MODE_UNKNOWN;
+	port->usif_ndevs = 0;
+	port->usif_frag_size = DEFAULT_USIF_SPI_FRAGMENT_SIZE;
+
+	/* Values specific to USIF SPI */
+	port->mapbase = LANTIQ_USIF_PHY_BASE;
+	port->membase = ioremap_nocache(port->mapbase, LANTIQ_USIF_SIZE);
+	if (!port->membase) {
+		printk(KERN_ERR "%s: Failed during io remap\n", __func__);
+		ret_val = -EBUSY;
+		goto errout1;
+	}
+	LANTIQ_USIF_PRINT(port, USIF_MSG_INIT,
+		"%s: mapbase 0x%08lx membase 0x%08x\n", __func__,
+		port->mapbase, (u32) port->membase);
+
+	/* Register with DMA engine */
+	port->dma_dev = dma_device_reserve("USIF");
+	if (port->dma_dev == NULL) {
+		printk(KERN_ERR "%s: Failed to reserve dma device!\n",
+			__func__);
+		goto errout2;
+	}
+
+	lantiq_usif_spi_init_dma_device(port->dma_dev);
+	strcpy(port->name, LANTIQ_USIF_SPI_NAME);
+	port->usif_cs_locked = false;
+	port->lock_qentry = NULL;
+	port->serve_qentry = NULL;
+#ifdef CONFIG_LANTIQ_USIF_SPI_DEBUG
+	port->usif_debug = USIF_MSG_INIT | USIF_MSG_ERROR; 
+#else
+	port->usif_debug = 0;
+#endif /* CONFIG_LANTIQ_USIF_SPI_DEBUG */
+
+	atomic_set(&port->dma_wait_state, 0);
+	port->dma_is_in_half_duplex = 1;
+	/* Either USIF tasklet or USIF kernel thread support, not both */
+#ifdef CONFIG_LANTIQ_USIF_SPI_ASYNCHRONOUS
+	lantiq_usif_spi_tasklet_init(port);
+#else
+	if (lantiq_usif_spi_thread_init(port)) {
+		printk(KERN_ERR "%s: unable to start usif_kthread\n",
+			__func__);
+		goto errout3;
+	}
+#endif /* CONFIG_LANTIQ_USIF_SPI_ASYNCHRONOUS */
+
+	/* The following buffer allocation for HW WAR, last 1~3 bytes in DMA
+	 * It will make sure buffer will align on dma burst length
+	 */
+	port->dma_orig_txbuf = kmalloc(DEFAULT_USIF_SPI_FRAGMENT_SIZE
+		+ ((port->dma_dev->tx_burst_len << 2) - 1), GFP_KERNEL);
+	if (port->dma_orig_txbuf == NULL) {
+		printk(KERN_ERR "%s: no memory for dma_orig_txbuf\n",
+			__func__);
+		goto errout4;
+	}
+	port->dma_txbuf = (char *) (((u32) (port->dma_orig_txbuf +
+		((port->dma_dev->tx_burst_len << 2) - 1)))
+		& ~((port->dma_dev->tx_burst_len << 2) - 1));
+
+
+	port->dma_orig_rxbuf = kmalloc(DEFAULT_USIF_SPI_FRAGMENT_SIZE
+		+ ((port->dma_dev->rx_burst_len << 2) - 1), GFP_KERNEL);
+	if (port->dma_orig_rxbuf == NULL) {
+		printk(KERN_ERR "%s: no memory for dma_orig_rxbuf\n",
+			__func__);
+		goto errout5;
+	}
+	port->dma_rxbuf = (char *) (((u32) (port->dma_orig_rxbuf +
+		((port->dma_dev->rx_burst_len << 2) - 1)))
+		& ~((port->dma_dev->rx_burst_len << 2) - 1));
+
+	TAILQ_INIT(&port->usif_devq);
+	TAILQ_INIT(&port->usif_asyncq);
+
+	for (i = 0; i < LANTIQ_USIF_SPI_PRIO_MAX; i++)
+		TAILQ_INIT(&port->usif_syncq[i]);
+
+	LANTIQ_USIF_SPI_Q_LOCK_INIT(port);
+	LANTIQ_USIF_SPI_SEM_INIT(port->dev_sem);
+	LANTIQ_USIF_SPI_WAKELIST_INIT(port->usif_thread_wait);
+	LANTIQ_USIF_SPI_IRQ_LOCK_INIT(port, "lantiq_usif_spi_lock");
+
+	if (lantiq_usif_spi_hwinit(port) < 0) {
+		printk(KERN_ERR "%s: hardware init failed for USIF SPI\n",
+			__func__);
+		goto errout6;
+	}
+#ifdef CONFIG_SYSCTL
+	lantiq_usif_spi_port_sysctl_attach(port);
+#endif /* CONFIG_SYSCTL */
+
+#ifdef CONFIG_PROC_FS
+	lantiq_usif_spi_proc_create();
+#endif
+	lantiq_usif_spi_drv_ver(ver_str);
+	printk(KERN_INFO "%s", ver_str);
+	return 0;
+
+errout6:
+	lantiq_usif_spi_gpio_release();
+	kfree(port->dma_orig_rxbuf);
+errout5:
+	kfree(port->dma_orig_txbuf);
+errout4:
+	kthread_stop(port->usif_tsk);
+#ifndef CONFIG_LANTIQ_USIF_SPI_ASYNCHRONOUS
+errout3:
+	dma_device_unregister(port->dma_dev);
+	dma_device_release(port->dma_dev);
+#endif
+errout2:
+	iounmap(port->membase);
+errout1:
+	return ret_val;
+}
+
+/**
+ * \fn static void __exit lantiq_usif_spi_exit (void)
+ * \brief USIF SPI Module Cleanup.
+ *
+ * Upon removal of the USIF-SPI module this function will free all allocated
+ * resources and unregister devices.
+ * \return none
+ * \ingroup LANTIQ_USIF_SPI_INTERNAL
+ */
+static void __exit lantiq_usif_spi_exit(void)
+{
+	struct dma_device_info *dma_dev;
+	struct lantiq_usif_port *port = &lantiq_usif_spi_port;
+
+	/* Exit running mode */
+	lantiq_usif_spi_clc_cfg_mode(port);
+
+	LANTIQ_USIF_SPI_SEM_LOCK(port->dev_sem);
+	if (!TAILQ_EMPTY(&port->usif_devq)) {
+		LANTIQ_USIF_SPI_SEM_UNLOCK(port->dev_sem);
+		printk(KERN_ERR "%s USIF devices still attached,"
+			" please release them first\n", __func__);
+		return;
+	}
+	LANTIQ_USIF_SPI_SEM_UNLOCK(port->dev_sem);
+
+#ifdef CONFIG_LANTIQ_USIF_SPI_ASYNCHRONOUS
+	tasklet_kill(&port->usif_txrxq);
+#else
+	if (port->usif_tsk) {
+		kthread_stop(port->usif_tsk);
+		port->usif_tsk = NULL;
+	}
+#endif /* CONFIG_LANTIQ_USIF_SPI_ASYNCHRONOUS */
+	LANTIQ_USIF_SPI_IRQ_LOCK_DESTROY(port);
+	LANTIQ_USIF_SPI_Q_LOCK_DESTROY(port);
+	dma_dev = port->dma_dev;
+	if (dma_dev != NULL) {
+		dma_device_unregister(dma_dev);
+		dma_device_release(dma_dev);
+	}
+#ifdef CONFIG_SYSCTL
+	lantiq_usif_spi_port_sysctl_detach(port);
+#endif /* CONFIG_SYSCTL */
+
+	kfree(port->dma_orig_rxbuf);
+	kfree(port->dma_orig_txbuf);
+#ifdef CONFIG_PROC_FS
+	lantiq_usif_spi_proc_delete();
+#endif
+	iounmap(port->membase);
+	lantiq_usif_spi_pm_disable();
+	lantiq_usif_spi_gpio_release();
+}
+
+module_init(lantiq_usif_spi_init);
+module_exit(lantiq_usif_spi_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Lei Chuanhua, Chuanhua.Lei@infineon.com");
+MODULE_DESCRIPTION("IFX USIF SPI driver for VRX200 reference board");
+MODULE_SUPPORTED_DEVICE("VRX200 builtin USIF-SPI module");
+
diff --git a/drivers/spi/lantiq_usif_spi_ar10.h b/drivers/spi/lantiq_usif_spi_ar10.h
new file mode 100644
--- /dev/null
+++ b/drivers/spi/lantiq_usif_spi_ar10.h
@@ -0,0 +1,48 @@
+/****************************************************************************
+*                             Copyright (c) 2010
+*                           Lantiq Deutschland GmbH
+*                    Am Campeon 3; 85579 Neubiberg, Germany
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+ *****************************************************************************/
+/*!
+  \file ltqmips_usif_spi_ar10.h
+  \ingroup IFX_USIF_SPI
+  \brief USIF SPI driver AR10 specific file
+*/
+#ifndef LTQMIPS_USIF_SPI_AR10_H
+#define LTQMIPS_USIF_SPI_AR10_H
+
+#include <linux/err.h>
+#include <linux/clk.h>
+
+static inline void lantiq_usif_spi_pm_enable(void)
+{
+	struct clk *clk;
+	
+	/* Activate USIF SPI */
+	clk = clk_get_sys("1da00000.usif", "NULL");
+	if (IS_ERR(clk)) {
+	        printk(KERN_ERR "USIF: failed to get clock\n");
+			        return;
+	}
+	clk_enable(clk);
+}
+
+
+static inline void lantiq_usif_spi_pm_disable(void)
+{
+	struct clk *clk;
+	
+	/* Activate USIF SPI */
+	clk = clk_get_sys("1da00000.usif", "usif");
+	if (IS_ERR(clk)) {
+	        printk(KERN_ERR "USIF: failed to get clock\n");
+			        return;
+	}
+	clk_disable(clk);
+}
+#endif /* LTQMIPS_USIF_SPI_AR10_H */
+
diff --git a/drivers/spi/lantiq_usif_spi_extern.h b/drivers/spi/lantiq_usif_spi_extern.h
new file mode 100644
--- /dev/null
+++ b/drivers/spi/lantiq_usif_spi_extern.h
@@ -0,0 +1,282 @@
+/******************************************************************************
+**
+** FILE NAME    : ltq_usif_spi.h
+** PROJECT      : IFX UEIP for VRX200
+** MODULES      : USIF for SPI Mode
+**
+** DATE         : 03 Jun 2009
+** AUTHOR       : Lei Chuanhua
+** DESCRIPTION  : USIF SPI mode for counterpart API
+** COPYRIGHT    :       Copyright (c) 2009
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+** HISTORY
+** $Date        $Author         $Comment
+** 03 Jun,2009  Lei Chuanhua    Initial version
+*******************************************************************************/
+
+#ifndef LTQ_USIF_SPI_H
+#define LTQ_USIF_SPI_H
+
+/*!
+  \defgroup LANTIQ_USIF_SPI IFX USIF SPI mode module
+  \brief ifx usif spi mode driver module
+*/
+
+/*!
+  \defgroup LANTIQ_USIF_SPI_DEFINITIONS Defintion and structures
+  \ingroup LANTIQ_USIF_SPI
+  \brief definitions for ifx usif spi mode driver
+*/
+
+/*!
+  \defgroup LANTIQ_USIF_SPI_FUNCTIONS External APIs
+  \ingroup LANTIQ_USIF_SPI
+  \brief usif spi external driver functions
+*/
+
+/*!
+  \defgroup LANTIQ_USIF_SPI_INTERNAL Internal functions
+  \ingroup LANTIQ_USIF_SPI
+  \brief usif spi internal driver functions
+*/
+
+/*!
+  \file ltq_usif_spi.h
+  \brief header file for usif spi driver
+*/
+
+/* @{ */
+/*!
+ \addtogroup LANTIQ_USIF_SPI_DEFINITIONS
+*/
+/*! \enum  LANTIQ_USIF_SPI_PRIO_t
+    \brief Set communication priority of USIF_SPI connection
+
+    Three priority levels are defined. Low-level priority queue used for
+    applications like FLASH driver (lantiq_usif_spi_prio_low). normal
+    priority queue used for applications like display
+    (lantiq_usif_spi_prio_mid). High priority queue used for applications
+    like RTP packet transfer (lantiq_usif_spi_prio_high).
+ */
+typedef enum {
+	/*!< Low Priority queue. For FLASH driver, etc. */
+	LANTIQ_USIF_SPI_PRIO_LOW = 0,
+	/*!< Normal Priority queue. For LCD, display data, etc. */
+	LANTIQ_USIF_SPI_PRIO_MID,
+	/*!< High priority queue. Ror RTP voice, etc. */
+	LANTIQ_USIF_SPI_PRIO_HIGH,
+	/*!< Tasklet priority (This is the highest supported priority). For
+	     this priority level only the asynchronous API set of the USIF
+	     driver can be called. These funtions stay unblocked and a
+	     callback function is called when the request is processed.
+	     This allows that the APIs are called from tasklet level.
+	     The callback function is always called on tasklet level */
+	LANTIQ_USIF_SPI_PRIO_ASYNC,
+} LANTIQ_USIF_SPI_PRIO_t;
+
+#define LANTIQ_USIF_SPI_PRIO_MAX LANTIQ_USIF_SPI_PRIO_ASYNC
+
+
+/*! \enum  LANTIQ_USIF_SPI_MODE_t
+    \brief Defines the Ssc hardware mode settings supported
+
+    Because there is no official specification, what exactly SPI is and what
+    not, it is necessary to consult the data sheets of the components one
+    wants to use. Important are the permitted clock frequencies and the type
+    of valid transitions. There are no general rules for transitions where
+    data should be latched. Although not specified by Motorola, in practice
+    four modes are used. These four modes are the combinations of CPOL and
+    CPHA. In table 1, the four modes are listed.If the phase of the clock is
+    zero, i.e. CPHA = 0, data is latched at the rising edge of the clock with
+    CPOL = 0, and at the falling edge of the clock with CPOL = 1. If CPHA = 1,
+    the polarities are reversed. CPOL = 0 means falling edge, CPOL = 1 rising
+    edge.The micro controllers from Motorola allow the polarity and the phase
+    of the clock to be adjusted. A positive polarity results in latching data
+    at the rising edge of the clock. However data is put on the data line
+    already at the falling edge in order to stabilize. Most peripherals which
+    can only be slaves, work with this configuration. If it should become
+    necessary to use the other polarity, transitions are reversed.
+  */
+typedef enum {
+	LANTIQ_USIF_SPI_MODE_0 = 0, /*!< CPOL=0,CPHA=0 */
+	LANTIQ_USIF_SPI_MODE_1, /*!< CPOL=0,CPHA=1 */
+	LANTIQ_USIF_SPI_MODE_2, /*!< CPOL=1,CPHA=0 */
+	LANTIQ_USIF_SPI_MODE_3, /*!< CPOL=1,CPHA=1 */
+	LANTIQ_USIF_SPI_MODE_UNKNOWN, /*!< Unknown SPI mode */
+} LANTIQ_USIF_SPI_MODE_t;
+
+/*! \enum  LANTIQ_USIF_SPI_HANDL_TYPE_t
+    \brief Defines the USIF SPI handler type supported
+  */
+typedef enum {
+	/*!< Only SYNC handler which be used by sync application */
+	LANTIQ_USIF_SPI_HANDL_TYPE_SYNC = 0,
+	/*!< Only ASYNC handler which be used by async application */
+	LANTIQ_USIF_SPI_HANDL_TYPE_ASYNC,
+} LANTIQ_USIF_SPI_HANDL_TYPE_t;
+
+/*! \enum  LANTIQ_USIF_SPI_DLX_t
+    \brief Set communication duplex mode of USIF SPI connection
+
+    The duplex mode is used to notify USIF SPI bus driver by USIF SPI device
+    driver about what kind of communication mode should be used. Which duplex
+    mode will be used depends on the USIF SPI device driver instead of USIF
+    SPI bus driver.
+ */
+typedef enum {
+	/*!< Half Duplex. Interface is used in half duplex when calling
+	    \ref lantiq_usif_spiTxRx or \ref lantiq_usif_spiAsyncTxRx The TX path
+	     is servered before the RX path. */
+	LANTIQ_USIF_SPI_HALF_DUPLEX = 0,
+	/*!< Full Duplex. Interface is used in full duplex when calling
+	     \ref lantiq_usif_spiTxRx or \ref lantiq_usif_spiAsyncTxRx. The TX
+	     -and RX- path is servered simultaneously. */
+
+	LANTIQ_USIF_SPI_FULL_DUPLEX,
+} LANTIQ_USIF_SPI_DLX_t;
+
+/*!< \typedef LANTIQ_USIF_SPI_CS_DATA_t
+     \brief Definition of device specific data for chip select
+ */
+typedef int LANTIQ_USIF_SPI_CS_DATA_t;
+
+/* chip select number */
+#define LANTIQ_USIF_SPI_CS0    0
+#define LANTIQ_USIF_SPI_CS1    1
+#define LANTIQ_USIF_SPI_CS2    2
+#define LANTIQ_USIF_SPI_CS3    3
+#define LANTIQ_USIF_SPI_CS4    4
+#define LANTIQ_USIF_SPI_CS5    5
+#define LANTIQ_USIF_SPI_CS6    6
+#define LANTIQ_USIF_SPI_CS7    7
+
+enum {
+	LANTIQ_USIF_SPI_CS_ON = 0,
+	LANTIQ_USIF_SPI_CS_OFF,
+};
+
+/*! \typedef LANTIQ_USIF_SPI_CS_CB_t
+    \brief Chip Select Callback function type declaration
+
+     csq csq=0, i.e. CS low (active). csq=1, i.e.CS high (idle).
+     cs_data This is the device number in case if more than one device is
+     using the same registered driver. E.g. two VINETICs, each with it´s own CS.
+ */
+typedef int (*LANTIQ_USIF_SPI_CS_CB_t) (u32 csq,
+	LANTIQ_USIF_SPI_CS_DATA_t cs_data);
+
+/*! typedef lantiq_usif_spi_async_fkt_cb_t
+    \brief Callback definition for asynchronous USIF API calls. This callback
+    is called by the USIF driver on tasklet level after the request is
+    completed or exit with an error.
+
+    \param handle Funktion handle that provided for callback registration
+     during the SSC asynchronous API call.
+    \param retvalue This return value describe if the asynchronous request
+     identified an error and worked successfully.
+*/
+typedef void (*lantiq_usif_spi_async_fkt_cb_t) (int handle, int retvalue);
+
+/*! typedef LANTIQ_SSC_ASYNC_CALLBACK_t
+    \brief Parameter to specify the asynchronous callback. It is called by the
+    USIF tasklet after the requested transmission or locking is done.
+*/
+typedef struct {
+	/*!< Callback function pointer, called in the USIF tasklet
+	     when the requested command is executed */
+	lantiq_usif_spi_async_fkt_cb_t pFunction;
+	/*!< Callback function handle. This parameter is transparently
+	     given to the callback function without any modification
+	     by the USIF driver */
+	int functionHandle;
+} LANTIQ_USIF_SPI_ASYNC_CALLBACK_t;
+
+/*!  \brief Parameter structure used to configure an USIF_SPI connection
+ * "ConnId".
+ */
+typedef struct {
+	/*!< Defines the hardware setup mode of the USIF_SPI */
+	LANTIQ_USIF_SPI_MODE_t spi_mode;
+	/*!< The communication priority of USIF_SPI connection. Three priority
+	     levels are defined. Low-level priority queue used for applications
+	     like FLASH driver (lantiq_usif_spi_prio_low). Normal priority queue
+	     used for applications like display (lantiq_usif_spi_prio_mid). High
+	     priority queue used for applications like RTP packet transfer
+	     (lantiq_usif_spi_prio_high). The here defined USIF_SPI priority
+	     corresponds to the priority the USIF_SPI driver application and
+	     should be set just for information when the driver is registered
+	     by the application. */
+	LANTIQ_USIF_SPI_PRIO_t spi_prio;
+	/*!< Baudrate used for the ConnId. This parameter can be later be
+	     modified by a call of lantiq_usif_spiSetBaud */
+	int baudrate;
+
+	/*!< All transmitted and received packets should be fragmented in this
+	     fragment size. Size given in Bytes. A maximum of 1024 Bytes is
+	     allowed. If the client uses a bigger values here, USIF_SPI returns
+	     with error. The client has to take care of the fragmentation */
+	int fragSize;
+	/*!< Maximum packet size in FIFO mode. All transmitted and received
+	     packets are transmitted in DMA mode if the packet size is greater
+	     than this value. A value of 148 is recommended at first. Size
+	     given in Bytes */
+	int maxFIFOSize;
+	/*!< Function Callback called by USIF_SPI driver when it starts/stops
+	     to receive or transmit */
+	LANTIQ_USIF_SPI_CS_CB_t csset_cb;
+	/*!< Parameter used for the function call of "csSet_cb". */
+	LANTIQ_USIF_SPI_CS_DATA_t cs_data;
+	/*!< Duplex Mode Selector. Connection used the USIF SPI interface
+	     either in half- or full- duplex mode. */
+	LANTIQ_USIF_SPI_DLX_t duplex_mode;
+
+} LANTIQ_USIF_SPI_CONFIGURE_t;
+
+/*! \typedef LANTIQ_USIF_SPI_HANDLE_t
+    \brief Definition of the connection handle
+
+     as it is used by the client kernel module that use the USIF_SPI driver
+     Inside of the USIF_SPI driver, this handle is mapped to an internal
+     structure that contains the connection specific parameter (e.g.
+     Baudrate, Chipselect Callbacks, etc.).
+ */
+typedef void *LANTIQ_USIF_SPI_HANDLE_t;
+/* @} */
+
+extern int lantiq_usif_spi_cs_low(u32 pin);
+extern int lantiq_usif_spi_cs_high(u32 pin);
+extern int lantiq_usif_spiLock(LANTIQ_USIF_SPI_HANDLE_t handler);
+extern int lantiq_usif_spiUnlock(LANTIQ_USIF_SPI_HANDLE_t handler);
+extern int lantiq_usif_spiSetBaud(LANTIQ_USIF_SPI_HANDLE_t handler,
+			unsigned int baud);
+extern int lantiq_usif_spiTxRx(LANTIQ_USIF_SPI_HANDLE_t handler, char *txbuf,
+			u32 txlen, char *rxbuf, u32 rxlen);
+extern int lantiq_usif_spiRx(LANTIQ_USIF_SPI_HANDLE_t handler, char *rxbuf,
+			u32 rxlen);
+extern int lantiq_usif_spiTx(LANTIQ_USIF_SPI_HANDLE_t handler, char *txbuf,
+			u32 txlen);
+extern LANTIQ_USIF_SPI_HANDLE_t lantiq_usif_spiAllocConnection(char *dev_name,
+		 LANTIQ_USIF_SPI_CONFIGURE_t *connid);
+extern int lantiq_usif_spiFreeConnection(LANTIQ_USIF_SPI_HANDLE_t handler);
+extern int lantiq_usif_spiAsyncTxRx(LANTIQ_USIF_SPI_HANDLE_t handler,
+	LANTIQ_USIF_SPI_ASYNC_CALLBACK_t *pCallback,
+	char *txbuf, int txsize, char *rxbuf, int rxsize);
+extern int lantiq_usif_spiAsyncTx(LANTIQ_USIF_SPI_HANDLE_t handler,
+		LANTIQ_USIF_SPI_ASYNC_CALLBACK_t *pCallback,
+		char *txbuf, int txsize);
+extern int lantiq_usif_spiAsyncRx(LANTIQ_USIF_SPI_HANDLE_t handler,
+		LANTIQ_USIF_SPI_ASYNC_CALLBACK_t *pCallback,
+		char *rxbuf, int rxsize);
+
+extern int lantiq_usif_spiAsyncLock(LANTIQ_USIF_SPI_HANDLE_t handler,
+	LANTIQ_USIF_SPI_ASYNC_CALLBACK_t *pCallback);
+extern int lantiq_usif_spiAsyncUnLock(LANTIQ_USIF_SPI_HANDLE_t handler);
+
+#endif /* LTQ_USIF_SPI_H */
+
diff --git a/drivers/spi/lantiq_usif_spi_intern.h b/drivers/spi/lantiq_usif_spi_intern.h
new file mode 100644
--- /dev/null
+++ b/drivers/spi/lantiq_usif_spi_intern.h
@@ -0,0 +1,562 @@
+/******************************************************************************
+**
+** FILE NAME    : ltqmips_usif_spi.h
+** PROJECT      : IFX UEIP for VRX200
+** MODULES      : USIF for SPI
+**
+** DATE         : 21 Aug 2008
+** AUTHOR       : Lei Chuanhua
+** DESCRIPTION  : USIF for SPI Master/Slave
+** COPYRIGHT    :       Copyright (c) 2008 ~ 2009
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+** HISTORY
+** $Date         $Author         $Comment
+** 21 Aug, 2008  Lei Chuanhua    Initial version
+** 20 Jun, 2009  Lei Chuanhua    Code review modification
+*******************************************************************************/
+
+#ifndef LTQMIPS_USIF_SPI_H
+#define LTQMIPS_USIF_SPI_H
+
+/*!
+ \file ltqmips_usif_spi.h
+ \ingroup LANTIQ_USIF_SPI
+ \brief header file for ifx usif spi driver internal definition
+*/
+
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/semaphore.h>
+
+#include <lantiq_usif_spi.h>
+#include "lantiq_usif_reg.h"
+
+/* Tail queue declarations */
+#define TAILQ_HEAD(name, type)                                     \
+struct name {                                                      \
+    struct type *tqh_first;     /* first element */                \
+    struct type **tqh_last;     /* addr of last next element */    \
+}
+
+#define TAILQ_HEAD_INITIALIZER(head)                               \
+    { NULL, &(head).tqh_first }
+
+#define TAILQ_ENTRY(type)                                              \
+struct {                                                               \
+    struct type *tqe_next;      /* next element */                     \
+    struct type **tqe_prev;     /* address of previous next element */ \
+}
+/*
+ * Tail queue functions.
+ */
+#define TAILQ_CONCAT(head1, head2, field) do {                          \
+    if (!TAILQ_EMPTY(head2)) {                                          \
+        *(head1)->tqh_last = (head2)->tqh_first;                        \
+        (head2)->tqh_first->field.tqe_prev = (head1)->tqh_last;         \
+        (head1)->tqh_last = (head2)->tqh_last;                          \
+        TAILQ_INIT((head2));                                            \
+    }                                                                   \
+} while (0)
+
+#define TAILQ_EMPTY(head)       ((head)->tqh_first == NULL)
+
+#define TAILQ_FIRST(head)       ((head)->tqh_first)
+
+#define TAILQ_FOREACH(var, head, field)                                  \
+     for ((var) = TAILQ_FIRST((head));                                  \
+        (var);                                                           \
+        (var) = TAILQ_NEXT((var), field))
+
+#define TAILQ_FOREACH_SAFE(var, head, field, tvar)                        \
+    for ((var) = TAILQ_FIRST((head));                                   \
+        (var) && ((tvar) = TAILQ_NEXT((var), field), 1);                \
+        (var) = (tvar))
+
+#define TAILQ_FOREACH_REVERSE(var, head, headname, field)                  \
+    for ((var) = TAILQ_LAST((head), headname);                            \
+        (var);                                                             \
+        (var) = TAILQ_PREV((var), headname, field))
+
+#define TAILQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)        \
+    for ((var) = TAILQ_LAST((head), headname);                            \
+        (var) && ((tvar) = TAILQ_PREV((var), headname, field), 1);        \
+        (var) = (tvar))
+
+#define TAILQ_INIT(head) do {                                               \
+    TAILQ_FIRST((head)) = NULL;                                             \
+    (head)->tqh_last = &TAILQ_FIRST((head));                                \
+} while (0)
+
+#define TAILQ_INSERT_AFTER(head, listelm, elm, field) do {                  \
+    if ((TAILQ_NEXT((elm), field) = TAILQ_NEXT((listelm), field)) != NULL)\
+        TAILQ_NEXT((elm), field)->field.tqe_prev =                          \
+             &TAILQ_NEXT((elm), field);                                     \
+    else {                                                                  \
+        (head)->tqh_last = &TAILQ_NEXT((elm), field);                       \
+    }                                                                       \
+    TAILQ_NEXT((listelm), field) = (elm);                                   \
+    (elm)->field.tqe_prev = &TAILQ_NEXT((listelm), field);                  \
+} while (0)
+
+#define TAILQ_INSERT_BEFORE(listelm, elm, field) do {                       \
+    (elm)->field.tqe_prev = (listelm)->field.tqe_prev;                      \
+    TAILQ_NEXT((elm), field) = (listelm);                                   \
+    *(listelm)->field.tqe_prev = (elm);                                     \
+    (listelm)->field.tqe_prev = &TAILQ_NEXT((elm), field);                  \
+} while (0)
+
+#define TAILQ_INSERT_HEAD(head, elm, field) do {                        \
+    if ((TAILQ_NEXT((elm), field) = TAILQ_FIRST((head))) != NULL)     \
+        TAILQ_FIRST((head))->field.tqe_prev =                           \
+            &TAILQ_NEXT((elm), field);                                  \
+    else                                                                \
+        (head)->tqh_last = &TAILQ_NEXT((elm), field);                   \
+    TAILQ_FIRST((head)) = (elm);                                        \
+    (elm)->field.tqe_prev = &TAILQ_FIRST((head));                       \
+} while (0)
+
+#define TAILQ_INSERT_TAIL(head, elm, field) do {                           \
+    TAILQ_NEXT((elm), field) = NULL;                                       \
+    (elm)->field.tqe_prev = (head)->tqh_last;                              \
+    *(head)->tqh_last = (elm);                                             \
+    (head)->tqh_last = &TAILQ_NEXT((elm), field);                          \
+} while (0)
+
+#define TAILQ_LAST(head, headname)                                         \
+    (*(((struct headname *)((head)->tqh_last))->tqh_last))
+
+#define TAILQ_NEXT(elm, field) ((elm)->field.tqe_next)
+
+#define TAILQ_PREV(elm, headname, field)                                    \
+    (*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
+
+#define TAILQ_REMOVE(head, elm, field) do {                                 \
+    if ((TAILQ_NEXT((elm), field)) != NULL)                               \
+         TAILQ_NEXT((elm), field)->field.tqe_prev =                         \
+             (elm)->field.tqe_prev;                                         \
+    else {                                                                  \
+        (head)->tqh_last = (elm)->field.tqe_prev;                           \
+    }                                                                       \
+    *(elm)->field.tqe_prev = TAILQ_NEXT((elm), field);                      \
+} while (0)
+
+#define LANTIQ_USIF_SPI_WAKELIST_INIT(queue) \
+	init_waitqueue_head(&queue)
+
+#define LANTIQ_USIF_SPI_WAIT_EVENT_TIMEOUT(info, event, timeout)    \
+	do {                                                     \
+		wait_event_interruptible_timeout((info)->dma_wait,  \
+		test_bit((event), &(info)->event_flags), (timeout)); \
+		clear_bit((event), &(info)->event_flags); \
+	} while (0)
+
+/* Wait queue has no address symbol in this macro
+ * interruptible_sleep_on() possibly cause lost-wakeup issue
+ * wait_event_interruptible is robust for multiple events
+ */
+#define LANTIQ_USIF_SPI_WAIT_EVENT(queue, event, flags)  \
+	do {                                              \
+		wait_event_interruptible((queue),        \
+		test_bit((event), &(flags)));            \
+		clear_bit((event), &(flags));            \
+		}while (0)
+
+#define LANTIQ_USIF_SPI_WAKEUP_EVENT(queue, event, flags)     \
+	do {                                               \
+		set_bit((event), &(flags));                \
+		wake_up_interruptible(&(queue));           \
+	}while (0)
+
+
+#define LANTIQ_USIF_SPI_IRQ_LOCK_INIT(port, _name) \
+	spin_lock_init(&((port)->usif_irq_lock))
+
+#define LANTIQ_USIF_SPI_IRQ_LOCK_DESTROY(port)
+#define LANTIQ_USIF_SPI_IRQ_LOCK(port)  do {            \
+	unsigned long __ilockflags;                     \
+	spin_lock_irqsave(&((port)->usif_irq_lock), __ilockflags);
+#define LANTIQ_USIF_SPI_IRQ_UNLOCK(port)               \
+	spin_unlock_irqrestore(&((port)->usif_irq_lock), __ilockflags);\
+} while (0)
+
+
+#define LANTIQ_USIF_SPI_SEM_INIT(sem)   \
+	sema_init(&sem, 1)
+
+#define LANTIQ_USIF_SPI_SEM_LOCK(sem)   \
+	down(&(sem))
+
+#define LANTIQ_USIF_SPI_SEM_UNLOCK(sem) \
+	up(&(sem))
+
+/* Data may run in kernel thread, tasklet at the same time */
+#define LANTIQ_USIF_SPI_Q_LOCK_INIT(port) \
+	spin_lock_init(&(port)->q_lock)
+
+#define LANTIQ_USIF_SPI_Q_LOCK_DESTROY(port)
+
+#define LANTIQ_USIF_SPI_Q_LOCK_BH(port)  do {   \
+	unsigned long __ilockflags;         \
+	spin_lock_irqsave(&((port)->q_lock), __ilockflags);
+#define LANTIQ_USIF_SPI_Q_UNLOCK_BH(port)       \
+	spin_unlock_irqrestore(&((port)->q_lock), __ilockflags);\
+} while (0)
+
+#define CTL_AUTO CTL_UNNUMBERED
+
+#define LANTIQ_INIT_CTL_NAME(val)
+#define LANTIQ_SET_CTL_NAME(ctl, val)
+
+#define LANTIQ_REGISTER_SYSCTL_TABLE(t) register_sysctl_table(t)
+
+#define LANTIQ_USIF_SPI_MAX_PORT_NUM    1 /* assume default value */
+
+#define LANTIQ_USIF_SPI_MAX_DEVNAME     16
+#define LANTIQ_USIF_SPI_MAX_DEVICE      8 /* XXX */
+
+/* Tx/Rx mode, FDF, HDF 2 bits */
+#define LANTIQ_USIF_SPI_MODE_OFF         0
+#define LANTIQ_USIF_SPI_MODE_RX          0x1
+#define LANTIQ_USIF_SPI_MODE_TX          0x2
+#define LANTIQ_USIF_SPI_MODE_RXTX        0x3
+#define LANTIQ_USIF_SPI_MODE_RXTX_MASK   (LANTIQ_USIF_SPI_MODE_RX\
+	| LANTIQ_USIF_SPI_MODE_TX)
+
+/* Heading Control */
+#define LANTIQ_USIF_SPI_LSB_FIRST            0
+#define LANTIQ_USIF_SPI_MSB_FIRST            1
+
+#define LANTIQ_USIF_SPI_CS_MAX               7
+
+/* Parameters for USIF_SPI DMA device */
+#define DEFAULT_USIF_SPI_TX_CHANNEL_CLASS   0
+#define DEFAULT_USIF_SPI_RX_CHANNEL_CLASS   0
+
+#define DEFAULT_USIF_SPI_TX_BURST_LEN       2 /* 2 words, 4 words, 8 words */
+#define DEFAULT_USIF_SPI_RX_BURST_LEN       2 /* 2 words, 4 words, 8 words */
+
+#define DEFAULT_USIF_SPI_TX_CHANNEL_NUM      1
+#define DEFAULT_USIF_SPI_RX_CHANNEL_NUM      1
+
+#define DEFAULT_USIF_SPI_TX_CHANNEL_DESC_NUM 1
+#define DEFAULT_USIF_SPI_RX_CHANNEL_DESC_NUM 1
+
+/* Default parameter */
+#define LANTIQ_USIF_SPI_DEF_SYNC           1 /* Synchronous */
+#define LANTIQ_USIF_SPI_DEF_MASTERSLAVE    1 /* Master */
+#define LANTIQ_USIF_SPI_DEF_FRMCTL         0 /* Disable framing control */
+#define LANTIQ_USIF_SPI_DEF_LOOP_BACK      0 /* Disable loopback */
+#define LANTIQ_USIF_SPI_DEF_ECHO_MODE      0 /* Disable echo mode */
+#define LANTIQ_USIF_SPI_DEF_TX_INVERT      0 /* Don't invert */
+#define LANTIQ_USIF_SPI_DEF_RX_INVERT      0 /* Don't invert */
+#define LANTIQ_USIF_SPI_DEF_SHIFT_CLK      0 /* No shift clock */
+#define LANTIQ_USIF_SPI_DEF_CLK_PO         0 /* Idle Low */
+/* 0: shift on leading edge, latch on trailling edge, 1, otherwise*/
+#define LANTIQ_USIF_SPI_DEF_CLK_PH         1
+#define LANTIQ_USIF_SPI_DEF_TX_IDLE_STATE  0 /* Low */
+#define LANTIQ_USIF_SPI_DEF_MODE_RXTX     LANTIQ_USIF_SPI_MODE_RXTX /* TX/RX modes */
+#define LANTIQ_USIF_SPI_DEF_CHAR_LEN       LANTIQ_USIF_PRTC_CFG_CLEN8
+#define LANTIQ_USIF_SPI_DEF_HDR_CTRL       LANTIQ_USIF_SPI_MSB_FIRST
+#define LANTIQ_USIF_SPI_DEF_WAKEUP         0
+
+#ifdef CONFIG_USE_EMULATOR
+#define LANTIQ_USIF_SPI_DEF_BAUDRATE        10000
+#else
+#define LANTIQ_USIF_SPI_DEF_BAUDRATE        2000000
+#endif
+#define LANTIQ_USIF_SPI_DEF_RMC             0x01 /* To use it up to max value */
+#define LANTIQ_USIF_SPI_DEF_ORMC            0x01
+
+/*!
+ \addtogroup LANTIQ_USIF_SPI_DEFINITIONS
+*/
+/* @{ */
+
+/*! \def DEFAULT_USIF_SPI_FRAGMENT_SIZE
+    \brief a maximum fragment size parameter is defined for all connections.
+
+    This threshold is given in number of bytes. It has to be configured for
+    each connection and be less or equal. If the size of the packet is greater
+    than this threshold the application has to take care of the fragmentation
+    of the packet. The default global value is given with 1056 bytes. This is
+    the recommended value to use, but each connection is free configure this
+    parameter to a lesser value individually
+  */
+#define DEFAULT_USIF_SPI_FRAGMENT_SIZE    1056
+
+/*! \def LANTIQ_USIF_SPI_MAX_FRAGSIZE
+    \brief maximum fragment size in theory.
+  */
+#define LANTIQ_USIF_SPI_MAX_FRAGSIZE             (32 * 1024)
+
+/*! \def LANTIQ_USIF_SPI_MIN_FRAGSIZE
+    \brief Mimimum fragment size. Smaller than this size has no meaning .
+  */
+#define LANTIQ_USIF_SPI_MIN_FRAGSIZE             32
+
+/*! \def DEFAULT_USIF_SPI_FIFO_THRESHOULD
+    \brief For enabling the USIF_SPI driver to choose between FIFO and DMA mode
+    in HDX communication a threshold parameter is set for all connections
+
+    This threshold is given in number of bytes. If the size of the packet is
+    lesser than this threshold the FIFO mode is used, else the DMA mode. The
+    global default value of 148 bytes is recommended. This value has to be
+    optimized/tuned accoring to application
+  */
+#define DEFAULT_USIF_SPI_FIFO_THRESHOULD  148
+
+/*! \def LANTIQ_USIF_SPI_FIFO_MAX_THRESHOULD
+    \brief Maximum FIFO/DMA threshould
+  */
+#define LANTIQ_USIF_SPI_FIFO_MAX_THRESHOULD      600
+
+/*! \def LANTIQ_USIF_SPI_FIFO_MIN_THRESHOULD
+    \brief Mimimum FIFO/DMA threshould.
+    \note  This thresould must be more than DMA burst length
+  */
+#define LANTIQ_USIF_SPI_FIFO_MIN_THRESHOULD      32
+
+/**
+ * TX FIFO burst size is set to 2 words, update accordingly
+ * when 'LANTIQ_USIF_SPI_TXFIFO_SETUP' changed
+ * NB, Must be the same as DMA burst length
+ */
+#define LANTIQ_USIF_SPI_TX_BUSRT_SIZE            0x02
+#define LANTIQ_USIF_SPI_TX_BUSRT_SIZE_BYTES      0x08 /* 8 bytes */
+
+/**
+ * TX FIFO is byte aligned, so one word contains 4 characters,
+ *   update accordingly when 'LANTIQ_USIF_SPI_TXFIFO_SETUP' changed
+ */
+#define LANTIQ_USIF_SPI_TX_FIFO_CHARS_PER_WORD   0x04
+
+/**
+ * RX FIFO burst size is set to 2 words, update accordingly
+ * when 'LANTIQ_USIF_SPI_RXFIFO_SETUP' changed
+ * NB, Must be the same as DMA burst length
+ */
+#define LANTIQ_USIF_SPI_RX_BUSRT_SIZE            0x02
+#define LANTIQ_USIF_SPI_RX_BUSRT_SIZE_BYTES      0x08 /* 8 bytes */
+/**
+ * RX FIFO is byte aligned, so one word contains 4 characters,
+ *   update accordingly when 'LANTIQ_USIF_SPI_RXFIFO_SETUP' changed
+ */
+#define LANTIQ_USIF_SPI_RX_FIFO_CHARS_PER_WORD   0x04
+
+/**
+ * TX FIFO is setup as flow control mode, with byte alignemnet and
+ *  busrt size as 2 words
+ */
+#define LANTIQ_USIF_SPI_TXFIFO_SETUP           \
+	(/*LANTIQ_USIF_FIFO_CFG_TXFC |*/\
+	SM(LANTIQ_USIF_TXFIFO_ALIGN_BYTE, LANTIQ_USIF_FIFO_CFG_RXFA) \
+	| SM(LANTIQ_USIF_TXFIFO_BURST_WORD2, LANTIQ_USIF_FIFO_CFG_TXBS))
+
+/*
+ * RX FIFO is setup as flow control mode, with byte alignemnet and
+ * busrt size as 2 words
+ */
+#define LANTIQ_USIF_SPI_RXFIFO_SETUP            \
+	(LANTIQ_USIF_FIFO_CFG_RXFC |\
+	SM(LANTIQ_USIF_RXFIFO_ALIGN_BYTE, LANTIQ_USIF_FIFO_CFG_RXFA) \
+	| SM(LANTIQ_USIF_RXFIFO_BURST_WORD2, LANTIQ_USIF_FIFO_CFG_RXBS))
+
+#define LANTIQ_USIF_SPI_FIFO_SETUP  (LANTIQ_USIF_SPI_TXFIFO_SETUP |\
+	LANTIQ_USIF_SPI_RXFIFO_SETUP)
+
+/*!
+  \brief USIF_SPI Statistics.
+  Symbolic constants to be used in USIF_SPI routines
+ */
+typedef struct lantiq_usif_spi_statistics {
+	u32 abortErr; /*!< abort error */
+	u32 modeErr; /*!< master/slave mode error */
+	u32 txOvErr; /*!< TX Overflow error */
+	u32 txUnErr; /*!< TX Underrun error */
+	u32 rxOvErr; /*!< RX Overflow error */
+	u32 rxUnErr; /*!< RX Underrun error */
+	u64 rxBytes; /*!< Received bytes */
+	u64 txBytes; /*!< Transmitted bytes */
+	u64 txFifo; /*!< Transmit transactions in FIFO */
+	u64 txDma; /*!< Transmit transactions in DMA */
+	u64 txDmaBytes; /*!< Transmit bytes in DMA mode */
+	u64 rxFifo; /*!< Receive transactions in FIFO */
+	u64 rxDma; /*!< Receive transactions in FIFO */
+	u64 rxDmaBytes; /*!< Receive bytes in DMA mode */
+} LANTIQ_USIF_SPI_STAT_t;
+
+/*!
+  \brief USIF_SPI Hardware Options.
+ */
+struct lantiq_usif_hwopts {
+	unsigned int sync:1;  /*!< Synchronous or Asynchronous */
+	unsigned int master:1; /*!< Master or slave for sync mode */
+	unsigned int frmctl:1; /*!< Framing control enable or disable */
+	unsigned int loopBack:1; /*!< Loopback mode */
+	unsigned int echoMode:1; /*!< Echo mode */
+	unsigned int txInvert:1; /*!< Transmissin line invert */
+	unsigned int rxInvert:1; /*!< Receive line invert */
+	unsigned int shiftClk:1; /*!< Shift clock force */
+	unsigned int clkPO:1; /*!< Shift clock polarity configuration */
+	unsigned int clkPH:1; /*!< Shift clock phase configuration */
+	unsigned int txIdleValue:1; /*!< Tx idle state */
+	unsigned int modeRxTx:2; /*!< Rx/tx mode */
+	unsigned int charLen:5; /*!< Character length */
+	unsigned int hdrCtrl:1; /*!< Heading of data bits */
+	unsigned int wakeUp:1; /*!< Wake-up bit detection */
+};
+
+struct lantiq_usif_device;
+
+/*! typedef LANTIQ_USIF_QUEUE
+    \brief queue structure for sync or async API
+*/
+typedef struct LANTIQ_USIF_QUEUE {
+	struct lantiq_usif_device *dev; /*!< Back pointer to SSC client device */
+	bool request_lock; /*!< Indicates this queue locked or not */
+	atomic_t isqueued; /*!< Only one entry is allowed per device
+				shared between tasklet and kernel thread
+				 */
+	char *txbuf; /*!< Transmission buffer snapshot */
+	int txsize; /*!< Transmission size snaphot */
+	char *rxbuf; /*!< Reception buffer snapshot */
+	int rxsize; /*!< Receptin size snapshot */
+	int exchange_bytes; /*!< TX/RX bytes for callback function */
+	/*!< Sync/Async handle type */
+	LANTIQ_USIF_SPI_HANDL_TYPE_t handle_type;
+	/*!< Async API callback function */
+	LANTIQ_USIF_SPI_ASYNC_CALLBACK_t callback;
+	/*!< Used if it works as queue header */
+	 TAILQ_ENTRY(LANTIQ_USIF_QUEUE) q_next;
+} LANTIQ_USIF_QUEUE_t;
+
+enum {
+	LANTIQ_USIF_SPI_DIR_RX = 0,
+	LANTIQ_USIF_SPI_DIR_TX,
+	LANTIQ_USIF_SPI_DIR_TXRX,
+};
+
+enum {
+	LANTIQ_USIF_SPI_DMA_DISABLE = 0,
+	LANTIQ_USIF_SPI_DMA_ENABLE,
+};
+
+/*!
+  \brief USIF SPI bus device statistics
+ */
+struct usif_device_stats {
+	u64 rxBytes;  /*!< Received bytes */
+	u64 txBytes;  /*!< Transmitted bytes */
+	u32 dup_qentries; /*!< Duplicated qentry error */
+	u32 context_err;  /*!< Context error */
+	u32 frag_err;     /*!< Fragment error */
+	u32 handler_err; /*!< Handler error */
+	u32 dlx_err; /*!< Duplex error */
+	u64 enqueue; /*!< enqueue times */
+	u64 dequeue; /*!< dequeue times */
+	/* More ... */
+};
+
+/*! typedef lantiq_usif_device_t
+    \brief USIF SPI device structure defintion
+*/
+typedef struct lantiq_usif_device {
+	char dev_name[LANTIQ_USIF_SPI_MAX_DEVNAME];
+	int duplex;
+	struct lantiq_usif_port *port; /* Back pointer */
+	 TAILQ_ENTRY(lantiq_usif_device) dev_entry;
+	LANTIQ_USIF_SPI_CONFIGURE_t conn_id;
+	struct usif_device_stats stats;
+#ifdef CONFIG_SYSCTL
+	struct ctl_table_header *usif_sysctl_header;
+	struct ctl_table *usif_sysctls;
+#endif /* CONFIG_SYSCTL */
+	LANTIQ_USIF_QUEUE_t queue;
+	LANTIQ_USIF_SPI_PRIO_t dev_prio;
+
+	/* Kernel thread based per device <ssc client> */
+	wait_queue_head_t dev_thread_wait;
+	volatile long event_flags;
+#define LANTIQ_USIF_SPI_DEV_THREAD_EVENT            1
+} lantiq_usif_device_t;
+
+typedef TAILQ_HEAD(, lantiq_usif_device) usif_devq_t;
+typedef TAILQ_HEAD(, LANTIQ_USIF_QUEUE) usif_dataq_t;
+
+/*! typedef lantiq_usif_port_t
+    \brief USIF SPI logical port definition
+*/
+typedef struct lantiq_usif_port {
+	unsigned char __iomem *membase; /* Virtual */
+	unsigned long mapbase; /* Physical */
+	struct lantiq_usif_hwopts opts;
+	LANTIQ_USIF_SPI_STAT_t stats;
+	u32 usif_debug; /* debug msg flags */
+	u32 tx_fifo_size_words;
+	u32 tx_fifo_size_bytes;
+	u32 rx_fifo_size_words;
+	u32 rx_fifo_size_bytes;
+	/* USIF_SPI port index, actually, it means
+	   how many spi ports we have. */
+	int port_idx;
+	usif_devq_t usif_devq;
+	lantiq_usif_device_t *current_dev; /* Current calling dev in the port */
+	int usif_ndevs;
+	char name[LANTIQ_USIF_SPI_MAX_DEVNAME];
+	struct semaphore dev_sem;
+	unsigned int prev_baudrate;
+	unsigned int baudrate;
+	/* Pointers to rx position */
+	volatile char *rxbuf_ptr;
+	int rx_len;
+
+	volatile long event_flags;
+	struct dma_device_info *dma_dev; /* DMA device structure */
+	LANTIQ_USIF_SPI_MODE_t prev_spi_mode;
+	int usif_frag_size; /* Possible configuration change, void malloc
+			     * big memory in reception
+			     */
+	LANTIQ_USIF_QUEUE_t *lock_qentry; /* XXX, protection? */
+	/* Only in its own tasklet or kernel thread */
+	LANTIQ_USIF_QUEUE_t *serve_qentry;
+	usif_dataq_t usif_asyncq; /* Async queue header */
+	usif_dataq_t usif_syncq[LANTIQ_USIF_SPI_PRIO_MAX]; /* Sync queue header */
+	spinlock_t q_lock; /* on three queues */
+	int usif_thread;
+	int usif_fake_irq;
+	spinlock_t usif_irq_lock;
+	atomic_t dma_wait_state;
+	wait_queue_head_t usif_thread_wait;
+#define LANTIQ_USIF_SPI_THREAD_EVENT       1
+
+	struct task_struct *usif_tsk;
+	bool usif_cs_locked; /* Done in the same tasklet or thread only */
+	struct tasklet_struct usif_txrxq;
+	/* HW WAR DMA buffer */
+	char *dma_txbuf; /* Aligned buffer */
+	char *dma_orig_txbuf; /* Original buffer */
+	char *dma_rxbuf;  /* Aligned buffer */
+	char *dma_orig_rxbuf; /* Original buffer */
+#ifdef CONFIG_SYSCTL
+	struct ctl_table_header *port_sysctl_header;
+	struct ctl_table *port_sysctls;
+#endif /* CONFIG_SYSCTL */
+	u32 dma_is_in_half_duplex;
+} lantiq_usif_port_t;
+/* @} */
+
+#ifdef CONFIG_USIF_SPI_XRX200
+#include "lantiq_usif_spi_vr9.h"
+#elif defined CONFIG_USIF_SPI_XRX300
+#include "lantiq_usif_spi_ar10.h"
+#else
+#error "USIF platform not defined!!!!"
+#endif
+#endif /* LTQMIPS_USIF_SPI_H */
+
diff --git a/drivers/spi/lantiq_usif_spi_vr9.h b/drivers/spi/lantiq_usif_spi_vr9.h
new file mode 100644
--- /dev/null
+++ b/drivers/spi/lantiq_usif_spi_vr9.h
@@ -0,0 +1,47 @@
+/****************************************************************************
+*                             Copyright (c) 2010
+*                           Lantiq Deutschland GmbH
+*                    Am Campeon 3; 85579 Neubiberg, Germany
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+ *****************************************************************************/
+/*!
+  \file ltqmips_usif_spi_vr9.h
+  \ingroup IFX_USIF_SPI
+  \brief USIF SPI driver VR9 specific file
+*/
+#ifndef LTQMIPS_USIF_SPI_VR9_H
+#define LTQMIPS_USIF_SPI_VR9_H
+
+#include <linux/clk.h>
+
+static inline void lantiq_usif_spi_pm_enable(void)
+{
+	/* Activate USIF SPI and AHB Master */
+//	USIF_PMU_SETUP(IFX_PMU_ENABLE);
+//	AHBM_PMU_SETUP(IFX_PMU_ENABLE);
+	struct clk *clk = NULL;
+
+	clk = clk_get_sys("1da00000.usif", "NULL");
+	if (clk < 0 || !clk) {
+		printk(KERN_ERR "%s: getting the clock for USIF failed\n",
+						__func__);
+	} else {
+		clk_enable(clk);
+		printk ("%s: successfully enabled the USIF clock\n", __FUNCTION__);
+	}
+}
+
+static inline void lantiq_usif_spi_pm_disable(void)
+{
+//	USIF_PMU_SETUP(IFX_PMU_DISABLE);
+//	AHBM_PMU_SETUP(IFX_PMU_DISABLE);
+	struct clk *clk;
+
+	clk = clk_get_sys("1da00000.usif", NULL);
+	clk_disable (clk);
+}
+#endif /* LTQMIPS_USIF_SPI_VR9_H */
+
