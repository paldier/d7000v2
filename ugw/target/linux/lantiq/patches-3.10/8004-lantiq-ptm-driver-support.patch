# HG changeset patch
# Parent d5b06482aad612f79051667cdc63b5cd07fb48bd

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -355,5 +355,6 @@ config VMXNET3
 	  module will be called vmxnet3.
 
 source "drivers/net/hyperv/Kconfig"
+source "drivers/net/lantiq_ptm/Kconfig"
 
 endif # NETDEVICES
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -72,3 +72,4 @@ obj-$(CONFIG_USB_CDC_PHONET)   += usb/
 
 obj-$(CONFIG_HYPERV_NET) += hyperv/
 obj-$(CONFIG_NTB_NETDEV) += ntb_netdev.o
+obj-$(CONFIG_LTQ_PTM)	 += lantiq_ptm/
diff --git a/drivers/net/lantiq_ptm/Kconfig b/drivers/net/lantiq_ptm/Kconfig
new file mode 100644
--- /dev/null
+++ b/drivers/net/lantiq_ptm/Kconfig
@@ -0,0 +1,34 @@
+config LTQ_PTM
+	tristate "Lantiq PTM driver"
+	depends on LANTIQ
+	default n
+	---help---
+	Use this exclusively with ATM mode or Acceleration Package
+
+choice
+	prompt "RX Packet Handling Mechanism"
+	depends on LTQ_PTM
+	default LTQ_PTM_RX_NAPI
+
+config LTQ_PTM_RX_NAPI
+	bool "NAPI"
+
+config LTQ_PTM_RX_TASKLET
+	bool "Tasklet"
+	depends on LTQ_PTM_XRX200
+
+config LTQ_PTM_RX_INTERRUPT
+	bool "Interrupt"
+	depends on LTQ_PTM_XRX200
+
+endchoice
+
+config LTQ_PTM_TEST_PROC
+	bool "Lantiq PTM Driver Test Proc"
+	depends on LTQ_PTM
+	default n
+
+config LTQ_PTM_XRX200
+	bool "PTM Platform Selection"
+	depends on LTQ_PTM
+	default y
diff --git a/drivers/net/lantiq_ptm/Makefile b/drivers/net/lantiq_ptm/Makefile
new file mode 100644
--- /dev/null
+++ b/drivers/net/lantiq_ptm/Makefile
@@ -0,0 +1,17 @@
+#
+# Makefile for the platform specific kernel interface routines under Linux.
+#
+
+obj-$(CONFIG_LTQ_PTM) = ltqmips_ptm.o
+
+ifeq ($(CONFIG_LTQ_PTM_XRX200),y)
+  ltqmips_ptm-objs := ltqmips_ptm_vdsl.o ltqmips_ptm_vr9.o
+endif
+
+ifeq ($(CONFIG_LTQ_PTM_TEST_PROC),y)
+  ifeq ($(CONFIG_LTQ_PTM),y)
+    ltqmips_ptm-objs += ltqmips_ptm_test.o
+  else
+    obj-$(CONFIG_LTQ_PTM) += ltqmips_ptm_test.o
+  endif
+endif
diff --git a/drivers/net/lantiq_ptm/ltq_ptm.h b/drivers/net/lantiq_ptm/ltq_ptm.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/lantiq_ptm/ltq_ptm.h
@@ -0,0 +1,203 @@
+/******************************************************************************
+**
+** FILE NAME    : ifx_ptm.h
+** PROJECT      : UEIP
+** MODULES      : PTM
+**
+** DATE         : 17 Jun 2009
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : Global PTM driver header file
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 07 JUL 2009  Xu Liang        Init Version
+*******************************************************************************/
+
+#ifndef IFX_PTM_H
+#define IFX_PTM_H
+
+
+
+/*!
+  \defgroup IFX_PTM UEIP Project - PTM driver module
+  \brief UEIP Project - PTM driver module, support Danube, Amazon-SE, AR9, VR9.
+ */
+
+/*!
+  \defgroup IFX_PTM_IOCTL IOCTL Commands
+  \ingroup IFX_PTM
+  \brief IOCTL Commands used by user application.
+ */
+
+/*!
+  \defgroup IFX_PTM_STRUCT Structures
+  \ingroup IFX_PTM
+  \brief Structures used by user application.
+ */
+
+/*!
+  \file ifx_ptm.h
+  \ingroup IFX_PTM
+  \brief PTM driver header file
+ */
+
+
+
+/*
+ * ####################################
+ *              Definition
+ * ####################################
+ */
+
+
+
+/*
+ * ####################################
+ *                IOCTL
+ * ####################################
+ */
+
+/*!
+  \addtogroup IFX_PTM_IOCTL
+ */
+/*@{*/
+
+/*
+ *  ioctl Command
+ */
+/*!
+  \brief PTM IOCTL Command - Get codeword MIB counters.
+
+  This command uses structure "PTM_CW_IF_ENTRY_T" to get codeword level MIB counters.
+ */
+#define IFX_PTM_MIB_CW_GET              SIOCDEVPRIVATE + 1
+/*!
+  \brief PTM IOCTL Command - Get packet MIB counters.
+
+  This command uses structure "PTM_FRAME_MIB_T" to get packet level MIB counters.
+ */
+#define IFX_PTM_MIB_FRAME_GET           SIOCDEVPRIVATE + 2
+/*!
+  \brief PTM IOCTL Command - Get firmware configuration (CRC).
+
+  This command uses structure "IFX_PTM_CFG_T" to get firmware configuration (CRC).
+ */
+#define IFX_PTM_CFG_GET                 SIOCDEVPRIVATE + 3
+/*!
+  \brief PTM IOCTL Command - Set firmware configuration (CRC).
+
+  This command uses structure "IFX_PTM_CFG_T" to set firmware configuration (CRC).
+ */
+#define IFX_PTM_CFG_SET                 SIOCDEVPRIVATE + 4
+/*!
+  \brief PTM IOCTL Command - Program priority value to TX queue mapping.
+
+  This command uses structure "IFX_PTM_PRIO_Q_MAP_T" to program priority value to TX queue mapping.
+ */
+#define IFX_PTM_MAP_PKT_PRIO_TO_Q       SIOCDEVPRIVATE + 14
+
+/*@}*/
+
+
+/*!
+  \addtogroup IFX_PTM_STRUCT
+ */
+/*@{*/
+
+/*
+ *  ioctl Data Type
+ */
+
+/*!
+  \typedef PTM_CW_IF_ENTRY_T
+  \brief Wrapping of structure "ptm_cw_ifEntry_t".
+ */
+/*!
+  \struct ptm_cw_ifEntry_t
+  \brief Structure used for CodeWord level MIB counters.
+ */
+typedef struct ptm_cw_ifEntry_t {
+    uint32_t    ifRxNoIdleCodewords;    /*!< output, number of ingress user codeword */
+    uint32_t    ifRxIdleCodewords;      /*!< output, number of ingress idle codeword */
+    uint32_t    ifRxCodingViolation;    /*!< output, number of error ingress codeword */
+    uint32_t    ifTxNoIdleCodewords;    /*!< output, number of egress user codeword */
+    uint32_t    ifTxIdleCodewords;      /*!< output, number of egress idle codeword */
+} PTM_CW_IF_ENTRY_T;
+
+/*!
+  \typedef PTM_FRAME_MIB_T
+  \brief Wrapping of structure "ptm_frame_mib_t".
+ */
+/*!
+  \struct ptm_frame_mib_t
+  \brief Structure used for packet level MIB counters.
+ */
+typedef struct ptm_frame_mib_t {
+    uint32_t    RxCorrect;      /*!< output, number of ingress packet */
+    uint32_t    TC_CrcError;    /*!< output, number of egress packet with CRC error */
+    uint32_t    RxDropped;      /*!< output, number of dropped ingress packet */
+    uint32_t    TxSend;         /*!< output, number of egress packet */
+} PTM_FRAME_MIB_T;
+
+/*!
+  \typedef IFX_PTM_CFG_T
+  \brief Wrapping of structure "ptm_cfg_t".
+ */
+/*!
+  \struct ptm_cfg_t
+  \brief Structure used for ETH/TC CRC configuration.
+ */
+typedef struct ptm_cfg_t {
+    uint32_t    RxEthCrcPresent;    /*!< input/output, ingress packet has ETH CRC */
+    uint32_t    RxEthCrcCheck;      /*!< input/output, check ETH CRC of ingress packet */
+    uint32_t    RxTcCrcCheck;       /*!< input/output, check TC CRC of ingress codeword */
+    uint32_t    RxTcCrcLen;         /*!< input/output, length of TC CRC of ingress codeword */
+    uint32_t    TxEthCrcGen;        /*!< input/output, generate ETH CRC for egress packet */
+    uint32_t    TxTcCrcGen;         /*!< input/output, generate TC CRC for egress codeword */
+    uint32_t    TxTcCrcLen;         /*!< input/output, length of TC CRC of egress codeword */
+} IFX_PTM_CFG_T;
+
+/*!
+  \typedef IFX_PTM_PRIO_Q_MAP_T
+  \brief Wrapping of structure "ppe_prio_q_map".
+ */
+/*!
+  \struct ppe_prio_q_map
+  \brief Structure used for Priority Value to TX Queue mapping.
+ */
+typedef struct ppe_prio_q_map {
+    int             pkt_prio;
+    int             qid;
+    int             vpi;    //  ignored in eth interface
+    int             vci;    //  ignored in eth interface
+} IFX_PTM_PRIO_Q_MAP_T;
+
+/*@}*/
+
+
+
+/*
+ * ####################################
+ *                 API
+ * ####################################
+ */
+
+#ifdef __KERNEL__
+struct port_cell_info {
+    unsigned int    port_num;
+    unsigned int    tx_link_rate[2];
+};
+#endif
+
+
+
+#endif  //  IFX_PTM_H
+
diff --git a/drivers/net/lantiq_ptm/ltqmips_ptm_common.h b/drivers/net/lantiq_ptm/ltqmips_ptm_common.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/lantiq_ptm/ltqmips_ptm_common.h
@@ -0,0 +1,102 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_ptm_common.h
+** PROJECT      : UEIP
+** MODULES      : PTM
+**
+** DATE         : 7 Jul 2009
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : PTM driver header file (common definitions)
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 17 JUN 2009  Xu Liang        Init Version
+*******************************************************************************/
+
+#ifndef IFXMIPS_PTM_COMMON_H
+#define IFXMIPS_PTM_COMMON_H
+
+
+
+/*
+ * ####################################
+ *              Version No.
+ * ####################################
+ */
+
+#define IFX_PTM_VER_MAJOR               1
+#define IFX_PTM_VER_MID                 2
+#define IFX_PTM_VER_MINOR               2
+
+
+
+/*
+ * ####################################
+ *              Definition
+ * ####################################
+ */
+
+/*
+ *  Compile Options
+ */
+
+#define ENABLE_DEBUG                    1
+
+#define ENABLE_ASSERT                   1
+
+#define INLINE
+
+#define DEBUG_DUMP_SKB                  1
+
+#define DEBUG_QOS                       1
+
+#define ENABLE_DBG_PROC                 1
+
+#define ENABLE_FW_PROC                  1
+
+#if defined(CONFIG_DSL_MEI_CPE_DRV) && !defined(CONFIG_IFXMIPS_DSL_CPE_MEI)
+  #define CONFIG_IFXMIPS_DSL_CPE_MEI    1
+#endif
+
+/*
+ *  Debug/Assert/Error Message
+ */
+
+#define DBG_ENABLE_MASK_ERR             (1 << 0)
+#define DBG_ENABLE_MASK_DEBUG_PRINT     (1 << 1)
+#define DBG_ENABLE_MASK_ASSERT          (1 << 2)
+#define DBG_ENABLE_MASK_DUMP_SKB_RX     (1 << 8)
+#define DBG_ENABLE_MASK_DUMP_SKB_TX     (1 << 9)
+#define DBG_ENABLE_MASK_DUMP_QOS        (1 << 10)
+#define DBG_ENABLE_MASK_DUMP_INIT       (1 << 11)
+#define DBG_ENABLE_MASK_MAC_SWAP        (1 << 12)
+#define DBG_ENABLE_MASK_ALL             (DBG_ENABLE_MASK_ERR | DBG_ENABLE_MASK_DEBUG_PRINT | DBG_ENABLE_MASK_ASSERT | DBG_ENABLE_MASK_DUMP_SKB_RX | DBG_ENABLE_MASK_DUMP_SKB_TX | DBG_ENABLE_MASK_DUMP_QOS | DBG_ENABLE_MASK_DUMP_INIT | DBG_ENABLE_MASK_MAC_SWAP)
+
+#define err(format, arg...)             do { if ( (ifx_ptm_dbg_enable & DBG_ENABLE_MASK_ERR) ) printk(KERN_ERR __FILE__ ":%d:%s: " format "\n", __LINE__, __FUNCTION__, ##arg); } while ( 0 )
+
+#if defined(ENABLE_DEBUG) && ENABLE_DEBUG
+  #undef  dbg
+  #define dbg(format, arg...)           do { if ( (ifx_ptm_dbg_enable & DBG_ENABLE_MASK_DEBUG_PRINT) ) printk(KERN_WARNING __FILE__ ":%d:%s: " format "\n", __LINE__, __FUNCTION__, ##arg); } while ( 0 )
+#else
+  #if !defined(dbg)
+    #define dbg(format, arg...)
+  #endif
+#endif
+
+#if defined(ENABLE_ASSERT) && ENABLE_ASSERT
+  #define ASSERT(cond, format, arg...)  do { if ( (ifx_ptm_dbg_enable & DBG_ENABLE_MASK_ASSERT) && !(cond) ) printk(KERN_ERR __FILE__ ":%d:%s: " format "\n", __LINE__, __FUNCTION__, ##arg); } while ( 0 )
+#else
+  #define ASSERT(cond, format, arg...)
+#endif
+
+
+
+#endif  //  IFXMIPS_PTM_COMMON_H
diff --git a/drivers/net/lantiq_ptm/ltqmips_ptm_fw_regs_vdsl.h b/drivers/net/lantiq_ptm/ltqmips_ptm_fw_regs_vdsl.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/lantiq_ptm/ltqmips_ptm_fw_regs_vdsl.h
@@ -0,0 +1,277 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_ptm_fw_regs_vdsl.h
+** PROJECT      : UEIP
+** MODULES      : PTM
+**
+** DATE         : 7 Jul 2009
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : PTM driver header file (firmware register for VDSL)
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 07 JUL 2009  Xu Liang        Init Version
+*******************************************************************************/
+
+
+
+#ifndef IFXMIPS_PTM_FW_REGS_VDSL_H
+#define IFXMIPS_PTM_FW_REGS_VDSL_H
+
+
+
+#include "ltqmips_ptm_fw_regs_vr9.h"
+
+/*
+ *  MIB Table Maintained by Firmware
+ */
+
+struct wan_rx_mib_table {
+    unsigned int            res1[2];
+    unsigned int            wrx_dropdes_pdu;
+    unsigned int            wrx_total_bytes;
+    unsigned int            res2[4];
+    //  wrx_total_pdu is implemented with hardware counter (not used by PTM TC)
+    //  check register "TC_RX_MIB_CMD"
+    //  "HEC_INC" used to increase preemption Gamma interface (wrx_total_pdu)
+    //  "AIIDLE_INC" used to increase normal Gamma interface (wrx_total_pdu)
+};
+
+struct wan_tx_mib_table {
+    //unsigned int            wtx_total_pdu;        //  version before 0.26
+    //unsigned int            small_pkt_drop_cnt;
+    //unsigned int            total_pkt_drop_cnt;
+    unsigned int            wrx_total_pdu;          //  version 0.26 and onwards
+    unsigned int            wrx_total_bytes;
+    unsigned int            wtx_total_pdu;
+    unsigned int            wtx_total_bytes;
+
+    unsigned int            wtx_cpu_dropsmall_pdu;
+    unsigned int            wtx_cpu_dropdes_pdu;
+    unsigned int            wtx_fast_dropsmall_pdu;
+    unsigned int            wtx_fast_dropdes_pdu;
+};
+
+
+/*
+ *  Host-PPE Communication Data Structure
+ */
+
+#if defined(__BIG_ENDIAN)
+
+  struct fw_ver_id_new {    //  @2000
+	/*  0 - 3h  */
+	unsigned int family         :4;
+    unsigned int package        :4;
+    unsigned int major          :8;
+    unsigned int middle         :8;
+	unsigned int minor          :8;
+    /*  4 - 7h  */
+	unsigned int features       :32;
+  };
+
+  struct fw_ver_id {        //  @2001
+    unsigned int family         :4;
+    unsigned int fwtype         :4;
+    unsigned int interface      :4;
+    unsigned int fwmode         :4;
+    unsigned int major          :8;
+    unsigned int minor          :8;
+  };
+
+  struct cfg_std_data_len {
+    unsigned int res1           :14;
+    unsigned int byte_off       :2;     //  byte offset in RX DMA channel
+    unsigned int data_len       :16;    //  data length for standard size packet buffer
+  };
+
+  struct tx_qos_cfg {
+    unsigned int time_tick      :16;    //  number of PP32 cycles per basic time tick
+    unsigned int overhd_bytes   :8;     //  number of overhead bytes per packet in rate shaping
+    unsigned int eth1_eg_qnum   :4;     //  number of egress QoS queues (< 8);
+    unsigned int eth1_burst_chk :1;     //  always 1, more accurate WFQ
+    unsigned int eth1_qss       :1;     //  1: FW QoS, 0: HW QoS
+    unsigned int shape_en       :1;     //  1: enable rate shaping, 0: disable
+    unsigned int wfq_en         :1;     //  1: WFQ enabled, 0: strict priority enabled
+  };
+
+  struct psave_cfg {
+    unsigned int res1           :15;
+    unsigned int start_state    :1;     //  1: start from partial PPE reset, 0: start from full PPE reset
+    unsigned int res2           :15;
+    unsigned int sleep_en       :1;     //  1: enable sleep mode, 0: disable sleep mode
+  };
+
+  struct eg_bwctrl_cfg {
+    unsigned int fdesc_wm       :16;    //  if free descriptors in QoS/Swap channel is less than this watermark, large size packets are discarded
+    unsigned int class_len      :16;    //  if packet length is not less than this value, the packet is recognized as large packet
+  };
+
+  struct test_mode {
+    unsigned int res1           :30;
+    unsigned int mib_clear_mode :1;     //  1: MIB counter is cleared with TPS-TC software reset, 0: MIB counter not cleared
+    unsigned int test_mode      :1;     //  1: test mode, 0: normal mode
+  };
+
+  struct gpio_mode {
+    unsigned int res1           :3;
+    unsigned int gpio_bit_bc1   :5;
+    unsigned int res2           :3;
+    unsigned int gpio_bit_bc0   :5;
+
+    unsigned int res3           :7;
+    unsigned int gpio_bc1_en    :1;
+
+    unsigned int res4           :7;
+    unsigned int gpio_bc0_en    :1;
+  };
+
+  struct gpio_wm_cfg {
+    unsigned int stop_wm_bc1    :8;
+    unsigned int start_wm_bc1   :8;
+    unsigned int stop_wm_bc0    :8;
+    unsigned int start_wm_bc0   :8;
+  };
+
+  struct rx_bc_cfg {
+    unsigned int res1           :14;
+    unsigned int local_state    :2;     //  0: local receiver is "Looking", 1: local receiver is "Freewheel Sync False", 2: local receiver is "Synced", 3: local receiver is "Freewheel Sync Truee"
+    unsigned int res2           :15;
+    unsigned int remote_state   :1;     //  0: remote receiver is "Out-of-Sync", 1: remote receiver is "Synced"
+    unsigned int to_false_th    :16;    //  the number of consecutive "Miss Sync" for leaving "Freewheel Sync False" to "Looking" (default 3)
+    unsigned int to_looking_th  :16;    //  the number of consecutive "Miss Sync" for leaving "Freewheel Sync True" to "Freewheel Sync False" (default 7)
+    unsigned int res_word[30];
+  };
+
+  struct rx_gamma_itf_cfg {
+    unsigned int res1           :31;
+    unsigned int receive_state  :1;     //  0: "Out-of-Fragment", 1: "In-Fragment"
+    unsigned int res2           :16;
+    unsigned int rx_min_len     :8;     //  min length of packet, padding if packet length is smaller than this value
+    unsigned int rx_pad_en      :1;     //  0:  padding disabled, 1: padding enabled
+    unsigned int res3           :2;
+    unsigned int rx_eth_fcs_ver_dis :1; //  0: ETH FCS verification is enabled, 1: disabled
+    unsigned int rx_rm_eth_fcs      :1; //  0: ETH FCS field is not removed, 1: ETH FCS field is removed
+    unsigned int rx_tc_crc_ver_dis  :1; //  0: TC CRC verification enabled, 1: disabled
+    unsigned int rx_tc_crc_size     :2; //  0: 0-bit, 1: 16-bit, 2: 32-bit
+    unsigned int rx_eth_fcs_result;     //  if the ETH FCS result matches this magic number, then the packet is valid packet
+    unsigned int rx_tc_crc_result;      //  if the TC CRC result matches this magic number, then the packet is valid packet
+    unsigned int rx_crc_cfg     :16;    //  TC CRC config, please check the description of SAR context data structure in the hardware spec
+    unsigned int res4           :16;
+    unsigned int rx_eth_fcs_init_value; //  ETH FCS initialization value
+    unsigned int rx_tc_crc_init_value;  //  TC CRC initialization value
+    unsigned int res_word1;
+    unsigned int rx_max_len_sel :1;     //  0: normal, the max length is given by MAX_LEN_NORMAL, 1: fragment, the max length is given by MAX_LEN_FRAG
+    unsigned int res5           :2;
+    unsigned int rx_edit_num2   :4;     //  number of bytes to be inserted/removed
+    unsigned int rx_edit_pos2   :7;     //  first byte position to be edited
+    unsigned int rx_edit_type2  :1;     //  0: remove, 1: insert
+    unsigned int rx_edit_en2    :1;     //  0: disable insertion or removal of data, 1: enable
+    unsigned int res6           :3;
+    unsigned int rx_edit_num1   :4;     //  number of bytes to be inserted/removed
+    unsigned int rx_edit_pos1   :7;     //  first byte position to be edited
+    unsigned int rx_edit_type1  :1;     //  0: remove, 1: insert
+    unsigned int rx_edit_en1    :1;     //  0: disable insertion or removal of data, 1: enable
+    unsigned int res_word2[2];
+    unsigned int rx_inserted_bytes_1l;
+    unsigned int rx_inserted_bytes_1h;
+    unsigned int rx_inserted_bytes_2l;
+    unsigned int rx_inserted_bytes_2h;
+    int rx_len_adj;                     //  the packet length adjustment, it is sign integer
+    unsigned int res_word3[16];
+  };
+
+  struct tx_bc_cfg {
+    unsigned int fill_wm        :16;    //  default 2
+    unsigned int uflw_wm        :16;    //  default 2
+    unsigned int res_word[31];
+  };
+
+  struct tx_gamma_itf_cfg {
+    unsigned int res_word1;
+    unsigned int res1           :8;
+    unsigned int tx_len_adj     :4;     //  4 * (not TX_ETH_FCS_GEN_DIS) + TX_TC_CRC_SIZE
+    unsigned int tx_crc_off_adj :4;     //  4 + TX_TC_CRC_SIZE
+    unsigned int tx_min_len     :8;     //  min length of packet, if length is less than this value, packet is padded
+    unsigned int res2           :3;
+    unsigned int tx_eth_fcs_gen_dis :1; //  0: ETH FCS generation enabled, 1: disabled
+    unsigned int res3           :2;
+    unsigned int tx_tc_crc_size :2;     //  0: 0-bit, 1: 16-bit, 2: 32-bit
+    unsigned int res4           :24;
+    unsigned int queue_mapping  :8;     //  TX queue attached to this Gamma interface
+    unsigned int res_word2;
+    unsigned int tx_crc_cfg     :16;    //  TC CRC config, please check the description of SAR context data structure in the hardware spec
+    unsigned int res5           :16;
+    unsigned int tx_eth_fcs_init_value; //  ETH FCS initialization value
+    unsigned int tx_tc_crc_init_value;  //  TC CRC initialization value
+    unsigned int res_word3[25];
+  };
+
+  struct wtx_qos_q_desc_cfg {
+    unsigned int threshold      :8;
+    unsigned int length         :8;
+    unsigned int addr           :16;
+    unsigned int rd_ptr         :16;
+    unsigned int wr_ptr         :16;
+  };
+
+  struct wtx_eg_q_shaping_cfg {
+    unsigned int t              :8;
+    unsigned int w              :24;
+    unsigned int s              :16;
+    unsigned int r              :16;
+    unsigned int res1           :8;
+    unsigned int d              :24;    //  ppe internal variable
+    unsigned int res2           :8;
+    unsigned int tick_cnt       :8;     //  ppe internal variable
+    unsigned int b              :16;    //  ppe internal variable
+  };
+
+  /* DMA descriptor */
+  struct rx_descriptor {
+    /*  0 - 3h  */
+    unsigned int own            :1;     //  0: Central DMA TX or MIPS, 1: PPE
+    unsigned int c              :1;     //  PPE tells current descriptor is complete
+    unsigned int sop            :1;
+    unsigned int eop            :1;
+    unsigned int res1           :3;
+    unsigned int byteoff        :2;
+    unsigned int res2           :7;
+    unsigned int datalen        :16;
+    /*  4 - 7h  */
+    unsigned int res3           :4;
+    unsigned int dataptr        :28;    //  byte address
+  };
+
+  struct tx_descriptor {
+    /*  0 - 3h  */
+    unsigned int own            :1;     //  CPU path - 0: MIPS, 1: PPE Dispatcher, Fastpath - 0: PPE Dispatcher, 1: Central DMA, QoS Queue - 0: PPE Dispatcher, 1: PPE DMA, SWAP Channel - 0: MIPS, 1: PPE Dispatcher
+    unsigned int c              :1;     //  MIPS or central DMA tells PPE the current descriptor is complete
+    unsigned int sop            :1;
+    unsigned int eop            :1;
+    unsigned int byteoff        :5;
+    unsigned int qid            :4;     //  TX Queue ID, bit 3 is reserved
+    unsigned int res1           :3;
+    unsigned int datalen        :16;
+    /*  4 - 7h  */
+    unsigned int small          :1;     //  0: standard size, 1: less than standard size
+    unsigned int res2           :3;
+    unsigned int dataptr        :28;    //  byte address
+  };
+
+#else /* defined(__BIG_ENDIAN) */
+  #error structures are defined in big endian
+#endif  /* defined(__BIG_ENDIAN) */
+
+
+
+#endif  //  IFXMIPS_PTM_FW_REGS_VDSL_H
+
diff --git a/drivers/net/lantiq_ptm/ltqmips_ptm_fw_regs_vr9.h b/drivers/net/lantiq_ptm/ltqmips_ptm_fw_regs_vr9.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/lantiq_ptm/ltqmips_ptm_fw_regs_vr9.h
@@ -0,0 +1,92 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_ptm_fw_regs_vr9.h
+** PROJECT      : UEIP
+** MODULES      : PTM
+**
+** DATE         : 7 Jul 2009
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : PTM driver header file (firmware register for VR9)
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 07 JUL 2009  Xu Liang        Init Version
+*******************************************************************************/
+
+
+
+#ifndef IFXMIPS_PTM_FW_REGS_VR9_H
+#define IFXMIPS_PTM_FW_REGS_VR9_H
+
+
+
+/*
+ *  Host-PPE Communication Data Address Mapping
+ */
+#define FW_VER_ID_NEW                           ((volatile struct fw_ver_id_new *)          SB_BUFFER(0x2000))
+#define FW_VER_ID                               ((volatile struct fw_ver_id *)              SB_BUFFER(0x2001))
+#define CFG_STD_DATA_LEN                        ((volatile struct cfg_std_data_len *)       SB_BUFFER(0x2011))
+#define TX_QOS_CFG                              ((volatile struct tx_qos_cfg *)             SB_BUFFER(0x2012))
+#define EG_BWCTRL_CFG                           ((volatile struct eg_bwctrl_cfg *)          SB_BUFFER(0x2013))
+#define PSAVE_CFG                               ((volatile struct psave_cfg *)              SB_BUFFER(0x2014))
+#define GPIO_ADDR                               SB_BUFFER(0x2019)
+#define GPIO_MODE                               ((volatile struct gpio_mode *)              SB_BUFFER(0x201C))
+#define GPIO_WM_CFG                             ((volatile struct gpio_wm_cfg *)            SB_BUFFER(0x201D))
+#define TEST_MODE                               ((volatile struct test_mode *)              SB_BUFFER(0x201F))
+#define WTX_QOS_Q_DESC_CFG(i)                   ((volatile struct wtx_qos_q_desc_cfg *)     SB_BUFFER(0x2FF0 + (i) * 2))    /*  i < 8   */
+#define WTX_EG_Q_PORT_SHAPING_CFG(i)            ((volatile struct wtx_eg_q_shaping_cfg *)   SB_BUFFER(0x2680 + (i) * 4))    /*  i < 1   */
+#define WTX_EG_Q_SHAPING_CFG(i)                 ((volatile struct wtx_eg_q_shaping_cfg *)   SB_BUFFER(0x2684 + (i) * 4))    /*  i < 8   */
+#define TX_QUEUE_CFG(i)                         WTX_EG_Q_PORT_SHAPING_CFG(i)    //  i < 9
+#define RX_BC_CFG(i)                            ((volatile struct rx_bc_cfg *)              SB_BUFFER(0x3E80 + (i) * 0x20)) //  i < 2
+#define TX_BC_CFG(i)                            ((volatile struct tx_bc_cfg *)              SB_BUFFER(0x3EC0 + (i) * 0x20)) //  i < 2
+#define RX_GAMMA_ITF_CFG(i)                     ((volatile struct rx_gamma_itf_cfg *)       SB_BUFFER(0x3D80 + (i) * 0x20)) //  i < 4
+#define TX_GAMMA_ITF_CFG(i)                     ((volatile struct tx_gamma_itf_cfg *)       SB_BUFFER(0x3E00 + (i) * 0x20)) //  i < 4
+#define TX_QOS_WFQ_RELOAD_MAP                   SB_BUFFER(0x3F13)
+#define WAN_RX_MIB_TABLE(i)                     ((volatile struct wan_rx_mib_table *)       SB_BUFFER(0x5B00 + (i) * 8))    //  i < 4
+#define WAN_TX_MIB_TABLE(i)                     ((volatile struct wan_tx_mib_table *)       SB_BUFFER(0x5B20 + (i) * 8))    //  i < 8
+#define TX_CTRL_K_TABLE(i)                      SB_BUFFER(0x47F0 + (i)) //  i < 16
+//  following MIB for debugging purpose
+#define RECEIVE_NON_IDLE_CELL_CNT(i)            SB_BUFFER(5020 + (i))
+#define RECEIVE_IDLE_CELL_CNT(i)                SB_BUFFER(5022 + (i))
+#define TRANSMIT_CELL_CNT(i)                    SB_BUFFER(5024 + (i))
+#define FP_RECEIVE_PKT_CNT                      SB_BUFFER(5026)
+
+#define UTP_CFG                                 SB_BUFFER(0x2018)   //  bit 0~3 - 0x0F: in showtime, 0x00: not in showtime
+
+/*
+ *  Descriptor Base Address
+ */
+#define CPU_TO_WAN_TX_DESC_BASE                 ((volatile struct tx_descriptor *)SB_BUFFER(0x3D00))
+#define __ETH_WAN_TX_QUEUE_NUM                  g_wanqos_en
+#define __ETH_WAN_TX_QUEUE_LEN                  ((WAN_TX_DESC_NUM_TOTAL / __ETH_WAN_TX_QUEUE_NUM) < 256 ? (WAN_TX_DESC_NUM_TOTAL / __ETH_WAN_TX_QUEUE_NUM) : 255)
+#define __ETH_WAN_TX_DESC_BASE(i)               (0x5C00 + (i) * 2 * __ETH_WAN_TX_QUEUE_LEN)
+#define WAN_TX_DESC_BASE(i)                     ((volatile struct tx_descriptor *)SB_BUFFER(__ETH_WAN_TX_DESC_BASE(i))) //  i < __ETH_WAN_TX_QUEUE_NUM, __ETH_WAN_TX_QUEUE_LEN each queue
+#define WAN_SWAP_DESC_BASE                      ((volatile struct tx_descriptor *)SB_BUFFER(0x2E80))
+#define FASTPATH_TO_WAN_TX_DESC_BASE            ((volatile struct tx_descriptor *)SB_BUFFER(0x2580))
+#define DMA_RX_CH1_DESC_BASE                    FASTPATH_TO_WAN_TX_DESC_BASE
+#define WAN_RX_DESC_BASE                        ((volatile struct rx_descriptor *)SB_BUFFER(0x2600))
+#define DMA_TX_CH1_DESC_BASE                    WAN_RX_DESC_BASE
+
+/*
+ *  Descriptor Number
+ */
+#define CPU_TO_WAN_TX_DESC_NUM                  64
+#define WAN_TX_DESC_NUM                         __ETH_WAN_TX_QUEUE_LEN
+#define WAN_SWAP_DESC_NUM                       32
+#define WAN_TX_DESC_NUM_TOTAL                   512
+#define FASTPATH_TO_WAN_TX_DESC_NUM             64
+#define DMA_RX_CH1_DESC_NUM                     FASTPATH_TO_WAN_TX_DESC_NUM
+#define WAN_RX_DESC_NUM                         64
+#define DMA_TX_CH1_DESC_NUM                     WAN_RX_DESC_NUM
+
+
+
+#endif  //  IFXMIPS_PTM_FW_REGS_VR9_H
diff --git a/drivers/net/lantiq_ptm/ltqmips_ptm_fw_vr9.h b/drivers/net/lantiq_ptm/ltqmips_ptm_fw_vr9.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/lantiq_ptm/ltqmips_ptm_fw_vr9.h
@@ -0,0 +1,458 @@
+#ifndef __VR9_E1_FW_H
+#define __VR9_E1_FW_H
+
+/******************************************************************************
+** FILE NAME    : ifxmips_ppa_datapath_fw_vr9_e1.h
+** PROJECT      : PPA
+** PLATFORM     : VR9
+** MODULES     	: E1
+**
+** DATE         : 19/05/2012
+** AUTHOR       : Lantiq PPE FW Team
+** DESCRIPTION  : VR9 E1 PPE Firmware Binary
+** COPYRIGHT    : 	   Copyright (c) 2012
+**			        Lantiq Deutschland GmbH 
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** FW VERSION [31:0] : 0x73012B09
+** FW FEATURE [31:0] : 0xB0000000
+** MERCURIAL TAG     : PTM_FW_PPA2.8_Pre_Rel_04@default@ptm_fw
+**
+** HISTORY
+** $Date         $Author                   $Comment
+** 19/05/2012    Lantiq PPE FW Team        VR9 E1 PPE Firmware Binary
+*******************************************************************************/
+
+static u32 vr9_e1_fw_code[] = {
+ 0x80000980, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x8000ffe0, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0xc1c20002, 0xd9cc00f8, 0xc0006950, 0xcbc000f8, 0xc0004024, 0xc8c000f8, 0xc0006950, 0x5bfc0002,
+ 0xa944676a, 0xcfc000f8, 0x00000000, 0xa4c265c2, 0x00000000, 0x00000000, 0x80000790, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0xc0e1fffe, 0x58cdfffe, 0xc1e1fffa, 0x59ddfffe, 0x94000001, 0x00000000, 0x00000000, 0x00000000,
+ 0xc0e1fffe, 0x58cdfffe, 0xc1e1fffa, 0x59ddfffe, 0x900009a1, 0x00000000, 0x00000000, 0x00000000,
+ 0x90cc0941, 0x00000000, 0x00000000, 0x00000000, 0xc0004010, 0xd14000f8, 0xc000400c, 0xc8c000f8,
+ 0xc1c1fffe, 0xd9d7e700, 0x45cce000, 0xc1c00002, 0xd9d40704, 0xc3e0e602, 0x5bfc5612, 0xc0004000,
+ 0xcfc000f8, 0xc3e16000, 0x5bfc0000, 0xc0004002, 0xcfc000f8, 0xc3c00000, 0xc0004024, 0xcbc20078,
+ 0x00000000, 0x00000000, 0xc1c00000, 0xd9c400f9, 0xdbc40078, 0xc1c00006, 0xd9c400f9, 0xc000403c,
+ 0xcfc000f8, 0xc3c0fc10, 0xc0006952, 0xcfc000f8, 0xc3c00000, 0xc3400000, 0xc3000040, 0xc2c00080,
+ 0x6ff8a000, 0x5bb87d00, 0x5838001c, 0xcf4000f8, 0x5838001e, 0xcec000f8, 0x58380020, 0xcf4000f8,
+ 0x58380022, 0xcf0000f8, 0x5bfc0002, 0x5ebc0004, 0x8400ffa0, 0x00000000, 0xc1e1fffe, 0x59ddfffa,
+ 0x141c0000, 0xc0004010, 0xd14000f8, 0xc000400c, 0xc8c000f8, 0xc1c1fffe, 0xd9d7e700, 0x45cce000,
+ 0xc1c00002, 0xd9d40704, 0xc1c00000, 0xc000691c, 0xcdc000f8, 0xab64002a, 0xc3c00000, 0xab66001a,
+ 0xc3c00002, 0x80001248, 0xc1c00002, 0xc000691c, 0xcdc000f8, 0x6ff8a000, 0x5bb87d00, 0x58380004,
+ 0xcb4000f8, 0xc2800000, 0x58380000, 0xca820008, 0xc000e824, 0xc3000000, 0xcb3c0070, 0x6f5c8000,
+ 0x41f4e000, 0x431d8000, 0x5b304000, 0xc000e828, 0xc1c00000, 0xc9fc0070, 0x00000000, 0xc0004000,
+ 0x41f4e000, 0x401c0000, 0xcac000f8, 0x5de80004, 0x84000988, 0xa6c608f2, 0x00000000, 0x6fe42000,
+ 0xc6e4a000, 0x6e60a000, 0x5a207b00, 0xc1800000, 0x58200000, 0xc9800000, 0xc2800000, 0xc6e80010,
+ 0x5dd80000, 0x8400003a, 0x5de80008, 0xc6a82012, 0xc1c00004, 0x45e8e000, 0x88000030, 0x80000650,
+ 0x5de80004, 0xc6a8010a, 0x5de80008, 0x84000630, 0x58380000, 0xc1c00002, 0xcdc00000, 0x58200000,
+ 0xc1c00002, 0xcdc00000, 0x5de80002, 0xcdc00002, 0xc000ea14, 0xc1e20000, 0xcdfe3100, 0xc000fb60,
+ 0xc1c00002, 0xcdfc0000, 0xc0006940, 0xc9c000f8, 0x403c0000, 0x00000000, 0x59dc0002, 0xcdc000f8,
+ 0xc1c00004, 0x45e8e000, 0x880000fa, 0x58200020, 0xc9c000f8, 0xc0c00018, 0xc1000000, 0xa5c0002a,
+ 0xc1400080, 0x5de80000, 0xc6ccf930, 0xc54c1932, 0x5de80000, 0xc1c0000a, 0xc5cc1230, 0xc5cc3202,
+ 0x58200022, 0xc9c000f8, 0xc74c0b30, 0xc7cc0008, 0xc5cc0528, 0xc1800000, 0xc6982000, 0xc1c00000,
+ 0xc69c0000, 0x71d8e000, 0xc5cc0400, 0x98405f10, 0xc5d00000, 0x7d80e000, 0xc5d00100, 0x5dd80002,
+ 0x84000480, 0xc1c00000, 0xc6ddc030, 0x59dc0006, 0xc5ec0e30, 0xc0c00018, 0xc1000004, 0x59dc0002,
+ 0xc5cc1230, 0xc74c0b30, 0xc7cc0008, 0xc0000088, 0x441ce000, 0xc5cc1930, 0xa6cc03a8, 0x583cfac0,
+ 0xc94000f8, 0xc1c80002, 0x70dc6000, 0xa55000c2, 0x58380024, 0xc94000f8, 0x00000000, 0x00000000,
+ 0x59540002, 0x58380024, 0xcd4000f8, 0xc0c00010, 0x98405f10, 0xc74c0b30, 0xc7cc0008, 0xc1000004,
+ 0x58200000, 0xc1c00000, 0xcdc00000, 0x58380026, 0xc94000f8, 0x00000000, 0x00000000, 0x59540002,
+ 0x58380026, 0xcd4000f8, 0x800002c0, 0xc1400000, 0xc6d5c030, 0x5d540002, 0x6d5c4010, 0x431c0000,
+ 0xc88000f8, 0xc1c00000, 0xc55c0008, 0xc0000006, 0x441ce000, 0x6ddc6000, 0x689c4010, 0xc1c001fe,
+ 0x749c4000, 0x59540002, 0xc1c000fe, 0x749c4000, 0x5c880020, 0xc48c1930, 0x5dc80002, 0x8800fee2,
+ 0xc1c0007c, 0x45c8e000, 0x8800feca, 0x4148c000, 0x59980002, 0x5dd80088, 0x8800002a, 0x58200000,
+ 0xc1c00000, 0xcdc00000, 0x800000c8, 0xc1400000, 0x6d9c4010, 0x431c0000, 0xc94000f8, 0xc1c00000,
+ 0xc59c0008, 0xc0000006, 0x441ce000, 0x6ddc6000, 0x695ca010, 0xc1c001fe, 0x755ca000, 0x00000000,
+ 0x00000000, 0x5dd40000, 0x84000018, 0x59980002, 0x8000ff48, 0x59980002, 0xc0800002, 0x5dd400a0,
+ 0xc4902100, 0xc4ac2602, 0x4588c002, 0xdbc800f9, 0xda4800f8, 0xda1000f9, 0x90405451, 0x58200020,
+ 0xc9c000f8, 0x58200022, 0xc94000f8, 0x5ddc0002, 0xc1c00000, 0xc5cc1932, 0xc6ddc030, 0x59dc0002,
+ 0x98405f10, 0xc5cc1230, 0xc54c0528, 0xc4d08000, 0xa5020072, 0xc1c00002, 0xc5d00100, 0xc5ac0e30,
+ 0xa6ccfd9a, 0xc1c00000, 0xc5cc0400, 0xc1c00086, 0x45d8e000, 0xc5cc1930, 0x8000ff28, 0x00000000,
+ 0x00000000, 0x00000000, 0x80000070, 0xdbc800f9, 0xda4800f8, 0xda1000f9, 0x90405451, 0x58200022,
+ 0xc98000f8, 0x58200020, 0xc9c000f8, 0x00000000, 0x98405f10, 0x5ddc0002, 0xc58c0528, 0xc5cc1932,
+ 0x80000210, 0xc1400000, 0xc000403e, 0xc9400000, 0xc1800000, 0x58200000, 0xc9800000, 0x5dd40002,
+ 0x84000020, 0x5dd80002, 0x84000010, 0x80000120, 0x5de80006, 0x84000088, 0x58380000, 0xc1c00002,
+ 0xcdc00000, 0xc000ea14, 0xc1e20000, 0xcdfe3100, 0xc000fb60, 0xc1c20002, 0xcdfc2100, 0xc0006944,
+ 0xc9c000f8, 0x403c0000, 0x00000000, 0x59dc0002, 0xcdc000f8, 0x80000100, 0x5de8000a, 0x84000080,
+ 0x58380000, 0xc1c00000, 0xcdc00000, 0xc000ea14, 0xc1c00000, 0xdd5c5100, 0x7dc0e000, 0xcdfe3100,
+ 0xc000fb60, 0xc1c20002, 0xcdfc2100, 0xc000facc, 0xc1c00002, 0xcdfc0000, 0x80000078, 0xa6ca0040,
+ 0xc000facc, 0xc1ca0002, 0xcdfca500, 0xc000fb64, 0xc1c60002, 0xcdfc6300, 0x80000038, 0xc000facc,
+ 0xc1c80002, 0xcdfc8400, 0xc000fb64, 0xc1c40002, 0xcdfc4200, 0xc0c00010, 0x98405f10, 0xc7cc0008,
+ 0xc74c0b30, 0xc1000004, 0x80000818, 0xc1c00002, 0x58380008, 0xcdc000f8, 0x58380000, 0xc1e00006,
+ 0xcdc21008, 0xc000facc, 0xc1c80002, 0xcdfc8400, 0xc000fb64, 0xc1c40002, 0xcdfc4200, 0xc0c00010,
+ 0x98405f10, 0xc7cc0008, 0xc74c0b30, 0xc1000004, 0x80000788, 0x5de80006, 0x84000180, 0xa6c60032,
+ 0x00000000, 0x58380000, 0xc1e00004, 0xcdc21008, 0x8000f658, 0x58380008, 0xca8000f8, 0xc2400000,
+ 0x58380002, 0xca420078, 0x00000000, 0x5aa80002, 0x58380008, 0xce8000f8, 0x46a4e000, 0x8800009a,
+ 0x58380000, 0xc1e00002, 0xcdc21008, 0x58380000, 0xc1c00000, 0xcdc00000, 0xc000facc, 0xc1c20002,
+ 0xcdfc2100, 0xc1e1e1a2, 0xc000ea1c, 0xcdfc00f8, 0xc000ea14, 0xc1c00000, 0xdd5c5100, 0x7dc0e000,
+ 0xcdfe3100, 0x80000038, 0xc000facc, 0xc1c80002, 0xcdfc8400, 0xc000fb64, 0xc1c40002, 0xcdfc4200,
+ 0xc0c00010, 0x98405f10, 0xc7cc0008, 0xc74c0b30, 0xc1000004, 0x80000600, 0x5de80002, 0x84000150,
+ 0xa6c6004a, 0x00000000, 0x58380000, 0xc1e00004, 0xcdc21008, 0xc1f8001e, 0xc000ea1c, 0xcdfc00f8,
+ 0x8000f4b8, 0x58380008, 0xca8000f8, 0xc2400000, 0x58380002, 0xca400078, 0xc000facc, 0xc1c20002,
+ 0xcdfc2100, 0x5aa80002, 0x58380008, 0xce8000f8, 0x46a4e000, 0x88000072, 0x58380000, 0xc1e00000,
+ 0xcdc21008, 0xc1c00000, 0x58380006, 0xcdc000f8, 0xc000e82c, 0xc1c00000, 0xcdfdce00, 0xc000e820,
+ 0xc1c00000, 0xcdfc0000, 0x80000300, 0xc0c00010, 0x98405f10, 0xc7cc0008, 0xc74c0b30, 0xc1000004,
+ 0x800004a8, 0x5838001c, 0xca8000f8, 0x5838001e, 0xca4000f8, 0x5aa80002, 0x5838001c, 0xce8000f8,
+ 0x4668e000, 0x88000098, 0x58380022, 0xca4000f8, 0x58380020, 0xca0000f8, 0xc000e82c, 0xc1c00000,
+ 0xcdfdce00, 0xc000e810, 0xce7c0030, 0xc2800000, 0x5838001c, 0xce8000f8, 0x5a200002, 0x58380020,
+ 0xce0000f8, 0xc000e82c, 0xc1dc0002, 0xcdfdce00, 0x58380006, 0xc8c000f8, 0x5830001c, 0xca8000f9,
+ 0xca4000f9, 0xc2000000, 0xca000001, 0x5dcc0006, 0x88000028, 0x58cc0002, 0x58380006, 0xccc000f8,
+ 0x80000250, 0x5838000a, 0xc8c000f9, 0xc90000f9, 0xc1400000, 0xc9400001, 0x74e86000, 0x75248000,
+ 0x7560a000, 0x58380010, 0xca8000f9, 0xca4000f9, 0xc2000000, 0xca000001, 0x98406080, 0x74e86000,
+ 0x75248000, 0x7560a000, 0x5dc800a0, 0x840001ba, 0x58380016, 0xca8000f9, 0xca4000f9, 0xc2000000,
+ 0xca000001, 0x98406080, 0x74e86000, 0x75248000, 0x7560a000, 0x5dc800a0, 0x84000162, 0x58380000,
+ 0xc1e00004, 0xcdc21008, 0x5838001c, 0xc1c00000, 0xcdc000f8, 0xc000e82c, 0xc1c00000, 0xcdfdce00,
+ 0xc1f8001e, 0xc000ea1c, 0xcdfc00f8, 0xc000e820, 0xc1c00002, 0xcdfc0000, 0xc1c00082, 0x45c8e000,
+ 0xc000e810, 0xcdfc0030, 0xc2400000, 0xc000e82c, 0xca7c0038, 0xc000e83c, 0xc2800000, 0xcabc0038,
+ 0xc0c00010, 0x98405f10, 0xc7cc0008, 0xc74c0b30, 0xc1000004, 0x5b740002, 0x4674e000, 0xc1c00000,
+ 0xc5f400fe, 0x5ea80002, 0x8400ffb0, 0xc000e83c, 0xc1c00000, 0xcdfc0038, 0xc000e82c, 0xc1dc0002,
+ 0xcdfdce00, 0x80000178, 0x58380010, 0xca8000f9, 0xca4000f9, 0xc2000000, 0xca000001, 0x58380016,
+ 0xce8000f9, 0xce4000f9, 0xce000001, 0x5838000a, 0xca8000f9, 0xca4000f9, 0xc2000000, 0xca000001,
+ 0x58380010, 0xce8000f9, 0xce4000f9, 0xce000001, 0x5830001c, 0xca8000f9, 0xca4000f9, 0xc2000000,
+ 0xca000001, 0x5838000a, 0xce8000f9, 0xce4000f9, 0xce000001, 0xc000facc, 0xc1c20002, 0xcdfc2100,
+ 0xc0c00010, 0x98405f10, 0xc7cc0008, 0xc74c0b30, 0xc1000004, 0xc000e83c, 0xc1d00002, 0xcdfd0800,
+ 0xc0c00000, 0xc000e82c, 0xc8fc0038, 0x5b740002, 0x00000000, 0x44f4e000, 0xc1c00000, 0xc5f400fe,
+ 0x58380004, 0xcf4000f8, 0x98406158, 0x00000000, 0x00000000, 0x00000000, 0xc000400c, 0xcbc000f8,
+ 0xc000400e, 0xcb8000f8, 0xc0007d00, 0xcac000f8, 0x73f8e000, 0x8400034a, 0x58000040, 0xca8000f8,
+ 0xc0006960, 0x4b000058, 0xc1e00002, 0x7dc0e000, 0x76dd6000, 0x769d4000, 0xc2620002, 0x5a640002,
+ 0xc3400000, 0xc2000006, 0x46e4e000, 0xc634000a, 0x46a4e000, 0xc634020a, 0xc000fb80, 0xcac000f8,
+ 0xc000fba0, 0xca8000f8, 0xc2400000, 0xc2000000, 0xc6e40000, 0xc6e40100, 0xc6a40200, 0xc6a40300,
+ 0xc6e02000, 0xc6e02100, 0xc6a02200, 0xc6a02300, 0x7765a000, 0x7761a000, 0xc6740818, 0x7b716000,
+ 0x84000232, 0xc0006960, 0xcf4000f8, 0xc0800000, 0xc1c1fffe, 0x45fce000, 0x88000022, 0xa9420018,
+ 0x00000000, 0xc0800008, 0x58fc0008, 0x59380008, 0xc1c1fffe, 0x45fce000, 0x88000018, 0x58fc0020,
+ 0x59380020, 0x776d4000, 0x840000ca, 0x6e950010, 0x5dd40000, 0x84000052, 0xc000f41a, 0xcfc000f8,
+ 0xc1c00000, 0xc7dc4050, 0x581cc000, 0x5dfdfffe, 0xc7c000fe, 0x6948a000, 0xcd4000f8, 0xc1c001fe,
+ 0x769d4000, 0x84000052, 0xc000f41a, 0xccc000f8, 0xc1c00000, 0xc4dc4050, 0x581cc000, 0x5dcdfffe,
+ 0xc4c000fe, 0x6a894000, 0xce8000f8, 0x7f41a000, 0x776d2000, 0x840000ca, 0x6e550010, 0x5dd40000,
+ 0x84000052, 0xc000f41a, 0xcf8000f8, 0xc1c00000, 0xc79c4050, 0x581cc000, 0x5df9fffe, 0xc78000fe,
+ 0x6948a000, 0xcd4000f8, 0xc1c001fe, 0x765d2000, 0x84000052, 0xc000f41a, 0xcd0000f8, 0xc1c00000,
+ 0xc51c4050, 0x581cc000, 0x5dd1fffe, 0xc50000fe, 0x6a492000, 0xce4000f8, 0xa9440180, 0xc000a340,
+ 0xcbc000f8, 0xa9420168, 0xc000a34a, 0xcb8000f8, 0xc000f414, 0xcb4000f8, 0x5dfc0002, 0x84000048,
+ 0xc000a346, 0x98405fc8, 0xc8c000f9, 0xc90000f8, 0xc3c00004, 0xc000a340, 0xcfc000f8, 0x80000058,
+ 0x5dfc0004, 0x84000048, 0xc1c40002, 0x75f4e000, 0x84000032, 0xc000f414, 0xcdc000f8, 0xc3c00006,
+ 0xc000a340, 0xcfc000f8, 0x5df80002, 0x84000048, 0xc000a350, 0x98405f10, 0xc8c000f9, 0xc90000f8,
+ 0xc3800004, 0xc000a34a, 0xcf8000f8, 0x80000058, 0x5df80004, 0x84000048, 0xc1c20002, 0x75f4e000,
+ 0x84000032, 0xc000f414, 0xcdc000f8, 0xc3800006, 0xc000a34a, 0xcf8000f8, 0xa9440b42, 0xc0006914,
+ 0xcbc000f8, 0xc2800000, 0xc2400000, 0x5bfc4b00, 0xc7c000f8, 0xcb0000f8, 0x58000002, 0xcac000f8,
+ 0xc0004026, 0xca800078, 0xc0004026, 0xca420078, 0xc3400000, 0xc7366018, 0xa73e0172, 0x00000000,
+ 0xc777e300, 0xc000694c, 0xc9c000f8, 0x00000000, 0x00000000, 0x59dc0002, 0xcdc000f8, 0x6f5c6000,
+ 0x58dcb640, 0x580c0000, 0xc90000f8, 0x580c0002, 0xc94000f8, 0x59100002, 0x580c0000, 0xcd0000f8,
+ 0xc1c00000, 0xc71c0078, 0x415ca000, 0x580c0002, 0xcd4000f8, 0x984026e8, 0x5834fc10, 0xc8c000f8,
+ 0xc1000000, 0x5dc80000, 0x84000070, 0x6f402000, 0x58005fe0, 0xc3800000, 0x58000000, 0xcb800078,
+ 0xc1c00000, 0x58000002, 0xc9c00078, 0x984029a0, 0x00000000, 0x439dc000, 0x00000000, 0x80000028,
+ 0x98402778, 0xc48c00f8, 0x00000000, 0x00000000, 0xc0006916, 0xcbc000f8, 0xc3400000, 0x00000000,
+ 0x5bfc7a00, 0xc7c000f8, 0xcb0000f8, 0x58000002, 0xcac000f8, 0xc7366018, 0xa73e0900, 0x00000000,
+ 0xc777e300, 0xc000694e, 0xc9c000f8, 0x00000000, 0x00000000, 0x59dc0002, 0xcdc000f8, 0x6f5c6000,
+ 0x58dcb640, 0x580c0000, 0xc90000f8, 0x580c0002, 0xc94000f8, 0x59100002, 0x580c0000, 0xcd0000f8,
+ 0xc1c00000, 0xc71c0078, 0x415ca000, 0x580c0002, 0xcd4000f8, 0x984026e8, 0x5834fc10, 0xc8c000f8,
+ 0xc1000000, 0x5dc80000, 0x84000070, 0x6f402000, 0x58005fe0, 0xc3800000, 0x58000000, 0xcb800078,
+ 0xc1c00000, 0x58000002, 0xc9c00078, 0x98402cb0, 0x00000000, 0x439dc000, 0x00000000, 0x800007b8,
+ 0x984028a0, 0xc48c00f8, 0x00000000, 0x00000000, 0x80000790, 0xc7100078, 0xc0800000, 0x6f402000,
+ 0x58005fe0, 0xc1400000, 0x58000000, 0xc9420038, 0x4690e000, 0x88000030, 0x454ca000, 0x9c400000,
+ 0x4564e000, 0xc1c00004, 0xc5c800fe, 0x9c400000, 0x454ce000, 0xc1c00002, 0xc5c800fe, 0xc0006914,
+ 0xc90000f8, 0xc1400000, 0xc0004022, 0xc9400078, 0x583c0000, 0xc1fc0000, 0xcdc3de00, 0x583c0000,
+ 0xcd400078, 0x583c0000, 0xc1fe0002, 0xcdc3ff00, 0x59100004, 0xc1c00100, 0x45d0e000, 0xc1c00000,
+ 0xc5d000fe, 0xc0006914, 0xcd0000f8, 0x6f546000, 0x5954b640, 0x5dcc0002, 0x84000038, 0x5814000c,
+ 0xc9c000f8, 0x00000000, 0x00000000, 0x59dc0002, 0xcdc000f8, 0x5814000e, 0xc9c000f8, 0x00000000,
+ 0x9c400000, 0x59dc0002, 0xcdc000f8, 0x00000000, 0xc0006916, 0xc90000f8, 0x583c0000, 0xc1fc0000,
+ 0xcdc3de00, 0x583c0000, 0xc1fe0000, 0xcdc3ff00, 0x59100004, 0xc1c00100, 0x45d0e000, 0xc1c00000,
+ 0xc5d000fe, 0xc0006916, 0xcd0000f8, 0x6f546000, 0x5954b640, 0x5dcc0002, 0x84000038, 0x58140008,
+ 0xc9c000f8, 0x00000000, 0x00000000, 0x59dc0002, 0xcdc000f8, 0x5814000a, 0xc9c000f8, 0x00000000,
+ 0x9c400000, 0x59dc0002, 0xcdc000f8, 0x00000000, 0xc78000f8, 0xc8c000f8, 0x58000002, 0xc90000f8,
+ 0xa4e00178, 0xc0006918, 0xca0000f8, 0x00000000, 0x00000000, 0x5a205d00, 0xc60000f8, 0xc94000f8,
+ 0x58000002, 0xc98000f8, 0xa57e006a, 0xc1c00000, 0xc0c00004, 0xc71c0078, 0xc46000f8, 0x98402778,
+ 0x45e8e000, 0xc1c00002, 0xc5cc00fe, 0x9e000000, 0xc1e00002, 0xc000e408, 0xcdc21000, 0xc55c00f8,
+ 0xc4d400f8, 0xc5cc00f8, 0xc59c00f8, 0xc51800f8, 0xc5d000f8, 0xc1c00000, 0xc5d41f00, 0xc5cff000,
+ 0x58200002, 0xcd8000f8, 0x5c000002, 0xcd4000f8, 0x5e205d00, 0x5a200004, 0xc1c00080, 0x45e0e000,
+ 0xc1c00000, 0xc5e000fe, 0xc0006918, 0xce0000f8, 0xc1e00002, 0xc000e408, 0xcdc21000, 0xc6dc00f8,
+ 0xc52c00f8, 0xc5d000f8, 0xc71c00f8, 0xc4f000f8, 0xc5cc00f8, 0xc0004022, 0xcb000078, 0xc1c00002,
+ 0xc5cc1f00, 0xc5f01f00, 0xc5f3fe00, 0x58380002, 0xcd0000f8, 0x5c000002, 0xccc000f8, 0x6f402000,
+ 0x58005fe0, 0xc1c00000, 0xc9c20138, 0xc2000000, 0x58000002, 0xca000078, 0x00000000, 0x00000000,
+ 0x5a200004, 0x45e0e000, 0xc1c00000, 0xc5e000fe, 0xce000078, 0x5e3c4b00, 0x5a200004, 0xc1c00100,
+ 0x45e0e000, 0xc1c00000, 0xc5e000fe, 0xc0006914, 0xce0000f8, 0xc1c00002, 0x69f4e000, 0xc5dc0838,
+ 0xd9f000f8, 0x583c0002, 0xcec000f8, 0x5c000002, 0xcf0000f8, 0x9c400000, 0x58380002, 0xc90000f8,
+ 0x5c000002, 0xc8c000f8, 0xc6dc00f8, 0xc52c00f8, 0xc5d000f8, 0xc71c00f8, 0xc4f000f8, 0xc5cc00f8,
+ 0xc1c00002, 0xc5cc1f00, 0xc1c00000, 0xc5f01f00, 0xc5f3fe00, 0x58380002, 0xcd0000f8, 0x5c000002,
+ 0xccc000f8, 0x6f402000, 0x58005fe0, 0xc1c00000, 0xc9c20138, 0xc2000000, 0x58000002, 0xca000078,
+ 0x00000000, 0x00000000, 0x5a200004, 0x45e0e000, 0xc1c00000, 0xc5e000fe, 0xce000078, 0x5e3c7a00,
+ 0x5a200004, 0xc1c00100, 0x45e0e000, 0xc1c00000, 0xc5e000fe, 0xc0006916, 0xce0000f8, 0xc1c00002,
+ 0x69f4e000, 0xc5dc0838, 0xd9f000f8, 0x583c0002, 0xcec000f8, 0x5c000002, 0xcf0000f8, 0xc1e20002,
+ 0xc000e408, 0xcdc23100, 0x9c400000, 0x00000000, 0x00000000, 0x00000000, 0xc0004010, 0xc9c000f8,
+ 0xc0007e24, 0xc8c000f8, 0xa5c200e2, 0x00000000, 0xc0007e22, 0xc9c000f8, 0x00000000, 0x00000000,
+ 0x5ddc0000, 0x840000aa, 0xc000f41a, 0xcdc000f8, 0x580ca100, 0xc90000f8, 0x580cc100, 0x00000000,
+ 0xa53e0070, 0x00000000, 0xcd0000f8, 0xc1c00000, 0x580ca100, 0xcdc000f8, 0x58cc0002, 0xc1c00080,
+ 0x45cce000, 0xc1c00000, 0xc5cc00fe, 0xc0007e24, 0xccc000f8, 0x8000ff78, 0xc3c00000, 0x6ff8a000,
+ 0x5bb87d80, 0x583cfb50, 0xc2800000, 0xca80c030, 0xc2400000, 0x58380000, 0xca400078, 0x58380006,
+ 0xca0000f8, 0x583cea28, 0xc9c000f8, 0xc0c00000, 0x00000000, 0xc5cc0038, 0x420c8000, 0x4268a000,
+ 0x4514e000, 0x8800012a, 0x58380004, 0xca4000f8, 0x5de00080, 0x8800007a, 0xc000ea28, 0xc1d2007e,
+ 0xcdfd2928, 0xc000ea28, 0xc1d00002, 0xcdfd0800, 0x5de0007e, 0xc000ea28, 0x6ddd2000, 0xcdfd2928,
+ 0xc000ea28, 0xc1d00002, 0xcdfd0800, 0x80000038, 0xc000ea28, 0x6e1d2000, 0xcdfd2928, 0xc000ea28,
+ 0xc1d00002, 0xcdfd0800, 0x583c6948, 0xc9c000f8, 0x00000000, 0x00000000, 0x41e0e000, 0xcdc000f8,
+ 0x46612000, 0x58380004, 0xce4000f8, 0x58380006, 0xc1c00000, 0xcdc000f8, 0x58380004, 0xca4000f8,
+ 0x583cea28, 0xc9c000f8, 0xc0c00000, 0x00000000, 0xc5cc0038, 0xc1400000, 0x58380000, 0xc9420078,
+ 0x424d0000, 0x00000000, 0x42948000, 0x4520e000, 0x88001e9a, 0xc000fa40, 0xc9bc00f8, 0x6ff42000,
+ 0xc3000000, 0xc5b4e000, 0xc2c07c00, 0x6f5ca000, 0x42dd6000, 0x582c0022, 0xc98000f8, 0x00000000,
+ 0x00000000, 0x5dd80000, 0x840003d2, 0x582c0026, 0xca8000f8, 0x5838000a, 0xc98000f8, 0xc000ea10,
+ 0xc2400000, 0xca7c0070, 0x6d9c8000, 0x41d8e000, 0x425d2000, 0x5a644000, 0x582c0032, 0xc9c000f8,
+ 0x582c002e, 0xc98000f8, 0x582c0030, 0xc94000f8, 0x00000000, 0x41d8e000, 0x41d4e000, 0xd9f800f8,
+ 0x5ddc0080, 0x880000a2, 0x00000000, 0xa7400018, 0xc180001e, 0xc180015e, 0xc1400000, 0x6d5c4010,
+ 0x425c0000, 0xc1c00006, 0x755c8000, 0x5dd00000, 0xcd80183a, 0x5dd00002, 0xcd80103a, 0x5dd00004,
+ 0xcd80083a, 0x5dd00006, 0xcd80003a, 0x5b300008, 0x80000278, 0x58240002, 0xc1800000, 0xcd8000f9,
+ 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9,
+ 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xa7400018,
+ 0xc18001e0, 0xc18001ea, 0xc1400000, 0x6d5c4010, 0x425c0000, 0xc90000f8, 0xc1c00000, 0xc55c0308,
+ 0x691c8008, 0xc5901838, 0x691c8018, 0xcd0000f8, 0x6d5c4010, 0x425c0000, 0xc1c00006, 0x755c8000,
+ 0x5dd00000, 0xcd80183a, 0x5dd00002, 0xcd80103a, 0x5dd00004, 0xcd80083a, 0x5dd00006, 0xcd80003a,
+ 0x5b300008, 0xdf9400f8, 0xc1008fe0, 0x6d5c4010, 0x411c0000, 0xc98000f8, 0xc1c00000, 0xc55c0308,
+ 0x699cc000, 0x6d9b0010, 0x6f1c4010, 0x425c0000, 0xc94000f8, 0xc1c00000, 0xc71c0308, 0x695ca008,
+ 0xc5941838, 0x695ca018, 0xcd4000f8, 0x6f1c4010, 0x425c0000, 0xc1c00006, 0x771ca000, 0x5dd40000,
+ 0xcd80183a, 0x5dd40002, 0xcd80103a, 0x5dd40004, 0xcd80083a, 0x5dd40006, 0xcd80003a, 0x5b300002,
+ 0x582c0022, 0xc1c00000, 0xcdc000f8, 0x800013f0, 0x00000000, 0xa9440328, 0xc000e444, 0xc90000f8,
+ 0xc0006956, 0xc8c000f8, 0xc000e442, 0xcd0000f8, 0x70d06000, 0xc0006956, 0xccc000f8, 0xc1c00002,
+ 0x69f4e000, 0xc0006960, 0xc88000f8, 0x74dc6000, 0x840018ea, 0x749c4000, 0x80000008, 0xc000401a,
+ 0xc9c000f8, 0x00000000, 0xc000f41a, 0xcdc000f8, 0xc0c00000, 0xc0004054, 0xc8c00078, 0xc0006958,
+ 0xc93400f8, 0x6f5ca000, 0x40dc6000, 0x40d06000, 0xc4c000f8, 0xc94000f8, 0x00000000, 0x00000000,
+ 0xa57e01a0, 0xc0004054, 0xc9820078, 0x6d1c2010, 0x59100004, 0x419cc000, 0x6f5c8000, 0x419cc000,
+ 0xc1c00040, 0x45d0e000, 0xc1c00000, 0xc5d000fe, 0xc0006958, 0xcd3400f8, 0x5dc80000, 0x8400016a,
+ 0x580c0002, 0xc90000f8, 0x582c0032, 0xc1c00000, 0xcdc000f8, 0x582c002a, 0xccc000f8, 0x582c0034,
+ 0xcd4000f8, 0x582c0036, 0xcd0000f8, 0xa9460042, 0xc58000f8, 0xc90000f8, 0x582c0032, 0xc1c00004,
+ 0xcdc000f8, 0x582c0038, 0xcd0000f8, 0xc1c00000, 0xc55e6018, 0x582c002c, 0xcdc000f8, 0x582c003a,
+ 0xc8c000f8, 0x582c003c, 0xc9c000f8, 0xc1800000, 0xc5580078, 0x58cc0002, 0x41d8e000, 0x582c003a,
+ 0xccc000f8, 0x582c003c, 0xcdc000f8, 0x80000070, 0xc0006956, 0xc8c000f8, 0xc1c00002, 0x69f4e000,
+ 0x7dc0e000, 0x74dc6000, 0xccc000f8, 0x80001670, 0xc4c000f8, 0xc1c00000, 0xc5d41f00, 0xcd4000f8,
+ 0x80001648, 0x80000928, 0xdb8800f9, 0xdb4800f8, 0xdb1000f9, 0xc2400000, 0xdf240038, 0xc0004024,
+ 0xcb8000f8, 0xdcb400f8, 0x6f404000, 0x58004d48, 0x58000006, 0xcb000078, 0xc3400000, 0xc7b50038,
+ 0xc2800000, 0xc7a88018, 0xc000fa40, 0xc8fc00f8, 0xc2800000, 0x582c0004, 0xca800038, 0xa4ce0042,
+ 0x58ec0040, 0xc1c00000, 0x580c0004, 0xc9c00038, 0x00000000, 0x00000000, 0x729d4000, 0x7e412000,
+ 0x76692000, 0xc0400000, 0xc7840008, 0xc000a0ae, 0x5de40000, 0x84000080, 0xc0c00000, 0xc8c000f8,
+ 0x5dc40000, 0xdcb800fb, 0xdcb400fa, 0xdd3000fb, 0x840014ea, 0x5dcc0000, 0xdcb800fb, 0xdcb400fa,
+ 0xdd3000fb, 0x840014c2, 0xc0c00000, 0xccc000f8, 0x80000250, 0xc0c00002, 0xccc000f8, 0xc65000f8,
+ 0x61010028, 0x5dc40000, 0x84000018, 0x62410008, 0x800003f8, 0xc0007e26, 0xc94000f8, 0xc0400000,
+ 0x00000000, 0x6140c028, 0x00000000, 0x00000000, 0xcd4000f8, 0x84000052, 0x6d804000, 0x58004d08,
+ 0x58000000, 0xc84000b8, 0x00000000, 0x00000000, 0x58000004, 0xcc4000b8, 0x8000ff78, 0x6e144000,
+ 0x59544d08, 0xc0400000, 0x58140004, 0xc84000b8, 0xa78200d0, 0xc0800000, 0xc1c00000, 0x6e1c2000,
+ 0x59dc5fe0, 0x581c0002, 0xc8820078, 0x581c0000, 0xc9c00078, 0xc1800000, 0x58140006, 0xc9800078,
+ 0x409ce000, 0xc0800000, 0x581c0000, 0xc8800078, 0x00000000, 0x00000000, 0x40b44000, 0x4588e000,
+ 0x88000030, 0xc1c00002, 0x69e0e000, 0x7dc0e000, 0x765d2000, 0x80000038, 0xa7800030, 0x5dc40000,
+ 0x84000022, 0xc1ee0002, 0x75c4e000, 0xc4cc2002, 0x61010028, 0xa60afed0, 0x00000000, 0x5de40000,
+ 0xdcb800fb, 0xdcb400fa, 0xdd3000fb, 0x84001272, 0x5dcc0000, 0x840000c2, 0xa78000b8, 0x62810028,
+ 0x840000aa, 0x6e0c4000, 0x58cc4d08, 0xc1000000, 0x580c0004, 0xc90000b8, 0xc1800000, 0x580c0000,
+ 0xc98000b8, 0x7d00a000, 0xc1f00002, 0x5ddc0002, 0x755ca000, 0x59540002, 0xc1ee0002, 0x75d0e000,
+ 0xc5d400fa, 0x45948000, 0x580c0004, 0xcd0000b8, 0x8000ff58, 0x5de40000, 0xdcb800fb, 0xdcb400fa,
+ 0xdd3000fb, 0x84001182, 0x62410008, 0xa7800100, 0x00000000, 0xa7820068, 0x00000000, 0xa7860058,
+ 0xc0004022, 0xc0c00000, 0xc8c00078, 0x00000000, 0x00000000, 0x470ce000, 0xdcb800fd, 0xdcb400fc,
+ 0xdd3000fd, 0x88001102, 0xc0c00000, 0xc65000f8, 0x6100a028, 0x6d584000, 0x59984d08, 0xc0400000,
+ 0x58180004, 0xc84000b8, 0x00000000, 0x00000000, 0xa46e002a, 0x44c4e000, 0x88000018, 0xc56000f8,
+ 0xc44c00f8, 0x6100a028, 0xa54aff98, 0x6e184000, 0x59984d08, 0xc0400000, 0xc0800000, 0x6e1c2000,
+ 0x59dc5fe0, 0x581c0002, 0xc8420078, 0x581c0000, 0xc8800078, 0xc1400000, 0x58180006, 0xc9400078,
+ 0x40484000, 0xc0c00000, 0x58080000, 0xc8c00078, 0x00000000, 0xa78200a0, 0x40f42000, 0x4704e000,
+ 0xdcb800fd, 0xdcb400fc, 0xdd3000fd, 0x88000fb2, 0x5dd5fffe, 0x84000022, 0x4544a000, 0x58180006,
+ 0xcd400078, 0x5df1fffe, 0x8400003a, 0x47058000, 0xdcb400f8, 0x6f404000, 0x58004d48, 0x58000006,
+ 0xcf000078, 0xa7800088, 0xc0400000, 0x58180000, 0xc84000b8, 0xc1000000, 0x58180004, 0xc90000b8,
+ 0x5dc40000, 0x8400004a, 0xc1ee0002, 0x5ddc0002, 0x445ce000, 0x8400002a, 0x450c8000, 0x45348000,
+ 0x58180004, 0xcd0000b8, 0x6e106000, 0x5910b640, 0x58100006, 0xc98000f8, 0x58100004, 0xc94000f8,
+ 0x418cc000, 0x58100006, 0xcd8000f8, 0x59540002, 0x58100004, 0xcd4000f8, 0x6e242000, 0x5a645fe0,
+ 0xc0c00000, 0x58240002, 0xc8c20078, 0xc1000000, 0x58240000, 0xc9020038, 0x582c002a, 0xcc8000f8,
+ 0x582c002c, 0xce0000f8, 0xc48000f8, 0xc94000f8, 0x58080002, 0xc98000f8, 0x582c0034, 0xcd4000f8,
+ 0x582c0036, 0xcd8000f8, 0x582c0038, 0xc1c00000, 0xcdc000f8, 0x582c0032, 0xc1c00000, 0xcdc000f8,
+ 0x6d102000, 0x58cc0004, 0x450ce000, 0xc1c00000, 0xc5cc00fe, 0x58240002, 0x6cde0000, 0xcdc21078,
+ 0xc0e00002, 0x68e06000, 0xd8f000f8, 0xdcb800f9, 0xdcb400f8, 0xdd3000f9, 0xc0006910, 0xc8c000f9,
+ 0xc90000f8, 0xc1c00000, 0xc1400040, 0x60c04000, 0x7494e000, 0x8400007a, 0xc1400080, 0x61004000,
+ 0x58880040, 0x7494e000, 0x84000052, 0x00000000, 0xab6c0002, 0x00000000, 0x00000000, 0x984059a0,
+ 0xc0006902, 0xc8c000f8, 0xc3c00000, 0x8000ff58, 0xc0006910, 0xc1c00000, 0xc49ca000, 0x401c0000,
+ 0xc8c000f8, 0xc1000002, 0xc1400000, 0xc4940020, 0x6914e000, 0x70dc6000, 0xccc000f8, 0x582c0020,
+ 0xcc8000f8, 0xc1c00002, 0x582c0022, 0xcdc000f8, 0xc2409c00, 0x6c9c6000, 0x425d2000, 0xc2807600,
+ 0x6c9c6000, 0x429d4000, 0x582c002c, 0xc98000f8, 0x582c0026, 0xce8000f8, 0x582c0028, 0xce4000f8,
+ 0x58240008, 0xcd8000f8, 0x5838000a, 0xc98000f8, 0xc000ea10, 0xc2000000, 0xca3c0070, 0x6d9c8000,
+ 0x41d8e000, 0x421d0000, 0x5a204000, 0x582c002a, 0xc98000f8, 0xc1400000, 0xc1000000, 0xc58000f8,
+ 0xc9c000f8, 0x5824000a, 0xcd8000f8, 0x5824000c, 0xcdc000f8, 0x59ac0034, 0x58180000, 0xc942e020,
+ 0x58180002, 0xc90000e0, 0xc000401e, 0xc98000f8, 0x58280002, 0xc1c00000, 0xcdc00078, 0x41148000,
+ 0xc1400000, 0xc5941078, 0x7d40a000, 0x75148000, 0xc1400000, 0xc5961078, 0x71148000, 0x58280004,
+ 0xcd0000e0, 0x58a40000, 0x586c0008, 0xc44000f8, 0xc8c000f9, 0xc90000f9, 0xc94000f8, 0xc48000f8,
+ 0xccc000f9, 0xcd0000f9, 0xcd4000f9, 0x5df00000, 0x84000138, 0x58200000, 0xc1800000, 0xcd8000f9,
+ 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9,
+ 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9,
+ 0xc18001ea, 0xc1c00002, 0x75f4e000, 0xc1c001e0, 0xc5d800fa, 0xc1400000, 0x6d5c4010, 0x421c0000,
+ 0xc1c00006, 0x755c8000, 0x5dd00000, 0xcd80183a, 0x5dd00002, 0xcd80103a, 0x5dd00004, 0xcd80083a,
+ 0x5dd00006, 0xcd80003a, 0x5b300008, 0xc000fa40, 0xc93c00f8, 0xc1400000, 0x582c0002, 0xc9428018,
+ 0xc0400000, 0xc0800080, 0x44944000, 0xc45800f8, 0xc1c00200, 0x75d0e000, 0xc49c00f8, 0xc5d800fa,
+ 0x582c0030, 0xcd4000f8, 0xd97800f8, 0x59ec0034, 0xc0c00000, 0x582c0002, 0xc8c10038, 0xc1000000,
+ 0x581c0000, 0xc9000078, 0x00000000, 0x00000000, 0xc50800f8, 0x4518e000, 0xc59c00f8, 0xc5c800fc,
+ 0xc4d400f8, 0x44c8e000, 0xc49c00f8, 0xc5d400fc, 0x582c002e, 0xcd4000f8, 0x582c0032, 0xc88000f8,
+ 0xdf9000f8, 0x4150e000, 0x41c8e000, 0xd9f800f8, 0x41f0e000, 0x5ddc0086, 0x88000082, 0xc18000a0,
+ 0x6f1c4010, 0x421c0000, 0xc1c00006, 0x771ca000, 0x5dd40000, 0xcd80183a, 0x5dd40002, 0xcd80103a,
+ 0x5dd40004, 0xcd80083a, 0x5dd40006, 0xcd80003a, 0x5b300002, 0x80000158, 0x00000000, 0x00000000,
+ 0x00000000, 0xdf9400f8, 0xc1008fe0, 0x6d5c4010, 0x411c0000, 0xc98000f8, 0xc1c00000, 0xc55c0308,
+ 0x699cc000, 0x6d9b0010, 0x6f1c4010, 0x421c0000, 0xc1c00006, 0x771c6000, 0x5dcc0000, 0xcd80183a,
+ 0x5dcc0002, 0xcd80103a, 0x5dcc0004, 0xcd80083a, 0x5dcc0006, 0xcd80003a, 0x5b300002, 0xc18000a0,
+ 0x6f1c4010, 0x421c0000, 0xc1c00006, 0x771ca000, 0x5dd40000, 0xcd80183a, 0x5dd40002, 0xcd80103a,
+ 0x5dd40004, 0xcd80083a, 0x5dd40006, 0xcd80003a, 0x5b300002, 0x582c0022, 0xc1c00000, 0xcdc000f8,
+ 0x00000000, 0x5df00088, 0x88000578, 0x582c0032, 0xca0000f8, 0x582c0038, 0xc8c000f8, 0x5de00000,
+ 0x8400004a, 0x582c0020, 0xc98000f8, 0x98404d38, 0xc2840002, 0xc5a80528, 0xc2400000, 0x5df00088,
+ 0x88000508, 0x582c0020, 0xc98000f8, 0xc2800000, 0xc2400000, 0xc5a80528, 0x582c002e, 0xc98000f8,
+ 0xc1000088, 0x45308000, 0xc51400f8, 0x4590e000, 0xc59c00f8, 0xc5d400fc, 0xc5681930, 0x5838000a,
+ 0xc90000f8, 0xc7281230, 0xc7e80008, 0xc5280b30, 0xd93800f8, 0xc1c00002, 0xc5e80400, 0x4594e000,
+ 0x8400001a, 0xc1c00000, 0xc5e80400, 0x5dd80000, 0x8400002a, 0xc1c00002, 0xc5e80300, 0xc1c00002,
+ 0xc5e80200, 0x582c0022, 0xc94000f8, 0xc7640e08, 0x00000000, 0x5d540002, 0x8400001a, 0xc1c00002,
+ 0xc5e40d00, 0xc0c00000, 0xc68f2030, 0x430c8000, 0xc5241838, 0xc0800088, 0x44904000, 0xc1c00000,
+ 0xc5c800fc, 0x582c0030, 0xc94000f8, 0xc0400000, 0x582c0002, 0xc8420018, 0xc49000f8, 0x4548e000,
+ 0xc55c00f8, 0xc5d000fc, 0xc5241418, 0x44546000, 0xc4e41018, 0x4550a000, 0x582c0030, 0xcd4000f8,
+ 0xc0c00000, 0xc68f2030, 0x458cc000, 0x582c002e, 0xcd8000f8, 0x43118000, 0x430d8000, 0xdf9800f8,
+ 0xc000ea10, 0xc1400000, 0xc97c0070, 0x6d9c8000, 0x41d8e000, 0x415ca000, 0x59544000, 0x00000000,
+ 0xc1000000, 0xc0000000, 0xc9140038, 0x00000000, 0x00000000, 0x59100002, 0xcd140038, 0x98405fc8,
+ 0xc68c00f8, 0xc65000f8, 0x00000000, 0x5df00088, 0x8800e8c2, 0x00000000, 0x80000218, 0xd87800f8,
+ 0xc1000088, 0x45308000, 0xc51400f8, 0x4610e000, 0xc61c00f8, 0xc5d400fc, 0xc5681930, 0x46150000,
+ 0x582c0032, 0xce0000f8, 0xc56000f8, 0x5838000a, 0xc94000f8, 0xc7281230, 0xc7e80008, 0xc5680b30,
+ 0xc000ea10, 0xc1000000, 0xc93c0070, 0x6d5c8000, 0x41d4e000, 0x411c8000, 0x59104000, 0x6f1c4010,
+ 0x411c0000, 0xc94000f8, 0xc1c00000, 0xc71c0308, 0x695ca008, 0xc4d71838, 0x695ca018, 0xcd4000f8,
+ 0x5b300002, 0x5e200002, 0x84000062, 0x6ccd0000, 0x6f1c4010, 0x411c0000, 0xc94000f8, 0xc1c00000,
+ 0xc71c0308, 0x695ca008, 0xc4d71838, 0x695ca018, 0xcd4000f8, 0x5b300002, 0x6ccd0000, 0x582c0038,
+ 0xccc000f8, 0xc1400000, 0xc0000000, 0xc9500038, 0x00000000, 0x00000000, 0x59540002, 0xcd500038,
+ 0xdfa000f8, 0x98405fc8, 0xc68c00f8, 0xc65000f8, 0x00000000, 0x9e000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x5df00000, 0x840000ba, 0xc1c00002, 0xc000691c, 0xcdc000f8, 0x5838000a, 0xc94000f8,
+ 0xc1000000, 0xc000ea14, 0xc93c0038, 0x59540002, 0x00000000, 0x4514e000, 0xc1c00000, 0xc5d400fe,
+ 0x5838000a, 0xcd4000f8, 0x58380004, 0xc94000f8, 0x00000000, 0x00000000, 0x59540002, 0x58380004,
+ 0xcd4000f8, 0x5df00000, 0x84000058, 0xa7400020, 0x00000000, 0x6ff42000, 0x8000e1a0, 0x5bfc0002,
+ 0x5dfc0002, 0x8400df32, 0x00000000, 0x00000000, 0x00000000, 0xab6c0052, 0x984059a0, 0xc0006902,
+ 0xc8c000f8, 0xc3c00000, 0xab6c002a, 0x984059a0, 0xc0006902, 0xc8c000f8, 0xc3c00000, 0xc0004032,
+ 0xcbc000f8, 0xc0004038, 0xcb8000f8, 0xc000691a, 0xcb0000f8, 0xc000403a, 0xcb4000f8, 0xc72c00f8,
+ 0xa7800058, 0xc2800000, 0x00000000, 0x98405278, 0xc0c07c80, 0xc0007c00, 0x00000000, 0x984052e0,
+ 0xc0006952, 0xc80000f8, 0xc1000000, 0xa7900058, 0xc2800002, 0x00000000, 0x98405278, 0xc0c07c80,
+ 0xc0007c00, 0x00000000, 0x984052e0, 0xc0006952, 0xc80000f8, 0xc1000000, 0x472ce000, 0x8400023a,
+ 0xc0c00000, 0xc78e0020, 0xc1c00002, 0x69cc8000, 0xc78f0020, 0x69cce000, 0x711c8000, 0xc000f41a,
+ 0xcfc000f8, 0xc1c00000, 0xc7dc4050, 0x581cc000, 0xcb0000f8, 0x00000000, 0x00000000, 0x76d16000,
+ 0x7d008000, 0x77118000, 0x732d8000, 0xcf0000f8, 0xc000691a, 0xcec000f8, 0x80000180, 0x5ea80000,
+ 0xc40c00fa, 0xc2400000, 0x580c0004, 0xca400038, 0x58cc0040, 0xc1c00000, 0x580c0004, 0xc9c00038,
+ 0x9c400000, 0x00000000, 0x00000000, 0x725d2000, 0x62406028, 0x84000032, 0xc9cc00f8, 0x00000000,
+ 0x00000000, 0x411c8000, 0x8000ffd0, 0xc1400000, 0xc7970020, 0x6f4e0010, 0x5de80000, 0xc74c00fa,
+ 0xc7960022, 0xc1c00000, 0xc4dd0038, 0x45d0e000, 0x88000048, 0xc1c00000, 0xc4dc0038, 0x451ce000,
+ 0x88000050, 0x9c400000, 0x00000000, 0x00000000, 0x00000000, 0xc1c00002, 0x9c400000, 0x69d4e000,
+ 0x7dc0e000, 0x76dd6000, 0x9c400000, 0xc1c00002, 0x69d4e000, 0x72dd6000, 0xc0004028, 0xcbc000f8,
+ 0xc000691c, 0xcb8000f8, 0xa7c0b738, 0x00000000, 0x5df80000, 0x8400b720, 0xc1c00002, 0xc000e070,
+ 0xcdc00000, 0x8000b700, 0xdcbc00f9, 0xdcb800f8, 0xdd3400f9, 0xc2400040, 0xc000401e, 0xd08000f8,
+ 0xc000690c, 0xc8c000f9, 0xc90000f8, 0xc1c00000, 0x60c18000, 0x7724e000, 0x84000052, 0x61018000,
+ 0x7724e000, 0x84000032, 0x98406158, 0x00000000, 0x00000000, 0x00000000, 0x8000ff90, 0x5b300040,
+ 0xc2c09400, 0x6f1c6000, 0x42dd6000, 0xc2809800, 0x429d4000, 0x58340022, 0xcf0000f8, 0x582c0008,
+ 0xcf8000f8, 0xc000690c, 0xc1c00000, 0xc71ca000, 0x401c0000, 0xc8c000f8, 0xc2000002, 0x6a30e000,
+ 0x70dc6000, 0xccc000f8, 0x58340008, 0xc8c000f9, 0xc90000f9, 0xc94000f9, 0x582c0000, 0xccc000f9,
+ 0xcd0000f9, 0xcd4000f9, 0x58340010, 0xc9c000f9, 0xc8c000f9, 0xc90000f9, 0xc94000f9, 0xc98000f9,
+ 0xc84000f9, 0xc88000f9, 0x58280000, 0xcdc000f9, 0xccc000f9, 0xcd0000f9, 0xcd4000f9, 0xcd8000f9,
+ 0xcc4000f9, 0xcc8000f9, 0xc1c00000, 0x5828000e, 0xc9c3e000, 0x00000000, 0x00000000, 0x5ddc0002,
+ 0x8400026a, 0xc000401a, 0xc9c000f8, 0x00000000, 0xc000f41a, 0xcdc000f8, 0xc000691e, 0xc88000f8,
+ 0xc0006908, 0xc8c000f8, 0xc1804c00, 0xc1000100, 0xa9440028, 0xc0004056, 0xc9800078, 0x6d102010,
+ 0x00000000, 0x6d1c2010, 0x5ddc0004, 0x449ce000, 0x88000150, 0x418c0000, 0x58000000, 0xc943e000,
+ 0x58cc0004, 0x450ce000, 0xc1c00000, 0xc5cc00fe, 0xa5400110, 0xc1000000, 0x58000002, 0xc90000e0,
+ 0xc1c00000, 0xc0004022, 0xc9c20008, 0x5828000e, 0xcd0000e0, 0x411ce000, 0xc1400000, 0xdc941078,
+ 0x7d40a000, 0x75d4e000, 0xc1400000, 0xdc961078, 0x71d4e000, 0x58280004, 0xcdc000e0, 0x5828000e,
+ 0xc1fe0002, 0xcdc3ff00, 0x5828000e, 0xc1fc0000, 0xcdc3de00, 0x58340020, 0xc1c00000, 0xcdc000f8,
+ 0xc0006908, 0xccc000f8, 0x58880002, 0xc000691e, 0xcc8000f8, 0x80000130, 0xc0c0b600, 0x6f9c6000,
+ 0x40dc6000, 0x580c0004, 0xc90000f8, 0x5828000e, 0xc1fc0002, 0xcdc3de00, 0x58340020, 0xc1c00002,
+ 0xcdc000f8, 0x59100002, 0x580c0004, 0xcd0000f8, 0x800000b8, 0xc0c00000, 0xc0004022, 0xc8c20008,
+ 0xc1000000, 0x5828000e, 0xc90000e0, 0x5828000e, 0xc1fc0000, 0xcdc3de00, 0x58340020, 0xc1c00000,
+ 0xcdc000f8, 0x410ce000, 0xc1400000, 0xdc941078, 0x7d40a000, 0x75d4e000, 0xc1400000, 0xdc961078,
+ 0x71d4e000, 0x58280004, 0xcdc000e0, 0x94000000, 0xc1c00002, 0xc000691c, 0xcdc000f8, 0xd87800f8,
+ 0xc3800000, 0x580c7400, 0xca4000f9, 0xca0000f8, 0xc3400000, 0xc3c00000, 0xc67c0008, 0x5dfc0004,
+ 0x88000480, 0xc639c008, 0xc674a028, 0xc0c00000, 0xc64d6030, 0xc000ea10, 0xc3000000, 0xcb3c0070,
+ 0x6cdc8000, 0x41cce000, 0x431d8000, 0x5b304000, 0x6faca000, 0x5aec7c00, 0xc0c00000, 0xc0000000,
+ 0xc8f00038, 0x6f686000, 0x5aa89c00, 0x5ccc0002, 0xccf00038, 0xc1000000, 0xc6128018, 0x5dd00000,
+ 0x840000f2, 0xc1800000, 0xc0800000, 0xc61a0018, 0xc60b0038, 0xc1c40002, 0x419cc000, 0x6d9c4010,
+ 0x429c0000, 0xc94000f8, 0xc1c00000, 0xc59c0308, 0x695ca000, 0x6d570010, 0x59980002, 0x6c9c4010,
+ 0x431c0000, 0xc1c00006, 0x749c2000, 0x5dc40000, 0xcd40183a, 0x5dc40002, 0xcd40103a, 0x5dc40004,
+ 0xcd40083a, 0x5dc40006, 0xcd40003a, 0x58880002, 0x5d100002, 0x8400ff50, 0xa61a00e8, 0xc000401a,
+ 0xc9c000f8, 0x00000000, 0xc000f41a, 0xcdc000f8, 0x5828000a, 0xc90000f8, 0x5828000c, 0xc94000f8,
+ 0xc0000000, 0xc1c00000, 0xc5d41f00, 0xcd5000f8, 0xc1000002, 0x58280008, 0xc94000f8, 0x5df40040,
+ 0xc0006912, 0x44100004, 0xc98000f8, 0x6934e000, 0x7dc0e000, 0x759cc000, 0xcd8000f8, 0xa9440022,
+ 0xc1b00002, 0x6994c000, 0xd9b000f8, 0x5ccc0000, 0x840001e0, 0x6fcca000, 0x58cc7d80, 0x580c0006,
+ 0xc90000f8, 0xc1400000, 0xc615a000, 0x59100002, 0x580c0006, 0xcd0000f8, 0xc1c00000, 0x7d40a000,
+ 0xc55c0000, 0x582c0024, 0xcdc000f8, 0xa61a0168, 0x7f80e000, 0xc5f80000, 0x6faca000, 0x5aec7c00,
+ 0x582c0024, 0xc94000f8, 0x580c0004, 0xc98000f8, 0x5dd40002, 0x8400011a, 0x5dd00080, 0x8800007a,
+ 0xc000ea28, 0xc1d2007e, 0xcdfd2928, 0xc000ea28, 0xc1d00002, 0xcdfd0800, 0x5dd0007e, 0xc000ea28,
+ 0x6ddd2000, 0xcdfd2928, 0xc000ea28, 0xc1d00002, 0xcdfd0800, 0x80000038, 0xc000ea28, 0x6d1d2000,
+ 0xcdfd2928, 0xc000ea28, 0xc1d00002, 0xcdfd0800, 0x583c6948, 0xc9c000f8, 0x00000000, 0x00000000,
+ 0x41d0e000, 0xcdc000f8, 0x4590c000, 0x580c0004, 0xcd8000f8, 0x580c0006, 0xc1c00000, 0xcdc000f8,
+ 0xc0006902, 0xc8c000f8, 0x00000000, 0x00000000, 0x58cc0004, 0xc1c00200, 0x45cce000, 0xc1c00000,
+ 0xc5cc00fe, 0xccc000f8, 0xc000f01e, 0xc1d00002, 0xcdc10800, 0xdf8400f8, 0x9c400000, 0x00000000,
+ 0x00000000, 0x00000000, 0xc0006904, 0xc94000f8, 0xab68008a, 0x00000000, 0x58147200, 0xccc000f9,
+ 0xcd0000f9, 0xc000f016, 0xc1d00002, 0xcdc10800, 0x59540004, 0xc1c00200, 0x45d4e000, 0xc1c00000,
+ 0xc5d400fe, 0x9c400000, 0xc0006904, 0xcd4000f8, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x8000ff60, 0xc0006906, 0xc94000f8, 0xab6a008a, 0x00000000, 0x58147400, 0xccc000f9, 0xcd0000f9,
+ 0xc000f404, 0xc1d00002, 0xcdc10800, 0x59540004, 0xc1c00200, 0x45d4e000, 0xc1c00000, 0xc5d400fe,
+ 0x9c400000, 0xc0006906, 0xcd4000f8, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x8000ff60,
+ 0xc08000a0, 0x74d0c000, 0x84000090, 0x78d0c000, 0x8400006a, 0x61800018, 0x6180e008, 0x441cc000,
+ 0x84000060, 0x5d940000, 0x84000050, 0x60c04008, 0xa48a0040, 0x9c400000, 0x61004008, 0x58880040,
+ 0x00000000, 0xa5400018, 0x00000000, 0xc0800080, 0x9c400000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0xc000f412, 0xc9c000f8, 0xc1800000, 0xc0800000, 0xa5c00580,
+ 0xc5d82028, 0xc1c00002, 0xc000691c, 0xcdc000f8, 0x6d886000, 0x59089800, 0x5810000e, 0xc9c3c000,
+ 0x59489400, 0xd9b800f8, 0xa5c004ca, 0x58140008, 0xc98000f8, 0xc0c07b00, 0xc0800000, 0x6d9ca000,
+ 0x40dc6000, 0xd9b800f8, 0x580c0002, 0xc8808000, 0x00000000, 0x00000000, 0xa480004a, 0x580c0004,
+ 0xc98000f8, 0x58140002, 0xc88000f8, 0x00000000, 0x00000000, 0x4498e000, 0x84000110, 0xc1c00000,
+ 0x580c0002, 0xc9c04000, 0x00000000, 0x00000000, 0xa5c0004a, 0x580c0006, 0xc98000f8, 0x58140004,
+ 0xc88000f8, 0x00000000, 0x00000000, 0x4498e000, 0x840000a0, 0xc0800000, 0x58100002, 0xc8800078,
+ 0x580c001e, 0xc94000f8, 0xc1800000, 0x580c0002, 0xc9810038, 0x40944000, 0xa4be0052, 0xc1400000,
+ 0x4498e000, 0x88000118, 0x580c0002, 0xc940e000, 0x00000000, 0x00000000, 0xa54000ca, 0xc1c00000,
+ 0x00000000, 0x00000000, 0x00000000, 0xdf9400f8, 0x00000000, 0x00000000, 0xc1800000, 0xc5582000,
+ 0xa5400042, 0xc000fb64, 0xc1c00002, 0xcdd80000, 0xc000facc, 0xc1c40002, 0xcdd84200, 0x800002a0,
+ 0xc000fb64, 0xc1c20002, 0xcdd82100, 0xc000facc, 0xc1c60002, 0xcdd86300, 0x80000268, 0x580c0002,
+ 0xc9c10038, 0x00000000, 0x00000000, 0x589c0000, 0xc000401a, 0xc9c000f8, 0x00000000, 0xc000f41a,
+ 0xcdc000f8, 0xc000690a, 0xc94000f8, 0xc0c04c00, 0xc1800100, 0xa9440028, 0xc0004056, 0xc8c00078,
+ 0x6d982010, 0x00000000, 0x40d46000, 0x59540004, 0x4594e000, 0xc1c00000, 0xc5d400fe, 0xc000690a,
+ 0xcd4000f8, 0xc1400000, 0x5810000e, 0xc94000e0, 0xa9440022, 0xc1800000, 0xc4c000f8, 0xc98000f8,
+ 0x580c0002, 0xcd4000e0, 0xc4980078, 0xdf9400f8, 0xc1f80006, 0xc5db9c18, 0x00000000, 0xc5581508,
+ 0xc4c000f8, 0xcd8000f8, 0xc000e408, 0xc1c00002, 0xcdc000f8, 0xc000691e, 0xc98000f8, 0x5810000e,
+ 0xc1fe0000, 0xcdc3ff00, 0x5d980002, 0xc000691e, 0xcd8000f8, 0xc1800000, 0x58100002, 0xc9800078,
+ 0x6d486000, 0x5888b600, 0x58080006, 0xc9c000f8, 0x00000000, 0x00000000, 0x419cc000, 0x58080006,
+ 0xcd8000f8, 0xc1800000, 0xc5582000, 0xa540002a, 0xc000fb60, 0xc1c40002, 0xcdd84200, 0x80000020,
+ 0xc000fb60, 0xc1c60002, 0xcdd86300, 0xdf9400f8, 0xc1800002, 0x00000000, 0x00000000, 0x5dd40040,
+ 0xc000690e, 0x44180004, 0xc88000f8, 0x6994e000, 0x7dc0e000, 0x749c4000, 0xcc8000f8, 0x9c400000,
+ 0x00000000, 0x00000000, 0x00000000, 0xc000403c, 0xc90000f8, 0xc1400000, 0xc4d60078, 0x4550e000,
+ 0x8400003a, 0xcd4000f8, 0xc1c00000, 0xd9c400f9, 0xd9440078, 0xc1c00006, 0xd9c400f9, 0xc3c00000,
+ 0xc4fc8018, 0x5bfc0008, 0xc3800000, 0x6fb44000, 0x5b744d08, 0xc3000000, 0x58340006, 0xcb020038,
+ 0xc2c00000, 0xc2800000, 0x5f300002, 0x84000080, 0x58340006, 0xcac00078, 0x58340002, 0xca800078,
+ 0xc2000000, 0x58340002, 0xca020078, 0x42e92000, 0x00000000, 0x4624e000, 0xc62400fc, 0x58340000,
+ 0xcb030038, 0x58340006, 0xce400078, 0x58340006, 0x6f1e0000, 0xcdc21038, 0x5bb80002, 0x47bce000,
+ 0x8800ff1a, 0x8000a078, 0x00000000, 0x00000000, 0x00000000, 0xa94ea058, 0xc0006954, 0xcbc000f8,
+ 0xc3800000, 0xdd790038, 0x5ffc0002, 0xc7bc00fc, 0xc0006954, 0xcfc000f8, 0x8800a010, 0xc0004044,
+ 0xcbc000f8, 0xc0004014, 0xcb8000f8, 0x5dfc0000, 0x84009fe2, 0x6f9d0010, 0x739da000, 0x6f9e0010,
+ 0x735da000, 0x6f9f0010, 0x735da000, 0xc1c0001e, 0x775da000, 0xc000e440, 0xcf4000f8, 0x80009f88,
+ 0x00000000, 0x00000000, 0x00000000,};
+
+static u32 vr9_e1_fw_data[] = {
+};
+
+#endif
diff --git a/drivers/net/lantiq_ptm/ltqmips_ptm_ppe_common.h b/drivers/net/lantiq_ptm/ltqmips_ptm_ppe_common.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/lantiq_ptm/ltqmips_ptm_ppe_common.h
@@ -0,0 +1,338 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_ptm_ppe_common.h
+** PROJECT      : UEIP
+** MODULES      : PTM
+**
+** DATE         : 7 Jul 2009
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : PTM driver header file (PPE register for all platform)
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 07 JUL 2009  Xu Liang        Init Version
+*******************************************************************************/
+
+
+
+#ifndef IFXMIPS_PTM_PPE_COMMON_H
+#define IFXMIPS_PTM_PPE_COMMON_H
+
+
+
+#include "ltqmips_ptm_ppe_vr9.h"
+
+/*
+ *  Code/Data Memory (CDM) Interface Configuration Register
+ */
+#define CDM_CFG                         PPE_REG_ADDR(0x0100)
+
+#define CDM_CFG_RAM1                    GET_BITS(*CDM_CFG, 3, 2)
+#define CDM_CFG_RAM0                    (*CDM_CFG & (1 << 1))
+
+#define CDM_CFG_RAM1_SET(value)         SET_BITS(0, 3, 2, value)
+#define CDM_CFG_RAM0_SET(value)         ((value) ? (1 << 1) : 0)
+
+/*
+ *  QSB Internal Cell Delay Variation Register
+ */
+#define QSB_ICDV                        QSB_CONF_REG_ADDR(0x0007)
+
+#define QSB_ICDV_TAU                    GET_BITS(*QSB_ICDV, 5, 0)
+
+#define QSB_ICDV_TAU_SET(value)         SET_BITS(0, 5, 0, value)
+
+/*
+ *  QSB Scheduler Burst Limit Register
+ */
+#define QSB_SBL                         QSB_CONF_REG_ADDR(0x0009)
+
+#define QSB_SBL_SBL                     GET_BITS(*QSB_SBL, 3, 0)
+
+#define QSB_SBL_SBL_SET(value)          SET_BITS(0, 3, 0, value)
+
+/*
+ *  QSB Configuration Register
+ */
+#define QSB_CFG                         QSB_CONF_REG_ADDR(0x000A)
+
+#define QSB_CFG_TSTEPC                  GET_BITS(*QSB_CFG, 1, 0)
+
+#define QSB_CFG_TSTEPC_SET(value)       SET_BITS(0, 1, 0, value)
+
+/*
+ *  QSB RAM Transfer Table Register
+ */
+#define QSB_RTM                         QSB_CONF_REG_ADDR(0x000B)
+
+#define QSB_RTM_DM                      (*QSB_RTM)
+
+#define QSB_RTM_DM_SET(value)           ((value) & 0xFFFFFFFF)
+
+/*
+ *  QSB RAM Transfer Data Register
+ */
+#define QSB_RTD                         QSB_CONF_REG_ADDR(0x000C)
+
+#define QSB_RTD_TTV                     (*QSB_RTD)
+
+#define QSB_RTD_TTV_SET(value)          ((value) & 0xFFFFFFFF)
+
+/*
+ *  QSB RAM Access Register
+ */
+#define QSB_RAMAC                       QSB_CONF_REG_ADDR(0x000D)
+
+#define QSB_RAMAC_RW                    (*QSB_RAMAC & (1 << 31))
+#define QSB_RAMAC_TSEL                  GET_BITS(*QSB_RAMAC, 27, 24)
+#define QSB_RAMAC_LH                    (*QSB_RAMAC & (1 << 16))
+#define QSB_RAMAC_TESEL                 GET_BITS(*QSB_RAMAC, 9, 0)
+
+#define QSB_RAMAC_RW_SET(value)         ((value) ? (1 << 31) : 0)
+#define QSB_RAMAC_TSEL_SET(value)       SET_BITS(0, 27, 24, value)
+#define QSB_RAMAC_LH_SET(value)         ((value) ? (1 << 16) : 0)
+#define QSB_RAMAC_TESEL_SET(value)      SET_BITS(0, 9, 0, value)
+
+/*
+ *  QSB Queue Scheduling and Shaping Definitions
+ */
+#define QSB_WFQ_NONUBR_MAX              0x3f00
+#define QSB_WFQ_UBR_BYPASS              0x3fff
+#define QSB_TP_TS_MAX                   65472
+#define QSB_TAUS_MAX                    64512
+#define QSB_GCR_MIN                     18
+
+/*
+ *  QSB Constant
+ */
+#define QSB_RAMAC_RW_READ               0
+#define QSB_RAMAC_RW_WRITE              1
+
+#define QSB_RAMAC_TSEL_QPT              0x01
+#define QSB_RAMAC_TSEL_SCT              0x02
+#define QSB_RAMAC_TSEL_SPT              0x03
+#define QSB_RAMAC_TSEL_VBR              0x08
+
+#define QSB_RAMAC_LH_LOW                0
+#define QSB_RAMAC_LH_HIGH               1
+
+#define QSB_QPT_SET_MASK                0x0
+#define QSB_QVPT_SET_MASK               0x0
+#define QSB_SET_SCT_MASK                0x0
+#define QSB_SET_SPT_MASK                0x0
+#define QSB_SET_SPT_SBVALID_MASK        0x7FFFFFFF
+
+#define QSB_SPT_SBV_VALID               (1 << 31)
+#define QSB_SPT_PN_SET(value)           (((value) & 0x01) ? (1 << 16) : 0)
+#define QSB_SPT_INTRATE_SET(value)      SET_BITS(0, 13, 0, value)
+
+/*
+ *  QSB Queue Parameter Table Entry and Queue VBR Parameter Table Entry
+ */
+#if defined(__BIG_ENDIAN)
+    union qsb_queue_parameter_table {
+        struct {
+            unsigned int    res1    :1;
+            unsigned int    vbr     :1;
+            unsigned int    wfqf    :14;
+            unsigned int    tp      :16;
+        }               bit;
+        u32             dword;
+    };
+
+    union qsb_queue_vbr_parameter_table {
+        struct {
+            unsigned int    taus    :16;
+            unsigned int    ts      :16;
+        }               bit;
+        u32             dword;
+    };
+#else
+    union qsb_queue_parameter_table {
+        struct {
+            unsigned int    tp      :16;
+            unsigned int    wfqf    :14;
+            unsigned int    vbr     :1;
+            unsigned int    res1    :1;
+        }               bit;
+        u32             dword;
+    };
+
+    union qsb_queue_vbr_parameter_table {
+        struct {
+            unsigned int    ts      :16;
+            unsigned int    taus    :16;
+        }               bit;
+        u32             dword;
+    };
+#endif  //  defined(__BIG_ENDIAN)
+
+/*
+ *  Mailbox IGU0 Registers
+ */
+#define MBOX_IGU0_ISRS                  PPE_REG_ADDR(0x0200)
+#define MBOX_IGU0_ISRC                  PPE_REG_ADDR(0x0201)
+#define MBOX_IGU0_ISR                   PPE_REG_ADDR(0x0202)
+#define MBOX_IGU0_IER                   PPE_REG_ADDR(0x0203)
+
+#define MBOX_IGU0_ISRS_SET(n)           (1 << (n))
+#define MBOX_IGU0_ISRC_CLEAR(n)         (1 << (n))
+#define MBOX_IGU0_ISR_ISR(n)            (*MBOX_IGU0_ISR & (1 << (n)))
+#define MBOX_IGU0_IER_EN(n)             (*MBOX_IGU0_IER & (1 << (n)))
+#define MBOX_IGU0_IER_EN_SET(n)         (1 << (n))
+
+/*
+ *  Mailbox IGU1 Registers
+ */
+#define MBOX_IGU1_ISRS                  PPE_REG_ADDR(0x0204)
+#define MBOX_IGU1_ISRC                  PPE_REG_ADDR(0x0205)
+#define MBOX_IGU1_ISR                   PPE_REG_ADDR(0x0206)
+#define MBOX_IGU1_IER                   PPE_REG_ADDR(0x0207)
+
+#define MBOX_IGU1_ISRS_SET(n)           (1 << (n))
+#define MBOX_IGU1_ISRC_CLEAR(n)         (1 << (n))
+#define MBOX_IGU1_ISR_ISR(n)            (*MBOX_IGU1_ISR & (1 << (n)))
+#define MBOX_IGU1_IER_EN(n)             (*MBOX_IGU1_IER & (1 << (n)))
+#define MBOX_IGU1_IER_EN_SET(n)         (1 << (n))
+
+/*
+ *  Mailbox IGU3 Registers
+ */
+#define MBOX_IGU3_ISRS                  PPE_REG_ADDR(0x0214)
+#define MBOX_IGU3_ISRC                  PPE_REG_ADDR(0x0215)
+#define MBOX_IGU3_ISR                   PPE_REG_ADDR(0x0216)
+#define MBOX_IGU3_IER                   PPE_REG_ADDR(0x0217)
+
+#define MBOX_IGU3_ISRS_SET(n)           (1 << (n))
+#define MBOX_IGU3_ISRC_CLEAR(n)         (1 << (n))
+#define MBOX_IGU3_ISR_ISR(n)            (*MBOX_IGU3_ISR & (1 << (n)))
+#define MBOX_IGU3_IER_EN(n)             (*MBOX_IGU3_IER & (1 << (n)))
+#define MBOX_IGU3_IER_EN_SET(n)         (1 << (n))
+
+/*
+ *  RTHA/TTHA Registers
+ */
+#define RFBI_CFG                        PPE_REG_ADDR(0x0400)
+#define RBA_CFG0                        PPE_REG_ADDR(0x0404)
+#define RBA_CFG1                        PPE_REG_ADDR(0x0405)
+#define RCA_CFG0                        PPE_REG_ADDR(0x0408)
+#define RCA_CFG1                        PPE_REG_ADDR(0x0409)
+#define RDES_CFG0                       PPE_REG_ADDR(0x040C)
+#define RDES_CFG1                       PPE_REG_ADDR(0x040D)
+#define SFSM_STATE0                     PPE_REG_ADDR(0x0410)
+#define SFSM_STATE1                     PPE_REG_ADDR(0x0411)
+#define SFSM_DBA0                       PPE_REG_ADDR(0x0412)
+#define SFSM_DBA1                       PPE_REG_ADDR(0x0413)
+#define SFSM_CBA0                       PPE_REG_ADDR(0x0414)
+#define SFSM_CBA1                       PPE_REG_ADDR(0x0415)
+#define SFSM_CFG0                       PPE_REG_ADDR(0x0416)
+#define SFSM_CFG1                       PPE_REG_ADDR(0x0417)
+#define SFSM_PGCNT0                     PPE_REG_ADDR(0x041C)
+#define SFSM_PGCNT1                     PPE_REG_ADDR(0x041D)
+#define FFSM_DBA0                       PPE_REG_ADDR(0x0508)
+#define FFSM_DBA1                       PPE_REG_ADDR(0x0509)
+#define FFSM_CFG0                       PPE_REG_ADDR(0x050A)
+#define FFSM_CFG1                       PPE_REG_ADDR(0x050B)
+#define FFSM_IDLE_HEAD_BC0              PPE_REG_ADDR(0x050E)
+#define FFSM_IDLE_HEAD_BC1              PPE_REG_ADDR(0x050F)
+#define FFSM_PGCNT0                     PPE_REG_ADDR(0x0514)
+#define FFSM_PGCNT1                     PPE_REG_ADDR(0x0515)
+
+/*
+ *  PPE TC Logic Registers (partial)
+ */
+#define DREG_A_VERSION                  PPE_REG_ADDR(0x0D00)
+#define DREG_A_CFG                      PPE_REG_ADDR(0x0D01)
+#define DREG_AT_CTRL                    PPE_REG_ADDR(0x0D02)
+#define DREG_AT_CB_CFG0                 PPE_REG_ADDR(0x0D03)
+#define DREG_AT_CB_CFG1                 PPE_REG_ADDR(0x0D04)
+#define DREG_AR_CTRL                    PPE_REG_ADDR(0x0D08)
+#define DREG_AR_CB_CFG0                 PPE_REG_ADDR(0x0D09)
+#define DREG_AR_CB_CFG1                 PPE_REG_ADDR(0x0D0A)
+#define DREG_A_UTPCFG                   PPE_REG_ADDR(0x0D0E)
+#define DREG_A_STATUS                   PPE_REG_ADDR(0x0D0F)
+#define DREG_AT_CFG0                    PPE_REG_ADDR(0x0D20)
+#define DREG_AT_CFG1                    PPE_REG_ADDR(0x0D21)
+#define DREG_AT_FB_SIZE0                PPE_REG_ADDR(0x0D22)
+#define DREG_AT_FB_SIZE1                PPE_REG_ADDR(0x0D23)
+#define DREG_AT_CELL0                   PPE_REG_ADDR(0x0D24)
+#define DREG_AT_CELL1                   PPE_REG_ADDR(0x0D25)
+#define DREG_AT_IDLE_CNT0               PPE_REG_ADDR(0x0D26)
+#define DREG_AT_IDLE_CNT1               PPE_REG_ADDR(0x0D27)
+#define DREG_AT_IDLE0                   PPE_REG_ADDR(0x0D28)
+#define DREG_AT_IDLE1                   PPE_REG_ADDR(0x0D29)
+#define DREG_AR_CFG0                    PPE_REG_ADDR(0x0D60)
+#define DREG_AR_CFG1                    PPE_REG_ADDR(0x0D61)
+#define DREG_AR_CELL0                   PPE_REG_ADDR(0x0D68)
+#define DREG_AR_CELL1                   PPE_REG_ADDR(0x0D69)
+#define DREG_AR_IDLE_CNT0               PPE_REG_ADDR(0x0D6A)
+#define DREG_AR_IDLE_CNT1               PPE_REG_ADDR(0x0D6B)
+#define DREG_AR_AIIDLE_CNT0             PPE_REG_ADDR(0x0D6C)
+#define DREG_AR_AIIDLE_CNT1             PPE_REG_ADDR(0x0D6D)
+#define DREG_AR_BE_CNT0                 PPE_REG_ADDR(0x0D6E)
+#define DREG_AR_BE_CNT1                 PPE_REG_ADDR(0x0D6F)
+#define DREG_AR_HEC_CNT0                PPE_REG_ADDR(0x0D70)
+#define DREG_AR_HEC_CNT1                PPE_REG_ADDR(0x0D71)
+#define DREG_AR_IDLE0                   PPE_REG_ADDR(0x0D74)
+#define DREG_AR_IDLE1                   PPE_REG_ADDR(0x0D75)
+#define DREG_AR_CERRN_CNT0              PPE_REG_ADDR(0x0DA0)
+#define DREG_AR_CERRN_CNT1              PPE_REG_ADDR(0x0DA1)
+#define DREG_AR_CERRNP_CNT0             PPE_REG_ADDR(0x0DA2)
+#define DREG_AR_CERRNP_CNT1             PPE_REG_ADDR(0x0DA3)
+#define DREG_AR_CVN_CNT0                PPE_REG_ADDR(0x0DA4)
+#define DREG_AR_CVN_CNT1                PPE_REG_ADDR(0x0DA5)
+#define DREG_AR_CVNP_CNT0               PPE_REG_ADDR(0x0DA6)
+#define DREG_AR_CVNP_CNT1               PPE_REG_ADDR(0x0DA7)
+#define DREG_B0_LADR                    PPE_REG_ADDR(0x0DA8)
+#define DREG_B1_LADR                    PPE_REG_ADDR(0x0DA9)
+
+/*
+ *  Bits Operation
+  */
+#define IFX_REG_R32(_r)                    __raw_readl((volatile unsigned int *)(_r))
+#define IFX_REG_W32(_v, _r)               __raw_writel((_v), (volatile unsigned int *)(_r))
+#define IFX_REG_W32_MASK(_clr, _set, _r)   IFX_REG_W32((IFX_REG_R32((_r)) & ~(_clr)) | (_set), (_r))
+
+#define GET_BITS(x, msb, lsb)               \
+      (((x) >> (lsb)) & ((1 << ((msb) + 1 - (lsb))) - 1))
+#define SET_BITS(x, msb, lsb, value)        \
+	  (((x) & ~(((1 << ((msb) + 1)) - 1) ^ ((1 << (lsb)) - 1))) | (((value) & ((1 << (1 + (msb) - (lsb))) - 1)) << (lsb)))
+
+#define NUM_ENTITY(x)                           (sizeof(x) / sizeof(*(x)))
+
+/*
+ *  find first 1 from MSB in a 32-bit word
+ *  if all ZERO, return -1
+ *  e.g. 0x10000000 => 28
+ */
+static inline int clz(unsigned int x)
+{
+    __asm__ (
+    "       .set    push                                    \n"
+    "       .set    mips32                                  \n"
+    "       clz     %0, %1                                  \n"
+    "       .set    pop                                     \n"
+    : "=r" (x)
+    : "r" (x));
+
+    return 31 - (int)x;
+}
+
+static inline int
+ifx_drv_ver(char *buf, char *module, int major, int mid, int minor)
+{
+    return sprintf(buf, "Lantiq %s driver, version %d.%d.%d, (c) 2001-2013 Lantiq Deutschland GmbH\n",
+	            module, major, mid, minor);
+}
+
+
+
+#endif  //  IFXMIPS_PTM_PPE_COMMON_H
diff --git a/drivers/net/lantiq_ptm/ltqmips_ptm_ppe_vr9.h b/drivers/net/lantiq_ptm/ltqmips_ptm_ppe_vr9.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/lantiq_ptm/ltqmips_ptm_ppe_vr9.h
@@ -0,0 +1,207 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_ptm_ppe_vr9.h
+** PROJECT      : UEIP
+** MODULES      : PTM
+**
+** DATE         : 7 Jul 2009
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : PTM driver header file (PPE register for VR9)
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 07 JUL 2009  Xu Liang        Init Version
+*******************************************************************************/
+
+
+
+#ifndef IFXMIPS_PTM_PPE_VR9_H
+#define IFXMIPS_PTM_PPE_VR9_H
+
+
+
+/*
+ *  FPI Configuration Bus Register and Memory Address Mapping
+ */
+#define IFX_PPE                         (KSEG1 | 0x1E200000)
+#define PP32_DEBUG_REG_ADDR(i, x)       ((volatile unsigned int*)(IFX_PPE + (((x) + 0x000000 + (i) * 0x00010000) << 2)))
+#define CDM_CODE_MEMORY(i, x)           ((volatile unsigned int*)(IFX_PPE + (((x) + 0x001000 + (i) * 0x00010000) << 2)))
+#define CDM_DATA_MEMORY(i, x)           ((volatile unsigned int*)(IFX_PPE + (((x) + 0x004000 + (i) * 0x00010000) << 2)))
+#define SB_RAM0_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x008000) << 2)))
+#define SB_RAM1_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x009000) << 2)))
+#define SB_RAM2_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x00A000) << 2)))
+#define SB_RAM3_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x00B000) << 2)))
+#define PPE_REG_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x00D000) << 2)))
+#define QSB_CONF_REG_ADDR(x)            ((volatile unsigned int*)(IFX_PPE + (((x) + 0x00E000) << 2)))
+#define SB_RAM6_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x018000) << 2)))
+
+/*
+ *  DWORD-Length of Memory Blocks
+ */
+#define PP32_DEBUG_REG_DWLEN            0x0030
+#define CDM_CODE_MEMORYn_DWLEN(n)       ((n) == 0 ? 0x1000 : 0x0800)
+#define CDM_DATA_MEMORY_DWLEN           CDM_CODE_MEMORYn_DWLEN(1)
+#define SB_RAM0_DWLEN                   0x1000
+#define SB_RAM1_DWLEN                   0x1000
+#define SB_RAM2_DWLEN                   0x1000
+#define SB_RAM3_DWLEN                   0x1000
+#define SB_RAM6_DWLEN                   0x8000
+#define QSB_CONF_REG_DWLEN              0x0100
+
+/*
+ *  PP32 to FPI Address Mapping
+ */
+#define SB_BUFFER(__sb_addr)            ((volatile unsigned int *)((((__sb_addr) >= 0x0000) && ((__sb_addr) <= 0x1FFF)) ? PPE_REG_ADDR((__sb_addr)) :           \
+                                                                   (((__sb_addr) >= 0x2000) && ((__sb_addr) <= 0x2FFF)) ? SB_RAM0_ADDR((__sb_addr) - 0x2000) :  \
+                                                                   (((__sb_addr) >= 0x3000) && ((__sb_addr) <= 0x3FFF)) ? SB_RAM1_ADDR((__sb_addr) - 0x3000) :  \
+                                                                   (((__sb_addr) >= 0x4000) && ((__sb_addr) <= 0x4FFF)) ? SB_RAM2_ADDR((__sb_addr) - 0x4000) :  \
+                                                                   (((__sb_addr) >= 0x5000) && ((__sb_addr) <= 0x5FFF)) ? SB_RAM3_ADDR((__sb_addr) - 0x5000) :  \
+                                                                   (((__sb_addr) >= 0x7000) && ((__sb_addr) <= 0x7FFF)) ? PPE_REG_ADDR((__sb_addr) - 0x7000) :  \
+                                                                   (((__sb_addr) >= 0x8000) && ((__sb_addr) <= 0xFFFF)) ? SB_RAM6_ADDR((__sb_addr) - 0x8000) :  \
+                                                                0))
+
+/*
+ *  PP32 Debug Control Register
+ */
+#define NUM_OF_PP32                             2
+
+#define PP32_FREEZE                             PPE_REG_ADDR(0x0000)
+#define PP32_SRST                               PPE_REG_ADDR(0x0020)
+
+#define PP32_DBG_CTRL(n)                        PP32_DEBUG_REG_ADDR(n, 0x0000)
+
+#define DBG_CTRL_RESTART                        0
+#define DBG_CTRL_STOP                           1
+
+#define PP32_CTRL_CMD(n)                        PP32_DEBUG_REG_ADDR(n, 0x0B00)
+  #define PP32_CTRL_CMD_RESTART                 (1 << 0)
+  #define PP32_CTRL_CMD_STOP                    (1 << 1)
+  #define PP32_CTRL_CMD_STEP                    (1 << 2)
+  #define PP32_CTRL_CMD_BREAKOUT                (1 << 3)
+
+#define PP32_CTRL_OPT(n)                        PP32_DEBUG_REG_ADDR(n, 0x0C00)
+  #define PP32_CTRL_OPT_BREAKOUT_ON_STOP_ON     (3 << 0)
+  #define PP32_CTRL_OPT_BREAKOUT_ON_STOP_OFF    (2 << 0)
+  #define PP32_CTRL_OPT_BREAKOUT_ON_BREAKIN_ON  (3 << 2)
+  #define PP32_CTRL_OPT_BREAKOUT_ON_BREAKIN_OFF (2 << 2)
+  #define PP32_CTRL_OPT_STOP_ON_BREAKIN_ON      (3 << 4)
+  #define PP32_CTRL_OPT_STOP_ON_BREAKIN_OFF     (2 << 4)
+  #define PP32_CTRL_OPT_STOP_ON_BREAKPOINT_ON   (3 << 6)
+  #define PP32_CTRL_OPT_STOP_ON_BREAKPOINT_OFF  (2 << 6)
+  #define PP32_CTRL_OPT_BREAKOUT_ON_STOP(n)     (*PP32_CTRL_OPT(n) & (1 << 0))
+  #define PP32_CTRL_OPT_BREAKOUT_ON_BREAKIN(n)  (*PP32_CTRL_OPT(n) & (1 << 2))
+  #define PP32_CTRL_OPT_STOP_ON_BREAKIN(n)      (*PP32_CTRL_OPT(n) & (1 << 4))
+  #define PP32_CTRL_OPT_STOP_ON_BREAKPOINT(n)   (*PP32_CTRL_OPT(n) & (1 << 6))
+
+#define PP32_BRK_PC(n, i)                       PP32_DEBUG_REG_ADDR(n, 0x0900 + (i) * 2)
+#define PP32_BRK_PC_MASK(n, i)                  PP32_DEBUG_REG_ADDR(n, 0x0901 + (i) * 2)
+#define PP32_BRK_DATA_ADDR(n, i)                PP32_DEBUG_REG_ADDR(n, 0x0904 + (i) * 2)
+#define PP32_BRK_DATA_ADDR_MASK(n, i)           PP32_DEBUG_REG_ADDR(n, 0x0905 + (i) * 2)
+#define PP32_BRK_DATA_VALUE_RD(n, i)            PP32_DEBUG_REG_ADDR(n, 0x0908 + (i) * 2)
+#define PP32_BRK_DATA_VALUE_RD_MASK(n, i)       PP32_DEBUG_REG_ADDR(n, 0x0909 + (i) * 2)
+#define PP32_BRK_DATA_VALUE_WR(n, i)            PP32_DEBUG_REG_ADDR(n, 0x090C + (i) * 2)
+#define PP32_BRK_DATA_VALUE_WR_MASK(n, i)       PP32_DEBUG_REG_ADDR(n, 0x090D + (i) * 2)
+  #define PP32_BRK_CONTEXT_MASK(i)              (1 << (i))
+  #define PP32_BRK_CONTEXT_MASK_EN              (1 << 4)
+  #define PP32_BRK_COMPARE_GREATER_EQUAL        (1 << 5)    //  valid for break data value rd/wr only
+  #define PP32_BRK_COMPARE_LOWER_EQUAL          (1 << 6)
+  #define PP32_BRK_COMPARE_EN                   (1 << 7)
+
+#define PP32_BRK_TRIG(n)                        PP32_DEBUG_REG_ADDR(n, 0x0F00)
+  #define PP32_BRK_GRPi_PCn_ON(i, n)            ((3 << ((n) * 2)) << ((i) * 16))
+  #define PP32_BRK_GRPi_PCn_OFF(i, n)           ((2 << ((n) * 2)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_ADDRn_ON(i, n)     ((3 << ((n) * 2 + 4)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_ADDRn_OFF(i, n)    ((2 << ((n) * 2 + 4)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_VALUE_RDn_ON(i, n) ((3 << ((n) * 2 + 8)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_VALUE_RDn_OFF(i, n)((2 << ((n) * 2 + 8)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_VALUE_WRn_ON(i, n) ((3 << ((n) * 2 + 12)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_VALUE_WRn_OFF(i, n)((2 << ((n) * 2 + 12)) << ((i) * 16))
+  #define PP32_BRK_GRPi_PCn(k, i, n)            (*PP32_BRK_TRIG(k) & ((1 << ((n))) << ((i) * 8)))
+  #define PP32_BRK_GRPi_DATA_ADDRn(k, i, n)     (*PP32_BRK_TRIG(k) & ((1 << ((n) + 2)) << ((i) * 8)))
+  #define PP32_BRK_GRPi_DATA_VALUE_RDn(k, i, n) (*PP32_BRK_TRIG(k) & ((1 << ((n) + 4)) << ((i) * 8)))
+  #define PP32_BRK_GRPi_DATA_VALUE_WRn(k, i, n) (*PP32_BRK_TRIG(k) & ((1 << ((n) + 6)) << ((i) * 8)))
+
+#define PP32_CPU_STATUS(n)                      PP32_DEBUG_REG_ADDR(n, 0x0D00)
+#define PP32_HALT_STAT(n)                       PP32_CPU_STATUS(n)
+#define PP32_DBG_CUR_PC(n)                      PP32_CPU_STATUS(n)
+  #define PP32_CPU_USER_STOPPED(n)              (*PP32_CPU_STATUS(n) & (1 << 0))
+  #define PP32_CPU_USER_BREAKIN_RCV(n)          (*PP32_CPU_STATUS(n) & (1 << 1))
+  #define PP32_CPU_USER_BREAKPOINT_MET(n)       (*PP32_CPU_STATUS(n) & (1 << 2))
+  #define PP32_CPU_CUR_PC(n)                    (*PP32_CPU_STATUS(n) >> 16)
+
+#define PP32_BREAKPOINT_REASONS(n)              PP32_DEBUG_REG_ADDR(n, 0x0A00)
+  #define PP32_BRK_PC_MET(n, i)                 (*PP32_BREAKPOINT_REASONS(n) & (1 << (i)))
+  #define PP32_BRK_DATA_ADDR_MET(n, i)          (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) + 2)))
+  #define PP32_BRK_DATA_VALUE_RD_MET(n, i)      (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) + 4)))
+  #define PP32_BRK_DATA_VALUE_WR_MET(n, i)      (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) + 6)))
+  #define PP32_BRK_DATA_VALUE_RD_LO_EQ(n, i)    (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) * 2 + 8)))
+  #define PP32_BRK_DATA_VALUE_RD_GT_EQ(n, i)    (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) * 2 + 9)))
+  #define PP32_BRK_DATA_VALUE_WR_LO_EQ(n, i)    (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) * 2 + 12)))
+  #define PP32_BRK_DATA_VALUE_WR_GT_EQ(n, i)    (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) * 2 + 13)))
+  #define PP32_BRK_CUR_CONTEXT(n)               ((*PP32_BREAKPOINT_REASONS(n) >> 16) & 0x03)
+
+#define PP32_GP_REG_BASE(n)                     PP32_DEBUG_REG_ADDR(n, 0x0E00)
+#define PP32_GP_CONTEXTi_REGn(n, i, j)          PP32_DEBUG_REG_ADDR(n, 0x0E00 + (i) * 16 + (j))
+
+/*
+ *  SAR Registers
+ */
+#define SAR_MODE_CFG                    PPE_REG_ADDR(0x080A)
+#define SAR_RX_CMD_CNT                  PPE_REG_ADDR(0x080B)
+#define SAR_TX_CMD_CNT                  PPE_REG_ADDR(0x080C)
+#define SAR_RX_CTX_CFG                  PPE_REG_ADDR(0x080D)
+#define SAR_TX_CTX_CFG                  PPE_REG_ADDR(0x080E)
+#define SAR_TX_CMD_DONE_CNT             PPE_REG_ADDR(0x080F)
+#define SAR_POLY_CFG_SET0               PPE_REG_ADDR(0x0812)
+#define SAR_POLY_CFG_SET1               PPE_REG_ADDR(0x0813)
+#define SAR_POLY_CFG_SET2               PPE_REG_ADDR(0x0814)
+#define SAR_POLY_CFG_SET3               PPE_REG_ADDR(0x0815)
+#define SAR_CRC_SIZE_CFG                PPE_REG_ADDR(0x0816)
+
+/*
+ *  PDMA/EMA Registers
+ */
+#define PDMA_CFG                        PPE_REG_ADDR(0x0A00)
+#define PDMA_RX_CMDCNT                  PPE_REG_ADDR(0x0A01)
+#define PDMA_TX_CMDCNT                  PPE_REG_ADDR(0x0A02)
+#define PDMA_RX_FWDATACNT               PPE_REG_ADDR(0x0A03)
+#define PDMA_TX_FWDATACNT               PPE_REG_ADDR(0x0A04)
+#define PDMA_RX_CTX_CFG                 PPE_REG_ADDR(0x0A05)
+#define PDMA_TX_CTX_CFG                 PPE_REG_ADDR(0x0A06)
+#define PDMA_RX_MAX_LEN_REG             PPE_REG_ADDR(0x0A07)
+#define PDMA_RX_DELAY_CFG               PPE_REG_ADDR(0x0A08)
+#define PDMA_INT_FIFO_RD                PPE_REG_ADDR(0x0A09)
+#define PDMA_ISR                        PPE_REG_ADDR(0x0A0A)
+#define PDMA_IER                        PPE_REG_ADDR(0x0A0B)
+#define PDMA_SUBID                      PPE_REG_ADDR(0x0A0C)
+#define PDMA_BAR0                       PPE_REG_ADDR(0x0A0D)
+#define PDMA_BAR1                       PPE_REG_ADDR(0x0A0E)
+
+#define SAR_PDMA_RX_CMDBUF_CFG          PPE_REG_ADDR(0x0F00)
+#define SAR_PDMA_TX_CMDBUF_CFG          PPE_REG_ADDR(0x0F01)
+#define SAR_PDMA_RX_FW_CMDBUF_CFG       PPE_REG_ADDR(0x0F02)
+#define SAR_PDMA_TX_FW_CMDBUF_CFG       PPE_REG_ADDR(0x0F03)
+#define SAR_PDMA_RX_CMDBUF_STATUS       PPE_REG_ADDR(0x0F04)
+#define SAR_PDMA_TX_CMDBUF_STATUS       PPE_REG_ADDR(0x0F05)
+
+#define PDMA_ALIGNMENT                  32              //  same as Central DMA because of descriptor swap
+#define EMA_ALIGNMENT                   PDMA_ALIGNMENT
+
+#define INT_NUM_IM2_IRL24    (INT_NUM_IM2_IRL0 + 24)
+
+/*
+ *  Mailbox IGU1 Interrupt
+ */
+#define PPE_MAILBOX_IGU1_INT            INT_NUM_IM2_IRL24
+
+
+
+#endif  //  IFXMIPS_PTM_PPE_VR9_H
diff --git a/drivers/net/lantiq_ptm/ltqmips_ptm_test.c b/drivers/net/lantiq_ptm/ltqmips_ptm_test.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/lantiq_ptm/ltqmips_ptm_test.c
@@ -0,0 +1,944 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_ptm_vdsl.c
+** PROJECT      : UEIP
+** MODULES      : PTM
+**
+** DATE         : 7 Jul 2009
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : PTM driver common source file (core functions for VR9)
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 07 JUL 2009  Xu Liang        Init Version
+*******************************************************************************/
+
+
+
+#ifdef CONFIG_LTQ_PTM_TEST_PROC
+
+/*
+ * ####################################
+ *              Head File
+ * ####################################
+ */
+
+/*
+ *  Common Head File
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/etherdevice.h>
+
+/*
+ *  Chip Specific Head File
+ */
+#include <common_routines.h>
+#include <ltq_regs.h>
+#include "ltqmips_ptm_common.h"
+#include "ltqmips_ptm_ppe_common.h"
+
+
+
+/*
+ * ####################################
+ *              Definition
+ * ####################################
+ */
+
+
+
+/*
+ * ####################################
+ *             Declaration
+ * ####################################
+ */
+
+/*
+ *  Proc File Functions
+ */
+static inline void proc_file_create(void);
+static inline void proc_file_delete(void);
+
+/*
+ *  Proc Help Functions
+ */
+static int proc_write_mem(struct file *, const char *, unsigned long, void *);
+static int proc_read_pp32(char *, char **, off_t, int, int *, void *);
+static int proc_write_pp32(struct file *, const char *, unsigned long, void *);
+static int stricmp(const char *, const char *);
+static int strincmp(const char *, const char *, int);
+static int get_token(char **, char **, int *, int *);
+static int get_number(char **, int *, int);
+static inline void ignore_space(char **, int *);
+
+
+
+/*
+ * ####################################
+ *            Local Variable
+ * ####################################
+ */
+
+
+
+/*
+ * ####################################
+ *            Local Function
+ * ####################################
+ */
+
+static inline void proc_file_create(void)
+{
+    struct proc_dir_entry *res;
+
+    res = create_proc_entry("driver/ifx_ptm/mem",
+                            0,
+                            NULL);
+    if ( res != NULL )
+        res->write_proc = proc_write_mem;
+    else
+        printk("%s:%s:%d: failed to create proc mem!", __FILE__, __func__, __LINE__);
+
+    res = create_proc_entry("driver/ifx_ptm/pp32",
+                            0,
+                            NULL);
+    if ( res != NULL ) {
+        res->read_proc = proc_read_pp32;
+        res->write_proc = proc_write_pp32;
+    }
+    else
+        printk("%s:%s:%d: failed to create proc pp32!", __FILE__, __func__, __LINE__);
+}
+
+static inline void proc_file_delete(void)
+{
+    remove_proc_entry("driver/ifx_ptm/pp32", NULL);
+
+    remove_proc_entry("driver/ifx_ptm/mem", NULL);
+}
+
+static inline unsigned long sb_addr_to_fpi_addr_convert(unsigned long sb_addr)
+{
+#define PP32_SB_ADDR_END        0xFFFF
+
+    if ( sb_addr < PP32_SB_ADDR_END) {
+        return (unsigned long ) SB_BUFFER(sb_addr);
+    }
+    else {
+        return sb_addr;
+    }
+}
+
+static int proc_write_mem(struct file *file, const char *buf, unsigned long count, void *data)
+{
+    char *p1, *p2;
+    int len;
+    int colon;
+    unsigned long *p;
+    char local_buf[1024];
+    int i, n, l;
+
+    len = sizeof(local_buf) < count ? sizeof(local_buf) - 1 : count;
+    len = len - copy_from_user(local_buf, buf, len);
+    local_buf[len] = 0;
+
+    p1 = local_buf;
+    colon = 1;
+    while ( get_token(&p1, &p2, &len, &colon) )
+    {
+        if ( stricmp(p1, "w") == 0 || stricmp(p1, "write") == 0 || stricmp(p1, "r") == 0 || stricmp(p1, "read") == 0 )
+            break;
+
+        p1 = p2;
+        colon = 1;
+    }
+
+    if ( *p1 == 'w' )
+    {
+        ignore_space(&p2, &len);
+        p = (unsigned long *)get_number(&p2, &len, 1);
+        p = (unsigned long *)sb_addr_to_fpi_addr_convert( (unsigned long) p);
+
+        if ( (u32)p >= KSEG0 )
+            while ( 1 )
+            {
+                ignore_space(&p2, &len);
+                if ( !len || !((*p2 >= '0' && *p2 <= '9') || (*p2 >= 'a' && *p2 <= 'f') || (*p2 >= 'A' && *p2 <= 'F')) )
+                    break;
+
+                *p++ = (u32)get_number(&p2, &len, 1);
+            }
+    }
+    else if ( *p1 == 'r' )
+    {
+        ignore_space(&p2, &len);
+        p = (unsigned long *)get_number(&p2, &len, 1);
+        p = (unsigned long *)sb_addr_to_fpi_addr_convert( (unsigned long) p);
+
+        if ( (u32)p >= KSEG0 )
+        {
+            ignore_space(&p2, &len);
+            n = (int)get_number(&p2, &len, 0);
+            if ( n )
+            {
+                char str[32] = {0};
+                char *pch = str;
+                int k;
+                u32 data;
+                char c;
+
+                n += (l = ((int)p >> 2) & 0x03);
+                p = (unsigned long *)((u32)p & ~0x0F);
+                for ( i = 0; i < n; i++ )
+                {
+                    if ( (i & 0x03) == 0 )
+                    {
+                        printk("%08X:", (u32)p);
+                        pch = str;
+                    }
+                    if ( i < l )
+                    {
+                        printk("         ");
+                        sprintf(pch, "    ");
+                    }
+                    else
+                    {
+                        data = (u32)*p;
+                        printk(" %08X", data);
+                        for ( k = 0; k < 4; k++ )
+                        {
+                            c = ((char*)&data)[k];
+                            pch[k] = c < ' ' ? '.' : c;
+                        }
+                    }
+                    p++;
+                    pch += 4;
+                    if ( (i & 0x03) == 0x03 )
+                    {
+                        pch[0] = 0;
+                        printk(" ; %s\n", str);
+                    }
+                }
+                if ( (n & 0x03) != 0x00 )
+                {
+                    for ( k = 4 - (n & 0x03); k > 0; k-- )
+                        printk("         ");
+                    pch[0] = 0;
+                    printk(" ; %s\n", str);
+                }
+            }
+        }
+    }
+
+    return count;
+}
+
+#ifdef CONFIG_DANUBE
+
+static int proc_read_pp32(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    static const char *halt_stat[] = {
+        "reset",
+        "break in line",
+        "stop",
+        "step",
+        "code",
+        "data0",
+        "data1"
+    };
+    static const char *brk_src_data[] = {
+        "off",
+        "read",
+        "write",
+        "read/write",
+        "write_equal",
+        "N/A",
+        "N/A",
+        "N/A"
+    };
+    static const char *brk_src_code[] = {
+        "off",
+        "on"
+    };
+
+    int len = 0;
+    int cur_task;
+    int i, j;
+    int k;
+    unsigned long bit;
+
+    len += sprintf(page + off + len, "Task No %d, PC %04x\n", *PP32_DBG_TASK_NO & 0x03, *PP32_DBG_CUR_PC & 0xFFFF);
+
+    if ( !(*PP32_HALT_STAT & 0x01) )
+        len += sprintf(page + off + len, "  Halt State: Running\n");
+    else
+    {
+        len += sprintf(page + off + len, "  Halt State: Stopped");
+        k = 0;
+        for ( bit = 2, i = 0; bit <= (1 << 7); bit <<= 1, i++ )
+            if ( (*PP32_HALT_STAT & bit) )
+            {
+                if ( !k )
+                {
+                    len += sprintf(page + off + len, ", ");
+                    k++;
+                }
+                else
+                    len += sprintf(page + off + len, " | ");
+                len += sprintf(page + off + len, halt_stat[i]);
+            }
+
+        len += sprintf(page + off + len, "\n");
+
+        cur_task = *PP32_DBG_TASK_NO & 0x03;
+        len += sprintf(page + off + len, "General Purpose Register (Task %d):\n", cur_task);
+        for ( i = 0; i < 4; i++ )
+        {
+            for ( j = 0; j < 4; j++ )
+                len += sprintf(page + off + len, "   %2d: %08x", i + j * 4, *PP32_DBG_TASK_GPR(cur_task, i + j * 4));
+            len += sprintf(page + off + len, "\n");
+        }
+    }
+
+    len += sprintf(page + off + len, "  Break Src:  data1 - %s, data0 - %s, pc3 - %s, pc2 - %s, pc1 - %s, pc0 - %s\n",
+                                                    brk_src_data[(*PP32_BRK_SRC >> 11) & 0x07], brk_src_data[(*PP32_BRK_SRC >> 8) & 0x07], brk_src_code[(*PP32_BRK_SRC >> 3) & 0x01], brk_src_code[(*PP32_BRK_SRC >> 2) & 0x01], brk_src_code[(*PP32_BRK_SRC >> 1) & 0x01], brk_src_code[*PP32_BRK_SRC & 0x01]);
+
+    for ( i = 0; i < 4; i++ )
+        len += sprintf(page + off + len, "    pc%d:      %04x - %04x\n", i, *PP32_DBG_PC_MIN(i), *PP32_DBG_PC_MAX(i));
+
+    for ( i = 0; i < 2; i++ )
+        len += sprintf(page + off + len, "    data%d:    %04x - %04x (%08x)\n", i, *PP32_DBG_DATA_MIN(i), *PP32_DBG_DATA_MAX(i), *PP32_DBG_DATA_VAL(i));
+
+    *eof = 1;
+
+    return len;
+}
+
+static int proc_write_pp32(struct file *file, const char *buf, unsigned long count, void *data)
+{
+    char str[2048];
+    char *p;
+    int len, rlen;
+
+    int id;
+    u32 addr;
+    u32 cmd;
+
+    len = count < sizeof(str) ? count : sizeof(str) - 1;
+    rlen = len - copy_from_user(str, buf, len);
+    while ( rlen && str[rlen - 1] <= ' ' )
+        rlen--;
+    str[rlen] = 0;
+    for ( p = str; *p && *p <= ' '; p++, rlen-- );
+    if ( !*p )
+    {
+        return 0;
+    }
+
+    if ( stricmp(str, "start") == 0 )
+        *PP32_DBG_CTRL = DBG_CTRL_START_SET(1);
+    else if ( stricmp(str, "stop") == 0 )
+        *PP32_DBG_CTRL = DBG_CTRL_STOP_SET(1);
+    else if ( stricmp(str, "step") == 0 )
+        *PP32_DBG_CTRL = DBG_CTRL_STEP_SET(1);
+    else if ( strincmp(p, "pc", 2) == 0 && p[2] >= '0' && p[2] <= '3' && p[3] == ' ' )
+    {
+        id = (int)(p[2] - '0');
+        p += 4;
+        rlen -= 4;
+        *PP32_BRK_SRC &= ~PP32_BRK_SRC_PC(id);
+        if ( stricmp(p, "off") != 0 )
+        {
+            ignore_space(&p, &rlen);
+            *PP32_DBG_PC_MIN(id) = *PP32_DBG_PC_MAX(id) = get_number(&p, &rlen, 1);
+            ignore_space(&p, &rlen);
+            if ( rlen > 0 )
+            {
+                addr = get_number(&p, &rlen, 1);
+                if ( addr >= *PP32_DBG_PC_MIN(id) )
+                    *PP32_DBG_PC_MAX(id) = addr;
+                else
+                    *PP32_DBG_PC_MIN(id) = addr;
+            }
+            *PP32_BRK_SRC |= PP32_BRK_SRC_PC(id);
+        }
+    }
+    else if ( strincmp(p, "daddr", 5) == 0 && p[5] >= '0' && p[5] <= '1' && p[6] == ' ' )
+    {
+        id = (int)(p[5] - '0');
+        p += 7;
+        rlen -= 7;
+        *PP32_BRK_SRC &= ~PP32_BRK_SRC_DATA(id, 7);
+        if ( stricmp(p, "off") != 0 )
+        {
+            ignore_space(&p, &rlen);
+            *PP32_DBG_DATA_MIN(id) = *PP32_DBG_DATA_MAX(id) = get_number(&p, &rlen, 1);
+            cmd = 1;
+            ignore_space(&p, &rlen);
+            if ( rlen > 0 && ((*p >= '0' && *p <= '9') || (*p >= 'a' && *p <= 'f') || (*p >= 'A' && *p <= 'F')) )
+            {
+                addr = get_number(&p, &rlen, 1);
+                if ( addr >= *PP32_DBG_PC_MIN(id) )
+                    *PP32_DBG_DATA_MAX(id) = addr;
+                else
+                    *PP32_DBG_DATA_MIN(id) = addr;
+                ignore_space(&p, &rlen);
+            }
+            if ( *p == 'w' )
+                cmd = 2;
+            else if ( *p == 'r' && p[1] == 'w' )
+            {
+                cmd = 3;
+                p++;
+                rlen--;
+            }
+            p++;
+            rlen--;
+            if ( rlen > 0 )
+            {
+                ignore_space(&p, &rlen);
+                if ( (*p >= '0' && *p <= '9') || (*p >= 'a' && *p <= 'f') || (*p >= 'A' && *p <= 'F'))
+                {
+                    *PP32_DBG_DATA_VAL(id) = get_number(&p, &rlen, 1);
+                    cmd = 4;
+                }
+            }
+            *PP32_BRK_SRC |= PP32_BRK_SRC_DATA(id, cmd);
+        }
+    }
+    else
+    {
+        printk("echo \"<command>\" > /proc/driver/ifx_ptm/pp32\n");
+        printk("  command:\n");
+        printk("    start - run pp32\n");
+        printk("    stop  - stop pp32\n");
+        printk("    step  - run pp32 with one step only\n");
+        printk("    pc0    - pc0 <addr_min [addr_max]>/off, set break point PC0\n");
+        printk("    pc1    - pc1 <addr_min [addr_max]>/off, set break point PC1\n");
+        printk("    pc2    - pc2 <addr_min [addr_max]>/off, set break point PC2\n");
+        printk("    pc3    - pc3 <addr_min [addr_max]>/off, set break point PC3\n");
+        printk("    daddr0 - daddr0 <addr_min [addr_max] r/w/rw [value]>/off, set break point data address 0\n");
+        printk("    daddr1 - daddr1 <addr_min [addr_max] r/w/rw [value]>/off, set break point data address 1\n");
+        printk("    help  - print this screen\n");
+    }
+
+    return count;
+}
+
+#else
+
+static int proc_read_pp32(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    static const char *stron = " on";
+    static const char *stroff = "off";
+
+    int len = 0;
+    int cur_context;
+    int f_stopped;
+    char str[256];
+    char strlength;
+    int i, j;
+
+    int pp32;
+
+    for ( pp32 = 0; pp32 < NUM_OF_PP32; pp32++ )
+    {
+        f_stopped = 0;
+
+        len += sprintf(page + off + len, "===== pp32 core %d =====\n", pp32);
+
+  #ifdef CONFIG_VR9
+        if ( (*PP32_FREEZE & (1 << (pp32 << 4))) != 0 )
+        {
+            sprintf(str, "freezed");
+            f_stopped = 1;
+        }
+  #else
+        if ( 0 )
+        {
+        }
+  #endif
+        else if ( PP32_CPU_USER_STOPPED(pp32) || PP32_CPU_USER_BREAKIN_RCV(pp32) || PP32_CPU_USER_BREAKPOINT_MET(pp32) )
+        {
+            strlength = 0;
+            if ( PP32_CPU_USER_STOPPED(pp32) )
+                strlength += sprintf(str + strlength, "stopped");
+            if ( PP32_CPU_USER_BREAKPOINT_MET(pp32) )
+                strlength += sprintf(str + strlength, strlength ? " | breakpoint" : "breakpoint");
+            if ( PP32_CPU_USER_BREAKIN_RCV(pp32) )
+                strlength += sprintf(str + strlength, strlength ? " | breakin" : "breakin");
+            f_stopped = 1;
+        }
+        else if ( PP32_CPU_CUR_PC(pp32) == PP32_CPU_CUR_PC(pp32) )
+        {
+            unsigned int pc_value[64] = {0};
+
+            f_stopped = 1;
+            for ( i = 0; f_stopped && i < NUM_ENTITY(pc_value); i++ )
+            {
+                pc_value[i] = PP32_CPU_CUR_PC(pp32);
+                for ( j = 0; j < i; j++ )
+                    if ( pc_value[j] != pc_value[i] )
+                    {
+                        f_stopped = 0;
+                        break;
+                    }
+            }
+            if ( f_stopped )
+                sprintf(str, "hang");
+        }
+        if ( !f_stopped )
+            sprintf(str, "running");
+        cur_context = PP32_BRK_CUR_CONTEXT(pp32);
+        len += sprintf(page + off + len, "Context: %d, PC: 0x%04x, %s\n", cur_context, PP32_CPU_CUR_PC(pp32), str);
+
+        if ( PP32_CPU_USER_BREAKPOINT_MET(pp32) )
+        {
+            strlength = 0;
+            if ( PP32_BRK_PC_MET(pp32, 0) )
+                strlength += sprintf(str + strlength, "pc0");
+            if ( PP32_BRK_PC_MET(pp32, 1) )
+                strlength += sprintf(str + strlength, strlength ? " | pc1" : "pc1");
+            if ( PP32_BRK_DATA_ADDR_MET(pp32, 0) )
+                strlength += sprintf(str + strlength, strlength ? " | daddr0" : "daddr0");
+            if ( PP32_BRK_DATA_ADDR_MET(pp32, 1) )
+                strlength += sprintf(str + strlength, strlength ? " | daddr1" : "daddr1");
+            if ( PP32_BRK_DATA_VALUE_RD_MET(pp32, 0) )
+            {
+                strlength += sprintf(str + strlength, strlength ? " | rdval0" : "rdval0");
+                if ( PP32_BRK_DATA_VALUE_RD_LO_EQ(pp32, 0) )
+                {
+                    if ( PP32_BRK_DATA_VALUE_RD_GT_EQ(pp32, 0) )
+                        strlength += sprintf(str + strlength, " ==");
+                    else
+                        strlength += sprintf(str + strlength, " <=");
+                }
+                else if ( PP32_BRK_DATA_VALUE_RD_GT_EQ(pp32, 0) )
+                    strlength += sprintf(str + strlength, " >=");
+            }
+            if ( PP32_BRK_DATA_VALUE_RD_MET(pp32, 1) )
+            {
+                strlength += sprintf(str + strlength, strlength ? " | rdval1" : "rdval1");
+                if ( PP32_BRK_DATA_VALUE_RD_LO_EQ(pp32, 1) )
+                {
+                    if ( PP32_BRK_DATA_VALUE_RD_GT_EQ(pp32, 1) )
+                        strlength += sprintf(str + strlength, " ==");
+                    else
+                        strlength += sprintf(str + strlength, " <=");
+                }
+                else if ( PP32_BRK_DATA_VALUE_RD_GT_EQ(pp32, 1) )
+                    strlength += sprintf(str + strlength, " >=");
+            }
+            if ( PP32_BRK_DATA_VALUE_WR_MET(pp32, 0) )
+            {
+                strlength += sprintf(str + strlength, strlength ? " | wtval0" : "wtval0");
+                if ( PP32_BRK_DATA_VALUE_WR_LO_EQ(pp32, 0) )
+                {
+                    if ( PP32_BRK_DATA_VALUE_WR_GT_EQ(pp32, 0) )
+                        strlength += sprintf(str + strlength, " ==");
+                    else
+                        strlength += sprintf(str + strlength, " <=");
+                }
+                else if ( PP32_BRK_DATA_VALUE_WR_GT_EQ(pp32, 0) )
+                    strlength += sprintf(str + strlength, " >=");
+            }
+            if ( PP32_BRK_DATA_VALUE_WR_MET(pp32, 1) )
+            {
+                strlength += sprintf(str + strlength, strlength ? " | wtval1" : "wtval1");
+                if ( PP32_BRK_DATA_VALUE_WR_LO_EQ(pp32, 1) )
+                {
+                    if ( PP32_BRK_DATA_VALUE_WR_GT_EQ(pp32, 1) )
+                        strlength += sprintf(str + strlength, " ==");
+                    else
+                        strlength += sprintf(str + strlength, " <=");
+                }
+                else if ( PP32_BRK_DATA_VALUE_WR_GT_EQ(pp32, 1) )
+                    strlength += sprintf(str + strlength, " >=");
+            }
+            len += sprintf(page + off + len, "break reason: %s\n", str);
+        }
+
+        if ( f_stopped )
+        {
+            len += sprintf(page + off + len, "General Purpose Register (Context %d):\n", cur_context);
+            for ( i = 0; i < 4; i++ )
+            {
+                for ( j = 0; j < 4; j++ )
+                    len += sprintf(page + off + len, "   %2d: %08x", i + j * 4, *PP32_GP_CONTEXTi_REGn(pp32, cur_context, i + j * 4));
+                len += sprintf(page + off + len, "\n");
+            }
+        }
+
+        len += sprintf(page + off + len, "break out on: break in - %s, stop - %s\n",
+                                            PP32_CTRL_OPT_BREAKOUT_ON_BREAKIN(pp32) ? stron : stroff,
+                                            PP32_CTRL_OPT_BREAKOUT_ON_STOP(pp32) ? stron : stroff);
+        len += sprintf(page + off + len, "     stop on: break in - %s, break point - %s\n",
+                                            PP32_CTRL_OPT_STOP_ON_BREAKIN(pp32) ? stron : stroff,
+                                            PP32_CTRL_OPT_STOP_ON_BREAKPOINT(pp32) ? stron : stroff);
+        len += sprintf(page + off + len, "breakpoint:\n");
+        len += sprintf(page + off + len, "     pc0: 0x%08x, %s\n", *PP32_BRK_PC(pp32, 0), PP32_BRK_GRPi_PCn(pp32, 0, 0) ? "group 0" : "off");
+        len += sprintf(page + off + len, "     pc1: 0x%08x, %s\n", *PP32_BRK_PC(pp32, 1), PP32_BRK_GRPi_PCn(pp32, 1, 1) ? "group 1" : "off");
+        len += sprintf(page + off + len, "  daddr0: 0x%08x, %s\n", *PP32_BRK_DATA_ADDR(pp32, 0), PP32_BRK_GRPi_DATA_ADDRn(pp32, 0, 0) ? "group 0" : "off");
+        len += sprintf(page + off + len, "  daddr1: 0x%08x, %s\n", *PP32_BRK_DATA_ADDR(pp32, 1), PP32_BRK_GRPi_DATA_ADDRn(pp32, 1, 1) ? "group 1" : "off");
+        len += sprintf(page + off + len, "  rdval0: 0x%08x\n", *PP32_BRK_DATA_VALUE_RD(pp32, 0));
+        len += sprintf(page + off + len, "  rdval1: 0x%08x\n", *PP32_BRK_DATA_VALUE_RD(pp32, 1));
+        len += sprintf(page + off + len, "  wrval0: 0x%08x\n", *PP32_BRK_DATA_VALUE_WR(pp32, 0));
+        len += sprintf(page + off + len, "  wrval1: 0x%08x\n", *PP32_BRK_DATA_VALUE_WR(pp32, 1));
+    }
+
+    *eof = 1;
+
+    return len;
+}
+
+static int proc_write_pp32(struct file *file, const char *buf, unsigned long count, void *data)
+{
+    char str[2048];
+    char *p;
+    int len, rlen;
+
+    int pp32 = 0;
+    u32 addr;
+
+    len = count < sizeof(str) ? count : sizeof(str) - 1;
+    rlen = len - copy_from_user(str, buf, len);
+    while ( rlen && str[rlen - 1] <= ' ' )
+        rlen--;
+    str[rlen] = 0;
+    for ( p = str; *p && *p <= ' '; p++, rlen-- );
+    if ( !*p )
+        return 0;
+
+    if ( strincmp(p, "pp32 ", 5) == 0 )
+    {
+        p += 5;
+        rlen -= 5;
+
+        while ( rlen > 0 && *p >= '0' && *p <= '9' )
+        {
+            pp32 += *p - '0';
+            p++;
+            rlen--;
+        }
+        while ( rlen > 0 && *p && *p <= ' ' )
+        {
+            p++;
+            rlen--;
+        }
+
+        if ( pp32 >= NUM_OF_PP32 )
+        {
+            printk(KERN_ERR __FILE__ ":%d:%s: incorrect pp32 index - %d\n", __LINE__, __FUNCTION__, pp32);
+            return count;
+        }
+    }
+
+    if ( stricmp(p, "start") == 0 )
+    {
+  #ifdef CONFIG_AMAZON_SE
+        *PP32_CTRL_CMD(pp32) = 0;
+  #endif
+        *PP32_CTRL_CMD(pp32) = PP32_CTRL_CMD_RESTART;
+    }
+    else if ( stricmp(p, "stop") == 0 )
+    {
+  #ifdef CONFIG_AMAZON_SE
+        *PP32_CTRL_CMD(pp32) = 0;
+  #endif
+        *PP32_CTRL_CMD(pp32) = PP32_CTRL_CMD_STOP;
+    }
+    else if ( stricmp(p, "step") == 0 )
+    {
+  #ifdef CONFIG_AMAZON_SE
+        *PP32_CTRL_CMD(pp32) = 0;
+  #endif
+        *PP32_CTRL_CMD(pp32) = PP32_CTRL_CMD_STEP;
+    }
+  #ifdef CONFIG_VR9
+    else if ( stricmp(p, "unfreeze") == 0 )
+        *PP32_FREEZE &= ~(1 << (pp32 << 4));
+    else if ( stricmp(p, "freeze") == 0 )
+        *PP32_FREEZE |= 1 << (pp32 << 4);
+  #else
+    else if ( stricmp(p, "unfreeze") == 0 )
+        *PP32_DBG_CTRL(pp32) = DBG_CTRL_RESTART;
+    else if ( stricmp(p, "freeze") == 0 )
+        *PP32_DBG_CTRL(pp32) = DBG_CTRL_STOP;
+  #endif
+    else if ( strincmp(p, "pc0 ", 4) == 0 )
+    {
+        p += 4;
+        rlen -= 4;
+        if ( stricmp(p, "off") == 0 )
+        {
+            *PP32_BRK_TRIG(pp32) = PP32_BRK_GRPi_PCn_OFF(0, 0);
+            *PP32_BRK_PC_MASK(pp32, 0) = PP32_BRK_CONTEXT_MASK_EN;
+            *PP32_BRK_PC(pp32, 0) = 0;
+        }
+        else
+        {
+            addr = get_number(&p, &rlen, 1);
+            *PP32_BRK_PC(pp32, 0) = addr;
+            *PP32_BRK_PC_MASK(pp32, 0) = PP32_BRK_CONTEXT_MASK_EN | PP32_BRK_CONTEXT_MASK(0) | PP32_BRK_CONTEXT_MASK(1) | PP32_BRK_CONTEXT_MASK(2) | PP32_BRK_CONTEXT_MASK(3);
+            *PP32_BRK_TRIG(pp32) = PP32_BRK_GRPi_PCn_ON(0, 0);
+        }
+    }
+    else if ( strincmp(p, "pc1 ", 4) == 0 )
+    {
+        p += 4;
+        rlen -= 4;
+        if ( stricmp(p, "off") == 0 )
+        {
+            *PP32_BRK_TRIG(pp32) = PP32_BRK_GRPi_PCn_OFF(1, 1);
+            *PP32_BRK_PC_MASK(pp32, 1) = PP32_BRK_CONTEXT_MASK_EN;
+            *PP32_BRK_PC(pp32, 1) = 0;
+        }
+        else
+        {
+            addr = get_number(&p, &rlen, 1);
+            *PP32_BRK_PC(pp32, 1) = addr;
+            *PP32_BRK_PC_MASK(pp32, 1) = PP32_BRK_CONTEXT_MASK_EN | PP32_BRK_CONTEXT_MASK(0) | PP32_BRK_CONTEXT_MASK(1) | PP32_BRK_CONTEXT_MASK(2) | PP32_BRK_CONTEXT_MASK(3);
+            *PP32_BRK_TRIG(pp32) = PP32_BRK_GRPi_PCn_ON(1, 1);
+        }
+    }
+    else if ( strincmp(p, "daddr0 ", 7) == 0 )
+    {
+        p += 7;
+        rlen -= 7;
+        if ( stricmp(p, "off") == 0 )
+        {
+            *PP32_BRK_TRIG(pp32) = PP32_BRK_GRPi_DATA_ADDRn_OFF(0, 0);
+            *PP32_BRK_DATA_ADDR_MASK(pp32, 0) = PP32_BRK_CONTEXT_MASK_EN;
+            *PP32_BRK_DATA_ADDR(pp32, 0) = 0;
+        }
+        else
+        {
+            addr = get_number(&p, &rlen, 1);
+            *PP32_BRK_DATA_ADDR(pp32, 0) = addr;
+            *PP32_BRK_DATA_ADDR_MASK(pp32, 0) = PP32_BRK_CONTEXT_MASK_EN | PP32_BRK_CONTEXT_MASK(0) | PP32_BRK_CONTEXT_MASK(1) | PP32_BRK_CONTEXT_MASK(2) | PP32_BRK_CONTEXT_MASK(3);
+            *PP32_BRK_TRIG(pp32) = PP32_BRK_GRPi_DATA_ADDRn_ON(0, 0);
+        }
+    }
+    else if ( strincmp(p, "daddr1 ", 7) == 0 )
+    {
+        p += 7;
+        rlen -= 7;
+        if ( stricmp(p, "off") == 0 )
+        {
+            *PP32_BRK_TRIG(pp32) = PP32_BRK_GRPi_DATA_ADDRn_OFF(1, 1);
+            *PP32_BRK_DATA_ADDR_MASK(pp32, 1) = PP32_BRK_CONTEXT_MASK_EN;
+            *PP32_BRK_DATA_ADDR(pp32, 1) = 0;
+        }
+        else
+        {
+            addr = get_number(&p, &rlen, 1);
+            *PP32_BRK_DATA_ADDR(pp32, 1) = addr;
+            *PP32_BRK_DATA_ADDR_MASK(pp32, 1) = PP32_BRK_CONTEXT_MASK_EN | PP32_BRK_CONTEXT_MASK(0) | PP32_BRK_CONTEXT_MASK(1) | PP32_BRK_CONTEXT_MASK(2) | PP32_BRK_CONTEXT_MASK(3);
+            *PP32_BRK_TRIG(pp32) = PP32_BRK_GRPi_DATA_ADDRn_ON(1, 1);
+        }
+    }
+    else
+    {
+
+        printk("echo \"<command>\" > /proc/driver/ifx_ptm/pp32\n");
+        printk("  command:\n");
+        printk("    unfreeze - unfreeze pp32\n");
+        printk("    freeze   - freeze pp32\n");
+        printk("    start    - run pp32\n");
+        printk("    stop     - stop pp32\n");
+        printk("    step     - run pp32 with one step only\n");
+        printk("    pc0      - pc0 <addr>/off, set break point PC0\n");
+        printk("    pc1      - pc1 <addr>/off, set break point PC1\n");
+        printk("    daddr0   - daddr0 <addr>/off, set break point data address 0\n");
+        printk("    daddr1   - daddr1 <addr>/off, set break point data address 1\n");
+        printk("    help     - print this screen\n");
+    }
+
+    if ( *PP32_BRK_TRIG(pp32) )
+        *PP32_CTRL_OPT(pp32) = PP32_CTRL_OPT_STOP_ON_BREAKPOINT_ON;
+    else
+        *PP32_CTRL_OPT(pp32) = PP32_CTRL_OPT_STOP_ON_BREAKPOINT_OFF;
+
+    return count;
+}
+
+#endif
+
+static int stricmp(const char *p1, const char *p2)
+{
+    int c1, c2;
+
+    while ( *p1 && *p2 )
+    {
+        c1 = *p1 >= 'A' && *p1 <= 'Z' ? *p1 + 'a' - 'A' : *p1;
+        c2 = *p2 >= 'A' && *p2 <= 'Z' ? *p2 + 'a' - 'A' : *p2;
+        if ( (c1 -= c2) )
+            return c1;
+        p1++;
+        p2++;
+    }
+
+    return *p1 - *p2;
+}
+
+static int strincmp(const char *p1, const char *p2, int n)
+{
+    int c1 = 0, c2;
+
+    while ( n && *p1 && *p2 )
+    {
+        c1 = *p1 >= 'A' && *p1 <= 'Z' ? *p1 + 'a' - 'A' : *p1;
+        c2 = *p2 >= 'A' && *p2 <= 'Z' ? *p2 + 'a' - 'A' : *p2;
+        if ( (c1 -= c2) )
+            return c1;
+        p1++;
+        p2++;
+        n--;
+    }
+
+    return n ? *p1 - *p2 : c1;
+}
+
+static int get_token(char **p1, char **p2, int *len, int *colon)
+{
+    int tlen = 0;
+
+    while ( *len && !((**p1 >= 'A' && **p1 <= 'Z') || (**p1 >= 'a' && **p1<= 'z')) )
+    {
+        (*p1)++;
+        (*len)--;
+    }
+    if ( !*len )
+        return 0;
+
+    if ( *colon )
+    {
+        *colon = 0;
+        *p2 = *p1;
+        while ( *len && **p2 > ' ' && **p2 != ',' )
+        {
+            if ( **p2 == ':' )
+            {
+                *colon = 1;
+                break;
+            }
+            (*p2)++;
+            (*len)--;
+            tlen++;
+        }
+        **p2 = 0;
+    }
+    else
+    {
+        *p2 = *p1;
+        while ( *len && **p2 > ' ' && **p2 != ',' )
+        {
+            (*p2)++;
+            (*len)--;
+            tlen++;
+        }
+        **p2 = 0;
+    }
+
+    return tlen;
+}
+
+static int get_number(char **p, int *len, int is_hex)
+{
+    int ret = 0;
+    int n = 0;
+
+    if ( (*p)[0] == '0' && (*p)[1] == 'x' )
+    {
+        is_hex = 1;
+        (*p) += 2;
+        (*len) -= 2;
+    }
+
+    if ( is_hex )
+    {
+        while ( *len && ((**p >= '0' && **p <= '9') || (**p >= 'a' && **p <= 'f') || (**p >= 'A' && **p <= 'F')) )
+        {
+            if ( **p >= '0' && **p <= '9' )
+                n = **p - '0';
+            else if ( **p >= 'a' && **p <= 'f' )
+               n = **p - 'a' + 10;
+            else if ( **p >= 'A' && **p <= 'F' )
+                n = **p - 'A' + 10;
+            ret = (ret << 4) | n;
+            (*p)++;
+            (*len)--;
+        }
+    }
+    else
+    {
+        while ( *len && **p >= '0' && **p <= '9' )
+        {
+            n = **p - '0';
+            ret = ret * 10 + n;
+            (*p)++;
+            (*len)--;
+        }
+    }
+
+    return ret;
+}
+
+static inline void ignore_space(char **p, int *len)
+{
+    while ( *len && (**p <= ' ' || **p == ':' || **p == '.' || **p == ',') )
+    {
+        (*p)++;
+        (*len)--;
+    }
+}
+
+
+
+/*
+ * ####################################
+ *           Global Function
+ * ####################################
+ */
+
+
+
+/*
+ * ####################################
+ *           Init/Cleanup API
+ * ####################################
+ */
+
+static int __init ifx_ptm_test_init(void)
+{
+    proc_file_create();
+
+    return 0;
+}
+
+static void __exit ifx_ptm_test_exit(void)
+{
+    proc_file_delete();
+}
+
+module_init(ifx_ptm_test_init);
+module_exit(ifx_ptm_test_exit);
+
+#endif
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/lantiq_ptm/ltqmips_ptm_vdsl.c b/drivers/net/lantiq_ptm/ltqmips_ptm_vdsl.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/lantiq_ptm/ltqmips_ptm_vdsl.c
@@ -0,0 +1,2226 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_ptm_vdsl.c
+** PROJECT      : UEIP
+** MODULES      : PTM
+**
+** DATE         : 7 Jul 2009
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : PTM driver common source file (core functions for VR9)
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 07 JUL 2009  Xu Liang        Init Version
+*******************************************************************************/
+
+
+
+/*
+ * ####################################
+ *              Head File
+ * ####################################
+ */
+
+/*
+ *  Common Head File
+ */
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/ctype.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/etherdevice.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include <lantiq_soc.h>
+
+/*
+ *  Chip Specific Head File
+ */
+#include "ltqmips_ptm_vdsl.h"
+
+
+/*
+ * ####################################
+ *        Kernel Version Adaption
+ * ####################################
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+  #define MODULE_PARM_ARRAY(a, b)   module_param_array(a, int, NULL, 0)
+  #define MODULE_PARM(a, b)         module_param(a, int, 0)
+#else
+  #define MODULE_PARM_ARRAY(a, b)   MODULE_PARM(a, b)
+#endif
+
+
+
+/*
+ * ####################################
+ *   Parameters to Configure PPE
+ * ####################################
+ */
+
+static int wanqos_en = 0;
+
+static int queue_gamma_map[4] = {0xFE, 0x01, 0x00, 0x00};
+
+MODULE_PARM(wanqos_en, "i");
+MODULE_PARM_DESC(wanqos_en, "WAN QoS support, 1 - enabled, 0 - disabled.");
+
+MODULE_PARM_ARRAY(queue_gamma_map, "4-4i");
+MODULE_PARM_DESC(queue_gamma_map, "TX QoS queues mapping to 4 TX Gamma interfaces.");
+
+
+
+/*
+ * ####################################
+ *              Definition
+ * ####################################
+ */
+
+#define ENABLE_TMP_DBG                          0
+
+#define ENABLE_LED_FRAMEWORK                    0
+
+#define DUMP_SKB_LEN                            ~0
+
+
+
+/*
+ * ####################################
+ *             Declaration
+ * ####################################
+ */
+
+/*
+ *  Network Operations
+ */
+static void ptm_setup(struct net_device *, int);
+static struct net_device_stats *ptm_get_stats(struct net_device *);
+static int ptm_open(struct net_device *);
+static int ptm_stop(struct net_device *);
+#ifdef CONFIG_LTQ_PTM_RX_NAPI
+  static unsigned int ptm_poll(int, unsigned int);
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+  static int ptm_napi_poll(struct net_device *, int *);
+ #else
+  static int ptm_napi_poll(struct napi_struct *, int);
+ #endif
+#endif
+static int ptm_hard_start_xmit(struct sk_buff *, struct net_device *);
+static int ptm_ioctl(struct net_device *, struct ifreq *, int);
+static void ptm_tx_timeout(struct net_device *);
+
+/*
+ *  DSL Data LED
+ */
+static INLINE void adsl_led_flash(void);
+
+/*
+ *  buffer manage functions
+ */
+static INLINE struct sk_buff* alloc_skb_rx(void);
+static INLINE struct sk_buff* alloc_skb_tx(unsigned int);
+static INLINE struct sk_buff *get_skb_pointer(unsigned int);
+static INLINE int get_tx_desc(unsigned int, unsigned int *);
+
+/*
+ *  Mailbox handler and signal function
+ */
+static irqreturn_t mailbox_irq_handler(int, void *);
+
+/*
+ *  Tasklet to Handle Swap Descriptors
+ */
+static void do_swap_desc_tasklet(unsigned long);
+
+/*
+ *  Debug Functions
+ */
+#if defined(DEBUG_DUMP_SKB) && DEBUG_DUMP_SKB
+  static void dump_skb(struct sk_buff *, u32, char *, int, int, int);
+#else
+  #define dump_skb(skb, len, title, port, ch, is_tx)    do {} while (0)
+#endif
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+  static void skb_swap(struct sk_buff *);
+#else
+  #define skb_swap(skb)                                 do {} while (0)
+#endif
+
+/*
+ *  Proc File Functions
+ */
+static INLINE void proc_file_create(void);
+static INLINE void proc_file_delete(void);
+static int proc_read_version(char *, char **, off_t, int, int *, void *);
+static int proc_read_wanmib(char *, char **, off_t, int, int *, void *);
+static int proc_write_wanmib(struct file *, const char *, unsigned long, void *);
+static int proc_read_prio(char *, char **, off_t, int, int *, void *);
+static int proc_write_prio(struct file *, const char *, unsigned long, void *);
+static int proc_read_qos(char *, char **, off_t, int, int *, void *);
+static int proc_read_gamma(char *, char **, off_t, int, int *, void *);
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+  static int proc_read_dbg(char *, char **, off_t, int, int *, void *);
+  static int proc_write_dbg(struct file *, const char *, unsigned long, void *);
+#endif
+#if defined(ENABLE_TMP_DBG) && ENABLE_TMP_DBG
+  static int proc_read_rdptr(char *, char **, off_t, int, int *, void *);
+#endif
+
+/*
+ *  Proc Help Functions
+ */
+static INLINE int stricmp(const char *, const char *);
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+  static INLINE int strincmp(const char *, const char *, int);
+#endif
+static INLINE int get_token(char **, char **, int *, int *);
+static INLINE int get_number(char **, int *, int);
+static INLINE void ignore_space(char **, int *);
+static INLINE int ifx_ptm_version(char *);
+
+/*
+ *  Init & clean-up functions
+ */
+static INLINE int init_priv_data(void);
+static INLINE void clear_priv_data(void);
+static INLINE int init_tables(void);
+static INLINE void clear_tables(void);
+
+/*
+ *  Exteranl Function
+ */
+#if defined(CONFIG_IFXMIPS_DSL_CPE_MEI) || defined(CONFIG_IFXMIPS_DSL_CPE_MEI_MODULE)
+ #if !defined(ENABLE_LED_FRAMEWORK) || !ENABLE_LED_FRAMEWORK
+  extern int ifx_mei_atm_led_blink(void);
+ #endif
+  extern int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr);
+#else
+ #if !defined(ENABLE_LED_FRAMEWORK) || !ENABLE_LED_FRAMEWORK
+  static inline int ifx_mei_atm_led_blink(void) { return 0; }
+ #endif
+  static inline int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr)
+  {
+    if ( is_showtime != NULL )
+        *is_showtime = 0;
+    return 0;
+  }
+#endif
+
+/*
+ *  External variable
+ */
+#if defined(CONFIG_IFXMIPS_DSL_CPE_MEI) || defined(CONFIG_IFXMIPS_DSL_CPE_MEI_MODULE)
+  extern int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *);
+  extern int (*ifx_mei_atm_showtime_exit)(void);
+#else
+  int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
+  EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);
+  int (*ifx_mei_atm_showtime_exit)(void) = NULL;
+  EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);
+#endif
+
+
+
+/*
+ * ####################################
+ *            Local Variable
+ * ####################################
+ */
+
+static int g_wanqos_en = 0;
+
+static int g_queue_gamma_map[4];
+
+static struct ptm_priv_data g_ptm_priv_data;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+static struct net_device_ops g_ptm_netdev_ops = {
+    .ndo_get_stats       = ptm_get_stats,
+    .ndo_open            = ptm_open,
+    .ndo_stop            = ptm_stop,
+    .ndo_start_xmit      = ptm_hard_start_xmit,
+    .ndo_validate_addr   = eth_validate_addr,
+    .ndo_set_mac_address = eth_mac_addr,
+    .ndo_change_mtu      = eth_change_mtu,
+    .ndo_do_ioctl        = ptm_ioctl,
+    .ndo_tx_timeout      = ptm_tx_timeout,
+};
+#endif
+
+static struct net_device *g_net_dev[1] = {0};
+static char *g_net_dev_name[1] = {"ptm0"};
+
+static int g_ptm_prio_queue_map[8];
+
+static DECLARE_TASKLET(g_swap_desc_tasklet, do_swap_desc_tasklet, 0);
+
+static int g_showtime = 0;
+static void *g_xdata_addr = NULL;
+
+#if defined(ENABLE_LED_FRAMEWORK) && ENABLE_LED_FRAMEWORK
+  static void *g_data_led_trigger = NULL;
+#endif
+
+unsigned int ifx_ptm_dbg_enable = DBG_ENABLE_MASK_ERR;
+
+static struct proc_dir_entry* g_ptm_dir = NULL;
+
+static unsigned int g_wrx_total_pdu[4] = {0};
+static unsigned int g_wrx_err_pdu[4] = {0};
+
+
+
+/*
+ * ####################################
+ *            Local Function
+ * ####################################
+ */
+
+static void ptm_setup(struct net_device *dev, int ndev)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+    /*  hook network operations */
+    dev->get_stats       = ptm_get_stats;
+    dev->open            = ptm_open;
+    dev->stop            = ptm_stop;
+  #ifdef CONFIG_LTQ_PTM_RX_NAPI
+    dev->poll            = ptm_napi_poll;
+    dev->weight          = 16;
+  #endif
+    dev->hard_start_xmit = ptm_hard_start_xmit;
+    dev->do_ioctl        = ptm_ioctl;
+    dev->tx_timeout      = ptm_tx_timeout;
+#else
+    dev->netdev_ops      = &g_ptm_netdev_ops;
+  #ifdef CONFIG_LTQ_PTM_RX_NAPI
+    netif_napi_add(dev, &g_ptm_priv_data.itf[ndev].napi, ptm_napi_poll, 16);
+  #endif
+#endif
+    dev->watchdog_timeo  = ETH_WATCHDOG_TIMEOUT;
+
+    dev->dev_addr[0] = 0x00;
+    dev->dev_addr[1] = 0x20;
+	dev->dev_addr[2] = 0xda;
+	dev->dev_addr[3] = 0x86;
+	dev->dev_addr[4] = 0x23;
+	dev->dev_addr[5] = 0x75 + ndev;
+}
+
+static struct net_device_stats *ptm_get_stats(struct net_device *dev)
+{
+    if ( dev != g_net_dev[0] )
+        return NULL;
+
+    return &g_ptm_priv_data.itf[0].stats;
+}
+
+static int ptm_open(struct net_device *dev)
+{
+    ASSERT(dev == g_net_dev[0], "incorrect device");
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32) && defined(CONFIG_LTQ_PTM_RX_NAPI)
+    napi_enable(&g_ptm_priv_data.itf[0].napi);
+#endif
+
+    IFX_REG_W32_MASK(0, 1, MBOX_IGU1_IER);
+
+    netif_start_queue(dev);
+
+    return 0;
+}
+
+static int ptm_stop(struct net_device *dev)
+{
+    ASSERT(dev == g_net_dev[0], "incorrect device");
+
+    IFX_REG_W32_MASK(1 | (1 << 17), 0, MBOX_IGU1_IER);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32) && defined(CONFIG_LTQ_PTM_RX_NAPI)
+    napi_disable(&g_ptm_priv_data.itf[0].napi);
+#endif
+
+    netif_stop_queue(dev);
+
+    return 0;
+}
+
+#ifdef CONFIG_LTQ_PTM_RX_NAPI
+static unsigned int ptm_poll(int ndev, unsigned int work_to_do)
+{
+    unsigned int work_done = 0;
+    volatile struct rx_descriptor *desc;
+    struct rx_descriptor reg_desc;
+    struct sk_buff *skb, *new_skb;
+
+    ASSERT(ndev >= 0 && ndev < NUM_ENTITY(g_net_dev), "ndev = %d (wrong value)", ndev);
+
+    while ( work_done < work_to_do ) {
+        desc = &WAN_RX_DESC_BASE[g_ptm_priv_data.itf[0].rx_desc_pos];
+        if ( desc->own /* || !desc->c */ )  //  if PP32 hold descriptor or descriptor not completed
+            break;
+        if ( ++g_ptm_priv_data.itf[0].rx_desc_pos == WAN_RX_DESC_NUM )
+            g_ptm_priv_data.itf[0].rx_desc_pos = 0;
+
+        reg_desc = *desc;
+        skb = get_skb_pointer(reg_desc.dataptr);
+        ASSERT(skb != NULL, "invalid pointer skb == NULL");
+
+        new_skb = alloc_skb_rx();
+        if ( new_skb != NULL ) {
+            ASSERT(reg_desc.byteoff == RX_HEAD_MAC_ADDR_ALIGNMENT, "invalid byteoff (%d) != RX_HEAD_MAC_ADDR_ALIGNMENT (%d)", reg_desc.byteoff, RX_HEAD_MAC_ADDR_ALIGNMENT);
+            skb_reserve(skb, reg_desc.byteoff);
+            skb_put(skb, reg_desc.datalen);
+
+            dump_skb(skb, DUMP_SKB_LEN, (char *)__func__, 0, 0, 0);
+
+            //  parse protocol header
+            skb->dev = g_net_dev[0];
+            skb->protocol = eth_type_trans(skb, skb->dev);
+
+            g_net_dev[0]->last_rx = jiffies;
+
+            netif_receive_skb(skb);
+
+            g_ptm_priv_data.itf[0].stats.rx_packets++;
+            g_ptm_priv_data.itf[0].stats.rx_bytes += reg_desc.datalen;
+
+            reg_desc.dataptr = (unsigned int)new_skb->data & 0x0FFFFFFF;
+            reg_desc.byteoff = RX_HEAD_MAC_ADDR_ALIGNMENT;
+        }
+
+        reg_desc.datalen = RX_MAX_BUFFER_SIZE - RX_HEAD_MAC_ADDR_ALIGNMENT;
+        reg_desc.own     = 1;
+        reg_desc.c       = 0;
+
+        /*  write discriptor to memory  */
+        *((volatile unsigned int *)desc + 1) = *((unsigned int *)&reg_desc + 1);
+        wmb();
+        *(volatile unsigned int *)desc = *(unsigned int *)&reg_desc;
+
+        adsl_led_flash();
+
+        work_done++;
+    }
+
+    return work_done;
+}
+  #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+static int ptm_napi_poll(struct net_device *dev, int *quota)
+{
+    int ndev = 0;
+    unsigned int work_to_do = min(dev->quota, *quota);
+    unsigned int work_done;
+
+    ASSERT(dev == g_net_dev[0], "incorrect device");
+
+    work_done = ptm_poll(ndev, work_to_do);
+
+    *quota -= work_done;
+
+    //  interface down
+    if ( !netif_running(dev) ) {
+        netif_rx_complete(dev);
+        return 0;
+    }
+
+    //  clear interrupt
+    IFX_REG_W32_MASK(0, 1, MBOX_IGU1_ISRC);
+    //  no more traffic
+    if ( WAN_RX_DESC_BASE[g_ptm_priv_data.itf[0].rx_desc_pos].own ) {   //  if PP32 hold descriptor
+        netif_rx_complete(dev);
+        IFX_REG_W32_MASK(0, 1, MBOX_IGU1_IER);
+        return 0;
+    }
+
+    //  next round
+    dev->quota -= work_done;
+    return 1;
+}
+  #else
+static int ptm_napi_poll(struct napi_struct *napi, int budget)
+{
+    int ndev = 0;
+    unsigned int work_done;
+
+    work_done = ptm_poll(ndev, budget);
+
+    //  interface down
+    if ( !netif_running(napi->dev) ) {
+        napi_complete(napi);
+        return work_done;
+    }
+
+    //  clear interrupt
+    IFX_REG_W32_MASK(0, 1, MBOX_IGU1_ISRC);
+    //  no more traffic
+    if ( WAN_RX_DESC_BASE[g_ptm_priv_data.itf[0].rx_desc_pos].own ) {   //  if PP32 hold descriptor
+        napi_complete(napi);
+        IFX_REG_W32_MASK(0, 1, MBOX_IGU1_IER);
+        return work_done;
+    }
+
+    //  next round
+    return work_done;
+}
+  #endif
+#endif
+
+static int ptm_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+    int qid;
+    unsigned int f_full;
+    int desc_base;
+    volatile struct tx_descriptor *desc;
+    struct tx_descriptor reg_desc = {0};
+    struct sk_buff *skb_to_free;
+    unsigned int byteoff;
+
+    ASSERT(dev == g_net_dev[0], "incorrect device");
+
+    if ( !g_showtime ) {
+        err("not in showtime");
+        goto PTM_HARD_START_XMIT_FAIL;
+    }
+
+    /*  allocate descriptor */
+    desc_base = get_tx_desc(0, &f_full);
+    if ( f_full ) {
+        dev->trans_start = jiffies;
+        netif_stop_queue(dev);
+
+        IFX_REG_W32_MASK(0, 1 << 17, MBOX_IGU1_ISRC);
+        IFX_REG_W32_MASK(0, 1 << 17, MBOX_IGU1_IER);
+    }
+    if ( desc_base < 0 )
+        goto PTM_HARD_START_XMIT_FAIL;
+    desc = &CPU_TO_WAN_TX_DESC_BASE[desc_base];
+
+    if ( skb->cb[13] == 0x5A )  //  magic number indicating forcing QId (e.g. directpath)
+        qid = skb->cb[15];
+    else
+        qid = g_ptm_prio_queue_map[skb->priority > 7 ? 7 : skb->priority];
+
+    byteoff = (unsigned int)skb->data & (DATA_BUFFER_ALIGNMENT - 1);
+    if ( skb_headroom(skb) < sizeof(struct sk_buff *) + byteoff || skb_cloned(skb) ) {
+        struct sk_buff *new_skb;
+
+        ASSERT(skb_headroom(skb) >= sizeof(struct sk_buff *) + byteoff, "skb_headroom(skb) < sizeof(struct sk_buff *) + byteoff");
+        ASSERT(!skb_cloned(skb), "skb is cloned");
+
+        new_skb = alloc_skb_tx(skb->len);
+        if ( new_skb == NULL ) {
+            dbg("no memory");
+            goto ALLOC_SKB_TX_FAIL;
+        }
+        skb_put(new_skb, skb->len);
+        memcpy(new_skb->data, skb->data, skb->len);
+        dev_kfree_skb_any(skb);
+        skb = new_skb;
+        byteoff = (unsigned int)skb->data & (DATA_BUFFER_ALIGNMENT - 1);
+        /*  write back to physical memory   */
+        dma_cache_sync(NULL, skb->data, skb->len, DMA_TO_DEVICE);
+    }
+
+    *(struct sk_buff **)((unsigned int)skb->data - byteoff - sizeof(struct sk_buff *)) = skb;
+    /*  write back to physical memory   */
+    dma_cache_sync(NULL, (void *)((unsigned long)skb->data - byteoff - sizeof(struct sk_buff *)), skb->len + byteoff + sizeof(struct sk_buff *), DMA_TO_DEVICE);
+
+    /*  free previous skb   */
+    skb_to_free = get_skb_pointer(desc->dataptr);
+    if ( skb_to_free != NULL )
+        dev_kfree_skb_any(skb_to_free);
+
+    /*  update descriptor   */
+    reg_desc.small   = 0;
+    reg_desc.dataptr = (unsigned int)skb->data & (0x0FFFFFFF ^ (DATA_BUFFER_ALIGNMENT - 1));
+    reg_desc.datalen = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+    reg_desc.qid     = qid;
+    reg_desc.byteoff = byteoff;
+    reg_desc.own     = 1;
+    reg_desc.c       = 1;
+    reg_desc.sop = reg_desc.eop = 1;
+
+    /*  update MIB  */
+    g_ptm_priv_data.itf[0].stats.tx_packets++;
+    g_ptm_priv_data.itf[0].stats.tx_bytes += reg_desc.datalen;
+
+    dump_skb(skb, DUMP_SKB_LEN, (char *)__func__, 0, reg_desc.qid, 1);
+
+    if ( (ifx_ptm_dbg_enable & DBG_ENABLE_MASK_MAC_SWAP) ) {
+        skb_swap(skb);
+    }
+
+    /*  write discriptor to memory  */
+    *((volatile unsigned int *)desc + 1) = *((unsigned int *)&reg_desc + 1);
+    wmb();
+    *(volatile unsigned int *)desc = *(unsigned int *)&reg_desc;
+
+    dev->trans_start = jiffies;
+
+    adsl_led_flash();
+
+    return 0;
+
+ALLOC_SKB_TX_FAIL:
+PTM_HARD_START_XMIT_FAIL:
+    dev_kfree_skb_any(skb);
+    g_ptm_priv_data.itf[0].stats.tx_dropped++;
+    return 0;
+}
+
+static int ptm_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+    ASSERT(dev == g_net_dev[0], "incorrect device");
+
+    switch ( cmd )
+    {
+    case IFX_PTM_MIB_CW_GET:
+        ((PTM_CW_IF_ENTRY_T *)ifr->ifr_data)->ifRxNoIdleCodewords   = IFX_REG_R32(DREG_AR_CELL0) + IFX_REG_R32(DREG_AR_CELL1);
+        ((PTM_CW_IF_ENTRY_T *)ifr->ifr_data)->ifRxIdleCodewords     = IFX_REG_R32(DREG_AR_IDLE_CNT0) + IFX_REG_R32(DREG_AR_IDLE_CNT1);
+        ((PTM_CW_IF_ENTRY_T *)ifr->ifr_data)->ifRxCodingViolation   = IFX_REG_R32(DREG_AR_CVN_CNT0) + IFX_REG_R32(DREG_AR_CVN_CNT1) + IFX_REG_R32(DREG_AR_CVNP_CNT0) + IFX_REG_R32(DREG_AR_CVNP_CNT1);
+        ((PTM_CW_IF_ENTRY_T *)ifr->ifr_data)->ifTxNoIdleCodewords   = IFX_REG_R32(DREG_AT_CELL0) + IFX_REG_R32(DREG_AT_CELL1);
+        ((PTM_CW_IF_ENTRY_T *)ifr->ifr_data)->ifTxIdleCodewords     = IFX_REG_R32(DREG_AT_IDLE_CNT0) + IFX_REG_R32(DREG_AT_IDLE_CNT1);
+        break;
+    case IFX_PTM_MIB_FRAME_GET:
+        {
+            PTM_FRAME_MIB_T data = {0};
+            int i;
+
+            data.RxCorrect = IFX_REG_R32(DREG_AR_HEC_CNT0) + IFX_REG_R32(DREG_AR_HEC_CNT1) + IFX_REG_R32(DREG_AR_AIIDLE_CNT0) + IFX_REG_R32(DREG_AR_AIIDLE_CNT1);
+            for ( i = 0; i < 4; i++ )
+                data.RxDropped += WAN_RX_MIB_TABLE(i)->wrx_dropdes_pdu;
+            for ( i = 0; i < 8; i++ )
+                data.TxSend    += WAN_TX_MIB_TABLE(i)->wtx_total_pdu;
+
+            *((PTM_FRAME_MIB_T *)ifr->ifr_data) = data;
+        }
+        break;
+    case IFX_PTM_CFG_GET:
+        //  use bear channel 0 preemption gamma interface settings
+        ((IFX_PTM_CFG_T *)ifr->ifr_data)->RxEthCrcPresent = 1;
+        ((IFX_PTM_CFG_T *)ifr->ifr_data)->RxEthCrcCheck   = RX_GAMMA_ITF_CFG(0)->rx_eth_fcs_ver_dis == 0 ? 1 : 0;
+        ((IFX_PTM_CFG_T *)ifr->ifr_data)->RxTcCrcCheck    = RX_GAMMA_ITF_CFG(0)->rx_tc_crc_ver_dis == 0 ? 1 : 0;;
+        ((IFX_PTM_CFG_T *)ifr->ifr_data)->RxTcCrcLen      = RX_GAMMA_ITF_CFG(0)->rx_tc_crc_size == 0 ? 0 : (RX_GAMMA_ITF_CFG(0)->rx_tc_crc_size * 16);
+        ((IFX_PTM_CFG_T *)ifr->ifr_data)->TxEthCrcGen     = TX_GAMMA_ITF_CFG(0)->tx_eth_fcs_gen_dis == 0 ? 1 : 0;
+        ((IFX_PTM_CFG_T *)ifr->ifr_data)->TxTcCrcGen      = TX_GAMMA_ITF_CFG(0)->tx_tc_crc_size == 0 ? 0 : 1;
+        ((IFX_PTM_CFG_T *)ifr->ifr_data)->TxTcCrcLen      = TX_GAMMA_ITF_CFG(0)->tx_tc_crc_size == 0 ? 0 : (TX_GAMMA_ITF_CFG(0)->tx_tc_crc_size * 16);
+        break;
+    case IFX_PTM_CFG_SET:
+        {
+            int i;
+
+            for ( i = 0; i < 4; i++ ) {
+                RX_GAMMA_ITF_CFG(i)->rx_eth_fcs_ver_dis = ((IFX_PTM_CFG_T *)ifr->ifr_data)->RxEthCrcCheck ? 0 : 1;
+
+                RX_GAMMA_ITF_CFG(0)->rx_tc_crc_ver_dis = ((IFX_PTM_CFG_T *)ifr->ifr_data)->RxTcCrcCheck ? 0 : 1;
+
+                switch ( ((IFX_PTM_CFG_T *)ifr->ifr_data)->RxTcCrcLen ) {
+                    case 16: RX_GAMMA_ITF_CFG(0)->rx_tc_crc_size = 1; break;
+                    case 32: RX_GAMMA_ITF_CFG(0)->rx_tc_crc_size = 2; break;
+                    default: RX_GAMMA_ITF_CFG(0)->rx_tc_crc_size = 0;
+                }
+
+                TX_GAMMA_ITF_CFG(0)->tx_eth_fcs_gen_dis = ((IFX_PTM_CFG_T *)ifr->ifr_data)->TxEthCrcGen ? 0 : 1;
+
+                if ( ((IFX_PTM_CFG_T *)ifr->ifr_data)->TxTcCrcGen ) {
+                    switch ( ((IFX_PTM_CFG_T *)ifr->ifr_data)->TxTcCrcLen ) {
+                        case 16: TX_GAMMA_ITF_CFG(0)->tx_tc_crc_size = 1; break;
+                        case 32: TX_GAMMA_ITF_CFG(0)->tx_tc_crc_size = 2; break;
+                        default: TX_GAMMA_ITF_CFG(0)->tx_tc_crc_size = 0;
+                    }
+                }
+                else
+                    TX_GAMMA_ITF_CFG(0)->tx_tc_crc_size = 0;
+            }
+        }
+        break;
+    case IFX_PTM_MAP_PKT_PRIO_TO_Q:
+        {
+            struct ppe_prio_q_map cmd;
+
+            if ( copy_from_user(&cmd, ifr->ifr_data, sizeof(cmd)) )
+                return -EFAULT;
+
+            if ( cmd.pkt_prio < 0 || cmd.pkt_prio >= NUM_ENTITY(g_ptm_prio_queue_map) )
+                return -EINVAL;
+
+            if ( cmd.qid < 0 || cmd.qid >= g_wanqos_en )
+                return -EINVAL;
+
+            g_ptm_prio_queue_map[cmd.pkt_prio] = cmd.qid;
+        }
+        break;
+    default:
+        return -EOPNOTSUPP;
+    }
+
+    return 0;
+}
+
+static void ptm_tx_timeout(struct net_device *dev)
+{
+    ASSERT(dev == g_net_dev[0], "incorrect device");
+
+    /*  disable TX irq, release skb when sending new packet */
+    IFX_REG_W32_MASK(1 << 17, 0, MBOX_IGU1_IER);
+
+    /*  wake up TX queue    */
+    netif_wake_queue(dev);
+
+    return;
+}
+
+static INLINE void adsl_led_flash(void)
+{
+#if defined(ENABLE_LED_FRAMEWORK) && ENABLE_LED_FRAMEWORK
+    if ( g_data_led_trigger != NULL )
+        ifx_led_trigger_activate(g_data_led_trigger);
+#else
+    return ifx_mei_atm_led_blink();
+#endif
+}
+
+static INLINE struct sk_buff* alloc_skb_rx(void)
+{
+    struct sk_buff *skb;
+
+    /*  allocate memroy including trailer and padding   */
+    skb = dev_alloc_skb(RX_MAX_BUFFER_SIZE + DATA_BUFFER_ALIGNMENT);
+    if ( skb != NULL ) {
+        /*  must be burst length alignment and reserve two more bytes for MAC address alignment  */
+        if ( ((unsigned int)skb->data & (DATA_BUFFER_ALIGNMENT - 1)) != 0 )
+            skb_reserve(skb, ~((unsigned int)skb->data + (DATA_BUFFER_ALIGNMENT - 1)) & (DATA_BUFFER_ALIGNMENT - 1));
+        /*  pub skb in reserved area "skb->data - 4"    */
+        *((struct sk_buff **)skb->data - 1) = skb;
+        wmb();
+        /*  write back and invalidate cache    */
+        dma_cache_sync(NULL, (void *)((unsigned long)skb->data - sizeof(skb)), sizeof(skb), DMA_BIDIRECTIONAL);
+        /*  invalidate cache    */
+        dma_cache_sync(NULL, skb->data, (unsigned int)skb->end - (unsigned int)skb->data, DMA_FROM_DEVICE);
+    }
+
+    return skb;
+}
+
+static INLINE struct sk_buff* alloc_skb_tx(unsigned int size)
+{
+    struct sk_buff *skb;
+
+    /*  allocate memory including padding   */
+    size = RX_MAX_BUFFER_SIZE;
+    size = (size + DATA_BUFFER_ALIGNMENT - 1) & ~(DATA_BUFFER_ALIGNMENT - 1);
+    skb = dev_alloc_skb(size + DATA_BUFFER_ALIGNMENT);
+    /*  must be burst length alignment  */
+    if ( skb != NULL )
+        skb_reserve(skb, ~((unsigned int)skb->data + (DATA_BUFFER_ALIGNMENT - 1)) & (DATA_BUFFER_ALIGNMENT - 1));
+    return skb;
+}
+
+static INLINE struct sk_buff *get_skb_pointer(unsigned int dataptr)
+{
+    unsigned int skb_dataptr;
+    struct sk_buff *skb;
+
+    //  usually, CPE memory is less than 256M bytes
+    //  so NULL means invalid pointer
+    if ( dataptr == 0 ) {
+        dbg("dataptr is 0, it's supposed to be invalid pointer");
+        return NULL;
+    }
+
+    skb_dataptr = (dataptr - 4) | KSEG1;
+    skb = *(struct sk_buff **)skb_dataptr;
+
+    ASSERT((unsigned int)skb >= KSEG0, "invalid skb - skb = %#08x, dataptr = %#08x", (unsigned int)skb, dataptr);
+    ASSERT((((unsigned int)skb->data & (0x0FFFFFFF ^ (DATA_BUFFER_ALIGNMENT - 1))) | KSEG1) == (dataptr | KSEG1), "invalid skb - skb = %#08x, skb->data = %#08x, dataptr = %#08x", (unsigned int)skb, (unsigned int)skb->data, dataptr);
+
+    return skb;
+}
+
+static INLINE int get_tx_desc(unsigned int itf, unsigned int *f_full)
+{
+    int desc_base = -1;
+    struct ptm_itf *p_itf = &g_ptm_priv_data.itf[0];
+
+    //  assume TX is serial operation
+    //  no protection provided
+
+    *f_full = 1;
+
+    if ( CPU_TO_WAN_TX_DESC_BASE[p_itf->tx_desc_pos].own == 0 ) {
+        desc_base = p_itf->tx_desc_pos;
+        if ( ++(p_itf->tx_desc_pos) == CPU_TO_WAN_TX_DESC_NUM )
+            p_itf->tx_desc_pos = 0;
+        if ( CPU_TO_WAN_TX_DESC_BASE[p_itf->tx_desc_pos].own == 0 )
+            *f_full = 0;
+    }
+
+    return desc_base;
+}
+
+static irqreturn_t mailbox_irq_handler(int irq, void *dev_id)
+{
+    unsigned int isr;
+    int i;
+
+    isr = IFX_REG_R32(MBOX_IGU1_ISR);
+    IFX_REG_W32(isr, MBOX_IGU1_ISRC);
+    isr &= IFX_REG_R32(MBOX_IGU1_IER);
+
+    while ( (i = clz(isr)) >= 0 ) {
+        isr ^= 1 << i;
+
+        switch ( i ) {
+            case 0:     //  RX
+#if defined(CONFIG_LTQ_PTM_RX_NAPI)
+                IFX_REG_W32_MASK(1, 0, MBOX_IGU1_IER);
+  #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+                netif_rx_schedule(g_net_dev[0]);
+  #else
+                napi_schedule(&g_ptm_priv_data.itf[0].napi);
+  #endif
+#endif
+#if defined(ENABLE_TMP_DBG) && ENABLE_TMP_DBG
+                {
+                    volatile struct rx_descriptor *desc = &WAN_RX_DESC_BASE[g_ptm_priv_data.itf[0].rx_desc_pos];
+
+                    if ( desc->own ) {  //  PP32 hold
+                        err("invalid interrupt");
+                    }
+                }
+#endif
+                break;
+            case 16:    //  SWAP
+                IFX_REG_W32_MASK(1 << 16, 0, MBOX_IGU1_IER);
+                tasklet_hi_schedule(&g_swap_desc_tasklet);
+                break;
+            case 17:    //  TX
+                IFX_REG_W32_MASK(1 << 17, 0, MBOX_IGU1_IER);
+                netif_wake_queue(g_net_dev[0]);
+                break;
+        }
+    }
+
+    return IRQ_HANDLED;
+}
+
+static void do_swap_desc_tasklet(unsigned long arg)
+{
+    int budget = 32;
+    volatile struct tx_descriptor *desc;
+    struct sk_buff *skb;
+    unsigned int byteoff;
+
+    while ( budget-- > 0 ) {
+        if ( WAN_SWAP_DESC_BASE[g_ptm_priv_data.itf[0].tx_swap_desc_pos].own )  //  if PP32 hold descriptor
+            break;
+
+        desc = &WAN_SWAP_DESC_BASE[g_ptm_priv_data.itf[0].tx_swap_desc_pos];
+        if ( ++g_ptm_priv_data.itf[0].tx_swap_desc_pos == WAN_SWAP_DESC_NUM )
+            g_ptm_priv_data.itf[0].tx_swap_desc_pos = 0;
+
+        skb = get_skb_pointer(desc->dataptr);
+        if ( skb != NULL )
+            dev_kfree_skb_any(skb);
+
+        skb = alloc_skb_tx(RX_MAX_BUFFER_SIZE);
+        if ( skb == NULL )
+            panic("can't allocate swap buffer for PPE firmware use\n");
+        byteoff = (unsigned int)skb->data & (DATA_BUFFER_ALIGNMENT - 1);
+        *(struct sk_buff **)((unsigned int)skb->data - byteoff - sizeof(struct sk_buff *)) = skb;
+
+        desc->dataptr = (unsigned int)skb->data & 0x0FFFFFFF;
+        desc->own = 1;
+    }
+
+    //  clear interrupt
+    IFX_REG_W32_MASK(0, 16, MBOX_IGU1_ISRC);
+    //  no more skb to be replaced
+    if ( WAN_SWAP_DESC_BASE[g_ptm_priv_data.itf[0].tx_swap_desc_pos].own ) {    //  if PP32 hold descriptor
+        IFX_REG_W32_MASK(0, 1 << 16, MBOX_IGU1_IER);
+        return;
+    }
+
+    tasklet_hi_schedule(&g_swap_desc_tasklet);
+    return;
+}
+
+#if defined(DEBUG_DUMP_SKB) && DEBUG_DUMP_SKB
+static void dump_skb(struct sk_buff *skb, u32 len, char *title, int port, int ch, int is_tx)
+{
+    int i;
+
+    if ( !(ifx_ptm_dbg_enable & (is_tx ? DBG_ENABLE_MASK_DUMP_SKB_TX : DBG_ENABLE_MASK_DUMP_SKB_RX)) )
+        return;
+
+    if ( skb->len < len )
+        len = skb->len;
+
+    if ( len > ETH_MAX_FRAME_LENGTH ) {
+        printk("too big data length: skb = %08x, skb->data = %08x, skb->len = %d\n", (u32)skb, (u32)skb->data, skb->len);
+        return;
+    }
+
+    if ( ch >= 0 )
+        printk("%s (port %d, ch %d)\n", title, port, ch);
+    else
+        printk("%s\n", title);
+    printk("  skb->data = %08X, skb->tail = %08X, skb->len = %d\n", (u32)skb->data, (u32)skb->tail, (int)skb->len);
+    for ( i = 1; i <= len; i++ ) {
+        if ( i % 16 == 1 )
+            printk("  %4d:", i - 1);
+        printk(" %02X", (int)(*((char*)skb->data + i - 1) & 0xFF));
+        if ( i % 16 == 0 )
+            printk("\n");
+    }
+    if ( (i - 1) % 16 != 0 )
+        printk("\n");
+}
+#endif
+
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+static void skb_swap(struct sk_buff *skb)
+{
+    unsigned char tmp[8];
+    unsigned char *p = skb->data;
+
+    if ( p[12] == 0x08 && p[13] == 0x06 ) { //  arp
+        if ( p[14] == 0x00 && p[15] == 0x01 && p[16] == 0x08 && p[17] == 0x00 && p[20] == 0x00 && p[21] == 0x01 ) {
+            //  dest mac
+            memcpy(p, p + 6, 6);
+            //  src mac
+            p[6] = p[7] = 0;
+            memcpy(p + 8, p + 38, 4);
+            //  arp reply
+            p[21] = 0x02;
+            //  sender mac
+            memcpy(p + 22, p + 6, 6);
+            //  sender IP
+            memcpy(tmp, p + 28, 4);
+            memcpy(p + 28, p + 38, 4);
+            //  target mac
+            memcpy(p + 32, p, 6);
+            //  target IP
+            memcpy(p + 38, tmp, 4);
+
+            dma_cache_sync(NULL, skb->data, 42, DMA_TO_DEVICE);
+        }
+    }
+    else if ( !(p[0] & 0x01) ) { //  bypass broadcast/multicast
+        //  swap MAC
+        memcpy(tmp, p, 6);
+        memcpy(p, p + 6, 6);
+        memcpy(p + 6, tmp, 6);
+        p += 12;
+
+        //  bypass VLAN
+        while ( p[0] == 0x81 && p[1] == 0x00 )
+            p += 4;
+
+        //  IP
+        if ( p[0] == 0x08 && p[1] == 0x00 ) {
+            p += 14;
+            memcpy(tmp, p, 4);
+            memcpy(p, p + 4, 4);
+            memcpy(p + 4, tmp, 4);
+            p += 8;
+        }
+
+        dma_cache_sync(NULL, skb->data, (unsigned long)p - (unsigned long)skb->data, DMA_TO_DEVICE);
+    }
+}
+#endif
+
+static INLINE void proc_file_create(void)
+{
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+    struct proc_dir_entry *res;
+#endif
+
+    g_ptm_dir = proc_mkdir("driver/ifx_ptm", NULL);
+
+    create_proc_read_entry("version",
+                            0,
+                            g_ptm_dir,
+                            proc_read_version,
+                            NULL);
+
+    res = create_proc_entry("wanmib",
+                            0,
+                            g_ptm_dir);
+    if ( res )
+    {
+        res->read_proc  = proc_read_wanmib;
+        res->write_proc = proc_write_wanmib;
+    }
+
+    res = create_proc_entry("prio",
+                            0,
+                            g_ptm_dir);
+    if ( res )
+    {
+        res->read_proc  = proc_read_prio;
+        res->write_proc = proc_write_prio;
+    }
+
+    res = create_proc_entry("qos",
+                            0,
+                            g_ptm_dir);
+    if ( res )
+        res->read_proc  = proc_read_qos;
+
+    res = create_proc_entry("gamma",
+                            0,
+                            g_ptm_dir);
+    if ( res )
+        res->read_proc  = proc_read_gamma;
+
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+    res = create_proc_entry("dbg",
+                            0,
+                            g_ptm_dir);
+    if ( res )
+    {
+        res->read_proc  = proc_read_dbg;
+        res->write_proc = proc_write_dbg;
+    }
+#endif
+
+#if defined(ENABLE_TMP_DBG) && ENABLE_TMP_DBG
+    res = create_proc_entry("rdptr",
+                            0,
+                            g_ptm_dir);
+    if ( res )
+        res->read_proc  = proc_read_rdptr;
+#endif
+}
+
+static INLINE void proc_file_delete(void)
+{
+#if defined(ENABLE_TMP_DBG) && ENABLE_TMP_DBG
+    remove_proc_entry("rdptr", g_ptm_dir);
+#endif
+
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+    remove_proc_entry("dbg", g_ptm_dir);
+#endif
+
+    remove_proc_entry("gamma", g_ptm_dir);
+
+    remove_proc_entry("qos", g_ptm_dir);
+
+    remove_proc_entry("prio", g_ptm_dir);
+
+    remove_proc_entry("wanmib", g_ptm_dir);
+
+    remove_proc_entry("version", g_ptm_dir);
+
+    remove_proc_entry("driver/ifx_ptm", NULL);
+}
+
+static int proc_read_version(char *buf, char **start, off_t offset, int count, int *eof, void *data)
+{
+    int len = 0;
+
+    len += ifx_ptm_version(buf + len);
+
+    if ( offset >= len ) {
+        *start = buf;
+        *eof = 1;
+        return 0;
+    }
+    *start = buf + offset;
+    if ( (len -= offset) > count )
+        return count;
+    *eof = 1;
+    return len;
+}
+
+static int proc_read_wanmib(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int len = 0;
+    volatile unsigned int *wrx_total_pdu[4] = {DREG_AR_AIIDLE_CNT0, DREG_AR_HEC_CNT0, DREG_AR_AIIDLE_CNT1, DREG_AR_HEC_CNT1};
+    volatile unsigned int *wrx_err_pdu[4] = {DREG_AR_CERRN_CNT0, DREG_AR_CERRN_CNT1, DREG_AR_CERRNP_CNT0, DREG_AR_CERRNP_CNT1};
+    int i;
+
+    len += sprintf(page + off + len, "RX:\n");
+    len += sprintf(page + off + len, "  wrx_total_pdu:   ");
+    for ( i = 0; i < 4; i++ ) {
+        if ( i != 0 )
+            len += sprintf(page + off + len, ", ");
+        len += sprintf(page + off + len, "%10u", IFX_REG_R32(wrx_total_pdu[i]) - g_wrx_total_pdu[i]);
+    }
+    len += sprintf(page + off + len, "\n");
+    len += sprintf(page + off + len, "  wrx_dropdes_pdu: ");
+    for ( i = 0; i < 4; i++ ) {
+        if ( i != 0 )
+            len += sprintf(page + off + len, ", ");
+        len += sprintf(page + off + len, "%10u", WAN_RX_MIB_TABLE(i)->wrx_dropdes_pdu);
+    }
+    len += sprintf(page + off + len, "\n");
+    len += sprintf(page + off + len, "  wrx_err_pdu:     ");
+    for ( i = 0; i < 4; i++ ) {
+        if ( i != 0 )
+            len += sprintf(page + off + len, ", ");
+        len += sprintf(page + off + len, "%10u", IFX_REG_R32(wrx_err_pdu[i]) - g_wrx_err_pdu[i]);
+    }
+    len += sprintf(page + off + len, "\n");
+    len += sprintf(page + off + len, "  wrx_total_bytes: ");
+    for ( i = 0; i < 4; i++ ) {
+        if ( i != 0 )
+            len += sprintf(page + off + len, ", ");
+        len += sprintf(page + off + len, "%10u", WAN_RX_MIB_TABLE(i)->wrx_total_bytes);
+    }
+    len += sprintf(page + off + len, "\n");
+
+    len += sprintf(page + off + len, "TX:\n");
+    len += sprintf(page + off + len, "  wrx_total_pdu:           ");
+    for ( i = 0; i < 8; i++ ) {
+        if ( i != 0 )
+            len += sprintf(page + off + len, ", ");
+        len += sprintf(page + off + len, "%10u", WAN_TX_MIB_TABLE(i)->wrx_total_pdu);
+    }
+    len += sprintf(page + off + len, "\n");
+    len += sprintf(page + off + len, "  wrx_total_bytes:         ");
+    for ( i = 0; i < 8; i++ ) {
+        if ( i != 0 )
+            len += sprintf(page + off + len, ", ");
+        len += sprintf(page + off + len, "%10u", WAN_TX_MIB_TABLE(i)->wrx_total_bytes);
+    }
+    len += sprintf(page + off + len, "\n");
+    len += sprintf(page + off + len, "  wtx_total_pdu:           ");
+    for ( i = 0; i < 8; i++ ) {
+        if ( i != 0 )
+            len += sprintf(page + off + len, ", ");
+        len += sprintf(page + off + len, "%10u", WAN_TX_MIB_TABLE(i)->wtx_total_pdu);
+    }
+    len += sprintf(page + off + len, "\n");
+    len += sprintf(page + off + len, "  wtx_total_bytes:         ");
+    for ( i = 0; i < 8; i++ ) {
+        if ( i != 0 )
+            len += sprintf(page + off + len, ", ");
+        len += sprintf(page + off + len, "%10u", WAN_TX_MIB_TABLE(i)->wtx_total_bytes);
+    }
+    len += sprintf(page + off + len, "\n");
+    len += sprintf(page + off + len, "  wtx_cpu_dropdes_pdu:     ");
+    for ( i = 0; i < 8; i++ ) {
+        if ( i != 0 )
+            len += sprintf(page + off + len, ", ");
+        len += sprintf(page + off + len, "%10u", WAN_TX_MIB_TABLE(i)->wtx_cpu_dropdes_pdu);
+    }
+    len += sprintf(page + off + len, "\n");
+    len += sprintf(page + off + len, "  wtx_cpu_dropsmall_pdu:   ");
+    for ( i = 0; i < 8; i++ ) {
+        if ( i != 0 )
+            len += sprintf(page + off + len, ", ");
+        len += sprintf(page + off + len, "%10u", WAN_TX_MIB_TABLE(i)->wtx_cpu_dropsmall_pdu);
+    }
+    len += sprintf(page + off + len, "\n");
+    len += sprintf(page + off + len, "  wtx_fast_dropdes_pdu:    ");
+    for ( i = 0; i < 8; i++ ) {
+        if ( i != 0 )
+            len += sprintf(page + off + len, ", ");
+        len += sprintf(page + off + len, "%10u", WAN_TX_MIB_TABLE(i)->wtx_fast_dropdes_pdu);
+    }
+    len += sprintf(page + off + len, "\n");
+    len += sprintf(page + off + len, "  wtx_fast_dropsmall_pdu:  ");
+    for ( i = 0; i < 8; i++ ) {
+        if ( i != 0 )
+            len += sprintf(page + off + len, ", ");
+        len += sprintf(page + off + len, "%10u", WAN_TX_MIB_TABLE(i)->wtx_fast_dropsmall_pdu);
+    }
+    len += sprintf(page + off + len, "\n");
+
+    *eof = 1;
+
+    return len;
+}
+
+static int proc_write_wanmib(struct file *file, const char *buf, unsigned long count, void *data)
+{
+    char str[2048];
+    char *p;
+    int len, rlen;
+
+    volatile unsigned int *wrx_total_pdu[4] = {DREG_AR_AIIDLE_CNT0, DREG_AR_HEC_CNT0, DREG_AR_AIIDLE_CNT1, DREG_AR_HEC_CNT1};
+    volatile unsigned int *wrx_err_pdu[4] = {DREG_AR_CERRN_CNT0, DREG_AR_CERRN_CNT1, DREG_AR_CERRNP_CNT0, DREG_AR_CERRNP_CNT1};
+    int i;
+
+    len = count < sizeof(str) ? count : sizeof(str) - 1;
+    rlen = len - copy_from_user(str, buf, len);
+    while ( rlen && str[rlen - 1] <= ' ' )
+        rlen--;
+    str[rlen] = 0;
+    for ( p = str; *p && *p <= ' '; p++, rlen-- );
+    if ( !*p )
+        return count;
+
+    if ( stricmp(p, "clear") == 0 || stricmp(p, "clean") == 0 ) {
+        void *tmp;
+        for ( i = 0; i < 4; i++ ) {
+            tmp = (void*)WAN_RX_MIB_TABLE(i);
+            memset(tmp, 0, sizeof(*WAN_RX_MIB_TABLE(i)));
+            g_wrx_total_pdu[i] = IFX_REG_R32(wrx_total_pdu[i]);
+            g_wrx_err_pdu[i] = IFX_REG_R32(wrx_err_pdu[i]);
+        }
+        for ( i = 0; i < 8; i++ ) {
+            tmp = (void*)WAN_TX_MIB_TABLE(i);
+            memset(tmp, 0, sizeof(*WAN_TX_MIB_TABLE(i)));
+        }
+    }
+
+    return count;
+}
+
+static int proc_read_prio(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int len = 0;
+    int j;
+
+    len += sprintf(page + off + len,        "Priority to Queue Map:\n");
+    len += sprintf(page + off + len,        "  prio     :  0  1  2  3  4  5  6  7\n");
+    len += sprintf(page + off + len,    "  ptm0     :");
+    for ( j = 0; j < NUM_ENTITY(g_ptm_prio_queue_map); j++ )
+        len += sprintf(page + off + len,"  %d", g_ptm_prio_queue_map[j]);
+    len += sprintf(page + off + len,    "\n");
+
+    *eof = 1;
+
+    return len;
+}
+
+static int proc_write_prio(struct file *file, const char *buf, unsigned long count, void *data)
+{
+    char local_buf[2048];
+    int len;
+    char *p1, *p2;
+    int colon = 1;
+    unsigned int port = ~0;
+    int prio = -1;
+    int queue = -1;
+
+    len = sizeof(local_buf) < count ? sizeof(local_buf) - 1 : count;
+    len = len - copy_from_user(local_buf, buf, len);
+    local_buf[len] = 0;
+
+    p1 = local_buf;
+    while ( get_token(&p1, &p2, &len, &colon) )
+    {
+        if ( stricmp(p1, "help") == 0 )
+        {
+            printk("echo <ptm0> prio xx queue xx [prio xx queue xx] > /proc/driver/ifx_ptm/prio\n");
+            break;
+        }
+        else if ( stricmp(p1, "eth0") == 0 )
+        {
+            printk("eth0 is not valid\n");
+            prio = queue = -1;
+        }
+        else if ( stricmp(p1, "eth1") == 0 )
+        {
+            printk("eth1 is not valid\n");
+            prio = queue = -1;
+        }
+        else if ( stricmp(p1, "ptm0") == 0 )
+        {
+            port = 2;
+            prio = queue = -1;
+            printk("port = 2 (PTM0)\n");
+        }
+        else if ( stricmp(p1, "pvc") == 0 )
+        {
+            printk("atm is not valid\n");
+            prio = queue = -1;
+        }
+        else if ( port != ~0 )
+        {
+            if ( stricmp(p1, "p") == 0 || stricmp(p1, "prio") == 0 )
+            {
+                ignore_space(&p2, &len);
+                prio = get_number(&p2, &len, 0);
+                printk("prio = %d\n", prio);
+                if ( port == 2 )
+                {
+                    if ( prio >= 0 && prio <  NUM_ENTITY(g_ptm_prio_queue_map) )
+                    {
+                        if ( queue >= 0 )
+                            g_ptm_prio_queue_map[prio] = queue;
+                    }
+                    else
+                        printk("prio (%d) is out of range 0 - %d\n", prio, NUM_ENTITY(g_ptm_prio_queue_map) - 1);
+                }
+            }
+            else if ( stricmp(p1, "q") == 0 || stricmp(p1, "queue") == 0 )
+            {
+                ignore_space(&p2, &len);
+                queue = get_number(&p2, &len, 0);
+                printk("queue = %d\n", queue);
+                if ( port == 2 )
+                {
+                    if ( queue >= 0 && queue < g_wanqos_en )
+                    {
+                        if ( prio >= 0 )
+                            g_ptm_prio_queue_map[prio] = queue;
+                    }
+                    else
+                        printk("queue (%d) is out of range 0 - %d\n", queue, g_wanqos_en - 1);
+                }
+            }
+            else
+                printk("unknown command (%s)\n", p1);
+        }
+        else
+            printk("unknown command (%s)\n", p1);
+
+        p1 = p2;
+        colon = 1;
+    }
+
+    return count;
+}
+
+static int proc_read_qos(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int len = 0;
+    int len_max = off + count;
+    char *pstr;
+    char str[200];
+    int llen;
+    int i;
+    struct wan_tx_mib_table qos_queue_mib;
+    volatile struct tx_qos_cfg tx_qos_cfg = *TX_QOS_CFG;
+    volatile struct wtx_qos_q_desc_cfg qos_q_desc_cfg;
+
+    pstr = *start = page;
+
+    __sync();
+
+    llen = sprintf(pstr, "\n  qos         : %s\n  wfq         : %s\n  Rate shaping: %s\n\n",
+                    tx_qos_cfg.eth1_qss ?"enabled":"disabled",
+                    tx_qos_cfg.wfq_en?"enabled":"disabled",
+                    tx_qos_cfg.shape_en ?"enabled":"disabled");
+    pstr += llen;
+    len += llen;
+
+    llen = sprintf(pstr, "  Ticks  =%u,    overhd    =%u,       qnum=%u  @%p\n", (u32)tx_qos_cfg.time_tick, (u32)tx_qos_cfg.overhd_bytes, (u32)tx_qos_cfg.eth1_eg_qnum, TX_QOS_CFG );
+    pstr += llen;
+    len += llen;
+
+    //llen = sprintf(pstr, "  PPE clk=%u MHz, basic tick=%u\n", (u32)cgu_get_pp32_clock() / 1000000, TX_QOS_CFG->time_tick / (cgu_get_pp32_clock() / 1000000));
+    pstr += llen;
+    len += llen;
+
+    if ( tx_qos_cfg.eth1_eg_qnum )
+    {
+        llen = sprintf(pstr, "\n  MIB : rx_pkt/rx_bytes         tx_pkt/tx_bytes       cpu_small_drop/cpu_drop  fast_small_drop/fast_drop_cnt\n");
+        pstr += llen;
+        len += llen;
+        for ( i = 0; i < 8; i++ )
+        {
+            qos_queue_mib = *WAN_TX_MIB_TABLE(i);
+
+            llen = sprintf(str, "    %2u: %010u/%010u  %010u/%010u  %010u/%010u  %010u/%010u  @0x%p\n", i,
+                qos_queue_mib.wrx_total_pdu, qos_queue_mib.wrx_total_bytes,
+                qos_queue_mib.wtx_total_pdu, qos_queue_mib.wtx_total_bytes,
+                qos_queue_mib.wtx_cpu_dropsmall_pdu, qos_queue_mib.wtx_cpu_dropdes_pdu,
+                qos_queue_mib.wtx_fast_dropsmall_pdu, qos_queue_mib.wtx_fast_dropdes_pdu,
+                WAN_TX_MIB_TABLE(i));
+
+            if ( len <= off && len + llen > off )
+            {
+                memcpy(pstr, str + off - len, len + llen - off);
+                pstr += len + llen - off;
+            }
+            else if ( len > off )
+            {
+                memcpy(pstr, str, llen);
+                pstr += llen;
+            }
+            len += llen;
+            if ( len >= len_max )
+                goto PROC_READ_MAC_OVERRUN_END;
+        }
+
+
+        //QOS queue descriptor
+        llen = sprintf(pstr, "\n  Desc: threshold  num    base_addr  rd_ptr   wr_ptr\n");
+        pstr += llen;
+        len += llen;
+        for ( i = 0; i < 8; i++ )
+        {
+            qos_q_desc_cfg = *WTX_QOS_Q_DESC_CFG(i);
+
+            llen = sprintf(pstr, "    %2u: 0x%02x       0x%02x   0x%04x     0x%04x   0x%04x  @0x%p\n", i,
+                qos_q_desc_cfg.threshold,
+                qos_q_desc_cfg.length,
+                qos_q_desc_cfg.addr,
+                qos_q_desc_cfg.rd_ptr,
+                qos_q_desc_cfg.wr_ptr,
+                WTX_QOS_Q_DESC_CFG(i) );
+
+            pstr += llen;
+            len += llen;
+        }
+    }
+
+    *eof = 1;
+
+    return len - off;
+
+PROC_READ_MAC_OVERRUN_END:
+    return len - llen - off;
+}
+
+static int proc_read_gamma(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int len = 0;
+
+    len += sprintf(page + off + len, "PSAVE_CFG     (0x%08X): start_state - %s, sleep_en - %s\n", (unsigned int)PSAVE_CFG, PSAVE_CFG->start_state ? "partial reset" : "full reset", PSAVE_CFG->sleep_en ? "on" : "off");
+    len += sprintf(page + off + len, "EG_BWCTRL_CFG (0x%08X): fdesc_wm - %d, class_len - %d\n", (unsigned int)EG_BWCTRL_CFG, EG_BWCTRL_CFG->fdesc_wm, EG_BWCTRL_CFG->class_len);
+    len += sprintf(page + off + len, "TEST_MODE     (0x%08X): mib_clear_mode - %s, test_mode - %s\n", (unsigned int)TEST_MODE, TEST_MODE->mib_clear_mode ? "on" : "off", TEST_MODE->test_mode ? "on" : "off");
+    len += sprintf(page + off + len, "RX_BC_CFG:\t0x%08x\t0x%08x\n",   (unsigned int)RX_BC_CFG(0),                (unsigned int)RX_BC_CFG(1));
+    len += sprintf(page + off + len, "  local_state:    %8d\t  %8d\n", (unsigned int)RX_BC_CFG(0)->local_state,   (unsigned int)RX_BC_CFG(1)->local_state);
+    len += sprintf(page + off + len, "  remote_state:   %8d\t  %8d\n", (unsigned int)RX_BC_CFG(0)->remote_state,  (unsigned int)RX_BC_CFG(1)->remote_state);
+    len += sprintf(page + off + len, "  to_false_th:    %8d\t  %8d\n", (unsigned int)RX_BC_CFG(0)->to_false_th,   (unsigned int)RX_BC_CFG(1)->to_false_th);
+    len += sprintf(page + off + len, "  to_looking_th:  %8d\t  %8d\n", (unsigned int)RX_BC_CFG(0)->to_looking_th, (unsigned int)RX_BC_CFG(1)->to_looking_th);
+    len += sprintf(page + off + len, "TX_BC_CFG:\t0x%08x\t0x%08x\n",   (unsigned int)TX_BC_CFG(0),                (unsigned int)TX_BC_CFG(1));
+    len += sprintf(page + off + len, "  fill_wm:\t  %8d\t  %8d\n", (unsigned int)TX_BC_CFG(0)->fill_wm,   (unsigned int)TX_BC_CFG(1)->fill_wm);
+    len += sprintf(page + off + len, "  uflw_wm:\t  %8d\t  %8d\n", (unsigned int)TX_BC_CFG(0)->uflw_wm,   (unsigned int)TX_BC_CFG(1)->uflw_wm);
+    len += sprintf(page + off + len, "RX_GAMMA_ITF_CFG:\t0x%08x\t0x%08x\t0x%08x\t0x%08x\n",       (unsigned int)RX_GAMMA_ITF_CFG(0),                        (unsigned int)RX_GAMMA_ITF_CFG(1),                        (unsigned int)RX_GAMMA_ITF_CFG(2),                        (unsigned int)RX_GAMMA_ITF_CFG(3));
+    len += sprintf(page + off + len, "  receive_state: \t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)RX_GAMMA_ITF_CFG(0)->receive_state,         (unsigned int)RX_GAMMA_ITF_CFG(1)->receive_state,         (unsigned int)RX_GAMMA_ITF_CFG(2)->receive_state,         (unsigned int)RX_GAMMA_ITF_CFG(3)->receive_state);
+    len += sprintf(page + off + len, "  rx_min_len:    \t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_min_len,            (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_min_len,            (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_min_len,            (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_min_len);
+    len += sprintf(page + off + len, "  rx_pad_en:     \t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_pad_en,             (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_pad_en,             (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_pad_en,             (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_pad_en);
+    len += sprintf(page + off + len, "  rx_eth_fcs_ver_dis:\t  %8d\t  %8d\t  %8d\t  %8d\n",       (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_eth_fcs_ver_dis,    (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_eth_fcs_ver_dis,    (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_eth_fcs_ver_dis,    (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_eth_fcs_ver_dis);
+    len += sprintf(page + off + len, "  rx_rm_eth_fcs: \t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_rm_eth_fcs,         (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_rm_eth_fcs,         (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_rm_eth_fcs,         (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_rm_eth_fcs);
+    len += sprintf(page + off + len, "  rx_tc_crc_ver_dis:\t  %8d\t  %8d\t  %8d\t  %8d\n",        (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_tc_crc_ver_dis,     (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_tc_crc_ver_dis,     (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_tc_crc_ver_dis,     (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_tc_crc_ver_dis);
+    len += sprintf(page + off + len, "  rx_tc_crc_size:\t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_tc_crc_size,        (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_tc_crc_size,        (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_tc_crc_size,        (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_tc_crc_size);
+    len += sprintf(page + off + len, "  rx_eth_fcs_result:\t0x%8X\t0x%8X\t0x%8X\t0x%8X\n",        (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_eth_fcs_result,     (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_eth_fcs_result,     (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_eth_fcs_result,     (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_eth_fcs_result);
+    len += sprintf(page + off + len, "  rx_tc_crc_result:\t0x%8X\t0x%8X\t0x%8X\t0x%8X\n",         (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_tc_crc_result,      (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_tc_crc_result,      (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_tc_crc_result,      (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_tc_crc_result);
+    len += sprintf(page + off + len, "  rx_crc_cfg:    \t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_crc_cfg,            (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_crc_cfg,            (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_crc_cfg,            (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_crc_cfg);
+    len += sprintf(page + off + len, "  rx_eth_fcs_init_value:0x%08X\t0x%08X\t0x%08X\t0x%08X\n",  (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_eth_fcs_init_value, (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_eth_fcs_init_value, (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_eth_fcs_init_value, (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_eth_fcs_init_value);
+    len += sprintf(page + off + len, "  rx_tc_crc_init_value:\t0x%08X\t0x%08X\t0x%08X\t0x%08X\n", (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_tc_crc_init_value,  (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_tc_crc_init_value,  (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_tc_crc_init_value,  (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_tc_crc_init_value);
+    len += sprintf(page + off + len, "  rx_max_len_sel:\t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_max_len_sel,        (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_max_len_sel,        (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_max_len_sel,        (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_max_len_sel);
+    len += sprintf(page + off + len, "  rx_edit_num2:  \t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_edit_num2,          (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_edit_num2,          (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_edit_num2,          (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_edit_num2);
+    len += sprintf(page + off + len, "  rx_edit_pos2:  \t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_edit_pos2,          (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_edit_pos2,          (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_edit_pos2,          (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_edit_pos2);
+    len += sprintf(page + off + len, "  rx_edit_type2: \t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_edit_type2,         (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_edit_type2,         (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_edit_type2,         (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_edit_type2);
+    len += sprintf(page + off + len, "  rx_edit_en2:   \t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_edit_en2,           (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_edit_en2,           (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_edit_en2,           (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_edit_en2);
+    len += sprintf(page + off + len, "  rx_edit_num1:  \t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_edit_num1,          (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_edit_num1,          (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_edit_num1,          (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_edit_num1);
+    len += sprintf(page + off + len, "  rx_edit_pos1:  \t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_edit_pos1,          (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_edit_pos1,          (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_edit_pos1,          (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_edit_pos1);
+    len += sprintf(page + off + len, "  rx_edit_type1: \t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_edit_type1,         (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_edit_type1,         (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_edit_type1,         (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_edit_type1);
+    len += sprintf(page + off + len, "  rx_edit_en1:   \t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_edit_en1,           (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_edit_en1,           (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_edit_en1,           (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_edit_en1);
+    len += sprintf(page + off + len, "  rx_inserted_bytes_1l:\t0x%08X\t0x%08X\t0x%08X\t0x%08X\n", (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_inserted_bytes_1l,  (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_inserted_bytes_1l,  (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_inserted_bytes_1l,  (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_inserted_bytes_1l);
+    len += sprintf(page + off + len, "  rx_inserted_bytes_1h:\t0x%08X\t0x%08X\t0x%08X\t0x%08X\n", (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_inserted_bytes_1h,  (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_inserted_bytes_1h,  (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_inserted_bytes_1h,  (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_inserted_bytes_1h);
+    len += sprintf(page + off + len, "  rx_inserted_bytes_2l:\t0x%08X\t0x%08X\t0x%08X\t0x%08X\n", (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_inserted_bytes_2l,  (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_inserted_bytes_2l,  (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_inserted_bytes_2l,  (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_inserted_bytes_2l);
+    len += sprintf(page + off + len, "  rx_inserted_bytes_2h:\t0x%08X\t0x%08X\t0x%08X\t0x%08X\n", (unsigned int)RX_GAMMA_ITF_CFG(0)->rx_inserted_bytes_2h,  (unsigned int)RX_GAMMA_ITF_CFG(1)->rx_inserted_bytes_2h,  (unsigned int)RX_GAMMA_ITF_CFG(2)->rx_inserted_bytes_2h,  (unsigned int)RX_GAMMA_ITF_CFG(3)->rx_inserted_bytes_2h);
+    len += sprintf(page + off + len, "RX_GAMMA_ITF_CFG:\t0x%08x\t0x%08x\t0x%08x\t0x%08x\n",       (unsigned int)TX_GAMMA_ITF_CFG(0),                        (unsigned int)TX_GAMMA_ITF_CFG(1),                        (unsigned int)TX_GAMMA_ITF_CFG(2),                        (unsigned int)TX_GAMMA_ITF_CFG(3));
+    len += sprintf(page + off + len, "  tx_len_adj:    \t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)TX_GAMMA_ITF_CFG(0)->tx_len_adj,            (unsigned int)TX_GAMMA_ITF_CFG(1)->tx_len_adj,            (unsigned int)TX_GAMMA_ITF_CFG(2)->tx_len_adj,            (unsigned int)TX_GAMMA_ITF_CFG(3)->tx_len_adj);
+    len += sprintf(page + off + len, "  tx_crc_off_adj:\t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)TX_GAMMA_ITF_CFG(0)->tx_crc_off_adj,        (unsigned int)TX_GAMMA_ITF_CFG(1)->tx_crc_off_adj,        (unsigned int)TX_GAMMA_ITF_CFG(2)->tx_crc_off_adj,        (unsigned int)TX_GAMMA_ITF_CFG(3)->tx_crc_off_adj);
+    len += sprintf(page + off + len, "  tx_min_len:    \t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)TX_GAMMA_ITF_CFG(0)->tx_min_len,            (unsigned int)TX_GAMMA_ITF_CFG(1)->tx_min_len,            (unsigned int)TX_GAMMA_ITF_CFG(2)->tx_min_len,            (unsigned int)TX_GAMMA_ITF_CFG(3)->tx_min_len);
+    len += sprintf(page + off + len, "  tx_eth_fcs_gen_dis:\t  %8d\t  %8d\t  %8d\t  %8d\n",       (unsigned int)TX_GAMMA_ITF_CFG(0)->tx_eth_fcs_gen_dis,    (unsigned int)TX_GAMMA_ITF_CFG(1)->tx_eth_fcs_gen_dis,    (unsigned int)TX_GAMMA_ITF_CFG(2)->tx_eth_fcs_gen_dis,    (unsigned int)TX_GAMMA_ITF_CFG(3)->tx_eth_fcs_gen_dis);
+    len += sprintf(page + off + len, "  tx_tc_crc_size:\t  %8d\t  %8d\t  %8d\t  %8d\n",           (unsigned int)TX_GAMMA_ITF_CFG(0)->tx_tc_crc_size,        (unsigned int)TX_GAMMA_ITF_CFG(1)->tx_tc_crc_size,        (unsigned int)TX_GAMMA_ITF_CFG(2)->tx_tc_crc_size,        (unsigned int)TX_GAMMA_ITF_CFG(3)->tx_tc_crc_size);
+    len += sprintf(page + off + len, "  tx_crc_cfg:    \t0x%08X\t0x%08X\t0x%08X\t0x%08X\n",       (unsigned int)TX_GAMMA_ITF_CFG(0)->tx_crc_cfg,            (unsigned int)TX_GAMMA_ITF_CFG(1)->tx_crc_cfg,            (unsigned int)TX_GAMMA_ITF_CFG(2)->tx_crc_cfg,            (unsigned int)TX_GAMMA_ITF_CFG(3)->tx_crc_cfg);
+    len += sprintf(page + off + len, "  tx_eth_fcs_init_value:0x%08X\t0x%08X\t0x%08X\t0x%08X\n",  (unsigned int)TX_GAMMA_ITF_CFG(0)->tx_eth_fcs_init_value, (unsigned int)TX_GAMMA_ITF_CFG(1)->tx_eth_fcs_init_value, (unsigned int)TX_GAMMA_ITF_CFG(2)->tx_eth_fcs_init_value, (unsigned int)TX_GAMMA_ITF_CFG(3)->tx_eth_fcs_init_value);
+    len += sprintf(page + off + len, "  tx_tc_crc_init_value:\t0x%08X\t0x%08X\t0x%08X\t0x%08X\n", (unsigned int)TX_GAMMA_ITF_CFG(0)->tx_tc_crc_init_value,  (unsigned int)TX_GAMMA_ITF_CFG(1)->tx_tc_crc_init_value,  (unsigned int)TX_GAMMA_ITF_CFG(2)->tx_tc_crc_init_value,  (unsigned int)TX_GAMMA_ITF_CFG(3)->tx_tc_crc_init_value);
+    len += sprintf(page + off + len, "  queue_mapping: \t0x%08X\t0x%08X\t0x%08X\t0x%08X\n",       (unsigned int)TX_GAMMA_ITF_CFG(0)->queue_mapping,         (unsigned int)TX_GAMMA_ITF_CFG(1)->queue_mapping,         (unsigned int)TX_GAMMA_ITF_CFG(2)->queue_mapping,         (unsigned int)TX_GAMMA_ITF_CFG(3)->queue_mapping);
+
+    *eof = 1;
+
+    return len;
+}
+
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+static int proc_read_dbg(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int len = 0;
+
+    len += sprintf(page + off + len, "error print      - %s\n", (ifx_ptm_dbg_enable & DBG_ENABLE_MASK_ERR)              ? "enabled" : "disabled");
+    len += sprintf(page + off + len, "debug print      - %s\n", (ifx_ptm_dbg_enable & DBG_ENABLE_MASK_DEBUG_PRINT)      ? "enabled" : "disabled");
+    len += sprintf(page + off + len, "assert           - %s\n", (ifx_ptm_dbg_enable & DBG_ENABLE_MASK_ASSERT)           ? "enabled" : "disabled");
+    len += sprintf(page + off + len, "dump rx skb      - %s\n", (ifx_ptm_dbg_enable & DBG_ENABLE_MASK_DUMP_SKB_RX)      ? "enabled" : "disabled");
+    len += sprintf(page + off + len, "dump tx skb      - %s\n", (ifx_ptm_dbg_enable & DBG_ENABLE_MASK_DUMP_SKB_TX)      ? "enabled" : "disabled");
+    len += sprintf(page + off + len, "mac swap         - %s\n", (ifx_ptm_dbg_enable & DBG_ENABLE_MASK_MAC_SWAP)         ? "enabled" : "disabled");
+
+    *eof = 1;
+
+    return len;
+}
+
+static int proc_write_dbg(struct file *file, const char *buf, unsigned long count, void *data)
+{
+    static const char *dbg_enable_mask_str[] = {
+        " error print",
+        " err",
+        " debug print",
+        " dbg",
+        " assert",
+        " assert",
+        " dump rx skb",
+        " rx",
+        " dump tx skb",
+        " tx",
+        " dump init",
+        " init",
+        " dump qos",
+        " qos",
+        " mac swap",
+        " swap",
+        " all"
+    };
+    static const int dbg_enable_mask_str_len[] = {
+        12, 4,
+        12, 4,
+        7,  7,
+        12, 3,
+        12, 3,
+        10, 5,
+        9,  4,
+        9,  5,
+        4
+    };
+    unsigned int dbg_enable_mask[] = {
+        DBG_ENABLE_MASK_ERR,
+        DBG_ENABLE_MASK_DEBUG_PRINT,
+        DBG_ENABLE_MASK_ASSERT,
+        DBG_ENABLE_MASK_DUMP_SKB_RX,
+        DBG_ENABLE_MASK_DUMP_SKB_TX,
+        DBG_ENABLE_MASK_DUMP_INIT,
+        DBG_ENABLE_MASK_DUMP_QOS,
+        DBG_ENABLE_MASK_MAC_SWAP,
+        DBG_ENABLE_MASK_ALL
+    };
+
+    char str[2048];
+    char *p;
+
+    int len, rlen;
+
+    int f_enable = 0;
+    int i;
+
+    len = count < sizeof(str) ? count : sizeof(str) - 1;
+    rlen = len - copy_from_user(str, buf, len);
+    while ( rlen && str[rlen - 1] <= ' ' )
+        rlen--;
+    str[rlen] = 0;
+    for ( p = str; *p && *p <= ' '; p++, rlen-- );
+    if ( !*p )
+        return 0;
+
+    //  debugging feature for enter/leave showtime
+    if ( strincmp(p, "enter", 5) == 0 && ifx_mei_atm_showtime_enter != NULL )
+        ifx_mei_atm_showtime_enter(NULL, NULL);
+    else if ( strincmp(p, "leave", 5) == 0 && ifx_mei_atm_showtime_exit != NULL )
+        ifx_mei_atm_showtime_exit();
+
+    if ( strincmp(p, "enable", 6) == 0 ) {
+        p += 6;
+        f_enable = 1;
+    }
+    else if ( strincmp(p, "disable", 7) == 0 ) {
+        p += 7;
+        f_enable = -1;
+    }
+    else if ( strincmp(p, "help", 4) == 0 || *p == '?' ) {
+        printk("echo <enable/disable> [err/dbg/assert/rx/tx/init/qos/swap/all] > /proc/driver/ifx_ptm/dbg\n");
+    }
+
+    if ( f_enable ) {
+        if ( *p == 0 ) {
+            if ( f_enable > 0 )
+                ifx_ptm_dbg_enable |= DBG_ENABLE_MASK_ALL & ~DBG_ENABLE_MASK_MAC_SWAP;
+            else
+                ifx_ptm_dbg_enable &= ~DBG_ENABLE_MASK_ALL | DBG_ENABLE_MASK_MAC_SWAP;
+        }
+        else {
+            do {
+                for ( i = 0; i < NUM_ENTITY(dbg_enable_mask_str); i++ )
+                    if ( strincmp(p, dbg_enable_mask_str[i], dbg_enable_mask_str_len[i]) == 0 ) {
+                        if ( f_enable > 0 )
+                            ifx_ptm_dbg_enable |= dbg_enable_mask[i >> 1];
+                        else
+                            ifx_ptm_dbg_enable &= ~dbg_enable_mask[i >> 1];
+                        p += dbg_enable_mask_str_len[i];
+                        break;
+                    }
+            } while ( i < NUM_ENTITY(dbg_enable_mask_str) );
+        }
+    }
+
+    return count;
+}
+#endif
+
+#if defined(ENABLE_TMP_DBG) && ENABLE_TMP_DBG
+static int proc_read_rdptr(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int len = 0;
+
+    len += sprintf(page + off + len, "rx_desc_pos - %d\n", g_ptm_priv_data.itf[0].rx_desc_pos);
+
+    *eof = 1;
+
+    return len;
+}
+#endif
+
+static INLINE int stricmp(const char *p1, const char *p2)
+{
+    int c1, c2;
+
+    while ( *p1 && *p2 )
+    {
+        c1 = *p1 >= 'A' && *p1 <= 'Z' ? *p1 + 'a' - 'A' : *p1;
+        c2 = *p2 >= 'A' && *p2 <= 'Z' ? *p2 + 'a' - 'A' : *p2;
+        if ( (c1 -= c2) )
+            return c1;
+        p1++;
+        p2++;
+    }
+
+    return *p1 - *p2;
+}
+
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+static INLINE int strincmp(const char *p1, const char *p2, int n)
+{
+    int c1 = 0, c2;
+
+    while ( n && *p1 && *p2 )
+    {
+        c1 = *p1 >= 'A' && *p1 <= 'Z' ? *p1 + 'a' - 'A' : *p1;
+        c2 = *p2 >= 'A' && *p2 <= 'Z' ? *p2 + 'a' - 'A' : *p2;
+        if ( (c1 -= c2) )
+            return c1;
+        p1++;
+        p2++;
+        n--;
+    }
+
+    return n ? *p1 - *p2 : c1;
+}
+#endif
+
+static INLINE int get_token(char **p1, char **p2, int *len, int *colon)
+{
+    int tlen = 0;
+
+    while ( *len && !((**p1 >= 'A' && **p1 <= 'Z') || (**p1 >= 'a' && **p1<= 'z') || (**p1 >= '0' && **p1<= '9')) )
+    {
+        (*p1)++;
+        (*len)--;
+    }
+    if ( !*len )
+        return 0;
+
+    if ( *colon )
+    {
+        *colon = 0;
+        *p2 = *p1;
+        while ( *len && **p2 > ' ' && **p2 != ',' )
+        {
+            if ( **p2 == ':' )
+            {
+                *colon = 1;
+                break;
+            }
+            (*p2)++;
+            (*len)--;
+            tlen++;
+        }
+        **p2 = 0;
+    }
+    else
+    {
+        *p2 = *p1;
+        while ( *len && **p2 > ' ' && **p2 != ',' )
+        {
+            (*p2)++;
+            (*len)--;
+            tlen++;
+        }
+        **p2 = 0;
+    }
+
+    return tlen;
+}
+
+static INLINE int get_number(char **p, int *len, int is_hex)
+{
+    int ret = 0;
+    int n = 0;
+
+    if ( (*p)[0] == '0' && (*p)[1] == 'x' )
+    {
+        is_hex = 1;
+        (*p) += 2;
+        (*len) -= 2;
+    }
+
+    if ( is_hex )
+    {
+        while ( *len && ((**p >= '0' && **p <= '9') || (**p >= 'a' && **p <= 'f') || (**p >= 'A' && **p <= 'F')) )
+        {
+            if ( **p >= '0' && **p <= '9' )
+                n = **p - '0';
+            else if ( **p >= 'a' && **p <= 'f' )
+               n = **p - 'a' + 10;
+            else if ( **p >= 'A' && **p <= 'F' )
+                n = **p - 'A' + 10;
+            ret = (ret << 4) | n;
+            (*p)++;
+            (*len)--;
+        }
+    }
+    else
+    {
+        while ( *len && **p >= '0' && **p <= '9' )
+        {
+            n = **p - '0';
+            ret = ret * 10 + n;
+            (*p)++;
+            (*len)--;
+        }
+    }
+
+    return ret;
+}
+
+static INLINE void ignore_space(char **p, int *len)
+{
+    while ( *len && (**p <= ' ' || **p == ':' || **p == '.' || **p == ',') )
+    {
+        (*p)++;
+        (*len)--;
+    }
+}
+
+static INLINE int ifx_ptm_version(char *buf)
+{
+    int len = 0;
+    unsigned int major, mid, minor;
+
+    ifx_ptm_get_fw_ver(&major, &mid, &minor);
+
+    len += ifx_drv_ver(buf + len, "PTM", IFX_PTM_VER_MAJOR, IFX_PTM_VER_MID, IFX_PTM_VER_MINOR);
+    if ( mid == ~0 )
+        len += sprintf(buf + len, "    PTM (E1) firmware version %u.%u\n", major, minor);
+    else
+        len += sprintf(buf + len, "    PTM (E1) firmware version %u.%u.%u\n", major, mid, minor);
+
+    return len;
+}
+
+static INLINE int init_priv_data(void)
+{
+    int i, j;
+
+    g_wanqos_en = wanqos_en ? wanqos_en : 8;
+    if ( g_wanqos_en > 8 )
+        g_wanqos_en = 8;
+
+    for ( i = 0; i < NUM_ENTITY(g_queue_gamma_map); i++ )
+    {
+        g_queue_gamma_map[i] = queue_gamma_map[i] & ((1 << g_wanqos_en) - 1);
+        for ( j = 0; j < i; j++ )
+            g_queue_gamma_map[i] &= ~g_queue_gamma_map[j];
+    }
+
+    memset(&g_ptm_priv_data, 0, sizeof(g_ptm_priv_data));
+
+    {
+        int max_packet_priority = NUM_ENTITY(g_ptm_prio_queue_map);
+        int tx_num_q;
+        int q_step, q_accum, p_step;
+
+        tx_num_q = __ETH_WAN_TX_QUEUE_NUM;
+        q_step = tx_num_q - 1;
+        p_step = max_packet_priority - 1;
+        for ( j = 0, q_accum = 0; j < max_packet_priority; j++, q_accum += q_step )
+            g_ptm_prio_queue_map[j] = q_step - (q_accum + (p_step >> 1)) / p_step;
+    }
+
+    return 0;
+}
+
+static INLINE void clear_priv_data(void)
+{
+}
+
+static INLINE int init_tables(void)
+{
+    struct sk_buff *skb_pool[WAN_RX_DESC_NUM] = {0};
+    struct cfg_std_data_len cfg_std_data_len = {0};
+    struct tx_qos_cfg tx_qos_cfg = {0};
+    struct psave_cfg psave_cfg = {0};
+    struct eg_bwctrl_cfg eg_bwctrl_cfg = {0};
+    struct test_mode test_mode = {0};
+    struct rx_bc_cfg rx_bc_cfg = {0};
+    struct tx_bc_cfg tx_bc_cfg = {0};
+    struct gpio_mode gpio_mode = {0};
+    struct gpio_wm_cfg gpio_wm_cfg = {0};
+    struct rx_gamma_itf_cfg rx_gamma_itf_cfg = {0};
+    struct tx_gamma_itf_cfg tx_gamma_itf_cfg = {0};
+    struct wtx_qos_q_desc_cfg wtx_qos_q_desc_cfg = {0};
+    struct rx_descriptor rx_desc = {0};
+    struct tx_descriptor tx_desc = {0};
+    int i;
+
+    for ( i = 0; i < WAN_RX_DESC_NUM; i++ ) {
+        skb_pool[i] = alloc_skb_rx();
+        if ( skb_pool[i] == NULL )
+            goto ALLOC_SKB_RX_FAIL;
+    }
+
+    cfg_std_data_len.byte_off = RX_HEAD_MAC_ADDR_ALIGNMENT; //  this field replaces byte_off in rx descriptor of VDSL ingress
+    cfg_std_data_len.data_len = 1600;
+    *CFG_STD_DATA_LEN = cfg_std_data_len;
+
+    //tx_qos_cfg.time_tick    = cgu_get_pp32_clock() / 62500; //  16 * (cgu_get_pp32_clock() / 1000000)
+    tx_qos_cfg.overhd_bytes = 0;
+    tx_qos_cfg.eth1_eg_qnum = __ETH_WAN_TX_QUEUE_NUM;
+    tx_qos_cfg.eth1_burst_chk = 1;
+    tx_qos_cfg.eth1_qss     = 0;
+    tx_qos_cfg.shape_en     = 0;    //  disable
+    tx_qos_cfg.wfq_en       = 0;    //  strict priority
+    *TX_QOS_CFG = tx_qos_cfg;
+
+    psave_cfg.start_state   = 0;
+    psave_cfg.sleep_en      = 1;    //  enable sleep mode
+    *PSAVE_CFG = psave_cfg;
+
+    eg_bwctrl_cfg.fdesc_wm  = 16;
+    eg_bwctrl_cfg.class_len = 128;
+    *EG_BWCTRL_CFG = eg_bwctrl_cfg;
+
+    //*GPIO_ADDR = (unsigned int)IFX_GPIO_P0_OUT;
+    *GPIO_ADDR = (unsigned int)0x00000000;  //  disabled by default
+
+    gpio_mode.gpio_bit_bc1 = 2;
+    gpio_mode.gpio_bit_bc0 = 1;
+    gpio_mode.gpio_bc1_en  = 0;
+    gpio_mode.gpio_bc0_en  = 0;
+    *GPIO_MODE = gpio_mode;
+
+    gpio_wm_cfg.stop_wm_bc1  = 2;
+    gpio_wm_cfg.start_wm_bc1 = 4;
+    gpio_wm_cfg.stop_wm_bc0  = 2;
+    gpio_wm_cfg.start_wm_bc0 = 4;
+    *GPIO_WM_CFG = gpio_wm_cfg;
+
+    test_mode.mib_clear_mode    = 0;
+    test_mode.test_mode         = 0;
+    *TEST_MODE = test_mode;
+
+    rx_bc_cfg.local_state   = 0;
+    rx_bc_cfg.remote_state  = 0;
+    rx_bc_cfg.to_false_th   = 7;
+    rx_bc_cfg.to_looking_th = 3;
+    *RX_BC_CFG(0) = rx_bc_cfg;
+    *RX_BC_CFG(1) = rx_bc_cfg;
+
+    tx_bc_cfg.fill_wm   = 2;
+    tx_bc_cfg.uflw_wm   = 2;
+    *TX_BC_CFG(0) = tx_bc_cfg;
+    *TX_BC_CFG(1) = tx_bc_cfg;
+
+    rx_gamma_itf_cfg.receive_state      = 0;
+    rx_gamma_itf_cfg.rx_min_len         = 60;
+    rx_gamma_itf_cfg.rx_pad_en          = 1;
+    rx_gamma_itf_cfg.rx_eth_fcs_ver_dis = 0;
+    rx_gamma_itf_cfg.rx_rm_eth_fcs      = 1;
+    rx_gamma_itf_cfg.rx_tc_crc_ver_dis  = 0;
+    rx_gamma_itf_cfg.rx_tc_crc_size     = 1;
+    rx_gamma_itf_cfg.rx_eth_fcs_result  = 0xC704DD7B;
+    rx_gamma_itf_cfg.rx_tc_crc_result   = 0x1D0F1D0F;
+    rx_gamma_itf_cfg.rx_crc_cfg         = 0x2500;
+    rx_gamma_itf_cfg.rx_eth_fcs_init_value  = 0xFFFFFFFF;
+    rx_gamma_itf_cfg.rx_tc_crc_init_value   = 0x0000FFFF;
+    rx_gamma_itf_cfg.rx_max_len_sel     = 0;
+    rx_gamma_itf_cfg.rx_edit_num2       = 0;
+    rx_gamma_itf_cfg.rx_edit_pos2       = 0;
+    rx_gamma_itf_cfg.rx_edit_type2      = 0;
+    rx_gamma_itf_cfg.rx_edit_en2        = 0;
+    rx_gamma_itf_cfg.rx_edit_num1       = 0;
+    rx_gamma_itf_cfg.rx_edit_pos1       = 0;
+    rx_gamma_itf_cfg.rx_edit_type1      = 0;
+    rx_gamma_itf_cfg.rx_edit_en1        = 0;
+    rx_gamma_itf_cfg.rx_inserted_bytes_1l   = 0;
+    rx_gamma_itf_cfg.rx_inserted_bytes_1h   = 0;
+    rx_gamma_itf_cfg.rx_inserted_bytes_2l   = 0;
+    rx_gamma_itf_cfg.rx_inserted_bytes_2h   = 0;
+    rx_gamma_itf_cfg.rx_len_adj         = -6;
+    for ( i = 0; i < 4; i++ )
+        *RX_GAMMA_ITF_CFG(i) = rx_gamma_itf_cfg;
+
+    tx_gamma_itf_cfg.tx_len_adj         = 6;
+    tx_gamma_itf_cfg.tx_crc_off_adj     = 6;
+    tx_gamma_itf_cfg.tx_min_len         = 0;
+    tx_gamma_itf_cfg.tx_eth_fcs_gen_dis = 0;
+    tx_gamma_itf_cfg.tx_tc_crc_size     = 1;
+    tx_gamma_itf_cfg.tx_crc_cfg         = 0x2F00;
+    tx_gamma_itf_cfg.tx_eth_fcs_init_value  = 0xFFFFFFFF;
+    tx_gamma_itf_cfg.tx_tc_crc_init_value   = 0x0000FFFF;
+    for ( i = 0; i < NUM_ENTITY(g_queue_gamma_map); i++ ) {
+        tx_gamma_itf_cfg.queue_mapping = g_queue_gamma_map[i];
+        *TX_GAMMA_ITF_CFG(i) = tx_gamma_itf_cfg;
+    }
+
+    for ( i = 0; i < __ETH_WAN_TX_QUEUE_NUM; i++ ) {
+        wtx_qos_q_desc_cfg.length = WAN_TX_DESC_NUM;
+        wtx_qos_q_desc_cfg.addr   = __ETH_WAN_TX_DESC_BASE(i);
+        *WTX_QOS_Q_DESC_CFG(i) = wtx_qos_q_desc_cfg;
+    }
+
+    //  default TX queue QoS config is all ZERO
+
+    //  TX Ctrl K Table
+    IFX_REG_W32(0x90111293, TX_CTRL_K_TABLE(0));
+    IFX_REG_W32(0x14959617, TX_CTRL_K_TABLE(1));
+    IFX_REG_W32(0x18999A1B, TX_CTRL_K_TABLE(2));
+    IFX_REG_W32(0x9C1D1E9F, TX_CTRL_K_TABLE(3));
+    IFX_REG_W32(0xA02122A3, TX_CTRL_K_TABLE(4));
+    IFX_REG_W32(0x24A5A627, TX_CTRL_K_TABLE(5));
+    IFX_REG_W32(0x28A9AA2B, TX_CTRL_K_TABLE(6));
+    IFX_REG_W32(0xAC2D2EAF, TX_CTRL_K_TABLE(7));
+    IFX_REG_W32(0x30B1B233, TX_CTRL_K_TABLE(8));
+    IFX_REG_W32(0xB43536B7, TX_CTRL_K_TABLE(9));
+    IFX_REG_W32(0xB8393ABB, TX_CTRL_K_TABLE(10));
+    IFX_REG_W32(0x3CBDBE3F, TX_CTRL_K_TABLE(11));
+    IFX_REG_W32(0xC04142C3, TX_CTRL_K_TABLE(12));
+    IFX_REG_W32(0x44C5C647, TX_CTRL_K_TABLE(13));
+    IFX_REG_W32(0x48C9CA4B, TX_CTRL_K_TABLE(14));
+    IFX_REG_W32(0xCC4D4ECF, TX_CTRL_K_TABLE(15));
+
+    //  init RX descriptor
+    rx_desc.own     = 1;
+    rx_desc.c       = 0;
+    rx_desc.sop     = 1;
+    rx_desc.eop     = 1;
+    rx_desc.byteoff = RX_HEAD_MAC_ADDR_ALIGNMENT;
+    rx_desc.datalen = RX_MAX_BUFFER_SIZE - RX_HEAD_MAC_ADDR_ALIGNMENT;
+    for ( i = 0; i < WAN_RX_DESC_NUM; i++ ) {
+        rx_desc.dataptr = (unsigned int)skb_pool[i]->data & 0x0FFFFFFF;
+        WAN_RX_DESC_BASE[i] = rx_desc;
+    }
+
+    //  init TX descriptor
+    tx_desc.own     = 0;
+    tx_desc.c       = 0;
+    tx_desc.sop     = 1;
+    tx_desc.eop     = 1;
+    tx_desc.byteoff = 0;
+    tx_desc.qid     = 0;
+    tx_desc.datalen = 0;
+    tx_desc.small   = 0;
+    tx_desc.dataptr = 0;
+    for ( i = 0; i < CPU_TO_WAN_TX_DESC_NUM; i++ )
+        CPU_TO_WAN_TX_DESC_BASE[i] = tx_desc;
+    for ( i = 0; i < WAN_TX_DESC_NUM_TOTAL; i++ )
+        WAN_TX_DESC_BASE(0)[i] = tx_desc;
+
+    //  init Swap descriptor
+    for ( i = 0; i < WAN_SWAP_DESC_NUM; i++ )
+        WAN_SWAP_DESC_BASE[i] = tx_desc;
+
+    //  init fastpath TX descriptor
+    tx_desc.own     = 1;
+    for ( i = 0; i < FASTPATH_TO_WAN_TX_DESC_NUM; i++ )
+        FASTPATH_TO_WAN_TX_DESC_BASE[i] = tx_desc;
+
+    return 0;
+
+ALLOC_SKB_RX_FAIL:
+    while ( i-- > 0 )
+        dev_kfree_skb_any(skb_pool[i]);
+    return -ENOMEM;
+}
+
+static INLINE void clear_tables(void)
+{
+    struct sk_buff *skb;
+    int i, j;
+
+    for ( i = 0; i < WAN_RX_DESC_NUM; i++ ) {
+        skb = get_skb_pointer(WAN_RX_DESC_BASE[i].dataptr);
+        if ( skb != NULL )
+            dev_kfree_skb_any(skb);
+    }
+
+    for ( i = 0; i < CPU_TO_WAN_TX_DESC_NUM; i++ ) {
+        skb = get_skb_pointer(CPU_TO_WAN_TX_DESC_BASE[i].dataptr);
+        if ( skb != NULL )
+            dev_kfree_skb_any(skb);
+    }
+
+    for ( j = 0; j < 8; j++ )
+        for ( i = 0; i < WAN_TX_DESC_NUM; i++ ) {
+            skb = get_skb_pointer(WAN_TX_DESC_BASE(j)[i].dataptr);
+            if ( skb != NULL )
+                dev_kfree_skb_any(skb);
+        }
+
+    for ( i = 0; i < WAN_SWAP_DESC_NUM; i++ ) {
+        skb = get_skb_pointer(WAN_SWAP_DESC_BASE[i].dataptr);
+        if ( skb != NULL )
+            dev_kfree_skb_any(skb);
+    }
+
+    for ( i = 0; i < FASTPATH_TO_WAN_TX_DESC_NUM; i++ ) {
+        skb = get_skb_pointer(FASTPATH_TO_WAN_TX_DESC_BASE[i].dataptr);
+        if ( skb != NULL )
+            dev_kfree_skb_any(skb);
+    }
+}
+
+
+
+/*
+ * ####################################
+ *           Global Function
+ * ####################################
+ */
+
+static int ptm_showtime_enter(struct port_cell_info *port_cell, void *xdata_addr)
+{
+    ASSERT(port_cell != NULL, "port_cell is NULL");
+    ASSERT(xdata_addr != NULL, "xdata_addr is NULL");
+
+    //  TODO: ReTX set xdata_addr
+    g_xdata_addr = xdata_addr;
+
+    g_showtime = 1;
+
+    IFX_REG_W32(0x0F, UTP_CFG);
+
+//#ifdef CONFIG_VR9
+//    IFX_REG_W32_MASK(1 << 17, 0, FFSM_CFG0);
+//#endif
+
+    printk("enter showtime\n");
+
+    return 0;
+}
+
+static int ptm_showtime_exit(void)
+{
+    if ( !g_showtime )
+        return -EIO;
+
+//#ifdef CONFIG_VR9
+//    IFX_REG_W32_MASK(0, 1 << 17, FFSM_CFG0);
+//#endif
+
+    IFX_REG_W32(0x00, UTP_CFG);
+
+    g_showtime = 0;
+
+    //  TODO: ReTX clean state
+    g_xdata_addr = NULL;
+
+    printk("leave showtime\n");
+
+    return 0;
+}
+
+
+
+/*
+ * ####################################
+ *           Init/Cleanup API
+ * ####################################
+ */
+
+/*
+ *  Description:
+ *    Initialize global variables, PP32, comunication structures, register IRQ
+ *    and register device.
+ *  Input:
+ *    none
+ *  Output:
+ *    0    --- successful
+ *    else --- failure, usually it is negative value of error code
+ */
+static int __init ifx_ptm_init(void)
+{
+    int ret;
+    struct port_cell_info port_cell = {0};
+    int i;
+    char ver_str[256];
+
+    ret = init_priv_data();
+    if ( ret != 0 ) {
+        err("INIT_PRIV_DATA_FAIL");
+        goto INIT_PRIV_DATA_FAIL;
+    }
+
+    ifx_ptm_init_chip();
+    ret = init_tables();
+    if ( ret != 0 ) {
+        err("INIT_TABLES_FAIL");
+        goto INIT_TABLES_FAIL;
+    }
+
+    for ( i = 0; i < NUM_ENTITY(g_net_dev); i++ ) {
+        g_net_dev[i] = alloc_netdev(0, g_net_dev_name[i], ether_setup);
+        if ( g_net_dev[i] == NULL )
+            goto ALLOC_NETDEV_FAIL;
+        ptm_setup(g_net_dev[i], i);
+    }
+
+    for ( i = 0; i < NUM_ENTITY(g_net_dev); i++ ) {
+        ret = register_netdev(g_net_dev[i]);
+        if ( ret != 0 )
+            goto REGISTER_NETDEV_FAIL;
+    }
+
+    /*  register interrupt handler  */
+    ret = request_irq(PPE_MAILBOX_IGU1_INT, mailbox_irq_handler, IRQF_DISABLED, "ptm_mailbox_isr", &g_ptm_priv_data);
+    if ( ret ) {
+        if ( ret == -EBUSY ) {
+            err("IRQ may be occupied by other driver, please reconfig to disable it.");
+        }
+        else {
+            err("request_irq fail");
+        }
+        goto REQUEST_IRQ_PPE_MAILBOX_IGU1_INT_FAIL;
+    }
+    disable_irq(PPE_MAILBOX_IGU1_INT);
+
+    ret = ifx_pp32_start(0);
+    if ( ret ) {
+        err("ifx_pp32_start fail!");
+        goto PP32_START_FAIL;
+    }
+    IFX_REG_W32(1 << 16, MBOX_IGU1_IER);    //  enable SWAP interrupt
+    IFX_REG_W32(~0, MBOX_IGU1_ISRC);
+
+    enable_irq(PPE_MAILBOX_IGU1_INT);
+
+    ifx_mei_atm_showtime_check(&g_showtime, &port_cell, &g_xdata_addr);
+
+#if defined(ENABLE_LED_FRAMEWORK) && ENABLE_LED_FRAMEWORK
+    ifx_led_trigger_register("dsl_data", &g_data_led_trigger);
+#endif
+
+    proc_file_create();
+
+    ifx_mei_atm_showtime_enter = ptm_showtime_enter;
+    ifx_mei_atm_showtime_exit  = ptm_showtime_exit;
+
+    ifx_ptm_version(ver_str);
+    printk(KERN_INFO "%s", ver_str);
+
+    printk("ifxmips_ptm: PTM init succeed\n");
+
+    return 0;
+
+PP32_START_FAIL:
+    free_irq(PPE_MAILBOX_IGU1_INT, &g_ptm_priv_data);
+REQUEST_IRQ_PPE_MAILBOX_IGU1_INT_FAIL:
+    i = NUM_ENTITY(g_net_dev);
+REGISTER_NETDEV_FAIL:
+    while ( i-- )
+        unregister_netdev(g_net_dev[i]);
+    i = NUM_ENTITY(g_net_dev);
+ALLOC_NETDEV_FAIL:
+    while ( i-- ) {
+        free_netdev(g_net_dev[i]);
+        g_net_dev[i] = NULL;
+    }
+INIT_TABLES_FAIL:
+INIT_PRIV_DATA_FAIL:
+    clear_priv_data();
+    printk("ifxmips_ptm: PTM init failed\n");
+    return ret;
+}
+
+/*
+ *  Description:
+ *    Release memory, free IRQ, and deregister device.
+ *  Input:
+ *    none
+ *  Output:
+ *   none
+ */
+static void __exit ifx_ptm_exit(void)
+{
+    int i;
+
+    ifx_mei_atm_showtime_enter = NULL;
+    ifx_mei_atm_showtime_exit  = NULL;
+
+    proc_file_delete();
+
+#if defined(ENABLE_LED_FRAMEWORK) && ENABLE_LED_FRAMEWORK
+    ifx_led_trigger_deregister(g_data_led_trigger);
+    g_data_led_trigger = NULL;
+#endif
+
+    ifx_pp32_stop(0);
+
+    free_irq(PPE_MAILBOX_IGU1_INT, &g_ptm_priv_data);
+
+    for ( i = 0; i < NUM_ENTITY(g_net_dev); i++ )
+        unregister_netdev(g_net_dev[i]);
+
+    for ( i = 0; i < NUM_ENTITY(g_net_dev); i++ ) {
+        free_netdev(g_net_dev[i]);
+        g_net_dev[i] = NULL;
+    }
+
+    clear_tables();
+
+    ifx_ptm_uninit_chip();
+
+    clear_priv_data();
+}
+
+#ifndef MODULE
+static int __init wanqos_en_setup(char *line)
+{
+    wanqos_en = simple_strtoul(line, NULL, 0);
+
+    if ( wanqos_en < 1 || wanqos_en > 8 )
+        wanqos_en = 0;
+
+    return 0;
+}
+
+static int __init queue_gamma_map_setup(char *line)
+{
+    char *p;
+    int i;
+
+    for ( i = 0, p = line; i < NUM_ENTITY(queue_gamma_map) && isxdigit(*p); i++ )
+    {
+        queue_gamma_map[i] = simple_strtoul(p, &p, 0);
+        if ( *p == ',' || *p == ';' || *p == ':' )
+            p++;
+    }
+
+    return 0;
+}
+#endif
+
+module_init(ifx_ptm_init);
+module_exit(ifx_ptm_exit);
+#ifndef MODULE
+  __setup("wanqos_en=", wanqos_en_setup);
+  __setup("queue_gamma_map=", queue_gamma_map_setup);
+#endif
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/lantiq_ptm/ltqmips_ptm_vdsl.h b/drivers/net/lantiq_ptm/ltqmips_ptm_vdsl.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/lantiq_ptm/ltqmips_ptm_vdsl.h
@@ -0,0 +1,123 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_ptm_vdsl.h
+** PROJECT      : UEIP
+** MODULES      : PTM
+**
+** DATE         : 7 Jul 2009
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : PTM driver header file (core functions for VR9)
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 07 JUL 2009  Xu Liang        Init Version
+*******************************************************************************/
+
+#ifndef IFXMIPS_PTM_VDSL_H
+#define IFXMIPS_PTM_VDSL_H
+
+
+
+#include <linux/version.h>
+#include <linux/netdevice.h>
+#include <lantiq_ptm.h>
+#include "ltqmips_ptm_common.h"
+#include "ltqmips_ptm_ppe_common.h"
+#include "ltqmips_ptm_fw_regs_vdsl.h"
+
+
+
+/*
+ * ####################################
+ *              Definition
+ * ####################################
+ */
+
+/*
+ *  Constant Definition
+ */
+#define ETH_WATCHDOG_TIMEOUT            (10 * HZ)
+
+/*
+ *  DMA RX/TX Channel Parameters
+ */
+#define MAX_ITF_NUMBER                  1
+#define MAX_RX_DMA_CHANNEL_NUMBER       1
+#define MAX_TX_DMA_CHANNEL_NUMBER       1
+#define DATA_BUFFER_ALIGNMENT           EMA_ALIGNMENT
+#define DESC_ALIGNMENT                  8
+
+/*
+ *  Ethernet Frame Definitions
+ */
+#define ETH_MAC_HEADER_LENGTH           14
+#define ETH_CRC_LENGTH                  4
+#define ETH_MIN_FRAME_LENGTH            64
+#define ETH_MAX_FRAME_LENGTH            (1518 + 4 * 2)
+
+/*
+ *  RX Frame Definitions
+ */
+#define RX_MAX_BUFFER_SIZE              (1600 + RX_HEAD_MAC_ADDR_ALIGNMENT)
+#define RX_HEAD_MAC_ADDR_ALIGNMENT      2
+#define RX_TAIL_CRC_LENGTH              0   //  PTM firmware does not have ethernet frame CRC
+                                            //  The len in descriptor doesn't include ETH_CRC
+                                            //  because ETH_CRC may not present in some configuration
+
+
+
+/*
+ * ####################################
+ *              Data Type
+ * ####################################
+ */
+
+struct ptm_itf {
+    unsigned int                    rx_desc_pos;
+
+    unsigned int                    tx_desc_pos;
+
+    unsigned int                    tx_swap_desc_pos;
+
+    struct net_device_stats         stats;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32) && defined(CONFIG_LTQ_PTM_RX_NAPI)
+    struct napi_struct              napi;
+#endif
+};
+
+struct ptm_priv_data {
+    struct ptm_itf                  itf[MAX_ITF_NUMBER];
+};
+
+
+
+/*
+ * ####################################
+ *             Declaration
+ * ####################################
+ */
+
+extern unsigned int ifx_ptm_dbg_enable;
+
+extern void ifx_ptm_get_fw_ver(unsigned int *major, unsigned int *mid, unsigned int *minor);
+
+extern void ifx_ptm_init_chip(void);
+extern void ifx_ptm_uninit_chip(void);
+
+extern int ifx_pp32_start(int pp32);
+extern void ifx_pp32_stop(int pp32);
+
+extern void ifx_reset_ppe(void);
+
+
+
+#endif  //  IFXMIPS_PTM_VDSL_H
diff --git a/drivers/net/lantiq_ptm/ltqmips_ptm_vr9.c b/drivers/net/lantiq_ptm/ltqmips_ptm_vr9.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/lantiq_ptm/ltqmips_ptm_vr9.c
@@ -0,0 +1,345 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_ptm_vr9.c
+** PROJECT      : UEIP
+** MODULES      : PTM
+**
+** DATE         : 7 Jul 2009
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : PTM driver common source file (core functions)
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 07 JUL 2009  Xu Liang        Init Version
+*******************************************************************************/
+
+
+
+/*
+ * ####################################
+ *              Head File
+ * ####################################
+ */
+
+/*
+ *  Common Head File
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <asm/delay.h>
+
+/*
+ *  Chip Specific Head File
+ */
+#include "ltqmips_ptm_vdsl.h"
+#include "ltqmips_ptm_fw_vr9.h"
+
+
+
+/*
+ * ####################################
+ *              Definition
+ * ####################################
+ */
+#ifdef __VR9_E1_FW_H
+  #define firmware_binary_code      vr9_e1_fw_code
+  #define firmware_binary_data      vr9_e1_fw_data
+#endif
+
+
+
+/*
+ * ####################################
+ *             Declaration
+ * ####################################
+ */
+
+/*
+ *  Hardware Init/Uninit Functions
+ */
+static inline void init_pmu(void);
+static inline void uninit_pmu(void);
+static inline void reset_ppe(void);
+static inline void init_pdma(void);
+static inline void init_mailbox(void);
+static inline void init_atm_tc(void);
+static inline void clear_share_buffer(void);
+
+
+
+/*
+ * ####################################
+ *            Local Variable
+ * ####################################
+ */
+
+
+
+/*
+ * ####################################
+ *            Local Function
+ * ####################################
+ */
+
+static inline void init_pmu(void)
+{
+/*
+    *PMU_PWDCR &= ~((1 << 29) | (1 << 22) | (1 << 21) | (1 << 19) | (1 << 18));
+    PPE_TOP_PMU_SETUP(IFX_PMU_ENABLE);
+    PPE_SLL01_PMU_SETUP(IFX_PMU_ENABLE);
+    PPE_TC_PMU_SETUP(IFX_PMU_ENABLE);
+    PPE_EMA_PMU_SETUP(IFX_PMU_ENABLE);
+    //PPE_QSB_PMU_SETUP(IFX_PMU_ENABLE);
+    PPE_TPE_PMU_SETUP(IFX_PMU_ENABLE);
+    DSL_DFE_PMU_SETUP(IFX_PMU_ENABLE);
+*/
+}
+
+static inline void uninit_pmu(void)
+{
+/*
+    PPE_SLL01_PMU_SETUP(IFX_PMU_DISABLE);
+    PPE_TC_PMU_SETUP(IFX_PMU_DISABLE);
+    PPE_EMA_PMU_SETUP(IFX_PMU_DISABLE);
+    //PPE_QSB_PMU_SETUP(IFX_PMU_DISABLE);
+    PPE_TPE_PMU_SETUP(IFX_PMU_DISABLE);
+    DSL_DFE_PMU_SETUP(IFX_PMU_DISABLE);
+    PPE_TOP_PMU_SETUP(IFX_PMU_DISABLE);
+*/
+}
+
+static inline void reset_ppe(void)
+{
+#ifdef MODULE
+    //  reset PPE
+    ifx_rcu_rst(IFX_RCU_DOMAIN_DSLDFE, IFX_RCU_MODULE_PTM);
+    udelay(1000);
+    ifx_rcu_rst(IFX_RCU_DOMAIN_DSLTC, IFX_RCU_MODULE_PTM);
+    udelay(1000);
+    ifx_rcu_rst(IFX_RCU_DOMAIN_PPE, IFX_RCU_MODULE_PTM);
+    udelay(1000);
+    *PP32_SRST &= ~0x000303CF;
+    udelay(1000);
+    *PP32_SRST |= 0x000303CF;
+    udelay(1000);
+#endif
+}
+
+static inline void init_pdma(void)
+{
+    IFX_REG_W32(0x00000001, PDMA_CFG);
+    IFX_REG_W32(0x00082C00, PDMA_RX_CTX_CFG);
+    IFX_REG_W32(0x00081B00, PDMA_TX_CTX_CFG);
+    IFX_REG_W32(0x02040604, PDMA_RX_MAX_LEN_REG);
+    IFX_REG_W32(0x000F003F, PDMA_RX_DELAY_CFG);
+
+    IFX_REG_W32(0x00000011, SAR_MODE_CFG);
+    IFX_REG_W32(0x00082A00, SAR_RX_CTX_CFG);
+    IFX_REG_W32(0x00082E00, SAR_TX_CTX_CFG);
+    IFX_REG_W32(0x00001021, SAR_POLY_CFG_SET0);
+    IFX_REG_W32(0x1EDC6F41, SAR_POLY_CFG_SET1);
+    IFX_REG_W32(0x04C11DB7, SAR_POLY_CFG_SET2);
+    IFX_REG_W32(0x00000F3E, SAR_CRC_SIZE_CFG);
+
+    IFX_REG_W32(0x01001900, SAR_PDMA_RX_CMDBUF_CFG);
+    IFX_REG_W32(0x01001A00, SAR_PDMA_TX_CMDBUF_CFG);
+}
+
+static inline void init_mailbox(void)
+{
+    IFX_REG_W32(0xFFFFFFFF, MBOX_IGU1_ISRC);
+    IFX_REG_W32(0x00000000, MBOX_IGU1_IER);
+    IFX_REG_W32(0xFFFFFFFF, MBOX_IGU3_ISRC);
+    IFX_REG_W32(0x00000000, MBOX_IGU3_IER);
+}
+
+static inline void init_atm_tc(void)
+{
+    IFX_REG_W32(0x00010040, SFSM_CFG0);
+    IFX_REG_W32(0x00010040, SFSM_CFG1);
+    IFX_REG_W32(0x00020000, SFSM_PGCNT0);
+    IFX_REG_W32(0x00020000, SFSM_PGCNT1);
+    IFX_REG_W32(0x00000000, DREG_AT_IDLE0);
+    IFX_REG_W32(0x00000000, DREG_AT_IDLE1);
+    IFX_REG_W32(0x00000000, DREG_AR_IDLE0);
+    IFX_REG_W32(0x00000000, DREG_AR_IDLE1);
+    IFX_REG_W32(0x0000080C, DREG_B0_LADR);
+    IFX_REG_W32(0x0000080C, DREG_B1_LADR);
+
+    IFX_REG_W32(0x000001F0, DREG_AR_CFG0);
+    IFX_REG_W32(0x000001F0, DREG_AR_CFG1);
+    IFX_REG_W32(0x000001E0, DREG_AT_CFG0);
+    IFX_REG_W32(0x000001E0, DREG_AT_CFG1);
+
+    /*  clear sync state    */
+    //IFX_REG_W32(0, SFSM_STATE0);
+    //IFX_REG_W32(0, SFSM_STATE1);
+
+    IFX_REG_W32_MASK(0, 1 << 14, SFSM_CFG0);    //  enable SFSM storing
+    IFX_REG_W32_MASK(0, 1 << 14, SFSM_CFG1);
+
+    IFX_REG_W32_MASK(0, 1 << 15, SFSM_CFG0);    //  HW keep the IDLE cells in RTHA buffer
+    IFX_REG_W32_MASK(0, 1 << 15, SFSM_CFG1);
+
+    IFX_REG_W32(0xF0D10000, FFSM_IDLE_HEAD_BC0);
+    IFX_REG_W32(0xF0D10000, FFSM_IDLE_HEAD_BC1);
+    IFX_REG_W32(0x00030028, FFSM_CFG0);         //  Force_idle
+    IFX_REG_W32(0x00030028, FFSM_CFG1);
+}
+
+static inline void clear_share_buffer(void)
+{
+    volatile u32 *p;
+    unsigned int i;
+
+    p = SB_RAM0_ADDR(0);
+    for ( i = 0; i < SB_RAM0_DWLEN + SB_RAM1_DWLEN + SB_RAM2_DWLEN + SB_RAM3_DWLEN; i++ )
+        IFX_REG_W32(0, p++);
+
+    p = SB_RAM6_ADDR(0);
+    for ( i = 0; i < SB_RAM6_DWLEN; i++ )
+        IFX_REG_W32(0, p++);
+}
+
+/*
+ *  Description:
+ *    Download PPE firmware binary code.
+ *  Input:
+ *    pp32      --- int, which pp32 core
+ *    src       --- u32 *, binary code buffer
+ *    dword_len --- unsigned int, binary code length in DWORD (32-bit)
+ *  Output:
+ *    int       --- 0:    Success
+ *                  else:           Error Code
+ */
+static inline int pp32_download_code(int pp32, u32 *code_src, unsigned int code_dword_len, u32 *data_src, unsigned int data_dword_len)
+{
+    unsigned int clr, set;
+    volatile u32 *dest;
+
+    if ( code_src == 0 || ((unsigned long)code_src & 0x03) != 0
+        || data_src == 0 || ((unsigned long)data_src & 0x03) != 0 )
+        return -EINVAL;
+
+    clr = pp32 ? 0xF0 : 0x0F;
+    if ( code_dword_len <= CDM_CODE_MEMORYn_DWLEN(0) )
+        set = pp32 ? (3 << 6): (2 << 2);
+    else
+        set = 0x00;
+    IFX_REG_W32_MASK(clr, set, CDM_CFG);
+
+    /*  copy code   */
+    dest = CDM_CODE_MEMORY(pp32, 0);
+    while ( code_dword_len-- > 0 )
+        IFX_REG_W32(*code_src++, dest++);
+
+    /*  copy data   */
+    dest = CDM_DATA_MEMORY(pp32, 0);
+    while ( data_dword_len-- > 0 )
+        IFX_REG_W32(*data_src++, dest++);
+
+    return 0;
+}
+
+
+
+/*
+ * ####################################
+ *           Global Function
+ * ####################################
+ */
+
+void ifx_ptm_get_fw_ver(unsigned int *major, unsigned int *mid, unsigned int *minor)
+{
+    ASSERT(major != NULL, "pointer is NULL");
+    ASSERT(minor != NULL, "pointer is NULL");
+
+    if ( *(volatile unsigned int *)FW_VER_ID_NEW == 0 ) {
+        *major = FW_VER_ID->major;
+        *mid   = ~0;
+        *minor = FW_VER_ID->minor;
+    }
+    else {
+        *major = FW_VER_ID_NEW->major;
+        *mid   = FW_VER_ID_NEW->middle;
+        *minor = FW_VER_ID_NEW->minor;
+    }
+}
+
+void ifx_ptm_init_chip(void)
+{
+    init_pmu();
+
+    reset_ppe();
+
+    init_pdma();
+
+    init_mailbox();
+
+    init_atm_tc();
+
+    clear_share_buffer();
+}
+
+void ifx_ptm_uninit_chip(void)
+{
+    uninit_pmu();
+}
+
+/*
+ *  Description:
+ *    Initialize and start up PP32.
+ *  Input:
+ *    none
+ *  Output:
+ *    int  --- 0: Success
+ *             else:        Error Code
+ */
+int ifx_pp32_start(int pp32)
+{
+    unsigned int mask = 1 << (pp32 << 4);
+    int ret;
+
+    /*  download firmware   */
+    ret = pp32_download_code(pp32, firmware_binary_code, sizeof(firmware_binary_code) / sizeof(*firmware_binary_code), firmware_binary_data, sizeof(firmware_binary_data) / sizeof(*firmware_binary_data));
+    if ( ret != 0 )
+        return ret;
+
+    /*  run PP32    */
+    IFX_REG_W32_MASK(mask, 0, PP32_FREEZE);
+
+    /*  idle for a while to let PP32 init itself    */
+    udelay(10);
+
+    return 0;
+}
+
+/*
+ *  Description:
+ *    Halt PP32.
+ *  Input:
+ *    none
+ *  Output:
+ *    none
+ */
+void ifx_pp32_stop(int pp32)
+{
+    unsigned int mask = 1 << (pp32 << 4);
+
+    /*  halt PP32   */
+    IFX_REG_W32_MASK(0, mask, PP32_FREEZE);
+}
