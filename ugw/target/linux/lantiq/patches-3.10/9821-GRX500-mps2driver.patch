# HG changeset patch
# Parent 05f257bf8d248bac012217d4f7aaffaa27730574

diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -664,5 +664,11 @@ config LTQ_SYSTEM_RESET
         default y
         ---help---
           Turn on this option to enable sytem reset driver.
+config LTQ_MPS2
+        tristate "Lantiq mps2 driver"
+				depends on SOC_GRX500||SOC_GRX500_BOOTCORE
+        default y
+        ---help---
+          Turn on this option to enable mps2 driver.
 endmenu
 
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -67,6 +67,8 @@ obj-$(CONFIG_LTQ_VOIP_TIMER)     += ltq_
 
 obj-$(CONFIG_LTQ_TEMP_SENSOR)             += ts-xway.o
 
+obj-$(CONFIG_LTQ_MPS2)+= ltq_mps2/
+
 obj-$(CONFIG_LTQ_SYSTEM_RESET)		+= ltq_reset/
 ifeq ($(CONFIG_SOC_GRX500_BOOTCORE),y)
 obj-$(CONFIG_LTQ_RCU)		+= ltq_reset/ltq_rcu/
diff --git a/drivers/char/ltq_mps2/Makefile b/drivers/char/ltq_mps2/Makefile
new file mode 100644
--- /dev/null
+++ b/drivers/char/ltq_mps2/Makefile
@@ -0,0 +1,8 @@
+#
+# drivers/char/ltq_mps2/Makefile
+#
+
+#
+# Makefile for the Lantiq mps2 driver
+#
+obj-y += drv_mps_common.o drv_mps_linux.o
diff --git a/drivers/char/ltq_mps2/drv_config.h b/drivers/char/ltq_mps2/drv_config.h
new file mode 100755
--- /dev/null
+++ b/drivers/char/ltq_mps2/drv_config.h
@@ -0,0 +1,40 @@
+/* drv_config.h.in.  Generated from configure.in by autoheader.  */
+
+/******************************************************************************
+
+                              Copyright (c) 2013
+                            Lantiq Deutschland GmbH
+                     Am Campeon 3; 85579 Neubiberg, Germany
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+#ifndef _DRV_CONFIG_H_
+#define _DRV_CONFIG_H_
+/*enable vpe0 configuration*/
+#ifdef CONFIG_SOC_GRX500_BOOTCORE
+	#define SYSTEM_4KEC
+	#define VPE0
+#elif defined(CONFIG_SOC_GRX500)
+	#define SYSTEM_GRX500
+#else
+	#define SYSTEM_VR9
+	#ifndef CONFIG_VPE1
+		#define VPE0
+	#endif
+#endif
+/*If library is defined undef all parts of else part*/
+#ifdef __LIBRARY__
+	#undef __KERNEL__
+	#undef SYSTEM_VR9
+	#undef VPE0
+#endif
+//#define FEAT_LINUX_PLATFORM_DRIVER
+/*Macros used in MPS/ICC*/
+#define SUCCESS 0
+#define ERROR -1
+#define TRUE 1
+#define FALSE 0
+#endif /* _DRV_CONFIG_H_ */
+
diff --git a/drivers/char/ltq_mps2/drv_mps.h b/drivers/char/ltq_mps2/drv_mps.h
new file mode 100755
--- /dev/null
+++ b/drivers/char/ltq_mps2/drv_mps.h
@@ -0,0 +1,154 @@
+#ifndef _DRV_MPS_VMMC_H
+#define _DRV_MPS_VMMC_H
+/******************************************************************************
+
+                              Copyright (c) 2012
+                            Lantiq Deutschland GmbH
+                             http://www.lantiq.com
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+****************************************************************************
+   Module      : drv_mps_vmmc.h
+   Description : This file contains the defines, the structures declarations
+                 the tables declarations and the global functions declarations.
+*******************************************************************************/
+
+#define MAX_UPSTRM_DATAWORDS 4
+#define ICC_PARAM_PTR 0x1
+#define ICC_PARAM_NO_PTR 0x0
+#define ICC_PARAM_PTR_IOCU 0x1
+#define ICC_PARAM_PTR_NON_IOCU 0x0
+#define CHECK_PTR(Attrs,Index) (Attrs&(ICC_PARAM_PTR<<(Index*2)))
+#define CHECK_PTR_IOCU(Attrs,Index) (Attrs&(ICC_PARAM_PTR_IOCU<<((Index*2)+1)))
+#define SET_PTR(Attrs,Index) (Attrs|(ICC_PARAM_PTR<<(Index*2)))
+#define SET_PTR_IOCU(Attrs,Index) (Attrs|(ICC_PARAM_PTR_IOCU<<((Index*2)+1)))
+#define MEM_SEG_SIZE 4096
+#define MEM_SIZE	32
+
+/* ============================= */
+/* MPS Common defines            */
+/* ============================= */
+typedef struct
+{
+#ifdef CONFIG_CPU_BIG_ENDIAN 
+   uint32_t src_id:8;
+   uint32_t dst_id:8;
+   uint32_t msg_id:8;
+   uint32_t param_attr:8;
+#else
+   uint32_t param_attr:8;
+   uint32_t msg_id:8;
+   uint32_t dst_id:8;
+   uint32_t src_id:8;
+#endif
+}mpsHd;
+
+typedef union
+{
+   uint32_t val;
+	 mpsHd Hd;
+} mpshd_u;
+ 
+
+typedef struct
+{
+   mpshd_u header;
+   uint32_t data[MAX_UPSTRM_DATAWORDS];
+} mps_message;
+
+#ifndef __LIBRARY__
+/******************************************************************************
+ * Exported IOCTLs
+ ******************************************************************************/
+/** magic number */
+#define MPS_MAGIC 'O'
+
+/**
+ * Read Message from Mailbox.
+ * \param   arg Pointer to structure #mps_message
+ * \ingroup IOCTL
+ */
+#define FIO_MPS_MB_READ _IOR(MPS_MAGIC, 3, mps_message)
+/**
+ * Write Message to Mailbox.
+ * \param   arg Pointer to structure #mps_message
+ * \ingroup IOCTL
+ */
+#define FIO_MPS_MB_WRITE _IOW(MPS_MAGIC, 4, mps_message)
+/**
+ * Reset Voice CPU.
+ * \ingroup IOCTL
+ */
+#define FIO_MPS_RESET _IO(MPS_MAGIC, 6)
+/**
+ * Restart Voice CPU.
+ * \ingroup IOCTL
+ */
+#define FIO_MPS_RESTART _IO(MPS_MAGIC, 7)
+/**
+ * Read Version String.
+ * \param   arg Pointer to version string.
+ * \ingroup IOCTL
+ */
+#define FIO_MPS_GETVERSION      _IOR(MPS_MAGIC, 8, char*)
+
+/******************************************************************************
+ * Register structure definitions
+ ******************************************************************************/
+typedef struct    /**< Register structure for Common status registers MPS_RAD0SR, MPS_SAD0SR,
+                     MPS_CAD0SR and MPS_AD0ENR  */
+{
+#ifdef CONFIG_CPU_BIG_ENDIAN
+   uint32_t res1:31;
+   uint32_t du_mbx:1;
+#else
+   uint32_t du_mbx:1;
+   uint32_t res1:31;
+#endif
+} MPS_Ad0Reg_s;
+
+typedef union
+{
+   uint32_t val;
+   MPS_Ad0Reg_s fld;
+} MPS_Ad0Reg_u;
+
+
+/******************************************************************************
+ * Exported functions
+ ******************************************************************************/
+#ifdef __KERNEL__
+bool check_mps_fifo_not_empty(void);
+int mps_init(void);
+#endif
+
+#endif/*__LIBRARY__*/
+
+#ifdef __KERNEL__
+#include <linux/fs.h>
+typedef struct /**< mps buffer monitoring structure */
+{
+   void *(*malloc) (size_t size, int32_t priority); /**< Buffer alloc function (def. kmalloc) */
+   void (*free) (const void *ptr);  /**< Buffer free  function (def. kfree) */
+   int32_t (*init) (void); /** Manager init function */
+   int32_t (*close) (void); /** Manager shutdown function */
+} mps_buf_mng_t;
+extern mps_buf_mng_t mps_buffer;
+int32_t mps_open (struct inode *inode, struct file *file_p);
+int32_t mps_close (struct inode *inode, struct file *filp);
+long mps_ioctl (struct file *filp,uint32_t nCmd, unsigned long arg);
+int32_t mps_register_callback (void (*callback) (void));
+int32_t mps_unregister_callback (void);
+int32_t mps_read_mailbox (mps_message * rw);
+int32_t mps_write_mailbox (mps_message * rw);
+void mps_bufman_register (void *
+                                    (*malloc) (size_t size,
+                                               int32_t priority),
+                                    void (*free) (const void * ptr));
+
+extern void cache_inv (ulong addr, uint32_t len);
+extern void cache_wb_inv (ulong addr, uint32_t len);
+#endif /*__KERNEL__*/
+#endif /* _DRV_MPS_VMMC_H */
diff --git a/drivers/char/ltq_mps2/drv_mps_common.c b/drivers/char/ltq_mps2/drv_mps_common.c
new file mode 100755
--- /dev/null
+++ b/drivers/char/ltq_mps2/drv_mps_common.c
@@ -0,0 +1,1647 @@
+/******************************************************************************
+
+                              Copyright (c) 2013
+                            Lantiq Deutschland GmbH
+                             http://www.lantiq.com
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+****************************************************************************
+   Module      : drv_mps_vmmc_common.c
+   Description : This file contains the implementation of the common MPS
+                 driver functions.
+*******************************************************************************/
+
+/* ============================= */
+/* Includes                      */
+/* ============================= */
+#include "drv_config.h"
+
+#include <linux/version.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include "drv_mps.h"
+#include "drv_mps_dbg.h"
+#include "drv_mps_device.h"
+
+/* ============================= */
+/* Local Macros & Definitions    */
+/* ============================= */
+#define MPS_UNUSED(var) ((void)(var))
+/* ============================= */
+/* Global variable definition    */
+/* ============================= */
+static DEFINE_SPINLOCK(g_mps2_lock_malloc);
+static DEFINE_SPINLOCK(g_mps2_lock_free);
+static DEFINE_SPINLOCK(g_mps2_lock);
+static DEFINE_SPINLOCK(g_mps2_lock_read);
+static DEFINE_SPINLOCK(g_mps2_lock_write);
+mps_comm_dev mps_dev;
+/** This variable holds the actual base address of the MPS register block. */
+uint32_t mps_reg_base=MPS_BASE_ADDR;  /* MPS registers */
+/** This variable holds the actual base address of the MPS SRAM area. */
+uint32_t mps_ram_base=(u32)MPS_SRAM;  /* MPS memory */
+/** This variable holds the interrupt number of the IRQ associated with the
+    MPS status register 4 which is used for AFE and DFE 0 status. */
+uint32_t mps_ir4=MPS_IR4;       /* MPS AD0 register interrupt */
+uint32_t mps_ir0=MPS_IR0;       /* MPS register interrupt */
+uint32_t mps_ir1=MPS_IR1; /* MPS register interrupt */
+
+/* ============================= */
+/* Global function declaration   */
+/* ============================= */
+void mps_mbx_data_upstream (ulong dummy);
+#ifndef __LIBRARY__
+int32_t mps_bufman_close (void);
+int32_t mps_mbx_read_message (mps_fifo * fifo, MbxMsg_s * msg,
+                                      uint32_t * bytes);
+
+void *mps_fastbuf_malloc (size_t size, int32_t priority);
+void mps_fastbuf_free (const void * ptr);
+#ifndef VPE0
+int32_t mps_fastbuf_init (void);
+int32_t mps_fastbuf_close (void);
+uint32_t mps_reset_structures (mps_comm_dev * pDev);
+#endif
+bool mps_ext_bufman (void);
+extern int mpsexcpt;
+/* ============================= */
+/* Local function declaration    */
+/* ============================= */
+
+/* ============================= */
+/* Local variable definition     */
+/* ============================= */
+/* global structure that holds VCPU buffer management data */
+mps_buf_mng_t mps_buffer = {
+   /* fast buffer manager */
+   .malloc = &mps_fastbuf_malloc,
+   .free = &mps_fastbuf_free,
+#ifndef VPE0
+   .init = &mps_fastbuf_init,
+   .close = &mps_fastbuf_close,
+#endif
+};
+
+mps_comm_dev *pMPSDev = &mps_dev;
+
+
+/******************************************************************************
+ * Fast bufferpool
+ ******************************************************************************/
+#define FASTBUF_USED     0x00000001
+#define FASTBUF_FW_OWNED 0x00000002
+#define FASTBUF_BUFS     (MPS_BUFFER_INITIAL*2)
+#define FASTBUF_BUFSIZE  MPS_MEM_SEG_DATASIZE
+uint32_t *fastbuf_ptr;
+uint32_t fastbuf_initialized = 0;
+uint32_t *fastbuf_pool;
+uint32_t *fastbuf_pool_unaligned;
+
+/* cache operations */
+#ifdef SYSTEM_4KEC
+#define CACHE_LINE_SZ 16
+#else
+#define CACHE_LINE_SZ 32
+#endif
+void cache_wb_inv (ulong addr, uint32_t len);
+void cache_inv (ulong addr, uint32_t len);
+
+/* ============================= */
+/* Local function definition     */
+/* ============================= */
+/**
+ * External buffer management check
+ * Checks for external buffer manager (e.g. lib_bufferpool).
+ *
+ * \param   none
+ *
+ * \return  TRUE    External buffer manager is used (e.g. lib_bufferpool)
+ * \return  FALSE   MPS internal buffer manager is used (fastbuf)
+ * \ingroup Internal
+ */
+bool mps_ext_bufman ()
+{
+   return (((mps_buffer.malloc != &mps_fastbuf_malloc) ||
+            (mps_buffer.free != &mps_fastbuf_free)) ? TRUE : FALSE);
+}
+
+/**
+ * Buffer allocate
+ * Allocates and returns a buffer from the buffer pool.
+ *
+ * \param   size        Size of requested buffer
+ * \param   priority    Ignored, always atomic
+ *
+ * \return  ptr    Address of the allocated buffer
+ * \return  NULL   No buffer available
+ * \ingroup Internal
+ */
+void *mps_fastbuf_malloc (size_t size, int32_t priority)
+{
+   unsigned long flags;
+   uint32_t ptr;
+#ifndef VPE0
+   int32_t findex = 0;
+#else
+  int32_t findex = MPS_BUFFER_INITIAL;
+#endif
+
+   if (fastbuf_initialized == 0)
+   {
+#ifdef VPE0
+   	uint32_t *ptr;
+	 	mps_mbx_reg *MBX_Memory = (mps_mbx_reg *) mps_ram_base;
+   	ptr = (uint32_t *)MBX_Memory->MBX_VPE1_PTR;
+	 	TRACE (MPS2, DBG_LEVEL_LOW, ("VPE0 buffer pool pointer is %p\n",ptr));
+	 	fastbuf_pool=ptr;
+		if(!fastbuf_pool){
+      TRACE (MPS2, DBG_LEVEL_HIGH,
+             ("%s() - error, fast buffer not initialised\n", __FUNCTION__));
+			return NULL;
+		}
+   	fastbuf_initialized = 1;
+#else
+      TRACE (MPS2, DBG_LEVEL_HIGH,
+             ("%s() - error, fast buffer not initialised\n", __FUNCTION__));
+      return NULL;
+#endif
+   }
+
+   if (size > FASTBUF_BUFSIZE)
+   {
+      TRACE (MPS2, DBG_LEVEL_HIGH,
+             ("%s() - error, buffer too large\n", __FUNCTION__));
+      return NULL;
+   }
+
+   spin_lock_irqsave (&g_mps2_lock_malloc,flags);
+   do
+   {
+      if (fastbuf_pool[findex] & FASTBUF_USED)
+         continue;
+      ptr = fastbuf_pool[findex];
+      fastbuf_pool[findex] |= FASTBUF_USED;
+      if ((priority == FASTBUF_FW_OWNED))
+         fastbuf_pool[findex] |= priority;
+      spin_unlock_irqrestore (&g_mps2_lock_malloc,flags);
+      return (void *) ptr;
+   } 
+#ifndef VPE0
+while (++findex < MPS_BUFFER_INITIAL);
+#else
+while (++findex < FASTBUF_BUFS);
+#endif
+   spin_unlock_irqrestore (&g_mps2_lock_malloc,flags);
+   TRACE (MPS2, DBG_LEVEL_HIGH,
+          ("%s() - error, buffer pool empty\n", __FUNCTION__));
+
+   return NULL;
+}
+
+
+/**
+ * Buffer free
+ * Returns a buffer to the buffer pool.
+ *
+ * \param   ptr    Address of the allocated buffer
+ *
+ * \return  none
+ * \ingroup Internal
+ */
+void mps_fastbuf_free (const void * ptr)
+{
+   unsigned long flags;
+   int32_t findex = 0;
+
+   spin_lock_irqsave (&g_mps2_lock_free,flags);
+   do
+   {
+      if ((fastbuf_pool[findex] & ~(FASTBUF_FW_OWNED ))
+          == ((uint32_t) ptr | FASTBUF_USED))
+      {
+         fastbuf_pool[findex] &=
+            ~(FASTBUF_FW_OWNED);
+         fastbuf_pool[findex] &= ~FASTBUF_USED;
+         spin_unlock_irqrestore (&g_mps2_lock_free,flags);
+         return;
+      }
+   } 
+	 while (++findex < FASTBUF_BUFS);
+   spin_unlock_irqrestore (&g_mps2_lock_free,flags);
+   TRACE (MPS2, DBG_LEVEL_HIGH,
+          ("%s() - error, buffer not inside pool (0x%p)\n", __FUNCTION__, ptr));
+}
+
+#ifndef VPE0
+/**
+ * Create MPS fastbuf proc file output.
+ * This function creates the output for the fastbuf proc file
+ *
+ * \param   buf      Buffer to write the string to
+ * \return  len      Lenght of data in buffer
+ * \ingroup Internal
+ */
+int32_t mps_fastbuf_get_proc (struct seq_file *s)
+{
+   int32_t findex = 0;
+
+   if (fastbuf_initialized == 0)
+   {
+      seq_printf (s, "Fastbuf not initialized.\n");
+      return 0;
+   }
+
+   seq_printf (s, "   Buffer   Owner  \n");
+
+   do
+   {
+      seq_printf (s, "0x%08x ", fastbuf_pool[findex] & 0xfffffffc);
+      if (fastbuf_pool[findex] & FASTBUF_USED)
+      {
+         seq_printf (s, " used - ");
+         if (fastbuf_pool[findex] & FASTBUF_FW_OWNED)
+            seq_printf (s, " BOOT CORE\n");
+         else
+            seq_printf (s, " IAP \n");
+      }
+      else
+         seq_printf (s, " free\n");
+   } while (++findex != FASTBUF_BUFS);
+   return 0;
+}
+
+
+/**
+ * Bufferpool init
+ * Initializes a buffer pool of size FASTBUF_BUFSIZE * FASTBUF_BUFS and
+ * separates it into FASTBUF_BUFS chunks. The 32byte alignment of the chunks
+ * is guaranteed by increasing the buffer size accordingly. The pointer to
+ * the pool is stored in fastbuf_ptr, while the pointers to the singles chunks
+ * are maintained in fastbuf_pool.
+ * Bit 0 of the address in fastbuf_pool is used as busy indicator.
+ *
+ * \return -ENOMEM  Memory allocation failed
+ * \return  SUCCESS      Buffer pool initialized
+ * \ingroup Internal
+ */
+int32_t mps_fastbuf_init (void)
+{
+   uint32_t *ptr, i;
+   uint32_t bufsize = (FASTBUF_BUFSIZE + (FASTBUF_BUFSIZE % 32));
+
+   if ((fastbuf_ptr = kmalloc(FASTBUF_BUFS * bufsize,GFP_KERNEL|GFP_DMA)) == NULL)
+      return -ENOMEM;
+   ptr = fastbuf_ptr;
+
+	 fastbuf_pool_unaligned=kmalloc((FASTBUF_BUFS * sizeof(uint32_t))+PAGE_SIZE,GFP_KERNEL|GFP_DMA);
+	 fastbuf_pool=(uint32_t *)(((uint32_t)fastbuf_pool_unaligned+PAGE_SIZE-1)&PAGE_MASK);
+	 fastbuf_pool=(uint32_t *)(KSEG1ADDR(fastbuf_pool)); /*changing it to have uncached access always*/
+   for (i = 0; i < FASTBUF_BUFS; i++)
+   {
+      fastbuf_pool[i] = (uint32_t) ptr;
+      ptr = (uint32_t *) ((uint32_t) ptr + bufsize);
+   }
+   fastbuf_initialized = 1;
+   return SUCCESS;
+}
+
+
+/**
+ * Bufferpool close
+ * Frees the buffer pool allocated by mps_fastbuf_init and clears the
+ * buffer pool.
+ *
+ * \return -ENOMEM  Memory allocation failed
+ * \return  SUCCESS      Buffer pool initialized
+ * \ingroup Internal
+ */
+int32_t mps_fastbuf_close (void)
+{
+   int32_t i;
+
+   if (fastbuf_initialized)
+   {
+      for (i = 0; i < FASTBUF_BUFS; i++)
+         fastbuf_pool[i] = 0;
+      kfree (fastbuf_ptr);
+			kfree (fastbuf_pool_unaligned);
+      fastbuf_initialized = 0;
+   }
+   return SUCCESS;
+}
+#endif
+
+/******************************************************************************
+ * Buffer manager
+ ******************************************************************************/
+/**
+ * Init buffer management
+ * This function initializes the buffer management data structures and
+ * provides buffer segments to CPU1.
+ *
+ * \return  0        SUCCESS, initialized and message sent
+ * \return  -1       Error during message transmission
+ * \ingroup Internal
+ */
+int32_t mps_bufman_init (void)
+{
+   int32_t ret = ERROR;
+   /* Initialize MPS fastbuf pool only in case of MPS internal buffer
+      management. Initialization of MPS fastbuf pool is not required in case of
+      external buffer pool management (e.g. lib_bufferpool). */
+   if (FALSE == mps_ext_bufman ())
+	 {
+#ifndef VPE0
+      mps_buffer.init ();
+#endif
+		ret=SUCCESS;
+	 }
+   return ret;
+}
+
+
+/**
+ * Close buffer management
+ * This function is called on termination of voice CPU firmware. The registered
+ * close function has to take care of freeing buffers still left in VCPU.
+ *
+ * \return  0        SUCCESS, buffer manage shutdown correctly
+ * \return  -1       Error during shutdown
+ * \ingroup Internal
+ */
+int32_t mps_bufman_close (void)
+{
+   int32_t ret = ERROR;
+#ifndef VPE0
+   mps_buffer.close ();
+#else
+   uint32_t i;
+   for (i =0 ; i < FASTBUF_BUFS; i++)
+   {
+      fastbuf_pool[i] = 0;
+   }
+			fastbuf_initialized=0;
+#endif
+   return ret;
+}
+
+
+/**
+ * Free buffer
+ *
+ * \ingroup Internal
+ */
+void mps_bufman_free (const void * ptr)
+{
+   mps_buffer.free ((void *) KSEG0ADDR (ptr));
+}
+
+/**
+ * Allocate buffer
+ *
+ * \ingroup Internal
+ */
+void *mps_bufman_malloc (size_t size, int32_t priority)
+{
+   void *ptr;
+
+   ptr = mps_buffer.malloc (size, priority);
+   return ptr;
+}
+
+
+/**
+ * Overwrite buffer management
+ * Allows the upper layer to register its own malloc/free functions in order to do
+ * its own buffer managment. To unregister driver needs to be re-initialized.
+ *
+ * \param   malloc      Buffer allocation - arguments and return value as kmalloc
+ * \param   free        Buffer de-allocation - arguments and return value as kmalloc
+ * \param   buf_size    Size of buffers provided to voice CPU
+ * \param   treshold    Count of buffers provided to voice CPU
+ */
+void mps_bufman_register (void *
+                                    (*malloc) (size_t size,
+                                               int32_t priority),
+                                    void (*free) (const void * ptr))
+{
+   mps_buffer.malloc = malloc;
+   mps_buffer.free = free;
+}
+#endif/* __LIBRARY__*/
+/******************************************************************************
+ * FIFO Managment
+ ******************************************************************************/
+
+/**
+ * Clear FIFO
+ * This function clears the FIFO by resetting the pointers. The data itself is
+ * not cleared.
+ *
+ * \param   fifo    Pointer to FIFO structure
+ * \ingroup Internal
+ */
+void mps_fifo_clear (mps_fifo * fifo)
+{
+   *fifo->pread_off = fifo->size - 4;
+   *fifo->pwrite_off = fifo->size - 4;
+   return;
+}
+
+
+/**
+ * Check FIFO for being not empty
+ * This function checks whether the referenced FIFO contains at least
+ * one unread data byte.
+ *
+ * \param   fifo     Pointer to FIFO structure
+ * \return  1        TRUE if data to be read is available in FIFO,
+ * \return  0        FALSE if FIFO is empty.
+ * \ingroup Internal
+ */
+bool mps_fifo_not_empty (mps_fifo * fifo)
+{
+   if (*fifo->pwrite_off == *fifo->pread_off)
+      return FALSE;
+
+   else
+      return TRUE;
+}
+
+#ifdef __LIBRARY__
+bool check_mps_fifo_not_empty(void){
+	return mps_fifo_not_empty(mps_dev.mb.upstrm_fifo);
+}
+#endif
+/**
+ * Check FIFO for free memory
+ * This function returns the amount of free bytes in FIFO.
+ *
+ * \param   fifo     Pointer to FIFO structure
+ * \return  0        The FIFO is full,
+ * \return  count    The number of available bytes
+ * \ingroup Internal
+ */
+uint32_t mps_fifo_mem_available (mps_fifo * fifo)
+{
+   uint32_t retval;
+
+   retval =
+      (fifo->size - 1 - (*fifo->pread_off - *fifo->pwrite_off)) & (fifo->size -
+                                                                   1);
+   return (retval);
+}
+
+
+/**
+ * Check FIFO for requested amount of memory
+ * This function checks whether the requested FIFO is capable to store
+ * the requested amount of data bytes.
+ * The selected Fifo should be a downstream direction Fifo.
+ *
+ * \param   fifo     Pointer to mailbox structure to be checked
+ * \param   bytes    Requested data bytes
+ * \return  1        TRUE if space is available in FIFO,
+ * \return  0        FALSE if not enough space in FIFO.
+ * \ingroup Internal
+ */
+bool mps_fifo_mem_request (mps_fifo * fifo, uint32_t bytes)
+{
+   uint32_t bytes_avail = mps_fifo_mem_available (fifo);
+
+   if (bytes_avail > bytes)
+   {
+      return TRUE;
+   }
+   else
+   {
+      return FALSE;
+   }
+}
+
+
+/**
+ * Update FIFO read pointer
+ * This function updates the position of the referenced FIFO.In case of
+ * reaching the FIFO's end the pointer is set to the start position.
+ *
+ * \param   fifo      Pointer to FIFO structure
+ * \param   increment Increment for read index
+ * \ingroup Internal
+ */
+void mps_fifo_read_ptr_inc (mps_fifo * fifo, uint8_t increment)
+{
+   int32_t new_read_index =
+      (int32_t) (*fifo->pread_off) - (int32_t) increment;
+
+   if ((uint32_t) increment > fifo->size)
+   {
+      TRACE (MPS2, DBG_LEVEL_HIGH,
+             ("%s(): Invalid offset passed: %d !\n", __FUNCTION__, increment));
+      return;
+   }
+
+   if (new_read_index >= 0)
+   {
+      *(fifo->pread_off) = (uint32_t) new_read_index;
+   }
+   else
+   {
+      *(fifo->pread_off) = (uint32_t) (new_read_index + (int32_t) (fifo->size));        /* overflow */
+   }
+
+   return;
+}
+
+
+/**
+ * Update FIFO write pointer
+ * This function updates the position of the write pointer of the referenced FIFO.
+ * In case of reaching the FIFO's end the pointer is set to the start position.
+ *
+ * \param   fifo      Pointer to FIFO structure
+ * \param   increment Increment of write index
+ * \ingroup Internal
+ */
+void mps_fifo_write_ptr_inc (mps_fifo * fifo, u16 increment)
+{
+   /* calculate new index ignoring ring buffer overflow */
+   int32_t new_write_index =
+      (int32_t) (*fifo->pwrite_off) - (int32_t) increment;
+
+   if ((uint32_t) increment > fifo->size)
+   {
+      TRACE (MPS2, DBG_LEVEL_HIGH,
+             ("%s(): Invalid offset passed: %d !\n", __FUNCTION__, increment));
+      return;
+   }
+
+   if (new_write_index >= 0)
+   {
+      *fifo->pwrite_off = (uint32_t) new_write_index;       /* no overflow */
+   }
+   else
+   {
+      *fifo->pwrite_off =
+         (uint32_t) (new_write_index + (int32_t) (fifo->size));
+   }
+   return;
+}
+
+
+/**
+ * Write data word to FIFO
+ * This function writes a data word (32bit) to the referenced FIFO. The word is
+ * written to the position defined by the current write pointer index and the
+ * offset being passed.
+ *
+ * \param   fifo           Pointer to FIFO structure
+ * \param   data           Data word to be written
+ * \param   offset         Byte offset to be added to write pointer position
+ * \return  0              SUCCESS, word written
+ * \return  -1             Invalid offset.
+ * \ingroup Internal
+ */
+int32_t mps_fifo_write (mps_fifo * fifo, uint32_t data,
+                                uint8_t offset)
+{
+   /* calculate write position */
+   int32_t new_write_index =
+      (int32_t) * fifo->pwrite_off - (int32_t) offset;
+   uint32_t write_address;
+
+   if (offset > fifo->size)
+   {
+      TRACE (MPS2, DBG_LEVEL_HIGH,
+             ("%s(): Invalid offset passed !\n", __FUNCTION__));
+      return -1;
+   }
+   write_address =
+      (uint32_t) fifo->pend + *fifo->pwrite_off - (uint32_t) offset;
+   if (new_write_index < 0)
+   {
+      write_address += fifo->size;
+   }
+   *(uint32_t *) write_address = data;
+   return 0;
+}
+
+
+
+/**
+ * Read data word from FIFO
+ * This function reads a data word (32bit) from the referenced FIFO. It first
+ * calculates and checks the address defined by the FIFO's read index and passed
+ * offset. The read pointer is not updated by this function.
+ * It has to be updated after the complete message has been read.
+ *
+ * \param   fifo          Pointer to FIFO structure
+ * \param   offset        Offset to read pointer position to be read from
+ * \return  count         Number of data words read.
+ * \return  -1            Invalid offset
+ * \ingroup Internal
+ */
+int32_t mps_fifo_read (mps_fifo * fifo, uint8_t offset,
+                               uint32_t * pData)
+{
+   uint32_t read_address;
+   int32_t new_read_index =
+      ((int32_t) * fifo->pread_off) - (int32_t) offset;
+   int32_t ret;
+
+   if (!mps_fifo_not_empty (fifo))
+   {
+      TRACE (MPS2, DBG_LEVEL_HIGH,
+             ("%s(): FIFO %p is empty\n", __FUNCTION__, fifo));
+      ret = ERROR;
+   }
+   else
+   {
+      if (offset > fifo->size)
+      {
+         TRACE (MPS2, DBG_LEVEL_HIGH,
+                ("%s(): Invalid offset passed: %d !\n", __FUNCTION__, offset));
+         return -1;
+      }
+      read_address =
+         (uint32_t) fifo->pend + (uint32_t) * fifo->pread_off -
+         (uint32_t) offset;
+      if (new_read_index < 0)
+      {
+         read_address += fifo->size;
+      }
+      *pData = *(uint32_t *) read_address;
+      ret = SUCCESS;
+   }
+   return (ret);
+}
+
+#ifndef  __LIBRARY__
+/******************************************************************************
+ * Global Routines
+ ******************************************************************************/
+
+/**
+ * Open MPS device
+ * Open routine for the MPS device driver.
+ *
+ * \param   mps_device  MPS communication device structure
+ * \param   pMBDev      Pointer to mailbox device structure
+ * \return  0           SUCCESS, successfully opened
+ * \return  -1          ERROR, Driver already installed
+ * \ingroup Internal
+ */
+int32_t mps_common_open (mps_comm_dev * mps_device,
+                                 mps_mbx_dev * pMBDev,
+                                 bool from_kernel)
+{
+   unsigned long flags;
+
+   spin_lock_irqsave (&g_mps2_lock,flags);
+
+   /* device is already installed or unknown device ID used */
+   if ((pMBDev->Installed == TRUE) || (pMBDev->devID == 0))
+   {
+      spin_unlock_irqrestore (&g_mps2_lock,flags);
+      return (ERROR);
+   }
+   pMBDev->Installed = TRUE;
+   spin_unlock_irqrestore (&g_mps2_lock,flags);
+      if (from_kernel)
+      {
+         pMBDev->upstrm_fifo = &mps_device->upstrm_fifo;
+         pMBDev->dwstrm_fifo = &mps_device->dwstrm_fifo;
+      }
+      else
+      {
+         pMBDev->upstrm_fifo = &mps_device->sw_upstrm_fifo;
+         pMBDev->dwstrm_fifo = &mps_device->dwstrm_fifo;
+      }
+
+   return (SUCCESS);
+}
+
+/**
+ * Register callback.
+ * Allows the upper layer to register a callback function either for
+ * downstream (tranmsit mailbox space available) or for upstream (read data
+ * available)
+ *
+ * \param   type     DSP device entity ( 1 - command, 2 - voice0, 3 - voice1,
+ *                   4 - voice2, 5 - voice3, 6 - voice4 )
+ * \param   callback Callback function to register
+ * \return  0        SUCCESS, callback registered successfully
+ * \return  ENXIO    Wrong DSP device entity (only 1-5 supported)
+ * \return  EBUSY    Callback already registered
+ * \return  EINVAL   Callback parameter null
+ * \ingroup API
+*/
+int32_t mps_register_callback (void (*callback) (void))
+{
+   mps_mbx_dev *pMBDev;
+
+   if (callback == NULL)
+   {
+      return (-EINVAL);
+   }
+
+   /* Get corresponding mailbox device structure */
+   if ((pMBDev = &mps_dev.mb) == 0)
+      return (-ENXIO);
+   if (pMBDev->up_callback != NULL)
+	  {
+      return (-EBUSY);
+   }
+   else
+   {
+      pMBDev->up_callback = callback;
+   } 
+	return (SUCCESS);
+}
+
+/**
+ * UnRegister callback.
+ * Allows the upper layer to unregister a callback function either for
+ *
+ * \param   type     DSP device entity ( 1 - command, 2 - voice0, 3 - voice1,
+ *                   4 - voice2, 5 - voice3, 6 - voice4 )
+ * \param   callback Callback function to register
+ * \return  0        SUCCESS, callback registered successfully
+ * \return  ENXIO    Wrong DSP device entity (only 1-5 supported)
+ * \return  EINVAL   nothing to unregister
+ * \ingroup API
+*/
+int32_t mps_unregister_callback (void)
+{
+   mps_mbx_dev *pMBDev;
+
+   /* Get corresponding mailbox device structure */
+   if ((pMBDev = &mps_dev.mb) == 0)
+      return (-ENXIO);
+   if (pMBDev->up_callback == NULL)
+	  {
+      return (-EINVAL);
+   }
+   else
+   {
+      pMBDev->up_callback = NULL;
+   } 
+	return (SUCCESS);
+}
+
+
+/**
+ * Close routine for MPS device driver
+ * This function closes the channel assigned to the passed mailbox
+ * device structure.
+ *
+ * \param   pMBDev   Pointer to mailbox device structure
+ * \return  0        SUCCESS, will never fail
+ * \ingroup Internal
+ */
+int32_t mps_common_close (mps_mbx_dev * pMBDev,
+                                  bool from_kernel)
+{
+   MPS_UNUSED(from_kernel);
+
+   /* clean data structures */
+   if (pMBDev->Installed == FALSE)
+   {
+      return (ERROR);
+   }
+   pMBDev->Installed = FALSE;
+
+   /* Clear the downstream queues for voice fds only */
+   {
+#ifdef CONFIG_PROC_FS
+      pMBDev->upstrm_fifo->min_space = MBX_DATA_UPSTRM_FIFO_SIZE;
+      pMBDev->dwstrm_fifo->min_space = MBX_DATA_DNSTRM_FIFO_SIZE;
+#endif /* */
+      /* clean-up messages left in software fifo... */
+      while (mps_fifo_not_empty (pMBDev->upstrm_fifo))
+      {
+         uint32_t bytes_read;
+         MbxMsg_s msg;
+         mps_mbx_read_message (pMBDev->upstrm_fifo, &msg, &bytes_read);
+         pMBDev->upstrm_fifo->discards++;
+      }
+      /* reset software fifo... */
+      *pMBDev->upstrm_fifo->pwrite_off = (pMBDev->upstrm_fifo->size - 4);
+      *pMBDev->upstrm_fifo->pread_off = (pMBDev->upstrm_fifo->size - 4);
+   }
+   return (SUCCESS);
+}
+#endif/*ifndef __LIBRARY__*/
+/**
+ * MPS Structure Initialization
+ * This function initializes the data structures of the Multi Processor System
+ * that are necessary for inter processor communication
+ *
+ * \param   pDev     Pointer to MPS device structure to be initialized
+ * \return  0        SUCCESS, if initialization was successful
+ * \return  -1       ERROR, allocation or semaphore access problem
+ * \ingroup Internal
+ */
+int32_t mps_init_structures (mps_comm_dev * pDev)
+{
+   mps_mbx_reg *MBX_Memory;
+
+   /* Initialize MPS main structure */
+   memset ((void *) pDev, 0, sizeof (mps_comm_dev));
+   pDev->base_global = (mps_mbx_reg *) mps_ram_base;
+   pDev->flags = 0x00000000;
+   MBX_Memory = pDev->base_global;
+
+   /* * Initialize common mailbox definition area which is used by both CPUs
+      for MBX communication. These are: mailbox base address, mailbox size, *
+      mailbox read index and mailbox write index. for command and voice
+      mailbox, * upstream and downstream direction. */
+#ifndef VPE0
+   memset ( /* avoid to overwrite CPU boot registers */
+            (void *) MBX_Memory,
+            0,
+            sizeof (mps_mbx_reg));
+#else
+   memset ( /* avoid to overwrite CPU boot registers */
+            (void *) MBX_Memory,
+            0,
+            sizeof (mps_mbx_reg) - (sizeof(uint32_t)));
+#endif
+   MBX_Memory->MBX_UPSTR_DATA_BASE =
+      (uint32_t *) CPHYSADDR ((uint32_t) MBX_UPSTRM_DATA_FIFO_BASE);
+   MBX_Memory->MBX_UPSTR_DATA_SIZE = MBX_DATA_UPSTRM_FIFO_SIZE;
+   MBX_Memory->MBX_DNSTR_DATA_BASE =
+      (uint32_t *) CPHYSADDR ((uint32_t) MBX_DNSTRM_DATA_FIFO_BASE);
+   MBX_Memory->MBX_DNSTR_DATA_SIZE = MBX_DATA_DNSTRM_FIFO_SIZE;
+
+   /* set read and write pointers below to the FIFO's uppermost address */
+   MBX_Memory->MBX_UPSTR_DATA_READ = (MBX_Memory->MBX_UPSTR_DATA_SIZE - 4);
+   MBX_Memory->MBX_UPSTR_DATA_WRITE = MBX_Memory->MBX_UPSTR_DATA_READ;
+   MBX_Memory->MBX_DNSTR_DATA_READ = (MBX_Memory->MBX_DNSTR_DATA_SIZE - 4);
+   MBX_Memory->MBX_DNSTR_DATA_WRITE = MBX_Memory->MBX_DNSTR_DATA_READ;
+#ifndef VPE0
+	/*If the buffer management is by external module he should write this adress
+		here as well*/
+#ifndef __LIBRARY__
+	 if(FALSE == mps_ext_bufman ())
+	 MBX_Memory->MBX_VPE1_PTR = (uint32_t)fastbuf_pool;
+#endif
+#endif
+
+   /* voice upstream data mailbox area */
+   pDev->upstrm_fifo.pstart =
+      (uint32_t *) KSEG1ADDR (MBX_Memory->MBX_UPSTR_DATA_BASE +
+                                  ((MBX_Memory->MBX_UPSTR_DATA_SIZE - 4) >> 2));
+   pDev->upstrm_fifo.pend =
+      (uint32_t *) KSEG1ADDR (MBX_Memory->MBX_UPSTR_DATA_BASE);
+   pDev->upstrm_fifo.pwrite_off =
+      (uint32_t *) & (MBX_Memory->MBX_UPSTR_DATA_WRITE);
+   pDev->upstrm_fifo.pread_off =
+      (uint32_t *) & (MBX_Memory->MBX_UPSTR_DATA_READ);
+   pDev->upstrm_fifo.size = MBX_Memory->MBX_UPSTR_DATA_SIZE;
+
+#ifdef CONFIG_PROC_FS
+   pDev->upstrm_fifo.min_space = MBX_Memory->MBX_UPSTR_DATA_SIZE;
+   pDev->upstrm_fifo.discards = 0;
+#endif /* */
+
+   /* voice downstream data mailbox area */
+   pDev->dwstrm_fifo.pstart =
+      (uint32_t *) KSEG1ADDR (MBX_Memory->MBX_DNSTR_DATA_BASE +
+                                  ((MBX_Memory->MBX_DNSTR_DATA_SIZE - 4) >> 2));
+   pDev->dwstrm_fifo.pend =
+      (uint32_t *) KSEG1ADDR (MBX_Memory->MBX_DNSTR_DATA_BASE);
+   pDev->dwstrm_fifo.pwrite_off =
+      (uint32_t *) & (MBX_Memory->MBX_DNSTR_DATA_WRITE);
+   pDev->dwstrm_fifo.pread_off =
+      (uint32_t *) & (MBX_Memory->MBX_DNSTR_DATA_READ);
+   pDev->dwstrm_fifo.size = MBX_Memory->MBX_DNSTR_DATA_SIZE;
+
+#ifdef CONFIG_PROC_FS
+   pDev->dwstrm_fifo.min_space = MBX_Memory->MBX_UPSTR_DATA_SIZE;
+#endif /* */
+
+   /* configure voice channel communication structure fields that are common to
+      all voice channels */
+   {
+      /* voice upstream data software fifo */
+      pDev->sw_upstrm_fifo.pend =
+         kmalloc(MBX_Memory->MBX_UPSTR_DATA_SIZE + 8,GFP_ATOMIC);
+      pDev->sw_upstrm_fifo.pstart =
+         (pDev->sw_upstrm_fifo.pend +
+          ((MBX_Memory->MBX_UPSTR_DATA_SIZE - 4) >> 2));
+      pDev->sw_upstrm_fifo.pwrite_off =
+         (pDev->sw_upstrm_fifo.pend +
+          ((MBX_Memory->MBX_UPSTR_DATA_SIZE) >> 2));
+      *pDev->sw_upstrm_fifo.pwrite_off =
+         (MBX_Memory->MBX_UPSTR_DATA_SIZE - 4);
+      pDev->sw_upstrm_fifo.pread_off =
+         (pDev->sw_upstrm_fifo.pend +
+          ((MBX_Memory->MBX_UPSTR_DATA_SIZE + 4) >> 2));
+      *pDev->sw_upstrm_fifo.pread_off =
+         (MBX_Memory->MBX_UPSTR_DATA_SIZE - 4);
+      pDev->sw_upstrm_fifo.size = MBX_Memory->MBX_UPSTR_DATA_SIZE;
+#ifdef CONFIG_PROC_FS
+      pDev->sw_upstrm_fifo.min_space = MBX_Memory->MBX_UPSTR_DATA_SIZE;
+      pDev->sw_upstrm_fifo.discards = 0;
+#endif /* */
+      memset ((void *) pDev->sw_upstrm_fifo.pend, 0x00,
+              MBX_Memory->MBX_UPSTR_DATA_SIZE);
+
+      /* upstrm fifo pointer might be changed on open... */
+      pDev->mb.upstrm_fifo = &pDev->upstrm_fifo;
+      pDev->mb.dwstrm_fifo = &pDev->dwstrm_fifo;
+      pDev->mb.Installed = FALSE;  /* current mbx installation
+                                                   status */
+      /* select mechanism implemented for each queue */
+      init_waitqueue_head(&(pDev->mb.mps_wakeuplist));
+   }
+
+   /* set channel identifiers */
+   pDev->mb.devID = 1;
+   /* allocate buffer for firmware image data */
+   return 0;
+}
+
+#ifndef __LIBRARY__
+/**
+ * MPS Structure Reset
+ * This function resets the global structures into inital state
+ *
+ * \param   pDev     Pointer to MPS device structure
+ * \return  0        SUCCESS, if initialization was successful
+ * \return  -1       ERROR, allocation or semaphore access problem
+ * \ingroup Internal
+ */
+uint32_t mps_reset_structures (mps_comm_dev * pDev)
+{
+#ifdef CONFIG_PROC_FS
+   pDev->dwstrm_fifo.min_space = pDev->dwstrm_fifo.size;
+   pDev->dwstrm_fifo.bytes = 0;
+   pDev->dwstrm_fifo.pkts = 0;
+   pDev->dwstrm_fifo.discards = 0;
+#endif /* */
+   {
+      mps_fifo_clear (pDev->mb.dwstrm_fifo);
+      mps_fifo_clear (pDev->mb.upstrm_fifo);
+
+#ifdef CONFIG_PROC_FS
+      pDev->mb.upstrm_fifo->min_space =
+         pDev->mb.upstrm_fifo->size;
+      pDev->mb.upstrm_fifo->bytes = 0;
+      pDev->mb.upstrm_fifo->pkts = 0;
+      pDev->mb.upstrm_fifo->discards = 0;
+#endif /* */
+   }
+   return SUCCESS;
+}
+
+#endif/* __LIBRARY__*/
+
+/**
+ * Read message from upstream data mailbox
+ * This function reads a complete data message from the upstream data mailbox.
+ * It reads the header checks how many payload words are included in the message
+ * and reads the payload afterwards. The mailbox's read pointer is updated afterwards
+ * by the amount of words read.
+ *
+ * \param   fifo        Pointer to mailbox structure to be read from
+ * \param   msg         Pointer to message structure read from buffer
+ * \param   bytes       Pointer to number of bytes included in read message
+ * \return  0           SUCCESS, successful read operation,
+ * \return  -1          Invalid length field read.
+ * \ingroup Internal
+ */
+int32_t mps_mbx_read_message (mps_fifo * fifo, MbxMsg_s * msg,
+                                      uint32_t * bytes)
+{
+   int32_t i, j,ret;
+#ifndef __LIBRARY__
+   unsigned long flags;
+   spin_lock_irqsave (&g_mps2_lock_read,flags);
+#endif
+	 ret = mps_fifo_read (fifo, (uint8_t)0, &msg->header.val);
+	 if (ret == ERROR)
+   {
+#ifndef __LIBRARY__
+    spin_unlock_irqrestore (&g_mps2_lock_read,flags);
+#endif
+   	return ret;
+   }
+	 j=MBX_LENGTH-4;
+   for (i = 0; i < j; i += 4)      /* read message payload
+                                                         */
+   {
+      ret = mps_fifo_read (fifo, (uint8_t) (i + 4), &msg->data[i / 4]);
+      if (ret == ERROR)
+      {
+#ifndef __LIBRARY__
+         spin_unlock_irqrestore (&g_mps2_lock_read,flags);
+#endif
+         return ret;
+      }
+   }
+   *bytes = MBX_LENGTH;
+   mps_fifo_read_ptr_inc (fifo,MBX_LENGTH);
+#ifndef __LIBRARY__
+   spin_unlock_irqrestore (&g_mps2_lock_read,flags);
+#endif
+   return SUCCESS;
+}
+
+
+/**
+ * Read message from FIFO
+ * This function reads a message from the upstream data mailbox and passes it
+ * to the calling function. A call to the notify_upstream function will trigger
+ * another wakeup in case there is already more data available.
+ *
+ * \param   pMBDev   Pointer to mailbox device structure
+ * \param   pPkg     Pointer to data transfer structure (output parameter)
+ * \param   timeout  Currently unused
+ * \return  0        SUCCESS, successful read operation,
+ * \return  -1       ERROR, in case of read error.
+ * \return  -ENODATA No data was available
+ * \return  -EBADMSG Accidential read of buffer message
+ * \ingroup Internal
+ */
+int32_t mps_mbx_read (mps_mbx_dev * pMBDev, mps_message * pPkg,
+                              int32_t timeout)
+{
+   MbxMsg_s msg;
+   uint32_t bytes = 0;
+   mps_fifo *fifo;
+   int32_t retval = ERROR;
+#ifndef __LIBRARY__
+	uint32_t i;
+#endif
+
+   MPS_UNUSED(timeout);
+
+   fifo = pMBDev->upstrm_fifo;
+   memset (&msg, 0, sizeof (msg));      /* initialize msg pointer */
+   if (!mps_fifo_not_empty (fifo))
+   {
+      /* Nothing available for this channel... */
+      return -ENODATA;
+   }
+
+   /* read message from mailbox */
+   if (mps_mbx_read_message (fifo, &msg, &bytes) == 0)
+   {
+      {
+				memcpy(pPkg,&msg,sizeof(msg));
+#if !defined(__LIBRARY__)
+				for(i=0;i<MAX_UPSTRM_DATAWORDS;i++){
+					if(CHECK_PTR(pPkg->header.Hd.param_attr,i)){
+#ifdef SYSTEM_GRX500
+						if(CHECK_PTR_IOCU(pPkg->header.Hd.param_attr,i)) 
+									pPkg->data[i]=RPHYSADDR(pPkg->data[i])|KSEG2;
+						else
+									pPkg->data[i]=RPHYSADDR(pPkg->data[i])|KSEG0;
+#else
+									pPkg->data[i]=KSEG0ADDR(pPkg->data[i]);
+#endif
+					}
+				}
+#endif
+            retval = SUCCESS;
+#ifdef CONFIG_PROC_FS
+            pMBDev->upstrm_fifo->bytes += bytes;
+#endif /* */
+      }
+   }
+   return retval;
+}
+
+
+/**
+ * Build 32 bit word starting at byte_ptr.
+ * This function builds a 32 bit word out of 4 consecutive bytes
+ * starting at byte_ptr position.
+ *
+ * \param   byte_ptr  Pointer to first byte (most significat 8 bits) of word calculation
+ * \return  value     Returns value of word starting at byte_ptr position
+ * \ingroup Internal
+ */
+uint32_t mps_mbx_build_word (uint8_t * byte_ptr)
+{
+   uint32_t result = 0x00000000;
+   int32_t i;
+
+   for (i = 0; i < 4; i++)
+   {
+      result += (uint32_t) (*(byte_ptr + i)) << ((3 - i) * 8);
+   }
+   return (result);
+}
+
+
+/**
+ * Write to Downstream Mailbox of MPS.
+ * This function writes messages into the downstream mailbox to be read
+ * by CPU1
+ *
+ * \param   pMBDev    Pointer to mailbox device structure
+ * \param   msg_ptr   Pointer to message
+ * \param   msg_bytes Number of bytes in message
+ * \return  0         Returns SUCCESS in case of successful write operation
+ * \return  -EAGAIN   in case of access fails with FIFO overflow while in irq
+ * \return  -EIO      in case of access fails with FIFO overflow in task context
+ * \ingroup Internal
+ */
+int32_t mps_mbx_write_message (mps_mbx_dev * pMBDev,
+                                       uint8_t * msg_ptr,
+                                       uint32_t msg_bytes)
+{
+   mps_fifo *mbx;
+   uint32_t i;
+#ifndef __LIBRARY__
+   unsigned long flags;
+   MPS_Ad0Reg_u Ad0Reg;
+#endif
+   int32_t retval = -EAGAIN;
+   int32_t retries = 0;
+   uint32_t word = 0;
+   bool word_aligned = TRUE;
+   static uint32_t trace_fag;
+
+#ifndef __LIBRARY__
+   spin_lock_irqsave (&g_mps2_lock_write,flags);
+#endif
+   mbx = pMBDev->dwstrm_fifo;   /* set pointer to downstream mailbox FIFO
+                                   structure */
+   if ((uint32_t) msg_ptr & 0x00000003)
+   {
+      word_aligned = FALSE;
+      TRACE (MPS2, DBG_LEVEL_HIGH,
+             ("%s(): Passed message not word aligned !!!\n", __FUNCTION__));
+   }
+
+   /* request for downstream mailbox buffer memory, make MAX_FIFO_WRITE_RETRIES
+      attempts in case not enough memory is not available */
+   while (++retries <= MAX_FIFO_WRITE_RETRIES)
+   {
+      if (mps_fifo_mem_request (mbx, msg_bytes) == TRUE)
+      {
+         trace_fag = 0;
+         break;
+      }
+#ifndef __LIBRARY__
+
+      if (in_interrupt ())
+      {
+         retries = MAX_FIFO_WRITE_RETRIES + 1;
+         break;
+      }
+      else
+      {
+         {
+            spin_unlock_irqrestore (&g_mps2_lock_write,flags);
+            udelay (125);
+            spin_lock_irqsave (&g_mps2_lock_write,flags);
+         }
+      }
+#endif
+   }
+
+   if (retries <= MAX_FIFO_WRITE_RETRIES)
+   {
+      /* write message words to mailbox buffer starting at write pointer
+         position and update the write pointer index by the amount of written
+         data afterwards */
+      for (i = 0; i < msg_bytes; i += 4)
+      {
+         if (word_aligned)
+            mps_fifo_write (mbx, *(uint32_t *) (msg_ptr + i), i);
+         else
+         {
+            word = mps_mbx_build_word (msg_ptr + i);
+            mps_fifo_write (mbx, word, i);
+         }
+      }
+      mps_fifo_write_ptr_inc (mbx, msg_bytes);
+#ifndef __LIBRARY__
+#ifndef VPE0
+   		Ad0Reg.val = *MPS_RAD0SR;
+#else
+   		Ad0Reg.val = *MPS_RAD1SR;
+#endif
+   		Ad0Reg.fld.du_mbx = 1;
+#ifndef VPE0
+      *MPS_SAD0SR |= Ad0Reg.val;
+#else
+      *MPS_SAD1SR |= Ad0Reg.val;
+#endif			
+#endif
+
+      retval = SUCCESS;
+
+#ifdef CONFIG_PROC_FS
+      pMBDev->dwstrm_fifo->pkts++;
+      pMBDev->dwstrm_fifo->bytes += msg_bytes;
+      if (mbx->min_space > mps_fifo_mem_available (mbx))
+         mbx->min_space = mps_fifo_mem_available (mbx);
+#endif /* CONFIG_PROC_FS */
+   }
+   else
+   {
+      /* insufficient space in the mailbox for writing the data */
+
+      /** \todo update error statistics */
+
+      if (!trace_fag)           /* protect from trace flood */
+      {
+         TRACE (MPS2, DBG_LEVEL_LOW,
+                ("%s(): write message timeout\n", __FUNCTION__));
+
+         /* trace only once until write succeeds at least one time */
+         trace_fag = 1;
+      }
+#ifndef __LIBRARY__
+
+      /* If the command downstream mailbox stays full for several milliseconds,
+         a fatal error has occurred and the voice CPU should be restarted */
+      if (!in_interrupt ())
+      {
+
+         /* -> return fatal error */
+         retval = -EIO;
+      }
+#endif
+   }
+#ifndef __LIBRARY__
+   spin_unlock_irqrestore (&g_mps2_lock_write,flags);
+#endif
+   return retval;
+}
+
+
+/**
+ * Write to Downstream Data Mailbox of MPS.
+ * This function writes the passed message into the downstream data mailbox.
+ *
+ * \param   pMBDev     Pointer to mailbox device structure
+ * \param   readWrite  Pointer to message structure
+ * \return  0          SUCCESS in case of successful write operation
+ * \return  -1         ERROR in case of access fails with FIFO overflow
+ * \ingroup Internal
+ */
+int32_t mps_mbx_write_data (mps_mbx_dev * pMBDev,
+                                    mps_message * readWrite)
+{
+   int32_t retval = ERROR;
+	 int32_t i;
+   {
+  		for(i=0;i<MAX_UPSTRM_DATAWORDS;i++){
+  			if(CHECK_PTR(readWrite->header.Hd.param_attr,i)){
+#ifdef VPE0
+      		readWrite->data[i] = CPHYSADDR ((uint32_t) readWrite->data[i]);
+#else
+			#ifdef SYSTEM_GRX500
+      		readWrite->data[i] = RPHYSADDR ((uint32_t) readWrite->data[i]);
+			#else
+      		readWrite->data[i] = CPHYSADDR ((uint32_t) readWrite->data[i]);
+			#endif
+#endif
+				}
+			}
+      if ((retval =
+           mps_mbx_write_message (pMBDev, (uint8_t *)readWrite,
+                                      MBX_LENGTH)) != SUCCESS)
+      {
+         TRACE (MPS2, DBG_LEVEL_LOW,
+                ("%s(): Writing data failed ! *\n", __FUNCTION__));
+      }
+   }
+
+   return retval;
+}
+
+#ifndef  __LIBRARY__
+
+/**
+ * Notify queue about upstream data reception
+ * This function checks the channel identifier included in the header
+ * of the message currently pointed to by the upstream data mailbox's
+ * read pointer. It wakes up the related queue to read the received data message
+ * out of the mailbox for further processing. The process is repeated
+ * as long as upstream messages are avaiilable in the mailbox.
+ * The function is attached to the driver's poll/select functionality.
+ *
+ * \param   dummy    Tasklet parameter, not used.
+ * \ingroup Internal
+ */
+void mps_mbx_data_upstream (ulong dummy)
+{
+   mps_fifo *mbx;
+   mps_mbx_dev *mbx_dev;
+   MbxMsg_s msg;
+   uint32_t bytes_read = 0;
+   unsigned long flags;
+   int32_t ret;
+
+   MPS_UNUSED(dummy);
+
+   /* set pointer to data upstream mailbox*/
+   mbx = &pMPSDev->upstrm_fifo;
+   while (mps_fifo_not_empty (mbx))
+   {
+      /* select mailbox device structure acc. to channel ID read from current
+         msg */
+      {
+            mbx_dev = (mps_mbx_dev *) & (pMPSDev->mb);
+      }
+			
+#ifdef CONFIG_PROC_FS
+      if (mbx->min_space > mps_fifo_mem_available (mbx))
+         mbx->min_space = mps_fifo_mem_available (mbx);
+      mbx->pkts++;
+      mbx->bytes +=  MBX_LENGTH;
+#endif /* */
+      {
+         /* discard packet in case no one is listening... */
+         if (mbx_dev->Installed == FALSE)
+         {
+          data_upstream_discard:
+            mps_mbx_read_message (mbx, &msg, &bytes_read);
+            mbx_dev->upstrm_fifo->discards++;
+            continue;
+         }
+				 if (mbx_dev->up_callback != NULL)
+				 {
+						spin_lock_irqsave (&g_mps2_lock,flags);
+  					mbx_dev->up_callback();
+						spin_unlock_irqrestore(&g_mps2_lock,flags);
+						continue;
+  			 }
+				 else
+         {
+            int32_t i, msg_bytes;
+
+            msg_bytes = MBX_LENGTH;
+            if (mps_fifo_mem_request (mbx_dev->upstrm_fifo, msg_bytes) !=
+                TRUE)
+            {
+               goto data_upstream_discard;
+            }
+						spin_lock_irqsave (&g_mps2_lock,flags);
+            /* Copy message into sw fifo */
+            for (i = 0; i < msg_bytes; i += 4)
+            {
+               uint32_t data;
+
+               ret = mps_fifo_read (mbx, (uint8_t) i, &data);
+               if (ret == ERROR){
+                  return;
+							 }
+               mps_fifo_write (mbx_dev->upstrm_fifo, data, (uint8_t) i);
+            }
+            mps_fifo_read_ptr_inc (mbx, msg_bytes);
+            mps_fifo_write_ptr_inc (mbx_dev->upstrm_fifo, msg_bytes);
+						spin_unlock_irqrestore(&g_mps2_lock,flags);
+#ifdef CONFIG_PROC_FS
+            if (mbx_dev->upstrm_fifo->min_space >
+                mps_fifo_mem_available (mbx_dev->upstrm_fifo))
+               mbx_dev->upstrm_fifo->min_space =
+                  mps_fifo_mem_available (mbx_dev->upstrm_fifo);
+            mbx_dev->upstrm_fifo->pkts++;
+#endif /* CONFIG_PROC_FS */
+						mpsexcpt=1;
+            /* use queue wake up to notify about data reception */
+            wake_up_interruptible(&(mbx_dev->mps_wakeuplist));
+         }
+      }
+   }
+   return;
+}
+
+/**
+   This function enables mailbox interrupts on Danube.
+\param
+   None.
+\return
+   None.
+*/
+
+void mps_enable_mailbox_int ()
+{
+   MPS_Ad0Reg_u Ad0Reg;
+#ifdef VPE0
+   Ad0Reg.val = *MPS_AD0ENR;
+#else
+   Ad0Reg.val = *MPS_AD1ENR;
+#endif
+   Ad0Reg.fld.du_mbx = 1;
+#ifdef VPE0
+   *MPS_AD0ENR = Ad0Reg.val;
+#else
+   *MPS_AD1ENR = Ad0Reg.val;
+#endif
+}
+
+/**
+   This function disables mailbox interrupts on Danube.
+\param
+   None.
+\return
+   None.
+*/
+void mps_disable_mailbox_int ()
+{
+   MPS_Ad0Reg_u Ad0Reg;
+
+#ifdef VPE0
+   Ad0Reg.val = *MPS_AD0ENR;
+#else
+   Ad0Reg.val = *MPS_AD1ENR;
+#endif
+   Ad0Reg.fld.du_mbx = 0;
+#ifdef VPE0
+   *MPS_AD0ENR = Ad0Reg.val;
+#else
+   *MPS_AD1ENR = Ad0Reg.val;
+#endif
+}
+
+/**
+   This function disables all MPS interrupts on Danube.
+\param
+   None.
+\return
+   None.
+*/
+void mps_disable_all_int ()
+{
+#ifdef VPE0
+   *MPS_SAD0SR = 0x00000000;
+#else
+   *MPS_SAD1SR = 0x00000000;
+#endif
+}
+
+/******************************************************************************
+ * Interrupt service routines
+ ******************************************************************************/
+
+/**
+ * Upstream data interrupt handler
+ * This function is called on occurence of an data upstream interrupt.
+ * Depending on the occured interrupt either the command or data upstream
+ * message processing is started via tasklet
+ *
+ * \param   irq      Interrupt number
+ * \param   pDev     Pointer to MPS communication device structure
+ * \ingroup Internal
+ */
+irqreturn_t mps_ad0_irq (int32_t irq, mps_comm_dev * pDev)
+{
+   MPS_Ad0Reg_u MPS_Ad0StatusReg;
+
+   MPS_UNUSED(pDev);
+#ifdef VPE0
+   /* read interrupt status */
+   MPS_Ad0StatusReg.val = *MPS_RAD0SR;
+   /* acknowledge interrupt */
+   *MPS_CAD0SR = MPS_Ad0StatusReg.val;
+   /* handle only enabled interrupts */
+   MPS_Ad0StatusReg.val &= *MPS_AD0ENR;
+#else
+	 /* read interrupt status */
+   MPS_Ad0StatusReg.val = *MPS_RAD1SR;
+   /* acknowledge interrupt */
+   *MPS_CAD1SR = MPS_Ad0StatusReg.val;
+   /* handle only enabled interrupts */
+   MPS_Ad0StatusReg.val &= *MPS_AD1ENR;
+#endif
+   if (MPS_Ad0StatusReg.fld.du_mbx)
+   {
+#ifdef CONFIG_PROC_FS
+      pMPSDev->mb.upstrm_fifo->pkts++;
+#endif /* CONFIG_PROC_FS */
+      mps_mbx_data_upstream (0);
+   }
+
+   return IRQ_HANDLED;
+}
+/**
+ * Issue a Hit_Invalidate_D operation on a data segment of a
+ * given size at given address. Address range is aligned to the
+ * multiple of a cache line size.
+ *
+ * \param   addr    Address of a data segment
+ * \param   len     Length in bytes of a data segment
+ * \return  none
+ * \ingroup Internal
+ * \remarks addr parameter must be in KSEG0
+ */
+void cache_inv (ulong addr, uint32_t len)
+{
+   ulong aline = addr & ~(CACHE_LINE_SZ - 1);
+   ulong end   = (addr + len - 1) & ~(CACHE_LINE_SZ - 1);
+
+	 if(addr<KSEG0||addr>KSEG1){
+			TRACE (MPS2, DBG_LEVEL_HIGH, ("Invalid address for cache ops %x\n",addr));
+			return;
+	 }
+
+   while (1)
+   {
+      __asm__ __volatile__(
+         " .set    push        \n"
+         " .set    noreorder   \n"
+         " .set    mips3\n\t   \n"
+         " cache   0x11, 0(%0) \n"
+         " .set    pop         \n"
+         : :"r"(aline));
+
+#ifndef VPE0
+      __asm__ __volatile__(
+         " .set    push        \n"
+         " .set    noreorder   \n"
+         " .set    mips3\n\t   \n"
+         " cache   0x13, 0(%0) \n"
+         " .set    pop         \n"
+         : :"r"(aline));
+#endif
+
+      if (aline == end)
+         break;
+
+      aline += CACHE_LINE_SZ;
+   }
+}
+
+/**
+ * Issue a Hit_Writeback_Inv_D operation on a data segment of a
+ * given size at given address. Address range is aligned to the
+ * multiple of a cache line size.
+ *
+ * \param   addr    Address of a data segment
+ * \param   len     Length in bytes of a data segment
+ * \return  none
+ * \ingroup Internal
+ * \remarks addr parameter must be in KSEG0
+ */
+void cache_wb_inv (ulong addr, uint32_t len)
+{
+   ulong aline = addr & ~(CACHE_LINE_SZ - 1);
+   ulong end   = (addr + len - 1) & ~(CACHE_LINE_SZ - 1);
+	 if(addr<KSEG0||addr>KSEG1){
+			TRACE (MPS2, DBG_LEVEL_HIGH, ("Invalid address for cache ops %x\n",addr));
+			return;
+	 }
+   while (1)
+   {
+      __asm__ __volatile__(
+         " .set    push            \n"
+         " .set    noreorder       \n"
+         " .set    mips3\n\t       \n"
+         " cache   0x15, 0(%0)     \n"
+         " .set    pop             \n"
+         : :"r" (aline));
+
+#ifndef VPE0
+      __asm__ __volatile__(
+         " .set    push            \n"
+         " .set    noreorder       \n"
+         " .set    mips3\n\t       \n"
+         " cache   0x17, 0(%0)     \n"
+         " .set    pop             \n"
+         : :"r" (aline));
+#endif
+      if (aline == end)
+         break;
+
+      aline += CACHE_LINE_SZ;
+   }
+   /* MIPS multicore write reordering workaround:
+      writing to on-chip SRAM and off-chip SDRAM can be reordered in time on
+      MIPS multicore, in other words, there is no guarantee that write
+      operation to SDRAM is finished at the moment of passing a data pointer to
+      voice CPU  through data mailbox in SRAM.
+      Workaround sequence:
+      1) Write back (and invalidate) all used cache lines
+      2) SYNC
+      3) Read-back uncahed one word
+      4) SYNC
+      5) Write data pointer message to the mailbox in the on-chip SRAM */
+   __asm__ __volatile__(" sync \n");
+   /* dummy read back uncached */
+   *((volatile uint32_t *)KSEG1ADDR(aline));
+   __asm__ __volatile__(" sync \n");
+}
+EXPORT_SYMBOL (mps_bufman_register);
+EXPORT_SYMBOL (mps_buffer);
+EXPORT_SYMBOL (cache_wb_inv);
+EXPORT_SYMBOL (cache_inv);
+#else 
+EXPORT_SYMBOL(check_mps_fifo_not_empty);
+#endif /* __LIBRARY__*/
diff --git a/drivers/char/ltq_mps2/drv_mps_dbg.h b/drivers/char/ltq_mps2/drv_mps_dbg.h
new file mode 100755
--- /dev/null
+++ b/drivers/char/ltq_mps2/drv_mps_dbg.h
@@ -0,0 +1,28 @@
+#ifndef _DRV_MPS_VMMC_DBG_H
+#define _DRV_MPS_VMMC_DBG_H
+/******************************************************************************
+
+                              Copyright (c) 2012
+                            Lantiq Deutschland GmbH
+                             http://www.lantiq.com
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+****************************************************************************
+   Module      : drv_mps_vmmc_dbg.h
+   Description : This file contains the macro definitions for runtime trace.
+*******************************************************************************/
+#define DBG_LEVEL_OFF      4
+#define DBG_LEVEL_HIGH     3
+#define DBG_LEVEL_NORMAL   2
+#define DBG_LEVEL_LOW      1
+
+#define CREATE_TRACE_GROUP(name) unsigned int G_nTraceGroup##name = DBG_LEVEL_HIGH
+#define DECLARE_TRACE_GROUP(name) extern unsigned int G_nTraceGroup##name
+#define PRINTF printk 
+#define TRACE(name,level,message) do {if(level >= G_nTraceGroup##name) \
+      { PRINTF message ; } } while(0)
+
+#endif  /* _DRV_MPS_VMMC_DBG_H */
+
diff --git a/drivers/char/ltq_mps2/drv_mps_device.h b/drivers/char/ltq_mps2/drv_mps_device.h
new file mode 100755
--- /dev/null
+++ b/drivers/char/ltq_mps2/drv_mps_device.h
@@ -0,0 +1,261 @@
+#ifndef _DRV_MPS_VMMC_DEVICE_H
+#define _DRV_MPS_VMMC_DEVICE_H
+/******************************************************************************
+
+                              Copyright (c) 2013
+                            Lantiq Deutschland GmbH
+                             http://www.lantiq.com
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+****************************************************************************
+   Module      : drv_mps_vmmc_device.h
+   Description : This file contains the defines, the structures declarations
+                 the tables declarations and the device specific functions
+                 declarations.
+*******************************************************************************/
+#include <asm/ltq_vpe.h>
+#include <irq.h>
+#include <lantiq_irq.h>
+
+/** This variable holds the actual base address of the MPS register block. */
+extern uint32_t mps_reg_base;  /* MPS registers */
+/** This variable holds the actual base address of the MPS SRAM area. */
+extern uint32_t mps_ram_base;  /* MPS memory */
+/** This variable holds the interrupt number of the IRQ associated with the
+    MPS status register 4 which is used for AFE and DFE 0 status. */
+extern uint32_t mps_ir4;       /* MPS AD0 register interrupt */
+extern uint32_t mps_ir0;       /* MPS register interrupt */
+extern uint32_t mps_ir1;       /* MPS register interrupt */
+
+/* MPS register block */
+#ifndef SYSTEM_VR9
+	#define MPS_BASE_ADDR        (KSEG1 | 0x1F107400)
+	#define MPS_SRAM             ((volatile u32 *)(KSEG1 | 0x1F201000))
+#else
+	#define MPS_BASE_ADDR        (KSEG1 | 0x1F107000)
+	#define MPS_SRAM             ((volatile u32 *)(KSEG1 | 0x1F200000))
+#endif
+#define MPS_RAD0SR              ((u32 *)(mps_reg_base + 0x0040))
+#define MPS_RAD1SR              ((u32 *)(mps_reg_base + 0x0084))
+#define MPS_SAD0SR              ((u32 *)(mps_reg_base + 0x0048))
+#define MPS_SAD1SR              ((u32 *)(mps_reg_base + 0x0070))
+#define MPS_CAD0SR              ((u32 *)(mps_reg_base + 0x0050))
+#define MPS_CAD1SR              ((u32 *)(mps_reg_base + 0x0080))
+#define MPS_AD0ENR              ((u32 *)(mps_reg_base + 0x0058))
+#define MPS_AD1ENR              ((u32 *)(mps_reg_base + 0x0074))
+
+#ifndef SYSTEM_VR9
+/* Interrupt vectors */
+	#define MPS_IR4  /* AD0 */          						 22
+	#define MPS_IR0  /* Global interrupt */          223
+	#define MPS_IR1  /* Global interrupt */          224
+#else
+/* Interrupt vectors */
+	#define MPS_IR4  /* AD0 */                       154
+	#define MPS_IR0  /* Global interrupt */          8
+	#define MPS_IR1  /* Global interrupt */          9
+#endif
+/* ============================= */
+/* MPS Common defines            */
+/* ============================= */
+/*---------------------------------------------------------------------------*/
+/* Mailbox definitions                                                       */
+/*---------------------------------------------------------------------------*/
+#ifdef VPE0
+	#if defined(SYSTEM_GRX500)||defined(SYSTEM_4KEC)
+		#define MBX_DATA_UPSTRM_FIFO_SIZE 496
+		#define MBX_DATA_DNSTRM_FIFO_SIZE 492
+	#else
+		#define MBX_DATA_UPSTRM_FIFO_SIZE 240
+		#define MBX_DATA_DNSTRM_FIFO_SIZE 236
+	#endif
+#define MBX_RW_POINTER_AREA_SIZE 32
+/* base addresses for mailboxes (upstream and downstream ) */
+#define MBX_UPSTRM_DATA_FIFO_BASE   (mps_ram_base + MBX_RW_POINTER_AREA_SIZE)
+#define MBX_DNSTRM_DATA_FIFO_BASE   (MBX_UPSTRM_DATA_FIFO_BASE + MBX_DATA_UPSTRM_FIFO_SIZE)
+#else
+	#if defined(SYSTEM_GRX500)||defined(SYSTEM_4KEC)
+		#define MBX_DATA_UPSTRM_FIFO_SIZE 492
+		#define MBX_DATA_DNSTRM_FIFO_SIZE 496
+	#else
+		#define MBX_DATA_UPSTRM_FIFO_SIZE 236
+		#define MBX_DATA_DNSTRM_FIFO_SIZE 240
+	#endif
+#define MBX_RW_POINTER_AREA_SIZE 32
+/* base addresses for mailboxes (upstream and downstream ) */
+#define MBX_DNSTRM_DATA_FIFO_BASE   (mps_ram_base + MBX_RW_POINTER_AREA_SIZE)
+#define MBX_UPSTRM_DATA_FIFO_BASE   (MBX_DNSTRM_DATA_FIFO_BASE + MBX_DATA_DNSTRM_FIFO_SIZE)
+#endif
+
+
+#if defined(SYSTEM_GRX500)||defined(SYSTEM_4KEC)
+	#define MBX_DATA_WORDS 247
+#else 
+	#define MBX_DATA_WORDS 119
+#endif
+
+
+#define MAX_FIFO_WRITE_RETRIES 80
+#define MBX_LENGTH 20
+
+/*---------------------------------------------------------------------------*/
+/* MPS buffer provision management structure definitions                   */
+/*---------------------------------------------------------------------------*/
+
+#define MPS_BUFFER_INITIAL   MEM_SIZE 
+#define MPS_MEM_SEG_DATASIZE MEM_SEG_SIZE
+
+/*---------------------------------------------------------------------------*/
+/* DEVICE DEPENDENCIES                                                       */
+/*---------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------*/
+/* Register structure definitions                                            */
+/*---------------------------------------------------------------------------*/
+typedef enum
+{
+   UPSTREAM,
+   DOWNSTREAM
+} MbxDirection_e;
+
+typedef struct
+{
+#ifdef CONFIG_CPU_BIG_ENDIAN
+   uint32_t src_id:8;
+   uint32_t dst_id:8;
+   uint32_t msg_id:8;
+   uint32_t param_attr:8;
+#else
+   uint32_t param_attr:8;
+   uint32_t msg_id:8;
+   uint32_t dst_id:8;
+   uint32_t src_id:8;
+#endif
+}MbxMsgHd;
+
+typedef union
+{
+   uint32_t val;
+	 MbxMsgHd Hd;
+} MbxMsgHd_u;
+ 
+
+typedef struct
+{
+   MbxMsgHd_u header;
+   uint32_t data[MAX_UPSTRM_DATAWORDS];
+} MbxMsg_s;
+
+/*---------------------------------------------------------------------------*/
+/* FIFO structure                                                            */
+/*---------------------------------------------------------------------------*/
+typedef struct
+{
+   volatile uint32_t *volatile pstart;     /**< Pointer to FIFO's read/write start address */
+   volatile uint32_t *volatile pend;       /**< Pointer to FIFO's read/write end address */
+   volatile uint32_t *volatile pwrite_off; /**< Pointer to FIFO's write index location */
+   volatile uint32_t *volatile pread_off;  /**< Pointer to FIFO's read index location */
+   volatile uint32_t size;        /**< FIFO size */
+   volatile uint32_t min_space;   /**< FIFO size */
+   volatile uint32_t bytes;
+   volatile uint32_t pkts;
+   volatile uint32_t discards;
+} mps_fifo;
+
+/*
+ * This structure represents the MPS mailbox definition area that is shared
+ * by CCPU and VCPU. It comprises the mailboxes' base addresses and sizes in bytes as well as the
+ *
+ *
+ */
+typedef struct
+{
+#ifdef VPE0
+   volatile uint32_t *MBX_UPSTR_DATA_BASE; /**< Upstream Data FIFO Base Address */
+   volatile uint32_t MBX_UPSTR_DATA_SIZE;  /**< Upstream Data FIFO size in byte */
+   volatile uint32_t *MBX_DNSTR_DATA_BASE; /**< Downstream Data FIFO Base Address */
+   volatile uint32_t MBX_DNSTR_DATA_SIZE;  /**< Downstream Data FIFO size in byte */
+   volatile uint32_t MBX_UPSTR_DATA_READ;   /**< Upstream Data FIFO Read Index */
+   volatile uint32_t MBX_UPSTR_DATA_WRITE;  /**< Upstream Data FIFO Write Index */
+   volatile uint32_t MBX_DNSTR_DATA_READ;   /**< Downstream Data FIFO Read Index */
+   volatile uint32_t MBX_DNSTR_DATA_WRITE;  /**< Downstream Data FIFO Write Index */
+#else
+   volatile uint32_t *MBX_DNSTR_DATA_BASE; /**< Downstream Data FIFO Base Address */
+   volatile uint32_t MBX_DNSTR_DATA_SIZE;  /**< Downstream Data FIFO size in byte */
+   volatile uint32_t *MBX_UPSTR_DATA_BASE; /**< Upstream Data FIFO Base Address */
+   volatile uint32_t MBX_UPSTR_DATA_SIZE;  /**< Upstream Data FIFO size in byte */
+   volatile uint32_t MBX_DNSTR_DATA_READ;   /**< Downstream Data FIFO Read Index */
+   volatile uint32_t MBX_DNSTR_DATA_WRITE;  /**< Downstream Data FIFO Write Index */
+   volatile uint32_t MBX_UPSTR_DATA_READ;   /**< Upstream Data FIFO Read Index */
+   volatile uint32_t MBX_UPSTR_DATA_WRITE;  /**< Upstream Data FIFO Write Index */
+#endif
+   volatile uint32_t MBX_DATA[MBX_DATA_WORDS];
+   volatile uint32_t MBX_VPE1_PTR;  				/**< Downstream Data FIFO Write Index */
+} mps_mbx_reg;
+
+/*---------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------*/
+/* Device connection structure                                               */
+/*---------------------------------------------------------------------------*/
+
+/**
+ * Mailbox Device Structure.
+ * This Structure holds top level parameters of the mailboxes used to allow
+ * the communication between the control CPU and the Voice CPU
+ */
+typedef struct
+{
+   /* Wakeuplist for the select mechanism */
+   wait_queue_head_t  mps_wakeuplist;
+   mps_fifo *upstrm_fifo;    /**< Data exchange FIFO for read (upstream) */
+   mps_fifo *dwstrm_fifo;    /**< Data exchange FIFO for write (downstream) */
+	 void (*up_callback) (void);
+	 int32_t devID;
+   volatile int32_t Installed;
+   struct cdev *mps_cdev;
+} mps_mbx_dev;
+
+/*---------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------*/
+/* Device structure                                                          */
+/*---------------------------------------------------------------------------*/
+
+/**
+ * Mailbox Device Structure.
+ * This Structure represents the communication device that provides the resources
+ * for the communication between CPU0 and CPU1
+ */
+typedef struct
+{
+   mps_mbx_reg *base_global;   /**< global register pointer for the ISR */
+   uint32_t flags;                   /**< Pointer to private date of the specific handler */
+   mps_mbx_dev mb;     /**< Data upstream and downstream mailboxes */
+   mps_fifo upstrm_fifo;
+   mps_fifo dwstrm_fifo;
+   mps_fifo sw_upstrm_fifo;
+} mps_comm_dev;
+
+/*---------------------------------------------------------------------------*/
+int32_t mps_common_open (mps_comm_dev * pDev, mps_mbx_dev * pMBDev,
+                                 bool from_kernel);
+int32_t mps_common_close (mps_mbx_dev * pMBDev,
+                                  bool from_kernel);
+int32_t mps_mbx_read (mps_mbx_dev * pMBDev, mps_message * pPkg,
+                              int32_t timeout);
+int32_t mps_mbx_write_data (mps_mbx_dev * pMBDev,
+                                    mps_message * readWrite);
+int32_t mps_init_structures (mps_comm_dev * pDev);
+uint32_t mps_fifo_mem_available (mps_fifo * mbx);
+int32_t mps_bufman_init (void);
+void mps_bufman_free (const void * ptr);
+void *mps_bufman_malloc (size_t size, int32_t priority);
+void mps_disable_mailbox_int (void);
+void mps_disable_all_int (void);
+void mps_enable_mailbox_int (void);
+DECLARE_TRACE_GROUP (MPS2);
+#endif /* _DRV_MPS_VMMC_DEVICE_H */
diff --git a/drivers/char/ltq_mps2/drv_mps_linux.c b/drivers/char/ltq_mps2/drv_mps_linux.c
new file mode 100755
--- /dev/null
+++ b/drivers/char/ltq_mps2/drv_mps_linux.c
@@ -0,0 +1,1191 @@
+/******************************************************************************
+
+                              Copyright (c) 2013
+                            Lantiq Deutschland GmbH
+                             http://www.lantiq.com
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+/**
+   \file drv_mps_vmmc_linux.c  Header file of the MPS driver Linux part.
+   This file contains the implementation of the linux specific driver functions.
+*/
+
+/* ============================= */
+/* Includes                      */
+/* ============================= */
+#include "drv_config.h"
+#include "drv_mps_version.h"
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/vmalloc.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#ifdef FEAT_LINUX_PLATFORM_DRIVER
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#endif /* FEAT_LINUX_PLATFORM_DRIVER */
+
+#ifdef CONFIG_PROC_FS
+   #include <linux/proc_fs.h>
+   #define MPS_FEAT_PROCFS_LEGACY_API
+
+   #if (LINUX_VERSION_CODE > KERNEL_VERSION(3,8,0))
+      /* sequence file is available since Linux 2.6.32 */
+      #include <linux/seq_file.h>
+      #define MPS_FEAT_SEQFILE
+      /* The legacy API of the procfs is no longer supported in Linux 3.10.x */
+      #undef MPS_FEAT_PROCFS_LEGACY_API
+   #endif
+#endif /* CONFIG_PROC_FS */
+#include <linux/cdev.h>
+#include <asm/setup.h>
+#if defined(SYSTEM_4KEC) 
+#include <grx500_bootcore_defs.h>
+#include <grx500_bootcore_cnfg.h>
+#include <grx500_bootcore_chadr.h>
+#include <grx500_bootcore_chipreg.h>
+#include <grx500_bootcore_emerald_env_regs.h>
+#include <grx500_bootcore_uart.h>
+#include <grx500_bootcore_time.h>
+#include <grx500_bootcore_interrupt.h>
+#endif
+#include "drv_mps.h"
+#include "drv_mps_dbg.h"
+#include "drv_mps_device.h"
+/* device structure */
+extern mps_comm_dev mps_dev;
+CREATE_TRACE_GROUP (MPS2);
+#ifndef __LIBRARY__
+/* ============================= */
+/* Local Macros & Definitions    */
+/* ============================= */
+#define MPS_DEV_NAME       "ltq_mps2"
+
+
+/* first minor number */
+#define LQ_MPS_FIRST_MINOR 1
+/* total file descriptor number */
+#define LQ_MPS_TOTAL_FD    2
+/* ============================= */
+/* Global variable definition    */
+/* ============================= */
+
+/* ============================= */
+/* Global function declaration   */
+extern irqreturn_t mps_ad0_irq (int32_t irq, void * pDev);
+extern uint32_t mps_reset_structures (mps_comm_dev * pDev);
+extern int32_t mps_bufman_close (void);
+int mpsexcpt;
+/* ============================= */
+/* Local function declaration    */
+/* ============================= */
+static uint32_t mps_poll (struct file *file_p, poll_table * wait);
+#ifndef VPE0
+extern int32_t mps_fastbuf_get_proc (struct seq_file *s);
+#endif
+
+
+/* ============================= */
+/* Local variable definition     */
+/* ============================= */
+
+/* ============================= */
+/* Local function definition     */
+/* ============================= */
+
+/* external function declaration */
+
+/* local function declaration */
+
+#if (defined(MODULE) && !defined(VMMC_WITH_MPS))
+MODULE_AUTHOR ("Lantiq Deutschland GmbH");
+MODULE_DESCRIPTION ("MPS/DSP driver for XRX500 family");
+#if defined(SYSTEM_GRX500)
+MODULE_SUPPORTED_DEVICE ("XRX500 family MIPSInteraptiv");
+#elif defined(SYSTE_VR9)
+MODULE_SUPPORTED_DEVICE ("XRX500 family MIPS34KC");
+#else /* 4KEC model*/
+MODULE_SUPPORTED_DEVICE ("XRX500 family MIPS4KEC");
+#endif /* */
+MODULE_LICENSE ("Dual BSD/GPL");
+#endif /* */
+static ushort mps_major_id = 0;
+module_param (mps_major_id, ushort, 0);
+MODULE_PARM_DESC (mps_major_id, "Major ID of device");
+char mps_dev_name[10];
+
+/* the driver callbacks */
+static struct file_operations mps_fops = {
+ owner:THIS_MODULE,
+ poll:mps_poll,
+ unlocked_ioctl:mps_ioctl,
+ open:mps_open,
+ release:mps_close
+};
+
+
+
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry *mps_proc_dir;
+#endif /* CONFIG_PROC_FS */
+static char mps_device_version[20];
+
+/**
+   This function registers char device in kernel.
+\param   pDev     pointer to mps_comm_dev structure
+\return  0        success
+\return  -ENOMEM
+\return  -EPERM
+*/
+int32_t lq_mps_os_register (mps_comm_dev *pDev)
+{
+   int32_t ret;
+
+   uint8_t minor;
+   dev_t       dev;
+
+   if (mps_major_id)
+   {
+      dev = MKDEV(mps_major_id, LQ_MPS_FIRST_MINOR);
+      ret = register_chrdev_region(dev, LQ_MPS_TOTAL_FD, mps_dev_name);
+   }
+   else
+   {
+      /* dynamic major */
+      ret = alloc_chrdev_region(&dev, LQ_MPS_FIRST_MINOR, LQ_MPS_TOTAL_FD, mps_dev_name);
+      mps_major_id = MAJOR(dev);
+   }
+   if (ret < 0)
+   {
+      TRACE (MPS2, DBG_LEVEL_HIGH,
+             ("MPS: can't get major %d\n", mps_major_id));
+      return ret;
+   }
+      TRACE (MPS2, DBG_LEVEL_HIGH,
+             ("MPS: major Id %d\n", mps_major_id));
+   {
+      struct cdev *p_cdev = cdev_alloc();
+
+      if (NULL == p_cdev)
+         return -ENOMEM;
+
+      cdev_init(p_cdev, &mps_fops);
+      p_cdev->owner = THIS_MODULE;
+			minor=LQ_MPS_FIRST_MINOR;
+      ret = cdev_add(p_cdev, MKDEV(mps_major_id, minor), 1);
+      if (ret != 0)
+      {
+         cdev_del (p_cdev);
+         return -EPERM;
+      }
+
+         pDev->mb.mps_cdev = p_cdev;
+   }
+   return ret;
+}
+
+/**
+   This function unregisters char device from kernel.
+\param   pDev     pointer to mps_comm_dev structure
+*/
+void lq_mps_os_unregister (mps_comm_dev *pDev)
+{
+
+   {
+         cdev_del (pDev->mb.mps_cdev);
+         pDev->mb.mps_cdev = NULL;
+   }
+   unregister_chrdev_region (MKDEV(mps_major_id, LQ_MPS_FIRST_MINOR), LQ_MPS_TOTAL_FD);
+}
+
+
+/**
+ * Open MPS device.
+ * Open the device from user mode (e.g. application) or kernel mode. An inode
+ * value of 1 indicates a kernel mode access. In such a case the inode value
+ * is used as minor ID.
+ *
+ * \param   inode   Pointer to device inode
+ * \param   file_p  Pointer to file descriptor
+ * \return  0       SUCCESS, device opened
+ * \return  EMFILE  Device already open
+ * \return  EINVAL  Invalid minor ID
+ * \ingroup API
+ */
+int32_t mps_open (struct inode * inode, struct file * file_p)
+{
+   mps_comm_dev *pDev = &mps_dev;
+   mps_mbx_dev *pMBDev;
+   int32_t from_kernel = 0;
+   int32_t num;
+
+   /* Check whether called from user or kernel mode */
+
+   /* a trick: VMMC driver passes the first parameter as a value So, if inode value is
+      [1...LQ_MPS_TOTAL_FD-1], then we make sure that we are calling from
+      kernel space. */
+   if (((int32_t) inode > 0) &&
+       ((int32_t) inode < LQ_MPS_TOTAL_FD))
+   {
+      from_kernel = 1;
+      num = (int32_t) inode;
+   }
+   else
+   {
+      num =  MINOR (inode->i_rdev);        /* the real device */
+   }
+	 TRACE( MPS2, DBG_LEVEL_LOW, ("device number is %d\n",num));
+   /* check the device number */
+   switch (num)
+   {
+      case 1:
+         pMBDev = &(pDev->mb);
+         break;
+      default:
+         TRACE (MPS2, DBG_LEVEL_HIGH,
+                ("MPS ERROR: max. device number exceed!\n"));
+         return -EINVAL;
+   }
+
+   if ((SUCCESS) ==
+       mps_common_open (pDev, pMBDev,from_kernel))
+   {
+      if (!from_kernel)
+      {
+
+         /* installation was successfull */
+         /* and use file_p->private_data to point to the device data */
+         file_p->private_data = pMBDev;
+      }
+      return 0;
+   }
+   else
+   {
+      /* installation failed */
+      TRACE (MPS2, DBG_LEVEL_HIGH,
+             ("MPS ERROR: Device %d is already open!\n", num));
+      return -EMFILE;
+   }
+}
+
+
+/**
+ * Close MPS device.
+ * Close the device from user mode (e.g. application) or kernel mode. An inode
+ * value of 1 indicates a kernel mode access. In such a case the inode value
+ * is used as minor ID.
+ *
+ * \param   inode   Pointer to device inode
+ * \param   file_p  Pointer to file descriptor
+ * \return  0       SUCCESS, device closed
+ * \return  ENODEV  Device invalid
+ * \return  EINVAL  Invalid minor ID
+ * \ingroup API
+ */
+int32_t mps_close (struct inode * inode, struct file * file_p)
+{
+   mps_mbx_dev *pMBDev;
+   int32_t from_kernel = 0;
+
+   if (((int32_t) inode > 0) &&
+       ((int32_t) inode <= LQ_MPS_TOTAL_FD))
+   {
+      from_kernel = 1;
+ 			switch ((int32_t)inode)
+   		{
+      	case 1:
+        	 pMBDev = &(mps_dev.mb);
+         break;
+      	default:
+        	 TRACE (MPS2, DBG_LEVEL_HIGH,
+                ("MPS ERROR: max. device number exceed!\n"));
+         return -EINVAL;
+   		}
+   }
+   else
+   {
+      pMBDev = file_p->private_data;
+   }
+
+   if (NULL != pMBDev)
+   {
+      /* device is still available */
+      if (mps_common_close (pMBDev, from_kernel) != SUCCESS)
+      {
+         TRACE (MPS2, DBG_LEVEL_HIGH,
+                ("MPS ERROR: Device is not open!\n"));
+         return -ENODEV;
+      }
+
+      return 0;
+   }
+   else
+   {
+      /* something went totally wrong */
+      TRACE (MPS2, DBG_LEVEL_HIGH, ("MPS2 ERROR: pMBDev pointer is NULL!\n"));
+      return -ENODEV;
+   }
+}
+
+
+/**
+ * Poll handler.
+ * The select function of the driver. A user space program may sleep until
+ * the driver wakes it up.
+ *
+ * \param   file_p  File structure of device
+ * \param   wait    Internal table of poll wait queues
+ * \return  mask    If new data is available the POLLPRI bit is set,
+ *                  triggering an exception indication. If the device pointer
+ *                  is null POLLERR is set.
+ * \ingroup API
+ */
+static uint32_t mps_poll (struct file *file_p, poll_table * wait)
+{
+   mps_mbx_dev *pMBDev = file_p->private_data;
+   uint32_t mask;
+
+   /* add to poll queue */
+	 poll_wait(file_p, &(pMBDev->mps_wakeuplist), wait);
+   mask = 0;
+		if(mpsexcpt){
+			mpsexcpt=0;
+			TRACE (MPS2, DBG_LEVEL_LOW, ("waking up sleeping process\n"));
+   		/* upstream queue */
+   		if (*pMBDev->upstrm_fifo->pwrite_off != *pMBDev->upstrm_fifo->pread_off)
+   		{
+      	mask = POLLIN | POLLRDNORM;
+   		}
+   		/* no downstream queue in case of event mailbox */
+   		if (pMBDev->dwstrm_fifo == NULL)
+      	return mask;
+
+   		/* downstream queue */
+   		if (mps_fifo_mem_available (pMBDev->dwstrm_fifo) != 0)
+   		{
+      	/* queue is not full */
+      	mask |= POLLOUT | POLLWRNORM;
+   		}
+	}
+   return mask;
+}
+
+
+/**
+ * MPS IOCTL handler.
+ * An inode value of 0..7 indicates a kernel mode access. In such a case the
+ * inode value is used as minor ID.
+ * The following IOCTLs are supported for the MPS device.
+ * - #FIO_MPS_MB_READ
+ * - #FIO_MPS_MB_WRITE
+ * - #FIO_MPS_GETVERSION
+ * - #FIO_MPS_RESET
+ * - #FIO_MPS_RESTART
+ *
+ * \param   inode        Inode of device
+ * \param   file_p       File structure of device
+ * \param   nCmd         IOCTL command
+ * \param   arg          Argument for some IOCTL commands
+ * \return  0            Setting the LED bits was successfull
+ * \return  -EINVAL      Invalid minor ID
+ * \return  -ENOIOCTLCMD Invalid command
+ * \ingroup API
+ */
+long mps_ioctl (struct file *file_p,
+                           uint32_t nCmd, ulong arg)
+{
+   int32_t retvalue = -EINVAL;
+   mps_message rw_struct;
+   mps_mbx_dev *pMBDev;
+   int32_t from_kernel = 0;
+
+   /* a trick: VMMC driver passes the first parameter as a value of
+      'mps_devices' enum type, which in fact is [0..8]; So, if inode value is
+      [1], then we make sure that we are calling from
+      kernel space. */
+   if (((int32_t) file_p > 0) &&
+       ((int32_t) file_p <= LQ_MPS_TOTAL_FD))
+   {
+      from_kernel = 1;
+			
+      /* Get corresponding mailbox device structure */
+      if ((pMBDev =&mps_dev.mb) == 0)
+			{
+         return (-EINVAL);
+      }
+      file_p = NULL;
+   }
+   else
+   {
+      pMBDev = file_p->private_data;
+   }
+
+   switch (nCmd)
+   {
+      case FIO_MPS_MB_READ:
+         /* Read the data from mailbox stored in local FIFO */
+         if (from_kernel)
+         {
+            retvalue = mps_mbx_read (pMBDev, (mps_message *) arg, 0);
+         }
+         else
+         {
+            uint32_t UserBuf[16]={0};
+
+            /* Initialize destination and copy mps_message from usermode */
+            memset (&rw_struct, 0, sizeof (mps_message));
+            if (0<
+                copy_from_user (&rw_struct, (void *) arg,
+                                   sizeof (mps_message)))
+            {
+               TRACE (MPS2, DBG_LEVEL_HIGH,
+                      (KERN_ERR "[%s %s %d]: copy_from_user error\r\n",
+                       __FILE__, __func__, __LINE__));
+            }
+						memcpy(UserBuf,rw_struct.data,16);
+																																	/* Remember
+                                                                   usermode
+                                                                   buffer */
+
+            /* read data from upstream mailbox FIFO */
+            retvalue = mps_mbx_read (pMBDev, &rw_struct, 0);
+            if (retvalue != SUCCESS)
+               return -ENOMSG;
+
+            /* Copy data to usermode buffer... */
+						if(CHECK_PTR(rw_struct.header.Hd.param_attr,0)){
+            	if (0<
+              	  copy_to_user ((uint8_t *)UserBuf[0], (uint8_t *)rw_struct.data[0],
+                                 rw_struct.data[1]))
+            	{
+               	TRACE (MPS2, DBG_LEVEL_HIGH,
+                	      (KERN_ERR "[%s %s %d]: copy_to_user error\r\n", __FILE__,
+                  	     __func__, __LINE__));
+            	}
+            	mps_bufman_free ((void *)rw_struct.data[0]);
+						}
+
+            /* ... and finally restore the buffer pointer and copy mps_message
+               back! */
+            memcpy(rw_struct.data,UserBuf,16);
+            if (0<
+                copy_to_user ((void *) arg, &rw_struct,
+                                 sizeof (mps_message)))
+            {
+               TRACE (MPS2, DBG_LEVEL_HIGH,
+                      (KERN_ERR "[%s %s %d]: copy_to_user error\r\n", __FILE__,
+                       __func__, __LINE__));
+            }
+         }
+         break;
+      case FIO_MPS_MB_WRITE:
+         /* Write data to send to the mailbox into the local FIFO */
+         if (from_kernel)
+         {
+               return (mps_mbx_write_data (pMBDev, (mps_message *) arg));
+         }
+         else
+         {
+            uint32_t UserBuf[16]={0};
+            if (0<
+                copy_from_user (&rw_struct, (void *) arg,
+                                   sizeof (mps_message)))
+            {
+               TRACE (MPS2, DBG_LEVEL_HIGH,
+                      (KERN_ERR "[%s %s %d]: copy_from_user error\r\n",
+                       __FILE__, __func__, __LINE__));
+            }
+
+            /* Remember usermode buffer */
+						memcpy(UserBuf,rw_struct.data,16);
+
+            /* Allocate kernelmode buffer for writing data */
+				if(CHECK_PTR(rw_struct.header.Hd.param_attr,0)){	
+#ifndef VPE0
+            rw_struct.data[0] =(uint32_t)
+               mps_bufman_malloc (rw_struct.data[1], 0x02);
+#else
+            rw_struct.data[0] =(uint32_t)
+               mps_bufman_malloc (rw_struct.data[1], 0xff);
+#endif
+					
+            if (rw_struct.data[0] == 0)
+            {
+               return (-ENOMEM);
+            }
+
+            /* copy data to kernelmode buffer and write to mailbox FIFO */
+            if (0<
+                copy_from_user ((uint8_t *)rw_struct.data[0], (uint8_t *)UserBuf[0],
+                                   rw_struct.data[1]))
+            {
+               TRACE (MPS2, DBG_LEVEL_HIGH,
+                      (KERN_ERR "[%s %s %d]: copy_from_user error\r\n",
+                       __FILE__, __func__, __LINE__));
+            }
+				}
+               if ((retvalue =
+                    mps_mbx_write_data (pMBDev, &rw_struct)) != SUCCESS)
+                  mps_bufman_free ((void *)rw_struct.data[0]);
+            /* ... and finally restore the buffer pointer and copy mps_message
+               back! */
+            memcpy(rw_struct.data,UserBuf,16);
+            if (0<
+                copy_to_user ((void *) arg, &rw_struct,
+                                 sizeof (mps_message)))
+            {
+               TRACE (MPS2, DBG_LEVEL_HIGH,
+                      (KERN_ERR "[%s %s %d]: copy_to_user error\r\n", __FILE__,
+                       __func__, __LINE__));
+            }
+         }
+         break;
+      case FIO_MPS_GETVERSION:
+         if (from_kernel)
+         {
+            memcpy ((char *) arg, (char *) mps_device_version,
+                    strlen (mps_device_version));
+         }
+         else
+         {
+            if (0<
+                copy_to_user ((void *) arg, mps_device_version,
+                                 strlen (mps_device_version)))
+            {
+               TRACE (MPS2, DBG_LEVEL_HIGH,
+                      (KERN_ERR "[%s %s %d]: copy_to_user error\r\n", __FILE__,
+                       __func__, __LINE__));
+            }
+         }
+         retvalue = SUCCESS;
+         break;
+      case FIO_MPS_RESET:
+         
+   			/* reset driver */
+   			mps_bufman_close ();
+         break;
+      case FIO_MPS_RESTART:
+            retvalue = mps_bufman_init ();
+         break;
+      default:
+         {
+            TRACE (MPS2, DBG_LEVEL_HIGH,
+                   ("MPS_Ioctl: Invalid IOCTL handle %d passed.\n", nCmd));
+            retvalue = -ENOIOCTLCMD;
+            break;
+         }
+   }
+   return retvalue;
+}
+
+
+/**
+ * Read from mailbox upstream FIFO.
+ * This function reads from the mailbox upstream FIFO selected by type.
+ *
+ * \param   type  DSP device entity ( 1 - command, 2 - voice0, 3 - voice1,
+ *                4 - voice2, 5 - voice3 )
+ * \param   rw    Pointer to message structure for received data
+ * \return  0     SUCCESS, successful read operation
+ * \return  ENXIO Wrong DSP device entity (only 1-5 supported)
+ * \return  -1    ERROR, in case of read error.
+ * \ingroup API
+ */
+int32_t mps_read_mailbox (mps_message * rw)
+{
+   int32_t ret;
+   ret = mps_mbx_read (&mps_dev.mb, rw, 0);
+   return (ret);
+}
+
+
+/**
+ * Write to downstream mailbox buffer.
+ * This function writes data to either the command or to the voice FIFO
+ *
+ * \param   type  1-data
+ * \param   rw    Pointer to message structure
+ * \return  0       SUCCESS, successful write operation
+ * \return  -ENXIO  Wrong DSP device entity (only 1-5 supported)
+ * \return  -EAGAIN ERROR, in case of FIFO overflow.
+ * \ingroup API
+ */
+int32_t mps_write_mailbox (mps_message * rw)
+{
+   int32_t ret;
+   ret = mps_mbx_write_data (&mps_dev.mb, rw);
+   return (ret);
+}
+
+
+#ifdef CONFIG_PROC_FS
+
+#ifdef MPS_FEAT_SEQFILE
+/**
+ * Create MPS version proc file output.
+ * This function creates the output for the MPS version proc file
+ *
+ * \param   s        Pointer to seq_file struct.
+ * \return  0 on success
+ * \ingroup Internal
+ */
+static int mps_get_version_proc (struct seq_file *s)
+{
+   seq_printf(s, "%s%s\n", MPS_INFO_STR, mps_device_version);
+   seq_printf(s, "Compiled on %s, %s for Linux kernel %s\n",
+               __DATE__, __TIME__,"3.10.12");
+
+   return 0;
+}
+#endif /* MPS_FEAT_SEQFILE */
+
+
+#ifdef MPS_FEAT_SEQFILE
+/**
+ * Create MPS status proc file output.
+ * This function creates the output for the MPS status proc file
+ *
+ * \param   s        Pointer to seq_file struct.
+ * \return  0 on success
+ * \ingroup Internal
+ */
+int32_t mps_get_status_proc (struct seq_file *s)
+{
+   seq_printf (s, "Status registers:\n");
+   seq_printf (s, "   AD0ENR = 0x%08x\n", *MPS_AD0ENR);
+   seq_printf (s, "   RAD0SR = 0x%08x\n", *MPS_RAD0SR);
+   seq_printf (s, "   AD1ENR = 0x%08x\n", *MPS_AD1ENR);
+   seq_printf (s, "   RAD1SR = 0x%08x\n", *MPS_RAD1SR);
+
+   seq_printf (s, "\n * VOICE *\t\tUP\t\tDO\n");
+   seq_printf (s, "   Size: \t  %8d\t  %8d\n",
+               mps_dev.upstrm_fifo.size,
+               mps_dev.dwstrm_fifo.size);
+   seq_printf (s, "   Fill: \t  %8d\t  %8d\n",
+               mps_dev.upstrm_fifo.size - 1 -
+               mps_fifo_mem_available (&mps_dev.upstrm_fifo),
+               mps_dev.dwstrm_fifo.size - 1 -
+               mps_fifo_mem_available (&mps_dev.dwstrm_fifo));
+   seq_printf (s, "   Free: \t  %8d\t  %8d\n",
+               mps_fifo_mem_available (&mps_dev.upstrm_fifo),
+               mps_fifo_mem_available (&mps_dev.dwstrm_fifo));
+   seq_printf (s, "   Pkts: \t  %8d\t  %8d\n",
+               mps_dev.upstrm_fifo.pkts,
+               mps_dev.dwstrm_fifo.pkts);
+   seq_printf (s, "   Bytes: \t  %8d\t  %8d\n",
+               mps_dev.upstrm_fifo.bytes,
+               mps_dev.dwstrm_fifo.bytes);
+   seq_printf (s, "   Discd: \t  %8d\n",
+               mps_dev.upstrm_fifo.discards);
+   seq_printf (s, "   minLv: \t  %8d\t  %8d\n",
+               mps_dev.upstrm_fifo.min_space,
+               mps_dev.dwstrm_fifo.min_space);
+   {
+      seq_printf (s, "\n * CH *\t\tUP\t\tDO\t%s\n", 
+                  (mps_dev.mb.Installed ==
+                   FALSE) ? "(idle)" : "(active)");
+      seq_printf (s, "   Size: \t  %8d\n",
+                  mps_dev.mb.upstrm_fifo->size);
+      seq_printf (s, "   Fill: \t  %8d\n",
+                  mps_dev.mb.upstrm_fifo->size - 1 -
+                  mps_fifo_mem_available (mps_dev.mb.
+                                              upstrm_fifo));
+      seq_printf (s, "   Free: \t  %8d\n",
+                  mps_fifo_mem_available (mps_dev.mb.
+                                              upstrm_fifo));
+      seq_printf (s, "   Pkts: \t  %8d\n",
+                  mps_dev.mb.upstrm_fifo->pkts);
+      seq_printf (s, "   Bytes: \t  %8d\n",
+                  mps_dev.mb.upstrm_fifo->bytes);
+      seq_printf (s, "   Discd: \t  %8d\n",
+                  mps_dev.mb.upstrm_fifo->discards);
+      seq_printf (s, "   minLv: \t  %8d\n",
+                  mps_dev.mb.upstrm_fifo->min_space);
+   }
+
+   return 0;
+}
+#endif /* MPS_FEAT_SEQFILE */
+
+
+#ifdef MPS_FEAT_SEQFILE
+/**
+ * Create MPS mailbox proc file output.
+ * This function creates the output for the MPS mailbox proc file
+ *
+ * \param   s        Pointer to seq_file struct.
+ * \return  0 on success
+ * \ingroup Internal
+ */
+static int32_t mps_get_mailbox_proc (struct seq_file *s)
+{
+   uint32_t i;
+
+   seq_printf (s, "\n * VOICE * UP");
+   seq_printf (s, " (wr:0x%08x, rd: 0x%08x)\n",
+               (uint32_t) mps_dev.upstrm_fifo.pend +
+               (uint32_t) * mps_dev.upstrm_fifo.pwrite_off,
+               (uint32_t) mps_dev.upstrm_fifo.pend +
+               (uint32_t) * mps_dev.upstrm_fifo.pread_off);
+   for (i = 0; i < mps_dev.upstrm_fifo.size; i += 16)
+   {
+      seq_printf (s, "   0x%08x: %08x %08x %08x %08x\n",
+                  (uint32_t) (mps_dev.upstrm_fifo.pend + (i / 4)),
+                  *(mps_dev.upstrm_fifo.pend + (i / 4)),
+                  *(mps_dev.upstrm_fifo.pend + 1 + (i / 4)),
+                  *(mps_dev.upstrm_fifo.pend + 2 + (i / 4)),
+                  *(mps_dev.upstrm_fifo.pend + 3 + (i / 4)));
+   }
+
+   seq_printf (s, "\n * VOICE * DO");
+   seq_printf (s, " (wr: 0x%08x, rd: 0x%08x)\n",
+               (uint32_t) mps_dev.dwstrm_fifo.pend +
+               (uint32_t) * mps_dev.dwstrm_fifo.pwrite_off,
+               (uint32_t) mps_dev.dwstrm_fifo.pend +
+               (uint32_t) * mps_dev.dwstrm_fifo.pread_off);
+   for (i = 0; i < mps_dev.dwstrm_fifo.size; i += 16)
+   {
+      seq_printf (s, "   0x%08x: %08x %08x %08x %08x\n",
+                  (uint32_t) (mps_dev.dwstrm_fifo.pend + (i / 4)),
+                  *(mps_dev.dwstrm_fifo.pend + (i / 4)),
+                  *(mps_dev.dwstrm_fifo.pend + 1 + (i / 4)),
+                  *(mps_dev.dwstrm_fifo.pend + 2 + (i / 4)),
+                  *(mps_dev.dwstrm_fifo.pend + 3 + (i / 4)));
+   }
+
+   return 0;
+}
+#endif /* MPS_FEAT_SEQFILE */
+
+
+#ifdef MPS_FEAT_SEQFILE
+/**
+ * Create MPS sw fifo proc file output.
+ * This function creates the output for the sw fifo proc file
+ *
+ * \param   s        Pointer to seq_file struct.
+ * \return  0 on success
+ * \ingroup Internal
+ */
+static int32_t mps_get_swfifo_proc (struct seq_file *s)
+{
+   int32_t i;
+   {
+      seq_printf (s, "\n"
+                     " * CH * UP");
+      seq_printf (s, " (wr:0x%08x, rd: 0x%08x)\n",
+                  (uint32_t) mps_dev.sw_upstrm_fifo.pend +
+                  (uint32_t) * mps_dev.sw_upstrm_fifo.pwrite_off,
+                  (uint32_t) mps_dev.sw_upstrm_fifo.pend +
+                  (uint32_t) * mps_dev.sw_upstrm_fifo.pread_off);
+
+      for (i = 0; i < mps_dev.sw_upstrm_fifo.size; i += 16)
+      {
+         seq_printf (s, "   0x%08x: %08x %08x %08x %08x\n",
+                     (uint32_t) (mps_dev.sw_upstrm_fifo.pend +
+                                     (i / 4)),
+                     *(mps_dev.sw_upstrm_fifo.pend + (i / 4)),
+                     *(mps_dev.sw_upstrm_fifo.pend + 1 + (i / 4)),
+                     *(mps_dev.sw_upstrm_fifo.pend + 2 + (i / 4)),
+                     *(mps_dev.sw_upstrm_fifo.pend + 3 + (i / 4)));
+      }
+   }
+
+   return 0;
+}
+#endif /* MPS_FEAT_SEQFILE */
+
+
+
+#ifndef MPS_FEAT_PROCFS_LEGACY_API
+typedef void (*mps_dump) (struct seq_file *s);
+
+static int mps_proc_show ( struct seq_file *s, void *p )
+{
+   mps_dump dump = s->private;
+
+   if (dump != NULL)
+      dump(s);
+
+   return 0;
+}
+
+static int mps_proc_open ( struct inode *inode, struct file *file )
+{
+   return single_open (file, mps_proc_show, PDE_DATA(inode));
+}
+
+struct proc_entry
+{
+   const char *name;
+   void *read_function;
+   void *write_function;
+   struct file_operations ops;
+};
+
+static struct proc_entry proc_entries[] =
+{
+   { "version", mps_get_version_proc},
+   { "status", mps_get_status_proc},
+   { "mailbox", mps_get_mailbox_proc},
+   { "swfifo", mps_get_swfifo_proc},
+#ifndef VPE0
+	 { "fastbuf",mps_fastbuf_get_proc},
+#endif
+};
+
+static void mps_proc_entrycreate ( struct proc_dir_entry *parent_node,
+                 struct proc_entry *proc_entry)
+{
+   memset(&proc_entry->ops, 0, sizeof(struct file_operations));
+   proc_entry->ops.owner   = THIS_MODULE;
+   proc_entry->ops.open    = mps_proc_open;
+   proc_entry->ops.read    = seq_read;
+   proc_entry->ops.write   = proc_entry->write_function;
+   proc_entry->ops.llseek  = seq_lseek;
+   proc_entry->ops.release = single_release;
+
+   proc_create_data ( proc_entry->name, 0, parent_node,
+            &proc_entry->ops, proc_entry->read_function);
+}
+#endif /* MPS_FEAT_PROCFS_LEGACY_API */
+
+#endif /* CONFIG_PROC_FS */
+
+#ifdef FEAT_LINUX_PLATFORM_DRIVER
+/**
+   Linux platform driver probe function.
+
+   Read parameters from device tree and configure driver.
+
+   Example entry of needed device tree nodes.
+   \verbatim
+   mps@107000 {
+      compatible = "lantiq,mps-xrx100";
+      reg = <0x107000 0x400>;
+      interrupt-parent = <&icu0>;
+      interrupts = <154 155>;
+      lantiq,mbx = <&mpsmbx>;
+   };
+
+   mpsmbx: mpsmbx@20000 {
+      reg = <0x200000 0x200>;
+   };
+   \endverbatim
+
+   \param  pdev         Pointer to struct platform_device.
+
+   \return
+   0 Successful
+   !0 Failed to find the config or the device.
+*/
+int ltq_mps_probe(struct platform_device *pdev)
+{
+   struct device_node   *pdn;
+   struct resource      *res = NULL;
+	 int uiFlag;
+   /* Clear parameters to detect if all can be set below. */
+   mps_ir4 = 0;
+   mps_reg_base = mps_ram_base = 0;
+#ifdef VPE0
+   /* Interrupt number connected to the AD0 register. */
+   mps_ir4 = platform_get_irq(pdev,0);
+	 uiFlag=(mps_ir4==0)?0:1;
+#else
+   mps_ir0 = platform_get_irq(pdev,0);
+   mps_ir1 = platform_get_irq(pdev,1);
+	 uiFlag=(mps_ir0==0||mps_ir1==0)?0:1;
+#endif
+   /* Baseaddress of the MPS register block. */
+   res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+   if (res)
+   {
+      static void __iomem *mps_reg_base;
+
+      mps_reg_base = devm_ioremap_resource(&pdev->dev, res);
+      if (IS_ERR(mps_reg_base))
+         return PTR_ERR(mps_reg_base);
+
+      mps_reg_base = (uint32_t)mps_reg_base;
+   }
+
+   /* Baseaddress of the MPS SRAM region. This is used for mailboxes. */
+   /* Dereference the phandle pointing to the node with the actual address. */
+   pdn = of_parse_phandle(pdev->dev.of_node, "lantiq,mbx", 0);
+   if (pdn)
+   {
+      struct resource mbx_res;
+
+      if (of_address_to_resource(pdn, 0, &mbx_res) == 0)
+      {
+         static void __iomem *mps_ram_base;
+
+         mps_ram_base = devm_ioremap_resource(&pdev->dev, &mbx_res);
+         if (IS_ERR(mps_ram_base))
+         {
+            of_node_put(pdn);
+            return PTR_ERR(mps_ram_base);
+         }
+
+         mps_ram_base = (uint32_t)mps_ram_base;
+      }
+      of_node_put(pdn);
+   }
+   /* Verify that all parameters were set. */
+   if (!uiFlag || !mps_reg_base || !mps_ram_base)
+   {
+#ifdef VPE0
+      if (!mps_ir4)
+      {
+         TRACE ( MPS2,DBG_LEVEL_HIGH,(KERN_ERR "Failed to find MPS2 AD0 irq in device tree.\n"));
+      }
+#else
+      if (!mps_ir0 || !mps_ir1)
+      {
+         TRACE ( MPS2,DBG_LEVEL_HIGH,(KERN_ERR "Failed to find MPS2 AD0 irq in device tree.\n"));
+      }
+#endif
+      if (!mps_reg_base)
+      {
+         TRACE ( MPS2,DBG_LEVEL_HIGH,(KERN_ERR "Failed to find MPS2 reg base in device tree.\n"));
+      }
+      if (!mps_ram_base)
+      {
+         TRACE ( MPS2,DBG_LEVEL_HIGH,(KERN_ERR "Failed to find MPS2 mbx base in device tree.\n"));
+      }
+
+      return -ENXIO;
+   }
+
+   return 0;
+}
+
+static const struct of_device_id ltq_mps_match[] = {
+  { .compatible = "lantiq,mps-xrx100" },
+  {},
+};
+MODULE_DEVICE_TABLE(of, ltq_asc_match);
+
+static struct platform_driver ltqmps_driver = {
+  .driver   = {
+    .name = "lantiq,mps-xrx500",
+    .owner  = THIS_MODULE,
+    .of_match_table = ltq_mps_match,
+  },
+};
+
+#endif /* FEAT_LINUX_PLATFORM_DRIVER */
+#if defined(VPE0) && defined(SYSTEM_4KEC)
+static struct irqaction mps_irqaction = {
+      .handler        = mps_ad0_irq,
+      .flags          = IRQF_DISABLED, /* for disable nested interrupts */
+      /* Lior.H - when we need to use-> IRQF_NOBALANCING ? */
+      .name           = "4kec_mps4",
+			.dev_id					= &mps_dev,
+};
+#endif
+/**
+   This function initializes the module.
+\param
+   None.
+\return  SUCCESS, module initialized
+\return  EPERM    Reset of CPU1 failed
+\return  ENOMEM   No memory left for structures
+*/
+static int32_t __init
+mps_init_module (void)
+{
+   int32_t result;
+   int32_t i;
+   unsigned int virt;
+
+   sprintf (mps_device_version, "%d.%d.%d.%d", MAJORSTEP, MINORSTEP,
+            VERSIONSTEP, VERS_TYPE);
+
+   TRACE (MPS2, DBG_LEVEL_HIGH,
+          ("%s%s, (c) 2006-2013 Lantiq Deutschland GmbH\n", MPS_INFO_STR,
+           mps_device_version));
+
+   sprintf (mps_dev_name, MPS_DEV_NAME);
+
+#ifdef FEAT_LINUX_PLATFORM_DRIVER
+	 result = platform_driver_probe(&ltqmps_driver, ltq_mps_probe);
+	 if(result)
+			return result;
+#endif
+   mps_bufman_init ();
+
+   /* init the device driver structure */
+   if (0 != mps_init_structures (&mps_dev))
+      return -ENOMEM;
+   /* register char module in kernel */
+   result = lq_mps_os_register (&mps_dev);
+   if (result)
+      return result;
+#if defined(SYSTEM_VR9)
+#ifdef VPE0
+   /* Set handler for interrupt generated by voice-FW AD0 status register. */
+   virt = irq_create_mapping(NULL, mps_ir4);
+   if (!virt)
+      return -1;
+   result = request_irq (virt,
+                         mps_ad0_irq, IRQF_DISABLED
+                         , "mps_mbx_0", &mps_dev);
+ if (result)
+      return result;
+#else
+   /* Set handler for interrupt generated by voice-FW AD0 status register. */
+   virt = irq_create_mapping(NULL, mps_ir0);
+   if (!virt)
+      return -1;
+   result = request_irq (virt,
+                         mps_ad0_irq, IRQF_DISABLED
+                         , "mps_mbx_0", &mps_dev);
+ if (result)
+      return result;
+#endif
+
+#else	
+#ifdef VPE0
+     virt=mps_ir4;
+	 grx500_bootcore_register_static_irq(virt,GRX500_BOOTCORE_MPS2_OUT_INDEX,&mps_irqaction,grx500_bootcore_mps_irq);
+#else
+	 virt=mps_ir0;
+   result = request_irq (virt,
+                         mps_ad0_irq, IRQF_DISABLED
+                         , "mps2_mbx_0", &mps_dev);
+ if (result)
+      return result;
+#endif
+#endif
+  mps_enable_mailbox_int ();
+
+#ifdef CONFIG_PROC_FS
+   /* install the proc entry */
+   mps_proc_dir = proc_mkdir ("driver/" MPS_DEV_NAME, NULL);
+   if (mps_proc_dir != NULL)
+   {
+      for(i=0; i<sizeof(proc_entries)/sizeof(proc_entries[0]);i++) {
+         mps_proc_entrycreate (mps_proc_dir, &proc_entries[i]);
+      }
+   }
+   else
+   {
+      TRACE (MPS2, DBG_LEVEL_HIGH, ("MPS2: cannot create proc entry\n"));
+   }
+#endif /* */
+  return SUCCESS;
+}
+
+
+/**
+   This function cleans up the module.
+\param
+   None.
+\return
+   None.
+*/
+static void __exit
+mps_cleanup_module (void)
+{
+	mps_disable_mailbox_int ();
+   /* disable all MPS interrupts */
+   mps_disable_all_int ();
+   /* unregister char module from kernel */
+   lq_mps_os_unregister (&mps_dev);
+
+#ifdef VPE0
+   /* release all interrupts at the system */
+#ifdef SYSTEM_VR9
+   free_irq (mps_ir4, &mps_dev);
+#elif defined(SYSTEM_4KEC)
+	 grx500_bootcore_unregister_irq(mps_ir4,11,&mps_dev);
+#endif
+#else
+   /* release all interrupts at the system */
+   free_irq (mps_ir0, &mps_dev);
+#endif
+#ifdef CONFIG_PROC_FS
+   remove_proc_entry ("mailbox", mps_proc_dir);
+   remove_proc_entry ("swfifo", mps_proc_dir);
+   remove_proc_entry ("version", mps_proc_dir);
+   remove_proc_entry ("status", mps_proc_dir);
+#ifndef VPE0
+   remove_proc_entry ("fastbuf", mps_proc_dir);
+#endif
+   remove_proc_entry ("driver/" MPS_DEV_NAME, NULL);
+#endif /* CONFIG_PROC_FS */
+
+   TRACE (MPS2, DBG_LEVEL_HIGH, (KERN_INFO "Lantiq MPS2 driver: cleanup done\n"));
+}
+
+module_init (mps_init_module);
+module_exit (mps_cleanup_module);
+
+EXPORT_SYMBOL (mps_write_mailbox);
+EXPORT_SYMBOL (mps_read_mailbox);
+EXPORT_SYMBOL (mps_open);
+EXPORT_SYMBOL (mps_close);
+EXPORT_SYMBOL (mps_register_callback);
+EXPORT_SYMBOL (mps_unregister_callback);
+#else/*ifndef __LIBRARY__*/
+int 
+mps_init (void)
+{
+   /* init the device driver structure */
+   if (0 != mps_init_structures (&mps_dev))
+      return -ENOMEM;
+	return 0;
+}
+/**
+ * Read from mailbox upstream FIFO.
+ * This function reads from the mailbox upstream FIFO selected by type.
+ *
+ * \param   type  DSP device entity ( 1 - command, 2 - voice0, 3 - voice1,
+ *                4 - voice2, 5 - voice3 )
+ * \param   rw    Pointer to message structure for received data
+ * \return  0     SUCCESS, successful read operation
+ * \return  ENXIO Wrong DSP device entity (only 1-5 supported)
+ * \return  -1    ERROR, in case of read error.
+ * \ingroup API
+ */
+int32_t mps_read_mailbox (mps_message * rw)
+{
+   int32_t ret;
+   ret = mps_mbx_read (&mps_dev.mb, rw, 0);
+   return (ret);
+}
+
+
+/**
+ * Write to downstream mailbox buffer.
+ * This function writes data to either the command or to the voice FIFO
+ *
+ * \param   type  1-data
+ * \param   rw    Pointer to message structure
+ * \return  0       SUCCESS, successful write operation
+ * \return  -ENXIO  Wrong DSP device entity (only 1-5 supported)
+ * \return  -EAGAIN ERROR, in case of FIFO overflow.
+ * \ingroup API
+ */
+int32_t mps_write_mailbox (mps_message * rw)
+{
+   int32_t ret;
+   ret = mps_mbx_write_data (&mps_dev.mb, rw);
+   return (ret);
+}
+
+EXPORT_SYMBOL (mps_write_mailbox);
+EXPORT_SYMBOL (mps_read_mailbox);
+EXPORT_SYMBOL(mps_init);
+#endif
diff --git a/drivers/char/ltq_mps2/drv_mps_version.h b/drivers/char/ltq_mps2/drv_mps_version.h
new file mode 100755
--- /dev/null
+++ b/drivers/char/ltq_mps2/drv_mps_version.h
@@ -0,0 +1,33 @@
+#ifndef _DRV_MPS_VERSION_H
+#define _DRV_MPS_VERSION_H
+
+/******************************************************************************
+
+                              Copyright (c) 2012
+                            Lantiq Deutschland GmbH
+                             http://www.lantiq.com
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+*******************************************************************************/
+
+#define MAJORSTEP    1
+#define MINORSTEP    0
+#define VERSIONSTEP  0
+#define VERS_TYPE    0
+
+#if defined(SYSTEM_GRX500) 
+   #define MPS_PLATFORM_NAME "MIPSInterAptiv"
+#elif defined(SYSTEM_4KEC)
+   #define MPS_PLATFORM_NAME "MIPS4KEC"
+#elif defined(SYSTEM_VR9)
+   #define MPS_PLATFORM_NAME "MIPS34KC"
+#else
+   #error unknown system
+#endif /*SYSTEM_... */
+
+#define MPS_INFO_STR \
+   "Lantiq " MPS_PLATFORM_NAME " MPS driver, version "
+
+#endif /* _DRV_MPS_VERSION_H */
