# HG changeset patch
# Parent b305db5d9d7a8d2e4237900881c4661aad492506

diff --git a/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_chadr.h b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_chadr.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_chadr.h
@@ -0,0 +1,38 @@
+#ifndef __MT_CHADR_H__
+#define __MT_CHADR_H__
+
+#ifdef  MT_GLOBAL
+#define MT_EXTERN
+#define MT_I(x) x
+#else
+#define MT_EXTERN extern
+#define MT_I(x)
+#endif
+
+/* unit base addresses */
+#define MT_LOCAL_MIPS_BASE_ADDRESS           0xb4900000 //0xa7000000 //HUANX
+#define GRX500_BOOTCORE_SYS_SHARED_REGS_OFFSET       0x001c0000
+#define GRX500_BOOTCORE_SYS_RESET_REG_OFFSET         0x00000008
+#define GRX500_BOOTCORE_SPI_MODE_ADDR                (MT_LOCAL_MIPS_BASE_ADDRESS+0x130)
+#define GRX500_BOOTCORE_SPI_MODE_SW_BIT              (0x400) //When this bit is set, FLASH is accessed in SW mode
+
+#define GRX500_BOOTCORE_RESET_OFFSET                 8
+#define GRX500_BOOTCORE_RESET_ADDR                   (MT_LOCAL_MIPS_BASE_ADDRESS+GRX500_BOOTCORE_SYS_SHARED_REGS_OFFSET+GRX500_BOOTCORE_RESET_OFFSET)
+#define GRX500_BOOTCORE_REBOOT_DATA                  0
+#define GRX500_BOOTCORE_REBOOT_BIT_MASK_NOT          0xfffeffff
+
+#define GRX500_BOOTCORE_SHARED_GMAC_BASE_ADDR        (MT_LOCAL_MIPS_BASE_ADDRESS+GRX500_BOOTCORE_SYS_SHARED_REGS_OFFSET)
+#define GRX500_BOOTCORE_GMAC_MODE_REG_OFFSET         0x68
+#define GRX500_BOOTCORE_GMAC_MODE_REG_ADDR           (MT_LOCAL_MIPS_BASE_ADDRESS+GRX500_BOOTCORE_SYS_SHARED_REGS_OFFSET+GRX500_BOOTCORE_GMAC_MODE_REG_OFFSET)
+#define GRX500_BOOTCORE_GMAC_MODE_2_REG_OFFSET       0x80
+#define GRX500_BOOTCORE_GMAC_MODE_2_REG_ADDR         (MT_LOCAL_MIPS_BASE_ADDRESS+GRX500_BOOTCORE_SYS_SHARED_REGS_OFFSET+GRX500_BOOTCORE_GMAC_MODE_2_REG_OFFSET)
+#define GRX500_BOOTCORE_DLY_PGM_REG_OFFSET           0x64
+#define GRX500_BOOTCORE_DLY_PGM_REG_ADDR             (MT_LOCAL_MIPS_BASE_ADDRESS+GRX500_BOOTCORE_SYS_SHARED_REGS_OFFSET+GRX500_BOOTCORE_DLY_PGM_REG_OFFSET)
+#define GRX500_BOOTCORE_HCYCLE_CALIB_IND_REG_OFFSET  0x90
+#define GRX500_BOOTCORE_HCYCLE_CALIB_IND_REG_ADDR    (MT_LOCAL_MIPS_BASE_ADDRESS+GRX500_BOOTCORE_SYS_SHARED_REGS_OFFSET+GRX500_BOOTCORE_HCYCLE_CALIB_IND_REG_OFFSET)
+
+
+#undef MT_EXTERN
+#undef MT_I
+
+#endif /* __MT_CHADR_H__ */ 
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_chipreg.h b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_chipreg.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_chipreg.h
@@ -0,0 +1,9 @@
+#ifndef __MT_CHIPREG_H__
+#define __MT_CHIPREG_H__
+
+extern MT_UINT32 MT_RdReg(MT_UINT32 unit, MT_UINT32 reg);
+extern void MT_WrReg(MT_UINT32 unit, MT_UINT32 reg, MT_UINT32 data);
+extern void MT_WrRegMask(MT_UINT32 unit, MT_UINT32 reg, MT_UINT32 mask,MT_UINT32 data);
+
+
+#endif /* __MT_CHIPREG_H__ */
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_cnfg.h b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_cnfg.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_cnfg.h
@@ -0,0 +1,38 @@
+#ifndef __MT_CNFG_H__
+#define __MT_CNFG_H__
+
+#ifdef MT_GLOBAL
+#define MT_EXTERN
+#define MT_I(x) x
+#else
+#define MT_EXTERN extern
+#define MT_I(x)
+#endif
+
+#define MIPS_INITIAL_CLOCK_MHz 40
+
+#define HW_CREG_U32(I)		*((volatile MT_UINT32*)(I))
+#define HW_CREG_U32_NEW(I)	*((volatile MT_UINT32*)(I))
+
+#define HW_CREG_U16(I)   	*((volatile MT_UINT16*)(I))
+
+#define HW_CREG(I)		*((volatile MT_UINT32*)(I))
+#define HW_C_U16(I)   	        *((volatile MT_UINT16*)(I))
+
+#define HW_CREG_UNIT(UNIT, REG)  (((MT_UINT32)UNIT) | \
+				  (((MT_UINT32)REG) << REG_MIPS_ADD_OFFSET) | \
+				   ((MT_UINT32)0x2))
+
+#define NONE_TRUNK_REG(UNIT, REG)	(HW_CREG_U32((MT_UINT32)UNIT | (MT_UINT32)REG ))
+
+
+
+#define MT_UBYTE		unsigned char
+#define MT_BYTE			char
+#define MT_UINT16		unsigned short
+#define MT_INT16		short
+#define MT_UINT32		unsigned long
+#define MT_INT32		long
+
+#endif /* __MT_CNFG_H__ */
+
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_defs.h b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_defs.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_defs.h
@@ -0,0 +1,13 @@
+#ifndef __MT_DEFS_H__
+#define __MT_DEFS_H__
+
+typedef unsigned char	   uint8;
+typedef unsigned short     uint16;
+typedef unsigned long      uint32;
+
+typedef char	           int8;
+typedef short              int16;
+typedef long               int32;
+
+
+#endif  /* __MT_DEFS_H__ */
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_emerald_env_regs.h b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_emerald_env_regs.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_emerald_env_regs.h
@@ -0,0 +1,564 @@
+#ifndef __Emerald_Env_regs_H__
+#define __Emerald_Env_regs_H__
+
+/* UART_WRITE_DATA */
+#define REG_UART_WRITE_DATA          0xc
+#define REG_UART_WRITE_DATA_MASK     0x000000ff
+#define REG_UART_WRITE_DATA_SHIFT    0
+#define REG_UART_WRITE_DATA_WIDTH    8
+
+/* UART_READ_DATA */
+#define REG_UART_READ_DATA          0x10
+#define REG_UART_READ_DATA_MASK     0x000000ff
+#define REG_UART_READ_DATA_SHIFT    0
+#define REG_UART_READ_DATA_WIDTH    8
+
+/* UART_READ_PARITY_ERROR_BIT */
+#define REG_UART_READ_PARITY_ERROR_BIT          0x10
+#define REG_UART_READ_PARITY_ERROR_BIT_MASK     0x00000100
+#define REG_UART_READ_PARITY_ERROR_BIT_SHIFT    8
+#define REG_UART_READ_PARITY_ERROR_BIT_WIDTH    1
+
+/* UART_CLOCK_DIVISION_RATIO */
+#define REG_UART_CLOCK_DIVISION_RATIO          0x14
+#define REG_UART_CLOCK_DIVISION_RATIO_MASK     0x00003fff
+#define REG_UART_CLOCK_DIVISION_RATIO_SHIFT    0
+#define REG_UART_CLOCK_DIVISION_RATIO_WIDTH    14
+
+/* UART_RX_FIFO_WATER_LEVEL */
+#define REG_UART_RX_FIFO_WATER_LEVEL          0x18
+#define REG_UART_RX_FIFO_WATER_LEVEL_MASK     0x0000001f
+#define REG_UART_RX_FIFO_WATER_LEVEL_SHIFT    0
+#define REG_UART_RX_FIFO_WATER_LEVEL_WIDTH    5
+
+/* UART_TX_FIFO_WATER_LEVEL */
+#define REG_UART_TX_FIFO_WATER_LEVEL          0x18
+#define REG_UART_TX_FIFO_WATER_LEVEL_MASK     0x000003e0
+#define REG_UART_TX_FIFO_WATER_LEVEL_SHIFT    5
+#define REG_UART_TX_FIFO_WATER_LEVEL_WIDTH    5
+
+/* UART_INT */
+#define REG_UART_INT          0x1c
+#define REG_UART_INT_MASK     0x0
+#define REG_UART_INT_SHIFT    0
+#define REG_UART_INT_WIDTH    0
+
+/* UART_OVERRUN_IRQ_ENABLE */
+#define REG_UART_OVERRUN_IRQ_ENABLE          0x1c
+#define REG_UART_OVERRUN_IRQ_ENABLE_MASK     0x00000001
+#define REG_UART_OVERRUN_IRQ_ENABLE_SHIFT    0
+#define REG_UART_OVERRUN_IRQ_ENABLE_WIDTH    1
+
+/* UART_FRAMING_ERROR_IRQ_ENABLE */
+#define REG_UART_FRAMING_ERROR_IRQ_ENABLE          0x1c
+#define REG_UART_FRAMING_ERROR_IRQ_ENABLE_MASK     0x00000002
+#define REG_UART_FRAMING_ERROR_IRQ_ENABLE_SHIFT    1
+#define REG_UART_FRAMING_ERROR_IRQ_ENABLE_WIDTH    1
+
+/* UART_PARITY_ERROR_IRQ_ENABLE */
+#define REG_UART_PARITY_ERROR_IRQ_ENABLE          0x1c
+#define REG_UART_PARITY_ERROR_IRQ_ENABLE_MASK     0x00000004
+#define REG_UART_PARITY_ERROR_IRQ_ENABLE_SHIFT    2
+#define REG_UART_PARITY_ERROR_IRQ_ENABLE_WIDTH    1
+
+/* UART_READ_COLLAPSE_BUFFER_IRQ_ENABLE */
+#define REG_UART_READ_COLLAPSE_BUFFER_IRQ_ENABLE          0x1c
+#define REG_UART_READ_COLLAPSE_BUFFER_IRQ_ENABLE_MASK     0x00000008
+#define REG_UART_READ_COLLAPSE_BUFFER_IRQ_ENABLE_SHIFT    3
+#define REG_UART_READ_COLLAPSE_BUFFER_IRQ_ENABLE_WIDTH    1
+
+/* UART_WRITE_COLLAPSE_BUFFER_IRQ_ENABLE */
+#define REG_UART_WRITE_COLLAPSE_BUFFER_IRQ_ENABLE          0x1c
+#define REG_UART_WRITE_COLLAPSE_BUFFER_IRQ_ENABLE_MASK     0x00000010
+#define REG_UART_WRITE_COLLAPSE_BUFFER_IRQ_ENABLE_SHIFT    4
+#define REG_UART_WRITE_COLLAPSE_BUFFER_IRQ_ENABLE_WIDTH    1
+
+/* UART_READ_FIFO_WATER_LEVEL_IRQ_ENABLE */
+#define REG_UART_READ_FIFO_WATER_LEVEL_IRQ_ENABLE          0x1c
+#define REG_UART_READ_FIFO_WATER_LEVEL_IRQ_ENABLE_MASK     0x00000020
+#define REG_UART_READ_FIFO_WATER_LEVEL_IRQ_ENABLE_SHIFT    5
+#define REG_UART_READ_FIFO_WATER_LEVEL_IRQ_ENABLE_WIDTH    1
+
+/* UART_WRITE_FIFO_WATER_LEVEL_IRQ_ENABLE */
+#define REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ_ENABLE          0x1c
+#define REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ_ENABLE_MASK     0x00000040
+#define REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ_ENABLE_SHIFT    6
+#define REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ_ENABLE_WIDTH    1
+
+/* UART_IDLE_IRQ_ENABLE */
+#define REG_UART_IDLE_IRQ_ENABLE          0x1c
+#define REG_UART_IDLE_IRQ_ENABLE_MASK     0x00000080
+#define REG_UART_IDLE_IRQ_ENABLE_SHIFT    7
+#define REG_UART_IDLE_IRQ_ENABLE_WIDTH    1
+
+/* UART_OVERRUN_IRQ */
+/* Clear the IRQ by writing "1" to this bit. */
+#define REG_UART_OVERRUN_IRQ          0x1c
+#define REG_UART_OVERRUN_IRQ_MASK     0x00000100
+#define REG_UART_OVERRUN_IRQ_SHIFT    8
+#define REG_UART_OVERRUN_IRQ_WIDTH    1
+
+/* UART_FRAMING_ERROR_IRQ */
+/* Clear the IRQ by writing "1" to this bit. */
+#define REG_UART_FRAMING_ERROR_IRQ          0x1c
+#define REG_UART_FRAMING_ERROR_IRQ_MASK     0x00000200
+#define REG_UART_FRAMING_ERROR_IRQ_SHIFT    9
+#define REG_UART_FRAMING_ERROR_IRQ_WIDTH    1
+
+/* UART_PARITY_ERROR_IRQ */
+/* Clear the IRQ by writing "1" to this bit. */
+#define REG_UART_PARITY_ERROR_IRQ          0x1c
+#define REG_UART_PARITY_ERROR_IRQ_MASK     0x00000400
+#define REG_UART_PARITY_ERROR_IRQ_SHIFT    10
+#define REG_UART_PARITY_ERROR_IRQ_WIDTH    1
+
+/* UART_READ_COLLAPSE_BUFFER_IRQ */
+/* Clear the IRQ by writing "1" to this bit. */
+#define REG_UART_READ_COLLAPSE_BUFFER_IRQ          0x1c
+#define REG_UART_READ_COLLAPSE_BUFFER_IRQ_MASK     0x00000800
+#define REG_UART_READ_COLLAPSE_BUFFER_IRQ_SHIFT    11
+#define REG_UART_READ_COLLAPSE_BUFFER_IRQ_WIDTH    1
+
+/* UART_WRITE_COLLAPSE_BUFFER_IRQ */
+/* Clear the IRQ by writing "1" to this bit. */
+#define REG_UART_WRITE_COLLAPSE_BUFFER_IRQ          0x1c
+#define REG_UART_WRITE_COLLAPSE_BUFFER_IRQ_MASK     0x00001000
+#define REG_UART_WRITE_COLLAPSE_BUFFER_IRQ_SHIFT    12
+#define REG_UART_WRITE_COLLAPSE_BUFFER_IRQ_WIDTH    1
+
+/* UART_READ_FIFO_WATER_LEVEL_IRQ */
+/* Clear the IRQ by writing "1" to this bit. */
+#define REG_UART_READ_FIFO_WATER_LEVEL_IRQ          0x1c
+#define REG_UART_READ_FIFO_WATER_LEVEL_IRQ_MASK     0x00002000
+#define REG_UART_READ_FIFO_WATER_LEVEL_IRQ_SHIFT    13
+#define REG_UART_READ_FIFO_WATER_LEVEL_IRQ_WIDTH    1
+
+/* UART_WRITE_FIFO_WATER_LEVEL_IRQ */
+/* Clear the IRQ by writing "1" to this bit. */
+#define REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ          0x1c
+#define REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ_MASK     0x00004000
+#define REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ_SHIFT    14
+#define REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ_WIDTH    1
+
+/* UART_IDLE_IRQ */
+/* Clear the IRQ by writing "1" to this bit. */
+#define REG_UART_IDLE_IRQ          0x1c
+#define REG_UART_IDLE_IRQ_MASK     0x00008000
+#define REG_UART_IDLE_IRQ_SHIFT    15
+#define REG_UART_IDLE_IRQ_WIDTH    1
+
+/* UART_CONTROL */
+#define REG_UART_CONTROL          0x20
+#define REG_UART_CONTROL_MASK     0x0
+#define REG_UART_CONTROL_SHIFT    0
+#define REG_UART_CONTROL_WIDTH    0
+
+/* UART_TX_OUTPUT_ENABLE */
+#define REG_UART_TX_OUTPUT_ENABLE          0x20
+#define REG_UART_TX_OUTPUT_ENABLE_MASK     0x00000001
+#define REG_UART_TX_OUTPUT_ENABLE_SHIFT    0
+#define REG_UART_TX_OUTPUT_ENABLE_WIDTH    1
+
+/* UART_RX_PARITY_MODE */
+#define REG_UART_RX_PARITY_MODE          0x20
+#define REG_UART_RX_PARITY_MODE_MASK     0x00000006
+#define REG_UART_RX_PARITY_MODE_SHIFT    1
+#define REG_UART_RX_PARITY_MODE_WIDTH    2
+
+/* UART_TX_PARITY_MODE */
+#define REG_UART_TX_PARITY_MODE          0x20
+#define REG_UART_TX_PARITY_MODE_MASK     0x00000018
+#define REG_UART_TX_PARITY_MODE_SHIFT    3
+#define REG_UART_TX_PARITY_MODE_WIDTH    2
+
+/* UART_RX_STOP */
+#define REG_UART_RX_STOP          0x20
+#define REG_UART_RX_STOP_MASK     0x00000020
+#define REG_UART_RX_STOP_SHIFT    5
+#define REG_UART_RX_STOP_WIDTH    1
+
+/* UART_TX_STOP */
+#define REG_UART_TX_STOP          0x20
+#define REG_UART_TX_STOP_MASK     0x00000040
+#define REG_UART_TX_STOP_SHIFT    6
+#define REG_UART_TX_STOP_WIDTH    1
+
+/* UART_LOOPBACK_MODE */
+#define REG_UART_LOOPBACK_MODE          0x20
+#define REG_UART_LOOPBACK_MODE_MASK     0x00000080
+#define REG_UART_LOOPBACK_MODE_SHIFT    7
+#define REG_UART_LOOPBACK_MODE_WIDTH    1
+
+/* UART_NOISE_COUNTER */
+#define REG_UART_NOISE_COUNTER          0x24
+#define REG_UART_NOISE_COUNTER_MASK     0x10000000
+#define REG_UART_NOISE_COUNTER_SHIFT    28
+#define REG_UART_NOISE_COUNTER_WIDTH    1
+
+/* UART_RX_IDLE_COUNTER */
+#define REG_UART_RX_IDLE_COUNTER          0x28
+#define REG_UART_RX_IDLE_COUNTER_MASK     0x000000ff
+#define REG_UART_RX_IDLE_COUNTER_SHIFT    0
+#define REG_UART_RX_IDLE_COUNTER_WIDTH    8
+
+/* UART_BYTES_IN_RX_FIFO */
+#define REG_UART_BYTES_IN_RX_FIFO          0x2c
+#define REG_UART_BYTES_IN_RX_FIFO_MASK     0x0000001f
+#define REG_UART_BYTES_IN_RX_FIFO_SHIFT    0
+#define REG_UART_BYTES_IN_RX_FIFO_WIDTH    5
+
+/* UART_BYTES_IN_TX_FIFO */
+#define REG_UART_BYTES_IN_TX_FIFO          0x2c
+#define REG_UART_BYTES_IN_TX_FIFO_MASK     0x000003e0
+#define REG_UART_BYTES_IN_TX_FIFO_SHIFT    5
+#define REG_UART_BYTES_IN_TX_FIFO_WIDTH    5
+
+/* UART_TX_INTERRUPT_MODE */
+#define REG_UART_TX_INTERRUPT_MODE          0x30
+#define REG_UART_TX_INTERRUPT_MODE_MASK     0x00000001
+#define REG_UART_TX_INTERRUPT_MODE_SHIFT    0
+#define REG_UART_TX_INTERRUPT_MODE_WIDTH    1
+
+
+#define REG_IRQ_MASK                       0x140
+
+/* IRQ_SOURCE_01_MAPPING */
+#define REG_IRQ_SOURCE_01_MAPPING          0x148
+#define REG_IRQ_SOURCE_01_MAPPING_MASK     0x0000001f
+#define REG_IRQ_SOURCE_01_MAPPING_SHIFT    0
+#define REG_IRQ_SOURCE_01_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_02_MAPPING */
+#define REG_IRQ_SOURCE_02_MAPPING          0x148
+#define REG_IRQ_SOURCE_02_MAPPING_MASK     0x000003e0
+#define REG_IRQ_SOURCE_02_MAPPING_SHIFT    5
+#define REG_IRQ_SOURCE_02_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_03_MAPPING */
+#define REG_IRQ_SOURCE_03_MAPPING          0x148
+#define REG_IRQ_SOURCE_03_MAPPING_MASK     0x00007c00
+#define REG_IRQ_SOURCE_03_MAPPING_SHIFT    10
+#define REG_IRQ_SOURCE_03_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_04_MAPPING */
+#define REG_IRQ_SOURCE_04_MAPPING          0x148
+#define REG_IRQ_SOURCE_04_MAPPING_MASK     0x000f8000
+#define REG_IRQ_SOURCE_04_MAPPING_SHIFT    15
+#define REG_IRQ_SOURCE_04_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_05_MAPPING */
+#define REG_IRQ_SOURCE_05_MAPPING          0x148
+#define REG_IRQ_SOURCE_05_MAPPING_MASK     0x01f00000
+#define REG_IRQ_SOURCE_05_MAPPING_SHIFT    20
+#define REG_IRQ_SOURCE_05_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_06_MAPPING */
+#define REG_IRQ_SOURCE_06_MAPPING          0x148
+#define REG_IRQ_SOURCE_06_MAPPING_MASK     0x3e000000
+#define REG_IRQ_SOURCE_06_MAPPING_SHIFT    25
+#define REG_IRQ_SOURCE_06_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_07_MAPPING */
+#define REG_IRQ_SOURCE_07_MAPPING          0x14c
+#define REG_IRQ_SOURCE_07_MAPPING_MASK     0x0000001f
+#define REG_IRQ_SOURCE_07_MAPPING_SHIFT    0
+#define REG_IRQ_SOURCE_07_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_08_MAPPING */
+#define REG_IRQ_SOURCE_08_MAPPING          0x14c
+#define REG_IRQ_SOURCE_08_MAPPING_MASK     0x000003e0
+#define REG_IRQ_SOURCE_08_MAPPING_SHIFT    5
+#define REG_IRQ_SOURCE_08_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_09_MAPPING */
+#define REG_IRQ_SOURCE_09_MAPPING          0x14c
+#define REG_IRQ_SOURCE_09_MAPPING_MASK     0x00007c00
+#define REG_IRQ_SOURCE_09_MAPPING_SHIFT    10
+#define REG_IRQ_SOURCE_09_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_10_MAPPING */
+#define REG_IRQ_SOURCE_10_MAPPING          0x14c
+#define REG_IRQ_SOURCE_10_MAPPING_MASK     0x000f8000
+#define REG_IRQ_SOURCE_10_MAPPING_SHIFT    15
+#define REG_IRQ_SOURCE_10_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_11_MAPPING */
+#define REG_IRQ_SOURCE_11_MAPPING          0x14c
+#define REG_IRQ_SOURCE_11_MAPPING_MASK     0x01f00000
+#define REG_IRQ_SOURCE_11_MAPPING_SHIFT    20
+#define REG_IRQ_SOURCE_11_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_12_MAPPING */
+#define REG_IRQ_SOURCE_12_MAPPING          0x14c
+#define REG_IRQ_SOURCE_12_MAPPING_MASK     0x3e000000
+#define REG_IRQ_SOURCE_12_MAPPING_SHIFT    25
+#define REG_IRQ_SOURCE_12_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_13_MAPPING */
+#define REG_IRQ_SOURCE_13_MAPPING          0x150
+#define REG_IRQ_SOURCE_13_MAPPING_MASK     0x0000001f
+#define REG_IRQ_SOURCE_13_MAPPING_SHIFT    0
+#define REG_IRQ_SOURCE_13_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_14_MAPPING */
+#define REG_IRQ_SOURCE_14_MAPPING          0x150
+#define REG_IRQ_SOURCE_14_MAPPING_MASK     0x000003e0
+#define REG_IRQ_SOURCE_14_MAPPING_SHIFT    5
+#define REG_IRQ_SOURCE_14_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_15_MAPPING */
+#define REG_IRQ_SOURCE_15_MAPPING          0x150
+#define REG_IRQ_SOURCE_15_MAPPING_MASK     0x00007c00
+#define REG_IRQ_SOURCE_15_MAPPING_SHIFT    10
+#define REG_IRQ_SOURCE_15_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_16_MAPPING */
+#define REG_IRQ_SOURCE_16_MAPPING          0x150
+#define REG_IRQ_SOURCE_16_MAPPING_MASK     0x000f8000
+#define REG_IRQ_SOURCE_16_MAPPING_SHIFT    15
+#define REG_IRQ_SOURCE_16_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_17_MAPPING */
+#define REG_IRQ_SOURCE_17_MAPPING          0x150
+#define REG_IRQ_SOURCE_17_MAPPING_MASK     0x01f00000
+#define REG_IRQ_SOURCE_17_MAPPING_SHIFT    20
+#define REG_IRQ_SOURCE_17_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_18_MAPPING */
+#define REG_IRQ_SOURCE_18_MAPPING          0x150
+#define REG_IRQ_SOURCE_18_MAPPING_MASK     0x3e000000
+#define REG_IRQ_SOURCE_18_MAPPING_SHIFT    25
+#define REG_IRQ_SOURCE_18_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_19_MAPPING */
+#define REG_IRQ_SOURCE_19_MAPPING          0x154
+#define REG_IRQ_SOURCE_19_MAPPING_MASK     0x0000001f
+#define REG_IRQ_SOURCE_19_MAPPING_SHIFT    0
+#define REG_IRQ_SOURCE_19_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_20_MAPPING */
+#define REG_IRQ_SOURCE_20_MAPPING          0x154
+#define REG_IRQ_SOURCE_20_MAPPING_MASK     0x000003e0
+#define REG_IRQ_SOURCE_20_MAPPING_SHIFT    5
+#define REG_IRQ_SOURCE_20_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_21_MAPPING */
+#define REG_IRQ_SOURCE_21_MAPPING          0x154
+#define REG_IRQ_SOURCE_21_MAPPING_MASK     0x00007c00
+#define REG_IRQ_SOURCE_21_MAPPING_SHIFT    10
+#define REG_IRQ_SOURCE_21_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_22_MAPPING */
+#define REG_IRQ_SOURCE_22_MAPPING          0x154
+#define REG_IRQ_SOURCE_22_MAPPING_MASK     0x000f8000
+#define REG_IRQ_SOURCE_22_MAPPING_SHIFT    15
+#define REG_IRQ_SOURCE_22_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_23_MAPPING */
+#define REG_IRQ_SOURCE_23_MAPPING          0x154
+#define REG_IRQ_SOURCE_23_MAPPING_MASK     0x01f00000
+#define REG_IRQ_SOURCE_23_MAPPING_SHIFT    20
+#define REG_IRQ_SOURCE_23_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_24_MAPPING */
+#define REG_IRQ_SOURCE_24_MAPPING          0x154
+#define REG_IRQ_SOURCE_24_MAPPING_MASK     0x3e000000
+#define REG_IRQ_SOURCE_24_MAPPING_SHIFT    25
+#define REG_IRQ_SOURCE_24_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_25_MAPPING */
+#define REG_IRQ_SOURCE_25_MAPPING          0x158
+#define REG_IRQ_SOURCE_25_MAPPING_MASK     0x0000001f
+#define REG_IRQ_SOURCE_25_MAPPING_SHIFT    0
+#define REG_IRQ_SOURCE_25_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_26_MAPPING */
+#define REG_IRQ_SOURCE_26_MAPPING          0x158
+#define REG_IRQ_SOURCE_26_MAPPING_MASK     0x000003e0
+#define REG_IRQ_SOURCE_26_MAPPING_SHIFT    5
+#define REG_IRQ_SOURCE_26_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_27_MAPPING */
+#define REG_IRQ_SOURCE_27_MAPPING          0x158
+#define REG_IRQ_SOURCE_27_MAPPING_MASK     0x00007c00
+#define REG_IRQ_SOURCE_27_MAPPING_SHIFT    10
+#define REG_IRQ_SOURCE_27_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_28_MAPPING */
+#define REG_IRQ_SOURCE_28_MAPPING          0x158
+#define REG_IRQ_SOURCE_28_MAPPING_MASK     0x000f8000
+#define REG_IRQ_SOURCE_28_MAPPING_SHIFT    15
+#define REG_IRQ_SOURCE_28_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_29_MAPPING */
+#define REG_IRQ_SOURCE_29_MAPPING          0x158
+#define REG_IRQ_SOURCE_29_MAPPING_MASK     0x01f00000
+#define REG_IRQ_SOURCE_29_MAPPING_SHIFT    20
+#define REG_IRQ_SOURCE_29_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_30_MAPPING */
+#define REG_IRQ_SOURCE_30_MAPPING          0x158
+#define REG_IRQ_SOURCE_30_MAPPING_MASK     0x3e000000
+#define REG_IRQ_SOURCE_30_MAPPING_SHIFT    25
+#define REG_IRQ_SOURCE_30_MAPPING_WIDTH    5
+
+/* IRQ_SOURCE_31_MAPPING */
+#define REG_IRQ_SOURCE_31_MAPPING          0x15c
+#define REG_IRQ_SOURCE_31_MAPPING_MASK     0x0000001f
+#define REG_IRQ_SOURCE_31_MAPPING_SHIFT    0
+#define REG_IRQ_SOURCE_31_MAPPING_WIDTH    5
+
+/* MAPPED_IRQS_FROM_MAPPER */
+#define REG_MAPPED_IRQS_FROM_MAPPER          0x160
+#define REG_MAPPED_IRQS_FROM_MAPPER_MASK     0x7fffffff
+#define REG_MAPPED_IRQS_FROM_MAPPER_SHIFT    0
+#define REG_MAPPED_IRQS_FROM_MAPPER_WIDTH    31
+
+/* UNMAPPED_IRQS_TO_MAPPER */
+#define REG_UNMAPPED_IRQS_TO_MAPPER          0x164
+#define REG_UNMAPPED_IRQS_TO_MAPPER_MASK     0x7fffffff
+#define REG_UNMAPPED_IRQS_TO_MAPPER_SHIFT    0
+#define REG_UNMAPPED_IRQS_TO_MAPPER_WIDTH    31
+
+/* TIMER_0_MAX_COUNT */
+#define REG_TIMER_0_MAX_COUNT          0x180
+#define REG_TIMER_0_MAX_COUNT_MASK     0xffffffff
+#define REG_TIMER_0_MAX_COUNT_SHIFT    0
+#define REG_TIMER_0_MAX_COUNT_WIDTH    32
+
+/* TIMER_1_MAX_COUNT */
+#define REG_TIMER_1_MAX_COUNT          0x184
+#define REG_TIMER_1_MAX_COUNT_MASK     0xffffffff
+#define REG_TIMER_1_MAX_COUNT_SHIFT    0
+#define REG_TIMER_1_MAX_COUNT_WIDTH    32
+
+/* TIMER_2_MAX_COUNT */
+#define REG_TIMER_2_MAX_COUNT          0x188
+#define REG_TIMER_2_MAX_COUNT_MASK     0xffffffff
+#define REG_TIMER_2_MAX_COUNT_SHIFT    0
+#define REG_TIMER_2_MAX_COUNT_WIDTH    32
+
+/* TIMER_3_MAX_COUNT */
+#define REG_TIMER_3_MAX_COUNT          0x18c
+#define REG_TIMER_3_MAX_COUNT_MASK     0xffffffff
+#define REG_TIMER_3_MAX_COUNT_SHIFT    0
+#define REG_TIMER_3_MAX_COUNT_WIDTH    32
+
+/* TIMER_0_COUNT_VALUE */
+#define REG_TIMER_0_COUNT_VALUE          0x190
+#define REG_TIMER_0_COUNT_VALUE_MASK     0xffffffff
+#define REG_TIMER_0_COUNT_VALUE_SHIFT    0
+#define REG_TIMER_0_COUNT_VALUE_WIDTH    32
+
+/* TIMER_1_COUNT_VALUE */
+#define REG_TIMER_1_COUNT_VALUE          0x194
+#define REG_TIMER_1_COUNT_VALUE_MASK     0xffffffff
+#define REG_TIMER_1_COUNT_VALUE_SHIFT    0
+#define REG_TIMER_1_COUNT_VALUE_WIDTH    32
+
+/* TIMER_2_COUNT_VALUE */
+#define REG_TIMER_2_COUNT_VALUE          0x198
+#define REG_TIMER_2_COUNT_VALUE_MASK     0xffffffff
+#define REG_TIMER_2_COUNT_VALUE_SHIFT    0
+#define REG_TIMER_2_COUNT_VALUE_WIDTH    32
+
+/* TIMER_3_COUNT_VALUE */
+#define REG_TIMER_3_COUNT_VALUE          0x19c
+#define REG_TIMER_3_COUNT_VALUE_MASK     0xffffffff
+#define REG_TIMER_3_COUNT_VALUE_SHIFT    0
+#define REG_TIMER_3_COUNT_VALUE_WIDTH    32
+
+/* TIMER0_EXPIRED */
+#define REG_TIMER0_EXPIRED          0x1a0
+#define REG_TIMER0_EXPIRED_MASK     0x00000001
+#define REG_TIMER0_EXPIRED_SHIFT    0
+#define REG_TIMER0_EXPIRED_WIDTH    1
+
+/* TIMER1_EXPIRED */
+#define REG_TIMER1_EXPIRED          0x1a0
+#define REG_TIMER1_EXPIRED_MASK     0x00000002
+#define REG_TIMER1_EXPIRED_SHIFT    1
+#define REG_TIMER1_EXPIRED_WIDTH    1
+
+/* TIMER2_EXPIRED */
+#define REG_TIMER2_EXPIRED          0x1a0
+#define REG_TIMER2_EXPIRED_MASK     0x00000004
+#define REG_TIMER2_EXPIRED_SHIFT    2
+#define REG_TIMER2_EXPIRED_WIDTH    1
+
+/* TIMER3_EXPIRED */
+#define REG_TIMER3_EXPIRED          0x1a0
+#define REG_TIMER3_EXPIRED_MASK     0x00000008
+#define REG_TIMER3_EXPIRED_SHIFT    3
+#define REG_TIMER3_EXPIRED_WIDTH    1
+
+/* TIMER_0_ONESHOT_MODE */
+#define REG_TIMER_0_ONESHOT_MODE          0x1a4
+#define REG_TIMER_0_ONESHOT_MODE_MASK     0x00000001
+#define REG_TIMER_0_ONESHOT_MODE_SHIFT    0
+#define REG_TIMER_0_ONESHOT_MODE_WIDTH    1
+
+/* TIMER_1_ONESHOT_MODE */
+#define REG_TIMER_1_ONESHOT_MODE          0x1a4
+#define REG_TIMER_1_ONESHOT_MODE_MASK     0x00000002
+#define REG_TIMER_1_ONESHOT_MODE_SHIFT    1
+#define REG_TIMER_1_ONESHOT_MODE_WIDTH    1
+
+/* TIMER_2_ONESHOT_MODE */
+#define REG_TIMER_2_ONESHOT_MODE          0x1a4
+#define REG_TIMER_2_ONESHOT_MODE_MASK     0x00000004
+#define REG_TIMER_2_ONESHOT_MODE_SHIFT    2
+#define REG_TIMER_2_ONESHOT_MODE_WIDTH    1
+
+/* TIMER_3_ONESHOT_MODE */
+#define REG_TIMER_3_ONESHOT_MODE          0x1a4
+#define REG_TIMER_3_ONESHOT_MODE_MASK     0x00000008
+#define REG_TIMER_3_ONESHOT_MODE_SHIFT    3
+#define REG_TIMER_3_ONESHOT_MODE_WIDTH    1
+
+/* TIMER_0_ENABLE */
+#define REG_TIMER_0_ENABLE          0x1a4
+#define REG_TIMER_0_ENABLE_MASK     0x00000010
+#define REG_TIMER_0_ENABLE_SHIFT    4
+#define REG_TIMER_0_ENABLE_WIDTH    1
+
+/* TIMER_1_ENABLE */
+#define REG_TIMER_1_ENABLE          0x1a4
+#define REG_TIMER_1_ENABLE_MASK     0x00000020
+#define REG_TIMER_1_ENABLE_SHIFT    5
+#define REG_TIMER_1_ENABLE_WIDTH    1
+
+/* TIMER_2_ENABLE */
+#define REG_TIMER_2_ENABLE          0x1a4
+#define REG_TIMER_2_ENABLE_MASK     0x00000040
+#define REG_TIMER_2_ENABLE_SHIFT    6
+#define REG_TIMER_2_ENABLE_WIDTH    1
+
+/* TIMER_3_ENABLE */
+#define REG_TIMER_3_ENABLE          0x1a4
+#define REG_TIMER_3_ENABLE_MASK     0x00000080
+#define REG_TIMER_3_ENABLE_SHIFT    7
+#define REG_TIMER_3_ENABLE_WIDTH    1
+
+/*Prescale */
+#define REG_TIMER_PRESCALER_MIN     2
+#define REG_TIMER_PRESCALER_MAX     3
+
+/* TIMER_0_PRESCALER - N/A*/
+
+/* TIMER_1_PRESCALER - N/A*/
+
+/* TIMER_2_PRESCALER */
+#define REG_TIMER_2_PRESCALER       0x1a8
+#define REG_TIMER_2_PRESCALER_MASK  0x000000ff
+#define REG_TIMER_2_PRESCALER_SHIFT 0
+#define REG_TIMER_2_PRESCALER_WIDTH 8
+
+/* TIMER_3_PRESCALER */
+#define REG_TIMER_3_PRESCALER       0x1ac
+#define REG_TIMER_3_PRESCALER_MASK  0x000000ff
+#define REG_TIMER_3_PRESCALER_SHIFT 0
+#define REG_TIMER_3_PRESCALER_WIDTH 8
+
+
+#endif /* __Emerald_Env_regs_H__ */
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_interrupt.h b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_interrupt.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_interrupt.h
@@ -0,0 +1,133 @@
+#ifndef __GRX500_BOOTCORE_INTERRUPT_H__
+#define __GRX500_BOOTCORE_INTERRUPT_H__
+
+#ifdef  MT_GLOBAL
+#define MT_EXTERN
+#define MT_I(x) x
+#else
+#define MT_EXTERN extern
+#define MT_I(x)
+#endif
+
+extern void grx500_bootcore_enable_irq_all_mips(unsigned long val);
+
+extern void grx500_bootcore_init_irq(void);
+
+/**
+ *      grx500_bootcore_register_static_irq - register interrupt
+ *      @irq_in: Incoming IRQ number for interrupt router
+ *      @irq_out: Outgoing IRQ number for interrupt router
+ *      @action: IRQ action structure in memory provided by user
+ *      @addr: Vector interrupt handler
+ *
+ * Used to statically register interrupt during system startup.
+ */
+
+extern int grx500_bootcore_register_static_irq(unsigned int irq_in, unsigned int irq_out, 
+                                    struct irqaction *action, vi_handler_t addr);
+
+/**
+ *      grx500_bootcore_register_irq - register interrupt
+ *      @irq_in: Incoming IRQ number for interrupt router
+ *      @irq_out: Outgoing IRQ number for interrupt router
+ *      @handler: User's handler function
+ *      @flags: IRQ flags
+ *      @name: Device name
+ *      @dev_id: Owner device ID
+ *      @addr: Vector interrupt handler
+ *
+ * Used to dynamically register interrupt during system operation.
+ */
+
+extern int grx500_bootcore_register_irq(unsigned int irq_in, unsigned int irq_out,
+                             irq_handler_t handler, unsigned long flags,
+                             const char *name, void *dev_id, vi_handler_t addr);
+
+/**
+ *      grx500_bootcore_unregister_irq - unregister interrupt
+ *      @irq_in: Incoming IRQ number for interrupt router
+ *      @irq_out: Outgoing IRQ number for interrupt router
+ *      @dev_id: Owner device ID
+ *
+ * Used to dynamically unregister interrupt during system operation.
+ */
+extern void grx500_bootcore_unregister_irq(unsigned int irq_in, unsigned int irq_out, void* dev_id);
+
+extern /*static */irqreturn_t uart_interrupt(int irq, void *dev_id);
+extern /*static */void grx500_bootcore_uart_irq(void);
+extern /*static */void grx500_bootcore_net_irq(void);
+extern /*static */void grx500_bootcore_net_g2_irq(void);
+extern void grx500_bootcore_wls_irq(void);
+extern void grx500_bootcore_enable_irq(struct irq_data *d);
+extern void grx500_bootcore_disable_irq(struct irq_data *d);
+extern void grx500_bootcore_disable_irq_all(void);
+extern void grx500_bootcore_enable_irq_all(void);
+
+extern void grx500_bootcore_gptc2_timer2_irq(void);
+extern void grx500_bootcore_gptc2_timer1_irq(void);
+extern void grx500_bootcore_mps_irq(void);
+
+//Yan
+//#ifdef CONFIG_SYNOPGMACHOST_PCI
+//extern irqreturn_t synopGMAC_intr_handler(/*s32*/int intr_num, void * dev_id/*, struct pt_regs *regs*/);
+//#endif
+
+#define IRQ_01_NUM	   			0
+#define IRQ_02_NUM	   			1
+#define IRQ_03_NUM	   			2
+#define IRQ_04_NUM	   			3
+#define IRQ_05_NUM	   			4
+#define IRQ_06_NUM	   			5
+#define IRQ_07_NUM	   			0
+#define IRQ_08_NUM	   			1
+#define IRQ_09_NUM	   			2
+#define IRQ_10_NUM	   			3
+#define IRQ_11_NUM	   			4
+#define IRQ_12_NUM	   			5
+#define IRQ_13_NUM	   			0
+#define IRQ_14_NUM	   			1
+#define IRQ_15_NUM	   			2
+#define IRQ_16_NUM	   			3
+#define IRQ_17_NUM	   			4
+#define IRQ_18_NUM	   			5
+#define IRQ_19_NUM	   			0
+#define IRQ_20_NUM	   			1
+#define IRQ_21_NUM	   			2
+#define IRQ_22_NUM	   			3
+#define IRQ_23_NUM	   			4
+#define IRQ_24_NUM	   			5
+#define IRQ_25_NUM	   			0
+#define IRQ_26_NUM	   			1
+#define IRQ_27_NUM	   			2
+#define IRQ_28_NUM	   			3
+#define IRQ_29_NUM	   			4
+#define IRQ_30_NUM	   			5
+#define IRQ_31_NUM	   			0
+
+#define GRX500_BOOTCORE_SERIAL_IRQ_IN_INDEX       28
+#define GRX500_BOOTCORE_TIMER_IRQ_IN_INDEX        28
+#define GRX500_BOOTCORE_SYNOP_ETHER_IRQ_IN_INDEX  1
+#define GRX500_BOOTCORE_SYNOP_ETHER_IRQ_GMAC2_IN_INDEX  3
+#define GRX500_BOOTCORE_WIRELESS_IRQ_IN_INDEX     9
+
+#define GRX500_BOOTCORE_SERIAL_IRQ_OUT_INDEX      8
+#define GRX500_BOOTCORE_TIMER_IRQ_OUT_INDEX       2
+#define GRX500_BOOTCORE_SYNOP_ETHER_IRQ_OUT_INDEX 3
+#ifndef VBG400_NO_ETH_SHARED_IRQ
+#define GRX500_BOOTCORE_SYNOP_ETHER_IRQ_GMAC2_OUT_INDEX 3
+#else
+#define GRX500_BOOTCORE_SYNOP_ETHER_IRQ_GMAC2_OUT_INDEX 4
+#endif
+#define GRX500_BOOTCORE_WIRELESS_IRQ_OUT_INDEX    5
+
+#define GRX500_BOOTCORE_GPTC2_TIMER2_IN_INDEX	1
+#define GRX500_BOOTCORE_GPTC2_TIMER2_OUT_INDEX	9
+
+#define GRX500_BOOTCORE_GPTC2_TIMER1_IN_INDEX	3
+#define GRX500_BOOTCORE_GPTC2_TIMER1_OUT_INDEX	10
+#define GRX500_BOOTCORE_MPS2_OUT_INDEX  11
+
+#undef MT_EXTERN
+#undef MT_I
+
+#endif /* __GRX500_BOOTCORE_INTERRUPT_H__ */ 
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_time.h b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_time.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_time.h
@@ -0,0 +1,76 @@
+#ifndef __GRX500_BOOTCORE_TIME_H__
+#define __GRX500_BOOTCORE_TIME_H__
+
+#ifdef  MT_GLOBAL
+#define MT_EXTERN
+#define MT_I(x) x
+#else
+#define MT_EXTERN extern
+#define MT_I(x)
+#endif
+
+extern void __init setup_grx500_bootcore_timer(void);
+
+enum {
+  MT_MIPS_TIMER_0,
+  MT_MIPS_TIMER_1,
+  MT_MIPS_TIMER_2,
+  MT_MIPS_TIMER_3
+};
+
+#define MT_MIPS_TIMER_DISABLE      0
+#define MT_MIPS_TIMER_ENABLE       1
+
+#define MT_MIPS_TIMER_ONE_SHOT     0
+#define MT_MIPS_TIMER_MULT_SHOT    1
+
+#ifdef DO_CPU_STAT
+extern void grx500_bootcore_set_time_mips_timer(unsigned long timerId, unsigned long maxCount);	
+extern void grx500_bootcore_set_mode_mips_timer(unsigned long timerId, unsigned long enableTimer, unsigned long shotMode);	
+extern void grx500_bootcore_set_time_mips_prescaler(unsigned long  timerId, unsigned long  prescale);	
+#endif
+
+#undef MT_EXTERN
+#undef MT_I
+
+/*for real system undefine GRX500_BOOTCORE_SCALE_DOWN*/
+extern unsigned int system_to_cpu_multiplier;
+#ifdef CONFIG_VBG400_CHIPIT
+#define GRX500_BOOTCORE_SCALE_DOWN
+#endif
+
+#ifdef GRX500_BOOTCORE_SCALE_DOWN
+#define GRX500_BOOTCORE_SCALE_VAL 10
+#else
+#define GRX500_BOOTCORE_SCALE_VAL 1
+#endif
+
+#if 1
+#ifdef CONFIG_USE_EMULATOR
+#define GRX500_BOOTCORE_SYSTEM_CLK  6000000
+#define GRX500_BOOTCORE_CPU_CLK     6000000; //480000000
+#else
+#define CLOCK_300M  300000000
+#define GRX500_BOOTCORE_SYSTEM_CLK CLOCK_300M
+#define GRX500_BOOTCORE_CPU_CLK    CLOCK_300M
+#endif
+#else
+#define GRX500_BOOTCORE_SYSTEM_CLK  (24000000*GRX500_BOOTCORE_SCALE_VAL)
+#ifdef CONFIG_VBG400_CHIPIT
+#define GRX500_BOOTCORE_CPU_CLK     (48000000*GRX500_BOOTCORE_SCALE_VAL)
+#else
+#define GRX500_BOOTCORE_CPU_CLK     (GRX500_BOOTCORE_SYSTEM_CLK *system_to_cpu_multiplier)
+#endif
+#endif
+
+#define REG_NPU_SYS_INFO		0x60
+#define CPU_FAST_MODE		0x00080000
+
+/* Note - the timer used is GRX500_BOOTCORE, run 24000000M
+* If we use the MIPS timer, change to  GRX500_BOOTCORE_CPU_CLK
+*/
+//#define TICK_DIV (GRX500_BOOTCORE_CPU_CLK/HZ)
+#define TICK_DIV (GRX500_BOOTCORE_SYSTEM_CLK/HZ)
+
+
+#endif /* __GRX500_BOOTCORE_TIME_H__ */ 
diff --git a/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_uart.h b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_uart.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/grx500/grx500_bootcore_uart.h
@@ -0,0 +1,329 @@
+#ifndef __MT_UART_H__
+#define __MT_UART_H__
+
+#include "grx500_bootcore_chadr.h"
+#include "grx500_bootcore_time.h"
+
+#ifdef MT_GLOBAL
+   #define MT_EXTERN
+   #define MT_I(x) x
+#else
+   #define MT_EXTERN extern
+   #define MT_I(x)
+#endif
+
+#define PORT_GRX500_BOOTCORE	82
+
+struct uart_port;
+extern void grx500_bootcore_uart_tx_isr(struct uart_port *port);
+extern void grx500_bootcore_uart_rx_isr(struct uart_port *port);
+
+#define UART_BASE	 			MT_LOCAL_MIPS_BASE_ADDRESS
+
+/***********************************/
+/*       UART  register MASK       */
+/***********************************/
+
+#define WR_ADDR					0x0c
+#define GCLK_ADDR				0 
+
+#define UART_WR_MASK                 			0x000000FF
+#define UART_RD_DATA_MASK	 					0x000000FF
+#define UART_RD_PERR_MASK	 					0x00000100
+#define	UART_DIVR_MASK		 					0x00003FFF
+#define	UART_FWL_RX_MASK	 					0x0000001F
+#define	UART_FWL_TX_MASK	 					0x000003E0
+
+/*	 UART	interrupts enable    */
+#define	UART_INT_OVERRUN_IRQ_ENABLE		 		    	0x00000001
+#define	UART_INT_FRAMING_ERROR_IRQ_ENABLE 	 			0x00000002
+#define UART_INT_PARITY_ERROR_IRQ_ENABLE         		        0x00000004
+#define UART_INT_READ_COLLAPSE_BUFFER_IRQ_ENABLE 	                0x00000008
+#define UART_INT_WRITE_COLLAPSE_BUFFER_IRQ_ENABLE     	                0x00000010
+#define UART_INT_READ_FIFO_WATER_LEVEL_IRQ_ENABLE 		        0x00000020
+#define UART_INT_WRITE_FIFO_WATER_LEVEL_IRQ_ENABLE		        0x00000040
+#define UART_INT_IDLE_IRQ_ENABLE		                        0x00000080
+/*	 UART	interrupts event    */
+#define	UART_INT_OVERRUN_IRQ		 		    		0x00000100
+#define	UART_INT_FRAMING_ERROR_IRQ 	 				0x00000200
+#define UART_INT_PARITY_ERROR_IRQ	 		    		0x00000400
+#define UART_INT_READ_COLLAPSE_BUFFER_IRQ 	    		        0x00000800
+#define UART_INT_WRITE_COLLAPSE_BUFFER_IRQ     			        0x00001000
+#define UART_INT_READ_FIFO_WATER_LEVEL_IRQ 				0x00002000
+#define UART_INT_WRITE_FIFO_WATER_LEVEL_IRQ				0x00004000
+#define UART_INT_IDLE_IRQ       		        		0x00008000
+#define UART_INT_IRQ_MASK_ALL						0x0000FF00
+
+#define UART_CONTROL_TX_OUTPUT_ENABLE_MASK				0x00000001
+#define UART_CONTROL_RX_PARITY_MODE_MASK				0x00000006	
+#define UART_CONTROL_TX_PARITY_MODE_MASK				0x00000018
+#define UART_CONTROL_RX_STOP_MASK					0x00000020
+#define UART_CONTROL_TX_STOP_MASK					0x00000040
+#define UART_CONTROL_LOOPBACK_MODE_MASK			    	        0x00000080
+
+#define UART_NOISE_COUNT_MASK						0x10000000
+
+#define UART_IDLE_CNT_MAX_MASK						0x000000FF
+
+#define UART_COUNT_FIF_RX_MASK                  		        0x0000001F
+#define UART_COUNT_FIF_TX_MASK  					0x000003E0
+#define UART_INT_MODE_MASK						0x00000001
+
+/**************************************************************************************/
+
+#define UART_ENABLE_INTRPT   1
+#define UART_DISABLE_INTRPT  0
+
+#define UART_TX_OUT_ENABLE_NO      1 
+#define UART_TX_OUT_ENABLE_YES     0
+#define UART_TX_OUT_ENABLE_SHIFT   0
+
+/*=============== Baud rate ====================*/
+#define UART_RATE_9600             9600UL
+#define UART_RATE_19200            19200UL
+#define UART_RATE_38400            38400UL
+#define UART_RATE_57600            57600UL
+#define UART_RATE_115200           115200UL
+#define UART_RATE_MAX              UART_RATE_115200
+#define UART_RATE_DEFAULT          UART_RATE_9600
+
+#define UART_BAUD_RATIO_DIV     16
+
+typedef enum  _UART_BAUD{
+   UART_BAUD115200,
+   UART_BAUD38400,
+   UART_BAUD19200,
+   UART_BAUD9600
+} _UART_BAUD;
+
+/* Standard COM flags (except for COM4, because of the 8514 problem) */
+#ifdef CONFIG_SERIAL_DETECT_IRQ
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ)
+#else
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST)
+#endif
+
+#define GRX500_BOOTCORE_BASE_BAUD (GRX500_BOOTCORE_SYSTEM_CLK / UART_BAUD_RATIO_DIV)
+#define GRX500_BOOTCORE_UART_IRQ	1
+//GRX500_BOOTCORE_SERIAL_IRQ_OUT_INDEX
+#define SERIAL_PORT_DFNS			\
+	/* UART CLK   PORT IRQ     FLAGS        */			\
+	{ 0, GRX500_BOOTCORE_BASE_BAUD, UART_BASE, GRX500_BOOTCORE_UART_IRQ, STD_COM_FLAGS },	/* ttyS0 */	
+#define MT_UARTRXIDLE ()
+
+
+/*=============== Parity =======================*/
+#define UART_PARITY_NONE           0           
+#define UART_PARITY_ODD            1
+#define UART_PARITY_EVEN	   3
+#define UART_PARITY_DEFAULT        UART_PARITY_NONE
+#define UART_PARITY_RX_SHIFT	   1 
+#define UART_PARITY_TX_SHIFT	   3
+	   
+/*=============== Num of stop bits ==============*/
+#define UART_STOP_ONEBIT           0
+#define UART_STOP_TWOBIT           1
+#define UART_STOP_DEFAULT          UART_STOP_ONEBIT
+#define	UART_STOP_BIT_RX_SHIFT	   9
+#define	UART_STOP_BIT_TX_SHIFT	   10
+/*=============== Invert output siganl============*/
+#define UART_SIGNAL_NO_INVERT      0
+#define UART_SIGNAL_INVERT         1
+#define UART_SIGNAL_DEFAULT        UART_SIGNAL_NO_INVERT
+
+/*=============== Loop back on off ============*/
+#define UART_LOOPBACK_ON           1
+#define UART_LOOPBACK_OFF          0
+#define UART_LOOPBACK_SHIFT	   11
+/*=============== Reset uart ==================*/
+#define UART_RESET_YES             1
+#define UART_RESET_NO              0
+
+/*=============== Enable disable uart cloocking */
+#define UART_CLOCK_ON              1
+#define UART_CLOCK_OFF             0
+
+/*=============== Enable/Disable host interrupts from uart */
+#define UART_HOST_INTRPT_ENABLE    0
+#define UART_HOST_INTRPT_DISABLE   1
+
+
+/*****************************************************************************
+*
+*       Module's Global Variables
+*
+*****************************************************************************/
+
+
+
+/**********************************************************************
+*			   MCOR	 of UART
+***********************************************************************/
+
+#define MCOR_UART_RX_NUM_MASK 0x1F
+#define UART_MCOR_RD_RX_BYTES ((MT_UBYTE)((MT_RdReg(MT_LOCAL_MIPS_BASE_ADDRESS, REG_UART_BYTES_IN_RX_FIFO) & MCOR_UART_RX_NUM_MASK)))
+
+
+
+
+
+/* Set which type of interrupts are masked */
+
+#define MT_UART_MCOR_IDLE            UART_INT_IDLE_IRQ
+#define MT_UART_MCOR_TX_WATER_LEVEL  UART_INT_WRITE_FIFO_WATER_LEVEL_IRQ
+#define MT_UART_MCOR_RX_WATER_LEVEL  UART_INT_READ_FIFO_WATER_LEVEL_IRQ
+#define MT_UART_MCOR_TX_COLLAPS_ERR  UART_INT_WRITE_COLLAPSE_BUFFER_IRQ
+#define MT_UART_MCOR_RX_COLLAPS_ERR  UART_INT_READ_COLLAPSE_BUFFER_IRQ
+#define MT_UART_MCOR_PARITY_ERR      UART_INT_PARITY_ERROR_IRQ
+#define MT_UART_MCOR_FRAMING_ERR     UART_INT_FRAMING_ERROR_IRQ
+#define MT_UART_MCOR_OVERRUN_ERR     UART_INT_OVERRUN_IRQ
+
+
+/* Find out if UART interrupt */
+#define UART_MCRO_INTRPT_ALL_EVENTS\
+ ( MT_UART_MCOR_IDLE |\
+   MT_UART_MCOR_TX_WATER_LEVEL |\
+   MT_UART_MCOR_RX_WATER_LEVEL |\
+   MT_UART_MCOR_TX_COLLAPS_ERR |\
+   MT_UART_MCOR_RX_COLLAPS_ERR| \
+   MT_UART_MCOR_PARITY_ERR |\
+   MT_UART_MCOR_FRAMING_ERR |\
+   MT_UART_MCOR_OVERRUN_ERR )
+
+
+
+/* Define for global error in uart */
+#define MT_UART_MCOR_ALL_RX_ERR\
+  ( MT_UART_MCOR_PARITY_ERR | MT_UART_MCOR_FRAMING_ERR \
+    | MT_UART_MCOR_OVERRUN_ERR |MT_UART_MCOR_RX_COLLAPS_ERR\
+    | MT_UART_MCOR_TX_COLLAPS_ERR)
+
+#define MT_UART_MCOR_RX_DATA_READY(STATUS) \
+          (STATUS&(MT_UART_MCOR_IDLE|MT_UART_MCOR_RX_WATER_LEVEL))
+
+#define MT_UART_MCOR_IS_TX_INTRPT(STATUS)\
+          (STATUS&MT_UART_MCOR_TX_WATER_LEVEL)
+
+#define MT_UART_MCOR_IS_RX_ERR(STATUS)\
+          (STATUS&MT_UART_MCOR_ALL_RX_ERR)
+
+#define MT_UART_MCOR_IS_RX_PARITY_ERR(STATUS)\
+           (STATUS&MT_UART_MCOR_PARITY_ERR)
+
+#define MT_UART_MCOR_IS_RX_OVERRUN_ERR(STATUS)\
+           (STATUS&MT_UART_MCOR_OVERRUN_ERR)
+
+#define MT_UART_MCOR_IS_RX_FRAMING_ERR(STATUS)\
+           (STATUS&MT_UART_MCOR_FRAMING_ERR )
+
+#define MT_UART_MCOR_IS_TX_COLLAPSE_ERR(STATUS)\
+           (STATUS&MT_UART_MCOR_TX_COLLAPS_ERR)
+
+#define MT_UART_MCOR_IS_RX_COLLAPSE_ERR(STATUS)\
+           (STATUS&MT_UART_MCOR_RX_COLLAPS_ERR)
+
+
+
+#define  MT_RX_INTERRUPT   0x01
+#define  MT_TX_INTERRUPT   0x02
+#define  MT_BSY_EVENT      0x04
+/*
+*  Communications status bit flags
+* ---------------------------------
+*/
+#define UART_INBUF_EMPTY_MASK       0x01 /* Set when the input buffer is empty        */
+#define UART_INBUF_FULL_MASK        0x02 /* Set when the input buffer is full         */
+/* #define MT_INBUF_ALMOST_FULL_MASK 0x04 */ /* deleted ....                              */
+#define UART_OUTBUF_EMPTY_MASK      0x08 /* Set when the output buffer is empty       */
+#define UART_OUTBUF_FULL_MASK       0x10 /* Set when the output buffer is full        */
+#define UART_ADDRESSED_MASK         0x20 /* Set when the modem is addressed           */
+/*#define UART_GLOBAL_ADDRESSED_MASK  0x40 *//* Set when the modem is globally addressed  */
+
+#define UART_COMMS_ERROR_MASK       0x80 /* Set when a comms error is detected.       */
+
+/*
+* Communications Debugging options bit flags
+* ----------------------------------------------
+*/
+#define UART_TRANSMIT_STOPPED    0x01 /* Set when there is no more Data in Output Buffer */
+#define UART_XON_IS_ACTIVE       0x02
+#define UART_XOFF_TRIGGER        0x04
+#define UART_XOFF_IS_ACTIVE      0x08
+#define UART_FIRST_XON           0x10
+#define UART_XON_TRIGGER         0x20
+/*#define UART_NOT_USED_6          0x40*/
+/*#define UART_ALMOST_FULL_FLAG    0x80*/
+
+/*
+*  Communications error flags
+* -----------------------------
+*/
+#define MT_UART_COM_ERR_OVERRUN_MASK      0x01
+#define MT_UART_COM_ERR_BUSY_MASK         0x02
+#define MT_UART_COM_ERR_FRAMING_MASK      0x04
+#define MT_UART_COM_ERR_PARITY_MASK       0x08
+#define MT_UART_COM_ERR_READ_EMPTY_MASK   0x10
+#define MT_UART_COM_ERR_WRITE_FULL_MASK   0x20
+#define MT_UART_COM_MIPS_BUF_OVERRUN_MASK 0x40
+
+
+
+
+
+
+#define MT_COMMS_BUFFER_SIZE  20   //80  ttpcom used 16 
+#define UART_MAX_TXFIFO		  14   /*The buffer tx 16 byte*/
+
+typedef struct {
+
+           unsigned UartOverRunIntrpt:1;
+           unsigned UartFramingIntrpt:1;
+           unsigned UartParityIntrpt:1;
+           unsigned UartRXFIFOCollapseIntrpt:1;
+           unsigned UartTxFIFOCollapseIntrpt:1;
+           unsigned UartRxWaterLevelIntrpt:1;
+           unsigned UartTxWaterLevelIntrpt:1;
+           unsigned UartIdleIntrpt:1;
+
+}MT_UART_STATUS;
+
+
+typedef struct {
+           unsigned UartTxOutEnable:1;
+           unsigned UartRxParity:2;
+           unsigned UartTxParity:2;
+           unsigned UartTxStopBits:1;
+           unsigned UartRxStopBits:1;
+           unsigned UartTxLogic:1;
+           unsigned UartRxLogic:1;
+           unsigned UartLoopBack: 1;
+
+           unsigned char UartRxIdle;
+
+           unsigned UartTxWaterLevel:4;
+           unsigned UartRxWaterLevel:4;
+
+
+           MT_UART_STATUS Status;
+
+           unsigned long UartRate;
+
+           unsigned UartReset:1;
+           unsigned UartClockOnOff:1;
+           unsigned UartEnableHostIntrpt:1;
+
+           unsigned reserve1:5;
+
+           unsigned reserve2:8;        /* Align to word boundry */
+} MT_UART_CNFG;
+
+/*****************************************************************************
+*
+*   Module's Global Function Prototypes
+*
+*****************************************************************************/
+
+#undef MT_EXTERN
+#undef MT_I
+#endif /* __MT_UART_H__ */
+
diff --git a/arch/mips/lantiq/Kconfig b/arch/mips/lantiq/Kconfig
--- a/arch/mips/lantiq/Kconfig
+++ b/arch/mips/lantiq/Kconfig
@@ -68,6 +68,24 @@ config DT_EASY50712
 
 endchoice
 
+choice 
+	prompt "TOS_SIZE"
+	depends on SOC_GRX500_BOOTCORE
+	default TOS_SIZE_32M
+config TOS_SIZE_16M
+	bool "16M tos size"
+
+config TOS_SIZE_32M
+	bool "32M tos size"
+
+config TOS_SIZE_64M
+	bool "64M tos size"
+
+config TOS_SIZE_128M
+	bool "128M tos size"
+endchoice
+
+
 config PCI_LANTIQ_BOOT
 	bool "PCI Boot Support"
 	depends on SOC_XWAY && PCI && !PCI_LANTIQ
diff --git a/arch/mips/lantiq/grx500_bootcore/Makefile b/arch/mips/lantiq/grx500_bootcore/Makefile
new file mode 100755
--- /dev/null
+++ b/arch/mips/lantiq/grx500_bootcore/Makefile
@@ -0,0 +1,1 @@
+obj-y := prom.o clk.o irq.o sysctrl.o early_printk.o
diff --git a/arch/mips/lantiq/grx500_bootcore/clk.c b/arch/mips/lantiq/grx500_bootcore/clk.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/lantiq/grx500_bootcore/clk.c
@@ -0,0 +1,234 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ * Copyright (C) 2010 Thomas Langer <thomas.langer@lantiq.com>
+ * Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ */
+#include <linux/io.h>
+#include <linux/export.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <asm/time.h>
+#include <asm/div64.h>
+#include <asm/setup.h>
+#include <lantiq_soc.h>
+#include "clk.h"
+#include "prom.h"
+
+#ifdef CONFIG_USE_EMULATOR
+#ifdef CONFIG_USE_PALLADIUM
+#define EMULATOR_CPU_SPEED    218500
+#elif defined(CONFIG_USE_HAPS)
+#define EMULATOR_TEP_CPU_SPEED    6000000
+#endif /*CONFIG_USE_PALLADIUM*/
+#endif /*CONFIG_USE_EMULATOR*/
+
+static int mips_cpu_timer_irq;
+
+//extern void ltq_soc_init(void);
+
+int ltq_grx500_set_cpu_hz(unsigned long cpu_freq)
+{
+#ifdef CONFIG_LTQ_CPU_FREQ
+        return ltq_set_cpu_hz(CLK_AR10, avail_rates_xrx390,
+                                freq_transition_xrx300);
+
+#else
+        printk("[%s]:[%d] \n", __FUNCTION__, __LINE__);
+        return -1;
+#endif /* CONFIG_LTQ_CPU_FREQ */
+}
+
+unsigned long ltq_grx500_cpu_hz(void)
+{
+#ifdef CONFIG_USE_EMULATOR
+        return EMULATOR_TEP_CPU_SPEED;
+#else
+        unsigned int clksys = CLOCK_300M;
+
+        return clksys;
+#endif
+}
+
+struct clk *clk_get_cpu(void)
+{
+	return clk_get_sys("cpu", "cpu");
+}
+EXPORT_SYMBOL_GPL(clk_get_cpu);
+
+static inline int clk_good(struct clk *clk)
+{
+	return clk && !IS_ERR(clk);
+}
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	if (unlikely(!clk_good(clk)))
+		return 0;
+
+#ifndef CONFIG_CPU_FREQ
+	if (clk->rate != 0)
+		return clk->rate;
+#endif
+
+	if (clk->get_rate != NULL) {
+		clk->rate = clk->get_rate();
+		return clk->rate;
+	}
+#if 0
+	if (clk->parent) {
+		pr_info("derive real clock speed for %s from clock %s ",
+			clk->cl.dev_id,
+			cpu_clk_generic[clk->parent - 1].cl.dev_id);
+		pr_info("with scale data 0x%08X\n", clk->scale_data);
+		return cpu_clk_generic[clk->parent - 1].rate;
+	}
+#endif
+	return 0;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	int i = 0;
+
+	if (unlikely(!clk_good(clk)))
+		return 0;
+
+	if (clk->rates && *clk->rates) {
+		unsigned long *r = clk->rates;
+
+		while (*r && (*r != rate)) {
+			r++;
+			i++;
+		}
+		if (!*r) {
+			pr_err("clk %s.%s: trying to set invalid rate %ld\n",
+				clk->cl.dev_id, clk->cl.con_id, rate);
+			return -1;
+		}
+	}
+
+	if (clk->set_rate != NULL) {
+		if (clk->set_rate(rate) == 0) {
+			clk->rate = rate;
+			return 0;
+		}
+	}
+
+	pr_err("trying to set invalid clk %s.%s: rate %ld.\n",
+			clk->cl.dev_id, clk->cl.con_id, rate);
+	pr_err("clk_set_rate not supported for this clk.\n");
+	return -EINVAL;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+int clk_enable(struct clk *clk)
+{
+	if (unlikely(!clk_good(clk)))
+		return -1;
+
+	if (clk->enable)
+		return clk->enable(clk);
+
+	return -1;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+	if (unlikely(!clk_good(clk)))
+		return;
+
+	if (clk->disable)
+		clk->disable(clk);
+}
+EXPORT_SYMBOL(clk_disable);
+
+int clk_activate(struct clk *clk)
+{
+	if (unlikely(!clk_good(clk)))
+		return -1;
+
+	if (clk->activate)
+		return clk->activate(clk);
+
+	return -1;
+}
+EXPORT_SYMBOL(clk_activate);
+
+void clk_deactivate(struct clk *clk)
+{
+	if (unlikely(!clk_good(clk)))
+		return;
+
+	if (clk->deactivate)
+		clk->deactivate(clk);
+}
+EXPORT_SYMBOL(clk_deactivate);
+
+struct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec)
+{
+	return NULL;
+}
+
+static void mips_timer_dispatch(void)
+{
+        do_IRQ(mips_cpu_timer_irq);
+}
+
+unsigned int __cpuinit get_c0_compare_int(void)
+{
+	if (cpu_has_veic) {
+		set_vi_handler(31, mips_timer_dispatch);
+                mips_cpu_timer_irq = 31;
+	}
+
+        return mips_cpu_timer_irq;
+}
+
+static inline u32 get_counter_resolution(void)
+{
+	u32 res;
+
+	__asm__ __volatile__(
+		".set	push\n"
+		".set	mips32r2\n"
+		"rdhwr	%0, $3\n"
+		".set pop\n"
+		: "=&r" (res)
+		: /* no input */
+		: "memory");
+
+	return res;
+}
+
+void __init plat_time_init(void)
+{
+	struct clk *clk;
+
+	ltq_soc_init();
+
+	clk = clk_get_sys("cpu", "cpu");
+	if (clk == NULL) {
+		pr_err("CPU clock structure not found\n");
+		return;
+	}
+	mips_hpt_frequency = clk_get_rate(clk) / get_counter_resolution();
+	write_c0_compare(read_c0_count());
+#ifdef CONFIG_USE_EMULATOR
+//        mips_hpt_frequency = 16000000;
+	mips_hpt_frequency = 240000000;
+        pr_info("CPU Clock: %ldKHz\n", clk_get_rate(clk) / 1000);
+#else
+        pr_info("CPU Clock: %ldMHz\n", clk_get_rate(clk) / 1000000);
+#endif
+	clk_put(clk);
+}
diff --git a/arch/mips/lantiq/grx500_bootcore/clk.h b/arch/mips/lantiq/grx500_bootcore/clk.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/lantiq/grx500_bootcore/clk.h
@@ -0,0 +1,107 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ * Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ * Copyright (C) 2013 Lei Chuanhua <Chuanhua.lei@lantiq.com>
+ */
+
+#ifndef _LTQ_CLK_H__
+#define _LTQ_CLK_H__
+
+#include <linux/clkdev.h>
+
+/* clock speeds */
+#define CLOCK_33M	33333333
+#define CLOCK_60M	60000000
+#define CLOCK_62_5M	62500000
+#define CLOCK_83M	83333333
+#define CLOCK_83_5M	83500000
+#define CLOCK_98_304M	98304000
+#define CLOCK_100M	100000000
+#define CLOCK_111M	111111111
+#define CLOCK_125M	125000000
+#define CLOCK_133M	133333333
+#define CLOCK_150M	150000000
+#define CLOCK_166M	166666666
+#define CLOCK_167M	166666667
+#define CLOCK_180M	180000000
+#define CLOCK_196_608M	196608000
+#define CLOCK_200M	200000000
+#define CLOCK_222M	222000000
+#define CLOCK_240M	240000000
+#define CLOCK_250M	250000000
+#define CLOCK_266M	266666666
+#define CLOCK_288M	288888888
+#define CLOCK_300M	300000000
+#define CLOCK_333M	333333333
+#define CLOCK_360M	360000000
+#define CLOCK_393M	393215332
+#define CLOCK_400M	400000000
+#define CLOCK_432M	432000000
+#define CLOCK_450M	450000000
+#define CLOCK_500M	500000000
+#define CLOCK_600M	600000000
+#define CLOCK_666M	666666666
+#define CLOCK_720M	720000000
+
+/* clock out speeds */
+#define CLOCK_32_768K	32768
+#define CLOCK_1_536M	1536000
+#define CLOCK_2_5M	2500000
+#define CLOCK_12M	12000000
+#define CLOCK_24M	24000000
+#define CLOCK_25M	25000000
+#define CLOCK_30M	30000000
+#define CLOCK_40M	40000000
+#define CLOCK_48M	48000000
+#define CLOCK_50M	50000000
+#define CLOCK_60M	60000000
+
+enum {
+	STATIC_CPU_CLK = 1,
+	STATIC_FPI_CLK,
+	STATIC_IO_CLK,
+	STATIC_PPE_CLK,
+	STATIC_NO_PARENT = 0xff,
+};
+
+struct clk_rates {
+	unsigned int cpu_freq;
+	unsigned int ddr_freq;
+	unsigned int cgu_sys;
+};
+
+struct clk {
+	struct clk_lookup cl;
+	unsigned long rate;
+	unsigned long *rates;
+	unsigned int module;
+	unsigned int bits;
+	unsigned int parent;
+	unsigned int scale_data;
+	atomic_t refcount;
+	bool always_on; /* 0 -- always on or not used, 1 -- configurable */
+	unsigned long (*get_rate) (void);
+	int (*set_rate) (unsigned long cpu_freq);
+	int (*enable) (struct clk *clk);
+	void (*disable) (struct clk *clk);
+	int (*activate) (struct clk *clk);
+	void (*deactivate) (struct clk *clk);
+	void (*reboot) (struct clk *clk);
+};
+
+/*
+extern void clkdev_add_static(unsigned long cpu, unsigned long fpi,
+				unsigned long io, unsigned long ppe);
+*/
+extern unsigned long ltq_grx500_cpu_hz(void);
+extern int ltq_grx500_set_cpu_hz(unsigned long cpu_freq);
+
+extern unsigned long ltq_grx500_fpi_hz(void);
+extern int ltq_grx500_set_fpi_hz(unsigned long cpu_freq);
+
+unsigned long *ltq_get_avail_scaling_rates(int sel);
+
+#endif
diff --git a/arch/mips/lantiq/grx500_bootcore/early_printk.c b/arch/mips/lantiq/grx500_bootcore/early_printk.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/lantiq/grx500_bootcore/early_printk.c
@@ -0,0 +1,222 @@
+#include <linux/tty.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+#include <linux/serial.h>
+#include <asm/setup.h>
+#include <irq.h>
+#include <grx500_bootcore_chadr.h>
+#include <grx500_bootcore_time.h>
+#include <grx500_bootcore_uart.h>
+#include <grx500_bootcore_defs.h>
+
+#include <grx500_bootcore_cnfg.h>
+#include <grx500_bootcore_chipreg.h>
+#include <grx500_bootcore_interrupt.h>
+
+#ifdef CONFIG_SOC_GRX500_BOOTCORE
+
+/* base addr of uart and clock timing */
+#define         BASE                    MT_LOCAL_MIPS_BASE_ADDRESS
+#define         MAX_BAUD                115200
+
+/*
+ * 0 - we need to do serial init
+ * 1 - skip serial init
+ */
+
+static int serialPortInitialized = 0;
+
+struct early_lntq_device {
+	struct uart_port port;
+};
+
+static struct early_lntq_device early_device;
+
+/*
+ *  * the default baud rate *if* we do serial init
+ *   */
+#ifdef CONFIG_USE_EMULATOR
+#define         BAUD_DEFAULT            UART16550_BAUD_9600 //UART16550_BAUD_115200
+#else
+#define         BAUD_DEFAULT            UART16550_BAUD_115200
+#endif
+
+/* === END OF CONFIG === */
+
+static void __init early_lntq_write(struct console *console, const char *s, unsigned int count);
+
+/* we need uint32 uint8 */
+//typedef         unsigned char uint8;
+//typedef         unsigned int  uint32;
+
+#define         UART16550_BAUD_2400             2400
+#define         UART16550_BAUD_4800             4800
+#define         UART16550_BAUD_9600             9600
+#define         UART16550_BAUD_19200            19200
+#define         UART16550_BAUD_38400            38400
+#define         UART16550_BAUD_57600            57600
+#define         UART16550_BAUD_115200           115200
+
+#define         UART16550_PARITY_NONE           0
+#define         UART16550_PARITY_ODD            0x08
+#define         UART16550_PARITY_EVEN           0x18
+#define         UART16550_PARITY_MARK           0x28
+#define         UART16550_PARITY_SPACE          0x38
+
+#define         UART16550_TX_OUTPUT_ENABLE      0x0
+
+#define         UART16550_STOP_1BIT             0x0
+#define         UART16550_STOP_2BIT             0x4
+
+/* register offset */
+#define			REG_UART_INT						(0x1c)
+#define			REG_UART_WRITE_DATA					(0xc)
+#define			REG_UART_READ_DATA					(0x10)
+#define			REG_UART_BYTES_IN_FIFO				(0x2c)
+#define			REG_UART_RX_FIFO_BITS_MASK			(0x1f)
+#define			REG_UART_TX_FIFO_BITS_MASK			(0x3e0)
+#define			REG_UART_CONTROL					(0x20)
+#define			REG_UART_CLOCK_DIVISION_RATIO		(0x14)
+#define			REG_UART_RX_IDLE_COUNTER			(0x28)
+
+/* memory-mapped read/write of the port */
+#define         UART16550_READ(y)    (*((volatile uint32*)(BASE + y)))
+#define         UART16550_WRITE(y, z)  ((*((volatile uint32*)(BASE + y))) = ((uint32)z))
+
+/*uart mux to host*/
+#define REG_UART_CONTROL_MUX_MPU_BIT 0x100
+
+#undef GRX500_BOOTCORE_DEBUG_EARLY
+
+void Uart16550Init_early(uint32 baud, uint8 data, uint8 parity, uint8 stop)
+{
+    serialPortInitialized = 1;
+	/* disable interrupts */
+    UART16550_WRITE(REG_UART_INT, 0x00); 
+
+	/* set up baud rate */
+	{ 
+		uint32 divisor;
+
+		/* set divisor */
+#ifndef CONFIG_VBG400_CHIPIT //Orig
+//#ifdef CONFIG_VBG400_CHIPIT
+
+        divisor = ((GRX500_BOOTCORE_SYSTEM_CLK) / (UART_BAUD_RATIO_DIV*baud)) - 1;
+#else
+		divisor = ((GRX500_BOOTCORE_SYSTEM_CLK/10) / (UART_BAUD_RATIO_DIV*baud)) - 1;
+#endif
+		//UART16550_WRITE16(REG_UART_CLOCK_DIVISION_RATIO, divisor & 0x3fff);
+		UART16550_WRITE(REG_UART_CLOCK_DIVISION_RATIO, divisor & 0xff);
+ 	}
+
+	/* set data format */
+	UART16550_WRITE(REG_UART_CONTROL, data|parity|stop|REG_UART_CONTROL_MUX_MPU_BIT); 
+	UART16550_WRITE(REG_UART_RX_IDLE_COUNTER, 90); //10 time one byte duration
+}
+
+static void __init console_config(void)
+{
+	Uart16550Init_early(BAUD_DEFAULT,
+					UART16550_TX_OUTPUT_ENABLE,
+					UART16550_PARITY_NONE, UART16550_STOP_1BIT);
+#ifdef GRX500_BOOTCORE_DEBUG_EARLY
+	{
+	UART16550_WRITE(REG_UART_WRITE_DATA, 'e');
+	UART16550_WRITE(REG_UART_WRITE_DATA, 'a');
+	UART16550_WRITE(REG_UART_WRITE_DATA, 'r');
+	UART16550_WRITE(REG_UART_WRITE_DATA, 'l');
+	UART16550_WRITE(REG_UART_WRITE_DATA, 'y');
+	UART16550_WRITE(REG_UART_WRITE_DATA, '\n');
+    }
+#endif
+}
+
+void __init  Uart16550Put(struct uart_port *port, /*char*/int byte)
+{
+	int dummy_count=0xfffff;
+
+	if (!serialPortInitialized) {
+			serialPortInitialized = 1;
+			Uart16550Init_early(BAUD_DEFAULT,
+							UART16550_TX_OUTPUT_ENABLE,
+							UART16550_PARITY_NONE, UART16550_STOP_1BIT);
+	}
+
+	while(((UART16550_READ(REG_UART_BYTES_IN_FIFO) & REG_UART_TX_FIFO_BITS_MASK) != 0) && dummy_count)
+	{
+		dummy_count--;
+	}
+	UART16550_WRITE(REG_UART_WRITE_DATA, (char)byte);
+}
+
+#ifdef CONFIG_KGDB
+int grx500_bootcore_kgdb_hook(int speed) 
+{
+	Uart16550Init_early(speed, UART16550_TX_OUTPUT_ENABLE, UART16550_PARITY_NONE, UART16550_STOP_1BIT);
+	return speed;
+}
+
+int __init grx500_bootcore_putDebugChar(char byte)
+{
+	struct uart_port *port = &early_device.port;
+	Uart16550Put(port, (int) byte);
+	return 1; 
+}
+
+char grx500_bootcore_getDebugChar(void)
+{
+	char char_in;
+	if (!serialPortInitialized) {
+		serialPortInitialized = 1;
+		Uart16550Init_early(BAUD_DEFAULT, UART16550_TX_OUTPUT_ENABLE,
+				UART16550_PARITY_NONE, UART16550_STOP_1BIT);
+	}
+
+	while((!(UART16550_READ(REG_UART_BYTES_IN_FIFO) & REG_UART_RX_FIFO_BITS_MASK)))
+		; //till there is no data in RX_FIFO
+	char_in = (char) (UART16550_READ(REG_UART_READ_DATA) & UART_RD_DATA_MASK);
+	return char_in;
+}
+#endif
+
+static struct console early_lntq_console __initdata = {
+	.name	= "early",
+	.write	= early_lntq_write,
+	.flags	= CON_PRINTBUFFER | CON_BOOT | CON_ENABLED,
+	.index	= -1,
+};
+
+
+
+static void __init early_lntq_write(struct console *console,
+					const char *s, unsigned int count)
+{
+	struct uart_port *port = &early_device.port;
+
+	uart_console_write(port, s, count, Uart16550Put);
+}
+
+int __init setup_early_lntq_console(char *cmdline)
+{
+    MT_WrReg(0xb4900000,0x0,0x3f); //huanx
+    MT_WrReg(0xb4900004,0x0,0x3f); //huanx
+    MT_WrReg(0xb4900020,0x0,0x1); //huanx
+    MT_WrReg(0xb6080120,0x0,0x440800); //huanx
+    *(unsigned long*)(0xb6200008)=(*(unsigned long*)(0xb6200008)&0xffffff0f)|0x60; 
+
+    //config HW
+	console_config();
+	
+
+	register_console(&early_lntq_console);
+
+	return 0;
+}
+
+early_param("console", setup_early_lntq_console);
+
+#endif
+
diff --git a/arch/mips/lantiq/grx500_bootcore/irq.c b/arch/mips/lantiq/grx500_bootcore/irq.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/lantiq/grx500_bootcore/irq.c
@@ -0,0 +1,445 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ * Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ * Copyright (C) 2010 Thomas Langer <thomas.langer@lantiq.com>
+ */
+
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/slab.h>
+
+#include <asm/bootinfo.h>
+#include <asm/irq_cpu.h>
+
+#include <lantiq_soc.h>
+#include <irq.h>
+#include <grx500_bootcore_emerald_env_regs.h>
+#include <grx500_bootcore_cnfg.h>
+#include <grx500_bootcore_chadr.h>
+#include <grx500_bootcore_chipreg.h>
+#include <grx500_bootcore_interrupt.h>
+#include <grx500_bootcore_uart.h>
+
+#define GET_REG_IRQ_MASK MT_RdReg( MT_LOCAL_MIPS_BASE_ADDRESS, REG_IRQ_MASK)
+#define SET_REG_IRQ_MASK(irq_mask) MT_WrReg( MT_LOCAL_MIPS_BASE_ADDRESS, REG_IRQ_MASK, irq_mask )
+
+static uint32_t irq_mask_save = 0;
+
+/*inline*/ void grx500_bootcore_disable_irq_all(void)
+{
+        uint32_t irq_mask = 0x0;
+
+        irq_mask_save = MT_RdReg( MT_LOCAL_MIPS_BASE_ADDRESS, REG_IRQ_MASK);
+        MT_WrReg( MT_LOCAL_MIPS_BASE_ADDRESS, REG_IRQ_MASK, irq_mask );
+}
+
+/*inline*/ void grx500_bootcore_disable_irq(struct irq_data *d)
+{
+        uint32_t irq_mask = 0;
+
+        irq_mask = MT_RdReg( MT_LOCAL_MIPS_BASE_ADDRESS, REG_IRQ_MASK);
+
+        irq_mask &= ~(1 << (d->irq));
+
+        MT_WrReg( MT_LOCAL_MIPS_BASE_ADDRESS, REG_IRQ_MASK, irq_mask );
+
+}
+
+inline void grx500_bootcore_ack_irq(unsigned int irq_nr)
+{
+    /* ack the relevant interrupt */
+    switch(irq_nr) {
+#if 1
+        case 4:
+        case 3:
+        case 2:
+#endif
+        case 1:
+        /* UART will reset the interrupt in the handler */
+                break;
+        default:
+        while(1);
+        BUG();
+                break;
+        }
+}
+
+#if 0
+/*inline*/ void grx500_bootcore_enable_irq_all(void)
+{
+        uint32_t irq_mask = 0;
+
+        irq_mask = (1<<GRX500_BOOTCORE_SERIAL_IRQ_OUT_INDEX) |
+                    (1<<GRX500_BOOTCORE_TIMER_IRQ_OUT_INDEX) |
+                    (1<<GRX500_BOOTCORE_SYNOP_ETHER_IRQ_OUT_INDEX) |
+                    (1<<GRX500_BOOTCORE_SYNOP_ETHER_IRQ_GMAC2_OUT_INDEX) |
+                    (1<<GRX500_BOOTCORE_WIRELESS_IRQ_OUT_INDEX);
+    
+
+        SET_REG_IRQ_MASK(irq_mask/*irq_mask_save*/);
+        //MT_WrReg( MT_LOCAL_MIPS_BASE_ADDRESS, REG_IRQ_MASK, irq_mask );
+}
+#endif
+
+/*inline*/ void grx500_bootcore_enable_irq(struct irq_data *d)
+{
+        uint32_t irq_mask = 0;
+
+        //irq_mask = MT_RdReg( MT_LOCAL_MIPS_BASE_ADDRESS, REG_IRQ_MASK);
+        irq_mask = GET_REG_IRQ_MASK;
+
+    irq_mask |= (1 << (d->irq));
+
+        SET_REG_IRQ_MASK(irq_mask);
+        //MT_WrReg( MT_LOCAL_MIPS_BASE_ADDRESS, REG_IRQ_MASK, irq_mask );
+}
+#if 1
+#define set_status(x)   __asm__ volatile("mtc0 %0,$12" :: "r" (x))
+
+/*inline*/ void grx500_bootcore_enable_irq_all_mips(unsigned long val)
+{
+        set_status(val);
+/*      __asm__(
+        "       li      $10,0xe0000001          \n"
+        "       mtc0    $10,$12                         \n"
+        );
+*/
+}
+#endif
+
+
+#if 1 //HUANX 
+/*static */irqreturn_t uart_interrupt(int irq, void *dev_id)
+{
+        uint32_t UartStatus;
+#ifdef GRX500_BOOTCORE_DEBUG_UART
+    uint32_t temp1,temp2;
+
+    temp1 = MT_RdReg(MT_LOCAL_MIPS_BASE_ADDRESS, REG_UNMAPPED_IRQS_TO_MAPPER);
+    temp2 = MT_RdReg(MT_LOCAL_MIPS_BASE_ADDRESS, REG_MAPPED_IRQS_FROM_MAPPER);
+#endif
+
+        UartStatus = MT_RdReg(MT_LOCAL_MIPS_BASE_ADDRESS, REG_UART_INT);
+    //UartStatus |=0x7f00;
+    
+    //printk("enter: UNMAPPED_IRQS_TO_MAPPER = %x, MAPPED_IRQS_FROM_MAPPER = %x, stat b=%x ", temp1, temp2, UartStatus);
+
+        // clear interrupt
+        MT_WrReg(MT_LOCAL_MIPS_BASE_ADDRESS, REG_UART_INT, UartStatus);
+#ifdef GRX500_BOOTCORE_DEBUG_UART
+    temp1 = MT_RdReg(MT_LOCAL_MIPS_BASE_ADDRESS, REG_UNMAPPED_IRQS_TO_MAPPER);
+    temp2 = MT_RdReg(MT_LOCAL_MIPS_BASE_ADDRESS, REG_MAPPED_IRQS_FROM_MAPPER);
+
+        UartStatus = MT_RdReg(MT_LOCAL_MIPS_BASE_ADDRESS, REG_UART_INT);
+    printk("exit: UNMAPPED_IRQS_TO_MAPPER = %x, MAPPED_IRQS_FROM_MAPPER = %x, stat b=%x ", temp1, temp2, UartStatus);
+#endif
+        // TX Part
+        if (UartStatus && REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ_MASK)
+            grx500_bootcore_uart_tx_isr(dev_id); /*needed???*/
+
+        // RX Part
+        if ((UartStatus && REG_UART_READ_FIFO_WATER_LEVEL_IRQ_MASK) ||
+            (UartStatus && REG_UART_IDLE_IRQ_MASK))
+        grx500_bootcore_uart_rx_isr(dev_id);
+         
+    return IRQ_HANDLED;
+}
+#endif //HUANX
+
+static struct irq_chip external_irq_type = {
+        .name     = "Lantiq GRX500_BOOTCORE Ext IRQ Controller",
+        .irq_mask_ack = grx500_bootcore_disable_irq,
+        .irq_mask     = grx500_bootcore_disable_irq,
+        .irq_unmask   = grx500_bootcore_enable_irq,
+};
+
+#if 0 
+static struct irqaction uart_irqaction = {
+        .handler        = uart_interrupt,
+        .flags          = IRQF_DISABLED, /* for disable nested interrupts */ 
+        /* Lior.H - when we need to use-> IRQF_NOBALANCING ? */
+        .name           = "grx500_bootcore_uart",
+};
+#endif
+
+asmlinkage void plat_irq_dispatch(void)
+{
+        while(1);
+}
+
+static inline int clz(unsigned long x)
+{
+        __asm__(
+        "       .set    push                                    \n"
+        "       .set    mips32                                  \n"
+        "       clz     %0, %1                                  \n"
+        "       .set    pop                                     \n"
+        : "=r" (x)
+        : "r" (x));
+
+        return x;
+}
+
+int __init icu_of_init(struct device_node *node, struct device_node *parent)
+{
+
+	mips_cpu_irq_init();
+
+	grx500_bootcore_init_irq();
+
+	return 0;
+}
+
+void MT_WrReg(MT_UINT32 unit, MT_UINT32 reg, MT_UINT32 data )
+{
+        NONE_TRUNK_REG(unit, reg)=data;
+}
+
+MT_UINT32 MT_RdReg(MT_UINT32 unit, MT_UINT32 reg)
+{
+        MT_UINT32 data;
+        data = NONE_TRUNK_REG(unit, reg);
+        return(data);
+}
+
+void MT_WrRegMask(MT_UINT32 unit, MT_UINT32 reg, MT_UINT32 mask,MT_UINT32 data )
+{
+                MT_UINT32 readVal,setData;      
+
+                readVal=MT_RdReg(unit,reg);
+                setData= (readVal & (~mask))|data;
+                MT_WrReg(unit,reg, setData );
+}
+
+void EXCEP_remap_line( MT_UINT32 int_line, MT_UINT32 map_address, MT_UINT32 num)
+{
+        MT_UINT32 org_map, result_map, t1 = 0, t2 = 0;
+
+
+    printk("EXCEP_remap_line: int_line = 0x%08lx, map_address = 0x%08lx, num = 0x%08lx \n",int_line,map_address, num);
+        org_map = MT_RdReg( MT_LOCAL_MIPS_BASE_ADDRESS, map_address );
+        t1 = ~(0x1f << (num * 5));
+        t2 = int_line << (num * 5);
+        result_map = org_map & t1;
+        result_map |= t2;
+    printk("EXCEP_remap_line: org_map = 0x%08lx, result_map = 0x%08lx \n",org_map,result_map);
+        MT_WrReg( MT_LOCAL_MIPS_BASE_ADDRESS, map_address, result_map );
+#if 0
+{
+        int i=0;
+    for(i=REG_IRQ_SOURCE_01_MAPPING ; i <= REG_IRQ_SOURCE_31_MAPPING ; i+=4)
+    {
+        printk("EXCEP_remap_line: map[%d] = 0x%08lx \n",i,MT_RdReg(MT_LOCAL_MIPS_BASE_ADDRESS, i));
+    }
+}
+#endif
+}
+
+/*static */void grx500_bootcore_uart_irq(void)
+{
+        do_IRQ(GRX500_BOOTCORE_SERIAL_IRQ_OUT_INDEX/*0x1*/);
+}
+
+/*static */void grx500_bootcore_net_irq(void)
+{
+        do_IRQ(GRX500_BOOTCORE_SYNOP_ETHER_IRQ_OUT_INDEX/*0x3*/);
+}
+EXPORT_SYMBOL(grx500_bootcore_net_irq);
+
+/*static */void grx500_bootcore_net_g2_irq(void)
+{
+        do_IRQ(GRX500_BOOTCORE_SYNOP_ETHER_IRQ_GMAC2_OUT_INDEX/*0x4*/);
+}
+EXPORT_SYMBOL(grx500_bootcore_net_g2_irq);
+
+void grx500_bootcore_wls_irq(void)
+{
+        do_IRQ(GRX500_BOOTCORE_WIRELESS_IRQ_OUT_INDEX);
+}
+
+EXPORT_SYMBOL(grx500_bootcore_wls_irq);
+
+/*static */void grx500_bootcore_gptc2_timer2_irq(void)
+{
+        do_IRQ(GRX500_BOOTCORE_GPTC2_TIMER2_OUT_INDEX);
+}
+
+/*static */void grx500_bootcore_gptc2_timer1_irq(void)
+{
+        do_IRQ(GRX500_BOOTCORE_GPTC2_TIMER1_OUT_INDEX);
+}
+
+void grx500_bootcore_mps_irq(void)
+{
+			do_IRQ(GRX500_BOOTCORE_MPS2_OUT_INDEX);
+} 
+#if 1
+void grx500_bootcore_register_static_irq_dummy(unsigned int irq_in, unsigned int irq_out)
+{
+  uint32_t mapper_reg;
+  uint32_t mapper_offset;
+
+  mapper_reg = REG_IRQ_SOURCE_01_MAPPING + (((irq_in - 1) / 6) * 4);
+  mapper_offset = ((irq_in - 1) % 6);
+  printk("grx500_bootcore_register_static_irq: irq_in = 0x%08x, irq_out = 0x%08x\n",irq_in,irq_out);
+  printk("grx500_bootcore_register_static_irq: mapper_reg = 0x%08lx, mapper_offset = 0x%08lx\n",(long unsigned int)mapper_reg,(long unsigned int)mapper_offset);
+  EXCEP_remap_line( irq_out, mapper_reg, mapper_offset);
+}
+#endif
+
+void grx500_bootcore_init_irq(void)
+{
+        uint32_t irq;
+        /*
+        31 - SI_TimerInt
+        30 - SI_SWInt[1]
+        29 - SI_SWInt[0]
+        28 - timer0_irq
+        27 - timer1_irq
+        26 - timer2_irq
+        25 - timer3_irq
+        24 - N/A
+        23 - N/A
+        ...
+        05 - N/A 
+        04 - N/A
+        03 - N/A
+        02 - UART
+        01 - ETH
+        00 - N/A - (Never used)
+        */
+
+        /* Remap all interrupts to an unused line - then open only those that are used */
+#if 1
+    for(irq=REG_IRQ_SOURCE_01_MAPPING ; irq <= REG_IRQ_SOURCE_31_MAPPING ; irq+=4)
+        {
+        MT_WrReg(MT_LOCAL_MIPS_BASE_ADDRESS, irq, 0 );
+        }
+
+        for (irq = 1; irq <= 31; irq++) {
+//                set_irq_chip_and_handler(irq, &external_irq_type,
+//                                         handle_level_irq);
+		irq_set_chip_and_handler(irq, &external_irq_type,
+						handle_level_irq);
+//huanx fix                grx500_bootcore_disable_irq(irq);
+#else
+        for (irq = 1; irq <= 31; irq++) {
+                if ((irq!= GRX500_BOOTCORE_SYNOP_ETHER_IRQ_IN_INDEX) |
+                        (irq!= GRX500_BOOTCORE_SERIAL_IRQ_IN_INDEX) |
+                            (irq!= GRX500_BOOTCORE_SYNOP_ETHER_IRQ_GMAC2_IN_INDEX) |
+                                (irq!= GRX500_BOOTCORE_WIRELESS_IRQ_IN_INDEX) |
+                                    (irq!= GRX500_BOOTCORE_TIMER_IRQ_IN_INDEX))
+        {
+                grx500_bootcore_register_static_irq_dummy(irq,0);
+
+                    set_irq_chip_and_handler(irq, &external_irq_type,
+                                             handle_level_irq);
+
+                    grx500_bootcore_disable_irq(irq);
+        }
+#endif
+        }
+
+#if 0
+    grx500_bootcore_register_irq(2 /* in */,1 /* out */,&uart_irqaction, grx500_bootcore_uart_irq); 
+#endif
+
+//grx500_bootcore_enable_irq_all_mips(/*0xe0000001*/0x00000001);
+
+        grx500_bootcore_register_static_irq_dummy(31, 31);//(31,2);
+//	grx500_bootcore_enable_irq(31);
+}
+
+int grx500_bootcore_register_static_irq(unsigned int irq_in, unsigned int irq_out,
+                             struct irqaction *action, vi_handler_t addr)
+{
+  uint32_t mapper_reg;
+  uint32_t mapper_offset;
+  int res;
+
+  mapper_reg = REG_IRQ_SOURCE_01_MAPPING + (((irq_in - 1) / 6) * 4);
+  mapper_offset = ((irq_in - 1) % 6);
+  printk("grx500_bootcore_register_static_irq: irq_in = 0x%08x, irq_out = 0x%08x\n",irq_in,irq_out);
+  printk("grx500_bootcore_register_static_irq: mapper_reg = 0x%08lx, mapper_offset = 0x%08lx\n",(long unsigned int)mapper_reg,(long unsigned int)mapper_offset);
+  EXCEP_remap_line( irq_out, mapper_reg, mapper_offset);
+
+  set_vi_handler(irq_out, addr);
+
+  res = setup_irq(irq_out, action);
+  if(0 != res) {
+         printk(KERN_INFO "grx500_bootcore_irq: setup_irq() failed!!! **********\n");
+    return res;
+  }
+#if 0
+  grx500_bootcore_enable_irq(irq_out);
+#endif
+  return 0;
+}
+
+EXPORT_SYMBOL(grx500_bootcore_register_static_irq);
+EXPORT_SYMBOL(grx500_bootcore_enable_irq);
+EXPORT_SYMBOL(grx500_bootcore_disable_irq);
+
+int grx500_bootcore_register_irq(unsigned int irq_in, unsigned int irq_out,
+                       irq_handler_t handler, unsigned long flags,
+                       const char *name, void *dev_id,
+                       vi_handler_t addr)
+{
+    struct irqaction *action;
+    int res;
+
+    action = kzalloc(sizeof(struct irqaction), GFP_KERNEL);
+    if (!action)
+      return -ENOMEM;
+
+    action->handler = handler;
+    action->flags = flags;
+    action->name = name;
+    action->dev_id = dev_id;
+
+    res = grx500_bootcore_register_static_irq(irq_in, irq_out, action, addr);
+
+    if(0 != res)
+      kfree(action);
+
+    return res;
+}
+
+EXPORT_SYMBOL(grx500_bootcore_register_irq);
+
+void grx500_bootcore_unregister_irq(unsigned int irq_in, unsigned int irq_out, void* dev_id)
+{
+    uint32_t mapper_reg;
+    uint32_t mapper_offset;
+
+//fix huanx    grx500_bootcore_disable_irq(irq_out);
+
+    mapper_reg = REG_IRQ_SOURCE_01_MAPPING + (((irq_in - 1) / 6) * 4);
+    mapper_offset = ((irq_in - 1) % 6);
+    EXCEP_remap_line(0, mapper_reg, mapper_offset);
+
+    set_vi_handler(irq_out, NULL);
+    free_irq(irq_out, dev_id);
+}
+
+EXPORT_SYMBOL(grx500_bootcore_unregister_irq);
+
+static struct of_device_id __initdata of_irq_ids[] = {
+	{ .compatible = "lantiq,icu", .data = icu_of_init },
+	{},
+};
+
+void __init arch_init_irq(void)
+{
+	of_irq_init(of_irq_ids);
+	grx500_bootcore_init_irq();	
+}
diff --git a/arch/mips/lantiq/grx500_bootcore/prom.c b/arch/mips/lantiq/grx500_bootcore/prom.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/lantiq/grx500_bootcore/prom.c
@@ -0,0 +1,181 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ * Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ */
+
+#include <linux/export.h>
+#include <linux/clk.h>
+#include <linux/bootmem.h>
+#include <linux/of_platform.h>
+#include <linux/of_fdt.h>
+
+#include <asm/bootinfo.h>
+#include <asm/time.h>
+
+#include <lantiq.h>
+#include <lantiq_soc.h>
+
+#include "prom.h"
+#include "clk.h"
+
+
+#define SOC_GRX500      "GRX500"
+#define COMP_GRX500     "lantiq,grx500"
+
+#ifdef CONFIG_USE_EMULATOR
+#define SOC_ID_PD 0
+#endif
+
+#define PART_SHIFT      12
+#define PART_MASK       0x0FFFFFFF
+#define REV_SHIFT       28
+#define REV_MASK        0x70000000
+
+/* access to the ebu needs to be locked between different drivers */
+DEFINE_SPINLOCK(ebu_lock);
+EXPORT_SYMBOL_GPL(ebu_lock);
+
+/*
+ * this struct is filled by the soc specific detection code and holds
+ * information about the specific soc type, revision and name
+ */
+static struct ltq_soc_info soc_info;
+
+const char *get_system_type(void)
+{
+	return soc_info.sys_type;
+}
+
+void prom_free_prom_memory(void)
+{
+}
+
+#ifndef CONFIG_USE_EMULATOR
+static void __init prom_init_cmdline(void)
+{
+#if 0
+	int argc = fw_arg0;
+	char **argv = (char **) KSEG1ADDR(fw_arg1);
+	int i;
+
+	arcs_cmdline[0] = '\0';
+
+	for (i = 0; i < argc; i++) {
+		char *p = (char *) KSEG1ADDR(argv[i]);
+
+		if (CPHYSADDR(p) && *p) {
+			strlcat(arcs_cmdline, p, sizeof(arcs_cmdline));
+			strlcat(arcs_cmdline, " ", sizeof(arcs_cmdline));
+		}
+	}
+#else
+	arcs_cmdline[0] = '\0';
+	strlcat(arcs_cmdline,"console=ttyLTQ0,115200n8r root=/dev/ram rw loglevel=8 ",sizeof(arcs_cmdline));
+	#if defined(CONFIG_TOS_SIZE_16M)
+		strlcat(arcs_cmdline,"mem=16M@128M ",sizeof(arcs_cmdline));
+	#elif defined(CONFIG_TOS_SIZE_64M)
+		strlcat(arcs_cmdline,"mem=64M@128M ",sizeof(arcs_cmdline));
+	#elif defined(CONFIG_TOS_SIZE_128M)
+		strlcat(arcs_cmdline,"mem=128M@128M ",sizeof(arcs_cmdline));
+	#else/*default is 32M*/
+		strlcat(arcs_cmdline,"mem=32M@128M ",sizeof(arcs_cmdline));
+	#endif
+#endif
+}
+#endif
+
+void __init plat_mem_setup(void)
+{
+	ioport_resource.start = IOPORT_RESOURCE_START;
+	ioport_resource.end = IOPORT_RESOURCE_END;
+	iomem_resource.start = IOMEM_RESOURCE_START;
+	iomem_resource.end = IOMEM_RESOURCE_END;
+
+	set_io_port_base((unsigned long) KSEG1);
+
+	/*
+	 * Load the builtin devicetree. This causes the chosen node to be
+	 * parsed resulting in our memory appearing
+	 */
+	__dt_setup_arch(&__image_dtb);
+}
+
+void __init device_tree_init(void)
+{
+	unsigned long base, size;
+
+	if (!initial_boot_params)
+		return;
+
+	base = virt_to_phys((void *)initial_boot_params);
+	size = be32_to_cpu(initial_boot_params->totalsize);
+
+	/* Before we do anything, lets reserve the dt blob */
+	reserve_bootmem(base, size, BOOTMEM_DEFAULT);
+
+	unflatten_device_tree();
+}
+
+void __init prom_init(void)
+{
+	/* call the soc specific detetcion code and get it to fill soc_info */
+	ltq_soc_detect(&soc_info);
+	snprintf(soc_info.sys_type, LTQ_SYS_TYPE_LEN - 1, "%s rev %s",
+		soc_info.name, soc_info.rev_type);
+	soc_info.sys_type[LTQ_SYS_TYPE_LEN - 1] = '\0';
+	pr_info("SoC: %s\n", soc_info.sys_type);
+#ifndef CONFIG_USE_EMULATOR
+	prom_init_cmdline();
+#endif
+}
+
+void __init ltq_soc_detect(struct ltq_soc_info *i)
+{
+#ifdef CONFIG_USE_EMULATOR
+        i->partnum = SOC_ID_PD;
+        i->rev = SOC_ID_PD;
+#else
+        i->partnum = (ltq_r32(LTQ_MPS_CHIPID) & PART_MASK) >> PART_SHIFT;
+        i->rev = (ltq_r32(LTQ_MPS_CHIPID) & REV_MASK) >> REV_SHIFT;
+#endif
+        sprintf(i->rev_type, "1.%d", i->rev);
+        switch (i->partnum) {
+        case SOC_ID_GRX562:
+        case SOC_ID_GRX582:
+        case SOC_ID_GRX583:
+        case SOC_ID_GRX580:
+                i->name = SOC_GRX500;
+                i->type = SOC_TYPE_GRX500;
+                i->compatible = COMP_GRX500;
+                break;
+#ifdef CONFIG_USE_EMULATOR
+        case SOC_ID_PD:
+                i->name = SOC_GRX500;
+                i->type = SOC_TYPE_GRX500;
+                i->compatible = COMP_GRX500;
+                break;
+#endif
+        default:
+                unreachable();
+                break;
+        }
+}
+
+int __init plat_of_setup(void)
+{
+	static struct of_device_id of_ids[3];
+
+	if (!of_have_populated_dt())
+		panic("device tree not present");
+
+	strncpy(of_ids[0].compatible, soc_info.compatible,
+		sizeof(of_ids[0].compatible));
+	strncpy(of_ids[1].compatible, "simple-bus",
+		sizeof(of_ids[1].compatible));
+	return of_platform_populate(NULL, of_ids, NULL, NULL);
+}
+
+arch_initcall(plat_of_setup);
diff --git a/arch/mips/lantiq/grx500_bootcore/prom.h b/arch/mips/lantiq/grx500_bootcore/prom.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/lantiq/grx500_bootcore/prom.h
@@ -0,0 +1,31 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ * Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ */
+
+#ifndef _LTQ_PROM_H__
+#define _LTQ_PROM_H__
+
+#define LTQ_SYS_TYPE_LEN	0x100
+#define LTQ_SYS_REV_LEN		0x10
+
+struct ltq_soc_info {
+	unsigned char *name;
+	unsigned int rev;
+	unsigned char rev_type[LTQ_SYS_REV_LEN];
+	unsigned int srev;
+	unsigned int partnum;
+	unsigned int type;
+	unsigned char sys_type[LTQ_SYS_TYPE_LEN];
+	unsigned char *compatible;
+};
+
+extern void ltq_soc_detect(struct ltq_soc_info *i);
+extern void ltq_soc_init(void);
+
+extern struct boot_param_header __image_dtb;
+
+#endif
diff --git a/arch/mips/lantiq/grx500_bootcore/sysctrl.c b/arch/mips/lantiq/grx500_bootcore/sysctrl.c
new file mode 100755
--- /dev/null
+++ b/arch/mips/lantiq/grx500_bootcore/sysctrl.c
@@ -0,0 +1,253 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2011-2012 John Crispin <blogic@openwrt.org>
+ *  Copyright (C) 2014 Lei Chuanhua <Chuanhua.lei@lantiq.com>
+ */
+#include <linux/ioport.h>
+#include <linux/export.h>
+#include <linux/clkdev.h>
+#include <linux/spinlock.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+
+#include <lantiq_soc.h>
+
+#include "clk.h"
+#include "prom.h"
+
+
+/* First register set */
+#define PMU_CLK_SR1	0x120 /* status */
+#define PMU_CLK_CR1_A	0x124 /* Enable */
+#define PMU_CLK_CR1_B	0x128 /* Disable */
+/* Second register set */
+#define PMU_CLK_SR2	0x130 /* status */
+#define PMU_CLK_CR2_A	0x134 /* Enable */
+#define PMU_CLK_CR2_B	0x138 /* Disable */
+
+/* clock gates that we can en/disable */
+/* Register 0 /module 0 */
+#define PMU_VCODEC	BIT(2)
+#define PMU_DMA		BIT(5)
+#define PMU_USB0	BIT(6)
+#define PMU_SPI1	BIT(7)
+#define PMU_SPI0	BIT(8)
+#define PMU_CBM		BIT(9)
+#define PMU_EBU		BIT(10)
+#define PMU_LEDC	BIT(11)
+#define PMU_GPTC0	BIT(12)
+#define PMU_GPTC1	BIT(13)
+#define PMU_GPTC2	BIT(14)
+#define PMU_ASC0	BIT(17) /* ASC1 enabled by default */
+#define PMU_EIP97	BIT(20)
+#define PMU_EIP123	BIT(21)
+#define PMU_TOE		BIT(22)
+#define PMU_MPE		BIT(23)
+#define PMU_TDM		BIT(25)
+#define PMU_SWITCH_R	BIT(26)
+#define PMU_USB1	BIT(27)
+#define PMU_SWITCH_L	BIT(28)
+
+#define PMU_MODULE0_ALL	0x1EF27FE4
+
+/* Register 1 /module 1*/
+#define PMU_PCIE_CTRL0	BIT(1)
+#define PMU_PCIE_CTRL1	BIT(17)
+#define PMU_PCIE_CTRL2	BIT(25)
+
+#define PMU_MODULE1_ALL	0x02020002
+
+#define PMU_REG_MODULE_0	0
+#define PMU_REG_MODULE_1	1
+
+#define pmu_w32(x, y)	ltq_w32((x), pmu_membase + (y))
+#define pmu_r32(x)	ltq_r32(pmu_membase + (x))
+
+static void __iomem *pmu_membase;
+void __iomem *ltq_ebu_membase;
+#if 0
+/* Status */
+static u32 pmu_clk_sr[] = {
+	PMU_CLK_SR1,
+	PMU_CLK_SR2,
+};
+
+/* Enable */
+static u32 pmu_clk_cr_a[] = {
+	PMU_CLK_CR1_A,
+	PMU_CLK_CR2_A,
+};
+
+/* Disable */
+static u32 pmu_clk_cr_b[] = {
+	PMU_CLK_CR1_B,
+	PMU_CLK_CR2_B,
+};
+
+/* power control register */
+#define PWDCR_EN_XRX(x)  (pmu_clk_cr_a[(x)])
+#define PWDCR_DIS_XRX(x)  (pmu_clk_cr_b[(x)])
+/* power status register */
+#define PWDSR_XRX(x)  (pmu_clk_sr[(x)])
+
+/* enable a clock gate */
+static int pmu_enable(struct clk *clk)
+{
+	int retry = 1000000;
+
+	if (!clk->always_on) {
+		pr_debug("%s module %d position 0x%08x always on\n",
+			__func__, clk->module, clk->bits);
+		return 0;
+	}
+
+	if (atomic_read(&clk->refcount) == 0) {
+		pmu_w32(clk->bits, PWDCR_EN_XRX(clk->module));
+		do {} while (--retry
+			&& (!(pmu_r32(PWDSR_XRX(clk->module)) & clk->bits)));
+		
+		if (!retry)
+			panic("Activating PMU module failed!\n");
+		pr_debug("%s module %d position 0x%08x enabled\n",
+			__func__, clk->module, clk->bits);
+
+	} else {
+		pr_debug("%s module %d position 0x%08x already enabled\n",
+			__func__, clk->module, clk->bits);
+	}
+	atomic_inc(&clk->refcount);
+	return 0;
+}
+
+/* disable a clock gate */
+static void pmu_disable(struct clk *clk)
+{
+	int retry = 1000000;
+
+	if (!clk->always_on) {
+		pr_debug("%s module %d position 0x%08x always on\n",
+			__func__, clk->module, clk->bits);
+		return;
+	}
+
+	/* Consider disabling the module when powering on the system */
+	if (atomic_read(&clk->refcount) > 0)
+		atomic_dec(&clk->refcount);
+
+	if (atomic_read(&clk->refcount) == 0) {
+		pmu_w32(clk->bits, PWDCR_DIS_XRX(clk->module));
+		do {} while (--retry
+			&& (pmu_r32(PWDSR_XRX(clk->module)) & clk->bits));
+
+		if (!retry)
+			panic("activating PMU module failed!\n");
+		pr_debug("%s module %d position 0x%08x disabled\n",
+			__func__, clk->module, clk->bits);
+	} else {
+		pr_debug("%s module %d position 0x%08x still used\n",
+			__func__, clk->module, clk->bits);
+	}
+}
+
+
+/* manage the clock gates via PMU */
+static void clkdev_add_pmu(const char *dev, const char *con,
+		bool used, unsigned int module, unsigned int bits)
+{
+	struct clk *clk = kzalloc(sizeof(struct clk), GFP_KERNEL);
+
+	clk->cl.dev_id = dev;
+	clk->cl.con_id = con;
+	clk->cl.clk = clk;
+	clk->always_on = used;
+	clk->enable = pmu_enable;
+	clk->disable = pmu_disable;
+	clk->module = module;
+	clk->bits = bits;
+	atomic_set(&clk->refcount, 0);
+	/* Disable it during the initialitin. Module should enable when used */
+	pmu_disable(clk);
+	clkdev_add(&clk->cl);
+}
+#endif
+/* bring up all register ranges that we need for basic system control */
+void __init ltq_soc_init(void)
+{
+	struct resource res_pmu, res_ebu;
+	struct device_node *np_pmu =
+		of_find_compatible_node(NULL, NULL, "lantiq,pmu-grx500");
+	struct device_node *np_ebu =
+		of_find_compatible_node(NULL, NULL, "lantiq,ebu-grx500");
+	struct clk *clk = NULL;
+
+	/* check if all the core register ranges are available */
+	if (!np_pmu || !np_ebu)
+		panic("Failed to load core nodes from devicetree");
+
+	if (of_address_to_resource(np_pmu, 0, &res_pmu) ||
+		of_address_to_resource(np_ebu, 0, &res_ebu))
+		panic("Failed to get core resources");
+
+	if ((request_mem_region(res_pmu.start, resource_size(&res_pmu),
+		res_pmu.name) < 0) ||
+		(request_mem_region(res_ebu.start, resource_size(&res_ebu),
+				res_ebu.name) < 0))
+		pr_err("Failed to request core reources");
+	pmu_membase = ioremap_nocache(res_pmu.start, resource_size(&res_pmu));
+	ltq_ebu_membase = ioremap_nocache(res_ebu.start,
+		resource_size(&res_ebu));
+	if (!pmu_membase || !ltq_ebu_membase)
+		panic("Failed to remap core resources");
+
+	ltq_ebu_w32(ltq_ebu_r32(LTQ_EBU_BUSCON0) & ~EBU_WRDIS,
+			LTQ_EBU_BUSCON0);
+
+		clk = kzalloc(sizeof(struct clk), GFP_KERNEL);
+		if (clk) {
+			clk->cl.dev_id = "cpu";
+			clk->cl.con_id = "cpu";
+			clk->cl.clk = clk;
+			clk->rate = ltq_grx500_cpu_hz();
+			clk->set_rate = ltq_grx500_set_cpu_hz;
+			clk->get_rate = ltq_grx500_cpu_hz;
+			clkdev_add(&clk->cl);
+		}
+#if 0
+	/* add our generic grx500 clocks */
+	clkdev_add_pmu(NULL, "vcodec", 1, PMU_REG_MODULE_0, PMU_VCODEC);
+	clkdev_add_pmu("16e00000.dma", NULL, 1, PMU_REG_MODULE_0, PMU_DMA);
+	clkdev_add_pmu("1a300000.usb", NULL, 1, PMU_REG_MODULE_0, PMU_USB0);
+	clkdev_add_pmu("16900000.spi", NULL, 1, PMU_REG_MODULE_0, PMU_SPI1);
+	clkdev_add_pmu("16800000.spi", NULL, 1, PMU_REG_MODULE_0, PMU_SPI0);
+	clkdev_add_pmu("1e500000.cbm", NULL, 1, PMU_REG_MODULE_0, PMU_CBM);
+	clkdev_add_pmu("16f00000.ebu", NULL, 0, PMU_REG_MODULE_0, PMU_EBU);
+
+	clkdev_add_pmu("16d00000.stp", NULL, 1, PMU_REG_MODULE_0, PMU_LEDC);
+	clkdev_add_pmu("16b00000.gptu", NULL, 1, PMU_REG_MODULE_0, PMU_GPTC0);
+	clkdev_add_pmu("16300000.gptu", NULL, 1, PMU_REG_MODULE_0, PMU_GPTC1);
+	clkdev_add_pmu("16400000.gptu", NULL, 1, PMU_REG_MODULE_0, PMU_GPTC2);
+	clkdev_add_pmu("16700000.serial", NULL, 1, PMU_REG_MODULE_0, PMU_ASC0);
+	clkdev_add_pmu("1e100000.eip97", NULL, 1, PMU_REG_MODULE_0, PMU_EIP97);
+	clkdev_add_pmu("1e000000.eip123", NULL, 1, PMU_REG_MODULE_0,
+		PMU_EIP123);
+	clkdev_add_pmu("a2000000.toe", NULL, 1, PMU_REG_MODULE_0, PMU_TOE);
+	clkdev_add_pmu("a0000000.mpe", NULL, 1, PMU_REG_MODULE_0, PMU_MPE);
+	clkdev_add_pmu("16500000.tdm", NULL, 1, PMU_REG_MODULE_0, PMU_TDM);
+	clkdev_add_pmu("1a000000.switch", NULL, 1, PMU_REG_MODULE_0,
+		PMU_SWITCH_R);
+	clkdev_add_pmu("1a600000.usb", NULL, 1, PMU_REG_MODULE_0, PMU_USB1);
+	clkdev_add_pmu("1c000000.switch", NULL, 1, PMU_REG_MODULE_0,
+		PMU_SWITCH_L);
+
+	clkdev_add_pmu("18900000.pcie", NULL, 1, PMU_REG_MODULE_1,
+		PMU_PCIE_CTRL0);
+	clkdev_add_pmu("18400000.pcie", NULL, 1, PMU_REG_MODULE_1,
+		PMU_PCIE_CTRL1);
+	clkdev_add_pmu("18e00000.pcie", NULL, 1, PMU_REG_MODULE_1,
+		PMU_PCIE_CTRL2);
+#endif
+}
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -1158,6 +1158,15 @@ config LANTIQ_USIF_UART_DEFAULT_BAUDRATE
         int "Lantiq USIF UART Default Baudrate"
         default "115200"
 
+config SERIAL_GRX500_BOOTCORE_CONSOLE
+        bool "Console on GRX500 TEP(grx500_bootcore) console"
+	depends on LANTIQ && SOC_GRX500_BOOTCORE
+        select SERIAL_CORE
+        default n
+        select SERIAL_CORE_CONSOLE
+        help
+          Support for Console on Lantiq GRX500 TEP(grx500_bootcore) console.
+
 config SERIAL_QE
 	tristate "Freescale QUICC Engine serial port support"
 	depends on QUICC_ENGINE
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -78,6 +78,7 @@ obj-$(CONFIG_SERIAL_PCH_UART)	+= pch_uar
 obj-$(CONFIG_SERIAL_MSM_SMD)	+= msm_smd_tty.o
 obj-$(CONFIG_SERIAL_MXS_AUART) += mxs-auart.o
 obj-$(CONFIG_SERIAL_LANTIQ)	+= lantiq.o
+obj-$(CONFIG_SERIAL_GRX500_BOOTCORE_CONSOLE) += grx500_bootcore-uart.o
 obj-$(CONFIG_SERIAL_XILINX_PS_UART) += xilinx_uartps.o
 obj-$(CONFIG_SERIAL_SIRFSOC) += sirfsoc_uart.o
 obj-$(CONFIG_SERIAL_TEGRA) += serial-tegra.o
diff --git a/drivers/tty/serial/grx500_bootcore-uart.c b/drivers/tty/serial/grx500_bootcore-uart.c
new file mode 100644
--- /dev/null
+++ b/drivers/tty/serial/grx500_bootcore-uart.c
@@ -0,0 +1,462 @@
+/*
+ *  linux/drivers/char/8250.c
+ *
+ *  Driver for grx500_bootcore serial ports
+ *
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ *  Copyright (C) 2001 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ *  $Id: grx500_bootcore.c
+ *
+ * A note about mapbase / membase
+ *
+ *  mapbase is the physical address of the IO port.
+ *  membase is an 'ioremapped' cookie.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_reg.h>
+//#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/nmi.h>
+#include <linux/mutex.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/serial.h>
+#include <asm/setup.h>
+
+#include <linux/serial_core.h>
+/*change name: ?*/
+#include <grx500_bootcore_defs.h>
+#include <grx500_bootcore_cnfg.h>
+#include <grx500_bootcore_chadr.h>
+#include <grx500_bootcore_chipreg.h>
+#include <grx500_bootcore_emerald_env_regs.h>
+#include <grx500_bootcore_uart.h>
+#include <grx500_bootcore_time.h>
+#include <grx500_bootcore_interrupt.h>
+
+
+#define WWPATCH
+
+
+#define UART_NR			1	/* only use one port */
+
+int uart_done = 0;
+
+
+static struct irqaction uart_irqaction = {
+      .handler        = uart_interrupt,
+    	.flags          = IRQF_DISABLED, /* for disable nested interrupts */ 
+    	/* Lior.H - when we need to use-> IRQF_NOBALANCING ? */
+      .name           = "grx500_bootcore_uart",
+};
+
+
+static void grx500_bootcore_console_write(struct console *co, const char *s, unsigned count);
+static void grx500_bootcore_start_tx(struct uart_port *port);
+
+/*uart mux to host*/
+#define REG_UART_CONTROL_MUX_MPU_BIT 0x100
+
+#define uart_full_hw_buffer() (((MT_RdReg(UART_BASE, REG_UART_BYTES_IN_TX_FIFO) & UART_FWL_TX_MASK)>>5) == 16)
+#define uart_get_char() (MT_RdReg(UART_BASE, REG_UART_READ_DATA) & UART_RD_DATA_MASK)
+/****************************************************************************
+* grx500_bootcore_config_hw
+*
+* REG_UART_FIFO_WATER_LEVEL (0x18):
+* REG_UART_RX_FIFO_WATER_LEVEL - [mask = 0x1f]
+* REG_UART_TX_FIFO_WATER_LEVEL - [mask = 0x3e0]
+*
+* REG_UART_INT (0x1c):
+* Those  registers define the UART water level for RX and TX FIFOs
+* The register is split to 2 section, mask_int and status int (clear write 1)
+* interesting mask:
+*   UART_read_FIFO_water_level_IRQ_enable - [mask =  0x20]
+*   UART_write_FIFO_water_level_IRQ_enable - [mask =  0x40] 
+* interesting status:
+*   UART_read_FIFO_water_level_IRQ - [mask =  0x2000]
+*   UART_write_FIFO_water_level_IRQ - [mask = 0x4000]
+*/
+void grx500_bootcore_config_hw(uint32 baud, uint8 data, uint8 parity, uint8 stop)
+{
+	uint32 temp = 0;
+	
+	/* disable interrupts */
+    MT_WrReg(UART_BASE,REG_UART_INT, 0x00); 
+
+	/* set up baud rate */
+	{ 
+		uint32 divisor;
+
+		/* set divisor - clock 40mHz assumed */
+//#ifndef CONFIG_VBG400_CHIPIT Orig
+#ifdef CONFIG_VBG400_CHIPIT
+		divisor = ((GRX500_BOOTCORE_SYSTEM_CLK) / (16*baud)) - 1;
+#else
+        divisor = ((GRX500_BOOTCORE_SYSTEM_CLK/GRX500_BOOTCORE_SCALE_VAL) / (16*baud)) - 1;
+#endif
+		MT_WrReg(UART_BASE,REG_UART_CLOCK_DIVISION_RATIO, divisor & 0xff);
+ 	}
+
+	/* set data format */
+	MT_WrReg(UART_BASE,REG_UART_CONTROL, data|parity|stop|REG_UART_CONTROL_MUX_MPU_BIT); 
+	MT_WrReg(UART_BASE,REG_UART_RX_IDLE_COUNTER, 90); //10 time one byte duration
+
+    /*============ Set WATER_L ======================================== */
+    temp = 0 << REG_UART_TX_FIFO_WATER_LEVEL_SHIFT;  //TX
+    temp |= (7 << REG_UART_RX_FIFO_WATER_LEVEL_SHIFT); //RX
+    MT_WrReg(UART_BASE,REG_UART_RX_FIFO_WATER_LEVEL, temp); //same register as TX
+
+	/*============ Set allowed interrupts ==================================== */
+    temp = (1 << REG_UART_READ_FIFO_WATER_LEVEL_IRQ_ENABLE_SHIFT);   //RX
+    temp |= 1 << REG_UART_WRITE_FIFO_WATER_LEVEL_IRQ_ENABLE_SHIFT; //TX
+    temp |= (1 << REG_UART_IDLE_IRQ_ENABLE_SHIFT);                   //IDLE
+	
+	MT_WrReg(UART_BASE,REG_UART_INT,temp);
+
+}
+
+
+static void grx500_bootcore_stop_tx(struct uart_port *port)
+{
+}
+
+static void grx500_bootcore_stop_rx(struct uart_port *port)
+{
+}
+
+static void grx500_bootcore_enable_ms(struct uart_port *port)
+{
+	return;
+}
+
+/********************************************************
+* Name: grx500_bootcore_uart_tx_isr
+*
+* Description: same handling as in start_tx clb.
+* if there is data pending, send it out.
+*
+* TODO - if WL > 0, use timer in order to clear FIFO in polling mode.
+*/
+void grx500_bootcore_uart_tx_isr(struct uart_port *port)
+{
+/*    struct console *co = NULL;
+    const char *s = NULL;
+    unsigned count = 0;
+    grx500_bootcore_start_tx(co, s, count); */
+	 grx500_bootcore_start_tx(port);
+}
+
+/********************************************************
+* Name: grx500_bootcore_uart_rx_isr
+*
+* Description: data in HW fifo.
+* send it up to the core layer.
+*
+* UART_read_FIFO_water_level_IRQ_enable - [mask =  0x20]
+*/
+void grx500_bootcore_uart_rx_isr(struct uart_port *port)
+{
+	unsigned char index, len;
+	unsigned char char_in;
+    char flag;
+	unsigned int status;
+
+	len = (unsigned char)UART_MCOR_RD_RX_BYTES;
+	flag = TTY_NORMAL;
+	/* TODO- error handling here...
+	if ()..
+	  flag = TTY_BREAK;
+      etc...
+    */
+    status = 0;
+	for (index=0; index <len; index++)
+	{
+		//char_in = (unsigned char) MT_RdReg( UART_BASE, REG_UART_READ_DATA) & UART_RD_DATA_MASK;
+		char_in = (unsigned char) uart_get_char();
+		port->icount.rx++;
+	    uart_insert_char(port, status, UART_LSR_OE, char_in, flag);
+	}
+
+//	tty_flip_buffer_push(port->info->tty);
+//huanx	tty_flip_buffer_push(port->state->port.tty);
+	tty_flip_buffer_push(&port->state->port);
+}
+
+
+static unsigned int grx500_bootcore_tx_empty(struct uart_port *port)
+{
+	return 0;
+}
+
+static unsigned int grx500_bootcore_get_mctrl(struct uart_port *port)
+{
+	return 0;
+}
+
+static void grx500_bootcore_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	return;
+}
+
+static void grx500_bootcore_break_ctl(struct uart_port *port, int break_state)
+{
+    return;
+}
+
+#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
+
+/*static*/ int grx500_bootcore_startup(struct uart_port *port)
+{
+	if (uart_done)
+        return 0;
+
+	/*config uart*/
+	printk(KERN_INFO "Serial: grx500_bootcore driver startup\n");
+    grx500_bootcore_config_hw(UART_RATE_9600,//UART_RATE_115200,
+                   UART_TX_OUT_ENABLE_YES/*0x1*/,
+                   UART_PARITY_NONE/*0*/,
+                   UART_STOP_ONEBIT/*0*/);
+
+	/*config vector interrupt*/
+	grx500_bootcore_register_static_irq(GRX500_BOOTCORE_SERIAL_IRQ_IN_INDEX, GRX500_BOOTCORE_SERIAL_IRQ_OUT_INDEX, &uart_irqaction, grx500_bootcore_uart_irq);
+    //grx500_bootcore_enable_irq(GRX500_BOOTCORE_SERIAL_IRQ_OUT_INDEX); huanx
+	uart_done = 1;
+
+	return 0;
+}
+
+static void grx500_bootcore_shutdown(struct uart_port *port)
+{
+    /*TODO*/
+}
+
+static void
+grx500_bootcore_set_termios(struct uart_port *port, struct ktermios *termios,
+		       struct ktermios *old)
+{
+    return;
+}
+
+static void
+grx500_bootcore_pm(struct uart_port *port, unsigned int state,
+	      unsigned int oldstate)
+{
+	return;
+}
+
+static void grx500_bootcore_release_port(struct uart_port *port)
+{
+	return;
+}
+
+static int grx500_bootcore_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+static void grx500_bootcore_config_port(struct uart_port *port, int flags)
+{
+	return;
+}
+
+static int
+grx500_bootcore_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	return 0;
+}
+
+static const char *
+grx500_bootcore_type(struct uart_port *port)
+{
+	return "grx500_bootcoretty";
+}
+
+#define GRX500_BOOTCORE_CONSOLE	&grx500_bootcore_console
+
+static struct uart_driver grx500_bootcore_uart_reg;
+
+static struct console grx500_bootcore_console = {
+	.name = "ttyLTQ",
+	.write = grx500_bootcore_console_write,
+	.device = uart_console_device,
+	.data		= &grx500_bootcore_uart_reg,
+	.flags = CON_PRINTBUFFER | CON_ENABLED | CON_CONSDEV,
+	.index = -1,
+};
+
+static struct uart_ops grx500_bootcore_ops = {
+	.tx_empty	    = grx500_bootcore_tx_empty,     /*NULL*/
+	.set_mctrl	    = grx500_bootcore_set_mctrl,    /*NULL*/
+	.get_mctrl	    = grx500_bootcore_get_mctrl,    /*NULL*/
+	.stop_tx	    = grx500_bootcore_stop_tx,
+	.start_tx	    = grx500_bootcore_start_tx,
+	.stop_rx        = grx500_bootcore_stop_rx,
+	.enable_ms	    = grx500_bootcore_enable_ms,    /*NULL*/
+	.break_ctl	    = grx500_bootcore_break_ctl,    /*NULL*/
+	.startup	    = grx500_bootcore_startup,
+	.shutdown	    = grx500_bootcore_shutdown,
+	.set_termios    = grx500_bootcore_set_termios,  /*NULL*/
+	.pm		        = grx500_bootcore_pm,           /*NULL*/
+	.type		    = grx500_bootcore_type,
+	.release_port	= grx500_bootcore_release_port, /*NULL*/
+	.request_port	= grx500_bootcore_request_port, /*NULL*/
+	.config_port	= grx500_bootcore_config_port,  /*NULL*/
+	.verify_port	= grx500_bootcore_verify_port,  /*NULL*/
+};
+
+static struct uart_port grx500_bootcore_port = {
+	.ops		= &grx500_bootcore_ops,
+   .type       = PORT_GRX500_BOOTCORE,
+};
+
+//static struct uart_driver grx500_bootcore_uart_reg;
+
+static struct uart_driver grx500_bootcore_uart_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name	= "serial",
+	.dev_name		= "ttyLTQ",
+	.major			= TTY_MAJOR,
+	.minor			= 64,
+	.nr			    = UART_NR,
+	.cons			= GRX500_BOOTCORE_CONSOLE,
+};
+
+#ifdef WWPATCH
+
+#define			REG_UART_BYTES_IN_FIFO				(0x2c)
+#define			REG_UART_TX_FIFO_BITS_MASK			(0x3e0)
+
+void wave400_console_tx_put(struct uart_port *port, /*char*/int byte)
+{
+	int dummy_count=0xfffff;
+
+	while(((MT_RdReg(UART_BASE,REG_UART_BYTES_IN_FIFO) & REG_UART_TX_FIFO_BITS_MASK) != 0) && dummy_count)
+	{
+		dummy_count--;
+	}
+	MT_WrReg(UART_BASE ,WR_ADDR, (char)byte);
+}
+
+
+#endif /* WWPATCH */
+
+
+/*static*/ void grx500_bootcore_console_write(struct console *co, const char *s, unsigned count)
+{
+
+	#ifdef WWPATCH
+	/* i think start tx below fail since console init is before driver initcall */
+	uart_console_write(&grx500_bootcore_port, s, count, wave400_console_tx_put);
+	#else /* WWPATCH */
+	struct uart_port *port = &grx500_bootcore_port;
+	grx500_bootcore_start_tx(port);
+	#endif
+}
+
+/*static*/ void grx500_bootcore_start_tx(struct uart_port *port)
+{
+//	struct uart_port *port = &grx500_bootcore_port;
+//	struct circ_buf *xmit = &port->info->xmit; //ptr to xmit buff
+	int count_local;
+	struct circ_buf *xmit = NULL;
+
+	if (!port->state)
+		return;
+
+	xmit = &port->state->xmit; //ptr to xmit buff
+
+	if (port->x_char) {
+		port->icount.tx++;
+        printk("grx500_bootcore_start_tx: xon-xoff non-zero=%c\n", port->x_char); 
+        port->x_char = 0;
+	}
+
+	/*buff handling:*/
+	count_local = uart_circ_chars_pending(xmit);
+	if (!count_local)
+    {
+	    return;
+    }
+
+	do {
+		//if ( uart_circ_empty(xmit) || (((MT_RdReg( UART_BASE, REG_UART_BYTES_IN_TX_FIFO) & UART_FWL_TX_MASK)>>5) == 16) )
+		if ( uart_circ_empty(xmit) || uart_full_hw_buffer() )
+			break; //who trigger tx again?
+	    MT_WrReg(UART_BASE ,WR_ADDR, (volatile unsigned long)xmit->buf[xmit->tail]);
+	    //MT_WrReg(UART_BASE ,WR_ADDR, ((volatile unsigned long)xmit->buf[xmit->tail] & 0x000000FF));
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+	} while (--count_local > 0);
+    
+    if (uart_circ_chars_pending(xmit))
+        uart_write_wakeup(port);
+    /*? can get port->x_char ??*/
+    
+}
+
+
+static int __init grx500_bootcore_uart_init(void)
+{
+    struct irqaction *action = &uart_irqaction;
+    struct uart_port *up = &grx500_bootcore_port;
+    int ret;
+
+	printk(KERN_INFO "Serial: grx500_bootcore driver init\n");
+            
+    /*register uart_port for use in interrupt handler*/
+    action->dev_id = up;
+
+	ret = uart_register_driver(&grx500_bootcore_uart_reg);
+	if (ret)
+		goto out;
+
+    ret = uart_add_one_port(&grx500_bootcore_uart_reg, &grx500_bootcore_port);
+	if (ret)
+	    uart_unregister_driver(&grx500_bootcore_uart_reg);
+	
+out:
+	return ret;
+}
+
+/*static*/ int __init grx500_bootcore_console_init(void)
+{
+	printk(KERN_INFO ": grx500_bootcore_console_init: call register\n");
+
+	register_console(&grx500_bootcore_console);
+    /*no need to unregister early console if set flag=CON_CONSDEV in new console,
+     done in register_console().
+    unregister_console(&early_lntq_console);*/
+
+	return 0;
+}
+
+console_initcall(grx500_bootcore_console_init);
+
+
+static void __exit grx500_bootcore_uart_exit(void)
+{
+
+	uart_unregister_driver(&grx500_bootcore_uart_reg);
+}
+
+module_init(grx500_bootcore_uart_init);
+module_exit(grx500_bootcore_uart_exit);
+
