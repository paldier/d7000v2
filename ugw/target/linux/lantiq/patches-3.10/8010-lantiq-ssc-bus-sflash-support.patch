# HG changeset patch
# Parent 443e82ee48506175047b09df764f45ee78eec57e

diff --git a/arch/mips/include/asm/mach-lantiq/xway/lantiq_ssc.h b/arch/mips/include/asm/mach-lantiq/xway/lantiq_ssc.h
new file mode 100755
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/xway/lantiq_ssc.h
@@ -0,0 +1,271 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2009~2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+
+#ifndef LANTIQ_SSC_H
+#define LANTIQ_SSC_H
+
+/*!
+ \defgroup IFX_SSC SSC bus driver module
+ \brief UEIP Project - SSC bus driver module, support all CPEs.
+*/
+
+/*!
+ \defgroup IFX_SSC_DEFINITIONS Definition and structions
+ \ingroup IFX_SSC
+ \brief definitions for ifx ssc driver
+*/
+
+/*!
+  \defgroup IFX_SSC_FUNCTIONS external APIs
+  \ingroup IFX_SSC
+  \brief IFX ssc external driver functions
+*/
+
+/*!
+  \defgroup IFX_SSC_INTERNAL Internal functions
+  \ingroup IFX_SSC
+  \brief IFX ssc internal driver functions
+*/
+
+/*!
+ \file ifx_ssc.h
+ \ingroup IFX_SSC
+ \brief header file for SSC bus driver external interface
+*/
+
+/*!
+ \addtogroup IFX_SSC_DEFINITIONS
+*/
+/* @{ */
+/*! \enum  IFX_SSC_PRIO_t
+    \brief Set communication priority of SSC connection
+
+    Three priority levels are defined. Low-level priority queue used for
+    applications like FLASH driver (ifx_ssc_prio_low). normal priority
+    queue used for applications like display (ifx_ssc_prio_mid).
+    High priority queue used for applications like RTP packet transfer
+    (ifx_ssc_prio_high).
+ */
+typedef enum {
+	IFX_SSC_PRIO_LOW = 0, /*!< Low Priority queue.
+				   For FLASH driver, etc. */
+	IFX_SSC_PRIO_MID,     /*!< Normal Priority queue.
+				   For LCD, display data, etc. */
+	IFX_SSC_PRIO_HIGH,    /*!< High priority queue.
+				   Ror RTP voice, etc. */
+	IFX_SSC_PRIO_ASYNC,   /*!< Tasklet priority (This is the highest
+				   supported priority) For this priority
+				   level only the asynchronous API set of
+				   the SSC driver can be called. These
+				   funtions stay unblocked and a callback
+				   function is called when the request is
+				   processed. This allows that the APIs are
+				   called from tasklet level. The callback
+				   function is always called on tasklet
+				   level */
+} IFX_SSC_PRIO_t;
+
+#define IFX_SSC_PRIO_MAX IFX_SSC_PRIO_ASYNC
+
+/*! \enum  IFX_SSC_MODE_t
+    \brief Defines the Ssc hardware mode settings supported
+
+    Because there is no official specification, what exactly SPI is and what
+    not, it is necessary to consult the data sheets of the components one
+    wants to use. Important are the permitted clock frequencies and the type
+    of valid transitions. There are no general rules for transitions where
+    data should be latched. Although not specified by Motorola, in practice
+    four modes are used. These four modes are the combinations of CPOL and
+    CPHA. In table 1, the four modes are listed.If the phase of the clock
+    is zero, i.e. CPHA = 0, data is latched at the rising edge of the clock
+    with CPOL = 0, and at the falling edge of the clock with CPOL = 1. If
+    CPHA = 1, the polarities are reversed. CPOL = 0 means falling edge,
+    CPOL = 1 rising edge.The micro controllers from Motorola allow the
+    polarity and the phase of the clock to be adjusted. A positive polarity
+    results in latching data at the rising edge of the clock. However data
+    is put on the data line already at the falling edge in order to stabilize.
+    Most peripherals which can only be slaves, work with this configuration.
+    If it should become necessary to use the other polarity, transitions are
+    reversed.
+  */
+typedef enum {
+	IFX_SSC_MODE_0 = 0, /*!< CPOL=0,CPHA=0 */
+	IFX_SSC_MODE_1, /*!< CPOL=0,CPHA=1 */
+	IFX_SSC_MODE_2, /*!< CPOL=1,CPHA=0 */
+	IFX_SSC_MODE_3, /*!< CPOL=1,CPHA=1 */
+	IFX_SSC_MODE_UNKNOWN, /*!< Unknown SPI mode */
+} IFX_SSC_MODE_t;
+
+/*! \enum  IFX_SSC_HANDL_TYPE_t
+    \brief Defines the SPI handler type supported
+ */
+typedef enum {
+	IFX_SSC_HANDL_TYPE_SYNC = 0, /*!< Only SYNC handler which be used
+					by sync application */
+	IFX_SSC_HANDL_TYPE_ASYNC, /*!< Only ASYNC handler which be used
+					by async application */
+} IFX_SSC_HANDL_TYPE_t;
+
+/*! \enum  IFX_SSC_DLX_t
+    \brief Set communication duplex mode of SSC connection
+
+    The duplex mode is used to notify SSC bus driver by SSC device driver
+    about what kind of communication mode should be used. Which duplex mode
+    will be used depends on the SSC device driver instead of SSC bus driver.
+ */
+typedef enum {
+	IFX_SSC_HALF_DUPLEX = 0,/*!< Half Duplex. Interface is used in half
+				     duplex when calling \ref ifx_sscTxRx or
+				     \ref ifx_sscAsyncTxRx. The TX path is
+				     servered before the RX path. */
+	IFX_SSC_FULL_DUPLEX,	/*!< Full Duplex. Interface is used in full
+				     duplex when calling \ref ifx_sscTxRx or
+				     \ref ifx_sscAsyncTxRx. The TX-and RX-
+				     path is servered simultaneously. */
+} IFX_SSC_DLX_t;
+
+/*!< \typedef IFX_CS_DATA
+     \brief Definition of device specific data for chip select
+ */
+typedef int IFX_CS_DATA;
+enum {
+	IFX_SSC_CS_ON = 0,	IFX_SSC_CS_OFF,
+};
+
+#define IFX_SSC_WHBGPOSTAT_OUT0_POS  0
+#define IFX_SSC_WHBGPOSTAT_OUT1_POS  1
+#define IFX_SSC_WHBGPOSTAT_OUT2_POS  2
+#define IFX_SSC_WHBGPOSTAT_OUT3_POS  3
+#define IFX_SSC_WHBGPOSTAT_OUT4_POS  4
+#define IFX_SSC_WHBGPOSTAT_OUT5_POS  5
+#define IFX_SSC_WHBGPOSTAT_OUT6_POS  6
+#define IFX_SSC_WHBGPOSTAT_OUT7_POS  7
+
+/*! \typedef IFX_SSC_CS_CB_t
+    \brief Chip Select Callback function type declaration
+
+     csq csq=0, i.e. CS low (active). csq=1, i.e.CS high (idle).
+     cs_data This is the device number in case if more than one device is using
+     the same registered driver. E.g. two VINETICs, each with it´s own CS.
+ */
+typedef int (*IFX_SSC_CS_CB_t) (u32 csq, IFX_CS_DATA cs_data);
+
+/*! typedef ifx_ssc_async_fkt_cb_t
+    \brief Callback definition for asynchronous SSC API calls. This callback is
+    called by the SSC driver on tasklet level after the request is completed or
+    exit with an error.
+
+    \param handle Funktion handle that provided for callback registration
+    during the SSC asynchronous API call.
+    \param retvalue This return value describe if the asynchronous request
+    identified an error and worked successfully.
+*/
+typedef void (*ifx_ssc_async_fkt_cb_t) (int handle, int retvalue);
+
+/*! typedef IFX_SSC_ASYNC_CALLBACK_t
+    \brief Parameter to specify the asynchronous callback. It is called
+    by the SSC tasklet after the requested transmission or locking is done.
+*/
+typedef struct {
+	ifx_ssc_async_fkt_cb_t pFunction;/*!< Callback function pointer,
+					  called in the SSC tasklet when
+					 the requested command is executed */
+	int functionHandle;	/*!< Callback function handle. This parameter
+				     is transparently given to the callback
+				     function without any modification by the
+				     SSC driver */
+} IFX_SSC_ASYNC_CALLBACK_t;
+
+/*!  \brief Parameter structure used to configure an SSC connection "ConnId".
+ */
+typedef struct {
+	IFX_SSC_MODE_t ssc_mode; /*!< Defines the hardware setup mode of
+				       the SSC */
+	IFX_SSC_PRIO_t ssc_prio; /*!< The communication priority of SSC
+				      connection. Three priority levels
+				      are defined. Low-level priority
+				      queue used for applications like
+				      FLASH driver (ifx_ssc_prio_low).
+				      Normal priority queue used for
+				      applications like display
+				      (ifx_ssc_prio_mid). High priority
+				      queue used for applications like RTP
+				      packet transfer (ifx_ssc_prio_high).
+				      The here defined SSC priority
+				      corresponds to the priority the SSC
+				      driver application and should be set
+				      just for information when the driver
+				      is registered by the application.
+				 */
+	int baudrate;		/*!< Baudrate used for the ConnId.
+				   This parameter can be later be modified
+				   by a call of ifx_sscSetBaud
+				 */
+	int fragSize;		/*!< All transmitted and received packets
+				     should be fragmented in this fragment
+				     size. Size given in Bytes. A maximum
+				     of 1024 Bytes is allowed. If the client
+				     uses a bigger values here, SSC returns
+				     with error. The client has to take care
+				     of the fragmentation
+				 */
+	int maxFIFOSize;	/*!< Maximum packet size in FIFO mode.
+				   All transmitted and received packets are
+				   transmitted in DMA mode if the packet
+				   size is greater than this value. A value
+				   of 148 is recommended at first.Size given
+				   in Bytes
+				 */
+	IFX_SSC_CS_CB_t csset_cb;	/*!< Function Callback called by SSC
+					     driver when it starts/stops to
+					     receive or transmit */
+	IFX_CS_DATA cs_data;	/*!< Parameter used for the function
+				     call of "csSet_cb". */
+	IFX_SSC_DLX_t duplex_mode;	/*!< Duplex Mode Selector. Connection
+					   used the SSC interface either in
+					   half- or full- duplex mode. */
+} IFX_SSC_CONFIGURE_t;
+
+/*! \typedef IFX_SSC_HANDLE
+    \brief Definition of the connection handle
+
+     as it is used by the client kernel module that use the SSC driver
+     Inside of the SSC driver, this handle is mapped to an internal
+     structure that contains the connection specific parameter
+     (e.g. Baudrate, Chipselect Callbacks, etc.).
+ */
+typedef void *IFX_SSC_HANDLE;
+
+/* @} */
+extern int ifx_ssc_cs_low(u32 pin);
+extern int ifx_ssc_cs_high(u32 pin);
+extern int ifx_sscLock(IFX_SSC_HANDLE handler);
+extern int ifx_sscUnlock(IFX_SSC_HANDLE handler);
+extern int ifx_sscSetBaud(IFX_SSC_HANDLE handler, unsigned int baud);
+extern int ifx_sscTxRx(IFX_SSC_HANDLE handler, char *tx_buf, u32 tx_len,
+			char *rx_buf, u32 rx_len);
+extern int ifx_sscRx(IFX_SSC_HANDLE handler, char *rx_buf, u32 rx_len);
+extern int ifx_sscTx(IFX_SSC_HANDLE handler, char *tx_buf, u32 tx_len);
+extern IFX_SSC_HANDLE ifx_sscAllocConnection(char *dev_name,
+					      IFX_SSC_CONFIGURE_t *connid);
+extern int ifx_sscFreeConnection(IFX_SSC_HANDLE handler);
+extern int ifx_sscAsyncTxRx(IFX_SSC_HANDLE handler,
+			     IFX_SSC_ASYNC_CALLBACK_t *pCallback,
+			      char *txbuf, int txsize, char *rxbuf, int rxsize);
+extern int ifx_sscAsyncTx(IFX_SSC_HANDLE handler,
+			   IFX_SSC_ASYNC_CALLBACK_t *pCallback,
+			    char *txbuf, int txsize);
+extern int ifx_sscAsyncRx(IFX_SSC_HANDLE handler,
+			   IFX_SSC_ASYNC_CALLBACK_t *pCallback,
+			    char *rxbuf, int rxsize);
+extern int ifx_sscAsyncLock(IFX_SSC_HANDLE handler,
+			     IFX_SSC_ASYNC_CALLBACK_t *pCallback);
+extern int ifx_sscAsyncUnLock(IFX_SSC_HANDLE handler);
+
+#endif /* LANTIQ_SSC_H */
+
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
old mode 100644
new mode 100755
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -385,6 +385,37 @@ config SPI_SC18IS602
 	help
 	  SPI driver for NXP SC18IS602/602B/603 I2C to SPI bridge.
 
+config LANTIQ_SPI
+	tristate "Lantiq SPI/SSC driver"
+	depends on SPI_MASTER
+	default n
+
+config LANTIQ_SPI_DEBUG
+    bool "Lantiq SPI/SSC runtime debug support"
+    depends on LANTIQ_SPI
+    default n
+    ----help---
+    Choose this option to enable Lantiq SPI/SSC runtime debug options.
+    This can be enabled by writing debug options into
+    /proc/sys/dev/ltq_ssc/debug.
+
+config LANTIQ_SPI_ASYNCHRONOUS
+	bool "Lantiq SPI/SSC tasklet support"
+	depends on LANTIQ_SPI
+	default y
+	---help---
+	Choose this option to support synchronous and asynchronous APIs
+	at the same time. SPI itself will run in tasklet. If not,
+	only synchronous API is supported. SPI context will in kernel
+	thread mode and belong to caller's context.
+
+config LANTIQ_SPI_FLASH
+	tristate "Lantiq SPI/SSC 25 types of serial flash driver"
+	depends on LANTIQ_SPI
+	default n
+
+
+
 config SPI_SH_MSIOF
 	tristate "SuperH MSIOF SPI controller"
 	depends on (SUPERH || ARCH_SHMOBILE) && HAVE_CLK
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
old mode 100644
new mode 100755
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -76,3 +76,6 @@ obj-$(CONFIG_SPI_TXX9)			+= spi-txx9.o
 obj-$(CONFIG_SPI_XCOMM)		+= spi-xcomm.o
 obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
 obj-$(CONFIG_SPI_XWAY)			+= spi-xway.o
+
+obj-$(CONFIG_LANTIQ_SPI)               += ltq_ssc.o
+obj-$(CONFIG_LANTIQ_SPI_FLASH)         += ltq_sflash.o
diff --git a/drivers/spi/ltq_sflash.c b/drivers/spi/ltq_sflash.c
new file mode 100755
--- /dev/null
+++ b/drivers/spi/ltq_sflash.c
@@ -0,0 +1,1156 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2009~2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+
+/*!
+  \defgroup IFX_SFLASH SSC Serial Flash module
+  \brief ifx serial flash driver module
+*/
+
+/*!
+  \defgroup IFX_SFLASH_OS OS APIs
+  \ingroup IFX_SFLASH
+  \brief IFX serial flash driver OS interface functions
+*/
+
+/*!
+  \defgroup IFX_SFLASH_INTERNAL Internal APIs
+  \ingroup IFX_SFLASH
+  \brief IFX serial flash driver functions
+*/
+
+/*!
+  \file ltq_sflash.c
+  \ingroup IFX_SFLASH
+  \brief ifx serial flash driver source file
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <../drivers/mtd/mtdcore.h>
+#include <linux/ctype.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/semaphore.h>
+#include <linux/math64.h>
+#include <linux/of.h>
+
+/* Project header */
+#include <lantiq.h>
+#include <lantiq_ssc.h>
+#include "ltq_sflash.h"
+
+#define IFX_SFLASH_MODE                IFX_SSC_MODE_0
+#define IFX_SFLASH_PRIORITY            IFX_SSC_PRIO_LOW
+#define IFX_SFLASH_FRAGSIZE            264  /* must be more than 260, page size
+					* + cmd + addr, must be a multiple
+					* of DMA burst length */
+#define IFX_SFLASH_MAXFIFOSIZE         32 /* FIFO mode */
+
+#define IFX_SFLASH_BAUDRATE            10000000 /*  20 MHz */
+#define IFX_SFLASH_CS                  IFX_SSC_WHBGPOSTAT_OUT0_POS
+
+
+#define IFX_SFLASH_VER_MAJOR          1
+#define IFX_SFLASH_VER_MID            2
+#define IFX_SFLASH_VER_MINOR          3
+
+#define IFX_SFLASH_NAME               "ltq_sflash"
+#define IFX_SFLASH_ADDR_CYCLES        3 /* 24bit address */
+
+/* #define IFX_SPI_FLASH_DBG */
+
+#if defined(IFX_SPI_FLASH_DBG)
+#define IFX_SFLASH_PRINT(format, arg...)   \
+	pr_info("%s: " format, __func__, ##arg)
+#define INLINE
+#else
+#define IFX_SFLASH_PRINT(format, arg...)   \
+	do { } while (0)
+#define INLINE inline
+#endif
+
+#define IFX_MTD_SPI_PARTITION_2MB_SIZE    0x001B0000
+#define IFX_MTD_SPI_PARTITION_4MB_SIZE    0x003A0000
+#define IFX_MTD_SPI_PARTITION_8MB_SIZE    0x007A0000
+#define IFX_MTD_SPI_PARTITION_16MB_SIZE   0x00FA0000
+#define IFX_MTD_SPI_PARTITION_32MB_SIZE   0x01FA0000
+
+
+#define IFX_MTD_SPI_PART_NB               3
+#define IFX_SPI_FLASH_MAX                 9
+
+static const struct mtd_partition
+g_ifx_mtd_spi_partitions[IFX_SPI_FLASH_MAX][IFX_MTD_SPI_PART_NB] = {
+	{ { 0, 0, 0 } },
+
+/* 256K Byte */
+	{ {
+		.name   =      "spi-boot",      /* U-Boot firmware */
+		.offset =      0x00000000,
+		.size   =      0x00040000,         /* 256 */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	}, {0}, {0},
+	},
+
+/* 512K Byte */
+	{ { 0, 0, 0 } },
+
+/* 1M Byte */
+	{ {
+		.name   =       "spi-boot",     /* U-Boot firmware */
+		.offset =       0x00000000,
+		.size   =       0x00010000,        /* 64K */
+		/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-firmware", /* firmware */
+		.offset =       0x00010000,
+		.size   =       0x00030000,        /* 64K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-rootfs,kernel,Data,Environment",
+		.offset =       0x00030000,
+		.size   =       0x000C0000,
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	} },
+
+/* 2M Byte */
+	{ {
+		.name   =       "spi-boot",     /* U-Boot firmware */
+		.offset =       0x00000000,
+		.size   =       0x00020000,        /* 128K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-firmware", /* firmware */
+		.offset =       0x00020000,
+		.size   =       0x00030000,        /* 192K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-rootfs,kernel,Data,Environment",
+		.offset =       0x00050000,
+		.size   =       IFX_MTD_SPI_PARTITION_2MB_SIZE,
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	} },
+
+/* 4M Byte */
+	{ {
+		.name   =       "spi-boot",     /* U-Boot firmware */
+		.offset =       0x00000000,
+		.size   =       0x00020000,        /* 128K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-firmware", /* firmware */
+		.offset =       0x00020000,
+		.size   =       0x00040000,        /* 256K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-rootfs,kernel,Data,Environment",
+		.offset =       0x00060000,
+		.size   =       IFX_MTD_SPI_PARTITION_4MB_SIZE,
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	} },
+
+/* 8M Byte */
+	{ {
+		.name   =       "spi-boot",     /* U-Boot firmware */
+		.offset =       0x00000000,
+		.size   =       0x00020000,        /* 128K */
+		/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =      "spi-firmware",  /* firmware */
+		.offset =      0x00020000,
+		.size   =      0x00030000,         /* 192K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-rootfs,kernel,Data,Environment",
+		.offset =       0x00050000,
+		.size   =       IFX_MTD_SPI_PARTITION_8MB_SIZE,
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	} },
+
+/* 16M Byte */
+	{ {
+		.name   =       "spi-boot",     /* U-Boot firmware */
+		.offset =       0x00000000,
+		.size   =       0x00020000,        /* 128K */
+		/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =      "spi-firmware",  /* firmware */
+		.offset =      0x00020000,
+		.size   =      0x00030000,         /* 192K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-rootfs,kernel,Data,Environment",
+		.offset =       0x00050000,
+		.size   =       IFX_MTD_SPI_PARTITION_16MB_SIZE,
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	} },
+/* 32M Byte */
+	{ {
+		.name   =       "spi-boot",     /* U-Boot firmware */
+		.offset =       0x00000000,
+		.size   =       0x00020000,        /* 128K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =      "spi-firmware",  /* firmware */
+		.offset =      0x00020000,
+		.size   =      0x00030000,         /* 192K */
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	},
+	{
+		.name   =       "spi-rootfs,kernel,Data,Environment",
+		.offset =       0x00050000,
+		.size   =       IFX_MTD_SPI_PARTITION_32MB_SIZE,
+	/*  mask_flags:   MTD_WRITEABLE,    force read-only */
+	} },
+};
+
+static struct semaphore ifx_sflash_sem;
+
+static ifx_spi_dev_t *spi_sflash;
+
+/*
+ * NOTE: double check command sets and memory organization when you add
+ * more flash chips.  This current list focusses on newer chips, which
+ * have been converging on command sets which including JEDEC ID.
+ */
+static const struct ifx_sflash_manufacturer_info
+	flash_manufacturers[] = {
+	{
+	 /* Spansion -- single (large) sector size only, at least
+	  * for the chips listed here (without boot sectors).
+	  */
+	 .name = "Spansion",
+	 .id = JED_MANU_SPANSION,
+	 .flashes = {
+		{"S25Sl004", 0x0212, 64 * 1024, 8,},
+		{"S25Sl008", 0x0213, 64 * 1024, 16,},
+		{"S25LF016", 0x0214, 64 * 1024, 32,},
+		{"S25LF032", 0x0215, 64 * 1024, 64,},
+		{"S25LF064", 0x0216, 64 * 1024, 128,},
+		{"", 0x0, 0, 0},
+		{"S25LF0128", 0x0218, 256 * 1024, 64,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		},
+	 },
+	{/* ST Microelectronics -- newer production may have feature updates */
+	 .name = "ST",
+	 .id = JED_MANU_ST,
+	 .flashes = {
+		{"m25p05", 0x2010, 32 * 1024, 2,},
+		{"m25p10", 0x2011, 32 * 1024, 4,},
+		{"m25p20", 0x2012, 64 * 1024, 4,},
+		{"m25p40", 0x2013, 64 * 1024, 8,},
+		{"m25p16", 0x2015, 64 * 1024, 32,},
+		{"m25px16", 0x7115, 64 * 1024, 32, SECT_4K,},
+		{"m25p32", 0x2016, 64 * 1024, 64,},
+		{"m25px32", 0x7116, 64 * 1024, 64, SECT_4K,},
+		{"m25p64", 0x2017, 64 * 1024, 128,},
+		{"m25px64", 0x7117, 64 * 1024, 128, SECT_4K,},
+		{"m25p128", 0x2018, 256 * 1024, 64,},
+		{"m45pe80", 0x4014, 64 * 1024, 16,},
+		{"m45pe16", 0x4015, 64 * 1024, 32,},
+		{"m25pe80", 0x8014, 64 * 1024, 16,},
+		{"m25pe16", 0x8015, 64 * 1024, 32, SECT_4K,},
+
+		},
+	 },
+	{/* SST -- large erase sizes are "overlays", "sectors" are 4K */
+	 .name = "SST",
+	 .id = JED_MANU_SST,
+	 .flashes = {
+		{"sst25vf040b", 0x258d, 64 * 1024, 8, SECT_4K,},
+		{"sst25vf080b", 0x258e, 64 * 1024, 16, SECT_4K,},
+		{"sst25vf016b", 0x2541, 64 * 1024, 32, SECT_4K,},
+		{"sst25vf032b", 0x254a, 64 * 1024, 64, SECT_4K,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		},
+	 },
+	{
+	 .name = "Atmel",
+	 .id = JED_MANU_ATMEL,
+	 .flashes = {
+		{"at25fs010", 0x6601, 32 * 1024, 4, SECT_4K,},
+		{"at25fs040", 0x6604, 64 * 1024, 8, SECT_4K,},
+		{"at25df041a", 0x4401, 64 * 1024, 8, SECT_4K,},
+		{"at25df641", 0x4800, 64 * 1024, 128, SECT_4K,},
+		{"at26f004", 0x0400, 64 * 1024, 8, SECT_4K,},
+		{"at26df081a", 0x4501, 64 * 1024, 16, SECT_4K,},
+		{"at26df161a", 0x4601, 64 * 1024, 32, SECT_4K,},
+		{"at26df321", 0x4701, 64 * 1024, 64, SECT_4K,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		},
+
+	 },
+	{/* Winbond -- w25x "blocks" are 64K, "sectors" are 4KiB */
+	 .name = "Winbond",
+	 .id = JED_MANU_WINBOND,
+	 .flashes = {
+		{"w25x10", 0x3011, 64 * 1024, 2, SECT_4K,},
+		{"w25x20", 0x3012, 64 * 1024, 4, SECT_4K,},
+		{"w25x40", 0x3013, 64 * 1024, 8, SECT_4K,},
+		{"w25x80", 0x3014, 64 * 1024, 16, SECT_4K,},
+		{"w25x16", 0x3015, 64 * 1024, 32, SECT_4K,},
+		{"w25x32", 0x3016, 64 * 1024, 64, SECT_4K,},
+		{"w25x64", 0x3017, 64 * 1024, 128, SECT_4K,},
+		{"W25P80", 0x2014, 256 * 256, 16,},
+		{"W25P16", 0x2015, 256 * 256, 32,},
+		{"W25P32", 0x2016, 256 * 256, 64,},
+		{"W25P64", 0x2017, 256 * 256, 128,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		},
+
+	 },
+	{
+	 .name = "MX",
+	 .id = JED_MANU_MX,
+	 .flashes = {
+		{"MX25P2005", 0x2012, 16 * 256, 64,},
+		{"MX25P4005", 0x2013, 16 * 256, 128,},
+		{"MX25P8005", 0x2014, 16 * 256, 256,},
+		{"MX25P1605", 0x2015, 256 * 256, 32,},
+		{"MX25P3205", 0x2016, 256 * 256, 64,},
+		{"MX25P6405", 0x2017, 256 * 256, 128,},
+		{"MX25L12835", 0x2018, 64 * 1024, 256, SECT_4K, },
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		{"", 0, 0, 0,},
+		},
+	 },
+};
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+static const char * const part_probes[] = { "cmdlinepart", NULL };
+#endif
+
+#ifdef IFX_SPI_FLASH_DBG
+static void flash_dump(const char *title, const u8 *buf, size_t len)
+{
+	int i, llen, lenlab = 0;
+	const u8 *pos = buf;
+	const int line_len = 16;
+
+	pr_info("%s - hex_ascii(len=%lu):\n",
+		title, (unsigned long) len);
+	while (len) {
+		llen = len > line_len ? line_len : len;
+		pr_info("%08x: ", lenlab);
+		for (i = 0; i < llen; i++)
+			pr_info(" %02x", pos[i]);
+		for (i = llen; i < line_len; i++)
+			pr_info("   ");
+		pr_info("   ");
+		for (i = 0; i < llen; i++) {
+			if (isprint(pos[i]))
+				pr_info("%c", pos[i]);
+			else
+				pr_info(".");
+		}
+		for (i = llen; i < line_len; i++)
+			pr_info(" ");
+		pr_info("\n");
+		pos += llen;
+		len -= llen;
+		lenlab += line_len;
+	}
+}
+#endif	/* IFX_SPI_FLASH_DBG */
+
+/*!
+ * \fn static INLINE void  u32_to_u8_addr(u32 address, u8* addr)
+ * \brief  convert address from u32 to u8 array
+ *
+ * \param[in]  address the address to be converted, maximum 32 bit
+ * \param[out] addr array that holds the results, maximum 4 elemets
+ * \ingroup  IFX_SFLASH_INTERNAL
+ */
+static INLINE void u32_to_u8_addr(u32 address, u8 *addr)
+{
+	addr[0] = (u8) ((address >> 16) & 0xff);
+	addr[1] = (u8) ((address >> 8) & 0xff);
+	addr[2] = (u8) (address & 0xff);
+}
+
+/**
+ * \fn static int ifx_sflash_rdsr(ifx_spi_dev_t *dev, u8 *status)
+ * \brief Return the status of the serial flash device.
+ *
+ * \param[in]  dev   Pointer to ifx_spi_dev_t
+ * \param[out] status Pointer to return status
+ * \return   -l  Failed to read status
+ * \return   0  OK
+ * \ingroup IFX_SFLASH_INTERNAL
+ */
+static int ifx_sflash_rdsr(ifx_spi_dev_t *dev, u8 *status)
+{
+	int ret;
+	u8 cmd = IFX_OPCODE_RDSR;
+
+	ret = ifx_sscTxRx(dev->sflash_handler, (char *) &cmd, sizeof(u8),
+		 status, sizeof(u8));
+	if (ret != 2) {
+		IFX_SFLASH_PRINT("line %d ifx_sscTxRx fails %d\n",
+			 __LINE__, ret);
+		return -1;
+	}
+	return 0;
+}
+
+/**
+ * \fn static int ifx_sflash_sync(ifx_spi_dev_t *dev)
+ * \brief Poll the serial flash device until it is READY
+ *
+ * \param[in]  dev   Pointer to ifx_spi_dev_t
+ * \return     -l  Failed to read status
+ * \return     0  OK
+ * \ingroup IFX_SFLASH_INTERNAL
+ */
+static int ifx_sflash_sync(ifx_spi_dev_t *dev)
+{
+	int ret = 0;
+	u8 status;
+	int count = 0;
+	unsigned long deadline;
+
+	deadline = jiffies + IFX_MAX_READY_WAIT_JIFFIES;
+	do {
+		ret = ifx_sflash_rdsr(dev, &status);
+		if (ret < 0) {
+			IFX_SFLASH_PRINT("Read back status fails %d\n",
+				 ret);
+			break;
+		}
+
+		if (!(status & IFX_SR_WIP))
+			return 0;
+
+		cond_resched();
+
+		/* This is mainly for detecting serial flash */
+		if (++count > IFX_SFLASH_DETECT_COUNTER) {
+			IFX_SFLASH_PRINT
+				("Detct counter out of range!!!\n");
+			break;
+		}
+
+	} while (!time_after_eq(jiffies, deadline));
+
+	return -1;
+}
+
+/**
+ * \fn static int ifx_sflash_session(ifx_spi_dev_t *dev, u8 cmd, u8 *addr,
+ *                u8 dummy_cycles, u8 *wbuf, u32 wcnt, u8 *rbuf, u32 rcnt)
+ * \brief Handle serial flash read/write/erase in one central function
+ *
+ * \param[in]  dev   Pointer to ifx_spi_dev_t
+ * \param[in]  cmd   Serial flash command code
+ * \param[in]  addr  Flash address offset
+ * \param[in]  dummy_cycles Dummy cycles for some serial flash
+ * \param[in]  wbuf     Pointer to the data packet to write.
+ * \param[in]  wcnt     Amount of Bytes to write.
+ * \param[out] rbuf     Pointer to store the read data.
+ * \param[in]  rcnt     Amount of Bytes to read.
+ * \return     -EINVAL  Invalid read data length
+ * \return     -EBUSY   Serial flash device is busy
+ * \return     0        OK
+ * \ingroup IFX_SFLASH_INTERNAL
+ */
+static int
+ifx_sflash_session(ifx_spi_dev_t *dev, u8 cmd, u8 *addr, u8 dummy_cycles,
+		   u8 *wbuf, u32 wcnt, u8 *rbuf, u32 rcnt)
+{
+	int i;
+	int ret = 0;
+	int err = 0;
+	int start = 0;
+	int total = 0;
+	char *buf = dev->flash_tx_buf;
+	char *tbuf;
+
+	/* Sanity check */
+	if (unlikely(rcnt >= IFX_SFLASH_MAX_READ_SIZE)) {
+		pr_err("%s: please increase read buffer size\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	/* CMD */
+	buf[0] = cmd;
+	start = 1;
+
+	/* Address */
+	if (addr != NULL) {
+		for (i = 0; i < dev->addr_cycles; i++)
+			buf[start + i] = addr[i];
+		start += dev->addr_cycles;
+	}
+
+	/* Dummy cycles */
+	if (dummy_cycles > 0 && dummy_cycles < IFX_MAX_DUMMY_CYCLES) {
+		for (i = 0; i < dummy_cycles; i++)
+			buf[start + i] = 0;
+		start += dummy_cycles;
+	}
+
+	/* Possibly, there is no flash mounted */
+	if (ifx_sflash_sync(dev) == -1)
+		return -EBUSY;
+
+	if ((wcnt == 0) && (rcnt == 0)) { /* Cmd + Addr + Dummy cycles */
+		ret = ifx_sscTx(dev->sflash_handler, buf, start);
+		if (ret != start) {
+			err++;
+			IFX_SFLASH_PRINT("line %d ifx_sscTx fails %d\n",
+				 __LINE__, ret);
+			goto sflash_session_out;
+		}
+	} else if (wcnt > 0) {	/* Cmd + Addr +  Dummy cycles + Write data */
+		total = start + wcnt;
+		memcpy(buf + start, wbuf, wcnt);
+		ret = ifx_sscTx(dev->sflash_handler, buf, total);
+		if (ret != total) {
+			err++;
+			IFX_SFLASH_PRINT("line %d ifx_sscTx fails %d\n",
+				 __LINE__, ret);
+			goto sflash_session_out;
+		}
+	} else if (rcnt > 0) {	/* Cmd + Addr +  Dummy cycles + Read data */
+		int rx_aligned = 0;
+
+		total = start + rcnt;
+		rx_aligned =
+			(((u32) rbuf) & (IFX_SFLASH_DMA_MAX_BURST_LEN - 1))
+			== 0 ? 1 : 0;
+		if (rx_aligned == 0)
+			tbuf = dev->flash_rx_buf;
+		else
+			tbuf = rbuf;
+
+		ret = ifx_sscTxRx(dev->sflash_handler, buf, start, tbuf, rcnt);
+		if (ret != total) {
+			err++;
+			IFX_SFLASH_PRINT("line %d ifx_sscTxRx fails %d\n",
+				 __LINE__, ret);
+			goto sflash_session_out;
+		}
+
+		if (rx_aligned == 0)
+			memcpy(rbuf, tbuf, rcnt);
+
+	} else {
+		pr_err("%s should never happen\n", __func__);
+	}
+sflash_session_out:
+	return err;
+}
+
+static INLINE int ifx_sflash_wren(void)
+{
+	u8 cmd = IFX_OPCODE_WREN;
+	return ifx_sflash_session(spi_sflash, cmd, NULL, 0, NULL, 0, NULL, 0);
+}
+
+static INLINE int ifx_sflash_se(u8 *addr)
+{
+	return ifx_sflash_session(spi_sflash, spi_sflash->erase_opcode,
+		addr, 0, NULL, 0, NULL, 0);
+}
+
+static INLINE int ifx_sflash_pp(u8 *addr, u8 *buf, u32 len)
+{
+	u8 cmd = IFX_OPCODE_PP;
+	return ifx_sflash_session(spi_sflash, cmd, addr, 0, buf, len, NULL, 0);
+}
+
+static INLINE int ifx_sflash_rd(u8 *addr, u8 *buf, u32 len)
+{
+	u8 cmd = IFX_OPCODE_READ;
+	return ifx_sflash_session(spi_sflash, cmd, addr,
+		spi_sflash->dummy_cycles, NULL, 0, buf, len);
+}
+
+static INLINE int ifx_spi_read(u32 saddr, u8 *buf, u32 len)
+{
+	int ret;
+	u8 addr[IFX_MAX_ADDRESS_NUM] = { 0 };
+
+	u32_to_u8_addr(saddr, addr);
+	ret = ifx_sflash_rd(addr, buf, len);
+	return ret;
+}
+
+static INLINE int ifx_spi_write(u32 saddr, u8 *buf, u32 len)
+{
+	int ret;
+	u8 addr[IFX_MAX_ADDRESS_NUM] = { 0 };
+
+	u32_to_u8_addr(saddr, addr);
+	ifx_sflash_wren();
+	ret = ifx_sflash_pp(addr, buf, len);
+	return ret;
+}
+
+static INLINE int ifx_spi_sector_erase(u32 saddr)
+{
+	u8 addr[IFX_MAX_ADDRESS_NUM] = { 0 };
+
+	u32_to_u8_addr(saddr, addr);
+	ifx_sflash_wren();
+	return ifx_sflash_se(addr);
+}
+
+static INLINE int ifx_spi_chip_erase(void)
+{
+	u8 cmd = IFX_OPCODE_CHIP_ERASE;
+
+	ifx_sflash_wren();
+	return ifx_sflash_session(spi_sflash, cmd, NULL, 0, NULL, 0, NULL, 0);
+}
+
+/**
+ * \fn static int ifx_spi_flash_probe(ifx_spi_dev_t *pdev)
+ * \brief Detect serial flash device
+ *
+ * \param[in]  pdev   Pointer to ifx_spi_dev_t
+ * \return   -l  Failed to detect device
+ * \return    0  OK
+ * \ingroup IFX_SFLASH_INTERNAL
+ */
+static int  ifx_spi_flash_probe(ifx_spi_dev_t *pdev)
+{
+	int i;
+	u16 dev_id;
+	u8 cmd = IFX_OPCODE_RDID;
+
+	ifx_sscLock(pdev->sflash_handler);
+	/* Send the request for the part identification */
+	ifx_sscTx(pdev->sflash_handler, &cmd, sizeof(cmd));
+	/* Now read in the manufacturer id bytes */
+	do {
+		ifx_sscRx(pdev->sflash_handler, &pdev->manufacturer_id, 1);
+		if (pdev->manufacturer_id == 0x7F)
+			pr_err("Warning: unhandled manufacturer continuation byte!\n");
+
+	} while (pdev->manufacturer_id == 0x7F);
+
+	/* Now read in the first device id byte */
+	ifx_sscRx(pdev->sflash_handler, &pdev->device_id1, 1);
+	/* Now read in the second device id byte */
+	ifx_sscRx(pdev->sflash_handler, &pdev->device_id2, 1);
+	ifx_sscUnlock(pdev->sflash_handler);
+	dev_id = (pdev->device_id1 << 8) | pdev->device_id2;
+	IFX_SFLASH_PRINT("Vendor %02x Type %02x sig %02x\n",
+		 pdev->manufacturer_id, pdev->device_id1,
+		 pdev->device_id2);
+	for (i = 0; i < ARRAY_SIZE(flash_manufacturers); ++i) {
+		if (pdev->manufacturer_id == flash_manufacturers[i].id)
+			break;
+
+	}
+	if (i == ARRAY_SIZE(flash_manufacturers))
+		goto unknown;
+
+	pdev->manufacturer =
+		(struct ifx_sflash_manufacturer_info *)&flash_manufacturers[i];
+	for (i = 0; pdev->manufacturer->flashes[i].id; ++i) {
+		if (dev_id == pdev->manufacturer->flashes[i].id)
+			break;
+	}
+	if (!pdev->manufacturer->flashes[i].id)
+		goto unknown;
+
+	pdev->flash = &pdev->manufacturer->flashes[i];
+	pdev->sector_size = pdev->flash->sector_size;
+	pdev->num_sectors = pdev->flash->num_sectors;
+	pdev->dummy_cycles = IFX_FAST_READ_DUMMY_BYTE;
+	pdev->write_length = IFX_FLASH_PAGESIZE;
+
+	pdev->size = pdev->sector_size * pdev->num_sectors;
+
+	IFX_SFLASH_PRINT("SPI Device: %s 0x%02X (%s) 0x%02X 0x%02X\n"
+			 "Parameters: num sectors = %lu, sector size = %lu,"
+			 " write size = %u\n",
+			 pdev->flash->name, pdev->manufacturer_id,
+			 pdev->manufacturer->name, pdev->device_id1,
+			 pdev->device_id2, pdev->num_sectors,
+			 pdev->sector_size, pdev->write_length);
+	return 0;
+unknown:
+	pr_err("Unknown SPI device: 0x%02X 0x%02X 0x%02X\n",
+	       pdev->manufacturer_id, pdev->device_id1, pdev->device_id2);
+	return -1;
+}
+
+static INLINE int ifx_spi_flash_cs_handler(u32 csq, IFX_CS_DATA cs_data)
+{
+	if (csq == IFX_SSC_CS_ON) { /* Low active */
+		return ifx_ssc_cs_low(cs_data);
+	} else {
+		return ifx_ssc_cs_high(cs_data);
+	}
+}
+
+static INLINE void ifx_spi_flash_version(void)
+{
+	pr_info("ltq_sflash ver %d.%d.%d\n", IFX_SFLASH_VER_MAJOR,
+		IFX_SFLASH_VER_MID, IFX_SFLASH_VER_MINOR);
+}
+
+/**
+ * \fn static int ifx_spi_flash_read(struct mtd_info *mtd, loff_t from, size_t len,
+ *                 size_t *retlen ,u_char *buf)
+ * \brief Read from the serial flash device.
+ *
+ * \param[in]  mtd    Pointer to struct mtd_info
+ * \param[in]  from   Start offset in flash device
+ * \param[in]  len    Amount to read
+ * \param[out] retlen About of data actually read
+ * \param[out] buf    Buffer containing the data
+ * \return     0      No need to read actually or read successfully
+ * \return     -EINVAL invalid read length
+ * \ingroup IFX_SFLASH_OS
+ */
+static int
+ifx_spi_flash_read(struct mtd_info *mtd, loff_t from, size_t len,
+	       size_t *retlen, u_char *buf)
+{
+	int total = 0;
+	int len_this_lp;
+	u32 addr;
+	u8 *mem;
+
+	IFX_SFLASH_PRINT("(from = 0x%.8x, len = %d)\n", (u32) from,
+		 (int) len);
+	if (!len)
+		return 0;
+	if ((from + len) > mtd->size)
+		return -EINVAL;
+	down(&ifx_sflash_sem);
+	/* Fragment support */
+	while (total < len) {
+		mem = (u8 *) (buf + total);
+		addr = from + total;
+		len_this_lp =
+			min((len - total), (size_t) IFX_SFLASH_FRAGSIZE);
+		ifx_spi_read(addr, mem, len_this_lp);
+		total += len_this_lp;
+	}
+
+	*retlen = len;
+	up(&ifx_sflash_sem);
+	return 0;
+}
+
+/**
+ * \fn static int ifx_spi_flash_write (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
+ * \brief Read from the serial flash device.
+ *
+ * \param[in]  mtd    Pointer to struct mtd_info
+ * \param[in]  to     Start offset in flash device
+ * \param[in]  len    Amount to write
+ * \param[out] retlen Amount of data actually written
+ * \param[out] buf    Buffer containing the data
+ * \return     0      No need to read actually or read successfully
+ * \return     -EINVAL invalid read length
+ * \ingroup IFX_SFLASH_OS
+ */
+static int
+ifx_spi_flash_write(struct mtd_info *mtd, loff_t to, size_t len,
+		    size_t *retlen, const u_char *buf)
+{
+	int total = 0, len_this_lp, bytes_this_page;
+	u32 addr = 0;
+	u8 *mem;
+
+	IFX_SFLASH_PRINT("(to = 0x%.8x, len = %d)\n", (u32) to, len);
+
+	if (retlen)
+		*retlen = 0;
+
+	/* sanity check */
+	if (len == 0)
+		return 0;
+
+	if ((to + len) > mtd->size)
+		return -EINVAL;
+
+	down(&ifx_sflash_sem);
+	while (total < len) {
+		mem = (u8 *) (buf + total);
+		addr = to + total;
+		bytes_this_page =
+			spi_sflash->write_length -
+			(addr % spi_sflash->write_length);
+		len_this_lp = min((len - total), (size_t) bytes_this_page);
+		ifx_spi_write(addr, mem, len_this_lp);
+		total += len_this_lp;
+	}
+	*retlen = len;
+	up(&ifx_sflash_sem);
+	return 0;
+}
+
+/**
+ * \fn static int ifx_spi_flash_erase(struct mtd_info *mtd,struct erase_info *instr)
+ * \brief Erase pages of serial flash device.
+ *
+ * \param[in]  mtd    Pointer to struct mtd_info
+ * \param[in]  instr  Pointer to struct erase_info
+ * \return     0      OK
+ * \return     -EINVAL invalid erase size
+ * \ingroup IFX_SFLASH_OS
+ */
+static int
+ifx_spi_flash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	u32 addr, len;
+	uint32_t rem;
+
+	IFX_SFLASH_PRINT("(addr = 0x%llx, len = %lld)\n",
+		 (long long) instr->addr, (long long) instr->len);
+
+	if ((instr->addr + instr->len) > mtd->size)
+		return -EINVAL;
+
+	div_u64_rem(instr->len, mtd->erasesize, &rem);
+	if (rem)
+		return -EINVAL;
+
+	addr = instr->addr;
+	len = instr->len;
+
+	down(&ifx_sflash_sem);
+	/* whole-chip erase? */
+	if (len == mtd->size) {
+		IFX_SFLASH_PRINT("%lldKiB\n",
+			 (long long) (mtd->size >> 10));
+
+		if (ifx_spi_chip_erase() != 0) {
+			instr->state = MTD_ERASE_FAILED;
+			up(&ifx_sflash_sem);
+			return -EIO;
+		}
+	} else {
+		/* REVISIT in some cases we could speed up erasing large
+		 * regions by using OPCODE_SE instead of OPCODE_BE_4K.
+		 * We may have set up to use "small sector erase", but
+		 * that's not always optimal.
+		 */
+		while (len) {
+			if (ifx_spi_sector_erase(addr) != 0) {
+				instr->state = MTD_ERASE_FAILED;
+				up(&ifx_sflash_sem);
+				return -EIO;
+			}
+			addr += mtd->erasesize;
+			len -= mtd->erasesize;
+		}
+	}
+	up(&ifx_sflash_sem);
+
+	/* Inform MTD subsystem that erase is complete */
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+	IFX_SFLASH_PRINT("return\n");
+	return 0;
+}
+
+static INLINE IFX_SSC_HANDLE ifx_spi_flash_register(char *dev_name)
+{
+	IFX_SSC_CONFIGURE_t ssc_cfg = { 0 };
+
+	ssc_cfg.baudrate = IFX_SFLASH_BAUDRATE;
+	ssc_cfg.csset_cb = ifx_spi_flash_cs_handler;
+	if (of_machine_is_compatible("lantiq,vr9")
+		|| of_machine_is_compatible("lantiq,ar9"))
+		ssc_cfg.cs_data = IFX_SSC_WHBGPOSTAT_OUT3_POS;
+	else
+		ssc_cfg.cs_data = IFX_SSC_WHBGPOSTAT_OUT0_POS;
+	ssc_cfg.fragSize = IFX_SFLASH_FRAGSIZE;
+	ssc_cfg.maxFIFOSize = IFX_SFLASH_MAXFIFOSIZE;
+	ssc_cfg.ssc_mode = IFX_SFLASH_MODE;
+	ssc_cfg.ssc_prio = IFX_SFLASH_PRIORITY;
+	ssc_cfg.duplex_mode = IFX_SSC_HALF_DUPLEX;
+	return ifx_sscAllocConnection(dev_name, &ssc_cfg);
+}
+
+static INLINE int ifx_spi_flash_size_to_index(u32 size)
+{
+	int i;
+	int index = IFX_FLASH_128KB;
+
+	i = (size >> 17);	/* 128 KB minimum */
+	if (i <= 1)
+		index = IFX_FLASH_128KB;
+	else if (i <= 2)
+		index = IFX_FLASH_256KB;
+	else if (i <= 4)
+		index = IFX_FLASH_512KB;
+	else if (i <= 8)
+		index = IFX_FLASH_1MB;
+	else if (i <= 16)
+		index = IFX_FLASH_2MB;
+	else if (i <= 32)
+		index = IFX_FLASH_4MB;
+	else if (i <= 64)
+		index = IFX_FLASH_8MB;
+	else if (i <= 128)
+		index = IFX_FLASH_16MB;
+	else
+		index = IFX_SPI_MAX_FLASH;
+	return index;
+}
+
+static INLINE void ifx_spi_flash_gpio_init(void)
+{
+
+}
+
+static INLINE void ifx_spi_flash_gpio_release(void)
+{
+
+}
+
+static int __init ifx_spi_flash_init(void)
+{
+	IFX_SSC_HANDLE *sflash_handler;
+	struct mtd_info *mtd;
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	int np;
+#endif	/* CONFIG_MTD_CMDLINE_PARTS */
+	int ret = 0;
+	int index;
+
+	sema_init(&ifx_sflash_sem, 1);
+
+	ifx_spi_flash_gpio_init();
+	spi_sflash = kmalloc(sizeof(ifx_spi_dev_t), GFP_KERNEL);
+	if (spi_sflash == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	memset(spi_sflash, 0, sizeof(ifx_spi_dev_t));
+	/*
+	 * Make sure tx buffer address is DMA burst length aligned and 2 page
+	 * size< 512> should be enouhg for serial flash. In this way, host cpu
+	 * can make good use of DMA operation.
+	 */
+	spi_sflash->flash_tx_org_buf =
+		kmalloc(IFX_SFLASH_MAX_WRITE_SIZE +
+			IFX_SFLASH_DMA_MAX_BURST_LEN - 1, GFP_KERNEL);
+	if (spi_sflash->flash_tx_org_buf == NULL) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+	spi_sflash->flash_tx_buf =
+		(char *) (((u32) (spi_sflash->flash_tx_org_buf +
+		       IFX_SFLASH_DMA_MAX_BURST_LEN - 1))
+		     & ~(IFX_SFLASH_DMA_MAX_BURST_LEN - 1));
+
+	/*
+	 * Make sure rx buffer address is DMA burst length aligned and 8 page
+	 * size< 2KB> should be enouhg for serial flash. In this way, host cpu
+	 * can make good use of DMA operation.
+	 */
+	spi_sflash->flash_rx_org_buf =
+		kmalloc(IFX_SFLASH_MAX_READ_SIZE +
+			IFX_SFLASH_DMA_MAX_BURST_LEN - 1, GFP_KERNEL);
+	if (spi_sflash->flash_rx_org_buf == NULL) {
+		ret = -ENOMEM;
+		goto err2;
+	}
+	spi_sflash->flash_rx_buf =
+		(char *) (((u32) (spi_sflash->flash_rx_org_buf +
+		       IFX_SFLASH_DMA_MAX_BURST_LEN - 1))
+		     & ~(IFX_SFLASH_DMA_MAX_BURST_LEN - 1));
+
+	spi_sflash->addr_cycles = IFX_SFLASH_ADDR_CYCLES;
+
+	mtd = kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
+	if (mtd == NULL) {
+		pr_warn("%s Cant allocate mtd stuff\n",
+		       __func__);
+		ret = -ENOMEM;
+		goto err3;
+	}
+	memset(mtd, 0, sizeof(struct mtd_info));
+
+	sflash_handler = ifx_spi_flash_register(IFX_SFLASH_NAME);
+	if (sflash_handler == NULL) {
+		pr_err("%s: failed to register sflash\n", __func__);
+		ret = -ENOMEM;
+		goto err4;
+	}
+
+	spi_sflash->sflash_handler = sflash_handler;
+	if (ifx_spi_flash_probe(spi_sflash) != 0) {
+		pr_warn("%s: Found no serial flash device\n",
+			__func__);
+		ret = -ENXIO;
+		goto err5;
+	}
+
+	mtd->name = IFX_SFLASH_NAME;
+	mtd->type = MTD_NORFLASH;
+	mtd->flags = (MTD_CAP_NORFLASH | MTD_WRITEABLE);
+	mtd->size = spi_sflash->size;
+	/* Prefer "small sector" erase if possible */
+	if (spi_sflash->flash->flags & SECT_4K) {
+		spi_sflash->erase_opcode = IFX_OPCODE_BE_4K;
+		mtd->erasesize = 4096;
+	} else {
+		spi_sflash->erase_opcode = IFX_OPCODE_SE;
+		mtd->erasesize = spi_sflash->sector_size;
+	}
+
+	mtd->numeraseregions = 0;
+	mtd->eraseregions = NULL;
+	mtd->owner = THIS_MODULE;
+	mtd->writesize = 1; /* like NOR flash, should be 1 */
+	mtd->_erase = ifx_spi_flash_erase;
+	mtd->_read = ifx_spi_flash_read;
+	mtd->_write = ifx_spi_flash_write;
+
+	index = ifx_spi_flash_size_to_index(spi_sflash->size);
+	if (index > IFX_SPI_MAX_FLASH) {
+		pr_warn("%s: flash size is too big to support\n", __func__);
+		ret = -EINVAL;
+		goto err5;
+	}
+#ifdef IFX_SPI_FLASH_DBG
+	pr_dbg(
+		"mtd->name = %s\n"
+		"mtd->size = 0x%.8x (%uM)\n"
+		"mtd->erasesize = 0x%.8x (%uK)\n"
+		"mtd->numeraseregions = %d\n"
+		"mtd index %d\n",
+		mtd->name,
+		mtd->size, mtd->size / (1024 * 1024),
+		mtd->erasesize, mtd->erasesize / 1024,
+		mtd->numeraseregions, index);
+
+	if (mtd->numeraseregions) {
+		int result;
+
+		for (result = 0; result < mtd->numeraseregions; result++) {
+			pr_dbg(
+				"\n\n"
+				"mtd->eraseregions[%d].offset = 0x%.8x\n"
+				"mtd->eraseregions[%d].erasesize = 0x%.8x (%uK)\n"
+				"mtd->eraseregions[%d].numblocks = %d\n",
+				result, mtd->eraseregions[result].offset,
+				result, mtd->eraseregions[result].erasesize,
+				mtd->eraseregions[result].erasesize / 1024,
+				result,
+				mtd->eraseregions[result].numblocks);
+		}
+	}
+#endif /* IFX_SPI_FLASH_DBG */
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	np = parse_mtd_partitions(mtd, part_probes,
+		&spi_sflash->parsed_parts, 0);
+	if (np > 0) {
+		add_mtd_partitions(mtd, spi_sflash->parsed_parts, np);
+	} else {
+		pr_err("%s: No valid partition table found in command line\n",
+			__func__);
+		goto err5;
+	}
+#else
+	add_mtd_partitions(mtd, g_ifx_mtd_spi_partitions[index],
+		ARRAY_SIZE(g_ifx_mtd_spi_partitions[index]));
+#endif /* CONFIG_MTD_CMDLINE_PARTS */
+
+	spi_sflash->mtd = mtd;
+	ifx_spi_flash_version();
+	return ret;
+err5:
+	ifx_sscFreeConnection(spi_sflash->sflash_handler);
+err4:
+	kfree(mtd);
+err3:
+	kfree(spi_sflash->flash_rx_org_buf);
+err2:
+	kfree(spi_sflash->flash_tx_org_buf);
+err1:
+	kfree(spi_sflash);
+done:
+	ifx_spi_flash_gpio_release();
+	return ret;
+}
+
+static void __exit ifx_spi_flash_exit(void)
+{
+	if (spi_sflash != NULL) {
+		if (spi_sflash->parsed_parts != NULL)
+			del_mtd_partitions(spi_sflash->mtd);
+
+		kfree(spi_sflash->mtd);
+		ifx_sscFreeConnection(spi_sflash->sflash_handler);
+		kfree(spi_sflash->flash_rx_org_buf);
+		kfree(spi_sflash->flash_tx_org_buf);
+		kfree(spi_sflash);
+	}
+	ifx_spi_flash_gpio_release();
+}
+
+module_init(ifx_spi_flash_init);
+module_exit(ifx_spi_flash_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Chuanhua.Lei@infineon.com");
+MODULE_SUPPORTED_DEVICE("Serial flash 25 types generic driver");
+MODULE_DESCRIPTION("IFAP SPI flash device driver");
+
diff --git a/drivers/spi/ltq_sflash.h b/drivers/spi/ltq_sflash.h
new file mode 100755
--- /dev/null
+++ b/drivers/spi/ltq_sflash.h
@@ -0,0 +1,132 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2009~2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+
+/*!
+  \file ltq_sflash.h
+  \ingroup IFX_SFLASH
+  \brief ifx serial flash driver header file
+*/
+#ifndef LTQ_SFLASH_H
+#define LTQ_SFLASH_H
+
+/* Flash related definition */
+#define IFX_FLASH_128KB   0
+#define IFX_FLASH_256KB   1
+#define IFX_FLASH_512KB   2
+#define IFX_FLASH_1MB	  3
+#define IFX_FLASH_2MB	  4
+#define IFX_FLASH_4MB	  5
+#define IFX_FLASH_8MB	  6
+#define IFX_FLASH_16MB	  7
+#define IFX_SPI_MAX_FLASH 8
+#define IFX_FLASH_INVALID_SIZE -1
+
+#define IFX_FLASH_PAGESIZE    256
+
+/* Flash opcodes. */
+#define IFX_OPCODE_WREN         0x06 /* Write enable */
+#define IFX_OPCODE_RDSR         0x05 /* Read status register */
+#define IFX_OPCODE_NORM_READ    0x03 /* Read data bytes (low frequency) */
+#define IFX_OPCODE_FAST_READ    0x0b /* Read data bytes (high frequency) */
+#define IFX_OPCODE_PP           0x02 /* Page program (up to 256 bytes) */
+#define IFX_OPCODE_BE_4K        0x20 /* Erase 4KiB block */
+#define IFX_OPCODE_BE_32K       0x52 /* Erase 32KiB block */
+#define IFX_OPCODE_CHIP_ERASE   0xc7 /* Erase whole flash chip */
+#define IFX_OPCODE_SE           0xd8 /* Sector erase (usually 64KiB) */
+#define IFX_OPCODE_RDID         0x9f /* Read JEDEC ID */
+
+#define IFX_MAX_ADDRESS_NUM     5
+#define IFX_MAX_DUMMY_CYCLES    10
+
+/* Status Register bits. */
+#define IFX_SR_WIP   1 /* Write in progress */
+#define IFX_SR_WEL   2 /* Write enable latch */
+/* meaning of other SR_* bits may differ between vendors */
+#define IFX_SR_BP0   4 /* Block protect 0 */
+#define IFX_SR_BP1   8 /* Block protect 1 */
+#define IFX_SR_BP2   0x10 /* Block protect 2 */
+#define IFX_SR_SRWD  0x80 /* SR write protect */
+
+#define IFX_SFLASH_DETECT_COUNTER 100000 /* XXX, check if flash mounted */
+
+/* Define max times to check status register before we give up. */
+#define	IFX_MAX_READY_WAIT_JIFFIES (10 * HZ)
+
+/*
+ * 32 should be maximum requirement for DMA alignment at the low level,
+ * keep it here for future change
+ */
+#define IFX_SFLASH_DMA_MAX_BURST_LEN    32
+#define IFX_SFLASH_MAX_WRITE_SIZE      (IFX_FLASH_PAGESIZE * 2)
+#define IFX_SFLASH_MAX_READ_SIZE       (IFX_FLASH_PAGESIZE * 8) /* Tunable */
+
+#define IFX_SFLASH_MAX_FLASH_TYPE 15  /* Per Vendor */
+
+/* Define fast read/normal read, fast read for higher frequence*/
+#define CONFIG_SPI_FLASH_SLOW_READ
+
+#ifdef CONFIG_SPI_FLASH_SLOW_READ
+#define IFX_OPCODE_READ  IFX_OPCODE_NORM_READ
+#define IFX_FAST_READ_DUMMY_BYTE  0
+#else
+#define IFX_OPCODE_READ  IFX_OPCODE_FAST_READ
+#define IFX_FAST_READ_DUMMY_BYTE  1
+#endif
+
+struct ifx_sflash_info {
+	char  *name;
+
+	/* JEDEC id zero means "no ID" (most older chips); otherwise it has
+	 * a high byte of zero plus three data bytes: the manufacturer id,
+	 * then a two byte device id.
+	 */
+	u16 id;
+	/* The size listed here is what works with IFX_OPCODE_SE, which isn't
+	 * necessarily called a "sector" by the vendor.
+	 */
+	unsigned int sector_size;
+	u16 num_sectors;
+	u16 flags;
+#define SECT_4K    0x01 /* IFX_OPCODE_BE_4K works uniformly */
+};
+
+struct ifx_sflash_manufacturer_info {
+	char  *name;
+	u8     id;
+	struct ifx_sflash_info flashes[IFX_SFLASH_MAX_FLASH_TYPE];
+};
+
+enum {
+	JED_MANU_SPANSION = 0x01,
+	JED_MANU_ST       = 0x20,
+	JED_MANU_SST      = 0xBF,
+	JED_MANU_ATMEL    = 0x1F,
+	JED_MANU_WINBOND  = 0xEF,
+	JED_MANU_MX       = 0xC2,
+};
+
+/* Driver private data */
+typedef struct {
+	struct mtd_info       *mtd;
+	struct mtd_partition  *parsed_parts; /* parsed partitions */
+	char                  *flash_tx_org_buf; /* Original write buffer */
+	char                  *flash_tx_buf; /* Aligned write buffer */
+	char                  *flash_rx_org_buf; /* Orignal read buffer */
+	char                  *flash_rx_buf;  /* Aligned read buffer */
+	u8                     addr_cycles;
+	IFX_SSC_HANDLE         sflash_handler;
+	struct ifx_sflash_manufacturer_info *manufacturer;
+	struct ifx_sflash_info     *flash;
+	u8                          erase_opcode;
+	u8 manufacturer_id, device_id1, device_id2;
+	unsigned int write_length;
+	unsigned long sector_size, num_sectors, size;
+	int  dummy_cycles;
+} ifx_spi_dev_t;
+#endif /* LTQ_SFLASH_H */
+
diff --git a/drivers/spi/ltq_ssc.c b/drivers/spi/ltq_ssc.c
new file mode 100755
--- /dev/null
+++ b/drivers/spi/ltq_ssc.c
@@ -0,0 +1,3796 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2009~2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+/*!
+  \file ltq_ssc.c
+  \ingroup IFX_SSC
+  \brief ssc bus driver source file
+*/
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/err.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sysctl.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/seq_file.h>
+
+#include <lantiq.h>
+#include <lantiq_soc.h>
+#include <lantiq_dma.h>
+#include <lantiq_ssc.h>
+#include "ltq_ssc.h"
+
+#define IFX_SSC_VER_MAJOR          2
+#define IFX_SSC_VER_MID            5
+#define IFX_SSC_VER_MINOR          2
+
+#define IFX_SSC_SPLIT_BAUD_RATE   25000000
+
+#ifdef CONFIG_LANTIQ_SPI_DEBUG
+#define INLINE
+enum {
+	SSC_MSG_TX_FIFO = 0x00000001,
+	SSC_MSG_TX_DMA = 0x00000002,
+	SSC_MSG_RX_FIFO = 0x00000004,
+	SSC_MSG_RX_DMA = 0x00000008,
+	SSC_MSG_INT = 0x00000010,  /* Interrupt msg */
+	SSC_MSG_CFG = 0x00000020,
+	SSC_MSG_THREAD = 0x00000040,
+	SSC_MSG_TASKLET = 0x00000080,
+	SSC_MSG_DEBUG = 0x00000100,
+	SSC_MSG_ERROR = 0x00000200,
+	SSC_MSG_INIT = 0x00000400, /* Initialization msg */
+	SSC_MSG_QUEUE = 0x00000800,
+	SSC_MSG_LOCK = 0x00001000,
+	SSC_MSG_CALLBACK = 0x00002000,
+	SSC_MSG_DUPLEX = 0x00004000, /* duplex mode */
+	SSC_MSG_ANY = 0xffffffff, /* anything */
+};
+
+static void ifx_ssc_debug(struct ifx_ssc_port *port, const char *fmt, ...);
+
+#define IFX_SSC_PRINT(_port, _m, _fmt, args...) do {    \
+	if ((_port)->ssc_debug & (_m))                  \
+		ifx_ssc_debug((_port), (_fmt), ##args); \
+} while (0)
+
+#else
+#define INLINE  inline
+#define IFX_SSC_PRINT(_port, _m, _fmt, ...)
+#endif /* CONFIG_LANTIQ_SPI_DEBUG */
+
+#define SSC_KASSERT(exp, msg) do {    \
+	if (unlikely(!(exp))) {       \
+		printk msg;            \
+		BUG();                 \
+	}                              \
+} while (0)
+#define IFX_SSC_NAME             "ltq_ssc"
+
+/**
+ * This is the per-channel data structure containing pointers, flags
+ * and variables for the port.  ifx_ssc_isp is allocated in ifx_ssc_init()
+ * based on the chip version.
+ */
+static struct ifx_ssc_port *ifx_ssc_isp;
+
+static struct proc_dir_entry *ifx_ssc_proc;
+
+/**
+ * \fn static void  ifx_ssc_start_tasklet(struct ifx_ssc_port *port)
+ * \brief Trigger different schedule procedures according to different context.
+ * if caller is already in tasklet, it will be done in caller's tasklet
+ *
+ * \param   port       Pointer to structure #ifx_ssc_port
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static void ifx_ssc_start_tasklet(struct ifx_ssc_port *port)
+{
+	struct tasklet_struct *ptasklet;
+
+	/*
+	 * Calls the internal process to serve the queue. This routine would
+	 * immediately return in case the SSC hardware is currently used to
+	 * serve another request.
+	 */
+	ptasklet = &port->ssc_txrxq;
+	if (in_irq()) {  /* Hardware irq */
+		IFX_SSC_PRINT(port, SSC_MSG_INT,
+			"%s hardware irq schedule\n", __func__);
+		tasklet_hi_schedule(ptasklet);
+	} else if (in_softirq()) { /* Softirq or tasklet */
+		IFX_SSC_PRINT(port, SSC_MSG_TASKLET,
+			"%s softirq schedule\n", __func__);
+		if (tasklet_trylock(ptasklet)) { /* tasklet_trylock for SMP */
+			ptasklet->func(ptasklet->data);
+			tasklet_unlock(ptasklet);
+		} else {
+			IFX_SSC_PRINT(port, SSC_MSG_TASKLET,
+				"%s should never happen\n", __func__);
+		}
+	} else { /* Process  context */
+		IFX_SSC_PRINT(port, SSC_MSG_THREAD,
+			"%s process schedule\n", __func__);
+		tasklet_schedule(ptasklet);
+	}
+}
+
+
+#ifdef CONFIG_LANTIQ_SPI_DEBUG
+/**
+ * \fn static void ifx_ssc_debug(struct ifx_ssc_port *port,
+ *                               const char *fmt, ...)
+ * \brief Debug all kinds of level message
+ *
+ * \param   port    Pointer to structure #ifx_ssc_port
+ * \param   fmt     debug output format
+ *
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static void ifx_ssc_debug(struct ifx_ssc_port *port, const char *fmt, ...)
+{
+	static char buf[256] = { 0 }; /* XXX */
+	va_list ap;
+#ifdef CONFIG_LANTIQ_SPI_ASYNCHRONOUS
+	static const char *p = "tasklet";
+#else
+	static const char *p = "kthread";
+#endif
+	va_start(ap, fmt);
+	vsnprintf(buf, sizeof(buf), fmt, ap);
+	va_end(ap);
+
+	pr_info("%s %s: %s\n", p, port->name, buf);
+}
+#endif /* CONFIG_LANTIQ_SPI_DEBUG */
+
+/**
+ * \fn static INLINE void ifx_ssc_wait_finished(struct ifx_ssc_port *port)
+ * \brief Wait for SPI bus becomes idle, FIFO empty doesn't means spi bus idle.
+ *        to start another transaction, need to make sure bus is idle
+ *
+ * \param   port    Pointer to structure #ifx_ssc_port
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static INLINE void ifx_ssc_wait_finished(struct ifx_ssc_port *port)
+{
+	while ((IFX_SSC_GET_STATE(port) & IFX_SSC_STATE_BUSY))
+		; /* Do nothing */
+
+}
+
+/**
+ * \fn static INLINE unsigned int ifx_ssc_get_kernel_clk(struct ifx_ssc_port *port)
+ * \brief Get SSC clock speed.
+ * Returns the current operating speed of the SSC peripheral, depending on chip
+ * specific bus speed and RMC setting in CLC register.
+ *
+ * \param   port     Pointer to structure #ifx_ssc_port
+ * \return  >0       Peripheral speed in HZ
+ * \return  0        Error
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static INLINE unsigned int
+ifx_ssc_get_kernel_clk(struct ifx_ssc_port *port)
+{
+	/* This function assumes that the CLC register is set with the
+	 * appropriate value for RMC.
+	 */
+	unsigned int rmc;
+
+	rmc = IFX_SSC_GET_CLC_RMC(port);
+	if (rmc == 0) {
+		pr_err("%s rmc==0\n", __func__);
+		return 0;
+	}
+	return clk_get_rate(port->fpiclk) / rmc;
+}
+
+/**
+ * \fn static int ifx_ssc_stats_proc(struct seq_file *s, void *v)
+ * \brief SSC proc file read.
+ * This function creates the proc file output for the SSC driver statistics.
+ *
+ * \param   page     Buffer to write the string to
+ * \param   start    not used (Linux internal)
+ * \param   offset   not used (Linux internal)
+ * \param   count    not used (Linux internal)
+ * \param   eof      Set to 1 when all data is stored in buffer
+ * \param   data     not used (Linux internal)
+ * \return  len      Lenght of data in buffer
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int ifx_ssc_stats_proc(struct seq_file *s, void *v)
+{
+	int t = 0;
+	struct ifx_ssc_port *port;
+	struct ifx_ssc_statistics *stats;
+	ssc_device_t *dev;
+
+	seq_puts(s,
+		"Statistics for Lantiq Synchronous Serial Controller(SSC)\n\n");
+	for (t = 0; t < IFX_SSC_MAX_PORT_NUM; t++) {
+		port = &ifx_ssc_isp[t];
+
+		stats = &port->stats;
+
+		seq_printf(s, "SSC%d\n", port->port_idx);
+		seq_printf(s, "RX overflow errors %d\n", stats->rxOvErr);
+		seq_printf(s, "RX underflow errors %d\n", stats->rxUnErr);
+		seq_printf(s, "TX overflow errors %d\n", stats->txOvErr);
+		seq_printf(s, "TX underflow errors %d\n", stats->txUnErr);
+		seq_printf(s, "Abort errors %d\n", stats->abortErr);
+		seq_printf(s, "Mode errors %d\n", stats->modeErr);
+		seq_printf(s, "RX Bytes %llu\n", stats->rxBytes);
+		seq_printf(s, "TX Bytes %llu\n", stats->txBytes);
+		seq_printf(s, "TX FIFO transaction %llu\n", stats->txFifo);
+		seq_printf(s, "TX DMA transaction %llu\n", stats->txDma);
+		seq_printf(s, "TX DMA bytes %llu\n", stats->txDmaBytes);
+		seq_printf(s, "RX FIFO transaction %llu\n", stats->rxFifo);
+		seq_printf(s, "RX DMA transaction %llu\n", stats->rxDma);
+		seq_printf(s, "RX DMA bytes %llu\n", stats->rxDmaBytes);
+		seq_printf(s, "SSC bus status %s\n",
+			port->ssc_cs_locked ? "locked" : "unlocked");
+		seq_puts(s, "\n");
+		/* Per device statistics */
+		IFX_SSC_SEM_LOCK(port->dev_sem);
+		TAILQ_FOREACH(dev, &port->ssc_devq, dev_entry) {
+			seq_printf(s, "Device %s duplex %s:\n", dev->dev_name,
+				(dev->duplex ==
+				IFX_SSC_HALF_DUPLEX) ? "Half" : "Full");
+			seq_printf(s, "Rx Bytes %llu\n", dev->stats.rxBytes);
+			seq_printf(s, "Tx Bytes %llu\n", dev->stats.txBytes);
+			seq_printf(s, "Context errors %d\n",
+				dev->stats.context_err);
+			seq_printf(s, "Duplicated qentry errors %d\n",
+				dev->stats.dup_qentries);
+			seq_printf(s, "Fragment errors %d\n",
+				dev->stats.frag_err);
+			seq_printf(s, "Handler errors %d\n",
+				dev->stats.handler_err);
+			seq_printf(s, "Duplex errors %d\n", dev->stats.dlx_err);
+			seq_printf(s, "Enqueue %llu\n", dev->stats.enqueue);
+			seq_printf(s, "Dequeue %llu\n", dev->stats.dequeue);
+		}
+		IFX_SSC_SEM_UNLOCK(port->dev_sem);
+	}
+	return 0;
+}
+
+static int ifx_ssc_stats_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ifx_ssc_stats_proc, NULL);
+}
+
+static const struct file_operations ifx_ssc_stats_proc_fops = {
+	.open           = ifx_ssc_stats_proc_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+/**
+ * \fn static int ifx_ssc_reg_read_proc(struct seq_file *s, void *v)
+ * \brief SSC proc file read.
+ * This function creates the proc file output for SSC register dump.
+ *
+ * \param   page     Buffer to write the string to
+ * \param   start    not used (Linux internal)
+ * \param   offset   not used (Linux internal)
+ * \param   count    not used (Linux internal)
+ * \param   eof      Set to 1 when all data is stored in buffer
+ * \param   data     not used (Linux internal)
+ * \return  len      Lenght of data in buffer
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int ifx_ssc_reg_read_proc(struct seq_file *s, void *v)
+{
+	int t = 0;
+#define IFX_SSC_REG_MAX  20
+	u32 stats[IFX_SSC_REG_MAX] = { 0 };
+	struct ifx_ssc_port *port;
+
+	seq_puts(s,
+		"Register Dump for Lantiq Synchronous Serial Controller(SSC)\n\n");
+	for (t = 0; t < IFX_SSC_MAX_PORT_NUM; t++) {
+		port = &ifx_ssc_isp[t];
+		IFX_SSC_IRQ_LOCK(port);
+		stats[0] = IFX_SSC_GET_CLC(port);
+		stats[1] = IFX_SSC_GET_ID(port);
+		stats[2] = IFX_SSC_GET_CON(port);
+		stats[3] = IFX_SSC_GET_STATE(port);
+		stats[4] = IFX_SSC_GET_TX_WORD(port);
+		stats[5] = IFX_SSC_GET_FIFO_STATUS(port);
+		stats[6] = IFX_SSC_GET_RX_FIFO_CTRL(port);
+		stats[7] = IFX_SSC_GET_TX_FIFO_CTRL(port);
+		stats[8] = IFX_SSC_GET_BR(port);
+		stats[9] = IFX_SSC_GET_FRAMING_CON(port);
+		stats[10] = IFX_SSC_GET_FRAMING_STATUS(port);
+		stats[11] = IFX_SSC_GET_GPOCON(port);
+		stats[12] = IFX_SSC_GET_GPOSTAT(port);
+		stats[13] = IFX_SSC_GET_RXREQ(port);
+		stats[14] = IFX_SSC_GET_RXCNT(port);
+		stats[15] = IFX_SSC_GET_DMA_CON(port);
+		stats[16] = IFX_SSC_GET_IRN_EN(port);
+		stats[17] = IFX_SSC_GET_IRN_CR(port);
+		stats[18] = IFX_SSC_GET_IRN_ICR(port);
+		IFX_SSC_IRQ_UNLOCK(port);
+		seq_printf(s, "SSC%d\n", port->port_idx);
+		seq_printf(s, "IFX_SSC_CLC     0x%08x\n", stats[0]);
+		seq_printf(s, "IFX_SSC_ID      0x%08x\n", stats[1]);
+		seq_printf(s, "IFX_SSC_MCON    0x%08x\n", stats[2]);
+		seq_printf(s, "IFX_SSC_STATE   0x%08x\n", stats[3]);
+		seq_printf(s, "IFX_SSC_TB      0x%08x\n", stats[4]);
+		seq_printf(s, "IFX_SSC_FSTAT   0x%08x\n", stats[5]);
+		seq_printf(s, "IFX_SSC_RXFCON  0x%08x\n", stats[6]);
+		seq_printf(s, "IFX_SSC_TXFCON  0x%08x\n", stats[7]);
+		seq_printf(s, "IFX_SSC_BR      0x%08x\n", stats[8]);
+		seq_printf(s, "IFX_SSC_SFCON   0x%08x\n", stats[9]);
+		seq_printf(s, "IFX_SSC_SFSTAT  0x%08x\n", stats[10]);
+		seq_printf(s, "IFX_SSC_GPOCON  0x%08x\n", stats[11]);
+		seq_printf(s, "IFX_SSC_GPOSTAT 0x%08x\n", stats[12]);
+		seq_printf(s, "IFX_SSC_RXREQ   0x%08x\n", stats[13]);
+		seq_printf(s, "IFX_SSC_RXCNT   0x%08x\n", stats[14]);
+		seq_printf(s, "IFX_SSC_DMACON  0x%08x\n", stats[15]);
+		seq_printf(s, "IFX_SSC_IRN_EN  0x%08x\n", stats[16]);
+		seq_printf(s, "IFX_SSC_IRN_CR  0x%08x\n", stats[17]);
+		seq_printf(s, "IFX_SSC_IRN_ICR 0x%08x\n", stats[18]);
+		seq_puts(s, "\n");
+	}
+	return 0;
+#undef IFX_SSC_REG_MAX
+}
+static int ifx_ssc_reg_read_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ifx_ssc_reg_read_proc, NULL);
+}
+
+static const struct file_operations ifx_ssc_reg_proc_fops = {
+	.open           = ifx_ssc_reg_read_proc_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+/**
+ * \fn static void ifx_ssc_dma_setup(struct ifx_ssc_port *port, int dir, int enabled)
+ * \brief Setup dma direction and enable/disable
+ *
+ * \param   port        Pointer to structure #ifx_ssc_port
+ * \param   dir         DMA Direction, tx/rx, tx&rx
+ * \param   enabled     DMA enable/disable
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static void
+ifx_ssc_dma_setup(struct ifx_ssc_port *port, int dir, int enabled)
+{
+	u32 reg = 0;
+
+	IFX_SSC_IRQ_LOCK(port);
+	reg = IFX_SSC_GET_DMA_CON(port);
+	if (dir == IFX_SSC_DIR_RX) {	/* RX */
+		if (enabled)
+			reg |= IFX_SSC_DMACON_RXON;
+		else
+			reg &= ~IFX_SSC_DMACON_RXON;
+	} else if (dir == IFX_SSC_DIR_TX) {
+		if (enabled)
+			reg |= IFX_SSC_DMACON_TXON;
+		else
+			reg &= ~IFX_SSC_DMACON_TXON;
+	} else {
+		if (enabled)
+			reg |= (IFX_SSC_DMACON_TXON | IFX_SSC_DMACON_RXON);
+		else
+			reg &= ~(IFX_SSC_DMACON_TXON |
+				 IFX_SSC_DMACON_RXON);
+	}
+	IFX_SSC_SET_DMA_CON(reg, port);
+	IFX_SSC_IRQ_UNLOCK(port);
+}
+
+/**
+ * \fn static INLINE void ifx_ssc_dma_irq_finished(struct ifx_ssc_port *port)
+ * \brief DMA<TX/RX> interrupt received, this function calls to reschedule or
+ *        wake up sleep kernel thread
+ *
+ * \param   port        Pointer to structure #ifx_ssc_port
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static INLINE void ifx_ssc_dma_irq_finished(struct ifx_ssc_port *port)
+{
+	/*
+	 * Reset the flag that we are waiting for the DMA to complete
+	 * This flag should be reset before the following stuff, otherwise
+	 * start_tasklet will stop
+	 */
+	atomic_set(&port->dma_wait_state, 0);
+	smp_wmb();
+#ifdef CONFIG_LANTIQ_SPI_ASYNCHRONOUS
+	ifx_ssc_start_tasklet(port);
+#else
+	IFX_SSC_WAKEUP_EVENT(port->ssc_thread_wait, IFX_SSC_THREAD_EVENT,
+		port->event_flags);
+#endif
+}
+
+/**
+ * \fn static int ifx_ssc_dma_int_handler( struct dma_device_info* dma_dev,
+ *                                         int status)
+ * \brief Pseudo Interrupt handler for DMA.
+ * This function processes DMA interrupts notified to the SSC device driver.
+ * It is installed at the DMA core as interrupt handler for the SSC DMA device
+ * and handles the following DMA interrupts:
+ * - In case of a DMA receive interrupt the received data is passed to the
+ *   upper layer.
+ *
+ * \param   dma_dev pointer to DMA device structure
+ * \param   status  type of interrupt being notified (RCV_INT: DMA receive
+ *                  interrupt, TX_BUF_FULL_INT: transmit buffer full interrupt,
+ *                  TRANSMIT_CPT_INT: transmission complete interrupt)
+ * \return  OK      In case of successful data reception from DMA
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int
+ifx_ssc_dma_int_handler(struct dma_device_info *dma_dev, int status)
+{
+	int i;
+	struct ifx_ssc_port *port;
+	u32 dma_burst_len;
+	u32 dma_burst_len_mask;
+	port = (struct ifx_ssc_port *) dma_dev->priv;
+
+	IFX_SSC_PRINT(port, SSC_MSG_INT, "Interrupt status %d\n", status);
+	switch (status) {
+	case RCV_INT:
+		IFX_SSC_PRINT(port, SSC_MSG_INT, "RCV_INT\n");
+		dma_burst_len = (dma_dev->rx_burst_len << 2);
+		dma_burst_len_mask = dma_burst_len - 1;
+		ifx_ssc_dma_setup(port, IFX_SSC_DIR_RX, IFX_SSC_DMA_DISABLE);
+
+		/*
+		 * NB, we have to reset SPI DMA Rx channel every time, just it
+		 * is not enough to clear the central DMA global dma status
+		 * variable. Because we should clear the DMA channel interrupt
+		 * status bit at the same time. However, if we don't reset
+		 * DMA descriptor because upper layer application may not take
+		 * the data yet. Therefore, DMA tasklet will continue to raise
+		 * pseudo interrupt. In order to reach the above two goals, it
+		 * is the most simple to close the channel. It will be openned
+		 * again when some data need to receive.
+		 */
+		(dma_dev->rx_chan[dma_dev->current_rx_chan])->
+			reset(dma_dev->rx_chan[dma_dev->current_rx_chan]);
+
+		/* HW WAR, if packet length is indivisible by burst length,
+		 * memory copy must be used */
+		if ((port->actual_rx_len & dma_burst_len_mask)) {
+			memcpy((char *) port->rxbuf_ptr, port->dma_rxbuf,
+				port->actual_rx_len);
+			/* Reset these for FIFO usage */
+			port->rxbuf_ptr = NULL;
+			port->actual_rx_len = 0;
+		}
+		ifx_ssc_dma_irq_finished(port);
+		break;
+
+	case TX_BUF_FULL_INT:
+		for (i = 0; i < dma_dev->max_tx_chan_num; i++) {
+			if ((dma_dev->tx_chan[i])->control == IFX_DMA_CH_ON) {
+				dma_dev->tx_chan[i]->enable_irq
+					(dma_dev->tx_chan[i]);
+			}
+		}
+		IFX_SSC_PRINT(port, SSC_MSG_INT, "TX_BUF_FULL_INT\n");
+		break;
+
+	case TRANSMIT_CPT_INT:
+		for (i = 0; i < dma_dev->max_tx_chan_num; i++)
+			dma_dev->tx_chan[i]->disable_irq(dma_dev->tx_chan[i]);
+
+		IFX_SSC_PRINT(port, SSC_MSG_INT, "TRANSMIT_CPT_INT\n");
+
+		/* 1. XXX, where is the best place because of HW limitation
+		 * NB, all cases should wait because it just indicates DMA has
+		 * finished transfered data to SSC FIFO, but the data could be
+		 * still in SSC FIFO.
+		 * 2. If FDX is used, only RCV_INT will schedule the proccess/
+		 * tasklet. HDX device may use FDX mode for RX operation.
+		 * However, for TX, only HDX can be used for HDX device.
+		 */
+		if (port->dma_is_in_half_duplex == 1) {
+			ifx_ssc_wait_finished(port);
+			ifx_ssc_dma_irq_finished(port);
+		}
+		break;
+
+	default:
+		pr_err("%s unknow interrupt %d\n", __func__,
+			status);
+		break;
+	}
+	return 0;
+}
+
+/**
+ * \fn static u8* ifx_ssc_dma_buffer_alloc(int len, int* byte_offset,
+ *                                         void** opt)
+ * \brief Allocates buffer for SSC DMA.
+ * This function is installed as DMA callback function to be called
+ * when the DMA needs to allocate a new buffer.
+ *
+ * \param   len          Length of packet
+ * \param   byte_offset Pointer to byte offset
+ * \param   opt        unused
+ * \return  NULL         In case of buffer allocation fails
+ * \return  buffer       Pointer to allocated memory
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static u8 *ifx_ssc_dma_buffer_alloc(int len, int *byte_offset, void **opt)
+{
+	return NULL;
+}
+
+/**
+ * \fn static int ifx_ssc_dma_buffer_free(u8* dataptr,void* opt)
+ * \brief Free DMA buffer.
+ * This function frees a buffer previously allocated by the DMA.
+ *
+ * \param   dataptr Pointer to data buffer
+ * \param   opt     unused
+ * \return  0        OK
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int ifx_ssc_dma_buffer_free(u8 *dataptr, void *opt)
+{
+	/* SPI will be in charge of memory free if necessary */
+	return 0;
+}
+
+/**
+ * \fn static int ifx_ssc_init_dma_device(int line, struct dma_device_info *dma_dev)
+ * \brief InitializeSC DMA device.
+ * This function initializes the passed DMA device structure for usage as
+ * SSC DMA device.
+ *
+ * \param   line     SSC device (0)
+ * \param   dma_dev Pointer to dma device structure to be initialized
+ * \return  0        OK
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int
+ifx_ssc_init_dma_device(int line, struct dma_device_info *dma_dev)
+{
+	int i;
+
+	dma_dev->priv = &ifx_ssc_isp[line];
+	dma_dev->num_tx_chan = DEFAULT_SSC_TX_CHANNEL_NUM;
+	dma_dev->num_rx_chan = DEFAULT_SSC_RX_CHANNEL_NUM;
+	dma_dev->tx_burst_len = DEFAULT_SSC_TX_BURST_LEN;
+	dma_dev->rx_burst_len = DEFAULT_SSC_RX_BURST_LEN;
+	dma_dev->port_tx_weight = 1;
+	dma_dev->tx_endianness_mode = IFX_DMA_ENDIAN_TYPE0;
+	dma_dev->rx_endianness_mode = IFX_DMA_ENDIAN_TYPE0;
+	dma_dev->port_packet_drop_enable = 0;
+	for (i = 0; i < dma_dev->num_tx_chan; i++) {
+		dma_dev->tx_chan[i]->desc_len =
+			DEFAULT_SSC_TX_CHANNEL_DESCR_NUM;
+		dma_dev->tx_chan[i]->control = IFX_DMA_CH_ON;
+		dma_dev->tx_chan[i]->packet_size = DEFAULT_SSC_FRAGMENT_SIZE;
+
+	}
+	for (i = 0; i < dma_dev->num_rx_chan; i++) {
+		dma_dev->rx_chan[i]->desc_len =
+			DEFAULT_SSC_RX_CHANNEL_DESCR_NUM;
+		dma_dev->rx_chan[i]->packet_size = DEFAULT_SSC_FRAGMENT_SIZE;
+		dma_dev->rx_chan[i]->control = IFX_DMA_CH_ON;
+		dma_dev->rx_chan[i]->byte_offset = 0;
+	}
+	dma_dev->current_tx_chan = 0;
+	dma_dev->current_rx_chan = 0;
+	/*
+	 * set DMA handler functions for rx-interrupts,
+	 * buffer allocation and release
+	 */
+	dma_dev->intr_handler = ifx_ssc_dma_int_handler;
+	dma_dev->buffer_alloc = ifx_ssc_dma_buffer_alloc;
+	dma_dev->buffer_free = ifx_ssc_dma_buffer_free;
+	dma_device_register(dma_dev);
+	return 0;
+}
+
+/**
+ * \fn static INLINE int ifx_ssc_rxtx_mode_set(struct ifx_ssc_port *port,
+ *                                             unsigned int val)
+ * \brief Rx/Tx mode set.
+ * Set the transmission mode while SSC is idle
+ *
+ * \param   port    Pointer to structure #ifx_ssc_port
+ * \param   val     Rx/Tx mode
+ * \return  0       OK
+ * \return  -EINVAL Invalid parameters supplied
+ * \return  -EBUSY  Transmission or reception ongoing
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static INLINE int
+ifx_ssc_rxtx_mode_set(struct ifx_ssc_port *port, unsigned int val)
+{
+	u32 reg;
+
+	if (!(port) || (val & ~(IFX_SSC_MODE_MASK)))
+		return -EINVAL;
+
+	/* check BUSY and RXCNT */
+	if ((IFX_SSC_GET_STATE(port) & IFX_SSC_STATE_BUSY)) {
+		pr_err("%s state busy\n", __func__);
+		return -EBUSY;
+	}
+	if (IFX_SSC_RX_TO_RECEIVED(port)) {
+		pr_err("%s rx todo busy\n", __func__);
+		return -EBUSY;
+	}
+	IFX_SSC_IRQ_LOCK(port);
+	reg = IFX_SSC_GET_CON(port);
+	reg &= ~(IFX_SSC_CON_RX_OFF | IFX_SSC_CON_TX_OFF);
+	reg |= val;
+	IFX_SSC_SET_CON(reg, port);
+	port->opts.modeRxTx = val;
+	IFX_SSC_IRQ_UNLOCK(port);
+	return 0;
+}
+
+/**
+ * \fn static int ifx_ssc_sethwopts(struct ifx_ssc_port *port)
+ * \brief SSC set hardware options.
+ * This routine intializes the SSC appropriately depending on slave/master and
+ * full-/half-duplex mode. It assumes that the SSC is disabled and the fifo's
+ * and buffers are flushed later on.
+ *
+ * \param   port    Pointer to structure #ifx_ssc_port
+ * \return  0       OK
+ * \return  -EINVAL Invalid hardware options supplied
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int ifx_ssc_sethwopts(struct ifx_ssc_port *port)
+{
+	unsigned long bits;
+	u32 reg;
+	struct ifx_ssc_hwopts *opts = &port->opts;
+
+	/* sanity checks */
+	if ((opts->dataWidth < IFX_SSC_MIN_DATA_WIDTH) ||
+	    (opts->dataWidth > IFX_SSC_MAX_DATA_WIDTH)) {
+		pr_err("%s: sanity check failed\n", __func__);
+		return -EINVAL;
+	}
+	bits = IFX_SSC_ENCODE_DATA_WIDTH(opts->dataWidth);
+	/* TXB+2, TXB+3 trigger FPI Addr */
+	bits |= IFX_SSC_CON_ENABLE_BYTE_VALID;
+
+	if (opts->rxOvErrDetect)
+		bits |= IFX_SSC_CON_RX_OFL_CHECK;
+	if (opts->rxUndErrDetect)
+		bits |= IFX_SSC_CON_RX_UFL_CHECK;
+	if (opts->txOvErrDetect)
+		bits |= IFX_SSC_CON_TX_OFL_CHECK;
+	if (opts->txUndErrDetect)
+		bits |= IFX_SSC_CON_TX_UFL_CHECK;
+	if (opts->loopBack)
+		bits |= IFX_SSC_CON_LOOPBACK_MODE;
+	if (opts->echoMode)
+		bits |= IFX_SSC_CON_ECHO_MODE_ON;
+	if (opts->headingControl)
+		bits |= IFX_SSC_CON_MSB_FIRST;
+	if (opts->clockPhase)
+		bits |= IFX_SSC_CON_PH;
+	if (opts->clockPolarity)
+		bits |= IFX_SSC_CON_PO;
+	switch (opts->modeRxTx) {
+	case IFX_SSC_MODE_TX:
+		bits |= IFX_SSC_CON_RX_OFF;
+		break;
+	case IFX_SSC_MODE_RX:
+		bits |= IFX_SSC_CON_TX_OFF;
+		break;
+	}
+	IFX_SSC_IRQ_LOCK(port);
+	IFX_SSC_SET_CON(bits, port);
+
+	reg = (port->opts.gpoCs << IFX_SSC_GPOCON_ISCSB0_POS) |
+		(port->opts.gpoInv << IFX_SSC_GPOCON_INVOUT0_POS);
+
+	IFX_SSC_SET_GPOCON(reg, port);
+
+	reg = port->opts.gpoCs << IFX_SSC_WHBGPOSTAT_SETOUT0_POS;
+
+	IFX_SSC_SET_FGPO(reg, port);
+
+	if (opts->masterSelect)
+		reg = IFX_SSC_WHBSTATE_MASTER_MODE;
+	else
+		reg = IFX_SSC_WHBSTATE_SLAVE_MODE;
+	IFX_SSC_SET_WHBSTATE(reg, port);
+	IFX_SSC_IRQ_UNLOCK(port);
+	port->tx_fifo_size_words = IFX_SSC_TX_FIFO_SIZE(port);
+	port->tx_fifo_size_bytes = port->tx_fifo_size_words << 2;
+	port->rx_fifo_size_words = IFX_SSC_RX_FIFO_SIZE(port);
+	port->rx_fifo_size_bytes = port->rx_fifo_size_words << 2;
+
+	return 0;
+}
+
+/**
+ * \fn int ifx_ssc_cs_low(u32 pin)
+ * \brief Chip select enable.
+ * This function sets the given chip select for SSC0 to low.
+ *
+ * \param   pin      Selected CS pin
+ * \return  0        OK
+ * \return  -EINVAL  Invalid GPIO pin provided
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int ifx_ssc_cs_low(u32 pin)
+{
+	int ret;
+	u32 reg;
+
+	struct ifx_ssc_port *port = &ifx_ssc_isp[0]; /* XXX */
+
+	if (pin > IFX_SSC_MAX_GPO_OUT)
+		ret = -EINVAL;
+	else {
+		reg = (1 << (pin + IFX_SSC_WHBGPOSTAT_CLROUT0_POS));
+		IFX_SSC_IRQ_LOCK(port);
+		IFX_SSC_SET_FGPO(reg, port);
+		IFX_SSC_IRQ_UNLOCK(port);
+		smp_wmb();
+		ret = 0;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(ifx_ssc_cs_low);
+
+/**
+ * \fn int ifx_ssc_cs_high(u32 pin)
+ * \brief Chip select disable.
+ * This function sets the given chip select for SSC0 to high.
+ *
+ * \param   pin      Selected CS pin
+ * \return  0        OK
+ * \return  -EINVAL  Invalid GPIO pin provided
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int ifx_ssc_cs_high(u32 pin)
+{
+	int ret;
+	u32 reg;
+
+	struct ifx_ssc_port *port = &ifx_ssc_isp[0];/* XXX */
+
+	if (pin > IFX_SSC_MAX_GPO_OUT)
+		ret = -EINVAL;
+	else {
+		/* XXX, at least half of cycle of baudrate delay is needed */
+		udelay(1);
+		reg = 1 << (pin + IFX_SSC_WHBGPOSTAT_SETOUT0_POS);
+		IFX_SSC_IRQ_LOCK(port);
+		IFX_SSC_SET_FGPO(reg, port);
+		IFX_SSC_IRQ_UNLOCK(port);
+		smp_wmb();
+		ret = 0;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(ifx_ssc_cs_high);
+
+/**
+ * \fn static int ifx_ssc_set_baudrate (struct ifx_ssc_port *port,
+ *                                      unsigned int baudrate)
+ * \brief SSC set baudrate.
+ * Sets the baudrate of the corresponding port according to the passed
+ * rate after reading out the current module speed.
+ *
+ * \param   port    Pointer to structure #ifx_ssc_port
+ * \param   baudrate  Desired baudrate
+ * \return  0       OK
+ * \return  -EINVAL Could not retrieve system clock or invalid baudrate setting
+ * \ingroup IFX_SSC_INTERNAL
+ */
+
+#define IFX_GPHY1_CFG                            0x0040
+#define IFX_SSC_HIGH_BAUD_DELAY_MASK             0x00000060
+#define IFX_SSC_HIGH_BAUD_DELAY_TWO_HALF_CLOCK   0x00000020
+#define IFX_SSC_HIGH_BAUD_DELAY_THREE_CLOCK      0x00000040
+#define IFX_SSC_HIGH_BAUD_DELAY_THREE_HALF_CLOCK 0x00000060
+
+static int
+ifx_ssc_set_baudrate(struct ifx_ssc_port *port, unsigned int baudrate)
+{
+	unsigned int ifx_ssc_clock;
+	unsigned int br;
+	int enabled;
+
+	ifx_ssc_clock = ifx_ssc_get_kernel_clk(port);
+	if (ifx_ssc_clock == 0)
+		return -EINVAL;
+
+	/* Baud rate or kernel clock change needs to calculate the new
+	 * baud rate */
+	if ((port->prev_baudrate == baudrate)
+	    && (port->prev_ssc_clk == ifx_ssc_clock))
+		return 0;
+	if (of_machine_is_compatible("lantiq,vr9")) {
+		if (ltq_get_soc_type() == SOC_TYPE_VR9_2) {
+			/* VR9 A21 high baudrate support */
+			u32 reg;
+
+			IFX_SSC_IRQ_LOCK(port);
+			if (baudrate > IFX_SSC_SPLIT_BAUD_RATE) {
+				reg = ltq_cgu_r32(IFX_GPHY1_CFG);
+				reg &= ~IFX_SSC_HIGH_BAUD_DELAY_MASK;
+				reg |= IFX_SSC_HIGH_BAUD_DELAY_THREE_CLOCK;
+				ltq_cgu_w32(reg, IFX_GPHY1_CFG);
+			} else {
+				reg = ltq_cgu_r32(IFX_GPHY1_CFG);
+				reg &= ~IFX_SSC_HIGH_BAUD_DELAY_MASK;
+				ltq_cgu_w32(reg, IFX_GPHY1_CFG);
+			}
+			IFX_SSC_IRQ_UNLOCK(port);
+		}
+	}
+
+	/* Compute divider */
+	br = (((ifx_ssc_clock >> 1) + baudrate / 2) / baudrate) - 1;
+	if (br > 0xffff || ((br == 0) &&
+		(IFX_SSC_GET_STATE(port) &
+		IFX_SSC_STATE_MASTER))) {
+		pr_err("%s: illegal baudrate %u br %d\n",
+			__func__, baudrate, br);
+		return -EINVAL;
+	}
+	IFX_SSC_IRQ_LOCK(port);
+	/* Have to disable theSC to set the baudrate */
+	enabled =
+		(IFX_SSC_GET_STATE(port) & IFX_SSC_STATE_ENABLED) ? 1 : 0;
+
+	IFX_SSC_CONFIG_MODE(port);
+
+	IFX_SSC_SET_BR(br, port);
+	smp_wmb();
+	if (of_machine_is_compatible("lantiq,ar10")
+		|| of_machine_is_compatible("lantiq,grx390")) {
+		u32 reg;
+
+		if (baudrate > IFX_SSC_SPLIT_BAUD_RATE) {
+			reg = IFX_SSC_GET_CON(port);
+			reg &= ~IFX_SSC_CON_CLK_DELAY;
+			reg |= SM(IFX_SSC_CON_CLK_DELAY_DEFAULT,
+				  IFX_SSC_CON_CLK_DELAY);
+			IFX_SSC_SET_CON(reg, port);
+		} else {
+			reg = IFX_SSC_GET_CON(port);
+			reg &= ~IFX_SSC_CON_CLK_DELAY;
+			IFX_SSC_SET_CON(reg, port);
+		}
+	}
+	if (enabled)
+		IFX_SSC_RUN_MODE(port);
+
+	IFX_SSC_IRQ_UNLOCK(port);
+	port->prev_baudrate = baudrate;
+	port->baudrate = baudrate;
+	port->prev_ssc_clk = ifx_ssc_clock;
+	return 0;
+}
+
+/**
+ * \fn static int ifx_ssc_hwinit (struct ifx_ssc_port *port)
+ * \brief SSC hardware initialization.
+ * Initializes the SSC port hardware with the desired baudrate and transmission
+ * options.
+ *
+ * \param   port    Pointer to structure #ifx_ssc_port
+ * \return  0       OK
+ * \return  -EINVAL Error during initialization
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int ifx_ssc_hwinit(struct ifx_ssc_port *port)
+{
+	u32 reg;
+	int enabled;
+
+	/* have to disable the SSC */
+	enabled =
+		(IFX_SSC_GET_STATE(port) & IFX_SSC_STATE_ENABLED) ? 1 : 0;
+
+	IFX_SSC_CONFIG_MODE(port);
+	if (ifx_ssc_sethwopts(port) < 0) {
+		pr_err("%s: setting the hardware options failed\n", __func__);
+		return -EINVAL;
+	}
+
+	if (ifx_ssc_set_baudrate(port, port->baudrate) < 0) {
+		pr_err("%s: setting the baud rate failed\n", __func__);
+		return -EINVAL;
+	}
+	IFX_SSC_IRQ_LOCK(port);
+	/*
+	 * With this setting it is assured, that if the DMA stalls (RX cannot
+	 * write data and TX cannot read data) at a certain point in time,
+	 * only one additional TX burst (2 words) + one word from the burst
+	 * that is just processing at maximum will be forwarded by the SSC TX
+	 * FIFO towards the line side. In this case I assume that at maximum
+	 * 4 words should be available within the RX FIFO (2 words from ongoing
+	 * TX burst + 2 additional words from the last TX burst requested
+	 * before the DMA stall (requested as the TX FIFO level reached 1).
+	 * In worst case timing may be 6 words remain within the RX FIFO,
+	.* but at least we should not face any overflow.
+	 */
+
+	/* TX FIFO filling level, half of FIFO size */
+	reg = SM(1 /*(port->tx_fifo_size_words >> 1) */ ,
+		 IFX_SSC_XFCON_ITL) |
+		IFX_SSC_XFCON_FIFO_FLUSH | IFX_SSC_XFCON_FIFO_ENABLE;
+	IFX_SSC_TX_FIFO_CTRL(reg, port);
+
+	/* RX FIFO filling level, half of FIFO size */
+	if (port->dma_support) {
+		/* Change to DMA RX trigger level to 2 to trigger DMA earlier
+		 * half FIFO size will be stuck */
+		reg = SM(2, IFX_SSC_XFCON_ITL);
+	} else
+		reg = SM((port->rx_fifo_size_words >> 1), IFX_SSC_XFCON_ITL);
+
+	reg |= IFX_SSC_XFCON_FIFO_FLUSH | IFX_SSC_XFCON_FIFO_ENABLE;
+	IFX_SSC_RX_FIFO_CTRL(reg, port);
+	if (enabled)
+		IFX_SSC_RUN_MODE(port);
+
+	IFX_SSC_IRQ_UNLOCK(port);
+	return 0;
+}
+
+/**
+ * \fn static int ifx_ssc_start_rx_last_word(struct ifx_ssc_port *port,
+ *                                           char *buf, size_t size)
+ * \brief Called to transmit last word <1 ~ 4> bytes for full duplex operation.
+ *
+ * \param   port       Pointer to structure #ifx_ssc_port
+ * \param   buf        Pointer to store the received data packet
+ * \param   size       Amount of bytes to receive
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static void
+ifx_ssc_start_rx_last_word(struct ifx_ssc_port *port, char *buf, size_t size)
+{
+	int i;
+	char *p;
+	int rx_cnt = size;
+	ifx_ssc_rxd_t rxd_data;
+
+	/* Last complete word or incomplete word */
+	rxd_data.rxd_word = IFX_SSC_GET_RX_WORD(port);
+	for (i = 4 - rx_cnt, p = (char *) buf; i < 4; i++, p++)
+		*(u8 *) p = rxd_data.rxd_byte.byte[i];
+}
+
+/**
+ * \fn static int ifx_ssc_start_tx_last_word(struct ifx_ssc_port *port,
+ *                                           char *buf, size_t size)
+ * \brief Called to transmit last word <1 ~ 4> bytes for full duplex operation.
+ *
+ * \param   port       Pointer to structure #ifx_ssc_port
+ * \param   buf        Pointer to the data packet to transmit
+ * \param   size       Amount of bytes to transmit
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static void
+ifx_ssc_start_tx_last_word(struct ifx_ssc_port *port, char *buf, size_t size)
+{
+	switch (size) {
+	case 1:
+		IFX_SSC_TX_BYTE(*(u8 *) buf, port);
+		break;
+	case 2:
+		IFX_SSC_TX_HALFWORD(*(u16 *) buf, port);
+		break;
+	case 3:
+		IFX_SSC_TX_HALFWORD(*(u16 *) buf, port);
+		IFX_SSC_TX_BYTE(*(u8 *) (buf + 2), port);
+		break;
+	case 4:
+		IFX_SSC_TX_WORD(*(u32 *) buf, port);
+		break;
+	default:
+		break;
+	}
+}
+
+/**
+ * \fn static void ifx_ssc_start_txfifo(struct ifx_ssc_port *port)
+ * \brief Start FIFO data transmision.
+ * This function copies remaining data in the transmit buffer into the FIFO
+ *
+ * \param   port     Pointer to structure #ifx_ssc_port
+ * \return  number of bytes transmitted
+ * Description:
+ * If txsize is not equal to zero, ssc driver will generate dummy data according
+ * to different cases.
+ * If txsize is equal to zero, just send dummy data whose length is equal to
+ * rxsize for clock generation.
+ * \ingroup IFX_SSC_INTERNAL
+ */
+
+static int
+ifx_ssc_start_txfifo(struct ifx_ssc_port *port, char *txbuf, size_t txsize)
+{
+	int i;
+	char *p;
+	u32 eff_bytes, eff_word;
+	u32 tx_cnt;
+	u32 *ptxbuf;
+	int total = txsize;
+
+	ifx_ssc_dma_setup(port, IFX_SSC_DIR_TX, IFX_SSC_DMA_DISABLE);
+	IFX_SSC_IRQ_LOCK(port);
+	while (1) {
+		/* Wait for TX FIFO empty */
+		while (IFX_SSC_TX_FIFO_FILL_LEVEL(port) != 0)
+			;
+
+		if (total <= 4) {
+			eff_bytes = total;
+			p = (char *) txbuf;
+			ifx_ssc_start_tx_last_word(port, p, eff_bytes);
+		} else if (total > port->tx_fifo_size_bytes) {
+			eff_bytes = port->tx_fifo_size_bytes;
+			eff_word = port->tx_fifo_size_words;
+			for (i = 0, ptxbuf = (u32 *) txbuf; i < eff_word;
+			     i++, ptxbuf++) {
+				IFX_SSC_TX_WORD(*ptxbuf, port);
+			}
+		} else { /* 5 ~ 32 bytes */
+			eff_bytes = total;
+			eff_word = (eff_bytes >> 2) + ((eff_bytes & 0x3) >
+				0 ? 1 : 0);
+
+			/* Transmit the complete word */
+			for (i = 0, ptxbuf = (u32 *) txbuf;
+			     i < eff_word - 1; i++, ptxbuf++) {
+				IFX_SSC_TX_WORD(*ptxbuf, port);
+			}
+
+			tx_cnt = (eff_bytes & 0x3);
+
+			/* Still one complete word */
+			if (tx_cnt == 0)
+				tx_cnt = 4;
+
+			ifx_ssc_start_tx_last_word(port, (char *) ptxbuf,
+				tx_cnt);
+		}
+		txbuf += eff_bytes;
+		total -= eff_bytes;
+		if (total == 0)
+			break;
+	}
+	IFX_SSC_IRQ_UNLOCK(port);
+	return txsize;
+}
+
+/**
+ * \fn static void ifx_ssc_start_rxfifo(struct ifx_ssc_port *port)
+ * \brief Start FIFO data reception.
+ * This function processes received data. It will read data from the FIFO
+ *
+ * \param   port     Pointer to structure #ifx_ssc_port
+ * \return  number of bytes received
+ * Description:
+ * In Tx/Rx mode, to void memory copy, where rx data starts must be determined
+ * several special cases
+ * 1) If txsize is divisable by 4, all tx data will be skipped.
+ * 2) If txsize is not divisable by 4,including less than 4 bytes.
+ * The remaining 1~3 bytes have to do swap.
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int
+ifx_ssc_start_rxfifo(struct ifx_ssc_port *port, char *rxbuf, size_t rxsize)
+{
+	int i;
+	int rx_cnt;
+	u32 eff_word;
+	u32 eff_bytes;
+	u32 *prxbuf;
+	int total = rxsize;
+
+	ifx_ssc_dma_setup(port, IFX_SSC_DIR_RX, IFX_SSC_DMA_DISABLE);
+	IFX_SSC_IRQ_LOCK(port);
+	while (1) {
+		/* In this case, no need to check last complete or
+		 * incomplete word */
+		if (total >= port->rx_fifo_size_bytes) {
+			eff_bytes = port->rx_fifo_size_bytes;
+			eff_word = port->rx_fifo_size_words;
+
+			/* Configure RX request number to start receiving */
+			IFX_SSC_SET_RXREQ(eff_bytes, port);
+
+			while (IFX_SSC_RX_FIFO_FILL_LEVEL(port) != eff_word)
+				;
+
+			for (i = 0, prxbuf = (u32 *) rxbuf; i < eff_word;
+			     i++, prxbuf++) {
+				*prxbuf = IFX_SSC_GET_RX_WORD(port);
+			}
+		} else {
+			eff_bytes = total;
+			eff_word = (eff_bytes >> 2) + ((eff_bytes & 0x3) >
+				0 ? 1 : 0);
+
+			IFX_SSC_SET_RXREQ(eff_bytes, port);
+
+			while (IFX_SSC_RX_FIFO_FILL_LEVEL(port) != eff_word)
+				;
+
+			/* Receive complete word */
+			for (i = 0, prxbuf = (u32 *) rxbuf;
+			     i < eff_word - 1; i++, prxbuf++) {
+				*prxbuf = IFX_SSC_GET_RX_WORD(port);
+			}
+
+			/* SPI Master know how many bytes to be received */
+			rx_cnt = total - ((eff_word - 1) << 2);
+
+			ifx_ssc_start_rx_last_word(port, (char *) prxbuf,
+				rx_cnt);
+		}
+		total -= eff_bytes;
+		rxbuf += eff_bytes;
+		if (total == 0)
+			break;
+	}
+	IFX_SSC_IRQ_UNLOCK(port);
+	return rxsize;
+}
+
+/**
+ * \fn static int ifx_ssc_txrx_fifo_fdx(struct ifx_ssc_port *port, char *txbuf,
+ *                                      u32 txsize, char *rxbuf, u32 rxsize)
+ * \brief Called to transmit/receive to/from SSC in one step using FIFO mode.
+ *
+ * \param   port      Pointer to structure #ifx_ssc_port
+ * \param   txbuf     Pointer to the data packet to transmit
+ * \param   txsize    Amount of Bytes to transmit
+ * \param   rxbuf     Pointer to store the received data packet
+ * \param   rxsize    Amount of Bytes to receive.
+ * \return  >= 0      Number of bytes received (if rxbuf != 0) or transmitted
+ * \return  < 0       error number
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int
+ifx_ssc_txrx_fifo_fdx(struct ifx_ssc_port *port, char *txbuf, u32 txsize,
+		      char *rxbuf, u32 rxsize)
+{
+	int i;
+	int tx_fifo_space;
+	int rx_fill_space;
+	u32 txtotal = txsize;
+	u32 rxtotal = rxsize;
+	u32 eff_bytes, eff_word;
+	int tx_cnt, rx_cnt;
+	u32 *ptxbuf;
+	u32 *prxbuf;
+
+	ifx_ssc_dma_setup(port, IFX_SSC_DIR_TXRX, IFX_SSC_DMA_DISABLE);
+
+	IFX_SSC_IRQ_LOCK(port);
+	while (1) {
+
+		tx_fifo_space =
+			port->tx_fifo_size_words -
+			IFX_SSC_TX_FIFO_FILL_LEVEL(port);
+		/* No space, wait */
+		if (tx_fifo_space == 0)
+			continue;
+
+		/* Still have more data to transmit, whole words */
+		if (txtotal > (tx_fifo_space << 2)) {
+			eff_bytes = (tx_fifo_space << 2);
+			eff_word = tx_fifo_space;
+			for (i = 0, ptxbuf = (u32 *) txbuf; i < eff_word;
+			     i++, ptxbuf++) {
+				IFX_SSC_TX_WORD(*ptxbuf, port);
+			}
+		} else {
+			eff_bytes = txtotal;
+			eff_word = (eff_bytes >> 2) + ((eff_bytes & 0x3) >
+					0 ? 1 : 0);
+
+			/* Transmit the complete word */
+			for (i = 0, ptxbuf = (u32 *) txbuf;
+			     i < eff_word - 1; i++, ptxbuf++) {
+				IFX_SSC_TX_WORD(*ptxbuf, port);
+			}
+
+			tx_cnt = (eff_bytes & 0x3);
+
+			/* Still one complete word */
+			if (tx_cnt == 0)
+				tx_cnt = 4;
+
+			ifx_ssc_start_tx_last_word(port, (char *) ptxbuf,
+				tx_cnt);
+		}
+		txbuf += eff_bytes;
+		txtotal -= eff_bytes;
+
+		/* NB, wait for data to come in, not efficient,
+		 * but no RX overrun issue */
+		while (IFX_SSC_RX_FIFO_FILL_LEVEL(port) != eff_word)
+			;
+
+		rx_fill_space = IFX_SSC_RX_FIFO_FILL_LEVEL(port);
+
+		if (rxtotal > (rx_fill_space << 2)) {
+			eff_bytes = (rx_fill_space << 2);
+			eff_word = rx_fill_space;
+			for (i = 0, prxbuf = (u32 *) rxbuf; i < eff_word;
+			     i++, prxbuf++) {
+				*prxbuf = IFX_SSC_GET_RX_WORD(port);
+			}
+		} else {	/* At least one word */
+			eff_bytes = rxtotal;
+			eff_word = (eff_bytes >> 2) + ((eff_bytes & 0x3) >
+					0 ? 1 : 0);
+			/* Receive complete word */
+			for (i = 0, prxbuf = (u32 *) rxbuf;
+			     i < eff_word - 1; i++, prxbuf++) {
+				*prxbuf = IFX_SSC_GET_RX_WORD(port);
+			}
+			/* SPI Master know how many bytes to be received */
+			rx_cnt = rxtotal - ((eff_word - 1) << 2);
+			ifx_ssc_start_rx_last_word(port, (char *) prxbuf,
+				rx_cnt);
+		}
+		rxbuf += eff_bytes;
+		rxtotal -= eff_bytes;
+
+		/* Both RX/TX finished, break */
+		if ((txtotal == 0) && (rxtotal == 0))
+			break;
+	}
+	IFX_SSC_IRQ_UNLOCK(port);
+	return txsize;
+}
+
+/**
+ * \fn static INLINE int ifx_ssc_txfifo(struct ifx_ssc_port *port,
+ *                                      char *txbuf, u32 txsize)
+ * \brief Called to transmit data to SSC using FIFO mode.
+ * \param   port       Pointer to structure #ifx_ssc_port
+ * \param   txbuf     Pointer to the data packet to transmit
+ * \param   txsize     Amount of Bytes to transmit
+ * \return  >= 0       Number of bytes transmitted
+ * \return  < 0        error number
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static INLINE int
+ifx_ssc_txfifo(struct ifx_ssc_port *port, char *txbuf, u32 txsize)
+{
+	SSC_KASSERT(port->opts.modeRxTx == IFX_SSC_MODE_TX,
+		("%s invalid txrx mode\n", __func__));
+	return ifx_ssc_start_txfifo(port, txbuf, txsize);
+}
+
+/**
+ * \fn static INLINE int ifx_ssc_rxfifo(struct ifx_ssc_port *port,
+ *                                      char *rxbuf, u32 rxsize)
+ * \brief   Called to receive from SSC using FIFO mode.
+ * \param   port       Pointer to structure #ifx_ssc_port
+ * \param   rxbuf      Pointer to store the received data packet
+ * \param   rxsize     Amount of Bytes to receive.
+ * \return  >= 0       Number of bytes received
+ * \return  < 0        error number
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static INLINE int
+ifx_ssc_rxfifo(struct ifx_ssc_port *port, char *rxbuf, u32 rxsize)
+{
+	SSC_KASSERT(port->opts.modeRxTx == IFX_SSC_MODE_RX,
+		("%s invalid txrx mode\n", __func__));
+	return ifx_ssc_start_rxfifo(port, rxbuf, rxsize);
+}
+
+/**
+ * \fn static INLINE int ifx_ssc_set_spi_mode(ssc_device_t *dev)
+ * \brief SSC set ssc_ mode
+ * Sets the spi mode of the corresponding device. SSC mode is per device
+ *      parameter. It is initialized during registeration
+ *
+ * \param   dev    Pointer to device
+ * \return  0       OK
+ * \return  -EBUSY  could not set ssc mode because the system is busy
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static INLINE int ifx_ssc_set_spi_mode(ssc_device_t *dev)
+{
+	u32 reg;
+	int val = IFX_SSC_CON_PH;
+
+	IFX_SSC_CONFIGURE_t *ssc_cfg;
+	struct ifx_ssc_port *port;
+
+	ssc_cfg = &dev->conn_id;
+	port = dev->port;
+
+	if (port->prev_ssc_mode == ssc_cfg->ssc_mode)
+		return 0;
+
+	if ((IFX_SSC_GET_STATE(port) & IFX_SSC_STATE_BUSY)
+		|| IFX_SSC_RX_TO_RECEIVED(port) > 0) {
+		pr_err("%s failed to set spi mode\n", __func__);
+		return -EBUSY;
+	}
+	switch (ssc_cfg->ssc_mode) {
+	case IFX_SSC_MODE_0:
+		val = IFX_SSC_CON_PH;
+		break;
+
+	case IFX_SSC_MODE_1:
+		val = 0;
+		break;
+
+	case IFX_SSC_MODE_2:
+		val = IFX_SSC_CON_PO | IFX_SSC_CON_PH;
+		break;
+
+	case IFX_SSC_MODE_3:
+		val = IFX_SSC_CON_PO;
+		break;
+
+	default:
+		break;
+	}
+	IFX_SSC_IRQ_LOCK(port);
+
+	IFX_SSC_CONFIG_MODE(port);
+
+	reg = IFX_SSC_GET_CON(port);
+	reg &= ~(IFX_SSC_CON_PO | IFX_SSC_CON_PH);
+	reg |= (val);
+	IFX_SSC_SET_CON(reg, port);
+	smp_wmb();
+	IFX_SSC_RUN_MODE(port);
+	IFX_SSC_IRQ_UNLOCK(port);
+	port->prev_ssc_mode = ssc_cfg->ssc_mode;
+	return 0;
+}
+
+/**
+ * \fn static INLINE void ifx_ssc_txrx_setup( struct ifx_ssc_port *port)
+ * \brief SSC set txrx direction if using FIFO mode.
+ * To use FIFO for transmission and reception. Firstly, rx/tx mode muse be set
+ *
+ * \param   port    Pointer to structure #ifx_ssc_port
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static INLINE void ifx_ssc_txrx_setup(struct ifx_ssc_port *port)
+{
+	if (port->opts.modeRxTx != IFX_SSC_MODE_RXTX)
+		ifx_ssc_rxtx_mode_set(port, IFX_SSC_MODE_RXTX);
+}
+
+/**
+ * \fn static INLINE void ifx_ssc_tx_setup( struct ifx_ssc_port *port)
+ * \brief SSC set Tx mode
+ *
+ * \param   port    Pointer to structure #ifx_ssc_port
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static INLINE void ifx_ssc_tx_setup(struct ifx_ssc_port *port)
+{
+	if (port->opts.modeRxTx != IFX_SSC_MODE_TX)
+		ifx_ssc_rxtx_mode_set(port, IFX_SSC_MODE_TX);
+}
+
+/**
+ * \fn static INLINE void ifx_ssc_rx_setup( struct ifx_ssc_port *port)
+ * \brief SSC set Rx mode
+ *
+ * \param   port    Pointer to structure #ifx_ssc_port
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static INLINE void ifx_ssc_rx_setup(struct ifx_ssc_port *port)
+{
+	if (port->opts.modeRxTx != IFX_SSC_MODE_RX)
+		ifx_ssc_rxtx_mode_set(port, IFX_SSC_MODE_RX);
+}
+
+/**
+ * \fn static void ifx_ssc_enqueue(IFX_SSC_QUEUE_t *queue)
+ * \brief SSC add queue entry to priority queue
+ *
+ * \param   queue    Pointer to structure #IFX_SSC_QUEUE_t
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static void ifx_ssc_enqueue(IFX_SSC_QUEUE_t *queue)
+{
+	ssc_device_t *dev;
+	struct ifx_ssc_port *port;
+
+	SSC_KASSERT((queue != NULL),
+		("%s should never happen\n", __func__));
+	dev = queue->dev;
+	port = dev->port;
+	IFX_SSC_PRINT(port, SSC_MSG_QUEUE, "%s dev %s prio %d enqueued\n",
+		__func__, dev->dev_name, dev->dev_prio);
+	IFX_SSC_Q_LOCK_BH(port);
+	if (dev->dev_prio == IFX_SSC_PRIO_ASYNC)
+		TAILQ_INSERT_TAIL(&port->ssc_asyncq, queue, q_next);
+	else
+		TAILQ_INSERT_TAIL(&port->ssc_syncq[dev->dev_prio], queue,
+				q_next);
+	dev->stats.enqueue++;
+	IFX_SSC_Q_UNLOCK_BH(port);
+}
+
+/**
+ * \fn static void ifx_ssc_dequeue(IFX_SSC_QUEUE_t *queue)
+ * \brief SSC remove queue entry from priority queue
+ *
+ * \param   queue    Pointer to structure #IFX_SSC_QUEUE_t
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static void ifx_ssc_dequeue(IFX_SSC_QUEUE_t *queue)
+{
+	ssc_device_t *dev;
+	struct ifx_ssc_port *port;
+
+	SSC_KASSERT((queue != NULL),
+		("%s should never happen\n", __func__));
+	dev = queue->dev;
+	port = dev->port;
+	IFX_SSC_PRINT(port, SSC_MSG_QUEUE, "%s dev %s prio %d dequeued\n",
+		__func__, dev->dev_name, dev->dev_prio);
+	IFX_SSC_Q_LOCK_BH(port);
+	if (dev->dev_prio == IFX_SSC_PRIO_ASYNC) {
+		if (!TAILQ_EMPTY(&port->ssc_asyncq))
+			TAILQ_REMOVE(&port->ssc_asyncq, queue, q_next);
+	} else {
+		if (!TAILQ_EMPTY(&port->ssc_syncq[dev->dev_prio]))
+			TAILQ_REMOVE(&port->ssc_syncq[dev->dev_prio],
+				queue, q_next);
+	}
+	dev->stats.dequeue++;
+	IFX_SSC_Q_UNLOCK_BH(port);
+}
+
+/**
+ * \fn static void ifx_ssc_cs_lock(ssc_device_t *dev)
+ * \brief SSC chip select function, set spi mode, baudrate, call registered
+ *     device-specific cs set function.
+ *
+ * \param   dev    Pointer to structure #ssc_device_t
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static void ifx_ssc_cs_lock(ssc_device_t *dev)
+{
+	IFX_SSC_CONFIGURE_t *ssc_cfg;
+	struct ifx_ssc_port *port;
+
+	port = dev->port;
+	if (port->ssc_cs_locked == true) {
+		pr_err("Fatal error: %s locked already before\n", __func__);
+		return;
+	}
+	IFX_SSC_PRINT(port, SSC_MSG_LOCK, "%s %s enter\n", __func__,
+		dev->dev_name);
+
+	port->ssc_cs_locked = true;
+	ssc_cfg = &dev->conn_id;
+	ifx_ssc_set_spi_mode(dev);
+	ifx_ssc_set_baudrate(port, ssc_cfg->baudrate);
+	if (ssc_cfg->csset_cb != NULL)
+		ssc_cfg->csset_cb(IFX_SSC_CS_ON, ssc_cfg->cs_data);
+}
+
+/**
+ * \fn static INLINE void ifx_ssc_cs_unlock(ssc_device_t *dev)
+ * \brief SSC chip un select function,  call registered device-specific cs reset
+ *        function.
+ *
+ * \param   dev    Pointer to structure #ssc_device_t
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static INLINE void ifx_ssc_cs_unlock(ssc_device_t *dev)
+{
+	IFX_SSC_CONFIGURE_t *ssc_cfg;
+	struct ifx_ssc_port *port;
+
+	port = dev->port;
+	if (port->ssc_cs_locked == false) {
+		pr_err("Fatal error: %s unlocked already before\n", __func__);
+		return;
+	}
+	ssc_cfg = &dev->conn_id;
+	if (ssc_cfg->csset_cb != NULL)
+		ssc_cfg->csset_cb(IFX_SSC_CS_OFF, ssc_cfg->cs_data);
+	port->ssc_cs_locked = false;
+	IFX_SSC_PRINT(port, SSC_MSG_LOCK, "%s %s exit\n", __func__,
+		dev->dev_name);
+}
+
+/**
+ *\fn int ifx_sscLock(IFX_SSC_HANDLE handler)
+ *\brief  Called to lock and reserve the whole SSC interface
+ * for the given 'handler'
+ *
+ * The chipselect, belonging to this SSC session is already
+ * activated. This means the chipselect callback is called.
+ * After complete data transmission and reception, ifx_sscUnLock
+ * has to be called to release the SSC interface again for
+ * other clients.
+ *
+ * \param   handler    Handle of the connection where to make the
+ *                     configuration on
+ * \return  0          Locked succesfully
+ * \return  -1         Failed to lock the ssc bus
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int ifx_sscLock(IFX_SSC_HANDLE handler)
+{
+	ssc_device_t *dev;
+	IFX_SSC_CONFIGURE_t *ssc_cfg;
+	struct ifx_ssc_port *port;
+	IFX_SSC_QUEUE_t *pqueue;
+
+	SSC_KASSERT((handler != NULL),
+		("%s Invalid parameter\n", __func__));
+
+	dev = (ssc_device_t *) handler;
+	pqueue = &dev->queue;
+	ssc_cfg = &dev->conn_id;
+	port = dev->port;
+
+	if (port->lock_qentry == pqueue)
+		return -1;
+
+	/*
+	 * Check if the queue entry of the ConnId is already queued with
+	 * a request but this request is not served yet. Every ConnId
+	 * can only queue up one request at one time.
+	 */
+	if (atomic_read(&pqueue->isqueued) == 1)
+		return -1;
+
+	IFX_SSC_Q_LOCK_BH(port);
+	/* Initialize unused variable */
+	pqueue->txbuf = NULL;
+	pqueue->txsize = 0;
+	pqueue->rxbuf = NULL;
+	pqueue->rxsize = 0;
+
+	/* Place a lock request in the queue */
+	pqueue->request_lock = true;
+	IFX_SSC_Q_UNLOCK_BH(port);
+	atomic_set(&pqueue->isqueued, 1);
+
+	/* Add queue entry to priority queue */
+	ifx_ssc_enqueue(pqueue);
+
+	/*
+	 * If no async support is avaiable, trigger the SSC kernel thread and
+	 * wait pending till job is done.
+	 */
+#ifdef CONFIG_LANTIQ_SPI_ASYNCHRONOUS
+	IFX_SSC_PRINT(port, SSC_MSG_TASKLET, "%s raise fake interrupt\n",
+		__func__);
+	ifx_ssc_start_tasklet(port);
+#else
+	IFX_SSC_PRINT(port, SSC_MSG_THREAD,
+		"%s wake up ssc kernel thread\n", __func__);
+	/* Kick off SSC kernel thread */
+	IFX_SSC_WAKEUP_EVENT(port->ssc_thread_wait, IFX_SSC_THREAD_EVENT,
+		port->event_flags);
+#endif
+	/* Wait till wake up from SSC kernel thread */
+	IFX_SSC_WAIT_EVENT(dev->dev_thread_wait, IFX_SSC_DEV_THREAD_EVENT,
+		dev->event_flags);
+	IFX_SSC_PRINT(port, SSC_MSG_THREAD,
+		"%s wakeup received from ssc kernel thread\n",
+		__func__);
+	return 0;
+}
+EXPORT_SYMBOL(ifx_sscLock);
+
+/**
+ *\fn int ifx_sscUnlock(IFX_SSC_HANDLE handler)
+ * \brief  This function releases the SSC lock that was placed before by
+ *         calling ifx_SscLock.
+ *
+ * This function also inactivate the chipselect signal, which was set in
+ * ifx_SscLock.
+ *
+ * \param   handler    Handle of the connection where to make the
+ *                     configuration on
+ * \return  0          UnLocked succesfully
+ * \return  -1         Failed to unlock the ssc bus
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int ifx_sscUnlock(IFX_SSC_HANDLE handler)
+{
+	ssc_device_t *dev;
+	IFX_SSC_CONFIGURE_t *ssc_cfg = NULL;
+	struct ifx_ssc_port *port = NULL;
+	IFX_SSC_QUEUE_t *pqueue;
+
+	SSC_KASSERT((handler != NULL),
+		    ("%s Invalid parameter\n", __func__));
+
+	dev = (ssc_device_t *) handler;
+	pqueue = &dev->queue;
+	ssc_cfg = &dev->conn_id;
+	port = dev->port;
+
+	if (port->lock_qentry != &dev->queue)
+		return -1;
+
+	/* Just forget about the lock, then the SSC driver would just take it
+	 * as a normel queue entry
+	 */
+	ifx_ssc_cs_unlock(dev);
+	IFX_SSC_Q_LOCK_BH(port);
+	pqueue->txbuf = NULL;
+	pqueue->txsize = 0;
+	pqueue->rxbuf = NULL;
+	pqueue->rxsize = 0;
+	port->lock_qentry = NULL;
+	IFX_SSC_Q_UNLOCK_BH(port);
+	return 0;
+}
+EXPORT_SYMBOL(ifx_sscUnlock);
+
+/**
+ * \fn int ifx_sscSetBaud(IFX_SSC_HANDLE handler, unsigned int baud)
+ * \brief Configures the Baudrate of a given connection.
+ *
+ * The baudrate can also be change multiple times
+ * for a single connection. The baudrate change
+ * will take place for the next call of ifx_SscTx,
+ * ifx_SscRx or ifx_SscTxRx.
+ *
+ * \param   handler    Handle of the connection where to make the
+ *                     configuration on
+ * \param   baud       Baudrate to configure. This value can be rounded
+ *                     during the calculation of the SSC clock divider
+ *
+ * \return  = 0        OK
+ * \return  < 0        error number
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int ifx_sscSetBaud(IFX_SSC_HANDLE handler, unsigned int baud)
+{
+	ssc_device_t *dev;
+	IFX_SSC_CONFIGURE_t *ssc_cfg;
+
+	/* Sanity check */
+	SSC_KASSERT((handler != NULL), ("%s Invalid parameter\n", __func__));
+
+	dev = (ssc_device_t *) handler;
+	ssc_cfg = &dev->conn_id;
+	/* XXX, protection because of being used in other places */
+	ssc_cfg->baudrate = baud;
+	return 0;
+}
+EXPORT_SYMBOL(ifx_sscSetBaud);
+
+/**
+ * \fn static int ifx_ssc_txdma(struct ifx_ssc_port *port, char *txbuf,
+ *     int txsize)
+ * \brief Called to transmit the data using DMA mode .
+ *
+ * \param   port       Pointer to structure #ifx_ssc_port
+ * \param   txbuf      Pointer to the data packet to transmit
+ * \param   txsize     Amount of Bytes to transmit
+ * \return  >= 0       Number of bytes transmitted
+ * \return  < 0        error number
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int
+ifx_ssc_txdma(struct ifx_ssc_port *port, char *txbuf, int txsize)
+{
+	int i, j;
+	int retval = 0;
+	int k, m;
+	char *p;
+	char *pbuf;
+	struct dma_device_info *dma_dev;
+
+	ifx_ssc_dma_setup(port, IFX_SSC_DIR_TX, IFX_SSC_DMA_ENABLE);
+
+	/*
+	 * HW WAR, last 1~3 byte must do swapping, but the wanted bytes could be
+	 * out of orignal tx buffer, so pre-allocated buffer used, and what's
+	 * more, memcpy involved.
+	 * XXX, actually, potential issues include data length which is a
+	 * multiple of DMA burst length.
+	 */
+	i = txsize >> 2;  /* divided by 4 */
+	j = txsize & 0x3; /* modulo */
+	if (j != 0) {  /* Hit last 1~3 byte case */
+		memcpy(port->dma_txbuf, txbuf, txsize);
+		p = port->dma_txbuf + (i << 2);
+		for (m = 0, k = j - 1; k >= 0; k--, m++)
+			p[4 - m - 1] = p[k];
+		pbuf = port->dma_txbuf;
+	} else
+		pbuf = txbuf;
+
+	dma_dev = port->dma_dev;
+
+	/**
+	* Set a flag that we are waiting for the DMA to complete. This flag
+	* will be reseted again in the DMA interrupt.
+	* NB, it must be ahead of the following stuff, because once descriptor
+	* is prepared, interrupt may come back immediately
+	*/
+	atomic_set(&port->dma_wait_state, 1);
+
+	/* TX DMA only half duplex is used */
+	port->dma_is_in_half_duplex = 1;
+	/**
+	* Run in tasklet or kernel thread, DMA tasklet may run the same function
+	* Lock must be used.
+	*/
+	retval = dma_device_write(dma_dev, pbuf, txsize, NULL);
+	SSC_KASSERT(retval == txsize, ("%s retval %d != txsize %d\n",
+		__func__, retval, txsize));
+
+	return retval;
+}
+
+/**
+ * \fn static int ifx_ssc_dma_fdx(struct ifx_ssc_port *port, char *txbuf,
+ *                                int txsize, char *rxbuf, int rxsize)
+ * \brief Called to transmit/receive the data using DMA mode .
+ *
+ * \param   port       Pointer to structure #ifx_ssc_port
+ * \param   txbuf      Pointer to the data packet to transmit
+ * \param   txsize     Amount of Bytes to transmit
+ * \param   rxbuf      Pointer to the data packet to be received
+ * \param   rxsize     Amount of Bytes to be received
+ * \return  >= 0       Number of bytes transmitted
+ * \return  < 0        error number
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int
+ifx_ssc_dma_fdx(struct ifx_ssc_port *port, char *txbuf, int txsize,
+		char *rxbuf, int rxsize)
+{
+	int retval = 0;
+	struct dma_device_info *dma_dev;
+	dma_dev = port->dma_dev;
+
+	/*
+	 * FDX required TX/RX has the same amount of data and they must be
+	 * a multiple of of DMA burst length
+	 */
+	if (((rxsize & ((dma_dev->rx_burst_len << 2) - 1)) != 0) ||
+	    ((txsize & ((dma_dev->tx_burst_len << 2) - 1)) != 0)) {
+		pr_err("%s data length is not a multiple of DMA burst length %d\n",
+			__func__, rxsize);
+		return -EINVAL;
+	}
+
+	/*
+	 * Backup original buffer, so that later we can find it in dma handler
+	 * Borrow two variables from FIFO usage
+	 */
+	port->rxbuf_ptr = rxbuf;
+	port->actual_rx_len = rxsize;
+
+	/* Prepare RX descriptor */
+	dma_device_desc_setup(dma_dev, rxbuf, rxsize);
+
+	/* Enable SSC TX/RX DMA */
+	ifx_ssc_dma_setup(port, IFX_SSC_DIR_TXRX, IFX_SSC_DMA_ENABLE);
+
+	/*
+	 * NB, Enable SPI DMA channel every time. There are two reasons as
+	 * follow,
+	 * 1. In synchronous DMA application, there is no pre-allocation
+	 *    memory for SPI bus driver. When it registers with central
+	 *    DMA driver, it will not open RX channel for reception. So
+	 *    at least, we need to open channel once before we use it.
+	 * 2. We have to close this channel after we receive the packet
+	 *    since we have only one descriptor, and we can't clear the
+	 *    descriptor. This will be explained further in close channel part.
+	 */
+	(dma_dev->rx_chan[dma_dev->current_rx_chan])->
+		open(dma_dev->rx_chan[dma_dev->current_rx_chan]);
+
+	/* Set a flag that we are waiting for the DMA to complete. This flag
+	 * will be reseted again in the DMA interrupt.
+	 */
+	atomic_set(&port->dma_wait_state, 1);
+
+	/* Full Duplex is used */
+	port->dma_is_in_half_duplex = 0;
+
+	/* TX real data sent, RX real data will come back */
+
+	retval = dma_device_write(dma_dev, txbuf, txsize, NULL);
+
+	SSC_KASSERT(retval == txsize, ("%s retval %d != txsize %d\n",
+				__func__, retval, txsize));
+
+	return retval;
+}
+
+/**
+ * \fn static int ifx_ssc_rxdma(struct ifx_ssc_port *port, char *rxbuf,
+ *                              int rxsize)
+ * \brief Called to receive the data using DMA mode .
+ *
+ * \param   port       Pointer to structure #ifx_ssc_port
+ * \param   rxbuf      Pointer to the data packet to be received
+ * \param   rxsize     Amount of Bytes to be received
+ * \return  >= 0       Number of bytes received
+ * \return   < 0       error number
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int
+ifx_ssc_rxdma(struct ifx_ssc_port *port, char *rxbuf, int rxsize)
+{
+	char *pbuf;
+	int dma_rxsize;
+	int retval = 0;
+	u32 dma_burst_len;
+	u32 dma_burst_len_mask;
+	struct dma_device_info *dma_dev;
+	dma_dev = port->dma_dev;
+	dma_burst_len = (dma_dev->rx_burst_len << 2);
+	dma_burst_len_mask = dma_burst_len - 1;
+
+	/*
+	 * Backup original buffer, so that later we can find it in dma handler
+	 * Borrow two variables from FIFO usage
+	 */
+	port->rxbuf_ptr = rxbuf;
+	port->actual_rx_len = rxsize;
+
+	if ((rxsize & dma_burst_len_mask)) {
+		pbuf = port->dma_rxbuf;
+		dma_rxsize = (rxsize & ~dma_burst_len_mask) + dma_burst_len;
+		SSC_KASSERT(dma_rxsize <= DEFAULT_SSC_FRAGMENT_SIZE,
+			("%s fragment %d out of range\n", __func__,
+			dma_rxsize));
+	} else {
+		pbuf = rxbuf;
+		dma_rxsize = rxsize;
+	}
+
+	dma_device_desc_setup(dma_dev, pbuf, dma_rxsize);
+
+	ifx_ssc_dma_setup(port, IFX_SSC_DIR_TXRX, IFX_SSC_DMA_ENABLE);
+
+	/*
+	 * NB, Enable SPI DMA channel every time. There are two reasons as
+	 * follow,
+	 * 1. In synchronous DMA application, there is no pre-allocation
+	 *    memory for SPI bus driver. When it registers with central
+	 *    DMA driver, it will not open RX channel for reception. So
+	 *    at least, we need to open channel once before we use it.
+	 * 2. We have to close this channel after we receive the packet
+	 *    since we have only one descriptor, and we can't clear the
+	 *    descriptor. This will be explained further in close channel part.
+	 */
+
+	(dma_dev->rx_chan[dma_dev->current_rx_chan])->
+		open(dma_dev->rx_chan[dma_dev->current_rx_chan]);
+
+	/* Set a flag that we are waiting for the DMA to complete. This flag
+	 * will be reseted again in the DMA interrupt.
+	 */
+	atomic_set(&port->dma_wait_state, 1);
+	port->dma_is_in_half_duplex = 0;
+
+	/* TX dummy data sent */
+
+	retval = dma_device_write(dma_dev, port->dma_txbuf, dma_rxsize, NULL);
+
+	SSC_KASSERT(retval == dma_rxsize, ("%s retval %d != txsize %d\n",
+		__func__, retval, dma_rxsize));
+
+	return rxsize;
+}
+
+/**
+ *\fn int ifx_sscTxRx (IFX_SSC_HANDLE handler, char *txbuf, u32 txsize,
+ *                     char *rxbuf, u32 rxsize)
+ *\brief Called to transmit/receive to/from SSC in one step.
+
+ * This means that the data transmission and reception is done in parallel.
+ * No DMA is possible here. The SSC driver sets the chipselect when the
+ * data transmission starts and resets it when the transmission is
+ * completed. The transmit and receive buffer memory allocation and
+ * de-allocation is done by the SSC client.
+ *
+ * \param   handler   Handle of the connection where to make the
+ *                    configuration on
+ * \param   txbuf     Pointer to the data packet to transmit
+ * \param   txsize    Amount of Bytes to transmit
+ * \param   rxbuf     Pointer to store the received data packet
+ * \param   rxsize    Amount of Bytes to receive.
+ * \return  >= 0      Number of bytes received (if rxbuf != 0) or transmitted
+ * \return  < 0       error number
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int
+ifx_sscTxRx(IFX_SSC_HANDLE handler, char *txbuf, u32 txsize, char *rxbuf,
+	    u32 rxsize)
+{
+	ssc_device_t *dev;
+	IFX_SSC_CONFIGURE_t *ssc_cfg;
+	IFX_SSC_QUEUE_t *pqueue;
+	struct ifx_ssc_port *port;
+	struct ifx_ssc_device_stats *stats;
+
+	/*anity check */
+	SSC_KASSERT((handler != NULL),
+		("%s Invalid parameter\n", __func__));
+
+	SSC_KASSERT(!((rxbuf == NULL) && (rxsize == 0)
+		&& (txbuf == NULL) && (txsize == 0)),
+		("%s Invalid parameter\n", __func__));
+
+	dev = (ssc_device_t *) handler;
+	stats = &dev->stats;
+	port = dev->port;
+
+	if (in_interrupt()) {
+		stats->context_err++;
+		pr_err("%s can't be called in interupt context < irq, softirq, tasklet>\n",
+			__func__);
+		return 0;
+	}
+	ssc_cfg = &dev->conn_id;
+	pqueue = &dev->queue;
+
+	if (txsize > ssc_cfg->fragSize || rxsize > ssc_cfg->fragSize) {
+		stats->frag_err++;
+		pr_err("%s Device driver must do its own fragmentation tx %d rx %d > %d\n",
+			__func__, txsize, rxsize, ssc_cfg->fragSize);
+		return 0;
+	}
+
+	/* Full dupex mode sanity check  */
+	if ((txsize != 0) && (rxsize != 0)) {
+		if (ssc_cfg->duplex_mode == IFX_SSC_FULL_DUPLEX) {
+			if (txsize != rxsize) {
+				stats->dlx_err++;
+				pr_err("%s full duplex required TX/RX has the same amount of data tx %d rx %d\n",
+					__func__, txsize, rxsize);
+				return 0;
+			}
+		}
+	}
+
+	/*
+	 * Ensure that only asynchronous SSC Handles could enqueue a
+	 * synchronous request. The parameter 'handle_type' is set during the
+	 * ConnId allocation process.
+	 */
+	if (pqueue->handle_type != IFX_SSC_HANDL_TYPE_SYNC) {
+		stats->handler_err++;
+		pr_err("%s must use sync handler\n", __func__);
+		return 0;
+	}
+
+	/*
+	 * Check if the queue entry of the ConnId is already queued with
+	 * a request but this request is not served yet. Every ConnId can
+	 * only queue up one request at one time.
+	 */
+	if (atomic_read(&pqueue->isqueued) == 1) {
+		stats->dup_qentries++;
+		IFX_SSC_PRINT(port, SSC_MSG_ERROR,
+			"%s same queue has queued more than once\n",
+			__func__);
+		return 0;
+	}
+	/* Add pointer and sizes to the queue entry of this SSC handle. */
+	IFX_SSC_Q_LOCK_BH(port);
+	pqueue->txbuf = txbuf;
+	pqueue->txsize = txsize;
+	pqueue->rxbuf = rxbuf;
+	pqueue->rxsize = rxsize;
+	atomic_set(&pqueue->isqueued, 1);
+	pqueue->exchange_bytes = 0;
+	pqueue->request_lock = false;
+	memset(&pqueue->callback, 0, sizeof(IFX_SSC_ASYNC_CALLBACK_t));
+	IFX_SSC_Q_UNLOCK_BH(port);
+	/* Add queue entry to priority queue */
+	ifx_ssc_enqueue(pqueue);
+
+	/* If no async support is avaiable, trigger the SSC kernel thread and
+	 * wait pending till job is done.
+	 */
+#ifdef CONFIG_LANTIQ_SPI_ASYNCHRONOUS
+	IFX_SSC_PRINT(port, SSC_MSG_TASKLET, "%s raise fake interrupt\n",
+		__func__);
+	ifx_ssc_start_tasklet(port);
+#else
+	IFX_SSC_PRINT(port, SSC_MSG_THREAD,
+		"%s wake up ssc kernel thread\n", __func__);
+	/* Kick off SSC kernel thread */
+	IFX_SSC_WAKEUP_EVENT(port->ssc_thread_wait, IFX_SSC_THREAD_EVENT,
+		port->event_flags);
+#endif
+	/* Wait till wakeup from SSC kernel thread */
+	IFX_SSC_WAIT_EVENT(dev->dev_thread_wait, IFX_SSC_DEV_THREAD_EVENT,
+		dev->event_flags);
+	IFX_SSC_PRINT(port, SSC_MSG_THREAD,
+		"%s wakeup event received from ssc kernel thread\n",
+		__func__);
+
+	/* Reset queue pointer */
+	IFX_SSC_Q_LOCK_BH(port);
+	pqueue->txbuf = NULL;
+	pqueue->rxbuf = NULL;
+	IFX_SSC_Q_UNLOCK_BH(port);
+	return pqueue->txsize + pqueue->rxsize;
+}
+EXPORT_SYMBOL(ifx_sscTxRx);
+
+/**
+ *\fn int ifx_sscTx(IFX_SSC_HANDLE handler, char *txbuf, u32 txsize)
+ *\brief Called to transmit the data.
+
+ * transmission starts and resets it when the transmission
+ * the transmit buffer is done by the SSC client.
+ *
+ * \param   handler    Handle of the connection where to make the
+ *                     configuration on
+ * \param   txbuf     Pointer to the data packet to transmit
+ * \param   txsize     Amount of Bytes to transmit
+ * \return  >= 0       Number of bytes transmitted
+ * \return  < 0        error number
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int ifx_sscTx(IFX_SSC_HANDLE handler, char *txbuf, u32 txsize)
+{
+	return ifx_sscTxRx(handler, txbuf, txsize, NULL, 0);
+}
+EXPORT_SYMBOL(ifx_sscTx);
+
+/**
+ *\fn int ifx_sscRx(IFX_SSC_HANDLE handler, char *rxbuf, u32 rxsize)
+ *\brief Called to receive the data.
+
+ * The SSC driver sets the chipselect when the data reception starts and
+ * resets it when the reception is completed. The memory allocation and
+ * de-allocation of the receive buffer is done by the SSC client.
+ *
+ * \param   handler    Handle of the connection where to make the
+ *                     configuration on
+ * \param   rxbuf     Pointer to the data packet to be received
+ * \param   rxsize     Amount of Bytes to be received
+ * \return  >= 0       Number of bytes received
+ * \return  < 0        error number
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int ifx_sscRx(IFX_SSC_HANDLE handler, char *rxbuf, u32 rxsize)
+{
+	return ifx_sscTxRx(handler, NULL, 0, rxbuf, rxsize);
+}
+EXPORT_SYMBOL(ifx_sscRx);
+
+/**
+ * \fn static int ifx_ssc_serve_qentry(struct ifx_ssc_port *port)
+ * \brief Called to serve every queue entry and it is a common function for
+ * SSC kernel thread and tasklet
+ *
+ * \param   port       Pointer to structure #ifx_ssc_port
+ * \return  1          Continue to loop this function until return 0
+ * \return  0         Immediately exit this function. For kernel thread,
+ *                     it will sleep, for tasklet, it will exit dynamically
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int ifx_ssc_serve_qentry(struct ifx_ssc_port *port)
+{
+	IFX_SSC_QUEUE_t *qentry = NULL;
+	ssc_device_t *dev;
+	IFX_SSC_CONFIGURE_t *ssc_cfg = NULL;
+	struct dma_device_info *dma_dev;
+	/*
+	 * Don't serve the current or next queue entry in case we are currently
+	 * waiting for the DMA interrupt to report the transmission completion.
+	 */
+	if (atomic_read(&port->dma_wait_state) == 1) {
+		/*
+		 * DMA interrupt will spawn tasklet or wake up kernel thread
+		 * in order to continue.
+		 */
+		return 0;
+	}
+
+	/* Identify the queue entry to serve */
+	if (port->serve_qentry != NULL) {
+		/* Continues serving the queue that was served before */
+		qentry = port->serve_qentry;
+	} else if (port->lock_qentry != NULL) {
+		/*
+		 * If one queue holds the lock, only serve this one element
+		 * and ignore all others.
+		 */
+		qentry = port->lock_qentry;
+		port->serve_qentry = qentry;
+	} else {
+		IFX_SSC_Q_LOCK_BH(port);
+		if (!TAILQ_EMPTY(&port->ssc_asyncq)) {
+			qentry = TAILQ_FIRST(&port->ssc_asyncq);
+		} else {
+			int i;
+			/* Choose the highest queue entry first */
+			for (i = IFX_SSC_PRIO_HIGH; i >= IFX_SSC_PRIO_LOW;
+			     i--) {
+				if (!TAILQ_EMPTY(&port->ssc_syncq[i])) {
+					qentry = TAILQ_FIRST
+						(&port->ssc_syncq[i]);
+					break;
+				}
+			}
+		}
+		IFX_SSC_Q_UNLOCK_BH(port);
+
+		/* Remember that we are working on this queue now */
+		port->serve_qentry = qentry;
+
+		/*
+		 * NB, Don't remove the qentry here since we may never come
+		 * here once callers called sequence. It may cause enqueue
+		 * /dequeue mismatch
+		 */
+	}
+	/* No queue found that should be served */
+	if (qentry == NULL)
+		return 0;
+
+	/* Get connection handle */
+	dev = qentry->dev;
+	ssc_cfg = &dev->conn_id;
+	dma_dev = port->dma_dev;
+
+	if ((ssc_cfg->duplex_mode == IFX_SSC_FULL_DUPLEX)
+		&& (qentry->txbuf != NULL)
+		&& (qentry->rxbuf != NULL)) {
+
+		if ((port->ssc_cs_locked == false)
+			&& (port->lock_qentry == NULL)) {
+			/* Call the set callback of theSC-Handle */
+			ifx_ssc_cs_lock(dev);
+		}
+		ifx_ssc_txrx_setup(port);
+
+		if (port->dma_support) {
+			int tx_dma_aligned = ((((u32) qentry->txbuf) &
+			 ((dma_dev->tx_burst_len << 2) - 1)) == 0) ? 1 : 0;
+			int rx_dma_aligned = ((((u32) qentry->rxbuf) &
+			((dma_dev->rx_burst_len << 2) - 1)) == 0) ? 1 : 0;
+
+			/* If buffer not aligned on DMA burst length,
+			 * fall back to FIFO */
+			if ((qentry->txsize > ssc_cfg->maxFIFOSize)
+				&& (tx_dma_aligned == 1)
+				&& (qentry->rxsize > ssc_cfg->maxFIFOSize)
+				&& (rx_dma_aligned == 1)) {
+
+				IFX_SSC_PRINT(port, SSC_MSG_DUPLEX,
+					"%s TX/RX DMA enter\n", __func__);
+				ifx_ssc_dma_fdx(port, qentry->txbuf,
+					qentry->txsize, qentry->rxbuf,
+					qentry->rxsize);
+
+				port->stats.txDma++;
+				port->stats.rxDma++;
+				/*
+				 * Reset the data pointer, because this data are
+				 * done on the SSC hardware.
+				 */
+				qentry->txbuf = NULL;
+				/* Count the number of transmitted bytes for
+				 * this queue entry */
+				qentry->exchange_bytes = qentry->txsize;
+
+				qentry->rxbuf = NULL;
+				qentry->exchange_bytes += qentry->rxsize;
+
+				dev->stats.txBytes += qentry->txsize;
+				port->stats.txBytes += qentry->txsize;
+				port->stats.txDmaBytes += qentry->txsize;
+				dev->stats.rxBytes += qentry->rxsize;
+				port->stats.rxBytes += qentry->rxsize;
+				port->stats.rxDmaBytes += qentry->rxsize;
+				return 0;
+			}  else
+				goto fdxfifo;
+		} else {
+fdxfifo:
+			ifx_ssc_txrx_fifo_fdx(port, qentry->txbuf,
+				qentry->txsize, qentry->rxbuf, qentry->rxsize);
+			port->stats.txFifo++;
+			port->stats.rxFifo++;
+			IFX_SSC_PRINT(port, SSC_MSG_DUPLEX,
+				"%s TX/RX FIFO enter\n", __func__);
+
+			/*
+			 * Reset the data pointer, because this data are
+			 * done on the SSC hardware.
+			 */
+			qentry->txbuf = NULL;
+			/* Count the number of transmitted bytes for
+			 * this queue entry */
+			qentry->exchange_bytes = qentry->txsize;
+			qentry->rxbuf = NULL;
+			qentry->exchange_bytes += qentry->rxsize;
+
+			dev->stats.txBytes += qentry->txsize;
+			port->stats.txBytes += qentry->txsize;
+			dev->stats.rxBytes += qentry->rxsize;
+			port->stats.rxBytes += qentry->rxsize;
+			return 1;
+		}
+
+	} else if (qentry->txbuf != NULL) {
+		if ((port->ssc_cs_locked == false)
+			&& (port->lock_qentry == NULL)) {
+			/* Call the set callback of the SSC-Handle */
+			ifx_ssc_cs_lock(dev);
+		}
+
+		/* If buffer not aligned on DMA burst length,
+		 * fall back to FIFO */
+		if (port->dma_support) {
+			int tx_dma_aligned = ((((u32) qentry->txbuf)&
+			((dma_dev->tx_burst_len << 2) - 1)) == 0) ? 1 : 0;
+
+			if ((qentry->txsize > ssc_cfg->maxFIFOSize)
+				&& (tx_dma_aligned == 1)) {
+				IFX_SSC_PRINT(port, SSC_MSG_TX_DMA,
+					"%s TX DMA enter\n", __func__);
+				ifx_ssc_tx_setup(port);
+				ifx_ssc_txdma(port, qentry->txbuf,
+					qentry->txsize);
+				port->stats.txDma++;
+				/*
+				 * Reset the data pointer, because this data
+				 * are done on theSC hardware.
+				 */
+				qentry->txbuf = NULL;
+				/* Count the number of transmitted bytes for
+				 * this queue entry */
+				qentry->exchange_bytes = qentry->txsize;
+				dev->stats.txBytes += qentry->txsize;
+				port->stats.txBytes += qentry->txsize;
+				port->stats.txDmaBytes += qentry->txsize;
+				return 0;
+			} else
+				goto txfifo;
+		} else {
+txfifo:
+			ifx_ssc_tx_setup(port);
+			ifx_ssc_txfifo(port, qentry->txbuf,
+				qentry->txsize);
+			port->stats.txFifo++;
+			IFX_SSC_PRINT(port, SSC_MSG_TX_FIFO,
+				"%s TX FIFO enter\n", __func__);
+
+			/*
+			 * Reset the data pointer, because this data are done
+			 * on the SSC hardware.
+			 */
+			qentry->txbuf = NULL;
+			/* Count the number of transmitted bytes for this
+			 * queue entry */
+			qentry->exchange_bytes = qentry->txsize;
+			dev->stats.txBytes += qentry->txsize;
+			port->stats.txBytes += qentry->txsize;
+			/* NB, Make sure data has been sent out */
+			ifx_ssc_wait_finished(port);
+			return 1;
+		}
+	} else if (qentry->rxbuf != NULL) {
+		if ((port->ssc_cs_locked == false)
+			&& (port->lock_qentry == NULL)) {
+			/* Call the set callback of the SSC-Handle */
+			ifx_ssc_cs_lock(dev);
+		}
+		/* If buffer not aligned on DMA burst length,
+		 * fall back to FIFO */
+		if (port->dma_support) {
+			int rx_dma_aligned = ((((u32) qentry->rxbuf) &
+			 ((dma_dev->rx_burst_len << 2) - 1)) == 0) ? 1 : 0;
+
+			if ((qentry->rxsize > ssc_cfg->maxFIFOSize)
+				&& (rx_dma_aligned == 1)) {
+				IFX_SSC_PRINT(port, SSC_MSG_RX_DMA,
+					"%s RX DMA enter\n", __func__);
+				ifx_ssc_txrx_setup(port);
+				ifx_ssc_rxdma(port, qentry->rxbuf,
+					qentry->rxsize);
+				port->stats.txDma++;
+				port->stats.rxDma++;
+
+				/* Reset the data pointer, because this data are
+				 * done on the SSC hardware.
+				 */
+				qentry->rxbuf = NULL;
+				/* Count the number of transmitted bytes for
+				 * this queue entry */
+				qentry->exchange_bytes += qentry->rxsize;
+				dev->stats.rxBytes += qentry->rxsize;
+				port->stats.rxBytes += qentry->rxsize;
+				port->stats.rxDmaBytes += qentry->rxsize;
+				dev->stats.txBytes += qentry->rxsize;
+				port->stats.txBytes += qentry->rxsize;
+				port->stats.txDmaBytes += qentry->rxsize;
+				return 0;
+			} else
+				goto rxfifo;
+		} else {
+rxfifo:
+			ifx_ssc_rx_setup(port);
+			ifx_ssc_rxfifo(port, qentry->rxbuf,
+				       qentry->rxsize);
+			port->stats.rxFifo++;
+			IFX_SSC_PRINT(port, SSC_MSG_RX_FIFO,
+				"%s RX FIFO enter\n", __func__);
+
+			/* Reset the data pointer, because this data are done
+			 * on the SSC hardware.
+			 */
+			qentry->rxbuf = NULL;
+			/* Count the number of recevied bytes for this
+			 * queue entry */
+			qentry->exchange_bytes += qentry->rxsize;
+			dev->stats.rxBytes += qentry->rxsize;
+			port->stats.rxBytes += qentry->rxsize;
+			/* NB, Make sure data has been sent out */
+			ifx_ssc_wait_finished(port);
+			return 1;
+		}
+	} else if (qentry->request_lock) {
+		/* A lock request found */
+		IFX_SSC_PRINT(port, SSC_MSG_LOCK,
+			"%s request lock enter\n", __func__);
+		port->lock_qentry = qentry;
+		qentry->request_lock = false;
+
+		/* Serving the current queue entry is done */
+		port->serve_qentry = NULL;
+
+		/*
+		 * Reset the flag in the queue element that this one is
+		 * queued with a request to be served.
+		 */
+		atomic_set(&qentry->isqueued, 0);
+
+		/* syncAPI has the last watchdog branch but nested callback
+		 * has to dequeue it */
+		if (qentry->handle_type == IFX_SSC_HANDL_TYPE_ASYNC)
+			ifx_ssc_dequeue(qentry);
+
+		/* Call the Chipselect set callback of the SSC-Handle */
+		ifx_ssc_cs_lock(dev);
+
+		if (qentry->callback.pFunction) {
+			/*
+			 * Store the callback parameter local to cleanup the
+			 * queue entry before calling the callback.
+			 */
+			IFX_SSC_ASYNC_CALLBACK_t callback =
+				qentry->callback;
+
+			qentry->callback.pFunction = NULL;
+			IFX_SSC_PRINT(port, SSC_MSG_CALLBACK,
+				"%s line%d request callback\n",
+				__func__, __LINE__);
+
+			callback.pFunction(callback.functionHandle, 0);
+		}
+		return 1;
+	} else if (qentry->callback.pFunction != NULL) {
+		/*
+		 * Store the callback parameter local to cleanup the queue
+		 * entry before calling the callback.
+		 */
+		IFX_SSC_ASYNC_CALLBACK_t callback = qentry->callback;
+
+		qentry->callback.pFunction = NULL;
+
+		/* Serving the current queue entry is done */
+		port->serve_qentry = NULL;
+
+		/*
+		 * Reset the flag in the queue element that this one is queued
+		 * with a request to be served.
+		 */
+		atomic_set(&qentry->isqueued, 0);
+
+		ifx_ssc_dequeue(qentry);
+
+		if ((port->ssc_cs_locked == true)
+		    && (port->lock_qentry == NULL)) {
+			/* Call the reset callback of the SSC-Handle */
+			ifx_ssc_cs_unlock(dev);
+		}
+
+		IFX_SSC_PRINT(port, SSC_MSG_CALLBACK,
+			"%s line%d direct callback\n", __func__, __LINE__);
+
+		/* Callback to call */
+		callback.pFunction(callback.functionHandle,
+			qentry->exchange_bytes);
+		return 1;
+	} else if (qentry->handle_type == IFX_SSC_HANDL_TYPE_SYNC) {
+		if ((port->ssc_cs_locked == true)
+		    && (port->lock_qentry == NULL)) {
+			/* Call the reset callback of the SSC-Handle */
+			ifx_ssc_cs_unlock(dev);
+		}
+
+
+		/* Serving the current queue entry is done */
+		port->serve_qentry = NULL;
+
+		/*
+		 * Reset the flag in the queue element that this one is queued
+		 * with a request to be served.
+		 */
+		atomic_set(&qentry->isqueued, 0);
+
+		ifx_ssc_dequeue(qentry);
+		/* Wake up the pending thread */
+		IFX_SSC_WAKEUP_EVENT(dev->dev_thread_wait,
+			IFX_SSC_DEV_THREAD_EVENT, dev->event_flags);
+		IFX_SSC_PRINT(port, SSC_MSG_THREAD,
+			"%s wakeup SSC client kernel thread\n", __func__);
+		/* syncAPI has no callback, we have to differentiate it */
+		if (port->ssc_cs_locked == true)
+			return 0;
+		else
+			return 1;
+	} else if ((qentry->handle_type == IFX_SSC_HANDL_TYPE_ASYNC)
+		   && (port->ssc_cs_locked == true)) {
+		/* Serving the current queue entry is done */
+		port->serve_qentry = NULL;
+		/* Don't let it continue, but must restart tasklet
+		 * in somewhere else */
+		return 0;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_LANTIQ_SPI_ASYNCHRONOUS
+/**
+ * \fn static INLINE void ifx_ssc_tasklet_serve_queue
+ *                        (struct ifx_ssc_port *port)
+ * \brief Called to serve every queue entry in tasklet
+ *
+ * \param   port       Pointer to structure #ifx_ssc_port
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static INLINE void ifx_ssc_tasklet_serve_queue(struct ifx_ssc_port *port)
+{
+	/*
+	 * Serve queue entries till no queue entry anymore to serve,
+	 * we wait for DMA or the lock entry is not in the queue.
+	 */
+	while (ifx_ssc_serve_qentry(port))
+		;
+}
+
+/**
+ * \fn static INLINE void ifx_ssc_tasklet(unsigned long arg)
+ * \brief SSC tasklet implementation
+ *
+ * \param   arg       cast to structure #ifx_ssc_port
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static INLINE void ifx_ssc_tasklet(unsigned long arg)
+{
+	struct ifx_ssc_port *port = (struct ifx_ssc_port *) arg;
+
+	IFX_SSC_PRINT(port, SSC_MSG_TASKLET, "%s enter\n", __func__);
+	ifx_ssc_tasklet_serve_queue(port);
+}
+
+/**
+ * \fn static INLINE void ifx_ssc_tasklet_init(struct ifx_ssc_port *port)
+ * \brief SSC tasklet initialization
+ *
+ * \param   port       Pointer to structure #ifx_ssc_port
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static INLINE void ifx_ssc_tasklet_init(struct ifx_ssc_port *port)
+{
+	tasklet_init(&port->ssc_txrxq, ifx_ssc_tasklet, (unsigned long) port);
+}
+
+#else
+
+/**
+ * \fn static int ifx_ssc_kthread(void *arg)
+ * \brief SSC kernel thread implementation function
+ *
+ * \param   arg       cast to structure #ifx_ssc_port
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int ifx_ssc_kthread(void *arg)
+{
+	struct ifx_ssc_port *port = (struct ifx_ssc_port *) arg;
+
+	set_current_state(TASK_INTERRUPTIBLE);
+	while (!kthread_should_stop()) {
+		/* Wait for DMA interrupt or sync queue to wakes us up */
+		IFX_SSC_WAIT_EVENT(port->ssc_thread_wait,
+			IFX_SSC_THREAD_EVENT, port->event_flags);
+		IFX_SSC_PRINT(port, SSC_MSG_THREAD,
+			"%s DMA or sync queue event received\n",
+			__func__);
+		__set_current_state(TASK_RUNNING);
+		/* Serve queue entries till no more queue entry to serve, */
+		while (ifx_ssc_serve_qentry(port))
+			;
+		set_current_state(TASK_INTERRUPTIBLE);
+	}
+	return 0;
+}
+
+/**
+ * \fn static INLINE int ifx_ssc_thread_init(struct ifx_ssc_port *port)
+ * \brief SSC kernel thread initialization
+ *
+ * \param   port       Pointer to structure #ifx_ssc_port
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static INLINE int ifx_ssc_thread_init(struct ifx_ssc_port *port)
+{
+	struct task_struct *p;
+	int error = 0;
+
+	p = kthread_run(ifx_ssc_kthread, (void *) port, "ssc_kthread");
+	if (IS_ERR(p))
+		error = PTR_ERR(p);
+	else
+		port->ssc_tsk = p;
+	return error;
+}
+#endif /* CONFIG_LANTIQ_SPI_ASYNCHRONOUS */
+
+/**
+ * \fn int ifx_sscAsyncTxRx(IFX_SSC_HANDLE handler,
+ *                          IFX_SSC_ASYNC_CALLBACK_t *pCallback,
+ *                          char *txbuf, int txsize, char *rxbuf, int rxsize)
+ * \brief Transmit/receive to/from SSC in one step. It performs the data
+ *  transmission and then the data reception.
+
+ * The SSC driver sets the chipselect when the data transmission starts and
+ * resets it when the transmission is completed.
+ * This routine is called to start an asynchronous data transmission.
+ * The provided callback routine is called after the transmission is done.
+ *
+ * \param   handler    Handle of the connection where to make the configuration
+ *                     on
+ * \param   pCallback  Function callback that is called after the request is
+ *                     performed.
+ * \param   txbuf      Pointer to the data packet to transmit.
+ * \param   txsize     Amount of Bytes to transmit.
+ * \param   rxbuf      Pointer to store the received data packet.
+ * \param   rxsize     Amount of Bytes to receive.
+
+ * \return Returns the amount of bytes that are transmitted in case of
+ *  successful transmission. In case of an error the function returns (-1).
+ *
+ * \remarks This function activates the chipselect before data transmission and
+ *  deactivates it after transmission (when function returns). This is done
+ *  with  the callback function. The chipselect is not modified in case
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int
+ifx_sscAsyncTxRx(IFX_SSC_HANDLE handler,
+		 IFX_SSC_ASYNC_CALLBACK_t *pCallback, char *txbuf,
+		 int txsize, char *rxbuf, int rxsize)
+{
+	ssc_device_t *dev;
+	IFX_SSC_CONFIGURE_t *ssc_cfg;
+	IFX_SSC_QUEUE_t *pqueue;
+	struct ifx_ssc_port *port;
+	struct ifx_ssc_device_stats *stats;
+
+	/*anity check */
+	SSC_KASSERT((handler != NULL),
+		("%s Invalid parameter\n", __func__));
+
+	SSC_KASSERT(!((rxbuf == NULL) && (rxsize == 0)
+		&& (txbuf == NULL) && (txsize == 0)),
+		("%s Invalid parameter\n", __func__));
+
+	dev = (ssc_device_t *) handler;
+	stats = &dev->stats;
+	port = dev->port;
+
+	if (!in_interrupt()) {
+		stats->context_err++;
+		pr_err("%s must be called in interrupt context <irq, softirq, tasklet>\n",
+			__func__);
+		return -1;
+	}
+
+	ssc_cfg = &dev->conn_id;
+	pqueue = &dev->queue;
+
+	if (txsize > ssc_cfg->fragSize || rxsize > ssc_cfg->fragSize) {
+		stats->frag_err++;
+		pr_err("%s Device driver must do its own fragmentation tx %d rx %d > %d\n",
+			__func__, txsize, rxsize, ssc_cfg->fragSize);
+		return -1;
+	}
+
+	if ((txsize != 0) && (rxsize != 0)) {
+		if (ssc_cfg->duplex_mode == IFX_SSC_FULL_DUPLEX) {
+			if (txsize != rxsize) {
+				stats->dlx_err++;
+				pr_err("%s full duplex required TX/RX has the same amount of data tx %d rx %d\n",
+					__func__, txsize, rxsize);
+				return -1;
+			}
+		}
+	}
+
+	/*
+	 * Ensure that only asynchronous SSC Handles could enqueue an
+	 * asynchronous request. The parameter 'sscHandleType' is set during
+	 * the ConnId allocation process.
+	 */
+	if (pqueue->handle_type != IFX_SSC_HANDL_TYPE_ASYNC) {
+		stats->handler_err++;
+		pr_err("%s must use async handler\n", __func__);
+		return -1;
+	}
+
+	/*
+	 * Check if the queue entry of the ConnId is already queued with a
+	 * request but this request is not served yet. Every ConnId can only
+	 * queue up one request at the time.
+	 */
+	if (atomic_read(&pqueue->isqueued) == 1) {
+		stats->dup_qentries++;
+		IFX_SSC_PRINT(port, SSC_MSG_ERROR,
+			"%s same queue has queued more than once\n",
+			__func__);
+		return -1;
+	}
+	IFX_SSC_Q_LOCK_BH(port);
+	/* Add pointer and sizes to the queue entry of this SSC handle. */
+	pqueue->txbuf = txbuf;
+	pqueue->txsize = txsize;
+	pqueue->rxbuf = rxbuf;
+	pqueue->rxsize = rxsize;
+	if (pCallback != NULL)
+		pqueue->callback = *pCallback;
+
+	pqueue->request_lock = false;
+	pqueue->exchange_bytes = 0;
+	atomic_set(&pqueue->isqueued, 1);
+	IFX_SSC_Q_UNLOCK_BH(port);
+
+	/* Add queue entry to priority synchronous queue */
+	ifx_ssc_enqueue(pqueue);
+
+	/*
+	 * Trigger schedule or tasklet or fake interrupt according to different
+	 * cases.
+	 */
+	ifx_ssc_start_tasklet(port);
+	return 0;
+}
+EXPORT_SYMBOL(ifx_sscAsyncTxRx);
+
+/**
+ * \fn int ifx_sscAsyncTx(IFX_SSC_HANDLE handler,
+ *                        IFX_SSC_ASYNC_CALLBACK_t *pCallback,
+ *                        char *txbuf, int txsize)
+ * \brief transmit the data, located at "txbuf". The "txsize" amount of bytes
+ * is transmitted over SSC.
+
+ * The SSC driver sets the chipselect when the data transmission starts and
+ * resets it when the transmission is completed.
+ * This routine is called to start an asynchronous data transmission.
+ * The provided callback routine is called after the transmission is done.
+ *
+ * \param   handler    Handle of the connection where to make the configuration
+ *                     on
+ * \param   pCallback  Function callback that is called after the request is
+ *                     performed.
+ * \param   txbuf      Pointer to the data packet to transmit.
+ * \param   txsize     Amount of Bytes to transmit.
+
+ * \return Returns the amount of bytes that are transmitted in case of
+ *  successful transmission. In case of an error the function returns (-1).
+ *
+ * \remarks This function activates the chipselect before data transmission and
+ *  deactivates it after transmission (when function returns). This is done
+ *  with the callback function. The chipselect is not modified in case
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int
+ifx_sscAsyncTx(IFX_SSC_HANDLE handler, IFX_SSC_ASYNC_CALLBACK_t *pCallback,
+	     char *txbuf, int txsize)
+{
+	return ifx_sscAsyncTxRx(handler, pCallback, txbuf, txsize, NULL, 0);
+}
+EXPORT_SYMBOL(ifx_sscAsyncTx);
+
+/**
+ * \fn int ifx_sscAsyncRx(IFX_SSC_HANDLE handler,
+ *                        IFX_SSC_ASYNC_CALLBACK_t *pCallback,
+ *                        char *rxbuf, int rxsize)
+ * \brief Receive from SSC. The received data are stored at "rxbuf".
+ * The "rxsize" describes the amount of bytes to receive from SSC.
+
+ * The SSC driver sets the chipselect when the data reception starts and
+ * resets it when the reception is completed.
+ *
+ * \param   handler    Handle of the connection where to make the
+ *                     configuration on
+ * \param   pCallback  Function callback that is called after the request is
+ *                     performed.
+ * \param   rxbuf      Pointer to store the received data packet.
+ * \param   rxsize     Amount of Bytes to receive.
+
+ * \return  Returns the amount of bytes that are received in case of successful
+   transmission. In case of an error the function returns (-1). (-1).
+ *
+ * \remarks This function activates the chipselect before data transmission and
+ *  deactivates it after transmission (when function returns). This is done
+ *  with the callback function. The chipselect is not modified in case
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int
+ifx_sscAsyncRx(IFX_SSC_HANDLE handler, IFX_SSC_ASYNC_CALLBACK_t *pCallback,
+	     char *rxbuf, int rxsize)
+{
+	return ifx_sscAsyncTxRx(handler, pCallback, NULL, 0, rxbuf, rxsize);
+}
+EXPORT_SYMBOL(ifx_sscAsyncRx);
+
+/**
+ * \fn int ifx_sscAsyncLock(IFX_SSC_HANDLE handler,
+ *                          IFX_SSC_ASYNC_CALLBACK_t *pCallback)
+ *
+ * \brief This function locks and reserves the whole SSC interface for the
+ * given 'handler'.
+
+ *  The chipselect, belonging to this SSC session is already
+ *  activated. This means the chipselect callback is called.
+ *  After complete data transmission and reception,
+ *  This routine is called to get the lock on tasklet level.
+ *  The provided callback routine is called after the lock is set.
+ *
+ * \param handler Handle of the connection.
+ * \param pCallback Function callback that is called after the request is
+ *        performed.
+ *
+ * \return Return (0) in case of success, otherwise (-1) in case of errors.
+ *
+ * \remarks This function actives the SSC chipselect of this 'handler' by
+ * calling the callback function.
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int
+ifx_sscAsyncLock(IFX_SSC_HANDLE handler, IFX_SSC_ASYNC_CALLBACK_t *pCallback)
+{
+	ssc_device_t *dev;
+	IFX_SSC_CONFIGURE_t *ssc_cfg;
+	struct ifx_ssc_port *port;
+	IFX_SSC_QUEUE_t *pqueue;
+
+	SSC_KASSERT((handler != NULL),
+		("%s Invalid parameter\n", __func__));
+	SSC_KASSERT((pCallback != NULL),
+		("%s Invalid parameter\n", __func__));
+
+	dev = (ssc_device_t *) handler;
+	pqueue = &dev->queue;
+	ssc_cfg = &dev->conn_id;
+	port = dev->port;
+
+	if (port->lock_qentry == pqueue) {
+		/* We hold the lock already -> nothing to request here! */
+		return -1;
+	}
+
+	/*
+	 * Check if the queue entry of the ConnId is already queued with a
+	 * request but this request is not served yet. Every ConnId can
+	 * only queue up one request at the time.
+	 */
+	if (atomic_read(&pqueue->isqueued) == 1)
+		return -1;
+
+	IFX_SSC_Q_LOCK_BH(port);
+	pqueue->txbuf = NULL;
+	pqueue->txsize = 0;
+	pqueue->rxbuf = NULL;
+	pqueue->rxsize = 0;
+	/* Place a lock request in the queue */
+	pqueue->request_lock = true;
+	pqueue->callback = *pCallback;
+	pqueue->exchange_bytes = 0;
+	atomic_set(&pqueue->isqueued, 1);
+	IFX_SSC_Q_UNLOCK_BH(port);
+
+	/* Add queue entry to priority synchronous queue */
+	ifx_ssc_enqueue(pqueue);
+
+	/*
+	 * Calls the internal process to serve the queue. This routine would
+	 * immediately return in case  the SSC hardware is currently used to
+	 * serve another request.
+	 */
+	ifx_ssc_start_tasklet(port);
+	return 0;
+}
+EXPORT_SYMBOL(ifx_sscAsyncLock);
+
+/**
+ * \fn int ifx_sscAsyncUnLock(IFX_SSC_HANDLE handler)
+ * \brief This function releases the SSC lock that was placed before by calling
+ * \ref ifx_sscAsyncLock. This function also inactivate the chipselect signal,
+ *  which was set in \ref ifx_sscAsyncLock.
+
+ * \param handler Handle of the connection.
+ *
+ * \return Return (0) in case of success, otherwise (-1) in case of errors.
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int ifx_sscAsyncUnLock(IFX_SSC_HANDLE handler)
+{
+	ssc_device_t *dev;
+	IFX_SSC_CONFIGURE_t *ssc_cfg = NULL;
+	struct ifx_ssc_port *port = NULL;
+	IFX_SSC_QUEUE_t *pqueue;
+
+	SSC_KASSERT((handler != NULL),
+		("%s Invalid parameter\n", __func__));
+
+	dev = (ssc_device_t *) handler;
+	ssc_cfg = &dev->conn_id;
+	pqueue = &dev->queue;
+	port = dev->port;
+
+	if (port->lock_qentry != pqueue) {
+		/* We do not hold the lock, therefore we can not release it! */
+		return -1;
+	}
+
+	/* Just forget about the lock, then the SSC driver would just take it
+	 * as a normel queue entry
+	 */
+	ifx_ssc_cs_unlock(dev);
+	/* XXX, Possible race condition if called in in_irq() */
+	IFX_SSC_Q_LOCK_BH(port);
+	pqueue->txbuf = NULL;
+	pqueue->txsize = 0;
+	pqueue->rxbuf = NULL;
+	pqueue->rxsize = 0;
+	pqueue->exchange_bytes = 0;
+	memset(&pqueue->callback, 0, sizeof(IFX_SSC_ASYNC_CALLBACK_t));
+	port->lock_qentry = NULL;
+	IFX_SSC_Q_UNLOCK_BH(port);
+	/* Restart tasklet since we are async release SPI bus */
+	ifx_ssc_start_tasklet(port);
+	return 0;
+}
+EXPORT_SYMBOL(ifx_sscAsyncUnLock);
+
+#ifdef CONFIG_SYSCTL
+
+#define SSC_SYSCTL_DECL(f, ctl, write, filp, buffer, lenp, ppos) \
+	f(ctl_table * ctl, int write, \
+	void __user *buffer, size_t *lenp, loff_t *ppos)
+#define SSC_SYSCTL_PROC_DOINTVEC(ctl, write, filp, buffer, lenp, ppos) \
+	proc_dointvec(ctl, write, buffer, lenp, ppos)
+
+/* SSC Client driver proc entry for parameter configuration */
+enum {
+	IFX_SSC_PRIV_FRAGMENT_SIZE = 1,
+	IFX_SSC_PRIV_FIFO_SIZE = 2,
+	IFX_SSC_PRIV_BAUDRATE = 3,
+	IFX_SSC_PRIV_MODE = 4,
+};
+
+static int
+SSC_SYSCTL_DECL(ssc_sysctl_private, ctl, write, filp, buffer, lenp, ppos)
+{
+	ssc_device_t *dev = ctl->extra1;
+	IFX_SSC_CONFIGURE_t *ssc_cfg = &dev->conn_id;
+	struct ifx_ssc_port *port;
+	u32 val;
+	int ret;
+
+	port = dev->port;
+	ctl->data = &val;
+	ctl->maxlen = sizeof(val);
+	if (write) {
+		ret = SSC_SYSCTL_PROC_DOINTVEC(ctl, write, filp, buffer,
+				lenp, ppos);
+		if (ret == 0) {
+			switch ((long) ctl->extra2) {
+			case IFX_SSC_PRIV_FRAGMENT_SIZE:
+				if (val < IFX_SSC_MIN_FRAGSIZE
+				    || val > IFX_SSC_MAX_FRAGSIZE)
+					return -EINVAL;
+				ssc_cfg->fragSize = val;
+				port->ssc_fragSize = val;
+				break;
+
+			case IFX_SSC_PRIV_FIFO_SIZE:
+				if (val < IFX_SSC_FIFO_MIN_THRESHOULD
+				    || val > IFX_SSC_FIFO_MAX_THRESHOULD)
+					return -EINVAL;
+				ssc_cfg->maxFIFOSize = val;
+				break;
+
+			case IFX_SSC_PRIV_BAUDRATE:
+				/* XXX, sanity check */
+				ssc_cfg->baudrate = val;
+				break;
+
+			case IFX_SSC_PRIV_MODE:
+				ret = -EINVAL;
+				break;
+
+			default:
+				return -EINVAL;
+			}
+		}
+	} else {
+		switch ((long) ctl->extra2) {
+		case IFX_SSC_PRIV_FRAGMENT_SIZE:
+			val = ssc_cfg->fragSize;
+			break;
+
+		case IFX_SSC_PRIV_FIFO_SIZE:
+			val = ssc_cfg->maxFIFOSize;
+			break;
+
+		case IFX_SSC_PRIV_BAUDRATE:
+			val = ssc_cfg->baudrate;
+			break;
+
+		case IFX_SSC_PRIV_MODE:
+			val = ssc_cfg->ssc_mode;
+			break;
+
+		default:
+			return -EINVAL;
+		}
+		ret = SSC_SYSCTL_PROC_DOINTVEC(ctl, write, filp, buffer,
+				lenp, ppos);
+	}
+	return ret;
+}
+
+static const ctl_table ssc_sysctl_template[] = {
+	/* NB: must be last entry before NULL */
+	{IFX_INIT_CTL_NAME(CTL_AUTO)
+	 .procname = "fragment_size",
+	 .mode = 0644,
+	 .proc_handler = ssc_sysctl_private,
+	 .extra2 = (void *) IFX_SSC_PRIV_FRAGMENT_SIZE,
+	 },
+	{IFX_INIT_CTL_NAME(CTL_AUTO)
+	 .procname = "fifosize",
+	 .mode = 0644,
+	 .proc_handler = ssc_sysctl_private,
+	 .extra2 = (void *) IFX_SSC_PRIV_FIFO_SIZE,
+	 },
+	{IFX_INIT_CTL_NAME(CTL_AUTO)
+	 .procname = "baudrate",
+	 .mode = 0644,
+	 .proc_handler = ssc_sysctl_private,
+	 .extra2 = (void *) IFX_SSC_PRIV_BAUDRATE,
+	 },
+	{IFX_INIT_CTL_NAME(CTL_AUTO)
+	 .procname = "spimode",
+	 .mode = 0644,
+	 .proc_handler = ssc_sysctl_private,
+	 .extra2 = (void *) IFX_SSC_PRIV_MODE,
+	 },
+	{0}
+};
+
+static void ifx_ssc_sysctl_attach(ssc_device_t *dev)
+{
+	int i, space;
+
+	space = 5 * sizeof(struct ctl_table) + sizeof(ssc_sysctl_template);
+	dev->ssc_sysctls = kmalloc(space, GFP_KERNEL);
+	if (dev->ssc_sysctls == NULL) {
+		pr_err("%s: no memory for sysctl table!\n", __func__);
+		return;
+	}
+
+	/* setup the table */
+	memset(dev->ssc_sysctls, 0, space);
+	IFX_SET_CTL_NAME(dev->ssc_sysctls[0], CTL_DEV);
+	dev->ssc_sysctls[0].procname = "dev";
+	dev->ssc_sysctls[0].mode = 0555;
+	dev->ssc_sysctls[0].child = &dev->ssc_sysctls[2];
+	/* [1] is NULL terminator */
+	IFX_SET_CTL_NAME(dev->ssc_sysctls[2], CTL_AUTO);
+	dev->ssc_sysctls[2].procname = dev->dev_name;
+	dev->ssc_sysctls[2].mode = 0555;
+	dev->ssc_sysctls[2].child = &dev->ssc_sysctls[4];
+	/* [3] is NULL terminator */
+	/* copy in pre-defined data */
+	memcpy(&dev->ssc_sysctls[4], ssc_sysctl_template,
+		sizeof(ssc_sysctl_template));
+
+	/* add in dynamic data references */
+	for (i = 4; dev->ssc_sysctls[i].procname; i++) {
+		if (dev->ssc_sysctls[i].extra1 == NULL)
+			dev->ssc_sysctls[i].extra1 = dev;
+	}
+
+	/* tack on back-pointer to parent device */
+	dev->ssc_sysctls[i - 1].data = dev->dev_name;
+
+	/* and register everything */
+	dev->ssc_sysctl_header =
+		IFX_REGISTER_SYSCTL_TABLE(dev->ssc_sysctls);
+	if (dev->ssc_sysctl_header == NULL) {
+		pr_err("%s: failed to register sysctls!\n", dev->dev_name);
+		kfree(dev->ssc_sysctls);
+		dev->ssc_sysctls = NULL;
+	}
+}
+
+static void ifx_ssc_sysctl_detach(ssc_device_t *dev)
+{
+	if (dev->ssc_sysctl_header != NULL) {
+		unregister_sysctl_table(dev->ssc_sysctl_header);
+		dev->ssc_sysctl_header = NULL;
+	}
+	if (dev->ssc_sysctls != NULL) {
+		kfree(dev->ssc_sysctls);
+		dev->ssc_sysctls = NULL;
+	}
+}
+
+/* SSC Driver itself proc support for debug and future configuration */
+enum {
+	IFX_SSC_PRIV_DEBUG = 1,
+};
+
+static int
+SSC_SYSCTL_DECL(port_sysctl_private, ctl, write, filp, buffer, lenp, ppos)
+{
+	struct ifx_ssc_port *port = ctl->extra1;
+	u32 val;
+	int ret;
+
+	ctl->data = &val;
+	ctl->maxlen = sizeof(val);
+	if (write) {
+		ret = SSC_SYSCTL_PROC_DOINTVEC(ctl, write, filp, buffer,
+					lenp, ppos);
+		if (ret == 0) {
+			switch ((long) ctl->extra2) {
+			case IFX_SSC_PRIV_DEBUG:
+				port->ssc_debug = val;
+				break;
+
+			default:
+				return -EINVAL;
+			}
+		}
+	} else {
+		switch ((long) ctl->extra2) {
+		case IFX_SSC_PRIV_DEBUG:
+			val = port->ssc_debug;
+			break;
+
+		default:
+			return -EINVAL;
+		}
+		ret = SSC_SYSCTL_PROC_DOINTVEC(ctl, write, filp, buffer,
+				lenp, ppos);
+	}
+	return ret;
+}
+
+static const ctl_table port_sysctl_template[] = {
+	/* NB: must be last entry before NULL */
+	{IFX_INIT_CTL_NAME(CTL_AUTO)
+	 .procname = "debug",
+	 .mode = 0644,
+	 .proc_handler = port_sysctl_private,
+	 .extra2 = (void *) IFX_SSC_PRIV_DEBUG,
+	 },
+	{0}
+};
+
+static void ifx_ssc_port_sysctl_attach(struct ifx_ssc_port *port)
+{
+	int i, space;
+
+	space = 5 * sizeof(struct ctl_table) +
+		sizeof(port_sysctl_template);
+	port->port_sysctls = kmalloc(space, GFP_KERNEL);
+	if (port->port_sysctls == NULL) {
+		pr_err("%s: no memory for sysctl table!\n", __func__);
+		return;
+	}
+
+	/* setup the table */
+	memset(port->port_sysctls, 0, space);
+	IFX_SET_CTL_NAME(port->port_sysctls[0], CTL_DEV);
+	port->port_sysctls[0].procname = "dev";
+	port->port_sysctls[0].mode = 0555;
+	port->port_sysctls[0].child = &port->port_sysctls[2];
+	/* [1] is NULL terminator */
+	IFX_SET_CTL_NAME(port->port_sysctls[2], CTL_AUTO);
+	port->port_sysctls[2].procname = port->name;
+	port->port_sysctls[2].mode = 0555;
+	port->port_sysctls[2].child = &port->port_sysctls[4];
+	/* [3] is NULL terminator */
+	/* copy in pre-defined data */
+	memcpy(&port->port_sysctls[4], port_sysctl_template,
+		sizeof(port_sysctl_template));
+
+	/* add in dynamic data references */
+	for (i = 4; port->port_sysctls[i].procname; i++) {
+		if (port->port_sysctls[i].extra1 == NULL)
+			port->port_sysctls[i].extra1 = port;
+	}
+
+	/* tack on back-pointer to parent device */
+	port->port_sysctls[i - 1].data = port->name;
+
+	/* and register everything */
+	port->port_sysctl_header =
+		IFX_REGISTER_SYSCTL_TABLE(port->port_sysctls);
+	if (port->port_sysctl_header == NULL) {
+		pr_err("%s: failed to register sysctls!\n", port->name);
+		kfree(port->port_sysctls);
+		port->port_sysctls = NULL;
+	}
+}
+
+static void ifx_ssc_port_sysctl_detach(struct ifx_ssc_port *port)
+{
+	if (port->port_sysctl_header != NULL) {
+		unregister_sysctl_table(port->port_sysctl_header);
+		port->port_sysctl_header = NULL;
+	}
+	if (port->port_sysctls != NULL) {
+		kfree(port->port_sysctls);
+		port->port_sysctls = NULL;
+	}
+}
+#endif /* CONFIG_SYSCTL */
+
+/**
+ *\fn IFX_SSC_HANDLE ifx_sscAllocConnection (char *dev_name,
+ *    IFX_SSC_CONFIGURE_t *connid)
+ *\brief Allocate and create a Connection ID "ConnId"
+ *
+ * Allocate and create a Connection ID "ConnId" to communicate over SSC.
+ * This ConnId is needed for all remaining SSC driver API calls. This
+ * ConnId is a handle that helps the SSC driver to find the configuration
+ * that belongs to the connection. ConnId specific parameters are e.g.
+ * Baudrate, Priority, Chipselect Callback, etc.
+ *
+ * \param   dev_name    unique name for this connection. If null, will alloc
+ *                      one unique name automatically
+ * \param   connid      Connectin id
+ * \return  a handle "IFX_SSC_HANDLE" in case the allocation was successful.
+ *          In case of an error, the return handle is zero (NULL).
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+IFX_SSC_HANDLE
+ifx_sscAllocConnection(char *dev_name, IFX_SSC_CONFIGURE_t *connid)
+{
+	struct ifx_ssc_port *port;
+	ssc_device_t *p;
+	ssc_device_t *q;
+	IFX_SSC_QUEUE_t *queue;
+	char buf[IFX_SSC_MAX_DEVNAME] = { 0 };
+	char *pName;
+
+	/* Sanity check first! */
+	if (ifx_ssc_isp == NULL) {
+		pr_err("%s ssc driver must be loaded first!\n",
+			__func__);
+		return NULL;
+	}
+
+	port = &ifx_ssc_isp[0];	/* XXX */
+
+	if (port->ssc_ndevs >= IFX_SSC_MAX_DEVICE) {
+		IFX_SSC_PRINT(port, SSC_MSG_ERROR,
+			"%s device number out of range\n", __func__);
+		return NULL;
+	}
+
+	if (connid == NULL) {
+		IFX_SSC_PRINT(port, SSC_MSG_ERROR,
+			"%s must provide connection portrmation!\n",
+			__func__);
+		return NULL;
+	}
+
+	if ((connid->ssc_mode < IFX_SSC_MODE_0)
+	    || (connid->ssc_mode > IFX_SSC_MODE_3)) {
+		IFX_SSC_PRINT(port, SSC_MSG_ERROR,
+			"%s invalid spi mode <%d~%d>!\n", __func__,
+			IFX_SSC_MODE_0, IFX_SSC_MODE_3);
+		return NULL;
+	}
+
+	if (connid->ssc_prio < IFX_SSC_PRIO_LOW
+	    || (connid->ssc_prio > IFX_SSC_PRIO_MAX)) {
+		IFX_SSC_PRINT(port, SSC_MSG_ERROR,
+			"%s invalid priority <%d~%d>!\n", __func__,
+			IFX_SSC_PRIO_LOW, IFX_SSC_PRIO_MAX);
+	}
+
+
+	if (connid->csset_cb == NULL) {
+		IFX_SSC_PRINT(port, SSC_MSG_ERROR,
+			"%s must provide cs function\n", __func__);
+		return NULL;
+	}
+
+	if (connid->fragSize < IFX_SSC_MIN_FRAGSIZE
+	    || connid->fragSize > IFX_SSC_MAX_FRAGSIZE) {
+		IFX_SSC_PRINT(port, SSC_MSG_ERROR,
+			"%s %d invalid fragment size <%d~%d>!\n",
+			__func__, connid->fragSize,
+			IFX_SSC_MIN_FRAGSIZE, IFX_SSC_MAX_FRAGSIZE);
+		return NULL;
+	}
+
+	if (connid->maxFIFOSize < IFX_SSC_FIFO_MIN_THRESHOULD
+	    || connid->maxFIFOSize > IFX_SSC_FIFO_MAX_THRESHOULD) {
+		IFX_SSC_PRINT(port, SSC_MSG_ERROR,
+			"%s %d invalid fifo size <%d~%d>!\n",
+			__func__, connid->maxFIFOSize,
+			IFX_SSC_FIFO_MIN_THRESHOULD,
+			IFX_SSC_FIFO_MAX_THRESHOULD);
+		return NULL;
+	}
+
+	if (connid->duplex_mode != IFX_SSC_FULL_DUPLEX
+	    && connid->duplex_mode != IFX_SSC_HALF_DUPLEX) {
+		IFX_SSC_PRINT(port, SSC_MSG_ERROR,
+			"%s %d invalid duplex mode <%d~%d>!\n",
+			__func__, connid->duplex_mode,
+			IFX_SSC_FULL_DUPLEX, IFX_SSC_HALF_DUPLEX);
+		return NULL;
+	}
+	/* If no name specified, will assign one name for identification */
+	if (dev_name == NULL) {
+		sprintf(buf, "ssc%d", port->ssc_ndevs);
+		pName = buf;
+	} else {
+		if (strlen(dev_name) > (IFX_SSC_MAX_DEVNAME - 1)) {
+			IFX_SSC_PRINT(port, SSC_MSG_ERROR,
+				"%s device name is too long\n",
+				__func__);
+			return NULL;
+		}
+		pName = dev_name;
+	}
+
+	p = kmalloc(sizeof(ssc_device_t), GFP_KERNEL);
+	if (p == NULL) {
+		IFX_SSC_PRINT(port, SSC_MSG_ERROR,
+			"%s failed to allocate memory\n", __func__);
+		return NULL;
+	}
+	memset(p, 0, sizeof(ssc_device_t));
+
+	IFX_SSC_SEM_LOCK(port->dev_sem);
+	TAILQ_FOREACH(q, &port->ssc_devq, dev_entry) {
+		if (strcmp(q->dev_name, pName) == 0) {
+			kfree(p);
+			IFX_SSC_SEM_UNLOCK(port->dev_sem);
+			IFX_SSC_PRINT(port, SSC_MSG_ERROR,
+				"%s device registered already!\n",
+				__func__);
+			return NULL;
+		}
+	}
+	IFX_SSC_SEM_UNLOCK(port->dev_sem);
+
+	/* Follow net device driver name rule */
+	memcpy(p->dev_name, pName, IFX_SSC_MAX_DEVNAME);
+	p->duplex = connid->duplex_mode;
+	memcpy((char *) &p->conn_id, (char *) connid,
+		sizeof(IFX_SSC_CONFIGURE_t));
+
+	queue = &p->queue;
+	/* Queue handler type converted from priority */
+	if (connid->ssc_prio == IFX_SSC_PRIO_ASYNC)
+		queue->handle_type = IFX_SSC_HANDL_TYPE_ASYNC;
+	else
+		queue->handle_type = IFX_SSC_HANDL_TYPE_SYNC;
+
+	/* Back pointer to later usage */
+	queue->dev = p;
+	atomic_set(&queue->isqueued, 0);
+	queue->request_lock = false;
+	/*
+	 * Just for fast access, priority based on device, instead of packet
+	 * Still keep per packet priority there for future change.
+	 */
+	p->dev_prio = connid->ssc_prio;
+
+	IFX_SSC_WAKELIST_INIT(p->dev_thread_wait);
+
+	p->port = port; /* back pointer to port for easy reference later */
+	port->ssc_ndevs++;
+#ifdef CONFIG_SYSCTL
+	ifx_ssc_sysctl_attach(p);
+#endif /* CONFIG_SYSCTL */
+	IFX_SSC_SEM_LOCK(port->dev_sem);
+	TAILQ_INSERT_TAIL(&port->ssc_devq, p, dev_entry);
+	IFX_SSC_SEM_UNLOCK(port->dev_sem);
+
+	/* Make sure very device CS in default state on registration */
+	if (connid->csset_cb != NULL)
+		connid->csset_cb(IFX_SSC_CS_OFF, connid->cs_data);
+
+	IFX_SSC_PRINT(port, SSC_MSG_INIT,
+		"%s: device %s register sucessfully!\n", __func__,
+		p->dev_name);
+	return (IFX_SSC_HANDLE) p;
+}
+EXPORT_SYMBOL(ifx_sscAllocConnection);
+
+/**
+ *\fn int ifx_sscFreeConnection (IFX_SSC_HANDLE handler)
+ *\brief Release ssc connnection
+ *
+ * Release a ConnId handle that was allocated by the function
+ * ifx_SscAllocConnection before. An allocated ConnId has to
+ * be released by the client driver module when the SSC driver
+ * is not used anymore. Note that all allocated ConnId's should
+ * be released before the SSC driver is unloaded from the kernel.
+ *
+ * \param   handler    ConnId handle allocated by ifx_SscAllocConnection
+ * \returns (0) in case of success, otherwise (-1) in case of errors.
+ * \ingroup IFX_SSC_FUNCTIONS
+ */
+int ifx_sscFreeConnection(IFX_SSC_HANDLE handler)
+{
+	ssc_device_t *p;
+	struct ifx_ssc_port *port;
+	ssc_device_t *q, *next;
+
+	SSC_KASSERT((handler != NULL), ("%s Invalid parameter\n", __func__));
+
+	p = (ssc_device_t *) handler;
+	port = p->port;
+	IFX_SSC_SEM_LOCK(port->dev_sem);
+	TAILQ_FOREACH_SAFE(q, &port->ssc_devq, dev_entry, next) {
+		if (strcmp(q->dev_name, p->dev_name) == 0) {
+			TAILQ_REMOVE(&port->ssc_devq, q, dev_entry);
+		#ifdef CONFIG_SYSCTL
+			ifx_ssc_sysctl_detach(q);
+		#endif /* CONFIG_SYSCTL */
+			kfree(q);
+			port->ssc_ndevs--;
+			IFX_SSC_SEM_UNLOCK(port->dev_sem);
+			IFX_SSC_PRINT(port, SSC_MSG_INIT,
+				"%s device %s unregistered\n",
+				__func__, p->dev_name);
+			return 0;
+		}
+	}
+	IFX_SSC_SEM_UNLOCK(port->dev_sem);
+	return -1;
+}
+EXPORT_SYMBOL(ifx_sscFreeConnection);
+
+/**
+ * \fn static void ifx_ssc_proc_init(void)
+ * \brief Create ssc proc directory and file when module initialized.
+ *
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int __init ifx_ssc_proc_init(void)
+{
+	struct proc_dir_entry *entry;
+
+	ifx_ssc_proc = proc_mkdir("driver/ltq_ssc", NULL);
+	if (!ifx_ssc_proc)
+		return -ENOMEM;
+
+	entry = proc_create("stats", 0,
+			ifx_ssc_proc, &ifx_ssc_stats_proc_fops);
+	if (!entry)
+		goto err1;
+
+	entry = proc_create("reg", 0,
+			ifx_ssc_proc, &ifx_ssc_reg_proc_fops);
+	if (!entry)
+		goto err2;
+	return 0;
+err2:
+	remove_proc_entry("stats", ifx_ssc_proc);
+err1:
+	remove_proc_entry("driver/ltq_ssc", NULL);
+	return -ENOMEM;
+}
+
+/**
+ * \fn static void ifx_ssc_proc_exit(void)
+ * \brief Delete ssc proc directory and file.
+ *
+ * \return  none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static void ifx_ssc_proc_exit(void)
+{
+	remove_proc_entry("stats", ifx_ssc_proc);
+
+	remove_proc_entry("reg", ifx_ssc_proc);
+
+	remove_proc_entry("driver/ltq_ssc", NULL);
+}
+
+/**
+ * \fn static int __init ifx_ssc_init (void)
+ * \brief SSC module Initialization.
+ *
+ * \return -ENOMEM  Failed to allocate memory
+ * \return -EBUSY   Failed to iomap register space
+ * \return 0        OK
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int ifx_ssc_init(struct platform_device *pdev)
+{
+	u32 reg;
+	struct ifx_ssc_port *port;
+	int j;
+	int ret_val = -ENOMEM;
+	static int ifx_ssc_initialized;
+	struct clk *clk;
+	struct resource *r;
+	u32 id;
+
+	ifx_ssc_isp = kzalloc(sizeof(struct ifx_ssc_port), GFP_KERNEL);
+	if (ifx_ssc_isp == NULL) {
+		pr_err("%s: no memory for isp\n", __func__);
+		return ret_val;
+	}
+	port = ifx_ssc_isp;
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		dev_err(&pdev->dev, "platform_get_resource\n");
+		ret_val = -ENOENT;
+		return ret_val;
+	}
+
+	r = devm_request_mem_region(&pdev->dev, r->start, resource_size(r),
+			pdev->name);
+	if (!r) {
+		dev_err(&pdev->dev, "failed to request memory region\n");
+		ret_val = -ENXIO;
+		return ret_val;
+	}
+	port->membase = devm_ioremap_nocache(&pdev->dev,
+		r->start, resource_size(r));
+	if (!port->membase) {
+		dev_err(&pdev->dev, "failed to remap memory region\n");
+		ret_val = -ENXIO;
+		return ret_val;
+	}
+	if (ifx_ssc_initialized == 1)
+		return 0;
+	else
+		ifx_ssc_initialized = 1;
+
+	port->port_idx = 0;
+	/* default values for the HwOpts */
+	port->opts.abortErrDetect = IFX_SSC_DEF_ABRT_ERR_DETECT;
+	port->opts.rxOvErrDetect = IFX_SSC_DEF_RO_ERR_DETECT;
+	port->opts.rxUndErrDetect = IFX_SSC_DEF_RU_ERR_DETECT;
+	port->opts.txOvErrDetect = IFX_SSC_DEF_TO_ERR_DETECT;
+	port->opts.txUndErrDetect = IFX_SSC_DEF_TU_ERR_DETECT;
+	port->opts.loopBack = IFX_SSC_DEF_LOOP_BACK;
+	port->opts.echoMode = IFX_SSC_DEF_ECHO_MODE;
+	port->opts.idleValue = IFX_SSC_DEF_IDLE_DATA;
+	port->opts.clockPolarity = IFX_SSC_DEF_CLOCK_POLARITY;
+	port->opts.clockPhase = IFX_SSC_DEF_CLOCK_PHASE;
+	port->opts.headingControl = IFX_SSC_DEF_HEADING_CONTROL;
+	port->opts.dataWidth = IFX_SSC_DEF_DATA_WIDTH;
+	port->opts.modeRxTx = IFX_SSC_DEF_MODE_RXTX;
+	port->opts.gpoCs = IFX_SSC_DEF_GPO_CS;
+	port->opts.gpoInv = IFX_SSC_DEF_GPO_INV;
+	port->opts.masterSelect = IFX_SSC_DEF_MASTERSLAVE;
+	port->prev_ssc_clk = 0;
+	port->baudrate = IFX_SSC_DEF_BAUDRATE;
+	port->prev_baudrate = 0;
+	port->prev_ssc_mode = IFX_SSC_MODE_UNKNOWN;
+	port->ssc_ndevs = 0;
+	port->ssc_fragSize = DEFAULT_SSC_FRAGMENT_SIZE;
+	port->fpiclk = clk_get_fpi();
+	if (IS_ERR(port->fpiclk)) {
+		pr_err("%s Failed to get fpi clock\n", __func__);
+		ret_val = PTR_ERR(port->fpiclk);
+		goto err_clk;
+	}
+
+	/* Activate SSC */
+	clk = clk_get_sys("1e100800.spi", NULL);
+	clk_enable(clk);
+
+	reg = IFX_SSC_GET_CLC(port);
+	reg |= SM(IFX_SSC_DEF_RMC, IFX_SSC_CLC_RMC);
+	reg &= ~IFX_SSC_CLC_DIS;
+	IFX_SSC_SET_CLC(reg, port);
+
+	id = IFX_SSC_GET_ID(port);
+	if (of_machine_is_compatible("lantiq,ar10")
+		|| of_machine_is_compatible("lantiq,grx390")
+		|| of_machine_is_compatible("lantiq,ase"))
+		port->dma_support = 0;
+	else
+		port->dma_support = 1;
+	/* Either SSC tasklet or SSC kernel thread support, not both */
+#ifdef CONFIG_LANTIQ_SPI_ASYNCHRONOUS
+	ifx_ssc_tasklet_init(port);
+#else
+	if (ifx_ssc_thread_init(port)) {
+		pr_err("%s: unable to start ssc_kthread\n", __func__);
+		goto errout1;
+	}
+#endif /* CONFIG_LANTIQ_SPI_ASYNCHRONOUS */
+	if (port->dma_support) {
+		/* Register with DMA engine */
+		port->dma_dev = dma_device_reserve("SPI");
+		if (port->dma_dev == NULL) {
+			pr_err("%s: Failed to reserve dma device!\n", __func__);
+			goto errout1;
+		}
+		ifx_ssc_init_dma_device(0, port->dma_dev);
+	}
+
+	strcpy(port->name, IFX_SSC_NAME);
+	port->ssc_cs_locked = false;
+	port->lock_qentry = NULL;
+	port->serve_qentry = NULL;
+#ifdef CONFIG_LANTIQ_SPI_DEBUG
+	port->ssc_debug = SSC_MSG_ERROR;
+#else
+	port->ssc_debug = 0;
+#endif /* CONFIG_LANTIQ_SPI_DEBUG */
+	port->dma_is_in_half_duplex = 1;
+	atomic_set(&port->dma_wait_state, 0);
+
+	if (port->dma_support) {
+		/* The following buffer allocation for HW WAR, last 1~3 bytes
+		 * in DMA, It will make sure buffer will align on dma
+		 * burst length
+		 */
+		port->dma_orig_txbuf = kmalloc(DEFAULT_SSC_FRAGMENT_SIZE
+			+ ((port->dma_dev->tx_burst_len << 2) - 1),
+			GFP_KERNEL);
+		if (port->dma_orig_txbuf == NULL) {
+			pr_err("%s: no memory for dma_orig_txbuf\n", __func__);
+			goto errout2;
+		}
+		port->dma_txbuf = (char *) (((u32) (port->dma_orig_txbuf +
+			((port->dma_dev->tx_burst_len << 2) - 1)))&~
+			((port->dma_dev->tx_burst_len << 2) - 1));
+
+
+		port->dma_orig_rxbuf = kmalloc(DEFAULT_SSC_FRAGMENT_SIZE
+			+ ((port->dma_dev->rx_burst_len << 2) - 1), GFP_KERNEL);
+		if (port->dma_orig_rxbuf == NULL) {
+			pr_err("%s: no memory for dma_orig_rxbuf\n", __func__);
+			goto errout3;
+		}
+		port->dma_rxbuf = (char *) (((u32) (port->dma_orig_rxbuf +
+			((port->dma_dev->rx_burst_len << 2) - 1)))&~
+			((port->dma_dev->rx_burst_len << 2) - 1));
+	}
+
+	/* Queue initialization */
+	TAILQ_INIT(&port->ssc_devq);
+	TAILQ_INIT(&port->ssc_asyncq);
+	for (j = 0; j < IFX_SSC_PRIO_MAX; j++)
+		TAILQ_INIT(&port->ssc_syncq[j]);
+
+	IFX_SSC_Q_LOCK_INIT(port);
+	IFX_SSC_SEM_INIT(port->dev_sem);
+	IFX_SSC_WAKELIST_INIT(port->ssc_thread_wait);
+	IFX_SSC_IRQ_LOCK_INIT(port, "ifx_ssc_lock");
+
+	/* Disable SSC module level real hardware interrupts */
+	IFX_SSC_SET_IRN_EN(0, port);
+
+	/* init serial framing register */
+	IFX_SSC_SET_FRAMING_CON(IFX_SSC_DEF_SFCON, port);
+
+	if (ifx_ssc_hwinit(port) < 0) {
+		pr_err("%s: hardware init failed\n", __func__);
+		goto errout4;
+	}
+#ifdef CONFIG_SYSCTL
+	ifx_ssc_port_sysctl_attach(port);
+#endif /* CONFIG_SYSCTL */
+	goto out;
+errout4:
+	if (port->dma_support) {
+		kfree(port->dma_orig_rxbuf);
+errout3:
+		kfree(port->dma_orig_txbuf);
+		dma_device_unregister(port->dma_dev);
+		dma_device_release(port->dma_dev);
+	}
+
+	kthread_stop(port->ssc_tsk);
+errout2:
+	if (clk) {
+		clk_disable(clk);
+		clk_put(clk);
+	}
+errout1:
+	if (port->fpiclk)
+		clk_put(port->fpiclk);
+err_clk:
+	kfree(ifx_ssc_isp);
+	return ret_val;
+
+out:
+	ifx_ssc_proc_init();
+
+	pr_info("Lantiq SoC SSC controller rev %u (TXFS %u, RXFS %u, DMA %u)\n",
+		id & IFX_SSC_ID_REV, port->tx_fifo_size_words,
+		port->rx_fifo_size_words, port->dma_support);
+
+	return 0;
+}
+
+/**
+ * \fn static void __exit ifx_ssc_exit (void)
+ * \brief SSC Module Cleanup.
+ *
+ * Upon removal of the SSC module this function will free all allocated
+ * resources and unregister devices.
+ * \return none
+ * \ingroup IFX_SSC_INTERNAL
+ */
+static int ifx_ssc_exit(struct platform_device *pdev)
+{
+	struct ifx_ssc_port *port;
+	struct clk *clk;
+
+	/* free up any allocated memory */
+
+	port = &ifx_ssc_isp[0];
+	/* Disable the SSC */
+	IFX_SSC_CONFIG_MODE(port);
+
+	IFX_SSC_SEM_LOCK(port->dev_sem);
+	if (!TAILQ_EMPTY(&port->ssc_devq)) {
+		IFX_SSC_SEM_UNLOCK(port->dev_sem);
+		pr_err("%s SSC devices still attached, please release them first\n",
+			__func__);
+		return -1;
+	}
+	IFX_SSC_SEM_UNLOCK(port->dev_sem);
+#ifdef CONFIG_LANTIQ_SPI_ASYNCHRONOUS
+	tasklet_kill(&port->ssc_txrxq);
+#else
+	if (port->ssc_tsk) {
+		kthread_stop(port->ssc_tsk);
+		port->ssc_tsk = NULL;
+	}
+
+#endif /* CONFIG_LANTIQ_SPI_ASYNCHRONOUS */
+	IFX_SSC_IRQ_LOCK_DESTROY(port);
+	IFX_SSC_Q_LOCK_DESTROY(port);
+	if (port->dma_support) {
+		struct dma_device_info *dma_dev;
+		dma_dev = port->dma_dev;
+		if (dma_dev != NULL) {
+			dma_device_unregister(dma_dev);
+			dma_device_release(dma_dev);
+		}
+	}
+#ifdef CONFIG_SYSCTL
+	ifx_ssc_port_sysctl_detach(port);
+#endif /* CONFIG_SYSCTL */
+
+	if (port->dma_support) {
+		kfree(port->dma_orig_rxbuf);
+		kfree(port->dma_orig_txbuf);
+	}
+	iounmap(port->membase);
+
+	kfree(ifx_ssc_isp);
+	ifx_ssc_proc_exit();
+	clk = clk_get_sys("1e100800.spi", NULL);
+	clk_disable(clk);
+	clk_put(clk);
+	return 0;
+}
+
+static const struct of_device_id ltq_spi_match[] = {
+	{ .compatible = "lantiq,spi-ssc" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ltq_spi_match);
+
+static struct platform_driver ltq_spi_driver = {
+	.probe = ifx_ssc_init,
+	.remove = ifx_ssc_exit,
+	.driver = {
+		.name = "spi-ssc",
+		.owner = THIS_MODULE,
+		.of_match_table = ltq_spi_match,
+	},
+};
+
+module_platform_driver(ltq_spi_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Lei Chuanhua, chuanhua.lei@infineon.com");
+MODULE_DESCRIPTION("IFX SSC driver");
+MODULE_SUPPORTED_DEVICE("IFX SSC IP module");
+
diff --git a/drivers/spi/ltq_ssc.h b/drivers/spi/ltq_ssc.h
new file mode 100755
--- /dev/null
+++ b/drivers/spi/ltq_ssc.h
@@ -0,0 +1,1065 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2009~2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+
+/*!
+ \file ltq_ssc.h
+ \ingroup IFX_SSC
+ \brief header file for ifx ssc driver internal definition
+*/
+
+#ifndef LTQ_SSC_H
+#define LTQ_SSC_H
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/semaphore.h>
+#include <lantiq_soc.h>
+#include <lantiq_ssc.h>
+
+#define MS(_v, _f)  (((_v) & (_f)) >> _f##_S)
+#define SM(_v, _f)  (((_v) << _f##_S) & (_f))
+
+#define ltq_ssc_r32    ltq_r32
+#define ltq_ssc_w32    ltq_w32
+
+
+#define IFX_SSC_PHY_BASE              (0x1E100800)
+#define IFX_SSC_SIZE                   256
+
+/* Default values for SSC configuration */
+#define IFX_SSC_DEF_IDLE_DATA       1  /* enable */
+#define IFX_SSC_DEF_BYTE_VALID_CTL  1  /* enable */
+#define IFX_SSC_DEF_DATA_WIDTH      32 /* bits */
+#define IFX_SSC_DEF_ABRT_ERR_DETECT 0  /* disable */
+#define IFX_SSC_DEF_RO_ERR_DETECT   1  /* enable */
+#define IFX_SSC_DEF_RU_ERR_DETECT   0  /* disable */
+#define IFX_SSC_DEF_TO_ERR_DETECT   0  /* disable */
+#define IFX_SSC_DEF_TU_ERR_DETECT   0  /* disable */
+#define IFX_SSC_DEF_LOOP_BACK       0  /* disable */
+#define IFX_SSC_DEF_ECHO_MODE       0  /* disable */
+#define IFX_SSC_DEF_CLOCK_POLARITY  0  /* low */
+#define IFX_SSC_DEF_CLOCK_PHASE     1
+#define IFX_SSC_DEF_HEADING_CONTROL IFX_SSC_MSB_FIRST
+#define IFX_SSC_DEF_MODE_RXTX       IFX_SSC_MODE_RXTX
+
+#define IFX_SSC_DEF_MASTERSLAVE     IFX_SSC_MASTER_MODE /* master */
+#ifdef CONFIG_USE_EMULATOR
+#define IFX_SSC_DEF_BAUDRATE        10000
+#else
+#define IFX_SSC_DEF_BAUDRATE        2000000
+#endif
+#define IFX_SSC_DEF_RMC             0x01 /* To use it up to max value */
+
+/* Tunnable, Smaller Trigger level means small polling time
+ * Max trigger level is equal to FIFO size - DMA burst length
+ */
+#define IFX_SSC_DEF_TXFIFO_FL       4
+
+/* DMA case, RX info must be even number */
+#define IFX_SSC_DEF_RXFIFO_FL       4
+
+#define IFX_SSC_DEF_GPO_CS      0x3 /* no chip select */
+#define IFX_SSC_DEF_GPO_INV     0   /* no chip select */
+#define IFX_SSC_DEF_SFCON       0   /* no serial framing */
+#define IFX_SSC_DEF_IRNEN       \
+	(IFX_SSC_T_BIT | IFX_SSC_R_BIT | IFX_SSC_E_BIT)
+
+/* Macros to configure SSC hardware */
+/* headingControl: */
+#define IFX_SSC_LSB_FIRST            0
+#define IFX_SSC_MSB_FIRST            1
+/* dataWidth: */
+#define IFX_SSC_MIN_DATA_WIDTH       2
+#define IFX_SSC_MAX_DATA_WIDTH       32
+/* master/slave mode select */
+#define IFX_SSC_MASTER_MODE          1
+#define IFX_SSC_SLAVE_MODE           0
+/* rx/tx mode */
+#define IFX_SSC_MODE_RXTX        0
+#define IFX_SSC_MODE_RX          1
+#define IFX_SSC_MODE_TX          2
+#define IFX_SSC_MODE_OFF         3
+#define IFX_SSC_MODE_MASK        (IFX_SSC_MODE_RX | IFX_SSC_MODE_TX)
+
+/* GPO values */
+#define IFX_SSC_MAX_GPO_OUT      7
+
+#define IFX_SSC_RXREQ_BLOCK_SIZE     32768
+
+/* Clock Control Register*/
+#define IFX_SSC_CLC                     0x00000000
+/* CLC register bits */
+#define IFX_SSC_CLC_EN                  0x00000000
+#define IFX_SSC_CLC_DIS                 0x00000001
+#define IFX_SSC_CLC_DIS_STATUS          0x00000002
+#define IFX_SSC_CLC_SUSPEND_EN          0x00000004
+#define IFX_SSC_CLC_EXT_CLOCK_DIS       0x00000008
+#define IFX_SSC_CLC_WR_PROTECT_DIS      0x00000010
+#define IFX_SSC_CLC_FAST_CLOCK_SHUT_OFF 0x00000020
+#define IFX_SSC_CLC_RMC                 0x0000FF00
+#define IFX_SSC_CLC_RMC_S               8
+#define IFX_SSC_CLC_SMC                 0x00FF0000
+#define IFX_SSC_CLC_SMC_S               16
+
+/* Port Input Select Register*/
+#define IFX_SSC_PISEL                   0x00000004
+
+#define IFX_SSC_PISEL_MASTER_IN_A       0x0000
+#define IFX_SSC_PISEL_MASTER_IN_B       0x0001
+#define IFX_SSC_PISEL_SLAVE_IN_A        0x0000
+#define IFX_SSC_PISEL_SLAVE_IN_B        0x0002
+#define IFX_SSC_PISEL_CLOCK_IN_A        0x0000
+#define IFX_SSC_PISEL_CLOCK_IN_B        0x0004
+
+/* Identification Register */
+#define IFX_SSC_ID                      0x00000008
+
+#define IFX_SSC_ID_REV                  0x0000001F
+#define IFX_SSC_ID_REV_S                0
+#define IFX_SSC_ID_CFG_DMA              0x00000020
+#define IFX_SSC_ID_MODULE_ID            0x0000FF00
+#define IFX_SSC_ID_MODULE_ID_S          8
+#define IFX_SSC_ID_RXFS                 0x003F0000
+#define IFX_SSC_ID_RXFS_S               16
+#define IFX_SSC_ID_TXFS                 0x3F000000
+#define IFX_SSC_ID_TXFS_S               24
+
+#define IFX_SSC_ID_MODULE_ID_VAL        0x45
+
+/* address of the Control Register of the SSC */
+#define IFX_SSC_CON                         0x00000010
+
+/* IFX_SSC_CON register */
+
+#define IFX_SSC_CON_RX_SWAP                 0x04000000
+#define IFX_SSC_CON_TX_SWAP                 0x02000000
+
+#define IFX_SSC_CON_CLK_DELAY                  0xF0000000
+#define IFX_SSC_CON_CLK_DELAY_S                28
+#define IFX_SSC_CON_CLK_DELAY_HALF_CYCLE       1
+#define IFX_SSC_CON_CLK_DELAY_ONE_CYCLE        2
+#define IFX_SSC_CON_CLK_DELAY_ONE_HALF_CYCLE   3
+#define IFX_SSC_CON_CLK_DELAY_TWO_CYCLE        4
+#define IFX_SSC_CON_CLK_DELAY_TWO_HALF_CYCLE   5
+#define IFX_SSC_CON_CLK_DELAY_THREE_CYCLE      6
+#define IFX_SSC_CON_CLK_DELAY_THREE_HALF_CYCLE 7
+#define IFX_SSC_CON_CLK_DELAY_FOUR_CYCLE       8
+#define IFX_SSC_CON_CLK_DELAY_FOUR_HALF_CYCLE  9
+#define IFX_SSC_CON_CLK_DELAY_FIVE_CYCLE       10
+#define IFX_SSC_CON_CLK_DELAY_FIVE_HALF_CYCLE  11
+#define IFX_SSC_CON_CLK_DELAY_SIX_CYCLE        12
+#define IFX_SSC_CON_CLK_DELAY_SIX_HALF_CYCLE   13
+#define IFX_SSC_CON_CLK_DELAY_SEVEN_CYCLE      14
+#define IFX_SSC_CON_CLK_DELAY_SEVEN_HALF_CYCLE 15
+
+#define IFX_SSC_CON_CLK_DELAY_DEFAULT  IFX_SSC_CON_CLK_DELAY_THREE_CYCLE
+
+
+#define IFX_SSC_CON_TXENDI                  0x04000000
+#define IFX_SSC_CON_RXENDI                  0x02000000
+#define IFX_SSC_CON_ECHO_MODE_ON            0x01000000
+#define IFX_SSC_CON_IDLE_HIGH               0x00800000
+#define IFX_SSC_CON_ENABLE_BYTE_VALID       0x00400000
+
+#define IFX_SSC_CON_DATA_WIDTH              0x001F0000
+#define IFX_SSC_CON_DATA_WIDTH_S            16
+
+#define IFX_SSC_CON_LATCH_CLK_DELAY         0x00002000
+#define IFX_SSC_CON_RX_UFL_CHECK            0x00001000
+#define IFX_SSC_CON_TX_UFL_CHECK            0x00000800
+#define IFX_SSC_CON_ABORT_ERR_CHECK         0x00000400
+#define IFX_SSC_CON_RX_OFL_CHECK            0x00000200
+#define IFX_SSC_CON_TX_OFL_CHECK            0x00000100
+
+#define IFX_SSC_CON_LOOPBACK_MODE           0x00000080
+#define IFX_SSC_CON_PO                      0x00000040
+#define IFX_SSC_CON_PH                      0x00000020
+#define IFX_SSC_CON_MSB_FIRST               0x00000010
+#define IFX_SSC_CON_ENABLE_CS_SLAVE         0x00000008
+#define IFX_SSC_CON_INVERT_CS_HIGH_ACTIVE   0x00000004
+#define IFX_SSC_CON_RX_OFF                  0x00000002
+#define IFX_SSC_CON_TX_OFF                  0x00000001
+
+#define IFX_SSC_ENCODE_DATA_WIDTH(width)  \
+	(SM(((width) - 1), IFX_SSC_CON_DATA_WIDTH))
+
+/* Status Register */
+#define IFX_SSC_STATE                      0x00000014
+
+#define IFX_SSC_STATE_RX_EOM               0x80000000
+#define IFX_SSC_STATE_RX_BYTE_VALID        0x70000000
+#define IFX_SSC_STATE_RX_BYTE_VALID_S      28
+
+#define IFX_SSC_DECODE_RX_BYTE_VALID(con_state) \
+	(MS((con_state), IFX_SSC_STATE_RX_BYTE_VALID))
+
+#define IFX_SSC_STATE_TX_EOM               0x08000000
+#define IFX_SSC_STATE_TX_BYTE_VALID        0x07000000
+#define IFX_SSC_STATE_TX_BYTE_VALID_S      24
+#define IFX_SSC_DECODE_TX_BYTE_VALID(con_state) \
+	(MS((con_state), IFX_SSC_STATE_TX_BYTE_VALID))
+
+#define IFX_SSC_STATE_BIT_COUNT            0x001F0000
+#define IFX_SSC_STATE_BIT_COUNT_S          16
+
+#define IFX_SSC_DECODE_DATA_WIDTH(con_state) \
+	(MS((con_state), IFX_SSC_STATE_BIT_COUNT) + 1)
+
+#define IFX_SSC_STATE_BUSY                 0x00002000
+#define IFX_SSC_STATE_RX_UFL               0x00001000
+#define IFX_SSC_STATE_TX_UFL               0x00000800
+#define IFX_SSC_STATE_ABORT_ERR            0x00000400
+#define IFX_SSC_STATE_RX_OFL               0x00000200
+#define IFX_SSC_STATE_TX_OFL               0x00000100
+#define IFX_SSC_STATE_MODE_ERR             0x00000080
+#define IFX_SSC_STATE_SLAVE_SELECTED       0x00000004
+#define IFX_SSC_STATE_MASTER               0x00000002
+#define IFX_SSC_STATE_ENABLED              0x00000001
+
+/* Write Hardware Modified Control Register Bits  */
+#define IFX_SSC_WHBSTATE                    0x00000018
+#define IFX_SSC_WHBSTATE_DISABLE_SSC        0x00000001
+#define IFX_SSC_WHBSTATE_CONFIGURATION_MODE 0x00000001
+#define IFX_SSC_WHBSTATE_ENABLE_SSC         0x00000002
+#define IFX_SSC_WHBSTATE_RUN_MODE           0x00000002
+#define IFX_SSC_WHBSTATE_SLAVE_MODE         0x00000004
+#define IFX_SSC_WHBSTATE_MASTER_MODE        0x00000008
+#define IFX_SSC_WHBSTATE_CLR_RX_UFL_ERROR   0x00000010
+#define IFX_SSC_WHBSTATE_SET_RX_UFL_ERROR   0x00000020
+#define IFX_SSC_WHBSTATE_CLR_MODE_ERROR     0x00000040
+#define IFX_SSC_WHBSTATE_SET_MODE_ERROR     0x00000080
+#define IFX_SSC_WHBSTATE_CLR_TX_OFL_ERROR   0x00000100
+#define IFX_SSC_WHBSTATE_CLR_RX_OFL_ERROR   0x00000200
+#define IFX_SSC_WHBSTATE_CLR_ABORT_ERROR    0x00000400
+#define IFX_SSC_WHBSTATE_CLR_TX_UFL_ERROR   0x00000800
+#define IFX_SSC_WHBSTATE_SET_TX_OFL_ERROR   0x00001000
+#define IFX_SSC_WHBSTATE_SET_RX_OFL_ERROR   0x00002000
+#define IFX_SSC_WHBSTATE_SET_ABORT_ERROR    0x00004000
+#define IFX_SSC_WHBSTATE_SET_TX_UFL_ERROR   0x00008000
+#define IFX_SSC_WHBSTATE_CLR_ALL_ERROR      0x00000F50
+#define IFX_SSC_WHBSTATE_SET_ALL_ERROR      0x0000F0A0
+
+/* Baudrate Timer Reload Register */
+#define IFX_SSC_BR                          0x00000040
+#define IFX_SSC_BR_BAUDRATE                 0xFFFF
+#define IFX_SSC_BR_BAUDRATE_S               0
+
+/* Baudrate Timer Status Register */
+#define IFX_SSC_BRSTAT                      0x00000044
+#define IFX_SSC_BRSTAT_BAUDTIMER            0xFFFF
+#define IFX_SSC_BRSTAT_BAUDTIMER_S          0
+
+/* Transmitter Buffer Register */
+#define IFX_SSC_TB                          0x00000020
+#define IFX_SSC_TB_DATA                     0xFFFFFFFF
+#define IFX_SSC_TB_DATA_S                   0
+
+/* Reciver Buffer Register */
+#define IFX_SSC_RB                          0x00000024
+#define IFX_SSC_RB_DATA                     0xFFFFFFFF
+#define IFX_SSC_RB_DATA_S                   0
+
+/* Receive FIFO Control Register */
+#define IFX_SSC_RXFCON                      0x00000030
+
+/* Transmit FIFO Control Register */
+#define IFX_SSC_TXFCON                      0x00000034
+
+#define IFX_SSC_XFCON_FIFO_ENABLE           0x00000001
+#define IFX_SSC_XFCON_FIFO_FLUSH            0x00000002
+#define IFX_SSC_XFCON_ITL                   0x00003F00
+#define IFX_SSC_XFCON_ITL_S                 8
+
+/* FIFO Status Register */
+#define IFX_SSC_FSTAT                       0x00000038
+#define IFX_SSC_FSTAT_RX_WORDS              0x0000003F
+#define IFX_SSC_FSTAT_RX_WORDS_S            0
+#define IFX_SSC_FSTAT_TX_WORDS              0x00003F00
+#define IFX_SSC_FSTAT_TX_WORDS_S            8
+
+/* Data Frame Control register */
+#define IFX_SSC_SFCON                          0x00000060
+#define IFX_SSC_SFCON_SF_ENABLE                0x00000001
+#define IFX_SSC_SFCON_FIR_ENABLE_BEFORE_PAUSE  0x00000004
+#define IFX_SSC_SFCON_FIR_ENABLE_AFTER_PAUSE   0x00000008
+#define IFX_SSC_SFCON_DATA_LENGTH              0x0000FFF0
+#define IFX_SSC_SFCON_DATA_LENGTH_S            4
+#define IFX_SSC_SFCON_PAUSE_DATA               0x00030000
+#define IFX_SSC_SFCON_PAUSE_DATA_S             16
+#define IFX_SSC_SFCON_PAUSE_DATA_0             0x00000000
+#define IFX_SSC_SFCON_PAUSE_DATA_1             0x00010000
+#define IFX_SSC_SFCON_PAUSE_DATA_IDLE          0x00020000
+#define IFX_SSC_SFCON_PAUSE_CLOCK              0x000C0000
+#define IFX_SSC_SFCON_PAUSE_CLOCK_S            18
+#define IFX_SSC_SFCON_PAUSE_CLOCK_0            0x00000000
+#define IFX_SSC_SFCON_PAUSE_CLOCK_1            0x00040000
+#define IFX_SSC_SFCON_PAUSE_CLOCK_IDLE         0x00080000
+#define IFX_SSC_SFCON_PAUSE_CLOCK_RUN          0x000C0000
+#define IFX_SSC_SFCON_STOP_AFTER_PAUSE         0x00100000
+#define IFX_SSC_SFCON_CONTINUE_AFTER_PAUSE     0x00000000
+#define IFX_SSC_SFCON_PAUSE_LENGTH             0xFFC00000
+#define IFX_SSC_SFCON_PAUSE_LENGTH_S           22
+#define IFX_SSC_SFCON_DATA_LENGTH_MAX          4096
+#define IFX_SSC_SFCON_PAUSE_LENGTH_MAX         1024
+
+#define IFX_SSC_SFCON_EXTRACT_DATA_LENGTH(sfcon)  \
+	(MS((sfcon), IFX_SSC_SFCON_DATA_LENGTH))
+
+#define IFX_SSC_SFCON_EXTRACT_PAUSE_LENGTH(sfcon) \
+	(MS((sfcon), IFX_SSC_SFCON_PAUSE_LENGTH))
+
+#define IFX_SSC_SFCON_SET_DATA_LENGTH(value)      \
+	(SM((value), IFX_SSC_SFCON_DATA_LENGTH))
+
+#define IFX_SSC_SFCON_SET_PAUSE_LENGTH(value)     \
+	(SM((value), IFX_SSC_SFCON_PAUSE_LENGTH))
+
+/* Data Frame Status register */
+#define IFX_SSC_SFSTAT                      0x00000064
+#define IFX_SSC_SFSTAT_IN_DATA              0x00000001
+#define IFX_SSC_SFSTAT_IN_PAUSE             0x00000002
+#define IFX_SSC_SFSTAT_DATA_COUNT           0x0000FFF0
+#define IFX_SSC_SFSTAT_DATA_COUNT_S         4
+#define IFX_SSC_SFSTAT_PAUSE_COUNT          0xFFF00000
+#define IFX_SSC_SFSTAT_PAUSE_COUNT_S        20
+
+#define IFX_SSC_SFSTAT_EXTRACT_DATA_COUNT(sfstat)  \
+	(MS((sfstat), IFX_SSC_SFSTAT_DATA_COUNT))
+
+#define IFX_SSC_SFSTAT_EXTRACT_PAUSE_COUNT(sfstat) \
+	(MS((sfstat), IFX_SSC_SFSTAT_PAUSE_COUNT))
+
+/* General Purpose Output Control register */
+#define IFX_SSC_GPOCON                      0x00000070
+#define IFX_SSC_GPOCON_INVOUT0_POS      0
+#define IFX_SSC_GPOCON_INV_OUT0         0x00000001
+#define IFX_SSC_GPOCON_TRUE_OUT0        0x00000000
+#define IFX_SSC_GPOCON_INVOUT1_POS      1
+#define IFX_SSC_GPOCON_INV_OUT1         0x00000002
+#define IFX_SSC_GPOCON_TRUE_OUT1        0x00000000
+#define IFX_SSC_GPOCON_INVOUT2_POS      2
+#define IFX_SSC_GPOCON_INV_OUT2         0x00000003
+#define IFX_SSC_GPOCON_TRUE_OUT2        0x00000000
+#define IFX_SSC_GPOCON_INVOUT3_POS      3
+#define IFX_SSC_GPOCON_INV_OUT3         0x00000008
+#define IFX_SSC_GPOCON_TRUE_OUT3        0x00000000
+#define IFX_SSC_GPOCON_INVOUT4_POS      4
+#define IFX_SSC_GPOCON_INV_OUT4         0x00000010
+#define IFX_SSC_GPOCON_TRUE_OUT4        0x00000000
+#define IFX_SSC_GPOCON_INVOUT5_POS      5
+#define IFX_SSC_GPOCON_INV_OUT5         0x00000020
+#define IFX_SSC_GPOCON_TRUE_OUT5        0x00000000
+#define IFX_SSC_GPOCON_INVOUT6_POS      6
+#define IFX_SSC_GPOCON_INV_OUT6         0x00000040
+#define IFX_SSC_GPOCON_TRUE_OUT6        0x00000000
+#define IFX_SSC_GPOCON_INVOUT7_POS      7
+#define IFX_SSC_GPOCON_INV_OUT7         0x00000080
+#define IFX_SSC_GPOCON_TRUE_OUT7        0x00000000
+#define IFX_SSC_GPOCON_INV_OUT_ALL      0x000000FF
+#define IFX_SSC_GPOCON_TRUE_OUT_ALL     0x00000000
+
+#define IFX_SSC_GPOCON_ISCSB0_POS       8
+#define IFX_SSC_GPOCON_IS_CSB0          0x00000100
+#define IFX_SSC_GPOCON_IS_GPO0          0x00000000
+#define IFX_SSC_GPOCON_ISCSB1_POS       9
+#define IFX_SSC_GPOCON_IS_CSB1          0x00000200
+#define IFX_SSC_GPOCON_IS_GPO1          0x00000000
+#define IFX_SSC_GPOCON_ISCSB2_POS       10
+#define IFX_SSC_GPOCON_IS_CSB2          0x00000400
+#define IFX_SSC_GPOCON_IS_GPO2          0x00000000
+#define IFX_SSC_GPOCON_ISCSB3_POS       11
+#define IFX_SSC_GPOCON_IS_CSB3          0x00000800
+#define IFX_SSC_GPOCON_IS_GPO3          0x00000000
+#define IFX_SSC_GPOCON_ISCSB4_POS       12
+#define IFX_SSC_GPOCON_IS_CSB4          0x00001000
+#define IFX_SSC_GPOCON_IS_GPO4          0x00000000
+#define IFX_SSC_GPOCON_ISCSB5_POS       13
+#define IFX_SSC_GPOCON_IS_CSB5          0x00002000
+#define IFX_SSC_GPOCON_IS_GPO5          0x00000000
+#define IFX_SSC_GPOCON_ISCSB6_POS       14
+#define IFX_SSC_GPOCON_IS_CSB6          0x00004000
+#define IFX_SSC_GPOCON_IS_GPO6          0x00000000
+#define IFX_SSC_GPOCON_ISCSB7_POS       15
+#define IFX_SSC_GPOCON_IS_CSB7          0x00008000
+#define IFX_SSC_GPOCON_IS_GPO7          0x00000000
+#define IFX_SSC_GPOCON_IS_CSB_ALL       0x0000FF00
+#define IFX_SSC_GPOCON_IS_GPO_ALL       0x00000000
+
+/* General Purpose Output Status register */
+#define IFX_SSC_GPOSTAT              0x00000074
+
+#define IFX_SSC_GPOSTAT_OUT0            0x00000001
+#define IFX_SSC_GPOSTAT_OUT1            0x00000002
+#define IFX_SSC_GPOSTAT_OUT2            0x00000004
+#define IFX_SSC_GPOSTAT_OUT3            0x00000008
+#define IFX_SSC_GPOSTAT_OUT4            0x00000010
+#define IFX_SSC_GPOSTAT_OUT5            0x00000020
+#define IFX_SSC_GPOSTAT_OUT6            0x00000040
+#define IFX_SSC_GPOSTAT_OUT7            0x00000080
+#define IFX_SSC_GPOSTAT_OUT_ALL         0x000000FF
+
+/* Force GPO Status register */
+#define IFX_SSC_WHBGPOSTAT              0x00000078
+#define IFX_SSC_WHBGPOSTAT_CLROUT0_POS  0
+#define IFX_SSC_WHBGPOSTAT_CLR_OUT0     0x00000001
+#define IFX_SSC_WHBGPOSTAT_CLROUT1_POS  1
+#define IFX_SSC_WHBGPOSTAT_CLR_OUT1     0x00000002
+#define IFX_SSC_WHBGPOSTAT_CLROUT2_POS  2
+#define IFX_SSC_WHBGPOSTAT_CLR_OUT2     0x00000004
+#define IFX_SSC_WHBGPOSTAT_CLROUT3_POS  3
+#define IFX_SSC_WHBGPOSTAT_CLR_OUT3     0x00000008
+#define IFX_SSC_WHBGPOSTAT_CLROUT4_POS  4
+#define IFX_SSC_WHBGPOSTAT_CLR_OUT4     0x00000010
+#define IFX_SSC_WHBGPOSTAT_CLROUT5_POS  5
+#define IFX_SSC_WHBGPOSTAT_CLR_OUT5     0x00000020
+#define IFX_SSC_WHBGPOSTAT_CLROUT6_POS  6
+#define IFX_SSC_WHBGPOSTAT_CLR_OUT6     0x00000040
+#define IFX_SSC_WHBGPOSTAT_CLROUT7_POS  7
+#define IFX_SSC_WHBGPOSTAT_CLR_OUT7     0x00000080
+#define IFX_SSC_WHBGPOSTAT_CLR_OUT_ALL  0x000000FF
+
+#define IFX_SSC_WHBGPOSTAT_SETOUT0_POS  8
+#define IFX_SSC_WHBGPOSTAT_SET_OUT0     0x00000100
+#define IFX_SSC_WHBGPOSTAT_SETOUT1_POS  9
+#define IFX_SSC_WHBGPOSTAT_SET_OUT1     0x00000200
+#define IFX_SSC_WHBGPOSTAT_SETOUT2_POS  10
+#define IFX_SSC_WHBGPOSTAT_SET_OUT2     0x00000400
+#define IFX_SSC_WHBGPOSTAT_SETOUT3_POS  11
+#define IFX_SSC_WHBGPOSTAT_SET_OUT3     0x00000800
+#define IFX_SSC_WHBGPOSTAT_SETOUT4_POS  12
+#define IFX_SSC_WHBGPOSTAT_SET_OUT4     0x00001000
+#define IFX_SSC_WHBGPOSTAT_SETOUT5_POS  13
+#define IFX_SSC_WHBGPOSTAT_SET_OUT5     0x00002000
+#define IFX_SSC_WHBGPOSTAT_SETOUT6_POS  14
+#define IFX_SSC_WHBGPOSTAT_SET_OUT6     0x00004000
+#define IFX_SSC_WHBGPOSTAT_SETOUT7_POS  15
+#define IFX_SSC_WHBGPOSTAT_SET_OUT7     0x00008000
+#define IFX_SSC_WHBGPOSTAT_SET_OUT_ALL  0x0000FF00
+
+/* Receive Request Register */
+#define IFX_SSC_RXREQ                   0x00000080
+#define IFX_SSC_RXREQ_RXCOUNT           0x0000FFFF
+#define IFX_SSC_RXREQ_RXCOUNT_S         0
+
+/* Receive Count Register */
+#define IFX_SSC_RXCNT                   0x00000084
+
+#define IFX_SSC_RXCNT_TODO              0x0000FFFF
+#define IFX_SSC_RXCNT_TODO_S            0
+
+/* DMA Configuration Register */
+#define IFX_SSC_DMACON                  0x000000EC
+
+#define IFX_SSC_DMACON_RXON             0x00000001
+#define IFX_SSC_DMACON_TXON             0x00000002
+#define IFX_SSC_DMACON_DMAON            0x00000003
+#define IFX_SSC_DMACON_CLASS            0x0000000C
+#define IFX_SSC_DMACON_CLASS_S          2
+
+/* Interrupt Node Enable Register */
+#define IFX_SSC_IRN_EN                 0xF4
+
+/* Interrupt Node Interrupt Capture Register */
+#define IFX_SSC_IRN_CR                 0xF8
+
+/* Interrupt Node Control Register */
+#define IFX_SSC_IRN_ICR                0xFC
+
+#define IFX_SSC_NUM_IRQ                4
+
+#ifdef CONFIG_DANUBE
+#define IFX_SSC_R_BIT       0x00000001
+#define IFX_SSC_T_BIT       0x00000002
+#else
+#define IFX_SSC_T_BIT       0x00000001
+#define IFX_SSC_R_BIT       0x00000002
+#endif
+#define IFX_SSC_E_BIT       0x00000004
+#define IFX_SSC_F_BIT       0x00000008
+
+/* Generic register operation can't meet the requirement */
+
+#ifdef CONFIG_CPU_LITTLE_ENDIAN
+#define ltq_ssc_w16(_v, _r)  ltq_w16(_v, (u16 *)(_r))
+#define ltq_ssc_w8(_v, _r)   ltq_w8(_v, (u8 *)(_r))
+#else
+#define ltq_ssc_w16(_v, _r)  ltq_w16(_v, (u16 *)((_r) + 2))
+#define ltq_ssc_w8(_v, _r)   ltq_w8(_v, (u8 *)((_r) + 3))
+#endif /* CONFIG_CPU_LITTLE_ENDIAN */
+
+/* Get or Set CLC configuration */
+#define IFX_SSC_GET_CLC(_p)      \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_CLC))
+#define IFX_SSC_GET_CLC_RMC(_p)  \
+	MS(IFX_SSC_GET_CLC((_p)), IFX_SSC_CLC_RMC)
+#define IFX_SSC_SET_CLC(_v, _p)  \
+	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_CLC))
+
+/* Get ID */
+#define IFX_SSC_GET_ID(_p)       \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_ID))
+#define IFX_SSC_TX_FIFO_SIZE(_p) \
+	MS(IFX_SSC_GET_ID((_p)), IFX_SSC_ID_TXFS)
+#define IFX_SSC_RX_FIFO_SIZE(_p) \
+	MS(IFX_SSC_GET_ID((_p)), IFX_SSC_ID_RXFS)
+
+/* Get or Set CON configuration */
+#define IFX_SSC_GET_CON(_p)      \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_CON))
+#define IFX_SSC_SET_CON(_v, _p)  \
+	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_CON))
+
+/* Get SSC Status */
+#define IFX_SSC_GET_STATE(_p)          \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_STATE))
+#define IFX_SSC_RX_VALID_BYTES(_p)     \
+	MS(IFX_SSC_GET_STATE((_p)), IFX_SSC_STATE_RX_BYTE_VALID)
+
+/* Set hardware modified control register */
+#define IFX_SSC_SET_WHBSTATE(_v, _p)   \
+	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_WHBSTATE))
+#define IFX_SSC_CONFIG_MODE(_p)        \
+	IFX_SSC_SET_WHBSTATE(IFX_SSC_WHBSTATE_CONFIGURATION_MODE, (_p))
+#define IFX_SSC_RUN_MODE(_p)           \
+	IFX_SSC_SET_WHBSTATE(IFX_SSC_WHBSTATE_RUN_MODE, (_p))
+
+/* Set Baud Rate Time */
+#define IFX_SSC_SET_BR(_v, _p)         \
+	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_BR))
+#define IFX_SSC_GET_BR(_p)             \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_BR))
+
+/* TX Buffer Get/Set */
+#define IFX_SSC_TX_WORD(_v, _p)        \
+	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_TB))
+#define IFX_SSC_GET_TX_WORD(_p)        \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_TB))
+#define IFX_SSC_TX_HALFWORD(_v, _p)    \
+	ltq_ssc_w16((_v), ((_p)->membase + IFX_SSC_TB))
+#define IFX_SSC_TX_BYTE(_v, _p)        \
+	ltq_ssc_w8((_v),  ((_p)->membase + IFX_SSC_TB))
+
+/* RX buffer Get */
+#define IFX_SSC_GET_RX_WORD(_p)        \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_RB))
+
+/* RX FIFO Control */
+#define IFX_SSC_RX_FIFO_CTRL(_v, _p)   \
+	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_RXFCON))
+#define IFX_SSC_GET_RX_FIFO_CTRL(_p)   \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_RXFCON))
+
+/* TX FIFO Control */
+#define IFX_SSC_TX_FIFO_CTRL(_v, _p)   \
+	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_TXFCON))
+#define IFX_SSC_GET_TX_FIFO_CTRL(_p)   \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_TXFCON))
+
+/* FIFO status */
+#define IFX_SSC_GET_FIFO_STATUS(_p)    \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_FSTAT))
+#define IFX_SSC_RX_FIFO_FILL_LEVEL(_p) \
+	MS(IFX_SSC_GET_FIFO_STATUS((_p)), IFX_SSC_FSTAT_RX_WORDS)
+#define IFX_SSC_TX_FIFO_FILL_LEVEL(_p) \
+	MS(IFX_SSC_GET_FIFO_STATUS((_p)), IFX_SSC_FSTAT_TX_WORDS)
+
+/* Serial Framing Control */
+#define IFX_SSC_GET_FRAMING_CON(_p)     \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_SFCON))
+#define IFX_SSC_SET_FRAMING_CON(_v, _p) \
+	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_SFCON))
+
+/* Get Serial Framing Status */
+#define IFX_SSC_GET_FRAMING_STATUS(_p)  \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_SFSTAT))
+
+/* General Purpose IO control */
+#define IFX_SSC_GET_GPOCON(_p)          \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_GPOCON))
+#define IFX_SSC_SET_GPOCON(_v, _p)      \
+	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_GPOCON))
+
+/* General Purpose IO status */
+#define IFX_SSC_GET_GPOSTAT(_p)         \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_GPOSTAT))
+
+/* GPIO Force Output */
+#define IFX_SSC_SET_FGPO(_v, _p)        \
+	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_WHBGPOSTAT))
+
+/* RX Request */
+#define IFX_SSC_SET_RXREQ(_v, _p)       \
+	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_RXREQ))
+#define IFX_SSC_GET_RXREQ(_p)           \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_RXREQ))
+
+/* Receive Reuest */
+#define IFX_SSC_GET_RXREQ(_p)           \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_RXREQ))
+
+/* Receive counter */
+#define IFX_SSC_GET_RXCNT(_p)           \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_RXCNT))
+#define IFX_SSC_RX_TO_RECEIVED(_p)      \
+	MS(IFX_SSC_GET_RXCNT(_p), IFX_SSC_RXCNT_TODO)
+
+/* DMA Configuration */
+#define IFX_SSC_GET_DMA_CON(_p)         \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_DMACON))
+#define IFX_SSC_SET_DMA_CON(_v, _p)     \
+	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_DMACON))
+
+/* Interrupt Enable register set/get */
+#define IFX_SSC_GET_IRN_EN(_p)          \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_IRN_EN))
+#define IFX_SSC_SET_IRN_EN(_v, _p)      \
+	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_IRN_EN))
+
+/* Interrupt capture register */
+#define IFX_SSC_GET_IRN_CR(_p)          \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_IRN_CR))
+#define IFX_SSC_SET_IRN_CR(_v, _p)      \
+	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_IRN_CR))
+
+/* Interrupt Control Register */
+#define IFX_SSC_GET_IRN_ICR(_p)          \
+	ltq_ssc_r32((u32 *)((_p)->membase + IFX_SSC_IRN_ICR))
+#define IFX_SSC_SET_IRN_ICR(_v, _p)      \
+	ltq_ssc_w32((_v), (u32 *)((_p)->membase + IFX_SSC_IRN_ICR))
+
+
+/* Tail queue declarations */
+#define TAILQ_HEAD(name, type)                          \
+struct name {                                           \
+	struct type *tqh_first;     /* first element */ \
+	struct type **tqh_last;     /*addr of last next element */    \
+}
+
+#define TAILQ_HEAD_INITIALIZER(head)      \
+	{ NULL, &(head).tqh_first }
+
+#define TAILQ_ENTRY(type)                                              \
+struct {                                                               \
+	struct type *tqe_next;      /* next element */                     \
+	struct type **tqe_prev;     /* address of previous next element */ \
+}
+/*
+ * Tail queue functions.
+ */
+#define TAILQ_CONCAT(head1, head2, field) do {                          \
+	if (!TAILQ_EMPTY(head2)) {                                      \
+		*(head1)->tqh_last = (head2)->tqh_first;                \
+		(head2)->tqh_first->field.tqe_prev = (head1)->tqh_last; \
+		(head1)->tqh_last = (head2)->tqh_last;                  \
+		TAILQ_INIT((head2));                                    \
+	}                                                               \
+} while (0)
+
+#define TAILQ_EMPTY(head)       ((head)->tqh_first == NULL)
+
+#define TAILQ_FIRST(head)       ((head)->tqh_first)
+
+#define TAILQ_FOREACH(var, head, field)                                  \
+	for ((var) = TAILQ_FIRST((head));                               \
+		(var);                                                   \
+		(var) = TAILQ_NEXT((var), field))
+
+#define TAILQ_FOREACH_SAFE(var, head, field, tvar)                        \
+	for ((var) = TAILQ_FIRST((head));                               \
+		(var) && ((tvar) = TAILQ_NEXT((var), field), 1);        \
+		(var) = (tvar))
+
+#define TAILQ_FOREACH_REVERSE(var, head, headname, field)                  \
+	for ((var) = TAILQ_LAST((head), headname);                        \
+		(var);                                                     \
+		(var) = TAILQ_PREV((var), headname, field))
+
+#define TAILQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)        \
+	for ((var) = TAILQ_LAST((head), headname);                        \
+		(var) && ((tvar) = TAILQ_PREV((var), headname, field), 1);\
+		(var) = (tvar))
+
+#define TAILQ_INIT(head) do {                                               \
+	TAILQ_FIRST((head)) = NULL;                                         \
+	(head)->tqh_last = &TAILQ_FIRST((head));                            \
+} while (0)
+
+#define TAILQ_INSERT_BEFORE(listelm, elm, field) do {                       \
+	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;                  \
+	TAILQ_NEXT((elm), field) = (listelm);                               \
+	*(listelm)->field.tqe_prev = (elm);                                 \
+	(listelm)->field.tqe_prev = &TAILQ_NEXT((elm), field);              \
+} while (0)
+
+#define TAILQ_INSERT_TAIL(head, elm, field) do {                           \
+	TAILQ_NEXT((elm), field) = NULL;                                   \
+	(elm)->field.tqe_prev = (head)->tqh_last;                          \
+	*(head)->tqh_last = (elm);                                         \
+	(head)->tqh_last = &TAILQ_NEXT((elm), field);                      \
+} while (0)
+
+#define TAILQ_LAST(head, headname)                                         \
+	(*(((struct headname *)((head)->tqh_last))->tqh_last))
+
+#define TAILQ_NEXT(elm, field) ((elm)->field.tqe_next)
+
+#define TAILQ_PREV(elm, headname, field)                                   \
+	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
+
+#define TAILQ_REMOVE(head, elm, field) do {                                 \
+	if ((TAILQ_NEXT((elm), field)) != NULL)                           \
+		TAILQ_NEXT((elm), field)->field.tqe_prev =                  \
+		(elm)->field.tqe_prev;                                      \
+	else {                                                              \
+		(head)->tqh_last = (elm)->field.tqe_prev;                   \
+	}                                                                   \
+	*(elm)->field.tqe_prev = TAILQ_NEXT((elm), field);                  \
+} while (0)
+
+#define IFX_SSC_WAKELIST_INIT(queue) \
+	init_waitqueue_head(&queue)
+
+#define IFX_SSC_WAIT_EVENT_TIMEOUT(queue, event, flags, timeout) \
+do {                                                             \
+	wait_event_interruptible_timeout((queue),               \
+		test_bit((event), &(flags)), (timeout));        \
+	clear_bit((event), &(flags));                           \
+} while (0)
+
+/* Wait queue has no address symbol in this macro
+ * interruptible_sleep_on() possibly cause lost-wakeup issue
+ * wait_event_interruptible is robust for multiple events
+ */
+#define IFX_SSC_WAIT_EVENT(queue, event, flags)       \
+do {                                                  \
+	wait_event_interruptible((queue),            \
+		test_bit((event), &(flags)));        \
+	clear_bit((event), &(flags));                \
+} while (0)
+
+#define IFX_SSC_WAKEUP_EVENT(queue, event, flags)     \
+do {                                                  \
+	set_bit((event), &(flags));                   \
+	wake_up_interruptible(&(queue));              \
+} while (0)
+
+#define IFX_SSC_IRQ_LOCK_INIT(port, _name)        \
+	spin_lock_init(&((port)->ssc_irq_lock))
+
+#define IFX_SSC_IRQ_LOCK_DESTROY(port)
+
+#define IFX_SSC_IRQ_LOCK(port) do {                     \
+	unsigned long __ilockflags;                     \
+	spin_lock_irqsave(&((port)->ssc_irq_lock), __ilockflags);
+#define IFX_SSC_IRQ_UNLOCK(port)                    \
+	spin_unlock_irqrestore(&((port)->ssc_irq_lock), __ilockflags);\
+} while (0)
+
+
+#define IFX_SSC_SEM_INIT(sem) sema_init(&sem, 1)
+
+#define IFX_SSC_SEM_LOCK(sem) down(&(sem))
+
+#define IFX_SSC_SEM_UNLOCK(sem) up(&(sem))
+
+/* Data may run in kernel thread, tasklet at the same time */
+#define IFX_SSC_Q_LOCK_INIT(port)      spin_lock_init(&(port)->q_lock)
+
+#define IFX_SSC_Q_LOCK_DESTROY(port)
+
+#define IFX_SSC_Q_LOCK_BH(port)  do {       \
+	unsigned long __ilockflags;         \
+	spin_lock_irqsave(&((port)->q_lock), __ilockflags);
+#define IFX_SSC_Q_UNLOCK_BH(port)       \
+	spin_unlock_irqrestore(&((port)->q_lock), __ilockflags);\
+} while (0)
+
+#define CTL_AUTO CTL_UNNUMBERED
+
+#define IFX_INIT_CTL_NAME(val)
+#define IFX_SET_CTL_NAME(ctl, val)
+
+#define IFX_REGISTER_SYSCTL_TABLE(t) register_sysctl_table(t)
+
+#define IFX_SSC_MAX_PORT_NUM        1  /* assume default value */
+
+#define IFX_SSC_MAX_DEVNAME         16
+#define IFX_SSC_MAX_DEVICE          8  /* XXX */
+
+/* Parameters for SSC DMA device */
+
+#define DEFAULT_SSC_TX_CHANNEL_CLASS 3
+#define DEFAULT_SSC_RX_CHANNEL_CLASS 0
+
+#define DEFAULT_SSC_TX_BURST_LEN   2 /* 2 words, 4 words, 8 words */
+#define DEFAULT_SSC_RX_BURST_LEN   2 /* 2 words, 4 words, 8 words */
+
+#define DEFAULT_SSC_TX_CHANNEL_NUM 1
+#define DEFAULT_SSC_RX_CHANNEL_NUM 1
+
+#define DEFAULT_SSC_TX_CHANNEL_DESCR_NUM 1
+#define DEFAULT_SSC_RX_CHANNEL_DESCR_NUM 1
+
+/*!
+ \addtogroup IFX_SSC_DEFINITIONS
+*/
+/* @{ */
+
+/*! \def DEFAULT_SSC_FRAGMENT_SIZE
+    \brief a maximum fragment size parameter is defined for all connections.
+
+    This threshold is given in number of bytes. It has to be configured for
+    each connection and be less or equal. If the size of the packet is greater
+    than this threshold the application has to take care of the fragmentation
+    of the packet. The default global value is given with 1056 bytes. This is
+    the recommended value to use, but each connection is free configure this
+    parameter to a lesser value individually
+  */
+#define DEFAULT_SSC_FRAGMENT_SIZE    1056
+
+/*! \def IFX_SSC_MAX_FRAGSIZE
+    \brief maximum fragment size in theory.
+  */
+#define IFX_SSC_MAX_FRAGSIZE         (32 * 1024)
+
+/*! \def IFX_SSC_MAX_FRAGSIZE
+    \brief Mimimum fragment size. Smaller than this size has no meaning.
+  */
+#define IFX_SSC_MIN_FRAGSIZE         32
+
+/*! \def DEFAULT_SSC_FIFO_THRESHOULD
+    \brief For enabling the SSC driver to choose between FIFO and DMA mode in
+    HDX communication a threshold parameter is set for all connections
+
+    This threshold is given in number of bytes. If the size of the packet is
+    lesser than this threshold the FIFO mode is used, else the DMA mode. The
+    global default value of 148 bytes is recommended. This value has to be
+    optimized/tuned accoring to application
+  */
+#define DEFAULT_SSC_FIFO_THRESHOULD  148
+
+/*! \def IFX_SSC_FIFO_MAX_THRESHOULD
+    \brief Maximum FIFO/DMA threshould
+  */
+#define IFX_SSC_FIFO_MAX_THRESHOULD  512
+
+/*! \def IFX_SSC_FIFO_MIN_THRESHOULD
+    \brief Mimimum FIFO/DMA threshould.
+    \note  This thresould must be more than DMA burst length
+  */
+#define IFX_SSC_FIFO_MIN_THRESHOULD  32
+
+/*!
+  \brief SSC Statistics.
+  Symbolic constants to be used in SSC routines
+ */
+struct ifx_ssc_statistics {
+	u32 abortErr;   /*!< abort error */
+	u32 modeErr;    /*!< master/slave mode error */
+	u32 txOvErr;    /*!< TX Overflow error */
+	u32 txUnErr;    /*!< TX Underrun error */
+	u32 rxOvErr;    /*!< RX Overflow error */
+	u32 rxUnErr;    /*!< RX Underrun error */
+	u64 rxBytes;    /*!< Received bytes */
+	u64 txBytes;    /*!< Transmitted bytes */
+	u64 txFifo;     /*!< Transmit transactions in FIFO */
+	u64 txDma;      /*!< Transmit transactions in DMA */
+	u64 txDmaBytes; /*!< Transmit bytes in DMA mode */
+	u64 rxFifo;     /*!< Receive transactions in FIFO */
+	u64 rxDma;      /*!< Receive transactions in FIFO */
+	u64 rxDmaBytes; /*!< Receive bytes in DMA mode */
+};
+
+
+/*!
+  \brief SSC Hardware Options.
+ */
+struct ifx_ssc_hwopts {
+	unsigned int abortErrDetect:1; /*!< Abort Error detection
+					(in slave mode) */
+	unsigned int rxOvErrDetect:1;  /*!< Receive Overflow Error detection */
+	unsigned int rxUndErrDetect:1; /*!< Receive Underflow Error detection */
+	unsigned int txOvErrDetect:1;  /*!< Transmit Overflow Error detection */
+	unsigned int txUndErrDetect:1;/*!< Transmit Underflow Error detection */
+	unsigned int echoMode:1;  /*!< Echo mode */
+	unsigned int loopBack:1;  /*!< Loopback mode */
+	unsigned int idleValue:1; /*!< Idle value */
+	unsigned int clockPolarity:1;  /*!< Idle clock is high or low */
+	unsigned int clockPhase:1;      /*!< Tx on trailing or leading edge */
+	unsigned int headingControl:1;  /*!< LSB first or MSB first */
+	unsigned int dataWidth:6;       /*!< from 2 up to 32 bits */
+	unsigned int masterSelect:1;    /*!< Master or Slave mode */
+	unsigned int modeRxTx:2;        /*!< rx/tx mode */
+	unsigned int gpoCs:8;      /*!< choose outputs to use for chip select */
+	unsigned int gpoInv:8;     /*!< invert GPO outputs */
+};
+
+#define IFX_SSC_IS_MASTER(p) ((p)->opts.masterSelect == SSC_MASTER_MODE)
+
+struct ssc_device;
+
+/*! typedef IFX_SSC_QUEUE_t
+    \brief queue structure for sync or async API
+*/
+typedef struct IFX_SSC_QUEUE {
+	struct ssc_device *dev; /*!< Back pointer to SSC client device */
+	bool request_lock;       /*!< Indicates this queue locked or not */
+	atomic_t isqueued;      /*!< Only one entry is allowed per device
+				   shared between tasklet and kernel thread
+				 */
+	char *txbuf;            /*!< Transmission buffer snapshot */
+	int txsize;             /*!< Transmission size snaphot */
+	char *rxbuf;            /*!< Reception buffer snapshot */
+	int rxsize;             /*!< Receptin size snapshot */
+	int exchange_bytes;     /*!< Transmit/Received bytes for
+				     callback function */
+	IFX_SSC_HANDL_TYPE_t handle_type;  /*!< Sync/Async handle type */
+	IFX_SSC_ASYNC_CALLBACK_t callback; /*!< Async API callback function */
+	TAILQ_ENTRY(IFX_SSC_QUEUE) q_next; /*!< Used if it works as
+						queue header */
+} IFX_SSC_QUEUE_t;
+/* @} */
+
+enum {
+	IFX_SSC_DIR_RX = 0,
+	IFX_SSC_DIR_TX,
+	IFX_SSC_DIR_TXRX,
+};
+
+enum {
+	IFX_SSC_DMA_DISABLE = 0,
+	IFX_SSC_DMA_ENABLE,
+};
+
+/*!
+  \brief SSC bus device statistics
+ */
+struct ifx_ssc_device_stats {
+	u64 rxBytes;      /*!< Received bytes */
+	u64 txBytes;      /*!< Transmitted bytes */
+	u32 dup_qentries; /*!< Duplicated qentry error */
+	u32 context_err;  /*!< Context error */
+	u32 frag_err;     /*!< Fragment error */
+	u32 handler_err;  /*!< Handler error */
+	u32 dlx_err;      /*!< Duplex error */
+	u64 enqueue;      /*!< enqueue times */
+	u64 dequeue;      /*!< dequeue times */
+	/* More ... */
+};
+
+/*! typedef ssc_device_t
+    \brief ssc device structure defintion
+*/
+typedef struct ssc_device {
+	char dev_name[IFX_SSC_MAX_DEVNAME];
+	int duplex;
+	struct ifx_ssc_port *port; /* back pointer */
+	TAILQ_ENTRY(ssc_device) dev_entry;
+	IFX_SSC_CONFIGURE_t conn_id;
+	struct ifx_ssc_device_stats stats;
+#ifdef CONFIG_SYSCTL
+	struct ctl_table_header *ssc_sysctl_header;
+	struct ctl_table *ssc_sysctls;
+#endif  /* CONFIG_SYSCTL */
+	IFX_SSC_QUEUE_t queue;
+	IFX_SSC_PRIO_t dev_prio;
+
+	/* Kernel thread based per device <ssc client> */
+	wait_queue_head_t dev_thread_wait;
+	volatile long event_flags;
+#define IFX_SSC_DEV_THREAD_EVENT            1
+} ssc_device_t;
+
+typedef TAILQ_HEAD(, ssc_device) ssc_devq_t;
+
+typedef TAILQ_HEAD(, IFX_SSC_QUEUE) ssc_dataq_t;
+
+/* Structure for transmit word */
+typedef union ifx_ssc_txd {
+	struct {
+		u8 byte[4];
+	} txd_byte;
+	u32 txd_word;
+} ifx_ssc_txd_t;
+
+/* Structure for receive word */
+typedef union ifx_ssc_rxd {
+	struct {
+		unsigned char byte[4];
+	} rxd_byte;
+	unsigned int rxd_word;
+} ifx_ssc_rxd_t;
+
+/*!
+  \brief SSC Hardware logical port
+ */
+struct ifx_ssc_port {
+	unsigned char __iomem *membase; /* Virtual */
+	struct ifx_ssc_hwopts opts;
+	struct ifx_ssc_statistics stats;
+	u32 ssc_debug;     /* debug msg flags */
+	/* SSC port index, actually, it means how many spi bus we have. */
+	int port_idx;
+	ssc_devq_t ssc_devq;
+
+	/* Device < ssc client> queue only happens in process context */
+	struct semaphore dev_sem;
+	int ssc_ndevs;
+	char name[IFX_SSC_MAX_DEVNAME];
+	unsigned int prev_ssc_clk;
+	unsigned int prev_baudrate;
+	unsigned int baudrate;
+	/* buffer and pointers to the rx/tx position FIFO */
+	char *rxbuf_end;    /* buffer end pointer for RX */
+	volatile char *rxbuf_ptr; /* buffer write pointer for RX */
+	char *txbuf_end;    /* buffer end pointer for TX */
+	volatile char *txbuf_ptr; /* buffer read pointer for TX */
+
+	/* All these counters used to remove FIFO memory copy */
+	int actual_rx_len; /* Real Rx data length for debugging */
+
+	volatile long event_flags;
+	struct dma_device_info *dma_dev; /* DMA device structure */
+	IFX_SSC_MODE_t prev_ssc_mode;
+	int ssc_fragSize; /* Possible configuration change, void malloc
+			   * big memory in reception
+			   */
+	IFX_SSC_QUEUE_t *lock_qentry;  /* XXX, protection? */
+	IFX_SSC_QUEUE_t *serve_qentry; /* Only in its own tasklet
+					  or kernel thread */
+	ssc_dataq_t ssc_asyncq;        /* Async queue header */
+	ssc_dataq_t ssc_syncq[IFX_SSC_PRIO_MAX]; /* Sync queue header */
+	spinlock_t q_lock; /* on three queues */
+	int ssc_thread;
+	spinlock_t ssc_irq_lock;
+	atomic_t dma_wait_state;
+	wait_queue_head_t ssc_thread_wait;
+#define IFX_SSC_THREAD_EVENT       1
+
+	struct task_struct *ssc_tsk;
+	bool ssc_cs_locked; /* Done in the same tasklet or thread only */
+	struct tasklet_struct ssc_txrxq;
+	/* HW WAR DMA buffer */
+	char *dma_txbuf;      /* Aligned buffer */
+	char *dma_orig_txbuf; /* Original buffer */
+	char *dma_rxbuf;      /* Aligned buffer */
+	char *dma_orig_rxbuf; /* Original buffer */
+#ifdef CONFIG_SYSCTL
+	struct ctl_table_header *port_sysctl_header;
+	struct ctl_table *port_sysctls;
+#endif /* CONFIG_SYSCTL */
+	u32 tx_fifo_size_words; /* in dwords */
+	u32 rx_fifo_size_words; /* in dwords */
+	u32 tx_fifo_size_bytes;
+	u32 rx_fifo_size_bytes;
+	bool dma_support;
+	u32 dma_is_in_half_duplex;
+	struct clk *fpiclk;
+};
+
+#endif /* LTQ_SSC_H */
+
