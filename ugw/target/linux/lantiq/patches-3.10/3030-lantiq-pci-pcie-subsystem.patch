# HG changeset patch
# Parent 31a17406b15029ff349e1cef9b599bc072e559bd

diff --git a/arch/mips/pci/Makefile b/arch/mips/pci/Makefile
old mode 100644
new mode 100755
--- a/arch/mips/pci/Makefile
+++ b/arch/mips/pci/Makefile
@@ -40,8 +40,9 @@ obj-$(CONFIG_SIBYTE_BCM112X)	+= fixup-sb
 obj-$(CONFIG_SIBYTE_BCM1x80)	+= pci-bcm1480.o pci-bcm1480ht.o
 obj-$(CONFIG_SNI_RM)		+= fixup-sni.o ops-sni.o
 obj-$(CONFIG_LANTIQ)		+= fixup-lantiq.o
+obj-$(CONFIG_PCI_LANTIQ_BOOT)   += pci-lantiq-boot.o
 obj-$(CONFIG_PCI_LANTIQ)	+= pci-lantiq.o ops-lantiq.o
-obj-$(CONFIG_PCIE_LANTIQ)	+= ifxmips_pcie_phy.o ifxmips_pcie.o fixup-lantiq-pcie.o
+obj-$(CONFIG_PCIE_LANTIQ)	+= pcie-lantiq-phy.o pcie-lantiq.o fixup-lantiq-pcie.o
 obj-$(CONFIG_PCIE_LANTIQ_MSI)	+= pcie-lantiq-msi.o
 obj-$(CONFIG_TANBAC_TB0219)	+= fixup-tb0219.o
 obj-$(CONFIG_TANBAC_TB0226)	+= fixup-tb0226.o
diff --git a/arch/mips/pci/fixup-lantiq-pcie.c b/arch/mips/pci/fixup-lantiq-pcie.c
--- a/arch/mips/pci/fixup-lantiq-pcie.c
+++ b/arch/mips/pci/fixup-lantiq-pcie.c
@@ -1,27 +1,13 @@
-/******************************************************************************
-**
-** FILE NAME    : ifxmips_fixup_pcie.c
-** PROJECT      : IFX UEIP for VRX200
-** MODULES      : PCIe 
-**
-** DATE         : 02 Mar 2009
-** AUTHOR       : Lei Chuanhua
-** DESCRIPTION  : PCIe Root Complex Driver
-** COPYRIGHT    :       Copyright (c) 2009
-**                      Infineon Technologies AG
-**                      Am Campeon 1-12, 85579 Neubiberg, Germany
-**
-**    This program is free software; you can redistribute it and/or modify
-**    it under the terms of the GNU General Public License as published by
-**    the Free Software Foundation; either version 2 of the License, or
-**    (at your option) any later version.
-** HISTORY
-** $Version $Date        $Author         $Comment
-** 0.0.1    17 Mar,2009  Lei Chuanhua    Initial version
-*******************************************************************************/
-/*!
- \file ifxmips_fixup_pcie.c
- \ingroup IFX_PCIE  
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C)2009~2015 Lei Chuanhua <Chuanhua.lei@lantiq.com>
+ */
+ /*!
+ \file fixup-lantiq-pcie.c
+ \ingroup PCIE
  \brief PCIe Fixup functions source file
 */
 #include <linux/pci.h>
@@ -32,51 +18,50 @@
 
 #include "pcie-lantiq.h"
 
-#define PCI_VENDOR_ID_INFINEON         0x15D1
-#define PCI_DEVICE_ID_INFINEON_DANUBE  0x000F
-#define PCI_DEVICE_ID_INFINEON_PCIE    0x0011
-#define PCI_VENDOR_ID_LANTIQ        0x1BEF
-#define PCI_DEVICE_ID_LANTIQ_PCIE       0x0011
+#define PCI_VENDOR_ID_INFINEON		0x15D1
+#define PCI_VENDOR_ID_LANTIQ		0x1BEF
 
+static void pcie_fixup_bridge(struct pci_dev *dev)
+{
+	struct ltq_pcie_port *lpp;
+	lpp = bus_to_ltq_pcie_port(dev->bus);
 
+	if ((dev->class >> 16) == PCI_BASE_CLASS_BRIDGE) {
+		u16 reg;
+		pci_read_config_word(dev, PCI_COMMAND, &reg);
+		/* Setup COMMAND register */
+		reg = PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER
+		| PCI_COMMAND_SERR;
+		pci_write_config_word(dev, PCI_COMMAND, reg);
+		dev_info(lpp->dev,
+			"%s port %d : fixup host controller %s (%04x:%04x)\n",
+			__func__, lpp->id, pci_name(dev),
+			dev->vendor, dev->device);
+	}
+}
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INFINEON, PCI_ANY_ID, pcie_fixup_bridge);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LANTIQ, PCI_ANY_ID, pcie_fixup_bridge);
 
-static void
-ifx_pcie_fixup_resource(struct pci_dev *dev)
+/*
+ * The root complex has a hardwired class of PCI_CLASS_NETWORK_OTHER or
+ * PCI_CLASS_BRIDGE_HOST, when it is operating as a root complex this
+ * needs to be switched to * PCI_CLASS_BRIDGE_PCI
+ */
+static void pcie_rc_class_fixup(struct pci_dev *dev)
 {
-    u32 reg;
+	struct ltq_pcie_port *lpp;
+	lpp = bus_to_ltq_pcie_port(dev->bus);
 
-    IFX_PCIE_PRINT(PCIE_MSG_FIXUP, "%s dev %s: enter\n", __func__, pci_name(dev));
-
-    printk("%s: fixup host controller %s (%04x:%04x)\n", 
-        __func__, pci_name(dev), dev->vendor, dev->device); 
-
-   /* Setup COMMAND register */
-    reg = PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER /* | 
-          PCI_COMMAND_INTX_DISABLE */| PCI_COMMAND_SERR;
-    pci_write_config_word(dev, PCI_COMMAND, reg);
-    IFX_PCIE_PRINT(PCIE_MSG_FIXUP, "%s dev %s: exit\n", __func__, pci_name(dev));
-}
-DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INFINEON, PCI_DEVICE_ID_INFINEON_PCIE, ifx_pcie_fixup_resource);
-DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LANTIQ, PCI_VENDOR_ID_LANTIQ, ifx_pcie_fixup_resource);
-
-static void
-ifx_pcie_rc_class_early_fixup(struct pci_dev *dev)
-{
-    IFX_PCIE_PRINT(PCIE_MSG_FIXUP, "%s dev %s: enter\n", __func__, pci_name(dev));
-
-    if (dev->devfn == PCI_DEVFN(0, 0) &&
-        (dev->class >> 8) == PCI_CLASS_BRIDGE_HOST) {
-
-        dev->class = (PCI_CLASS_BRIDGE_PCI << 8) | (dev->class & 0xff);
-
-        printk(KERN_INFO "%s: fixed pcie host bridge to pci-pci bridge\n", __func__);
-    }
-    IFX_PCIE_PRINT(PCIE_MSG_FIXUP, "%s dev %s: exit\n", __func__, pci_name(dev));
-    mdelay(10);
+	if ((dev->bus->parent == NULL) && (dev->devfn == 0)) {
+		dev->class = (PCI_CLASS_BRIDGE_PCI << 8) | (dev->class & 0xff);
+		dev_info(lpp->dev,
+			"%s port %d: fixed pci host bridge to pci-pci bridge\n",
+			__func__, lpp->id);
+	}
 }
 
-DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INFINEON, PCI_DEVICE_ID_INFINEON_PCIE,
-     ifx_pcie_rc_class_early_fixup);
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INFINEON, PCI_ANY_ID,
+	pcie_rc_class_fixup);
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LANTIQ, PCI_ANY_ID,
+	pcie_rc_class_fixup);
 
-DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LANTIQ, PCI_DEVICE_ID_LANTIQ_PCIE,
-     ifx_pcie_rc_class_early_fixup);
diff --git a/arch/mips/pci/fixup-lantiq.c b/arch/mips/pci/fixup-lantiq.c
--- a/arch/mips/pci/fixup-lantiq.c
+++ b/arch/mips/pci/fixup-lantiq.c
@@ -4,8 +4,9 @@
  *  by the Free Software Foundation.
  *
  *  Copyright (C) 2012 John Crispin <blogic@openwrt.org>
+ *  Copyright (C) 2015 Lei Chuanhua <Chuanhua.lei@lantiq.com>
  */
-
+#include <linux/pci.h>
 #include <linux/of_irq.h>
 #include <linux/of_pci.h>
 
@@ -15,8 +16,12 @@ int (*ltq_pci_map_irq)(const struct pci_
 
 int pcibios_plat_dev_init(struct pci_dev *dev)
 {
-	if (ltq_pci_plat_arch_init)
-		ltq_pci_plat_arch_init(dev);
+	int pos;
+	pos = pci_find_capability((struct pci_dev *)dev, PCI_CAP_ID_EXP);
+	if (pos > 0) {
+		if (ltq_pci_plat_arch_init)
+			return ltq_pci_plat_arch_init(dev);
+	}
 
 	if (ltq_pci_plat_dev_init)
 		return ltq_pci_plat_dev_init(dev);
@@ -26,18 +31,24 @@ int pcibios_plat_dev_init(struct pci_dev
 
 int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
+	int pos;
 	struct of_irq dev_irq;
-	int irq;
+	int irq = -1;
 
-	if (ltq_pci_map_irq)
-		return ltq_pci_map_irq(dev, slot, pin);
-	if (of_irq_map_pci(dev, &dev_irq)) {
-		dev_err(&dev->dev, "trying to map irq for unknown slot:%d pin:%d\n",
-			slot, pin);
-		return 0;
+	pos = pci_find_capability((struct pci_dev *)dev, PCI_CAP_ID_EXP);
+	if (pos > 0) {
+		if (ltq_pci_map_irq)
+			return ltq_pci_map_irq(dev, slot, pin);
+	} else {
+		if (of_irq_map_pci(dev, &dev_irq)) {
+			dev_err(&dev->dev,
+			"trying to map irq for unknown slot:%d pin:%d\n",
+				slot, pin);
+			return 0;
+		}
+		irq = irq_create_of_mapping(dev_irq.controller,
+			dev_irq.specifier, dev_irq.size);
 	}
-	irq = irq_create_of_mapping(dev_irq.controller, dev_irq.specifier,
-					dev_irq.size);
 	dev_info(&dev->dev, "SLOT:%d PIN:%d IRQ:%d\n", slot, pin, irq);
 	return irq;
 }
diff --git a/arch/mips/pci/ifxmips_pci_common.h b/arch/mips/pci/ifxmips_pci_common.h
deleted file mode 100644
--- a/arch/mips/pci/ifxmips_pci_common.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/******************************************************************************
-**
-** FILE NAME    : ifxmips_pci_common.h
-** PROJECT      : IFX UEIP
-** MODULES      : PCI subsystem
-**
-** DATE         : 30 June 2009
-** AUTHOR       : Lei Chuanhua
-** DESCRIPTION  : PCIe Root Complex Driver
-** COPYRIGHT    :       Copyright (c) 2009
-**                      Infineon Technologies AG
-**                      Am Campeon 1-12, 85579 Neubiberg, Germany
-**
-**    This program is free software; you can redistribute it and/or modify
-**    it under the terms of the GNU General Public License as published by
-**    the Free Software Foundation; either version 2 of the License, or
-**    (at your option) any later version.
-** HISTORY
-** $Version $Date        $Author         $Comment
-** 0.0.1    30 June,2009  Lei Chuanhua    Initial version
-*******************************************************************************/
-
-#ifndef IFXMIPS_PCI_COMMON_H
-#define IFXMIPS_PCI_COMMON_H
-#include <linux/version.h>
-/*!
- \defgroup IFX_PCI_COM  IFX PCI/PCIe common parts for OS integration  
- \brief  PCI/PCIe common parts
-*/
-
-/*!
- \defgroup IFX_PCI_COM_OS OS APIs
- \ingroup IFX_PCI_COM
- \brief PCI/PCIe bus driver OS interface functions
-*/
-/*!
-  \file ifxmips_pci_common.h
-  \ingroup IFX_PCI_COM
-  \brief PCI/PCIe bus driver common OS header file
-*/
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
-#define IFX_PCI_CONST
-#else
-#define IFX_PCI_CONST const
-#endif
-#ifdef CONFIG_IFX_PCI
-extern int ifx_pci_bios_map_irq(IFX_PCI_CONST struct pci_dev *dev, u8 slot, u8 pin);
-extern int ifx_pci_bios_plat_dev_init(struct pci_dev *dev);
-#endif /* COFNIG_IFX_PCI */
-
-#ifdef CONFIG_IFX_PCIE
-extern int ifx_pcie_bios_map_irq(IFX_PCI_CONST struct pci_dev *dev, u8 slot, u8 pin);
-extern int ifx_pcie_bios_plat_dev_init(struct pci_dev *dev);
-#endif
-
-#endif /* IFXMIPS_PCI_COMMON_H */
-
diff --git a/arch/mips/pci/ifxmips_pcie.c b/arch/mips/pci/ifxmips_pcie.c
deleted file mode 100644
--- a/arch/mips/pci/ifxmips_pcie.c
+++ /dev/null
@@ -1,1099 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 as published
- *  by the Free Software Foundation.
- *
- *  Copyright (C) 2009 Lei Chuanhua <chuanhua.lei@infineon.com>
- *  Copyright (C) 2013 John Crispin <blogic@openwrt.org>
- */
-
-#include <linux/types.h>
-#include <linux/pci.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/mm.h>
-#include <asm/paccess.h>
-#include <linux/pci.h>
-#include <linux/pci_regs.h>
-#include <linux/module.h>
-
-#include "ifxmips_pcie.h"
-#include "ifxmips_pcie_reg.h"
-
-/* Enable 32bit io due to its mem mapped io nature */
-#define IFX_PCIE_ERROR_INT
-#define IFX_PCIE_IO_32BIT
-
-#define IFX_PCIE_IR                     (INT_NUM_IM4_IRL0 + 25)
-#define IFX_PCIE_INTA                   (INT_NUM_IM4_IRL0 + 8)
-#define IFX_PCIE_INTB                   (INT_NUM_IM4_IRL0 + 9)
-#define IFX_PCIE_INTC                   (INT_NUM_IM4_IRL0 + 10)
-#define IFX_PCIE_INTD                   (INT_NUM_IM4_IRL0 + 11)
-#define MS(_v, _f)  (((_v) & (_f)) >> _f##_S)
-#define SM(_v, _f)  (((_v) << _f##_S) & (_f))
-#define IFX_REG_SET_BIT(_f, _r) \
-	IFX_REG_W32((IFX_REG_R32((_r)) &~ (_f)) | (_f), (_r))
-
-#define IFX_PCIE_LTSSM_ENABLE_TIMEOUT 10
-
-static DEFINE_SPINLOCK(ifx_pcie_lock);
-
-u32 g_pcie_debug_flag = PCIE_MSG_ANY & (~PCIE_MSG_CFG);
-
-static ifx_pcie_irq_t pcie_irqs[IFX_PCIE_CORE_NR] = {
-    {
-        .ir_irq = {
-            .irq  = IFX_PCIE_IR,
-            .name = "ifx_pcie_rc0",
-        },
-
-        .legacy_irq = {
-            {
-                .irq_bit = PCIE_IRN_INTA,
-                .irq     = IFX_PCIE_INTA,
-            },
-            {
-                .irq_bit = PCIE_IRN_INTB,
-                .irq     = IFX_PCIE_INTB,
-            },
-            {
-                .irq_bit = PCIE_IRN_INTC,
-                .irq     = IFX_PCIE_INTC,
-            },
-            {
-                .irq_bit = PCIE_IRN_INTD,
-                .irq     = IFX_PCIE_INTD,
-            },
-        },
-    },
-
-};
-
-void ifx_pcie_debug(const char *fmt, ...)
-{
-	static char buf[256] = {0};      /* XXX */
-	va_list ap;
-
-	va_start(ap, fmt);
-	vsnprintf(buf, sizeof(buf), fmt, ap);
-	va_end(ap);
-
-	printk("%s", buf);
-}
-
-
-static inline int pcie_ltssm_enable(int pcie_port)
-{
-	int i;
-
-	/* Enable LTSSM */
-	IFX_REG_W32(PCIE_RC_CCR_LTSSM_ENABLE, PCIE_RC_CCR(pcie_port));
-
-	/* Wait for the link to come up */
-	for (i = 0; i < IFX_PCIE_LTSSM_ENABLE_TIMEOUT; i++) {
-		if (!(IFX_REG_R32(PCIE_LCTLSTS(pcie_port)) & PCIE_LCTLSTS_RETRAIN_PENDING))
-			return 0;
-		udelay(10);
-	}
-
-	printk("%s link timeout!!!!!\n", __func__);
-	return -1;
-}
-
-static inline void pcie_status_register_clear(int pcie_port)
-{
-	IFX_REG_W32(0, PCIE_RC_DR(pcie_port));
-	IFX_REG_W32(0, PCIE_PCICMDSTS(pcie_port));
-	IFX_REG_W32(0, PCIE_DCTLSTS(pcie_port));
-	IFX_REG_W32(0, PCIE_LCTLSTS(pcie_port));
-	IFX_REG_W32(0, PCIE_SLCTLSTS(pcie_port));
-	IFX_REG_W32(0, PCIE_RSTS(pcie_port));
-	IFX_REG_W32(0, PCIE_UES_R(pcie_port));
-	IFX_REG_W32(0, PCIE_UEMR(pcie_port));
-	IFX_REG_W32(0, PCIE_UESR(pcie_port));
-	IFX_REG_W32(0, PCIE_CESR(pcie_port));
-	IFX_REG_W32(0, PCIE_CEMR(pcie_port));
-	IFX_REG_W32(0, PCIE_RESR(pcie_port));
-	IFX_REG_W32(0, PCIE_PVCCRSR(pcie_port));
-	IFX_REG_W32(0, PCIE_VC0_RSR0(pcie_port));
-	IFX_REG_W32(0, PCIE_TPFCS(pcie_port));
-	IFX_REG_W32(0, PCIE_TNPFCS(pcie_port));
-	IFX_REG_W32(0, PCIE_TCFCS(pcie_port));
-	IFX_REG_W32(0, PCIE_QSR(pcie_port));
-	IFX_REG_W32(0, PCIE_IOBLSECS(pcie_port));
-}
-
-static inline int ifx_pcie_link_up(int pcie_port)
-{
-    return (IFX_REG_R32(PCIE_PHY_SR(pcie_port)) & PCIE_PHY_SR_PHY_LINK_UP) ? 1 : 0;
-}
-
-
-static inline void pcie_mem_io_setup(int pcie_port)
-{
-    u32 reg;
-    /*
-     * BAR[0:1] readonly register 
-     * RC contains only minimal BARs for packets mapped to this device 
-     * Mem/IO filters defines a range of memory occupied by memory mapped IO devices that
-     * reside on the downstream side fo the bridge.
-     */
-    reg = SM((PCIE_MEM_PHY_PORT_TO_END(pcie_port) >> 20), PCIE_MBML_MEM_LIMIT_ADDR)
-        | SM((PCIE_MEM_PHY_PORT_TO_BASE(pcie_port) >> 20), PCIE_MBML_MEM_BASE_ADDR);
-
-    IFX_REG_W32(reg, PCIE_MBML(pcie_port));
-
-
-#ifdef IFX_PCIE_PREFETCH_MEM_64BIT
-    reg = SM((PCIE_MEM_PHY_PORT_TO_END(pcie_port) >> 20), PCIE_PMBL_END_ADDR)
-        | SM((PCIE_MEM_PHY_PORT_TO_BASE(pcie_port) >> 20), PCIE_PMBL_UPPER_12BIT)
-        | PCIE_PMBL_64BIT_ADDR;
-    IFX_REG_W32(reg, PCIE_PMBL(pcie_port));
-
-    /* Must configure upper 32bit */
-    IFX_REG_W32(0, PCIE_PMBU32(pcie_port));
-    IFX_REG_W32(0, PCIE_PMLU32(pcie_port));
-#else
-    /* PCIe_PBML, same as MBML */
-    IFX_REG_W32(IFX_REG_R32(PCIE_MBML(pcie_port)), PCIE_PMBL(pcie_port));
-#endif 
-
-    /* IO Address Range */
-    reg = SM((PCIE_IO_PHY_PORT_TO_END(pcie_port) >> 12), PCIE_IOBLSECS_IO_LIMIT_ADDR)
-        | SM((PCIE_IO_PHY_PORT_TO_BASE(pcie_port) >> 12), PCIE_IOBLSECS_IO_BASE_ADDR);
-#ifdef IFX_PCIE_IO_32BIT    
-    reg |= PCIE_IOBLSECS_32BIT_IO_ADDR;
-#endif /* IFX_PCIE_IO_32BIT */
-    IFX_REG_W32(reg, PCIE_IOBLSECS(pcie_port));
-
-#ifdef IFX_PCIE_IO_32BIT
-    reg = SM((PCIE_IO_PHY_PORT_TO_END(pcie_port) >> 16), PCIE_IO_BANDL_UPPER_16BIT_IO_LIMIT)
-        | SM((PCIE_IO_PHY_PORT_TO_BASE(pcie_port) >> 16), PCIE_IO_BANDL_UPPER_16BIT_IO_BASE);
-    IFX_REG_W32(reg, PCIE_IO_BANDL(pcie_port));
-
-#endif /* IFX_PCIE_IO_32BIT */
-}
-
-static inline void
-pcie_device_setup(int pcie_port)
-{
-    u32 reg;
-
-    /* Device capability register, set up Maximum payload size */
-    reg = IFX_REG_R32(PCIE_DCAP(pcie_port));
-    reg |= PCIE_DCAP_ROLE_BASE_ERR_REPORT;
-    reg |= SM(PCIE_MAX_PAYLOAD_128, PCIE_DCAP_MAX_PAYLOAD_SIZE);
-
-    /* Only available for EP */
-    reg &= ~(PCIE_DCAP_EP_L0S_LATENCY | PCIE_DCAP_EP_L1_LATENCY);
-    IFX_REG_W32(reg, PCIE_DCAP(pcie_port));
-
-    /* Device control and status register */
-    /* Set Maximum Read Request size for the device as a Requestor */
-    reg = IFX_REG_R32(PCIE_DCTLSTS(pcie_port));
-
-    /* 
-     * Request size can be larger than the MPS used, but the completions returned 
-     * for the read will be bounded by the MPS size.
-     * In our system, Max request size depends on AHB burst size. It is 64 bytes.
-     * but we set it as 128 as minimum one.
-     */
-    reg |= SM(PCIE_MAX_PAYLOAD_128, PCIE_DCTLSTS_MAX_READ_SIZE)
-            | SM(PCIE_MAX_PAYLOAD_128, PCIE_DCTLSTS_MAX_PAYLOAD_SIZE);
-
-    /* Enable relaxed ordering, no snoop, and all kinds of errors */
-    reg |= PCIE_DCTLSTS_RELAXED_ORDERING_EN | PCIE_DCTLSTS_ERR_EN | PCIE_DCTLSTS_NO_SNOOP_EN;
-
-    IFX_REG_W32(reg, PCIE_DCTLSTS(pcie_port));
-}
-
-static inline void
-pcie_link_setup(int pcie_port)
-{
-    u32 reg;
-
-    /*
-     * XXX, Link capability register, bit 18 for EP CLKREQ# dynamic clock management for L1, L2/3 CPM 
-     * L0s is reported during link training via TS1 order set by N_FTS
-     */
-    reg = IFX_REG_R32(PCIE_LCAP(pcie_port));
-    reg &= ~PCIE_LCAP_L0S_EIXT_LATENCY;
-    reg |= SM(3, PCIE_LCAP_L0S_EIXT_LATENCY);
-    IFX_REG_W32(reg, PCIE_LCAP(pcie_port));
-
-    /* Link control and status register */
-    reg = IFX_REG_R32(PCIE_LCTLSTS(pcie_port));
-
-    /* Link Enable, ASPM enabled  */
-    reg &= ~PCIE_LCTLSTS_LINK_DISABLE;
-
-#ifdef CONFIG_PCIEASPM
-    /*  
-     * We use the same physical reference clock that the platform provides on the connector 
-     * It paved the way for ASPM to calculate the new exit Latency
-     */
-    reg |= PCIE_LCTLSTS_SLOT_CLK_CFG;
-    reg |= PCIE_LCTLSTS_COM_CLK_CFG;
-    /*
-     * We should disable ASPM by default except that we have dedicated power management support
-     * Enable ASPM will cause the system hangup/instability, performance degration
-     */
-    reg |= PCIE_LCTLSTS_ASPM_ENABLE;
-#else
-    reg &= ~PCIE_LCTLSTS_ASPM_ENABLE;
-#endif /* CONFIG_PCIEASPM */
-
-    /* 
-     * The maximum size of any completion with data packet is bounded by the MPS setting 
-     * in  device control register 
-     */
-
-    /* RCB may cause multiple split transactions, two options available, we use 64 byte RCB */
-    reg &= ~ PCIE_LCTLSTS_RCB128;
-
-    IFX_REG_W32(reg, PCIE_LCTLSTS(pcie_port));
-}
-
-static inline void pcie_error_setup(int pcie_port)
-{
-	u32 reg;
-
-	/* 
-	* Forward ERR_COR, ERR_NONFATAL, ERR_FATAL to the backbone 
-	* Poisoned write TLPs and completions indicating poisoned TLPs will set the PCIe_PCICMDSTS.MDPE 
-	*/
-	reg = IFX_REG_R32(PCIE_INTRBCTRL(pcie_port));
-	reg |= PCIE_INTRBCTRL_SERR_ENABLE | PCIE_INTRBCTRL_PARITY_ERR_RESP_ENABLE;
-
-	IFX_REG_W32(reg, PCIE_INTRBCTRL(pcie_port));
-
-	/* Uncorrectable Error Mask Register, Unmask <enable> all bits in PCIE_UESR */
-	reg = IFX_REG_R32(PCIE_UEMR(pcie_port));
-	reg &= ~PCIE_ALL_UNCORRECTABLE_ERR;
-	IFX_REG_W32(reg, PCIE_UEMR(pcie_port));
-
-	/* Uncorrectable Error Severity Register, ALL errors are FATAL */
-	IFX_REG_W32(PCIE_ALL_UNCORRECTABLE_ERR, PCIE_UESR(pcie_port));
-
-	/* Correctable Error Mask Register, unmask <enable> all bits */
-	reg = IFX_REG_R32(PCIE_CEMR(pcie_port));
-	reg &= ~PCIE_CORRECTABLE_ERR;
-	IFX_REG_W32(reg, PCIE_CEMR(pcie_port));
-
-	/* Advanced Error Capabilities and Control Registr */
-	reg = IFX_REG_R32(PCIE_AECCR(pcie_port));
-	reg |= PCIE_AECCR_ECRC_CHECK_EN | PCIE_AECCR_ECRC_GEN_EN;
-	IFX_REG_W32(reg, PCIE_AECCR(pcie_port));
-
-	/* Root Error Command Register, Report all types of errors */
-	reg = IFX_REG_R32(PCIE_RECR(pcie_port));
-	reg |= PCIE_RECR_ERR_REPORT_EN;
-	IFX_REG_W32(reg, PCIE_RECR(pcie_port));
-
-	/* Clear the Root status register */
-	reg = IFX_REG_R32(PCIE_RESR(pcie_port));
-	IFX_REG_W32(reg, PCIE_RESR(pcie_port));
-}
-
-static inline void pcie_port_logic_setup(int pcie_port)
-{
-	u32 reg;
-
-	/* FTS number, default 12, increase to 63, may increase time from/to L0s to L0  */
-	reg = IFX_REG_R32(PCIE_AFR(pcie_port));
-	reg &= ~(PCIE_AFR_FTS_NUM | PCIE_AFR_COM_FTS_NUM);
-	reg |= SM(PCIE_AFR_FTS_NUM_DEFAULT, PCIE_AFR_FTS_NUM)
-		| SM(PCIE_AFR_FTS_NUM_DEFAULT, PCIE_AFR_COM_FTS_NUM);
-	/* L0s and L1 entry latency */
-	reg &= ~(PCIE_AFR_L0S_ENTRY_LATENCY | PCIE_AFR_L1_ENTRY_LATENCY);
-	reg |= SM(PCIE_AFR_L0S_ENTRY_LATENCY_DEFAULT, PCIE_AFR_L0S_ENTRY_LATENCY)
-		| SM(PCIE_AFR_L1_ENTRY_LATENCY_DEFAULT, PCIE_AFR_L1_ENTRY_LATENCY);
-	IFX_REG_W32(reg, PCIE_AFR(pcie_port));
-
-
-	/* Port Link Control Register */
-	reg = IFX_REG_R32(PCIE_PLCR(pcie_port));
-	reg |= PCIE_PLCR_DLL_LINK_EN;  /* Enable the DLL link */
-	IFX_REG_W32(reg, PCIE_PLCR(pcie_port));
-
-	/* Lane Skew Register */
-	reg = IFX_REG_R32(PCIE_LSR(pcie_port));
-	/* Enable ACK/NACK and FC */
-	reg &= ~(PCIE_LSR_ACKNAK_DISABLE | PCIE_LSR_FC_DISABLE);
-	IFX_REG_W32(reg, PCIE_LSR(pcie_port));
-
-	/* Symbol Timer Register and Filter Mask Register 1 */
-	reg = IFX_REG_R32(PCIE_STRFMR(pcie_port));
-
-	/* Default SKP interval is very accurate already, 5us */
-	/* Enable IO/CFG transaction */
-	reg |= PCIE_STRFMR_RX_CFG_TRANS_ENABLE | PCIE_STRFMR_RX_IO_TRANS_ENABLE;
-	/* Disable FC WDT */
-	reg &= ~PCIE_STRFMR_FC_WDT_DISABLE;
-	IFX_REG_W32(reg, PCIE_STRFMR(pcie_port));
-
-	/* Filter Masker Register 2 */
-	reg = IFX_REG_R32(PCIE_FMR2(pcie_port));
-	reg |= PCIE_FMR2_VENDOR_MSG1_PASSED_TO_TRGT1 | PCIE_FMR2_VENDOR_MSG0_PASSED_TO_TRGT1;
-	IFX_REG_W32(reg, PCIE_FMR2(pcie_port));
-
-	/* VC0 Completion Receive Queue Control Register */
-	reg = IFX_REG_R32(PCIE_VC0_CRQCR(pcie_port));
-	reg &= ~PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE;
-	reg |= SM(PCIE_VC0_TLP_QUEUE_MODE_BYPASS, PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE);
-	IFX_REG_W32(reg, PCIE_VC0_CRQCR(pcie_port));
-}
-
-static inline void pcie_rc_cfg_reg_setup(int pcie_port)
-{
-	u32 reg;
-
-	/* Disable LTSSM */
-	IFX_REG_W32(0, PCIE_RC_CCR(pcie_port)); /* Disable LTSSM */
-
-	pcie_mem_io_setup(pcie_port);
-
-	/* XXX, MSI stuff should only apply to EP */
-	/* MSI Capability: Only enable 32-bit addresses */
-	reg = IFX_REG_R32(PCIE_MCAPR(pcie_port));
-	reg &= ~PCIE_MCAPR_ADDR64_CAP;
-
-	reg |= PCIE_MCAPR_MSI_ENABLE;
-
-	/* Disable multiple message */
-	reg &= ~(PCIE_MCAPR_MULTI_MSG_CAP | PCIE_MCAPR_MULTI_MSG_ENABLE);
-	IFX_REG_W32(reg, PCIE_MCAPR(pcie_port));
-
-
-	/* Enable PME, Soft reset enabled */
-	reg = IFX_REG_R32(PCIE_PM_CSR(pcie_port));
-	reg |= PCIE_PM_CSR_PME_ENABLE | PCIE_PM_CSR_SW_RST;
-	IFX_REG_W32(reg, PCIE_PM_CSR(pcie_port));
-
-	/* setup the bus */
-	reg = SM(0, PCIE_BNR_PRIMARY_BUS_NUM) | SM(1, PCIE_PNR_SECONDARY_BUS_NUM) | SM(0xFF, PCIE_PNR_SUB_BUS_NUM);
-	IFX_REG_W32(reg, PCIE_BNR(pcie_port));
-
-
-	pcie_device_setup(pcie_port);
-	pcie_link_setup(pcie_port);
-	pcie_error_setup(pcie_port);
-
-	/* Root control and capabilities register */
-	reg = IFX_REG_R32(PCIE_RCTLCAP(pcie_port));
-	reg |= PCIE_RCTLCAP_SERR_ENABLE | PCIE_RCTLCAP_PME_INT_EN;
-	IFX_REG_W32(reg, PCIE_RCTLCAP(pcie_port));
-
-	/* Port VC Capability Register 2 */
-	reg = IFX_REG_R32(PCIE_PVC2(pcie_port));
-	reg &= ~PCIE_PVC2_VC_ARB_WRR;
-	reg |= PCIE_PVC2_VC_ARB_16P_FIXED_WRR;
-	IFX_REG_W32(reg, PCIE_PVC2(pcie_port));
-
-	/* VC0 Resource Capability Register */
-	reg = IFX_REG_R32(PCIE_VC0_RC(pcie_port));
-	reg &= ~PCIE_VC0_RC_REJECT_SNOOP;
-	IFX_REG_W32(reg, PCIE_VC0_RC(pcie_port));
-
-	pcie_port_logic_setup(pcie_port);
-}
-
-static int ifx_pcie_wait_phy_link_up(int pcie_port)
-{
-#define IFX_PCIE_PHY_LINK_UP_TIMEOUT  1000 /* XXX, tunable */
-    int i;
-
-    /* Wait for PHY link is up */
-    for (i = 0; i < IFX_PCIE_PHY_LINK_UP_TIMEOUT; i++) {
-        if (ifx_pcie_link_up(pcie_port)) {
-            break;
-        }
-        udelay(100);
-    }
-    if (i >= IFX_PCIE_PHY_LINK_UP_TIMEOUT) {
-        printk(KERN_ERR "%s timeout\n", __func__);
-        return -1;
-    }
-
-    /* Check data link up or not */
-    if (!(IFX_REG_R32(PCIE_RC_DR(pcie_port)) & PCIE_RC_DR_DLL_UP)) {
-        printk(KERN_ERR "%s DLL link is still down\n", __func__);
-        return -1;
-    }
-
-    /* Check Data link active or not */
-    if (!(IFX_REG_R32(PCIE_LCTLSTS(pcie_port)) & PCIE_LCTLSTS_DLL_ACTIVE)) {
-        printk(KERN_ERR "%s DLL is not active\n", __func__);
-        return -1;
-    }
-    return 0;
-}
-
-static inline int pcie_app_loigc_setup(int pcie_port)
-{
-	/* supress ahb bus errrors */
-	IFX_REG_W32(PCIE_AHB_CTRL_BUS_ERROR_SUPPRESS, PCIE_AHB_CTRL(pcie_port));
-
-	/* Pull PCIe EP out of reset */
-	pcie_device_rst_deassert(pcie_port);
-
-	/* Start LTSSM training between RC and EP */
-	pcie_ltssm_enable(pcie_port);
-
-	/* Check PHY status after enabling LTSSM */
-	if (ifx_pcie_wait_phy_link_up(pcie_port) != 0)
-		return -1;
-
-	return 0;
-}
-
-/*
- * The numbers below are directly from the PCIe spec table 3-4/5. 
- */
-static inline void pcie_replay_time_update(int pcie_port)
-{
-	u32 reg;
-	int nlw;
-	int rtl;
-
-	reg = IFX_REG_R32(PCIE_LCTLSTS(pcie_port));
-
-	nlw = MS(reg, PCIE_LCTLSTS_NEGOTIATED_LINK_WIDTH);
-	switch (nlw) {
-	case PCIE_MAX_LENGTH_WIDTH_X1:
-		rtl = 1677;
-		break;
-	case PCIE_MAX_LENGTH_WIDTH_X2:
-		rtl = 867;
-		break;
-	case PCIE_MAX_LENGTH_WIDTH_X4:
-		rtl = 462;
-		break;
-	case PCIE_MAX_LENGTH_WIDTH_X8:
-		rtl = 258;
-		break;
-	default:
-		rtl = 1677;
-		break;
-	}
-	reg = IFX_REG_R32(PCIE_ALTRT(pcie_port));
-	reg &= ~PCIE_ALTRT_REPLAY_TIME_LIMIT;
-	reg |= SM(rtl, PCIE_ALTRT_REPLAY_TIME_LIMIT);
-	IFX_REG_W32(reg, PCIE_ALTRT(pcie_port));
-}
-
-/*
- * Table 359 Enhanced Configuration Address Mapping1)
- * 1) This table is defined in Table 7-1, page 341, PCI Express Base Specification v1.1
- * Memory Address PCI Express Configuration Space
- * A[(20+n-1):20] Bus Number 1 < n < 8
- * A[19:15] Device Number
- * A[14:12] Function Number
- * A[11:8] Extended Register Number
- * A[7:2] Register Number
- * A[1:0] Along with size of the access, used to generate Byte Enables
- * For VR9, only the address bits [22:0] are mapped to the configuration space:
- * . Address bits [22:20] select the target bus (1-of-8)1)
- * . Address bits [19:15] select the target device (1-of-32) on the bus
- * . Address bits [14:12] select the target function (1-of-8) within the device.
- * . Address bits [11:2] selects the target dword (1-of-1024) within the selected function.s configuration space
- * . Address bits [1:0] define the start byte location within the selected dword.
- */
-static inline u32 pcie_bus_addr(u8 bus_num, u16 devfn, int where)
-{
-	u32 addr;
-	u8  bus;
-
-	if (!bus_num) {
-		/* type 0 */
-		addr = ((PCI_SLOT(devfn) & 0x1F) << 15) | ((PCI_FUNC(devfn) & 0x7) << 12) | ((where & 0xFFF)& ~3);
-	} else {
-		bus = bus_num;
-		/* type 1, only support 8 buses  */
-		addr = ((bus & 0x7) << 20) | ((PCI_SLOT(devfn) & 0x1F) << 15) |
-			((PCI_FUNC(devfn) & 0x7) << 12) | ((where & 0xFFF) & ~3);
-	}
-	return addr;
-}
-
-static int pcie_valid_config(int pcie_port, int bus, int dev)
-{
-	/* RC itself */
-	if ((bus == 0) && (dev == 0)) {
-		return 1;
-	}
-
-	/* No physical link */
-	if (!ifx_pcie_link_up(pcie_port)) {
-		return 0;
-	}
-
-	/* Bus zero only has RC itself
-	* XXX, check if EP will be integrated 
-	*/
-	if ((bus == 0) && (dev != 0)) {
-		return 0;
-	}
-
-	/* Maximum 8 buses supported for VRX */
-	if (bus > 9) {
-		return 0;
-	}
-
-	/* 
-	 * PCIe is PtP link, one bus only supports only one device 
-	 * except bus zero and PCIe switch which is virtual bus device
-	 * The following two conditions really depends on the system design
-	 * and attached the device.
-	 * XXX, how about more new switch
-	*/
-	if ((bus == 1) && (dev != 0)) {
-		return 0;
-	}
-
-	if ((bus >= 3) && (dev != 0)) {
-		return 0;
-	}
-	return 1;
-}
-
-static inline u32 ifx_pcie_cfg_rd(int pcie_port, u32 reg)
-{
-    return IFX_REG_R32((volatile u32 *)(PCIE_CFG_PORT_TO_BASE(pcie_port) + reg));
-}
-
-static inline void ifx_pcie_cfg_wr(int pcie_port, unsigned int reg, u32 val)
-{
-    IFX_REG_W32( val, (volatile u32 *)(PCIE_CFG_PORT_TO_BASE(pcie_port) + reg));
-}
-
-static inline u32 ifx_pcie_rc_cfg_rd(int pcie_port, u32 reg)
-{
-    return IFX_REG_R32((volatile u32 *)(PCIE_RC_PORT_TO_BASE(pcie_port) + reg));
-}
-
-static inline void ifx_pcie_rc_cfg_wr(int pcie_port, unsigned int reg, u32 val)
-{
-	IFX_REG_W32(val, (volatile u32 *)(PCIE_RC_PORT_TO_BASE(pcie_port) + reg));
-}
-
-u32 ifx_pcie_bus_enum_read_hack(int where, u32 value)
-{
-	u32 tvalue = value;
-
-	if (where == PCI_PRIMARY_BUS) {
-		u8 primary, secondary, subordinate;
-
-		primary = tvalue & 0xFF;
-		secondary = (tvalue >> 8) & 0xFF;
-		subordinate = (tvalue >> 16) & 0xFF;
-		primary += pcibios_1st_host_bus_nr();
-		secondary += pcibios_1st_host_bus_nr();
-		subordinate += pcibios_1st_host_bus_nr();
-		tvalue = (tvalue & 0xFF000000) | (u32)primary | (u32)(secondary << 8) | (u32)(subordinate << 16);
-	}
-	return tvalue;
-}
-
-u32 ifx_pcie_bus_enum_write_hack(int where, u32 value)
-{
-    u32 tvalue = value;
-
-    if (where == PCI_PRIMARY_BUS) {
-        u8 primary, secondary, subordinate;
-
-        primary = tvalue & 0xFF;
-        secondary = (tvalue >> 8) & 0xFF;
-        subordinate = (tvalue >> 16) & 0xFF;
-        if (primary > 0 && primary != 0xFF) {
-            primary -= pcibios_1st_host_bus_nr();
-        }
-
-        if (secondary > 0 && secondary != 0xFF) {
-            secondary -= pcibios_1st_host_bus_nr();
-        }
-        if (subordinate > 0 && subordinate != 0xFF) {
-            subordinate -= pcibios_1st_host_bus_nr();
-        }
-        tvalue = (tvalue & 0xFF000000) | (u32)primary | (u32)(secondary << 8) | (u32)(subordinate << 16);
-    }
-    else if (where == PCI_SUBORDINATE_BUS) {
-        u8 subordinate = tvalue & 0xFF;
-
-        subordinate = subordinate > 0 ? subordinate - pcibios_1st_host_bus_nr() : 0;
-        tvalue = subordinate;
-    }
-    return tvalue;
-}
-
-static int ifx_pcie_read_config(struct pci_bus *bus, u32 devfn,
-				int where, int size, u32 *value)
-{
-    u32 data = 0;
-    int bus_number = bus->number;
-    static const u32 mask[8] = {0, 0xff, 0xffff, 0, 0xffffffff, 0, 0, 0};
-    int ret = PCIBIOS_SUCCESSFUL;
-    struct ifx_pci_controller *ctrl = bus->sysdata;
-    int pcie_port = ctrl->port;
-
-    if (unlikely(size != 1 && size != 2 && size != 4)){
-        ret = PCIBIOS_BAD_REGISTER_NUMBER;
-        goto out;
-    }
-
-    /* Make sure the address is aligned to natural boundary */
-    if (unlikely(((size - 1) & where))) {
-        ret = PCIBIOS_BAD_REGISTER_NUMBER;
-        goto out;
-    }
-
-    /* 
-     * If we are second controller, we have to cheat OS so that it assume 
-     * its bus number starts from 0 in host controller
-     */
-    bus_number = ifx_pcie_bus_nr_deduct(bus_number, pcie_port);
-
-    /* 
-     * We need to force the bus number to be zero on the root 
-     * bus. Linux numbers the 2nd root bus to start after all 
-     * busses on root 0. 
-     */ 
-    if (bus->parent == NULL) {
-        bus_number = 0; 
-    }
-
-    /* 
-     * PCIe only has a single device connected to it. It is 
-     * always device ID 0. Don't bother doing reads for other 
-     * device IDs on the first segment. 
-     */ 
-    if ((bus_number == 0) && (PCI_SLOT(devfn) != 0)) {
-        ret = PCIBIOS_FUNC_NOT_SUPPORTED;
-        goto out; 
-    }
-
-    if (pcie_valid_config(pcie_port, bus_number, PCI_SLOT(devfn)) == 0) {
-        *value = 0xffffffff;
-        ret = PCIBIOS_DEVICE_NOT_FOUND;
-        goto out;
-    }
-
-    PCIE_IRQ_LOCK(ifx_pcie_lock);
-    if (bus_number == 0) { /* RC itself */
-        u32 t;
-
-        t = (where & ~3);
-        data = ifx_pcie_rc_cfg_rd(pcie_port, t);
-    } else {
-        u32 addr = pcie_bus_addr(bus_number, devfn, where);
-
-        data = ifx_pcie_cfg_rd(pcie_port, addr);
-    #ifdef CONFIG_IFX_PCIE_HW_SWAP
-            data = le32_to_cpu(data);
-    #endif /* CONFIG_IFX_PCIE_HW_SWAP */
-    }
-    /* To get a correct PCI topology, we have to restore the bus number to OS */
-    data = ifx_pcie_bus_enum_hack(bus, devfn, where, data, pcie_port, 1);
-
-    PCIE_IRQ_UNLOCK(ifx_pcie_lock);
-
-    *value = (data >> (8 * (where & 3))) & mask[size & 7];
-out:
-    return ret;
-}
-
-static u32 ifx_pcie_size_to_value(int where, int size, u32 data, u32 value)
-{
-	u32 shift;
-	u32 tdata = data;
-
-	switch (size) {
-	case 1:
-		shift = (where & 0x3) << 3;
-		tdata &= ~(0xffU << shift);
-		tdata |= ((value & 0xffU) << shift);
-		break;
-	case 2:
-		shift = (where & 3) << 3;
-		tdata &= ~(0xffffU << shift);
-		tdata |= ((value & 0xffffU) << shift);
-		break;
-	case 4:
-		tdata = value;
-		break;
-	}
-	return tdata;
-}
-
-static int ifx_pcie_write_config(struct pci_bus *bus, u32 devfn,
-				int where, int size, u32 value)
-{
-	int bus_number = bus->number;
-	int ret = PCIBIOS_SUCCESSFUL;
-	struct ifx_pci_controller *ctrl = bus->sysdata;
-	int pcie_port = ctrl->port;
-	u32 tvalue = value;
-	u32 data;
-
-	/* Make sure the address is aligned to natural boundary */
-	if (unlikely(((size - 1) & where))) {
-		ret = PCIBIOS_BAD_REGISTER_NUMBER;
-		goto out;
-	}
-	/* 
-	* If we are second controller, we have to cheat OS so that it assume 
-	* its bus number starts from 0 in host controller
-	*/
-	bus_number = ifx_pcie_bus_nr_deduct(bus_number, pcie_port);
-
-	/* 
-	* We need to force the bus number to be zero on the root 
-	* bus. Linux numbers the 2nd root bus to start after all 
-	* busses on root 0. 
-	*/ 
-	if (bus->parent == NULL) {
-		bus_number = 0; 
-	}
-
-	if (pcie_valid_config(pcie_port, bus_number, PCI_SLOT(devfn)) == 0) {
-		ret = PCIBIOS_DEVICE_NOT_FOUND;
-		goto out;
-	}
-
-	/* XXX, some PCIe device may need some delay */
-	PCIE_IRQ_LOCK(ifx_pcie_lock);
-
-	/* 
-	* To configure the correct bus topology using native way, we have to cheat Os so that
-	* it can configure the PCIe hardware correctly.
-	*/
-	tvalue = ifx_pcie_bus_enum_hack(bus, devfn, where, value, pcie_port, 0);
-
-	if (bus_number == 0) { /* RC itself */
-		u32 t;
-
-		t = (where & ~3);
-		data = ifx_pcie_rc_cfg_rd(pcie_port, t);
-
-		data = ifx_pcie_size_to_value(where, size, data, tvalue);
-
-		ifx_pcie_rc_cfg_wr(pcie_port, t, data);
-	} else {
-		u32 addr = pcie_bus_addr(bus_number, devfn, where);
-
-		data = ifx_pcie_cfg_rd(pcie_port, addr);
-#ifdef CONFIG_IFX_PCIE_HW_SWAP
-		data = le32_to_cpu(data);
-#endif
-
-		data = ifx_pcie_size_to_value(where, size, data, tvalue);
-#ifdef CONFIG_IFX_PCIE_HW_SWAP
-		data = cpu_to_le32(data);
-#endif
-		ifx_pcie_cfg_wr(pcie_port, addr, data);
-	}
-	PCIE_IRQ_UNLOCK(ifx_pcie_lock);
-out:
-	return ret;
-}
-
-static struct resource ifx_pcie_io_resource = {
-	.name	= "PCIe0 I/O space",
-	.start	= PCIE_IO_PHY_BASE,
-	.end	= PCIE_IO_PHY_END,
-	.flags	= IORESOURCE_IO,
-};
-
-static struct resource ifx_pcie_mem_resource = {
-	.name	= "PCIe0 Memory space",
-	.start	= PCIE_MEM_PHY_BASE,
-	.end	= PCIE_MEM_PHY_END,
-	.flags	= IORESOURCE_MEM,
-};
-
-static struct pci_ops ifx_pcie_ops = {
-	.read	= ifx_pcie_read_config,
-	.write	= ifx_pcie_write_config,
-};
-
-static struct ifx_pci_controller ifx_pcie_controller[IFX_PCIE_CORE_NR] = {
-    {
-        .pcic = {
-            .pci_ops      = &ifx_pcie_ops,
-            .mem_resource = &ifx_pcie_mem_resource,
-            .io_resource  = &ifx_pcie_io_resource,
-         },
-         .port = IFX_PCIE_PORT0,
-    },
-};
-
-#ifdef IFX_PCIE_ERROR_INT
-
-static irqreturn_t pcie_rc_core_isr(int irq, void *dev_id)
-{
-	struct ifx_pci_controller *ctrl = (struct ifx_pci_controller *)dev_id;
-	int pcie_port = ctrl->port;
-	u32 reg;
-
-	printk("PCIe RC error intr %d\n", irq);
-	reg = IFX_REG_R32(PCIE_IRNCR(pcie_port));
-	reg &= PCIE_RC_CORE_COMBINED_INT;
-	IFX_REG_W32(reg, PCIE_IRNCR(pcie_port));
-
-	return IRQ_HANDLED;
-}
-
-static int
-pcie_rc_core_int_init(int pcie_port)
-{
-	int ret;
-
-	/* Enable core interrupt */
-	IFX_REG_SET_BIT(PCIE_RC_CORE_COMBINED_INT, PCIE_IRNEN(pcie_port));
-
-	/* Clear it first */
-	IFX_REG_SET_BIT(PCIE_RC_CORE_COMBINED_INT, PCIE_IRNCR(pcie_port));
-	ret = request_irq(pcie_irqs[pcie_port].ir_irq.irq, pcie_rc_core_isr, 0,
-		pcie_irqs[pcie_port].ir_irq.name, &ifx_pcie_controller[pcie_port]);
-	if (ret)
-		printk(KERN_ERR "%s request irq %d failed\n", __func__, IFX_PCIE_IR);
-
-	return ret;
-}
-#endif
-
-int ifx_pcie_bios_map_irq(IFX_PCI_CONST struct pci_dev *dev, u8 slot, u8 pin)
-{
-	u32 irq_bit = 0;
-	int irq = 0;
-	struct ifx_pci_controller *ctrl = dev->bus->sysdata;
-	int pcie_port = ctrl->port;
-
-	printk("%s port %d dev %s slot %d pin %d \n", __func__, pcie_port, pci_name(dev), slot, pin);
-
-	if ((pin == PCIE_LEGACY_DISABLE) || (pin > PCIE_LEGACY_INT_MAX)) {
-		printk(KERN_WARNING "WARNING: dev %s: invalid interrupt pin %d\n", pci_name(dev), pin);
-		return -1;
-	}
-
-	/* Pin index so minus one */
-	irq_bit = pcie_irqs[pcie_port].legacy_irq[pin - 1].irq_bit;
-	irq = pcie_irqs[pcie_port].legacy_irq[pin - 1].irq;
-	IFX_REG_SET_BIT(irq_bit, PCIE_IRNEN(pcie_port));
-	IFX_REG_SET_BIT(irq_bit, PCIE_IRNCR(pcie_port));
-	printk("%s dev %s irq %d assigned\n", __func__, pci_name(dev), irq);
-	return irq;
-}
-
-int  ifx_pcie_bios_plat_dev_init(struct pci_dev *dev)
-{
-    u16 config;
-#ifdef IFX_PCIE_ERROR_INT
-    u32 dconfig; 
-    int pos;
-#endif
-
-    /* Enable reporting System errors and parity errors on all devices */ 
-    /* Enable parity checking and error reporting */ 
-    pci_read_config_word(dev, PCI_COMMAND, &config);
-    config |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR /*| PCI_COMMAND_INVALIDATE |
-          PCI_COMMAND_FAST_BACK*/;
-    pci_write_config_word(dev, PCI_COMMAND, config);
-
-    if (dev->subordinate) {
-        /* Set latency timers on sub bridges */
-        pci_write_config_byte(dev, PCI_SEC_LATENCY_TIMER, 0x40); /* XXX, */
-        /* More bridge error detection */
-        pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &config);
-        config |= PCI_BRIDGE_CTL_PARITY | PCI_BRIDGE_CTL_SERR;
-        pci_write_config_word(dev, PCI_BRIDGE_CONTROL, config);
-    }
-#ifdef IFX_PCIE_ERROR_INT
-    /* Enable the PCIe normal error reporting */
-    pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
-    if (pos) {
-
-        /* Disable system error generation in response to error messages */
-        pci_read_config_word(dev, pos + PCI_EXP_RTCTL, &config);
-        config &= ~(PCI_EXP_RTCTL_SECEE | PCI_EXP_RTCTL_SENFEE | PCI_EXP_RTCTL_SEFEE);
-        pci_write_config_word(dev, pos + PCI_EXP_RTCTL, config);
-
-        /* Clear PCIE Capability's Device Status */
-        pci_read_config_word(dev, pos + PCI_EXP_DEVSTA, &config);
-        pci_write_config_word(dev, pos + PCI_EXP_DEVSTA, config);
-
-        /* Update Device Control */ 
-        pci_read_config_word(dev, pos + PCI_EXP_DEVCTL, &config);
-        /* Correctable Error Reporting */
-        config |= PCI_EXP_DEVCTL_CERE;
-        /* Non-Fatal Error Reporting */
-        config |= PCI_EXP_DEVCTL_NFERE;
-        /* Fatal Error Reporting */
-        config |= PCI_EXP_DEVCTL_FERE;
-        /* Unsupported Request */
-        config |= PCI_EXP_DEVCTL_URRE;
-        pci_write_config_word(dev, pos + PCI_EXP_DEVCTL, config);
-    }
-
-    /* Find the Advanced Error Reporting capability */
-    pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
-    if (pos) {
-        /* Clear Uncorrectable Error Status */ 
-        pci_read_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS, &dconfig);
-        pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS, dconfig);
-        /* Enable reporting of all uncorrectable errors */
-        /* Uncorrectable Error Mask - turned on bits disable errors */
-        pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, 0);
-        /* 
-        * Leave severity at HW default. This only controls if 
-        * errors are reported as uncorrectable or 
-        * correctable, not if the error is reported. 
-        */ 
-        /* PCI_ERR_UNCOR_SEVER - Uncorrectable Error Severity */
-        /* Clear Correctable Error Status */
-        pci_read_config_dword(dev, pos + PCI_ERR_COR_STATUS, &dconfig);
-        pci_write_config_dword(dev, pos + PCI_ERR_COR_STATUS, dconfig);
-        /* Enable reporting of all correctable errors */
-        /* Correctable Error Mask - turned on bits disable errors */
-        pci_write_config_dword(dev, pos + PCI_ERR_COR_MASK, 0);
-        /* Advanced Error Capabilities */ 
-        pci_read_config_dword(dev, pos + PCI_ERR_CAP, &dconfig);
-        /* ECRC Generation Enable */
-        if (dconfig & PCI_ERR_CAP_ECRC_GENC) {
-            dconfig |= PCI_ERR_CAP_ECRC_GENE;
-        }
-        /* ECRC Check Enable */
-        if (dconfig & PCI_ERR_CAP_ECRC_CHKC) {
-            dconfig |= PCI_ERR_CAP_ECRC_CHKE;
-        }
-        pci_write_config_dword(dev, pos + PCI_ERR_CAP, dconfig);
-
-        /* PCI_ERR_HEADER_LOG - Header Log Register (16 bytes) */
-        /* Enable Root Port's interrupt in response to error messages */
-        pci_write_config_dword(dev, pos + PCI_ERR_ROOT_COMMAND,
-              PCI_ERR_ROOT_CMD_COR_EN |
-              PCI_ERR_ROOT_CMD_NONFATAL_EN |
-              PCI_ERR_ROOT_CMD_FATAL_EN); 
-        /* Clear the Root status register */
-        pci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, &dconfig);
-        pci_write_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, dconfig);
-    }
-#endif /* IFX_PCIE_ERROR_INT */
-    /* WAR, only 128 MRRS is supported, force all EPs to support this value */
-    pcie_set_readrq(dev, 128);
-    return 0;
-}
-
-static int
-pcie_rc_initialize(int pcie_port)
-{
-	int i;
-#define IFX_PCIE_PHY_LOOP_CNT  5
-
-	pcie_rcu_endian_setup(pcie_port);
-
-	pcie_ep_gpio_rst_init(pcie_port);
-
-	/* 
-	* XXX, PCIe elastic buffer bug will cause not to be detected. One more 
-	* reset PCIe PHY will solve this issue 
-	*/
-	for (i = 0; i < IFX_PCIE_PHY_LOOP_CNT; i++) {
-		/* Disable PCIe PHY Analog part for sanity check */
-		pcie_phy_pmu_disable(pcie_port);
-
-		pcie_phy_rst_assert(pcie_port);
-		pcie_phy_rst_deassert(pcie_port);
-
-		/* Make sure PHY PLL is stable */
-		udelay(20);
-
-		/* PCIe Core reset enabled, low active, sw programmed */
-		pcie_core_rst_assert(pcie_port);
-
-		/* Put PCIe EP in reset status */
-		pcie_device_rst_assert(pcie_port);
-
-		/* PCI PHY & Core reset disabled, high active, sw programmed */
-		pcie_core_rst_deassert(pcie_port);
-
-		/* Already in a quiet state, program PLL, enable PHY, check ready bit */
-		pcie_phy_clock_mode_setup(pcie_port);
-
-		/* Enable PCIe PHY and Clock */
-		pcie_core_pmu_setup(pcie_port);
-
-		/* Clear status registers */
-		pcie_status_register_clear(pcie_port);
-
-#ifdef CONFIG_PCI_MSI
-		pcie_msi_init(pcie_port);
-#endif /* CONFIG_PCI_MSI */
-		pcie_rc_cfg_reg_setup(pcie_port);
-
-		/* Once link is up, break out */
-		if (pcie_app_loigc_setup(pcie_port) == 0)
-			break;
-	}
-	if (i >= IFX_PCIE_PHY_LOOP_CNT) {
-		printk(KERN_ERR "%s link up failed!!!!!\n", __func__);
-		return -EIO;
-	}
-	/* NB, don't increase ACK/NACK timer timeout value, which will cause a lot of COR errors */
-	pcie_replay_time_update(pcie_port);
-	return 0;
-}
-
-extern int (*ltq_pci_plat_arch_init)(struct pci_dev *dev);
-extern int (*ltq_pci_map_irq)(const struct pci_dev *dev, u8 slot, u8 pin);
-
-static int __init ifx_pcie_bios_init(void)
-{
-    void __iomem *io_map_base;
-    int pcie_port;
-    int startup_port;
-
-
-	ltq_pci_map_irq = ifx_pcie_bios_map_irq;
-	ltq_pci_plat_arch_init = ifx_pcie_bios_plat_dev_init;
-
-    /* Enable AHB Master/ Slave */
-    pcie_ahb_pmu_setup();
-
-    startup_port = IFX_PCIE_PORT0;
-    
-    for (pcie_port = startup_port; pcie_port < IFX_PCIE_CORE_NR; pcie_port++){
-	if (pcie_rc_initialize(pcie_port) == 0) {
-	    IFX_PCIE_PRINT(PCIE_MSG_INIT, "%s: ifx_pcie_cfg_base 0x%p\n", 
-                 __func__, PCIE_CFG_PORT_TO_BASE(pcie_port));
-            /* Otherwise, warning will pop up */
-            io_map_base = ioremap(PCIE_IO_PHY_PORT_TO_BASE(pcie_port), PCIE_IO_SIZE);
-            if (io_map_base == NULL) {
-                IFX_PCIE_PRINT(PCIE_MSG_ERR, "%s io space ioremap failed\n", __func__);
-                return -ENOMEM;
-            }
-            ifx_pcie_controller[pcie_port].pcic.io_map_base = (unsigned long)io_map_base;
-
-            register_pci_controller(&ifx_pcie_controller[pcie_port].pcic);
-            /* XXX, clear error status */
-
-            IFX_PCIE_PRINT(PCIE_MSG_INIT, "%s: mem_resource 0x%p, io_resource 0x%p\n", 
-                              __func__, &ifx_pcie_controller[pcie_port].pcic.mem_resource, 
-                              &ifx_pcie_controller[pcie_port].pcic.io_resource);
-
-        #ifdef IFX_PCIE_ERROR_INT
-            pcie_rc_core_int_init(pcie_port);
-        #endif /* IFX_PCIE_ERROR_INT */
-        }
-    }
-
-    return 0;
-}
-arch_initcall(ifx_pcie_bios_init);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Chuanhua.Lei@infineon.com");
-MODULE_SUPPORTED_DEVICE("Infineon builtin PCIe RC module");
-MODULE_DESCRIPTION("Infineon builtin PCIe RC driver");
-
diff --git a/arch/mips/pci/ifxmips_pcie.h b/arch/mips/pci/ifxmips_pcie.h
deleted file mode 100644
--- a/arch/mips/pci/ifxmips_pcie.h
+++ /dev/null
@@ -1,135 +0,0 @@
-/******************************************************************************
-**
-** FILE NAME    : ifxmips_pcie.h
-** PROJECT      : IFX UEIP for VRX200
-** MODULES      : PCIe module
-**
-** DATE         : 02 Mar 2009
-** AUTHOR       : Lei Chuanhua
-** DESCRIPTION  : PCIe Root Complex Driver
-** COPYRIGHT    :       Copyright (c) 2009
-**                      Infineon Technologies AG
-**                      Am Campeon 1-12, 85579 Neubiberg, Germany
-**
-**    This program is free software; you can redistribute it and/or modify
-**    it under the terms of the GNU General Public License as published by
-**    the Free Software Foundation; either version 2 of the License, or
-**    (at your option) any later version.
-** HISTORY
-** $Version $Date        $Author         $Comment
-** 0.0.1    17 Mar,2009  Lei Chuanhua    Initial version
-*******************************************************************************/
-#ifndef IFXMIPS_PCIE_H
-#define IFXMIPS_PCIE_H
-#include <linux/version.h>
-#include <linux/types.h>
-#include <linux/pci.h>
-#include <linux/interrupt.h>
-#include "ifxmips_pci_common.h"
-#include "ifxmips_pcie_reg.h"
-
-/*!
- \defgroup IFX_PCIE  PCI Express bus driver module   
- \brief  PCI Express IP module support VRX200 
-*/
-
-/*!
- \defgroup IFX_PCIE_OS OS APIs
- \ingroup IFX_PCIE
- \brief PCIe bus driver OS interface functions
-*/
-
-/*!
- \file ifxmips_pcie.h
- \ingroup IFX_PCIE  
- \brief header file for PCIe module common header file
-*/
-#define PCIE_IRQ_LOCK(lock) do {             \
-    unsigned long flags;                     \
-    spin_lock_irqsave(&(lock), flags);
-#define PCIE_IRQ_UNLOCK(lock)                \
-    spin_unlock_irqrestore(&(lock), flags);  \
-} while (0)
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
-#define IRQF_SHARED SA_SHIRQ
-#endif
-
-#define PCIE_MSG_MSI        0x00000001
-#define PCIE_MSG_ISR        0x00000002
-#define PCIE_MSG_FIXUP      0x00000004
-#define PCIE_MSG_READ_CFG   0x00000008
-#define PCIE_MSG_WRITE_CFG  0x00000010
-#define PCIE_MSG_CFG        (PCIE_MSG_READ_CFG | PCIE_MSG_WRITE_CFG)
-#define PCIE_MSG_REG        0x00000020
-#define PCIE_MSG_INIT       0x00000040
-#define PCIE_MSG_ERR        0x00000080
-#define PCIE_MSG_PHY        0x00000100
-#define PCIE_MSG_ANY        0x000001ff
-
-#define IFX_PCIE_PORT0      0
-#define IFX_PCIE_PORT1      1
-
-#ifdef CONFIG_IFX_PCIE_2ND_CORE
-#define IFX_PCIE_CORE_NR    2
-#else
-#define IFX_PCIE_CORE_NR    1
-#endif
-
-#define IFX_PCIE_ERROR_INT
-
-//#define IFX_PCIE_DBG
-
-#if defined(IFX_PCIE_DBG)
-#define IFX_PCIE_PRINT(_m, _fmt, args...) do {   \
-        ifx_pcie_debug((_fmt), ##args);          \
-} while (0)
-
-#define INLINE 
-#else
-#define IFX_PCIE_PRINT(_m, _fmt, args...)   \
-    do {} while(0)
-#define INLINE inline
-#endif
-
-struct ifx_pci_controller {
-	struct pci_controller   pcic;
-    
-	/* RC specific, per host bus information */
-	u32   port;  /* Port index, 0 -- 1st core, 1 -- 2nd core */
-};
-
-typedef struct ifx_pcie_ir_irq {
-    const unsigned int irq;
-    const char name[16];
-}ifx_pcie_ir_irq_t;
-
-typedef struct ifx_pcie_legacy_irq{
-    const u32 irq_bit;
-    const int irq;
-}ifx_pcie_legacy_irq_t;
-
-typedef struct ifx_pcie_irq {
-    ifx_pcie_ir_irq_t ir_irq;
-    ifx_pcie_legacy_irq_t legacy_irq[PCIE_LEGACY_INT_MAX];
-}ifx_pcie_irq_t;
-
-extern u32 g_pcie_debug_flag;
-extern void ifx_pcie_debug(const char *fmt, ...);
-extern void pcie_phy_clock_mode_setup(int pcie_port);
-extern void pcie_msi_pic_init(int pcie_port);
-extern u32 ifx_pcie_bus_enum_read_hack(int where, u32 value);
-extern u32 ifx_pcie_bus_enum_write_hack(int where, u32 value);
-
-#define CONFIG_VR9
-
-#ifdef CONFIG_VR9
-#include "ifxmips_pcie_vr9.h"
-#elif defined (CONFIG_AR10)
-#include "ifxmips_pcie_ar10.h"
-#else
-#error "PCIE: platform not defined"
-#endif /* CONFIG_VR9 */
-
-#endif  /* IFXMIPS_PCIE_H */
-
diff --git a/arch/mips/pci/ifxmips_pcie_ar10.h b/arch/mips/pci/ifxmips_pcie_ar10.h
deleted file mode 100644
--- a/arch/mips/pci/ifxmips_pcie_ar10.h
+++ /dev/null
@@ -1,290 +0,0 @@
-/****************************************************************************
-                              Copyright (c) 2010
-                            Lantiq Deutschland GmbH
-                     Am Campeon 3; 85579 Neubiberg, Germany
-
-  For licensing information, see the file 'LICENSE' in the root folder of
-  this software module.
-
- *****************************************************************************/
-/*!
-  \file ifxmips_pcie_ar10.h
-  \ingroup IFX_PCIE
-  \brief PCIe RC driver ar10 specific file
-*/
-
-#ifndef IFXMIPS_PCIE_AR10_H
-#define IFXMIPS_PCIE_AR10_H
-#ifndef AUTOCONF_INCLUDED
-#include <linux/config.h>
-#endif /* AUTOCONF_INCLUDED */
-#include <linux/types.h>
-#include <linux/delay.h>
-
-/* Project header file */
-#include <asm/ifx/ifx_types.h>
-#include <asm/ifx/ifx_pmu.h>
-#include <asm/ifx/ifx_gpio.h>
-#include <asm/ifx/ifx_ebu_led.h>
-
-static inline void pcie_ep_gpio_rst_init(int pcie_port)
-{
-    ifx_ebu_led_enable();
-    if (pcie_port == 0) {
-        ifx_ebu_led_set_data(11, 1);        
-    }
-    else {
-        ifx_ebu_led_set_data(12, 1);  
-    }
-}
-
-static inline void pcie_ahb_pmu_setup(void) 
-{
-    /* XXX, moved to CGU to control AHBM */
-}
-
-static inline void pcie_rcu_endian_setup(int pcie_port)
-{
-    u32 reg;
-
-    reg = IFX_REG_R32(IFX_RCU_AHB_ENDIAN);
-    /* Inbound, big endian */
-    reg |= IFX_RCU_BE_AHB4S;
-    if (pcie_port == 0) {
-        reg |= IFX_RCU_BE_PCIE0M;
-
-    #ifdef CONFIG_IFX_PCIE_HW_SWAP
-        /* Outbound, software swap needed */
-        reg |= IFX_RCU_BE_AHB3M;
-        reg &= ~IFX_RCU_BE_PCIE0S;
-    #else
-        /* Outbound little endian  */
-        reg &= ~IFX_RCU_BE_AHB3M;
-        reg &= ~IFX_RCU_BE_PCIE0S;
-    #endif
-    }
-    else {
-        reg |= IFX_RCU_BE_PCIE1M;
-    #ifdef CONFIG_IFX_PCIE1_HW_SWAP
-        /* Outbound, software swap needed */
-        reg |= IFX_RCU_BE_AHB3M;
-        reg &= ~IFX_RCU_BE_PCIE1S;
-    #else
-        /* Outbound little endian  */
-        reg &= ~IFX_RCU_BE_AHB3M;
-        reg &= ~IFX_RCU_BE_PCIE1S;
-    #endif
-    }
-
-    IFX_REG_W32(reg, IFX_RCU_AHB_ENDIAN);
-    IFX_PCIE_PRINT(PCIE_MSG_REG, "%s IFX_RCU_AHB_ENDIAN: 0x%08x\n", __func__, IFX_REG_R32(IFX_RCU_AHB_ENDIAN));
-}
-
-static inline void pcie_phy_pmu_enable(int pcie_port)
-{
-    if (pcie_port == 0) { /* XXX, should use macro*/
-        PCIE0_PHY_PMU_SETUP(IFX_PMU_ENABLE);
-    }
-    else {
-        PCIE1_PHY_PMU_SETUP(IFX_PMU_ENABLE);
-    }
-}
-
-static inline void pcie_phy_pmu_disable(int pcie_port)
-{
-    if (pcie_port == 0) { /* XXX, should use macro*/
-        PCIE0_PHY_PMU_SETUP(IFX_PMU_DISABLE);
-    }
-    else {
-        PCIE1_PHY_PMU_SETUP(IFX_PMU_DISABLE);
-    }
-}
-
-static inline void pcie_pdi_big_endian(int pcie_port)
-{
-    u32 reg;
-
-    reg = IFX_REG_R32(IFX_RCU_AHB_ENDIAN);
-    if (pcie_port == 0) {
-        /* Config AHB->PCIe and PDI endianness */
-        reg |= IFX_RCU_BE_PCIE0_PDI;
-    }
-    else {
-        /* Config AHB->PCIe and PDI endianness */
-        reg |= IFX_RCU_BE_PCIE1_PDI;
-    }
-    IFX_REG_W32(reg, IFX_RCU_AHB_ENDIAN);
-}
-
-static inline void pcie_pdi_pmu_enable(int pcie_port)
-{
-    if (pcie_port == 0) {
-        /* Enable PDI to access PCIe PHY register */
-        PDI0_PMU_SETUP(IFX_PMU_ENABLE);
-    }
-    else {
-        PDI1_PMU_SETUP(IFX_PMU_ENABLE);
-    }
-}
-
-static inline void pcie_core_rst_assert(int pcie_port)
-{
-    u32 reg;
-
-    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-
-    /* Reset Core, bit 22 */
-    if (pcie_port == 0) {
-        reg |= 0x00400000;
-    }
-    else {
-        reg |= 0x08000000; /* Bit 27 */
-    }
-    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-}
-
-static inline void pcie_core_rst_deassert(int pcie_port)
-{
-    u32 reg;
-
-    /* Make sure one micro-second delay */
-    udelay(1);
-
-    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-    if (pcie_port == 0) {
-        reg &= ~0x00400000; /* bit 22 */
-    }
-    else {
-        reg &= ~0x08000000; /* Bit 27 */
-    }
-    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-}
-
-static inline void pcie_phy_rst_assert(int pcie_port)
-{
-    u32 reg;
-
-    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-    if (pcie_port == 0) {
-        reg |= 0x00001000; /* Bit 12 */
-    }
-    else {
-        reg |= 0x00002000; /* Bit 13 */
-    }
-    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-}
-
-static inline void pcie_phy_rst_deassert(int pcie_port)
-{
-    u32 reg;
-
-    /* Make sure one micro-second delay */
-    udelay(1);
-
-    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-    if (pcie_port == 0) {
-        reg &= ~0x00001000; /* Bit 12 */
-    }
-    else {
-        reg &= ~0x00002000; /* Bit 13 */
-    }
-    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-}
-
-static inline void pcie_device_rst_assert(int pcie_port)
-{
-    if (pcie_port == 0) {
-        ifx_ebu_led_set_data(11, 0);
-    }
-    else {
-        ifx_ebu_led_set_data(12, 0);
-    }
-}
-
-static inline void pcie_device_rst_deassert(int pcie_port)
-{
-    mdelay(100);
-    if (pcie_port == 0) {
-        ifx_ebu_led_set_data(11, 1);
-    }
-    else {
-        ifx_ebu_led_set_data(12, 1);
-    }
-    ifx_ebu_led_disable();
-}
-
-static inline void pcie_core_pmu_setup(int pcie_port)
-{
-    if (pcie_port == 0) {
-        PCIE0_CTRL_PMU_SETUP(IFX_PMU_ENABLE);
-    }
-    else {
-        PCIE1_CTRL_PMU_SETUP(IFX_PMU_ENABLE); 
-    }
-}
-
-static inline void pcie_msi_init(int pcie_port)
-{
-    pcie_msi_pic_init(pcie_port);
-    if (pcie_port == 0) {
-        MSI0_PMU_SETUP(IFX_PMU_ENABLE);
-    }
-    else {
-        MSI1_PMU_SETUP(IFX_PMU_ENABLE);
-    }
-}
-
-static inline u32
-ifx_pcie_bus_nr_deduct(u32 bus_number, int pcie_port)
-{
-    u32 tbus_number = bus_number;
-
-#ifdef CONFIG_IFX_PCIE_2ND_CORE
-    if (pcie_port == IFX_PCIE_PORT1) { /* Port 1 must check if there are two cores enabled */
-        if (pcibios_host_nr() > 1) {
-            tbus_number -= pcibios_1st_host_bus_nr();
-        }        
-    }
-#endif /* CONFIG_IFX_PCI */
-    return tbus_number;
-}
-
-static inline u32
-ifx_pcie_bus_enum_hack(struct pci_bus *bus, u32 devfn, int where, u32 value, int pcie_port, int read)
-{
-    struct pci_dev *pdev;
-    u32 tvalue = value;
-
-    /* Sanity check */
-    pdev = pci_get_slot(bus, devfn);
-    if (pdev == NULL) {
-        return tvalue;
-    }
-
-    /* Only care about PCI bridge */
-    if (pdev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {
-        return tvalue;
-    }
-
-    if (read) { /* Read hack */
-    #ifdef CONFIG_IFX_PCIE_2ND_CORE
-        if (pcie_port == IFX_PCIE_PORT1) { /* Port 1 must check if there are two cores enabled */
-            if (pcibios_host_nr() > 1) {
-                tvalue = ifx_pcie_bus_enum_read_hack(where, tvalue);
-            }
-        }
-    #endif /* CONFIG_IFX_PCIE_2ND_CORE */
-    }
-    else { /* Write hack */
-    #ifdef CONFIG_IFX_PCIE_2ND_CORE
-        if (pcie_port == IFX_PCIE_PORT1) { /* Port 1 must check if there are two cores enabled */
-            if (pcibios_host_nr() > 1) {
-                tvalue = ifx_pcie_bus_enum_write_hack(where, tvalue);
-            }
-        }
-    #endif
-    }
-    return tvalue;
-}
-
-#endif /* IFXMIPS_PCIE_AR10_H */
diff --git a/arch/mips/pci/ifxmips_pcie_msi.c b/arch/mips/pci/ifxmips_pcie_msi.c
deleted file mode 100644
--- a/arch/mips/pci/ifxmips_pcie_msi.c
+++ /dev/null
@@ -1,392 +0,0 @@
-/******************************************************************************
-**
-** FILE NAME    : ifxmips_pcie_msi.c
-** PROJECT      : IFX UEIP for VRX200
-** MODULES      : PCI MSI sub module
-**
-** DATE         : 02 Mar 2009
-** AUTHOR       : Lei Chuanhua
-** DESCRIPTION  : PCIe MSI Driver
-** COPYRIGHT    :       Copyright (c) 2009
-**                      Infineon Technologies AG
-**                      Am Campeon 1-12, 85579 Neubiberg, Germany
-**
-**    This program is free software; you can redistribute it and/or modify
-**    it under the terms of the GNU General Public License as published by
-**    the Free Software Foundation; either version 2 of the License, or
-**    (at your option) any later version.
-** HISTORY
-** $Date        $Author         $Comment
-** 02 Mar,2009  Lei Chuanhua    Initial version
-*******************************************************************************/
-/*!
- \defgroup IFX_PCIE_MSI MSI OS APIs
- \ingroup IFX_PCIE
- \brief PCIe bus driver OS interface functions
-*/
-
-/*!
- \file ifxmips_pcie_msi.c
- \ingroup IFX_PCIE 
- \brief PCIe MSI OS interface file
-*/
-
-#ifndef AUTOCONF_INCLUDED
-#include <linux/config.h>
-#endif /* AUTOCONF_INCLUDED */
-#include <linux/init.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/kernel_stat.h>
-#include <linux/pci.h>
-#include <linux/msi.h>
-#include <linux/module.h>
-#include <asm/bootinfo.h>
-#include <asm/irq.h>
-#include <asm/traps.h>
-
-#include <asm/ifx/ifx_types.h>
-#include <asm/ifx/ifx_regs.h>
-#include <asm/ifx/common_routines.h>
-#include <asm/ifx/irq.h>
-
-#include "ifxmips_pcie_reg.h"
-#include "ifxmips_pcie.h"
-
-#define IFX_MSI_IRQ_NUM    16
-
-enum {
-    IFX_PCIE_MSI_IDX0 = 0,
-    IFX_PCIE_MSI_IDX1,
-    IFX_PCIE_MSI_IDX2,
-    IFX_PCIE_MSI_IDX3,
-};
-
-typedef struct ifx_msi_irq_idx {
-    const int irq;
-    const int idx;
-}ifx_msi_irq_idx_t;
-
-struct ifx_msi_pic {
-    volatile u32  pic_table[IFX_MSI_IRQ_NUM];
-    volatile u32  pic_endian;    /* 0x40  */
-};
-typedef struct ifx_msi_pic *ifx_msi_pic_t;
-
-typedef struct ifx_msi_irq {
-    const volatile ifx_msi_pic_t msi_pic_p;
-    const u32 msi_phy_base;
-    const ifx_msi_irq_idx_t msi_irq_idx[IFX_MSI_IRQ_NUM];
-    /*
-     * Each bit in msi_free_irq_bitmask represents a MSI interrupt that is 
-     * in use.
-     */
-    u16 msi_free_irq_bitmask;
-
-    /*
-     * Each bit in msi_multiple_irq_bitmask tells that the device using 
-     * this bit in msi_free_irq_bitmask is also using the next bit. This 
-     * is used so we can disable all of the MSI interrupts when a device 
-     * uses multiple.
-     */
-    u16 msi_multiple_irq_bitmask;
-}ifx_msi_irq_t;
-
-static ifx_msi_irq_t msi_irqs[IFX_PCIE_CORE_NR] = {
-    {
-        .msi_pic_p = (const volatile ifx_msi_pic_t)IFX_MSI_PIC_REG_BASE,
-        .msi_phy_base = PCIE_MSI_PHY_BASE,
-        .msi_irq_idx = {
-            {IFX_PCIE_MSI_IR0, IFX_PCIE_MSI_IDX0}, {IFX_PCIE_MSI_IR1, IFX_PCIE_MSI_IDX1},
-            {IFX_PCIE_MSI_IR2, IFX_PCIE_MSI_IDX2}, {IFX_PCIE_MSI_IR3, IFX_PCIE_MSI_IDX3},
-            {IFX_PCIE_MSI_IR0, IFX_PCIE_MSI_IDX0}, {IFX_PCIE_MSI_IR1, IFX_PCIE_MSI_IDX1},
-            {IFX_PCIE_MSI_IR2, IFX_PCIE_MSI_IDX2}, {IFX_PCIE_MSI_IR3, IFX_PCIE_MSI_IDX3},
-            {IFX_PCIE_MSI_IR0, IFX_PCIE_MSI_IDX0}, {IFX_PCIE_MSI_IR1, IFX_PCIE_MSI_IDX1},
-            {IFX_PCIE_MSI_IR2, IFX_PCIE_MSI_IDX2}, {IFX_PCIE_MSI_IR3, IFX_PCIE_MSI_IDX3},
-            {IFX_PCIE_MSI_IR0, IFX_PCIE_MSI_IDX0}, {IFX_PCIE_MSI_IR1, IFX_PCIE_MSI_IDX1},
-            {IFX_PCIE_MSI_IR2, IFX_PCIE_MSI_IDX2}, {IFX_PCIE_MSI_IR3, IFX_PCIE_MSI_IDX3},
-        },
-        .msi_free_irq_bitmask = 0,
-        .msi_multiple_irq_bitmask= 0,
-    },
-#ifdef CONFIG_IFX_PCIE_2ND_CORE
-    {
-        .msi_pic_p = (const volatile ifx_msi_pic_t)IFX_MSI1_PIC_REG_BASE,
-        .msi_phy_base = PCIE1_MSI_PHY_BASE,
-        .msi_irq_idx = {
-            {IFX_PCIE1_MSI_IR0, IFX_PCIE_MSI_IDX0}, {IFX_PCIE1_MSI_IR1, IFX_PCIE_MSI_IDX1},
-            {IFX_PCIE1_MSI_IR2, IFX_PCIE_MSI_IDX2}, {IFX_PCIE1_MSI_IR3, IFX_PCIE_MSI_IDX3},
-            {IFX_PCIE1_MSI_IR0, IFX_PCIE_MSI_IDX0}, {IFX_PCIE1_MSI_IR1, IFX_PCIE_MSI_IDX1},
-            {IFX_PCIE1_MSI_IR2, IFX_PCIE_MSI_IDX2}, {IFX_PCIE1_MSI_IR3, IFX_PCIE_MSI_IDX3},
-            {IFX_PCIE1_MSI_IR0, IFX_PCIE_MSI_IDX0}, {IFX_PCIE1_MSI_IR1, IFX_PCIE_MSI_IDX1},
-            {IFX_PCIE1_MSI_IR2, IFX_PCIE_MSI_IDX2}, {IFX_PCIE1_MSI_IR3, IFX_PCIE_MSI_IDX3},
-            {IFX_PCIE1_MSI_IR0, IFX_PCIE_MSI_IDX0}, {IFX_PCIE1_MSI_IR1, IFX_PCIE_MSI_IDX1},
-            {IFX_PCIE1_MSI_IR2, IFX_PCIE_MSI_IDX2}, {IFX_PCIE1_MSI_IR3, IFX_PCIE_MSI_IDX3},
-        },
-        .msi_free_irq_bitmask = 0,
-        .msi_multiple_irq_bitmask= 0,
-
-    },
-#endif /* CONFIG_IFX_PCIE_2ND_CORE */
-};
-
-/* 
- * This lock controls updates to msi_free_irq_bitmask, 
- * msi_multiple_irq_bitmask and pic register settting
- */ 
-static DEFINE_SPINLOCK(ifx_pcie_msi_lock);
-
-void pcie_msi_pic_init(int pcie_port)
-{
-    spin_lock(&ifx_pcie_msi_lock);
-    msi_irqs[pcie_port].msi_pic_p->pic_endian = IFX_MSI_PIC_BIG_ENDIAN;
-    spin_unlock(&ifx_pcie_msi_lock);
-}
-
-/** 
- * \fn int arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
- * \brief Called when a driver request MSI interrupts instead of the 
- * legacy INT A-D. This routine will allocate multiple interrupts 
- * for MSI devices that support them. A device can override this by 
- * programming the MSI control bits [6:4] before calling 
- * pci_enable_msi(). 
- * 
- * \param[in] pdev   Device requesting MSI interrupts 
- * \param[in] desc   MSI descriptor 
- * 
- * \return   -EINVAL Invalid pcie root port or invalid msi bit
- * \return    0        OK
- * \ingroup IFX_PCIE_MSI
- */
-int 
-arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
-{
-    int  irq, pos;
-    u16  control;
-    int  irq_idx;
-    int  irq_step;
-    int configured_private_bits;
-    int request_private_bits;
-    struct msi_msg msg;
-    u16 search_mask;
-    struct ifx_pci_controller *ctrl = pdev->bus->sysdata;
-    int pcie_port = ctrl->port;
-
-    IFX_PCIE_PRINT(PCIE_MSG_MSI, "%s %s enter\n", __func__, pci_name(pdev));
-
-    /* XXX, skip RC MSI itself */
-    if (pdev->pcie_type == PCI_EXP_TYPE_ROOT_PORT) {
-        IFX_PCIE_PRINT(PCIE_MSG_MSI, "%s RC itself doesn't use MSI interrupt\n", __func__);
-        return -EINVAL;
-    }
-
-    /*
-     * Read the MSI config to figure out how many IRQs this device 
-     * wants.  Most devices only want 1, which will give 
-     * configured_private_bits and request_private_bits equal 0. 
-     */
-    pci_read_config_word(pdev, desc->msi_attrib.pos + PCI_MSI_FLAGS, &control);
-
-    /*
-     * If the number of private bits has been configured then use 
-     * that value instead of the requested number. This gives the 
-     * driver the chance to override the number of interrupts 
-     * before calling pci_enable_msi(). 
-     */
-    configured_private_bits = (control & PCI_MSI_FLAGS_QSIZE) >> 4; 
-    if (configured_private_bits == 0) {
-        /* Nothing is configured, so use the hardware requested size */
-        request_private_bits = (control & PCI_MSI_FLAGS_QMASK) >> 1;
-    }
-    else {
-        /*
-         * Use the number of configured bits, assuming the 
-         * driver wanted to override the hardware request 
-         * value.
-         */
-        request_private_bits = configured_private_bits;
-    }
-
-    /*
-     * The PCI 2.3 spec mandates that there are at most 32
-     * interrupts. If this device asks for more, only give it one.
-     */
-    if (request_private_bits > 5) {
-        request_private_bits = 0;
-    }
-again:
-    /*
-     * The IRQs have to be aligned on a power of two based on the
-     * number being requested.
-     */
-    irq_step = (1 << request_private_bits);
-
-    /* Mask with one bit for each IRQ */
-    search_mask = (1 << irq_step) - 1;
-
-    /*
-     * We're going to search msi_free_irq_bitmask_lock for zero 
-     * bits. This represents an MSI interrupt number that isn't in 
-     * use.
-     */
-    spin_lock(&ifx_pcie_msi_lock);
-    for (pos = 0; pos < IFX_MSI_IRQ_NUM; pos += irq_step) {
-        if ((msi_irqs[pcie_port].msi_free_irq_bitmask & (search_mask << pos)) == 0) {
-            msi_irqs[pcie_port].msi_free_irq_bitmask |= search_mask << pos; 
-            msi_irqs[pcie_port].msi_multiple_irq_bitmask |= (search_mask >> 1) << pos;
-            break; 
-        }
-    }
-    spin_unlock(&ifx_pcie_msi_lock); 
-
-    /* Make sure the search for available interrupts didn't fail */ 
-    if (pos >= IFX_MSI_IRQ_NUM) {
-        if (request_private_bits) {
-            IFX_PCIE_PRINT(PCIE_MSG_MSI, "%s: Unable to find %d free "
-                  "interrupts, trying just one", __func__, 1 << request_private_bits);
-            request_private_bits = 0;
-            goto again;
-        }
-        else {
-            printk(KERN_ERR "%s: Unable to find a free MSI interrupt\n", __func__);
-            return -EINVAL;
-        }
-    } 
-    irq = msi_irqs[pcie_port].msi_irq_idx[pos].irq;
-    irq_idx = msi_irqs[pcie_port].msi_irq_idx[pos].idx;
-
-    IFX_PCIE_PRINT(PCIE_MSG_MSI, "pos %d, irq %d irq_idx %d\n", pos, irq, irq_idx);
-
-    /*
-     * Initialize MSI. This has to match the memory-write endianess from the device 
-     * Address bits [23:12]
-     */
-    spin_lock(&ifx_pcie_msi_lock); 
-    msi_irqs[pcie_port].msi_pic_p->pic_table[pos] = SM(irq_idx, IFX_MSI_PIC_INT_LINE) |
-                    SM((msi_irqs[pcie_port].msi_phy_base >> 12), IFX_MSI_PIC_MSG_ADDR) |
-                    SM((1 << pos), IFX_MSI_PIC_MSG_DATA);
-
-    /* Enable this entry */
-    msi_irqs[pcie_port].msi_pic_p->pic_table[pos] &= ~IFX_MSI_PCI_INT_DISABLE;
-    spin_unlock(&ifx_pcie_msi_lock);
-
-    IFX_PCIE_PRINT(PCIE_MSG_MSI, "pic_table[%d]: 0x%08x\n",
-        pos, msi_irqs[pcie_port].msi_pic_p->pic_table[pos]);
-
-    /* Update the number of IRQs the device has available to it */
-    control &= ~PCI_MSI_FLAGS_QSIZE;
-    control |= (request_private_bits << 4);
-    pci_write_config_word(pdev, desc->msi_attrib.pos + PCI_MSI_FLAGS, control);
-
-    set_irq_msi(irq, desc);
-    msg.address_hi = 0x0;
-    msg.address_lo = msi_irqs[pcie_port].msi_phy_base;
-    msg.data = SM((1 << pos), IFX_MSI_PIC_MSG_DATA);
-    IFX_PCIE_PRINT(PCIE_MSG_MSI, "msi_data: pos %d 0x%08x\n", pos, msg.data);
-
-    write_msi_msg(irq, &msg);
-    IFX_PCIE_PRINT(PCIE_MSG_MSI, "%s exit\n", __func__);
-    return 0;
-}
-
-static int
-pcie_msi_irq_to_port(unsigned int irq, int *port)
-{
-    int ret = 0;
-
-    if (irq == IFX_PCIE_MSI_IR0 || irq == IFX_PCIE_MSI_IR1 ||
-        irq == IFX_PCIE_MSI_IR2 || irq == IFX_PCIE_MSI_IR3) {
-        *port = IFX_PCIE_PORT0;
-    }
-#ifdef CONFIG_IFX_PCIE_2ND_CORE
-    else if (irq == IFX_PCIE1_MSI_IR0 || irq == IFX_PCIE1_MSI_IR1 ||
-        irq == IFX_PCIE1_MSI_IR2 || irq == IFX_PCIE1_MSI_IR3) {
-        *port = IFX_PCIE_PORT1;
-    }
-#endif /* CONFIG_IFX_PCIE_2ND_CORE */
-    else {
-        printk(KERN_ERR "%s: Attempted to teardown illegal " 
-            "MSI interrupt (%d)\n", __func__, irq);
-        ret = -EINVAL;
-    }
-    return ret;
-}
-
-/** 
- * \fn void arch_teardown_msi_irq(unsigned int irq)
- * \brief Called when a device no longer needs its MSI interrupts. All 
- * MSI interrupts for the device are freed. 
- * 
- * \param irq   The devices first irq number. There may be multple in sequence.
- * \return none
- * \ingroup IFX_PCIE_MSI
- */
-void 
-arch_teardown_msi_irq(unsigned int irq)
-{
-    int pos;
-    int number_irqs; 
-    u16 bitmask;
-    int pcie_port;
-
-    IFX_PCIE_PRINT(PCIE_MSG_MSI, "%s enter\n", __func__);
-
-    BUG_ON(irq > INT_NUM_IM4_IRL31);
-
-    if (pcie_msi_irq_to_port(irq, &pcie_port) != 0) {
-        return;
-    }
-
-    /* Shift the mask to the correct bit location, not always correct 
-     * Probally, the first match will be chosen.
-     */
-    for (pos = 0; pos < IFX_MSI_IRQ_NUM; pos++) {
-        if ((msi_irqs[pcie_port].msi_irq_idx[pos].irq == irq) 
-            && (msi_irqs[pcie_port].msi_free_irq_bitmask & ( 1 << pos))) {
-            break;
-        }
-    }
-    if (pos >= IFX_MSI_IRQ_NUM) {
-        printk(KERN_ERR "%s: Unable to find a matched MSI interrupt\n", __func__);
-        return;
-    }
-    spin_lock(&ifx_pcie_msi_lock);
-    /* Disable this entry */
-    msi_irqs[pcie_port].msi_pic_p->pic_table[pos] |= IFX_MSI_PCI_INT_DISABLE;
-    msi_irqs[pcie_port].msi_pic_p->pic_table[pos] &= ~(IFX_MSI_PIC_INT_LINE | IFX_MSI_PIC_MSG_ADDR | IFX_MSI_PIC_MSG_DATA);
-    spin_unlock(&ifx_pcie_msi_lock); 
-    /*
-     * Count the number of IRQs we need to free by looking at the
-     * msi_multiple_irq_bitmask. Each bit set means that the next
-     * IRQ is also owned by this device.
-     */ 
-    number_irqs = 0; 
-    while (((pos + number_irqs) < IFX_MSI_IRQ_NUM) && 
-        (msi_irqs[pcie_port].msi_multiple_irq_bitmask & (1 << (pos + number_irqs)))) {
-        number_irqs++;
-    }
-    number_irqs++;
-
-    /* Mask with one bit for each IRQ */
-    bitmask = (1 << number_irqs) - 1;
-
-    bitmask <<= pos;
-    if ((msi_irqs[pcie_port].msi_free_irq_bitmask & bitmask) != bitmask) {
-        printk(KERN_ERR "%s: Attempted to teardown MSI "
-             "interrupt (%d) not in use\n", __func__, irq);
-        return;
-    }
-    /* Checks are done, update the in use bitmask */
-    spin_lock(&ifx_pcie_msi_lock);
-    msi_irqs[pcie_port].msi_free_irq_bitmask &= ~bitmask;
-    msi_irqs[pcie_port].msi_multiple_irq_bitmask &= ~(bitmask >> 1);
-    spin_unlock(&ifx_pcie_msi_lock);
-    IFX_PCIE_PRINT(PCIE_MSG_MSI, "%s exit\n", __func__);
-}
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Chuanhua.Lei@infineon.com");
-MODULE_SUPPORTED_DEVICE("Infineon PCIe IP builtin MSI PIC module");
-MODULE_DESCRIPTION("Infineon PCIe IP builtin MSI PIC driver");
-
diff --git a/arch/mips/pci/ifxmips_pcie_phy.c b/arch/mips/pci/ifxmips_pcie_phy.c
deleted file mode 100644
--- a/arch/mips/pci/ifxmips_pcie_phy.c
+++ /dev/null
@@ -1,478 +0,0 @@
-/******************************************************************************
-**
-** FILE NAME    : ifxmips_pcie_phy.c
-** PROJECT      : IFX UEIP for VRX200
-** MODULES      : PCIe PHY sub module
-**
-** DATE         : 14 May 2009
-** AUTHOR       : Lei Chuanhua
-** DESCRIPTION  : PCIe Root Complex Driver
-** COPYRIGHT    :       Copyright (c) 2009
-**                      Infineon Technologies AG
-**                      Am Campeon 1-12, 85579 Neubiberg, Germany
-**
-**    This program is free software; you can redistribute it and/or modify
-**    it under the terms of the GNU General Public License as published by
-**    the Free Software Foundation; either version 2 of the License, or
-**    (at your option) any later version.
-** HISTORY
-** $Version $Date        $Author         $Comment
-** 0.0.1    14 May,2009  Lei Chuanhua    Initial version
-*******************************************************************************/
-/*!
- \file ifxmips_pcie_phy.c
- \ingroup IFX_PCIE  
- \brief PCIe PHY PLL register programming source file
-*/
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <asm/paccess.h>
-#include <linux/delay.h>
-
-#include "ifxmips_pcie_reg.h"
-#include "ifxmips_pcie.h"
-
-/* PCIe PDI only supports 16 bit operation */
-
-#define IFX_PCIE_PHY_REG_WRITE16(__addr, __data) \
-    ((*(volatile u16 *) (__addr)) = (__data))
-    
-#define IFX_PCIE_PHY_REG_READ16(__addr)  \
-    (*(volatile u16 *) (__addr))
-
-#define IFX_PCIE_PHY_REG16(__addr)   \
-    (*(volatile u16 *) (__addr))
-
-#define IFX_PCIE_PHY_REG(__reg, __value, __mask) do { \
-    u16 read_data;                                    \
-    u16 write_data;                                   \
-    read_data = IFX_PCIE_PHY_REG_READ16((__reg));      \
-    write_data = (read_data & ((u16)~(__mask))) | (((u16)(__value)) & ((u16)(__mask)));\
-    IFX_PCIE_PHY_REG_WRITE16((__reg), write_data);               \
-} while (0)
-
-#define IFX_PCIE_PLL_TIMEOUT 1000 /* Tunnable */
-
-//#define IFX_PCI_PHY_REG_DUMP
-
-#ifdef IFX_PCI_PHY_REG_DUMP
-static void
-pcie_phy_reg_dump(int pcie_port) 
-{
-    printk("PLL REGFILE\n");
-    printk("PCIE_PHY_PLL_CTRL1    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_CTRL1(pcie_port)));
-    printk("PCIE_PHY_PLL_CTRL2    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_CTRL2(pcie_port)));
-    printk("PCIE_PHY_PLL_CTRL3    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_CTRL3(pcie_port)));
-    printk("PCIE_PHY_PLL_CTRL4    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_CTRL4(pcie_port)));
-    printk("PCIE_PHY_PLL_CTRL5    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_CTRL5(pcie_port)));
-    printk("PCIE_PHY_PLL_CTRL6    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_CTRL6(pcie_port)));
-    printk("PCIE_PHY_PLL_CTRL7    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_CTRL7(pcie_port)));
-    printk("PCIE_PHY_PLL_A_CTRL1  0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_A_CTRL1(pcie_port)));
-    printk("PCIE_PHY_PLL_A_CTRL2  0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_A_CTRL2(pcie_port)));
-    printk("PCIE_PHY_PLL_A_CTRL3  0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_A_CTRL3(pcie_port)));
-    printk("PCIE_PHY_PLL_STATUS   0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_STATUS(pcie_port)));
-
-    printk("TX1 REGFILE\n");
-    printk("PCIE_PHY_TX1_CTRL1    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX1_CTRL1(pcie_port)));
-    printk("PCIE_PHY_TX1_CTRL2    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX1_CTRL2(pcie_port)));
-    printk("PCIE_PHY_TX1_CTRL3    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX1_CTRL3(pcie_port)));
-    printk("PCIE_PHY_TX1_A_CTRL1  0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX1_A_CTRL1(pcie_port)));
-    printk("PCIE_PHY_TX1_A_CTRL2  0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX1_A_CTRL2(pcie_port)));
-    printk("PCIE_PHY_TX1_MOD1     0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX1_MOD1(pcie_port)));
-    printk("PCIE_PHY_TX1_MOD2     0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX1_MOD2(pcie_port)));
-    printk("PCIE_PHY_TX1_MOD3     0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX1_MOD3(pcie_port)));
-
-    printk("TX2 REGFILE\n");
-    printk("PCIE_PHY_TX2_CTRL1    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX2_CTRL1(pcie_port)));
-    printk("PCIE_PHY_TX2_CTRL2    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX2_CTRL2(pcie_port)));
-    printk("PCIE_PHY_TX2_A_CTRL1  0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX2_A_CTRL1(pcie_port)));
-    printk("PCIE_PHY_TX2_A_CTRL2  0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX2_A_CTRL2(pcie_port)));
-    printk("PCIE_PHY_TX2_MOD1     0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX2_MOD1(pcie_port)));
-    printk("PCIE_PHY_TX2_MOD2     0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX2_MOD2(pcie_port)));
-    printk("PCIE_PHY_TX2_MOD3     0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX2_MOD3(pcie_port)));
-
-    printk("RX1 REGFILE\n");
-    printk("PCIE_PHY_RX1_CTRL1    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_RX1_CTRL1(pcie_port)));
-    printk("PCIE_PHY_RX1_CTRL2    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_RX1_CTRL2(pcie_port)));
-    printk("PCIE_PHY_RX1_CDR      0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_RX1_CDR(pcie_port)));
-    printk("PCIE_PHY_RX1_EI       0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_RX1_EI(pcie_port)));
-    printk("PCIE_PHY_RX1_A_CTRL   0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_RX1_A_CTRL(pcie_port)));
-}
-#endif /* IFX_PCI_PHY_REG_DUMP */
-
-static void
-pcie_phy_comm_setup(int pcie_port)
-{
-   /* PLL Setting */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL1(pcie_port), 0x120e, 0xFFFF);
-
-    /* increase the bias reference voltage */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL2(pcie_port), 0x39D7, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL3(pcie_port), 0x0900, 0xFFFF);
-
-    /* Endcnt */
-    IFX_PCIE_PHY_REG(PCIE_PHY_RX1_EI(pcie_port), 0x0004, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_RX1_A_CTRL(pcie_port), 0x6803, 0xFFFF);
-
-    /* force */
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_CTRL1(pcie_port), 0x0008, 0x0008);
-
-    /* predrv_ser_en */
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_A_CTRL2(pcie_port), 0x0706, 0xFFFF);
-
-    /* ctrl_lim */
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_CTRL3(pcie_port), 0x1FFF, 0xFFFF);
-
-    /* ctrl */
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_A_CTRL1(pcie_port), 0x0800, 0xFF00);
-
-    /* predrv_ser_en */
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_A_CTRL2(pcie_port), 0x4702, 0x7F00);
-
-    /* RTERM*/
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_CTRL2(pcie_port), 0x2e00, 0xFFFF);
-
-    /* Improved 100MHz clock output  */
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_CTRL2(pcie_port), 0x3096, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_A_CTRL2(pcie_port), 0x4707, 0xFFFF);
-
-    /* Reduced CDR BW to avoid glitches */
-    IFX_PCIE_PHY_REG(PCIE_PHY_RX1_CDR(pcie_port), 0x0235, 0xFFFF);
-}
-
-#ifdef CONFIG_IFX_PCIE_PHY_36MHZ_MODE
-static void 
-pcie_phy_36mhz_mode_setup(int pcie_port) 
-{
-    IFX_PCIE_PRINT(PCIE_MSG_PHY, "%s pcie_port %d enter\n", __func__, pcie_port);
-#ifdef IFX_PCI_PHY_REG_DUMP
-    IFX_PCIE_PRINT(PCIE_MSG_PHY, "Initial PHY register dump\n");
-    pcie_phy_reg_dump(pcie_port);
-#endif
-
-    /* en_ext_mmd_div_ratio */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL3(pcie_port), 0x0000, 0x0002);
-
-    /* ext_mmd_div_ratio*/
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL3(pcie_port), 0x0000, 0x0070);
-
-    /* pll_ensdm */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0200, 0x0200);
-
-    /* en_const_sdm */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0100, 0x0100);
-
-    /* mmd */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL3(pcie_port), 0x2000, 0xe000);
-
-    /* lf_mode */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL2(pcie_port), 0x0000, 0x4000);
-
-    /* const_sdm */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL1(pcie_port), 0x38e4, 0xFFFF);
-
-    /* const sdm */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x00ee, 0x00FF);
-
-    /* pllmod */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL7(pcie_port), 0x0002, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL6(pcie_port), 0x3a04, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL5(pcie_port), 0xfae3, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL4(pcie_port), 0x1b72, 0xFFFF);
-
-    IFX_PCIE_PRINT(PCIE_MSG_PHY, "%s pcie_port %d exit\n", __func__, pcie_port);
-}
-#endif /* CONFIG_IFX_PCIE_PHY_36MHZ_MODE */
-
-#ifdef CONFIG_IFX_PCIE_PHY_36MHZ_SSC_MODE
-static void 
-pcie_phy_36mhz_ssc_mode_setup(int pcie_port) 
-{
-    IFX_PCIE_PRINT(PCIE_MSG_PHY, "%s pcie_port %d enter\n", __func__, pcie_port);
-#ifdef IFX_PCI_PHY_REG_DUMP
-    IFX_PCIE_PRINT(PCIE_MSG_PHY, "Initial PHY register dump\n");
-    pcie_phy_reg_dump(pcie_port);
-#endif
-
-    /* PLL Setting */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL1(pcie_port), 0x120e, 0xFFFF);
-
-    /* Increase the bias reference voltage */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL2(pcie_port), 0x39D7, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL3(pcie_port), 0x0900, 0xFFFF);
-
-    /* Endcnt */
-    IFX_PCIE_PHY_REG(PCIE_PHY_RX1_EI(pcie_port), 0x0004, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_RX1_A_CTRL(pcie_port), 0x6803, 0xFFFF);
-
-    /* Force */
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_CTRL1(pcie_port), 0x0008, 0x0008);
-
-    /* Predrv_ser_en */
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_A_CTRL2(pcie_port), 0x0706, 0xFFFF);
-
-    /* ctrl_lim */
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_CTRL3(pcie_port), 0x1FFF, 0xFFFF);
-
-    /* ctrl */
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_A_CTRL1(pcie_port), 0x0800, 0xFF00);
-
-    /* predrv_ser_en */
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_A_CTRL2(pcie_port), 0x4702, 0x7F00);
-
-    /* RTERM*/
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_CTRL2(pcie_port), 0x2e00, 0xFFFF);
-
-    /* en_ext_mmd_div_ratio */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL3(pcie_port), 0x0000, 0x0002);
-
-    /* ext_mmd_div_ratio*/
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL3(pcie_port), 0x0000, 0x0070);
-
-    /* pll_ensdm */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0400, 0x0400);
-
-    /* en_const_sdm */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0200, 0x0200);
-
-    /* mmd */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL3(pcie_port), 0x2000, 0xe000);
-
-    /* lf_mode */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL2(pcie_port), 0x0000, 0x4000);
-
-    /* const_sdm */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL1(pcie_port), 0x38e4, 0xFFFF);
-
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0000, 0x0100);
-    /* const sdm */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x00ee, 0x00FF);
-
-    /* pllmod */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL7(pcie_port), 0x0002, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL6(pcie_port), 0x3a04, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL5(pcie_port), 0xfae3, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL4(pcie_port), 0x1c72, 0xFFFF);
-
-    /* improved 100MHz clock output  */
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_CTRL2(pcie_port), 0x3096, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_A_CTRL2(pcie_port), 0x4707, 0xFFFF);
-
-    /* reduced CDR BW to avoid glitches */
-    IFX_PCIE_PHY_REG(PCIE_PHY_RX1_CDR(pcie_port), 0x0235, 0xFFFF);
-    
-    IFX_PCIE_PRINT(PCIE_MSG_PHY, "%s pcie_port %d exit\n", __func__, pcie_port);
-}
-#endif /* CONFIG_IFX_PCIE_PHY_36MHZ_SSC_MODE */
-
-#ifdef CONFIG_IFX_PCIE_PHY_25MHZ_MODE
-static void 
-pcie_phy_25mhz_mode_setup(int pcie_port) 
-{
-    IFX_PCIE_PRINT(PCIE_MSG_PHY, "%s pcie_port %d enter\n", __func__, pcie_port);
-#ifdef IFX_PCI_PHY_REG_DUMP
-    IFX_PCIE_PRINT(PCIE_MSG_PHY, "Initial PHY register dump\n");
-    pcie_phy_reg_dump(pcie_port);
-#endif
-    /* en_const_sdm */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0100, 0x0100);
-
-    /* pll_ensdm */    
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0000, 0x0200);
-
-    /* en_ext_mmd_div_ratio*/
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL3(pcie_port), 0x0002, 0x0002);
-
-    /* ext_mmd_div_ratio*/
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL3(pcie_port), 0x0040, 0x0070);
-
-    /* mmd */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL3(pcie_port), 0x6000, 0xe000);
-
-    /* lf_mode */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL2(pcie_port), 0x4000, 0x4000);
-
-    IFX_PCIE_PRINT(PCIE_MSG_PHY, "%s pcie_port %d exit\n", __func__, pcie_port);
-}
-#endif /* CONFIG_IFX_PCIE_PHY_25MHZ_MODE */
-
-#ifdef CONFIG_IFX_PCIE_PHY_100MHZ_MODE
-static void 
-pcie_phy_100mhz_mode_setup(int pcie_port) 
-{
-    IFX_PCIE_PRINT(PCIE_MSG_PHY, "%s pcie_port %d enter\n", __func__, pcie_port);
-#ifdef IFX_PCI_PHY_REG_DUMP
-    IFX_PCIE_PRINT(PCIE_MSG_PHY, "Initial PHY register dump\n");
-    pcie_phy_reg_dump(pcie_port);
-#endif 
-    /* en_ext_mmd_div_ratio */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL3(pcie_port), 0x0000, 0x0002);
-
-    /* ext_mmd_div_ratio*/
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL3(pcie_port), 0x0000, 0x0070);
-
-    /* pll_ensdm */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0200, 0x0200);
-
-    /* en_const_sdm */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0100, 0x0100);
-
-    /* mmd */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL3(pcie_port), 0x2000, 0xe000);
-
-    /* lf_mode */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL2(pcie_port), 0x0000, 0x4000);
-
-    /* const_sdm */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL1(pcie_port), 0x38e4, 0xFFFF);
-
-    /* const sdm */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x00ee, 0x00FF);
-
-    /* pllmod */
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL7(pcie_port), 0x0002, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL6(pcie_port), 0x3a04, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL5(pcie_port), 0xfae3, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL4(pcie_port), 0x1b72, 0xFFFF);
-
-    IFX_PCIE_PRINT(PCIE_MSG_PHY, "%s pcie_port %d exit\n", __func__, pcie_port);
-}
-#endif /* CONFIG_IFX_PCIE_PHY_100MHZ_MODE */
-
-static int
-pcie_phy_wait_startup_ready(int pcie_port)
-{
-    int i;
-
-    for (i = 0; i < IFX_PCIE_PLL_TIMEOUT; i++) {
-        if ((IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_STATUS(pcie_port)) & 0x0040) != 0) {
-            break;
-        }
-        udelay(10);
-    }
-    if (i >= IFX_PCIE_PLL_TIMEOUT) {
-        printk(KERN_ERR "%s PLL Link timeout\n", __func__);
-        return -1;
-    }
-    return 0;
-}
-
-static void 
-pcie_phy_load_enable(int pcie_port, int slice) 
-{
-    /* Set the load_en of tx/rx slice to '1' */
-    switch (slice) {
-        case 1:
-            IFX_PCIE_PHY_REG(PCIE_PHY_TX1_CTRL1(pcie_port), 0x0010, 0x0010);
-            break;
-        case 2:
-            IFX_PCIE_PHY_REG(PCIE_PHY_TX2_CTRL1(pcie_port), 0x0010, 0x0010);
-            break;
-        case 3:
-            IFX_PCIE_PHY_REG(PCIE_PHY_RX1_CTRL1(pcie_port), 0x0002, 0x0002);
-            break;
-    }
-}
-
-static void 
-pcie_phy_load_disable(int pcie_port, int slice) 
-{ 
-    /* set the load_en of tx/rx slice to '0' */ 
-    switch (slice) {
-        case 1:
-            IFX_PCIE_PHY_REG(PCIE_PHY_TX1_CTRL1(pcie_port), 0x0000, 0x0010);
-            break;
-        case 2:
-            IFX_PCIE_PHY_REG(PCIE_PHY_TX2_CTRL1(pcie_port), 0x0000, 0x0010);
-            break;
-        case 3: 
-            IFX_PCIE_PHY_REG(PCIE_PHY_RX1_CTRL1(pcie_port), 0x0000, 0x0002);
-            break;
-    }
-}
-
-static void 
-pcie_phy_load_war(int pcie_port)
-{
-    int slice;
-
-    for (slice = 1; slice < 4; slice++) {
-        pcie_phy_load_enable(pcie_port, slice);
-        udelay(1);
-        pcie_phy_load_disable(pcie_port, slice);
-    }
-}
-
-static void 
-pcie_phy_tx2_modulation(int pcie_port)
-{
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_MOD1(pcie_port), 0x1FFE, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_MOD2(pcie_port), 0xFFFE, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_MOD3(pcie_port), 0x0601, 0xFFFF);
-    mdelay(1);
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_MOD3(pcie_port), 0x0001, 0xFFFF);
-}
-
-static void 
-pcie_phy_tx1_modulation(int pcie_port)
-{
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_MOD1(pcie_port), 0x1FFE, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_MOD2(pcie_port), 0xFFFE, 0xFFFF);
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_MOD3(pcie_port), 0x0601, 0xFFFF);
-    mdelay(1);
-    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_MOD3(pcie_port), 0x0001, 0xFFFF);
-}
-
-static void
-pcie_phy_tx_modulation_war(int pcie_port)
-{
-    int i;
-
-#define PCIE_PHY_MODULATION_NUM 5 
-    for (i = 0; i < PCIE_PHY_MODULATION_NUM; i++) {
-        pcie_phy_tx2_modulation(pcie_port);
-        pcie_phy_tx1_modulation(pcie_port);
-    }
-#undef PCIE_PHY_MODULATION_NUM
-}
-
-void
-pcie_phy_clock_mode_setup(int pcie_port)
-{
-    pcie_pdi_big_endian(pcie_port);
-
-    /* Enable PDI to access PCIe PHY register */
-    pcie_pdi_pmu_enable(pcie_port);
-
-    /* Configure PLL and PHY clock */
-    pcie_phy_comm_setup(pcie_port);
-
-#ifdef CONFIG_IFX_PCIE_PHY_36MHZ_MODE
-    pcie_phy_36mhz_mode_setup(pcie_port);
-#elif defined(CONFIG_IFX_PCIE_PHY_36MHZ_SSC_MODE)
-    pcie_phy_36mhz_ssc_mode_setup(pcie_port);
-#elif defined(CONFIG_IFX_PCIE_PHY_25MHZ_MODE)
-    pcie_phy_25mhz_mode_setup(pcie_port);
-#elif defined (CONFIG_IFX_PCIE_PHY_100MHZ_MODE)
-    pcie_phy_100mhz_mode_setup(pcie_port);
-#else
-    #error "PCIE PHY Clock Mode must be chosen first!!!!"
-#endif /* CONFIG_IFX_PCIE_PHY_36MHZ_MODE */
-
-    /* Enable PCIe PHY and make PLL setting take effect */
-    pcie_phy_pmu_enable(pcie_port);
-
-    /* Check if we are in startup_ready status */
-    pcie_phy_wait_startup_ready(pcie_port);
-
-    pcie_phy_load_war(pcie_port);
-
-    /* Apply TX modulation workarounds */
-    pcie_phy_tx_modulation_war(pcie_port);
-
-#ifdef IFX_PCI_PHY_REG_DUMP
-    IFX_PCIE_PRINT(PCIE_MSG_PHY, "Modified PHY register dump\n");
-    pcie_phy_reg_dump(pcie_port);
-#endif
-}
-
diff --git a/arch/mips/pci/ifxmips_pcie_pm.c b/arch/mips/pci/ifxmips_pcie_pm.c
deleted file mode 100644
--- a/arch/mips/pci/ifxmips_pcie_pm.c
+++ /dev/null
@@ -1,176 +0,0 @@
-/******************************************************************************
-**
-** FILE NAME    : ifxmips_pcie_pm.c
-** PROJECT      : IFX UEIP
-** MODULES      : PCIE Root Complex Driver
-**
-** DATE         : 21 Dec 2009
-** AUTHOR       : Lei Chuanhua
-** DESCRIPTION  : PCIE Root Complex Driver Power Managment
-** COPYRIGHT    :       Copyright (c) 2009
-**                      Lantiq Deutschland GmbH
-**                      Am Campeon 3, 85579 Neubiberg, Germany
-**
-**    This program is free software; you can redistribute it and/or modify
-**    it under the terms of the GNU General Public License as published by
-**    the Free Software Foundation; either version 2 of the License, or
-**    (at your option) any later version.
-**
-** HISTORY
-** $Date        $Author         $Comment
-** 21 Dec,2009   Lei Chuanhua    First UEIP release
-*******************************************************************************/
-/*!
-  \defgroup IFX_PCIE_PM Power Management functions
-  \ingroup IFX_PCIE
-  \brief IFX PCIE Root Complex Driver power management functions
-*/
-
-/*!
- \file ifxmips_pcie_pm.c
- \ingroup IFX_PCIE    
- \brief source file for PCIE Root Complex Driver Power Management
-*/
-
-#ifndef EXPORT_SYMTAB
-#define EXPORT_SYMTAB
-#endif
-#ifndef AUTOCONF_INCLUDED
-#include <linux/config.h>
-#endif /* AUTOCONF_INCLUDED */
-#include <linux/version.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <asm/system.h>
-
-/* Project header */
-#include <asm/ifx/ifx_types.h>
-#include <asm/ifx/ifx_regs.h>
-#include <asm/ifx/common_routines.h>
-#include <asm/ifx/ifx_pmcu.h>
-#include "ifxmips_pcie_pm.h"
-
-/** 
- * \fn static IFX_PMCU_RETURN_t ifx_pcie_pmcu_state_change(IFX_PMCU_STATE_t pmcuState)
- * \brief the callback function to request pmcu state in the power management hardware-dependent module
- *
- * \param pmcuState This parameter is a PMCU state.
- *
- * \return IFX_PMCU_RETURN_SUCCESS Set Power State successfully
- * \return IFX_PMCU_RETURN_ERROR   Failed to set power state.
- * \return IFX_PMCU_RETURN_DENIED  Not allowed to operate power state
- * \ingroup IFX_PCIE_PM
- */
-static IFX_PMCU_RETURN_t 
-ifx_pcie_pmcu_state_change(IFX_PMCU_STATE_t pmcuState)
-{
-    switch(pmcuState) 
-    {
-        case IFX_PMCU_STATE_D0:
-            return IFX_PMCU_RETURN_SUCCESS;
-        case IFX_PMCU_STATE_D1: // Not Applicable
-            return IFX_PMCU_RETURN_DENIED;
-        case IFX_PMCU_STATE_D2: // Not Applicable
-            return IFX_PMCU_RETURN_DENIED;
-        case IFX_PMCU_STATE_D3: // Module clock gating and Power gating
-            return IFX_PMCU_RETURN_SUCCESS;
-        default:
-            return IFX_PMCU_RETURN_DENIED;
-    }
-}
-
-/** 
- * \fn static IFX_PMCU_RETURN_t ifx_pcie_pmcu_state_get(IFX_PMCU_STATE_t *pmcuState)
- * \brief the callback function to get pmcu state in the power management hardware-dependent module
-
- * \param pmcuState Pointer to return power state.
- *
- * \return IFX_PMCU_RETURN_SUCCESS Set Power State successfully
- * \return IFX_PMCU_RETURN_ERROR   Failed to set power state.
- * \return IFX_PMCU_RETURN_DENIED  Not allowed to operate power state
- * \ingroup IFX_PCIE_PM
- */
-static IFX_PMCU_RETURN_t 
-ifx_pcie_pmcu_state_get(IFX_PMCU_STATE_t *pmcuState)
-{
-    return IFX_PMCU_RETURN_SUCCESS;
-}
-
-/**
- * \fn IFX_PMCU_RETURN_t ifx_pcie_pmcu_prechange(IFX_PMCU_MODULE_t pmcuModule, IFX_PMCU_STATE_t newState, IFX_PMCU_STATE_t oldState)
- * \brief Apply all callbacks registered to be executed before a state change for pmcuModule
- * 
- * \param   pmcuModule      Module
- * \param   newState        New state
- * \param   oldState        Old state
- * \return  IFX_PMCU_RETURN_SUCCESS Set Power State successfully
- * \return  IFX_PMCU_RETURN_ERROR   Failed to set power state.
- * \ingroup IFX_PCIE_PM
- */
-static IFX_PMCU_RETURN_t 
-ifx_pcie_pmcu_prechange(IFX_PMCU_MODULE_t pmcuModule, IFX_PMCU_STATE_t newState, IFX_PMCU_STATE_t oldState)
-{
-    return IFX_PMCU_RETURN_SUCCESS;
-}
-
-/**
- * \fn IFX_PMCU_RETURN_t ifx_pcie_pmcu_postchange(IFX_PMCU_MODULE_t pmcuModule, IFX_PMCU_STATE_t newState, IFX_PMCU_STATE_t oldState)
- * \brief Apply all callbacks registered to be executed before a state change for pmcuModule
- * 
- * \param   pmcuModule      Module
- * \param   newState        New state
- * \param   oldState        Old state
- * \return IFX_PMCU_RETURN_SUCCESS Set Power State successfully
- * \return IFX_PMCU_RETURN_ERROR   Failed to set power state.
- * \ingroup IFX_PCIE_PM
- */
-static IFX_PMCU_RETURN_t 
-ifx_pcie_pmcu_postchange(IFX_PMCU_MODULE_t pmcuModule, IFX_PMCU_STATE_t newState, IFX_PMCU_STATE_t oldState)
-{
-    return IFX_PMCU_RETURN_SUCCESS;
-}
-
-/** 
- * \fn static void ifx_pcie_pmcu_init(void)
- * \brief Register with central PMCU module
- * \return none
- * \ingroup IFX_PCIE_PM
- */
-void
-ifx_pcie_pmcu_init(void)
-{
-    IFX_PMCU_REGISTER_t pmcuRegister;
-
-    /* XXX, hook driver context */
-
-    /* State function register */
-    memset(&pmcuRegister, 0, sizeof(IFX_PMCU_REGISTER_t));
-    pmcuRegister.pmcuModule = IFX_PMCU_MODULE_PCIE;
-    pmcuRegister.pmcuModuleNr = 0;
-    pmcuRegister.ifx_pmcu_state_change = ifx_pcie_pmcu_state_change;
-    pmcuRegister.ifx_pmcu_state_get = ifx_pcie_pmcu_state_get;
-    pmcuRegister.pre = ifx_pcie_pmcu_prechange;
-    pmcuRegister.post= ifx_pcie_pmcu_postchange;
-    ifx_pmcu_register(&pmcuRegister); 
-}
-
-/** 
- * \fn static void ifx_pcie_pmcu_exit(void)
- * \brief Unregister with central PMCU module
- *
- * \return none
- * \ingroup IFX_PCIE_PM
- */
-void
-ifx_pcie_pmcu_exit(void)
-{
-    IFX_PMCU_REGISTER_t pmcuUnRegister;
-
-   /* XXX, hook driver context */
-   
-    pmcuUnRegister.pmcuModule = IFX_PMCU_MODULE_PCIE;
-    pmcuUnRegister.pmcuModuleNr = 0;
-    ifx_pmcu_unregister(&pmcuUnRegister);
-}
-
diff --git a/arch/mips/pci/ifxmips_pcie_pm.h b/arch/mips/pci/ifxmips_pcie_pm.h
deleted file mode 100644
--- a/arch/mips/pci/ifxmips_pcie_pm.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/******************************************************************************
-**
-** FILE NAME    : ifxmips_pcie_pm.h
-** PROJECT      : IFX UEIP
-** MODULES      : PCIe Root Complex Driver
-**
-** DATE         : 21 Dec 2009
-** AUTHOR       : Lei Chuanhua
-** DESCRIPTION  : PCIe Root Complex Driver Power Managment
-** COPYRIGHT    :       Copyright (c) 2009
-**                      Lantiq Deutschland GmbH
-**                      Am Campeon 3, 85579 Neubiberg, Germany
-**
-**    This program is free software; you can redistribute it and/or modify
-**    it under the terms of the GNU General Public License as published by
-**    the Free Software Foundation; either version 2 of the License, or
-**    (at your option) any later version.
-**
-** HISTORY
-** $Date        $Author         $Comment
-** 21 Dec,2009   Lei Chuanhua    First UEIP release
-*******************************************************************************/
-/*!
- \file ifxmips_pcie_pm.h
- \ingroup IFX_PCIE 
- \brief header file for PCIe Root Complex Driver Power Management
-*/
-
-#ifndef IFXMIPS_PCIE_PM_H
-#define IFXMIPS_PCIE_PM_H
-
-void ifx_pcie_pmcu_init(void);
-void ifx_pcie_pmcu_exit(void);
-
-#endif /* IFXMIPS_PCIE_PM_H  */
-
diff --git a/arch/mips/pci/ifxmips_pcie_reg.h b/arch/mips/pci/ifxmips_pcie_reg.h
deleted file mode 100644
--- a/arch/mips/pci/ifxmips_pcie_reg.h
+++ /dev/null
@@ -1,1001 +0,0 @@
-/******************************************************************************
-**
-** FILE NAME    : ifxmips_pcie_reg.h
-** PROJECT      : IFX UEIP for VRX200
-** MODULES      : PCIe module
-**
-** DATE         : 02 Mar 2009
-** AUTHOR       : Lei Chuanhua
-** DESCRIPTION  : PCIe Root Complex Driver
-** COPYRIGHT    :       Copyright (c) 2009
-**                      Infineon Technologies AG
-**                      Am Campeon 1-12, 85579 Neubiberg, Germany
-**
-**    This program is free software; you can redistribute it and/or modify
-**    it under the terms of the GNU General Public License as published by
-**    the Free Software Foundation; either version 2 of the License, or
-**    (at your option) any later version.
-** HISTORY
-** $Version $Date        $Author         $Comment
-** 0.0.1    17 Mar,2009  Lei Chuanhua    Initial version
-*******************************************************************************/
-#ifndef IFXMIPS_PCIE_REG_H
-#define IFXMIPS_PCIE_REG_H
-/*!
- \file ifxmips_pcie_reg.h
- \ingroup IFX_PCIE  
- \brief header file for PCIe module register definition
-*/
-/* PCIe Address Mapping Base */
-#define PCIE_CFG_PHY_BASE        0x1D000000UL
-#define PCIE_CFG_BASE           (KSEG1 + PCIE_CFG_PHY_BASE)
-#define PCIE_CFG_SIZE           (8 * 1024 * 1024)
-
-#define PCIE_MEM_PHY_BASE        0x1C000000UL
-#define PCIE_MEM_BASE           (KSEG1 + PCIE_MEM_PHY_BASE)
-#define PCIE_MEM_SIZE           (16 * 1024 * 1024)
-#define PCIE_MEM_PHY_END        (PCIE_MEM_PHY_BASE + PCIE_MEM_SIZE - 1)
-
-#define PCIE_IO_PHY_BASE         0x1D800000UL
-#define PCIE_IO_BASE            (KSEG1 + PCIE_IO_PHY_BASE)
-#define PCIE_IO_SIZE            (1 * 1024 * 1024)
-#define PCIE_IO_PHY_END         (PCIE_IO_PHY_BASE + PCIE_IO_SIZE - 1)
-
-#define PCIE_RC_CFG_BASE        (KSEG1 + 0x1D900000)
-#define PCIE_APP_LOGIC_REG      (KSEG1 + 0x1E100900)
-#define PCIE_MSI_PHY_BASE        0x1F600000UL
-
-#define PCIE_PDI_PHY_BASE        0x1F106800UL
-#define PCIE_PDI_BASE           (KSEG1 + PCIE_PDI_PHY_BASE)
-#define PCIE_PDI_SIZE            0x400
-
-#define PCIE1_CFG_PHY_BASE        0x19000000UL
-#define PCIE1_CFG_BASE           (KSEG1 + PCIE1_CFG_PHY_BASE)
-#define PCIE1_CFG_SIZE           (8 * 1024 * 1024)
-
-#define PCIE1_MEM_PHY_BASE        0x18000000UL
-#define PCIE1_MEM_BASE           (KSEG1 + PCIE1_MEM_PHY_BASE)
-#define PCIE1_MEM_SIZE           (16 * 1024 * 1024)
-#define PCIE1_MEM_PHY_END        (PCIE1_MEM_PHY_BASE + PCIE1_MEM_SIZE - 1)
-
-#define PCIE1_IO_PHY_BASE         0x19800000UL
-#define PCIE1_IO_BASE            (KSEG1 + PCIE1_IO_PHY_BASE)
-#define PCIE1_IO_SIZE            (1 * 1024 * 1024)
-#define PCIE1_IO_PHY_END         (PCIE1_IO_PHY_BASE + PCIE1_IO_SIZE - 1)
-
-#define PCIE1_RC_CFG_BASE        (KSEG1 + 0x19900000)
-#define PCIE1_APP_LOGIC_REG      (KSEG1 + 0x1E100700)
-#define PCIE1_MSI_PHY_BASE        0x1F400000UL
-
-#define PCIE1_PDI_PHY_BASE        0x1F700400UL
-#define PCIE1_PDI_BASE           (KSEG1 + PCIE1_PDI_PHY_BASE)
-#define PCIE1_PDI_SIZE            0x400
-
-#define PCIE_CFG_PORT_TO_BASE(X)     ((X) > 0 ? (PCIE1_CFG_BASE) : (PCIE_CFG_BASE))
-#define PCIE_MEM_PORT_TO_BASE(X)     ((X) > 0 ? (PCIE1_MEM_BASE) : (PCIE_MEM_BASE))
-#define PCIE_IO_PORT_TO_BASE(X)      ((X) > 0 ? (PCIE1_IO_BASE) : (PCIE_IO_BASE))
-#define PCIE_MEM_PHY_PORT_TO_BASE(X) ((X) > 0 ? (PCIE1_MEM_PHY_BASE) : (PCIE_MEM_PHY_BASE))
-#define PCIE_MEM_PHY_PORT_TO_END(X)  ((X) > 0 ? (PCIE1_MEM_PHY_END) : (PCIE_MEM_PHY_END))
-#define PCIE_IO_PHY_PORT_TO_BASE(X)  ((X) > 0 ? (PCIE1_IO_PHY_BASE) : (PCIE_IO_PHY_BASE))
-#define PCIE_IO_PHY_PORT_TO_END(X)   ((X) > 0 ? (PCIE1_IO_PHY_END) : (PCIE_IO_PHY_END))
-#define PCIE_APP_PORT_TO_BASE(X)     ((X) > 0 ? (PCIE1_APP_LOGIC_REG) : (PCIE_APP_LOGIC_REG))
-#define PCIE_RC_PORT_TO_BASE(X)      ((X) > 0 ? (PCIE1_RC_CFG_BASE) : (PCIE_RC_CFG_BASE))
-#define PCIE_PHY_PORT_TO_BASE(X)     ((X) > 0 ? (PCIE1_PDI_BASE) : (PCIE_PDI_BASE))
-
-/* PCIe Application Logic Register */
-/* RC Core Control Register */
-#define PCIE_RC_CCR(X)                      (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x10)
-/* This should be enabled after initializing configuratin registers
- * Also should check link status retraining bit
- */
-#define PCIE_RC_CCR_LTSSM_ENABLE             0x00000001    /* Enable LTSSM to continue link establishment */
-
-/* RC Core Debug Register */
-#define PCIE_RC_DR(X)                       (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x14)
-#define PCIE_RC_DR_DLL_UP                    0x00000001  /* Data Link Layer Up */
-#define PCIE_RC_DR_CURRENT_POWER_STATE       0x0000000E  /* Current Power State */
-#define PCIE_RC_DR_CURRENT_POWER_STATE_S     1
-#define PCIE_RC_DR_CURRENT_LTSSM_STATE       0x000001F0  /* Current LTSSM State */
-#define PCIE_RC_DR_CURRENT_LTSSM_STATE_S     4
-
-#define PCIE_RC_DR_PM_DEV_STATE              0x00000E00  /* Power Management D-State */
-#define PCIE_RC_DR_PM_DEV_STATE_S            9
-
-#define PCIE_RC_DR_PM_ENABLED                0x00001000  /* Power Management State from PMU */
-#define PCIE_RC_DR_PME_EVENT_ENABLED         0x00002000  /* Power Management Event Enable State */
-#define PCIE_RC_DR_AUX_POWER_ENABLED         0x00004000  /* Auxiliary Power Enable */
-
-/* Current Power State Definition */
-enum {
-    PCIE_RC_DR_D0 = 0,
-    PCIE_RC_DR_D1,   /* Not supported */
-    PCIE_RC_DR_D2,   /* Not supported */
-    PCIE_RC_DR_D3,
-    PCIE_RC_DR_UN,
-};
-
-/* PHY Link Status Register */
-#define PCIE_PHY_SR(X)                      (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x18)
-#define PCIE_PHY_SR_PHY_LINK_UP              0x00000001   /* PHY Link Up/Down Indicator */
-
-/* Electromechanical Control Register */
-#define PCIE_EM_CR(X)                       (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x1C)
-#define PCIE_EM_CR_CARD_IS_PRESENT           0x00000001  /* Card Presence Detect State */
-#define PCIE_EM_CR_MRL_OPEN                  0x00000002  /* MRL Sensor State */
-#define PCIE_EM_CR_POWER_FAULT_SET           0x00000004  /* Power Fault Detected */
-#define PCIE_EM_CR_MRL_SENSOR_SET            0x00000008  /* MRL Sensor Changed */
-#define PCIE_EM_CR_PRESENT_DETECT_SET        0x00000010  /* Card Presense Detect Changed */
-#define PCIE_EM_CR_CMD_CPL_INT_SET           0x00000020  /* Command Complete Interrupt */
-#define PCIE_EM_CR_SYS_INTERLOCK_SET         0x00000040  /* System Electromechanical IterLock Engaged */
-#define PCIE_EM_CR_ATTENTION_BUTTON_SET      0x00000080  /* Attention Button Pressed */
-
-/* Interrupt Status Register */
-#define PCIE_IR_SR(X)                       (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x20)
-#define PCIE_IR_SR_PME_CAUSE_MSI             0x00000002  /* MSI caused by PME */
-#define PCIE_IR_SR_HP_PME_WAKE_GEN           0x00000004  /* Hotplug PME Wake Generation */
-#define PCIE_IR_SR_HP_MSI                    0x00000008  /* Hotplug MSI */
-#define PCIE_IR_SR_AHB_LU_ERR                0x00000030  /* AHB Bridge Lookup Error Signals */
-#define PCIE_IR_SR_AHB_LU_ERR_S              4
-#define PCIE_IR_SR_INT_MSG_NUM               0x00003E00  /* Interrupt Message Number */
-#define PCIE_IR_SR_INT_MSG_NUM_S             9
-#define PCIE_IR_SR_AER_INT_MSG_NUM           0xF8000000  /* Advanced Error Interrupt Message Number */
-#define PCIE_IR_SR_AER_INT_MSG_NUM_S         27
-
-/* Message Control Register */
-#define PCIE_MSG_CR(X)                      (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x30)
-#define PCIE_MSG_CR_GEN_PME_TURN_OFF_MSG     0x00000001  /* Generate PME Turn Off Message */
-#define PCIE_MSG_CR_GEN_UNLOCK_MSG           0x00000002  /* Generate Unlock Message */
-
-#define PCIE_VDM_DR(X)                      (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x34)
-
-/* Vendor-Defined Message Requester ID Register */
-#define PCIE_VDM_RID(X)                     (PCIE_APP_PORT_TO_BASE (X) + 0x38)
-#define PCIE_VDM_RID_VENROR_MSG_REQ_ID       0x0000FFFF
-#define PCIE_VDM_RID_VDMRID_S                0
-
-/* ASPM Control Register */
-#define PCIE_ASPM_CR(X)                     (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x40)
-#define PCIE_ASPM_CR_HOT_RST                 0x00000001  /* Hot Reset Request to the downstream device */
-#define PCIE_ASPM_CR_REQ_EXIT_L1             0x00000002  /* Request to Exit L1 */
-#define PCIE_ASPM_CR_REQ_ENTER_L1            0x00000004  /* Request to Enter L1 */
-
-/* Vendor Message DW0 Register */
-#define PCIE_VM_MSG_DW0(X)                  (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x50)
-#define PCIE_VM_MSG_DW0_TYPE                 0x0000001F  /* Message type */
-#define PCIE_VM_MSG_DW0_TYPE_S               0
-#define PCIE_VM_MSG_DW0_FORMAT               0x00000060  /* Format */
-#define PCIE_VM_MSG_DW0_FORMAT_S             5
-#define PCIE_VM_MSG_DW0_TC                   0x00007000  /* Traffic Class */
-#define PCIE_VM_MSG_DW0_TC_S                 12
-#define PCIE_VM_MSG_DW0_ATTR                 0x000C0000  /* Atrributes */
-#define PCIE_VM_MSG_DW0_ATTR_S               18
-#define PCIE_VM_MSG_DW0_EP_TLP               0x00100000  /* Poisoned TLP */
-#define PCIE_VM_MSG_DW0_TD                   0x00200000  /* TLP Digest */
-#define PCIE_VM_MSG_DW0_LEN                  0xFFC00000  /* Length */
-#define PCIE_VM_MSG_DW0_LEN_S                22
-
-/* Format Definition */
-enum {
-    PCIE_VM_MSG_FORMAT_00 = 0,  /* 3DW Hdr, no data*/
-    PCIE_VM_MSG_FORMAT_01,      /* 4DW Hdr, no data */
-    PCIE_VM_MSG_FORMAT_10,      /* 3DW Hdr, with data */
-    PCIE_VM_MSG_FORMAT_11,      /* 4DW Hdr, with data */
-};
-
-/* Traffic Class Definition */
-enum {
-    PCIE_VM_MSG_TC0 = 0,
-    PCIE_VM_MSG_TC1,
-    PCIE_VM_MSG_TC2,
-    PCIE_VM_MSG_TC3,
-    PCIE_VM_MSG_TC4,
-    PCIE_VM_MSG_TC5,
-    PCIE_VM_MSG_TC6,
-    PCIE_VM_MSG_TC7,
-};
-
-/* Attributes Definition */
-enum {
-    PCIE_VM_MSG_ATTR_00 = 0,   /* RO and No Snoop cleared */
-    PCIE_VM_MSG_ATTR_01,       /* RO cleared , No Snoop set */
-    PCIE_VM_MSG_ATTR_10,       /* RO set, No Snoop cleared*/
-    PCIE_VM_MSG_ATTR_11,       /* RO and No Snoop set */
-};
-
-/* Payload Size Definition */
-#define PCIE_VM_MSG_LEN_MIN  0
-#define PCIE_VM_MSG_LEN_MAX  1024
-
-/* Vendor Message DW1 Register */
-#define PCIE_VM_MSG_DW1(X)                 (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x54)
-#define PCIE_VM_MSG_DW1_FUNC_NUM            0x00000070  /* Function Number */
-#define PCIE_VM_MSG_DW1_FUNC_NUM_S          8
-#define PCIE_VM_MSG_DW1_CODE                0x00FF0000  /* Message Code */
-#define PCIE_VM_MSG_DW1_CODE_S              16
-#define PCIE_VM_MSG_DW1_TAG                 0xFF000000  /* Tag */
-#define PCIE_VM_MSG_DW1_TAG_S               24
-
-#define PCIE_VM_MSG_DW2(X)                  (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x58)
-#define PCIE_VM_MSG_DW3(X)                  (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x5C)
-
-/* Vendor Message Request Register */
-#define PCIE_VM_MSG_REQR(X)                 (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x60)
-#define PCIE_VM_MSG_REQR_REQ                 0x00000001  /* Vendor Message Request */
-
-
-/* AHB Slave Side Band Control Register */
-#define PCIE_AHB_SSB(X)                     (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x70)
-#define PCIE_AHB_SSB_REQ_BCM                0x00000001 /* Slave Reques BCM filed */
-#define PCIE_AHB_SSB_REQ_EP                 0x00000002 /* Slave Reques EP filed */
-#define PCIE_AHB_SSB_REQ_TD                 0x00000004 /* Slave Reques TD filed */
-#define PCIE_AHB_SSB_REQ_ATTR               0x00000018 /* Slave Reques Attribute number */
-#define PCIE_AHB_SSB_REQ_ATTR_S             3
-#define PCIE_AHB_SSB_REQ_TC                 0x000000E0 /* Slave Request TC Field */
-#define PCIE_AHB_SSB_REQ_TC_S               5
-
-/* AHB Master SideBand Ctrl Register */
-#define PCIE_AHB_MSB(X)                     (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x74)
-#define PCIE_AHB_MSB_RESP_ATTR               0x00000003 /* Master Response Attribute number */
-#define PCIE_AHB_MSB_RESP_ATTR_S             0
-#define PCIE_AHB_MSB_RESP_BAD_EOT            0x00000004 /* Master Response Badeot filed */
-#define PCIE_AHB_MSB_RESP_BCM                0x00000008 /* Master Response BCM filed */
-#define PCIE_AHB_MSB_RESP_EP                 0x00000010 /* Master Response EP filed */
-#define PCIE_AHB_MSB_RESP_TD                 0x00000020 /* Master Response TD filed */
-#define PCIE_AHB_MSB_RESP_FUN_NUM            0x000003C0 /* Master Response Function number */
-#define PCIE_AHB_MSB_RESP_FUN_NUM_S          6
-
-/* AHB Control Register, fixed bus enumeration exception */
-#define PCIE_AHB_CTRL(X)                     (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x78)
-#define PCIE_AHB_CTRL_BUS_ERROR_SUPPRESS     0x00000001 
-
-/* Interrupt Enalbe Register */
-#define PCIE_IRNEN(X)                        (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0xF4)
-#define PCIE_IRNCR(X)                        (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0xF8)
-#define PCIE_IRNICR(X)                       (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0xFC)
-
-/* PCIe interrupt enable/control/capture register definition */
-#define PCIE_IRN_AER_REPORT                 0x00000001  /* AER Interrupt */
-#define PCIE_IRN_AER_MSIX                   0x00000002  /* Advanced Error MSI-X Interrupt */
-#define PCIE_IRN_PME                        0x00000004  /* PME Interrupt */
-#define PCIE_IRN_HOTPLUG                    0x00000008  /* Hotplug Interrupt */
-#define PCIE_IRN_RX_VDM_MSG                 0x00000010  /* Vendor-Defined Message Interrupt */
-#define PCIE_IRN_RX_CORRECTABLE_ERR_MSG     0x00000020  /* Correctable Error Message Interrupt */
-#define PCIE_IRN_RX_NON_FATAL_ERR_MSG       0x00000040  /* Non-fatal Error Message */
-#define PCIE_IRN_RX_FATAL_ERR_MSG           0x00000080  /* Fatal Error Message */
-#define PCIE_IRN_RX_PME_MSG                 0x00000100  /* PME Message Interrupt */
-#define PCIE_IRN_RX_PME_TURNOFF_ACK         0x00000200  /* PME Turnoff Ack Message Interrupt */
-#define PCIE_IRN_AHB_BR_FATAL_ERR           0x00000400  /* AHB Fatal Error Interrupt */
-#define PCIE_IRN_LINK_AUTO_BW_STATUS        0x00000800  /* Link Auto Bandwidth Status Interrupt */
-#define PCIE_IRN_BW_MGT                     0x00001000  /* Bandwidth Managment Interrupt */
-#define PCIE_IRN_INTA                       0x00002000  /* INTA */
-#define PCIE_IRN_INTB                       0x00004000  /* INTB */
-#define PCIE_IRN_INTC                       0x00008000  /* INTC */
-#define PCIE_IRN_INTD                       0x00010000  /* INTD */
-#define PCIE_IRN_WAKEUP                     0x00020000  /* Wake up Interrupt */
-
-#define PCIE_RC_CORE_COMBINED_INT    (PCIE_IRN_AER_REPORT |  PCIE_IRN_AER_MSIX | PCIE_IRN_PME | \
-                                      PCIE_IRN_HOTPLUG | PCIE_IRN_RX_VDM_MSG | PCIE_IRN_RX_CORRECTABLE_ERR_MSG |\
-                                      PCIE_IRN_RX_NON_FATAL_ERR_MSG | PCIE_IRN_RX_FATAL_ERR_MSG | \
-                                      PCIE_IRN_RX_PME_MSG | PCIE_IRN_RX_PME_TURNOFF_ACK | PCIE_IRN_AHB_BR_FATAL_ERR | \
-                                      PCIE_IRN_LINK_AUTO_BW_STATUS | PCIE_IRN_BW_MGT)
-/* PCIe RC Configuration Register */
-#define PCIE_VDID(X)                (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x00)
-
-/* Bit definition from pci_reg.h */
-#define PCIE_PCICMDSTS(X)           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x04)
-#define PCIE_CCRID(X)               (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x08)
-#define PCIE_CLSLTHTBR(X)           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x0C) /* EP only */
-/* BAR0, BAR1,Only necessary if the bridges implements a device-specific register set or memory buffer */
-#define PCIE_BAR0(X)                (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x10) /* Not used*/
-#define PCIE_BAR1(X)                (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x14) /* Not used */
-
-#define PCIE_BNR(X)                 (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x18) /* Mandatory */
-/* Bus Number Register bits */
-#define PCIE_BNR_PRIMARY_BUS_NUM             0x000000FF
-#define PCIE_BNR_PRIMARY_BUS_NUM_S           0
-#define PCIE_PNR_SECONDARY_BUS_NUM           0x0000FF00
-#define PCIE_PNR_SECONDARY_BUS_NUM_S         8
-#define PCIE_PNR_SUB_BUS_NUM                 0x00FF0000
-#define PCIE_PNR_SUB_BUS_NUM_S               16
-
-/* IO Base/Limit Register bits */
-#define PCIE_IOBLSECS(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x1C)  /* RC only */
-#define PCIE_IOBLSECS_32BIT_IO_ADDR             0x00000001
-#define PCIE_IOBLSECS_IO_BASE_ADDR              0x000000F0
-#define PCIE_IOBLSECS_IO_BASE_ADDR_S            4
-#define PCIE_IOBLSECS_32BIT_IOLIMT              0x00000100
-#define PCIE_IOBLSECS_IO_LIMIT_ADDR             0x0000F000
-#define PCIE_IOBLSECS_IO_LIMIT_ADDR_S           12
-
-/* Non-prefetchable Memory Base/Limit Register bit */
-#define PCIE_MBML(X)                           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x20)  /* RC only */
-#define PCIE_MBML_MEM_BASE_ADDR                 0x0000FFF0
-#define PCIE_MBML_MEM_BASE_ADDR_S               4
-#define PCIE_MBML_MEM_LIMIT_ADDR                0xFFF00000
-#define PCIE_MBML_MEM_LIMIT_ADDR_S              20
-
-/* Prefetchable Memory Base/Limit Register bit */
-#define PCIE_PMBL(X)                           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x24)  /* RC only */
-#define PCIE_PMBL_64BIT_ADDR                    0x00000001
-#define PCIE_PMBL_UPPER_12BIT                   0x0000FFF0
-#define PCIE_PMBL_UPPER_12BIT_S                 4
-#define PCIE_PMBL_E64MA                         0x00010000
-#define PCIE_PMBL_END_ADDR                      0xFFF00000
-#define PCIE_PMBL_END_ADDR_S                    20
-#define PCIE_PMBU32(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x28)  /* RC only */
-#define PCIE_PMLU32(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x2C)  /* RC only */
-
-/* I/O Base/Limit Upper 16 bits register */
-#define PCIE_IO_BANDL(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x30)  /* RC only */
-#define PCIE_IO_BANDL_UPPER_16BIT_IO_BASE        0x0000FFFF
-#define PCIE_IO_BANDL_UPPER_16BIT_IO_BASE_S      0
-#define PCIE_IO_BANDL_UPPER_16BIT_IO_LIMIT       0xFFFF0000
-#define PCIE_IO_BANDL_UPPER_16BIT_IO_LIMIT_S     16
-
-#define PCIE_CPR(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x34)
-#define PCIE_EBBAR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x38)
-
-/* Interrupt and Secondary Bridge Control Register */
-#define PCIE_INTRBCTRL(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x3C)
-
-#define PCIE_INTRBCTRL_INT_LINE                 0x000000FF
-#define PCIE_INTRBCTRL_INT_LINE_S               0
-#define PCIE_INTRBCTRL_INT_PIN                  0x0000FF00
-#define PCIE_INTRBCTRL_INT_PIN_S                8
-#define PCIE_INTRBCTRL_PARITY_ERR_RESP_ENABLE   0x00010000    /* #PERR */
-#define PCIE_INTRBCTRL_SERR_ENABLE              0x00020000    /* #SERR */
-#define PCIE_INTRBCTRL_ISA_ENABLE               0x00040000    /* ISA enable, IO 64KB only */
-#define PCIE_INTRBCTRL_VGA_ENABLE               0x00080000    /* VGA enable */
-#define PCIE_INTRBCTRL_VGA_16BIT_DECODE         0x00100000    /* VGA 16bit decode */
-#define PCIE_INTRBCTRL_RST_SECONDARY_BUS        0x00400000    /* Secondary bus rest, hot rest, 1ms */
-/* Others are read only */
-enum {
-    PCIE_INTRBCTRL_INT_NON = 0,
-    PCIE_INTRBCTRL_INTA,
-    PCIE_INTRBCTRL_INTB,
-    PCIE_INTRBCTRL_INTC,
-    PCIE_INTRBCTRL_INTD,
-};
-
-#define PCIE_PM_CAPR(X)                  (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x40)
-
-/* Power Management Control and Status Register */
-#define PCIE_PM_CSR(X)                   (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x44)
-
-#define PCIE_PM_CSR_POWER_STATE           0x00000003   /* Power State */
-#define PCIE_PM_CSR_POWER_STATE_S         0
-#define PCIE_PM_CSR_SW_RST                0x00000008   /* Soft Reset Enabled */
-#define PCIE_PM_CSR_PME_ENABLE            0x00000100   /* PME Enable */
-#define PCIE_PM_CSR_PME_STATUS            0x00008000   /* PME status */
-
-/* MSI Capability Register for EP */
-#define PCIE_MCAPR(X)                    (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x50)
-
-#define PCIE_MCAPR_MSI_CAP_ID             0x000000FF  /* MSI Capability ID */
-#define PCIE_MCAPR_MSI_CAP_ID_S           0
-#define PCIE_MCAPR_MSI_NEXT_CAP_PTR       0x0000FF00  /* Next Capability Pointer */
-#define PCIE_MCAPR_MSI_NEXT_CAP_PTR_S     8
-#define PCIE_MCAPR_MSI_ENABLE             0x00010000  /* MSI Enable */
-#define PCIE_MCAPR_MULTI_MSG_CAP          0x000E0000  /* Multiple Message Capable */
-#define PCIE_MCAPR_MULTI_MSG_CAP_S        17
-#define PCIE_MCAPR_MULTI_MSG_ENABLE       0x00700000  /* Multiple Message Enable */
-#define PCIE_MCAPR_MULTI_MSG_ENABLE_S     20
-#define PCIE_MCAPR_ADDR64_CAP             0X00800000  /* 64-bit Address Capable */
-
-/* MSI Message Address Register */
-#define PCIE_MA(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x54)
-
-#define PCIE_MA_ADDR_MASK                 0xFFFFFFFC  /* Message Address */
-
-/* MSI Message Upper Address Register */
-#define PCIE_MUA(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x58)
-
-/* MSI Message Data Register */
-#define PCIE_MD(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x5C)
-
-#define PCIE_MD_DATA                      0x0000FFFF  /* Message Data */
-#define PCIE_MD_DATA_S                    0
-
-/* PCI Express Capability Register */
-#define PCIE_XCAP(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x70)
-
-#define PCIE_XCAP_ID                      0x000000FF  /* PCI Express Capability ID */
-#define PCIE_XCAP_ID_S                    0
-#define PCIE_XCAP_NEXT_CAP                0x0000FF00  /* Next Capability Pointer */
-#define PCIE_XCAP_NEXT_CAP_S              8
-#define PCIE_XCAP_VER                     0x000F0000  /* PCI Express Capability Version */
-#define PCIE_XCAP_VER_S                   16
-#define PCIE_XCAP_DEV_PORT_TYPE           0x00F00000  /* Device Port Type */
-#define PCIE_XCAP_DEV_PORT_TYPE_S         20
-#define PCIE_XCAP_SLOT_IMPLEMENTED        0x01000000  /* Slot Implemented */
-#define PCIE_XCAP_MSG_INT_NUM             0x3E000000  /* Interrupt Message Number */
-#define PCIE_XCAP_MSG_INT_NUM_S           25
-
-/* Device Capability Register */
-#define PCIE_DCAP(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x74)
-
-#define PCIE_DCAP_MAX_PAYLOAD_SIZE        0x00000007   /* Max Payload size */
-#define PCIE_DCAP_MAX_PAYLOAD_SIZE_S      0
-#define PCIE_DCAP_PHANTOM_FUNC            0x00000018   /* Phanton Function, not supported */
-#define PCIE_DCAP_PHANTOM_FUNC_S          3
-#define PCIE_DCAP_EXT_TAG                 0x00000020   /* Extended Tag Field */
-#define PCIE_DCAP_EP_L0S_LATENCY          0x000001C0   /* EP L0s latency only */
-#define PCIE_DCAP_EP_L0S_LATENCY_S        6
-#define PCIE_DCAP_EP_L1_LATENCY           0x00000E00   /* EP L1 latency only */
-#define PCIE_DCAP_EP_L1_LATENCY_S         9
-#define PCIE_DCAP_ROLE_BASE_ERR_REPORT    0x00008000   /* Role Based ERR */
-
-/* Maximum payload size supported */
-enum {
-    PCIE_MAX_PAYLOAD_128 = 0,
-    PCIE_MAX_PAYLOAD_256,
-    PCIE_MAX_PAYLOAD_512,
-    PCIE_MAX_PAYLOAD_1024,
-    PCIE_MAX_PAYLOAD_2048,
-    PCIE_MAX_PAYLOAD_4096,
-};
-
-/* Device Control and Status Register */
-#define PCIE_DCTLSTS(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x78)
-
-#define PCIE_DCTLSTS_CORRECTABLE_ERR_EN        0x00000001   /* COR-ERR */
-#define PCIE_DCTLSTS_NONFATAL_ERR_EN           0x00000002   /* Non-fatal ERR */
-#define PCIE_DCTLSTS_FATAL_ERR_EN              0x00000004   /* Fatal ERR */
-#define PCIE_DCTLSYS_UR_REQ_EN                 0x00000008   /* UR ERR */
-#define PCIE_DCTLSTS_RELAXED_ORDERING_EN       0x00000010   /* Enable relaxing ordering */
-#define PCIE_DCTLSTS_MAX_PAYLOAD_SIZE          0x000000E0   /* Max payload mask */
-#define PCIE_DCTLSTS_MAX_PAYLOAD_SIZE_S        5
-#define PCIE_DCTLSTS_EXT_TAG_EN                0x00000100   /* Extended tag field */
-#define PCIE_DCTLSTS_PHANTOM_FUNC_EN           0x00000200   /* Phantom Function Enable */
-#define PCIE_DCTLSTS_AUX_PM_EN                 0x00000400   /* AUX Power PM Enable */
-#define PCIE_DCTLSTS_NO_SNOOP_EN               0x00000800   /* Enable no snoop, except root port*/
-#define PCIE_DCTLSTS_MAX_READ_SIZE             0x00007000   /* Max Read Request size*/
-#define PCIE_DCTLSTS_MAX_READ_SIZE_S           12
-#define PCIE_DCTLSTS_CORRECTABLE_ERR           0x00010000   /* COR-ERR Detected */
-#define PCIE_DCTLSTS_NONFATAL_ERR              0x00020000   /* Non-Fatal ERR Detected */
-#define PCIE_DCTLSTS_FATAL_ER                  0x00040000   /* Fatal ERR Detected */
-#define PCIE_DCTLSTS_UNSUPPORTED_REQ           0x00080000   /* UR Detected */
-#define PCIE_DCTLSTS_AUX_POWER                 0x00100000   /* Aux Power Detected */
-#define PCIE_DCTLSTS_TRANSACT_PENDING          0x00200000   /* Transaction pending */
-
-#define PCIE_DCTLSTS_ERR_EN      (PCIE_DCTLSTS_CORRECTABLE_ERR_EN | \
-                                  PCIE_DCTLSTS_NONFATAL_ERR_EN | PCIE_DCTLSTS_FATAL_ERR_EN | \
-                                  PCIE_DCTLSYS_UR_REQ_EN)
-
-/* Link Capability Register */
-#define PCIE_LCAP(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x7C)
-#define PCIE_LCAP_MAX_LINK_SPEED               0x0000000F  /* Max link speed, 0x1 by default */
-#define PCIE_LCAP_MAX_LINK_SPEED_S             0
-#define PCIE_LCAP_MAX_LENGTH_WIDTH             0x000003F0  /* Maxium Length Width */
-#define PCIE_LCAP_MAX_LENGTH_WIDTH_S           4
-#define PCIE_LCAP_ASPM_LEVEL                   0x00000C00  /* Active State Link PM Support */
-#define PCIE_LCAP_ASPM_LEVEL_S                 10
-#define PCIE_LCAP_L0S_EIXT_LATENCY             0x00007000  /* L0s Exit Latency */
-#define PCIE_LCAP_L0S_EIXT_LATENCY_S           12
-#define PCIE_LCAP_L1_EXIT_LATENCY              0x00038000  /* L1 Exit Latency */
-#define PCIE_LCAP_L1_EXIT_LATENCY_S            15
-#define PCIE_LCAP_CLK_PM                       0x00040000  /* Clock Power Management */
-#define PCIE_LCAP_SDER                         0x00080000  /* Surprise Down Error Reporting */
-#define PCIE_LCAP_DLL_ACTIVE_REPROT            0x00100000  /* Data Link Layer Active Reporting Capable */
-#define PCIE_LCAP_PORT_NUM                     0xFF0000000  /* Port number */
-#define PCIE_LCAP_PORT_NUM_S                   24
-
-/* Maximum Length width definition */
-#define PCIE_MAX_LENGTH_WIDTH_RES  0x00
-#define PCIE_MAX_LENGTH_WIDTH_X1   0x01  /* Default */
-#define PCIE_MAX_LENGTH_WIDTH_X2   0x02
-#define PCIE_MAX_LENGTH_WIDTH_X4   0x04
-#define PCIE_MAX_LENGTH_WIDTH_X8   0x08
-#define PCIE_MAX_LENGTH_WIDTH_X12  0x0C
-#define PCIE_MAX_LENGTH_WIDTH_X16  0x10
-#define PCIE_MAX_LENGTH_WIDTH_X32  0x20
-
-/* Active State Link PM definition */
-enum {
-    PCIE_ASPM_RES0                = 0,
-    PCIE_ASPM_L0S_ENTRY_SUPPORT,        /* L0s */
-    PCIE_ASPM_RES1,
-    PCIE_ASPM_L0S_L1_ENTRY_SUPPORT,     /* L0s and L1, default */
-};
-
-/* L0s Exit Latency definition */
-enum {
-    PCIE_L0S_EIXT_LATENCY_L64NS    = 0, /* < 64 ns */
-    PCIE_L0S_EIXT_LATENCY_B64A128,      /* > 64 ns < 128 ns */
-    PCIE_L0S_EIXT_LATENCY_B128A256,     /* > 128 ns < 256 ns */
-    PCIE_L0S_EIXT_LATENCY_B256A512,     /* > 256 ns < 512 ns */
-    PCIE_L0S_EIXT_LATENCY_B512TO1U,     /* > 512 ns < 1 us */
-    PCIE_L0S_EIXT_LATENCY_B1A2U,        /* > 1 us < 2 us */
-    PCIE_L0S_EIXT_LATENCY_B2A4U,        /* > 2 us < 4 us */
-    PCIE_L0S_EIXT_LATENCY_M4US,         /* > 4 us  */
-};
-
-/* L1 Exit Latency definition */
-enum {
-    PCIE_L1_EXIT_LATENCY_L1US  = 0,  /* < 1 us */
-    PCIE_L1_EXIT_LATENCY_B1A2,       /* > 1 us < 2 us */
-    PCIE_L1_EXIT_LATENCY_B2A4,       /* > 2 us < 4 us */
-    PCIE_L1_EXIT_LATENCY_B4A8,       /* > 4 us < 8 us */
-    PCIE_L1_EXIT_LATENCY_B8A16,      /* > 8 us < 16 us */
-    PCIE_L1_EXIT_LATENCY_B16A32,     /* > 16 us < 32 us */
-    PCIE_L1_EXIT_LATENCY_B32A64,     /* > 32 us < 64 us */
-    PCIE_L1_EXIT_LATENCY_M64US,      /* > 64 us */
-};
-
-/* Link Control and Status Register */
-#define PCIE_LCTLSTS(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x80)
-#define PCIE_LCTLSTS_ASPM_ENABLE            0x00000003  /* Active State Link PM Control */
-#define PCIE_LCTLSTS_ASPM_ENABLE_S          0
-#define PCIE_LCTLSTS_RCB128                 0x00000008  /* Read Completion Boundary 128*/
-#define PCIE_LCTLSTS_LINK_DISABLE           0x00000010  /* Link Disable */
-#define PCIE_LCTLSTS_RETRIAN_LINK           0x00000020  /* Retrain Link */
-#define PCIE_LCTLSTS_COM_CLK_CFG            0x00000040  /* Common Clock Configuration */
-#define PCIE_LCTLSTS_EXT_SYNC               0x00000080  /* Extended Synch */
-#define PCIE_LCTLSTS_CLK_PM_EN              0x00000100  /* Enable Clock Powerm Management */
-#define PCIE_LCTLSTS_LINK_SPEED             0x000F0000  /* Link Speed */
-#define PCIE_LCTLSTS_LINK_SPEED_S           16
-#define PCIE_LCTLSTS_NEGOTIATED_LINK_WIDTH  0x03F00000  /* Negotiated Link Width */
-#define PCIE_LCTLSTS_NEGOTIATED_LINK_WIDTH_S 20
-#define PCIE_LCTLSTS_RETRAIN_PENDING        0x08000000  /* Link training is ongoing */
-#define PCIE_LCTLSTS_SLOT_CLK_CFG           0x10000000  /* Slot Clock Configuration */
-#define PCIE_LCTLSTS_DLL_ACTIVE             0x20000000  /* Data Link Layer Active */
-
-/* Slot Capabilities Register */
-#define PCIE_SLCAP(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x84)
-
-/* Slot Capabilities */
-#define PCIE_SLCTLSTS(X)                    (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x88)
-
-/* Root Control and Capability Register */
-#define PCIE_RCTLCAP(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x8C)
-#define PCIE_RCTLCAP_SERR_ON_CORRECTABLE_ERR  0x00000001   /* #SERR on COR-ERR */
-#define PCIE_RCTLCAP_SERR_ON_NONFATAL_ERR     0x00000002   /* #SERR on Non-Fatal ERR */
-#define PCIE_RCTLCAP_SERR_ON_FATAL_ERR        0x00000004   /* #SERR on Fatal ERR */
-#define PCIE_RCTLCAP_PME_INT_EN               0x00000008   /* PME Interrupt Enable */
-#define PCIE_RCTLCAP_SERR_ENABLE    (PCIE_RCTLCAP_SERR_ON_CORRECTABLE_ERR | \
-                                     PCIE_RCTLCAP_SERR_ON_NONFATAL_ERR | PCIE_RCTLCAP_SERR_ON_FATAL_ERR)
-/* Root Status Register */
-#define PCIE_RSTS(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x90)
-#define PCIE_RSTS_PME_REQ_ID                   0x0000FFFF   /* PME Request ID */
-#define PCIE_RSTS_PME_REQ_ID_S                 0
-#define PCIE_RSTS_PME_STATUS                   0x00010000   /* PME Status */
-#define PCIE_RSTS_PME_PENDING                  0x00020000   /* PME Pending */
-
-/* PCI Express Enhanced Capability Header */
-#define PCIE_ENHANCED_CAP(X)                (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x100)
-#define PCIE_ENHANCED_CAP_ID                 0x0000FFFF  /* PCI Express Extended Capability ID */
-#define PCIE_ENHANCED_CAP_ID_S               0
-#define PCIE_ENHANCED_CAP_VER                0x000F0000  /* Capability Version */
-#define PCIE_ENHANCED_CAP_VER_S              16
-#define PCIE_ENHANCED_CAP_NEXT_OFFSET        0xFFF00000  /* Next Capability Offset */
-#define PCIE_ENHANCED_CAP_NEXT_OFFSET_S      20
-
-/* Uncorrectable Error Status Register */
-#define PCIE_UES_R(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x104)
-#define PCIE_DATA_LINK_PROTOCOL_ERR          0x00000010  /* Data Link Protocol Error Status */
-#define PCIE_SURPRISE_DOWN_ERROR             0x00000020  /* Surprise Down Error Status */
-#define PCIE_POISONED_TLP                    0x00001000  /* Poisoned TLP Status */
-#define PCIE_FC_PROTOCOL_ERR                 0x00002000  /* Flow Control Protocol Error Status */
-#define PCIE_COMPLETION_TIMEOUT              0x00004000  /* Completion Timeout Status */
-#define PCIE_COMPLETOR_ABORT                 0x00008000  /* Completer Abort Error */
-#define PCIE_UNEXPECTED_COMPLETION           0x00010000  /* Unexpected Completion Status */
-#define PCIE_RECEIVER_OVERFLOW               0x00020000  /* Receive Overflow Status */
-#define PCIE_MALFORNED_TLP                   0x00040000  /* Malformed TLP Stauts */
-#define PCIE_ECRC_ERR                        0x00080000  /* ECRC Error Stauts */
-#define PCIE_UR_REQ                          0x00100000  /* Unsupported Request Error Status */
-#define PCIE_ALL_UNCORRECTABLE_ERR    (PCIE_DATA_LINK_PROTOCOL_ERR | PCIE_SURPRISE_DOWN_ERROR | \
-                         PCIE_POISONED_TLP | PCIE_FC_PROTOCOL_ERR | PCIE_COMPLETION_TIMEOUT |   \
-                         PCIE_COMPLETOR_ABORT | PCIE_UNEXPECTED_COMPLETION | PCIE_RECEIVER_OVERFLOW |\
-                         PCIE_MALFORNED_TLP | PCIE_ECRC_ERR | PCIE_UR_REQ)
-
-/* Uncorrectable Error Mask Register, Mask means no report */
-#define PCIE_UEMR(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x108)
-
-/* Uncorrectable Error Severity Register */
-#define PCIE_UESR(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x10C)
-
-/* Correctable Error Status Register */
-#define PCIE_CESR(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x110)
-#define PCIE_RX_ERR                          0x00000001  /* Receive Error Status */
-#define PCIE_BAD_TLP                         0x00000040  /* Bad TLP Status */
-#define PCIE_BAD_DLLP                        0x00000080  /* Bad DLLP Status */
-#define PCIE_REPLAY_NUM_ROLLOVER             0x00000100  /* Replay Number Rollover Status */
-#define PCIE_REPLAY_TIMER_TIMEOUT_ERR        0x00001000  /* Reply Timer Timeout Status */
-#define PCIE_ADVISORY_NONFTAL_ERR            0x00002000  /* Advisory Non-Fatal Error Status */
-#define PCIE_CORRECTABLE_ERR        (PCIE_RX_ERR | PCIE_BAD_TLP | PCIE_BAD_DLLP | PCIE_REPLAY_NUM_ROLLOVER |\
-                                     PCIE_REPLAY_TIMER_TIMEOUT_ERR | PCIE_ADVISORY_NONFTAL_ERR)
-
-/* Correctable Error Mask Register */
-#define PCIE_CEMR(X)                        (volatile u32*)(PCIE_RC_CFG_BASE + 0x114)
-
-/* Advanced Error Capabilities and Control Register */
-#define PCIE_AECCR(X)                       (volatile u32*)(PCIE_RC_CFG_BASE + 0x118)
-#define PCIE_AECCR_FIRST_ERR_PTR            0x0000001F  /* First Error Pointer */
-#define PCIE_AECCR_FIRST_ERR_PTR_S          0
-#define PCIE_AECCR_ECRC_GEN_CAP             0x00000020  /* ECRC Generation Capable */
-#define PCIE_AECCR_ECRC_GEN_EN              0x00000040  /* ECRC Generation Enable */
-#define PCIE_AECCR_ECRC_CHECK_CAP           0x00000080  /* ECRC Check Capable */
-#define PCIE_AECCR_ECRC_CHECK_EN            0x00000100  /* ECRC Check Enable */
-
-/* Header Log Register 1 */
-#define PCIE_HLR1(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x11C)
-
-/* Header Log Register 2 */
-#define PCIE_HLR2(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x120)
-
-/* Header Log Register 3 */
-#define PCIE_HLR3(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x124)
-
-/* Header Log Register 4 */
-#define PCIE_HLR4(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x128)
-
-/* Root Error Command Register */
-#define PCIE_RECR(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x12C)
-#define PCIE_RECR_CORRECTABLE_ERR_REPORT_EN  0x00000001 /* COR-ERR */
-#define PCIE_RECR_NONFATAL_ERR_REPORT_EN     0x00000002 /* Non-Fatal ERR */
-#define PCIE_RECR_FATAL_ERR_REPORT_EN        0x00000004 /* Fatal ERR */
-#define PCIE_RECR_ERR_REPORT_EN  (PCIE_RECR_CORRECTABLE_ERR_REPORT_EN | \
-                PCIE_RECR_NONFATAL_ERR_REPORT_EN | PCIE_RECR_FATAL_ERR_REPORT_EN)
-
-/* Root Error Status Register */
-#define PCIE_RESR(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x130)
-#define PCIE_RESR_CORRECTABLE_ERR                0x00000001   /* COR-ERR Receveid */
-#define PCIE_RESR_MULTI_CORRECTABLE_ERR          0x00000002   /* Multiple COR-ERR Received */
-#define PCIE_RESR_FATAL_NOFATAL_ERR              0x00000004   /* ERR Fatal/Non-Fatal Received */
-#define PCIE_RESR_MULTI_FATAL_NOFATAL_ERR        0x00000008   /* Multiple ERR Fatal/Non-Fatal Received */
-#define PCIE_RESR_FIRST_UNCORRECTABLE_FATAL_ERR  0x00000010   /* First UN-COR Fatal */
-#define PCIR_RESR_NON_FATAL_ERR                  0x00000020   /* Non-Fatal Error Message Received */
-#define PCIE_RESR_FATAL_ERR                      0x00000040   /* Fatal Message Received */
-#define PCIE_RESR_AER_INT_MSG_NUM                0xF8000000   /* Advanced Error Interrupt Message Number */
-#define PCIE_RESR_AER_INT_MSG_NUM_S              27
-
-/* Error Source Indentification Register */
-#define PCIE_ESIR(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x134)
-#define PCIE_ESIR_CORRECTABLE_ERR_SRC_ID         0x0000FFFF
-#define PCIE_ESIR_CORRECTABLE_ERR_SRC_ID_S       0
-#define PCIE_ESIR_FATAL_NON_FATAL_SRC_ID         0xFFFF0000
-#define PCIE_ESIR_FATAL_NON_FATAL_SRC_ID_S       16
-
-/* VC Enhanced Capability Header */
-#define PCIE_VC_ECH(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x140)
-
-/* Port VC Capability Register */
-#define PCIE_PVC1(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x144)
-#define PCIE_PVC1_EXT_VC_CNT                    0x00000007  /* Extended VC Count */
-#define PCIE_PVC1_EXT_VC_CNT_S                  0
-#define PCIE_PVC1_LOW_PRI_EXT_VC_CNT            0x00000070  /* Low Priority Extended VC Count */
-#define PCIE_PVC1_LOW_PRI_EXT_VC_CNT_S          4
-#define PCIE_PVC1_REF_CLK                       0x00000300  /* Reference Clock */
-#define PCIE_PVC1_REF_CLK_S                     8
-#define PCIE_PVC1_PORT_ARB_TAB_ENTRY_SIZE       0x00000C00  /* Port Arbitration Table Entry Size */
-#define PCIE_PVC1_PORT_ARB_TAB_ENTRY_SIZE_S     10
-
-/* Extended Virtual Channel Count Defintion */
-#define PCIE_EXT_VC_CNT_MIN   0
-#define PCIE_EXT_VC_CNT_MAX   7
-
-/* Port Arbitration Table Entry Size Definition */
-enum {
-    PCIE_PORT_ARB_TAB_ENTRY_SIZE_S1BIT = 0,
-    PCIE_PORT_ARB_TAB_ENTRY_SIZE_S2BIT,
-    PCIE_PORT_ARB_TAB_ENTRY_SIZE_S4BIT,
-    PCIE_PORT_ARB_TAB_ENTRY_SIZE_S8BIT,
-};
-
-/* Port VC Capability Register 2 */
-#define PCIE_PVC2(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x148)
-#define PCIE_PVC2_VC_ARB_16P_FIXED_WRR      0x00000001  /* HW Fixed arbitration, 16 phase WRR */
-#define PCIE_PVC2_VC_ARB_32P_WRR            0x00000002  /* 32 phase WRR */
-#define PCIE_PVC2_VC_ARB_64P_WRR            0x00000004  /* 64 phase WRR */
-#define PCIE_PVC2_VC_ARB_128P_WRR           0x00000008  /* 128 phase WRR */
-#define PCIE_PVC2_VC_ARB_WRR                0x0000000F
-#define PCIE_PVC2_VC_ARB_TAB_OFFSET         0xFF000000  /* VC arbitration table offset, not support */
-#define PCIE_PVC2_VC_ARB_TAB_OFFSET_S       24
-
-/* Port VC Control and Status Register */     
-#define PCIE_PVCCRSR(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x14C)
-#define PCIE_PVCCRSR_LOAD_VC_ARB_TAB         0x00000001  /* Load VC Arbitration Table */
-#define PCIE_PVCCRSR_VC_ARB_SEL              0x0000000E  /* VC Arbitration Select */
-#define PCIE_PVCCRSR_VC_ARB_SEL_S            1
-#define PCIE_PVCCRSR_VC_ARB_TAB_STATUS       0x00010000  /* Arbitration Status */
-
-/* VC0 Resource Capability Register */
-#define PCIE_VC0_RC(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x150)
-#define PCIE_VC0_RC_PORT_ARB_HW_FIXED        0x00000001  /* HW Fixed arbitration */
-#define PCIE_VC0_RC_PORT_ARB_32P_WRR         0x00000002  /* 32 phase WRR */
-#define PCIE_VC0_RC_PORT_ARB_64P_WRR         0x00000004  /* 64 phase WRR */
-#define PCIE_VC0_RC_PORT_ARB_128P_WRR        0x00000008  /* 128 phase WRR */
-#define PCIE_VC0_RC_PORT_ARB_TM_128P_WRR     0x00000010  /* Time-based 128 phase WRR */
-#define PCIE_VC0_RC_PORT_ARB_TM_256P_WRR     0x00000020  /* Time-based 256 phase WRR */
-#define PCIE_VC0_RC_PORT_ARB          (PCIE_VC0_RC_PORT_ARB_HW_FIXED | PCIE_VC0_RC_PORT_ARB_32P_WRR |\
-                        PCIE_VC0_RC_PORT_ARB_64P_WRR | PCIE_VC0_RC_PORT_ARB_128P_WRR | \
-                        PCIE_VC0_RC_PORT_ARB_TM_128P_WRR | PCIE_VC0_RC_PORT_ARB_TM_256P_WRR)
-
-#define PCIE_VC0_RC_REJECT_SNOOP             0x00008000  /* Reject Snoop Transactioin */
-#define PCIE_VC0_RC_MAX_TIMESLOTS            0x007F0000  /* Maximum time Slots */
-#define PCIE_VC0_RC_MAX_TIMESLOTS_S          16
-#define PCIE_VC0_RC_PORT_ARB_TAB_OFFSET      0xFF000000  /* Port Arbitration Table Offset */
-#define PCIE_VC0_RC_PORT_ARB_TAB_OFFSET_S    24
-
-/* VC0 Resource Control Register */
-#define PCIE_VC0_RC0(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x154)
-#define PCIE_VC0_RC0_TVM0                    0x00000001  /* TC0 and VC0 */
-#define PCIE_VC0_RC0_TVM1                    0x00000002  /* TC1 and VC1 */
-#define PCIE_VC0_RC0_TVM2                    0x00000004  /* TC2 and VC2 */
-#define PCIE_VC0_RC0_TVM3                    0x00000008  /* TC3 and VC3 */
-#define PCIE_VC0_RC0_TVM4                    0x00000010  /* TC4 and VC4 */
-#define PCIE_VC0_RC0_TVM5                    0x00000020  /* TC5 and VC5 */
-#define PCIE_VC0_RC0_TVM6                    0x00000040  /* TC6 and VC6 */
-#define PCIE_VC0_RC0_TVM7                    0x00000080  /* TC7 and VC7 */
-#define PCIE_VC0_RC0_TC_VC                   0x000000FF  /* TC/VC mask */
-
-#define PCIE_VC0_RC0_LOAD_PORT_ARB_TAB       0x00010000  /* Load Port Arbitration Table */
-#define PCIE_VC0_RC0_PORT_ARB_SEL            0x000E0000  /* Port Arbitration Select */
-#define PCIE_VC0_RC0_PORT_ARB_SEL_S          17
-#define PCIE_VC0_RC0_VC_ID                   0x07000000  /* VC ID */
-#define PCIE_VC0_RC0_VC_ID_S                 24
-#define PCIE_VC0_RC0_VC_EN                   0x80000000  /* VC Enable */
-
-/* VC0 Resource Status Register */
-#define PCIE_VC0_RSR0(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x158)
-#define PCIE_VC0_RSR0_PORT_ARB_TAB_STATUS    0x00010000  /* Port Arbitration Table Status,not used */
-#define PCIE_VC0_RSR0_VC_NEG_PENDING         0x00020000  /* VC Negotiation Pending */
-
-/* Ack Latency Timer and Replay Timer Register */
-#define PCIE_ALTRT(X)                         (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x700)
-#define PCIE_ALTRT_ROUND_TRIP_LATENCY_LIMIT   0x0000FFFF  /* Round Trip Latency Time Limit */
-#define PCIE_ALTRT_ROUND_TRIP_LATENCY_LIMIT_S 0
-#define PCIE_ALTRT_REPLAY_TIME_LIMIT          0xFFFF0000  /* Replay Time Limit */
-#define PCIE_ALTRT_REPLAY_TIME_LIMIT_S        16
-
-/* Other Message Register */
-#define PCIE_OMR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x704)
-
-/* Port Force Link Register */
-#define PCIE_PFLR(X)                         (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x708)
-#define PCIE_PFLR_LINK_NUM                   0x000000FF  /* Link Number */
-#define PCIE_PFLR_LINK_NUM_S                 0
-#define PCIE_PFLR_FORCE_LINK                 0x00008000  /* Force link */
-#define PCIE_PFLR_LINK_STATE                 0x003F0000  /* Link State */
-#define PCIE_PFLR_LINK_STATE_S               16
-#define PCIE_PFLR_LOW_POWER_ENTRY_CNT        0xFF000000  /* Low Power Entrance Count, only for EP */
-#define PCIE_PFLR_LOW_POWER_ENTRY_CNT_S      24
-
-/* Ack Frequency Register */
-#define PCIE_AFR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x70C)
-#define PCIE_AFR_AF                          0x000000FF  /* Ack Frequency */
-#define PCIE_AFR_AF_S                        0
-#define PCIE_AFR_FTS_NUM                     0x0000FF00  /* The number of Fast Training Sequence from L0S to L0 */
-#define PCIE_AFR_FTS_NUM_S                   8
-#define PCIE_AFR_COM_FTS_NUM                 0x00FF0000  /* N_FTS; when common clock is used*/
-#define PCIE_AFR_COM_FTS_NUM_S               16
-#define PCIE_AFR_L0S_ENTRY_LATENCY           0x07000000  /* L0s Entrance Latency */
-#define PCIE_AFR_L0S_ENTRY_LATENCY_S         24
-#define PCIE_AFR_L1_ENTRY_LATENCY            0x38000000  /* L1 Entrance Latency */
-#define PCIE_AFR_L1_ENTRY_LATENCY_S          27
-#define PCIE_AFR_FTS_NUM_DEFAULT             32
-#define PCIE_AFR_L0S_ENTRY_LATENCY_DEFAULT   7
-#define PCIE_AFR_L1_ENTRY_LATENCY_DEFAULT    5
-
-/* Port Link Control Register */
-#define PCIE_PLCR(X)                         (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x710)
-#define PCIE_PLCR_OTHER_MSG_REQ              0x00000001  /* Other Message Request */
-#define PCIE_PLCR_SCRAMBLE_DISABLE           0x00000002  /* Scramble Disable */  
-#define PCIE_PLCR_LOOPBACK_EN                0x00000004  /* Loopback Enable */
-#define PCIE_PLCR_LTSSM_HOT_RST              0x00000008  /* Force LTSSM to the hot reset */
-#define PCIE_PLCR_DLL_LINK_EN                0x00000020  /* Enable Link initialization */
-#define PCIE_PLCR_FAST_LINK_SIM_EN           0x00000080  /* Sets all internal timers to fast mode for simulation purposes */
-#define PCIE_PLCR_LINK_MODE                  0x003F0000  /* Link Mode Enable Mask */
-#define PCIE_PLCR_LINK_MODE_S                16
-#define PCIE_PLCR_CORRUPTED_CRC_EN           0x02000000  /* Enabled Corrupt CRC */
-
-/* Lane Skew Register */
-#define PCIE_LSR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x714)
-#define PCIE_LSR_LANE_SKEW_NUM               0x00FFFFFF  /* Insert Lane Skew for Transmit, not applicable */
-#define PCIE_LSR_LANE_SKEW_NUM_S             0
-#define PCIE_LSR_FC_DISABLE                  0x01000000  /* Disable of Flow Control */
-#define PCIE_LSR_ACKNAK_DISABLE              0x02000000  /* Disable of Ack/Nak */
-#define PCIE_LSR_LANE_DESKEW_DISABLE         0x80000000  /* Disable of Lane-to-Lane Skew */
-
-/* Symbol Number Register */
-#define PCIE_SNR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x718)
-#define PCIE_SNR_TS                          0x0000000F  /* Number of TS Symbol */
-#define PCIE_SNR_TS_S                        0
-#define PCIE_SNR_SKP                         0x00000700  /* Number of SKP Symbol */
-#define PCIE_SNR_SKP_S                       8
-#define PCIE_SNR_REPLAY_TIMER                0x0007C000  /* Timer Modifier for Replay Timer */
-#define PCIE_SNR_REPLAY_TIMER_S              14
-#define PCIE_SNR_ACKNAK_LATENCY_TIMER        0x00F80000  /* Timer Modifier for Ack/Nak Latency Timer */
-#define PCIE_SNR_ACKNAK_LATENCY_TIMER_S      19
-#define PCIE_SNR_FC_TIMER                    0x1F000000  /* Timer Modifier for Flow Control Watchdog Timer */
-#define PCIE_SNR_FC_TIMER_S                  28
-
-/* Symbol Timer Register and Filter Mask Register 1 */
-#define PCIE_STRFMR(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x71C)
-#define PCIE_STRFMR_SKP_INTERVAL            0x000007FF  /* SKP lnterval Value */
-#define PCIE_STRFMR_SKP_INTERVAL_S          0
-#define PCIE_STRFMR_FC_WDT_DISABLE          0x00008000  /* Disable of FC Watchdog Timer */
-#define PCIE_STRFMR_TLP_FUNC_MISMATCH_OK    0x00010000  /* Mask Function Mismatch Filtering for Incoming Requests */
-#define PCIE_STRFMR_POISONED_TLP_OK         0x00020000  /* Mask Poisoned TLP Filtering */
-#define PCIE_STRFMR_BAR_MATCH_OK            0x00040000  /* Mask BAR Match Filtering */
-#define PCIE_STRFMR_TYPE1_CFG_REQ_OK        0x00080000  /* Mask Type 1 Configuration Request Filtering */
-#define PCIE_STRFMR_LOCKED_REQ_OK           0x00100000  /* Mask Locked Request Filtering */
-#define PCIE_STRFMR_CPL_TAG_ERR_RULES_OK    0x00200000  /* Mask Tag Error Rules for Received Completions */
-#define PCIE_STRFMR_CPL_REQUESTOR_ID_MISMATCH_OK 0x00400000  /* Mask Requester ID Mismatch Error for Received Completions */
-#define PCIE_STRFMR_CPL_FUNC_MISMATCH_OK         0x00800000  /* Mask Function Mismatch Error for Received Completions */
-#define PCIE_STRFMR_CPL_TC_MISMATCH_OK           0x01000000  /* Mask Traffic Class Mismatch Error for Received Completions */
-#define PCIE_STRFMR_CPL_ATTR_MISMATCH_OK         0x02000000  /* Mask Attribute Mismatch Error for Received Completions */
-#define PCIE_STRFMR_CPL_LENGTH_MISMATCH_OK       0x04000000  /* Mask Length Mismatch Error for Received Completions */
-#define PCIE_STRFMR_TLP_ECRC_ERR_OK              0x08000000  /* Mask ECRC Error Filtering */
-#define PCIE_STRFMR_CPL_TLP_ECRC_OK              0x10000000  /* Mask ECRC Error Filtering for Completions */
-#define PCIE_STRFMR_RX_TLP_MSG_NO_DROP           0x20000000  /* Send Message TLPs */
-#define PCIE_STRFMR_RX_IO_TRANS_ENABLE           0x40000000  /* Mask Filtering of received I/O Requests */
-#define PCIE_STRFMR_RX_CFG_TRANS_ENABLE          0x80000000  /* Mask Filtering of Received Configuration Requests */
-
-#define PCIE_DEF_SKP_INTERVAL    700             /* 1180 ~1538 , 125MHz * 2, 250MHz * 1 */
-
-/* Filter Masker Register 2 */
-#define PCIE_FMR2(X)                             (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x720)
-#define PCIE_FMR2_VENDOR_MSG0_PASSED_TO_TRGT1    0x00000001  /* Mask RADM Filtering and Error Handling Rules */
-#define PCIE_FMR2_VENDOR_MSG1_PASSED_TO_TRGT1    0x00000002  /* Mask RADM Filtering and Error Handling Rules */
-
-/* Debug Register 0 */
-#define PCIE_DBR0(X)                              (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x728)
-
-/* Debug Register 1 */
-#define PCIE_DBR1(X)                              (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x72C)
-
-/* Transmit Posted FC Credit Status Register */
-#define PCIE_TPFCS(X)                             (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x730)
-#define PCIE_TPFCS_TX_P_DATA_FC_CREDITS           0x00000FFF /* Transmit Posted Data FC Credits */
-#define PCIE_TPFCS_TX_P_DATA_FC_CREDITS_S         0
-#define PCIE_TPFCS_TX_P_HDR_FC_CREDITS            0x000FF000 /* Transmit Posted Header FC Credits */
-#define PCIE_TPFCS_TX_P_HDR_FC_CREDITS_S          12
-
-/* Transmit Non-Posted FC Credit Status */
-#define PCIE_TNPFCS(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x734)
-#define PCIE_TNPFCS_TX_NP_DATA_FC_CREDITS         0x00000FFF /* Transmit Non-Posted Data FC Credits */
-#define PCIE_TNPFCS_TX_NP_DATA_FC_CREDITS_S       0
-#define PCIE_TNPFCS_TX_NP_HDR_FC_CREDITS          0x000FF000 /* Transmit Non-Posted Header FC Credits */
-#define PCIE_TNPFCS_TX_NP_HDR_FC_CREDITS_S        12
-
-/* Transmit Complete FC Credit Status Register */
-#define PCIE_TCFCS(X)                             (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x738)
-#define PCIE_TCFCS_TX_CPL_DATA_FC_CREDITS         0x00000FFF /* Transmit Completion Data FC Credits */
-#define PCIE_TCFCS_TX_CPL_DATA_FC_CREDITS_S       0
-#define PCIE_TCFCS_TX_CPL_HDR_FC_CREDITS          0x000FF000 /* Transmit Completion Header FC Credits */
-#define PCIE_TCFCS_TX_CPL_HDR_FC_CREDITS_S        12
-
-/* Queue Status Register */
-#define PCIE_QSR(X)                              (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x73C)
-#define PCIE_QSR_WAIT_UPDATE_FC_DLL               0x00000001 /* Received TLP FC Credits Not Returned */
-#define PCIE_QSR_TX_RETRY_BUF_NOT_EMPTY           0x00000002 /* Transmit Retry Buffer Not Empty */
-#define PCIE_QSR_RX_QUEUE_NOT_EMPTY               0x00000004 /* Received Queue Not Empty */
-
-/* VC Transmit Arbitration Register 1 */
-#define PCIE_VCTAR1(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x740)
-#define PCIE_VCTAR1_WRR_WEIGHT_VC0               0x000000FF /* WRR Weight for VC0 */
-#define PCIE_VCTAR1_WRR_WEIGHT_VC1               0x0000FF00 /* WRR Weight for VC1 */
-#define PCIE_VCTAR1_WRR_WEIGHT_VC2               0x00FF0000 /* WRR Weight for VC2 */
-#define PCIE_VCTAR1_WRR_WEIGHT_VC3               0xFF000000 /* WRR Weight for VC3 */
-
-/* VC Transmit Arbitration Register 2 */
-#define PCIE_VCTAR2(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x744)
-#define PCIE_VCTAR2_WRR_WEIGHT_VC4               0x000000FF /* WRR Weight for VC4 */
-#define PCIE_VCTAR2_WRR_WEIGHT_VC5               0x0000FF00 /* WRR Weight for VC5 */
-#define PCIE_VCTAR2_WRR_WEIGHT_VC6               0x00FF0000 /* WRR Weight for VC6 */
-#define PCIE_VCTAR2_WRR_WEIGHT_VC7               0xFF000000 /* WRR Weight for VC7 */
-
-/* VC0 Posted Receive Queue Control Register */
-#define PCIE_VC0_PRQCR(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x748)
-#define PCIE_VC0_PRQCR_P_DATA_CREDITS            0x00000FFF /* VC0 Posted Data Credits */
-#define PCIE_VC0_PRQCR_P_DATA_CREDITS_S          0
-#define PCIE_VC0_PRQCR_P_HDR_CREDITS             0x000FF000 /* VC0 Posted Header Credits */
-#define PCIE_VC0_PRQCR_P_HDR_CREDITS_S           12
-#define PCIE_VC0_PRQCR_P_TLP_QUEUE_MODE          0x00E00000 /* VC0 Posted TLP Queue Mode */
-#define PCIE_VC0_PRQCR_P_TLP_QUEUE_MODE_S        20
-#define PCIE_VC0_PRQCR_TLP_RELAX_ORDER           0x40000000 /* TLP Type Ordering for VC0 */    
-#define PCIE_VC0_PRQCR_VC_STRICT_ORDER           0x80000000 /* VC0 Ordering for Receive Queues */
-
-/* VC0 Non-Posted Receive Queue Control */
-#define PCIE_VC0_NPRQCR(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x74C)
-#define PCIE_VC0_NPRQCR_NP_DATA_CREDITS          0x00000FFF /* VC0 Non-Posted Data Credits */
-#define PCIE_VC0_NPRQCR_NP_DATA_CREDITS_S        0
-#define PCIE_VC0_NPRQCR_NP_HDR_CREDITS           0x000FF000 /* VC0 Non-Posted Header Credits */
-#define PCIE_VC0_NPRQCR_NP_HDR_CREDITS_S         12
-#define PCIE_VC0_NPRQCR_NP_TLP_QUEUE_MODE        0x00E00000 /* VC0 Non-Posted TLP Queue Mode */
-#define PCIE_VC0_NPRQCR_NP_TLP_QUEUE_MODE_S      20
-
-/* VC0 Completion Receive Queue Control */
-#define PCIE_VC0_CRQCR(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x750)
-#define PCIE_VC0_CRQCR_CPL_DATA_CREDITS          0x00000FFF /* VC0 Completion TLP Queue Mode */
-#define PCIE_VC0_CRQCR_CPL_DATA_CREDITS_S        0
-#define PCIE_VC0_CRQCR_CPL_HDR_CREDITS           0x000FF000 /* VC0 Completion Header Credits */
-#define PCIE_VC0_CRQCR_CPL_HDR_CREDITS_S         12
-#define PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE        0x00E00000 /* VC0 Completion Data Credits */
-#define PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE_S      21
-
-/* Applicable to the above three registers */
-enum {
-    PCIE_VC0_TLP_QUEUE_MODE_STORE_FORWARD = 1,
-    PCIE_VC0_TLP_QUEUE_MODE_CUT_THROUGH   = 2,
-    PCIE_VC0_TLP_QUEUE_MODE_BYPASS        = 4,
-};
-
-/* VC0 Posted Buffer Depth Register */
-#define PCIE_VC0_PBD(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x7A8)
-#define PCIE_VC0_PBD_P_DATA_QUEUE_ENTRIES       0x00003FFF /* VC0 Posted Data Queue Depth */
-#define PCIE_VC0_PBD_P_DATA_QUEUE_ENTRIES_S     0
-#define PCIE_VC0_PBD_P_HDR_QUEUE_ENTRIES        0x03FF0000 /* VC0 Posted Header Queue Depth */
-#define PCIE_VC0_PBD_P_HDR_QUEUE_ENTRIES_S      16
-
-/* VC0 Non-Posted Buffer Depth Register */
-#define PCIE_VC0_NPBD(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x7AC)
-#define PCIE_VC0_NPBD_NP_DATA_QUEUE_ENTRIES     0x00003FFF /* VC0 Non-Posted Data Queue Depth */
-#define PCIE_VC0_NPBD_NP_DATA_QUEUE_ENTRIES_S   0
-#define PCIE_VC0_NPBD_NP_HDR_QUEUE_ENTRIES      0x03FF0000 /* VC0 Non-Posted Header Queue Depth */
-#define PCIE_VC0_NPBD_NP_HDR_QUEUE_ENTRIES_S    16
-
-/* VC0 Completion Buffer Depth Register */
-#define PCIE_VC0_CBD(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x7B0)
-#define PCIE_VC0_CBD_CPL_DATA_QUEUE_ENTRIES     0x00003FFF /* C0 Completion Data Queue Depth */
-#define PCIE_VC0_CBD_CPL_DATA_QUEUE_ENTRIES_S   0
-#define PCIE_VC0_CBD_CPL_HDR_QUEUE_ENTRIES      0x03FF0000 /* VC0 Completion Header Queue Depth */
-#define PCIE_VC0_CBD_CPL_HDR_QUEUE_ENTRIES_S    16
-
-/* PHY Status Register, all zeros in VR9 */
-#define PCIE_PHYSR(X)                           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x810)
-
-/* PHY Control Register, all zeros in VR9 */
-#define PCIE_PHYCR(X)                           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x814)
-
-/* 
- * PCIe PDI PHY register definition, suppose all the following 
- * stuff is confidential. 
- * XXX, detailed bit definition
- */
-#define	PCIE_PHY_PLL_CTRL1(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x22 << 1))
-#define	PCIE_PHY_PLL_CTRL2(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x23 << 1))
-#define	PCIE_PHY_PLL_CTRL3(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x24 << 1))
-#define	PCIE_PHY_PLL_CTRL4(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x25 << 1))
-#define	PCIE_PHY_PLL_CTRL5(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x26 << 1))
-#define	PCIE_PHY_PLL_CTRL6(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x27 << 1))
-#define	PCIE_PHY_PLL_CTRL7(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x28 << 1))
-#define	PCIE_PHY_PLL_A_CTRL1(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x29 << 1))
-#define	PCIE_PHY_PLL_A_CTRL2(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x2A << 1))
-#define	PCIE_PHY_PLL_A_CTRL3(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x2B << 1))
-#define	PCIE_PHY_PLL_STATUS(X)      (PCIE_PHY_PORT_TO_BASE(X) + (0x2C << 1))
- 
-#define PCIE_PHY_TX1_CTRL1(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x30 << 1))
-#define PCIE_PHY_TX1_CTRL2(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x31 << 1))
-#define PCIE_PHY_TX1_CTRL3(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x32 << 1))
-#define PCIE_PHY_TX1_A_CTRL1(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x33 << 1))
-#define PCIE_PHY_TX1_A_CTRL2(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x34 << 1))
-#define PCIE_PHY_TX1_MOD1(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x35 << 1))
-#define PCIE_PHY_TX1_MOD2(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x36 << 1))
-#define PCIE_PHY_TX1_MOD3(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x37 << 1))
-
-#define PCIE_PHY_TX2_CTRL1(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x38 << 1))
-#define PCIE_PHY_TX2_CTRL2(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x39 << 1))
-#define PCIE_PHY_TX2_A_CTRL1(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x3B << 1))
-#define PCIE_PHY_TX2_A_CTRL2(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x3C << 1))
-#define PCIE_PHY_TX2_MOD1(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x3D << 1))
-#define PCIE_PHY_TX2_MOD2(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x3E << 1))
-#define PCIE_PHY_TX2_MOD3(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x3F << 1))
-
-#define PCIE_PHY_RX1_CTRL1(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x50 << 1))
-#define PCIE_PHY_RX1_CTRL2(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x51 << 1))
-#define PCIE_PHY_RX1_CDR(X)         (PCIE_PHY_PORT_TO_BASE(X) + (0x52 << 1))
-#define PCIE_PHY_RX1_EI(X)          (PCIE_PHY_PORT_TO_BASE(X) + (0x53 << 1))
-#define PCIE_PHY_RX1_A_CTRL(X)      (PCIE_PHY_PORT_TO_BASE(X) + (0x55 << 1))
-
-/* Interrupt related stuff */
-#define PCIE_LEGACY_DISABLE 0
-#define PCIE_LEGACY_INTA  1
-#define PCIE_LEGACY_INTB  2
-#define PCIE_LEGACY_INTC  3
-#define PCIE_LEGACY_INTD  4
-#define PCIE_LEGACY_INT_MAX PCIE_LEGACY_INTD
-
-#endif /* IFXMIPS_PCIE_REG_H */
-
diff --git a/arch/mips/pci/ifxmips_pcie_vr9.h b/arch/mips/pci/ifxmips_pcie_vr9.h
deleted file mode 100644
--- a/arch/mips/pci/ifxmips_pcie_vr9.h
+++ /dev/null
@@ -1,271 +0,0 @@
-/****************************************************************************
-                              Copyright (c) 2010
-                            Lantiq Deutschland GmbH
-                     Am Campeon 3; 85579 Neubiberg, Germany
-
-  For licensing information, see the file 'LICENSE' in the root folder of
-  this software module.
-
- *****************************************************************************/
-/*!
-  \file ifxmips_pcie_vr9.h
-  \ingroup IFX_PCIE
-  \brief PCIe RC driver vr9 specific file
-*/
-
-#ifndef IFXMIPS_PCIE_VR9_H
-#define IFXMIPS_PCIE_VR9_H
-
-#include <linux/types.h>
-#include <linux/delay.h>
-
-#include <linux/gpio.h>
-#include <lantiq_soc.h>
-
-#define IFX_PCIE_GPIO_RESET  238
-
-#define IFX_REG_R32    ltq_r32
-#define IFX_REG_W32    ltq_w32
-#define CONFIG_IFX_PCIE_HW_SWAP
-#define IFX_RCU_AHB_ENDIAN                      ((volatile u32*)(IFX_RCU + 0x004C))
-#define IFX_RCU_RST_REQ                         ((volatile u32*)(IFX_RCU + 0x0010))
-#define IFX_RCU_AHB_BE_PCIE_PDI                  0x00000080  /* Configure PCIE PDI module in big endian*/
-
-#define IFX_RCU                                 (KSEG1 | 0x1F203000)
-#define IFX_RCU_AHB_BE_PCIE_M                    0x00000001  /* Configure AHB master port that connects to PCIe RC in big endian */
-#define IFX_RCU_AHB_BE_PCIE_S                    0x00000010  /* Configure AHB slave port that connects to PCIe RC in little endian */
-#define IFX_RCU_AHB_BE_XBAR_M                    0x00000002  /* Configure AHB master port that connects to XBAR in big endian */
-#define CONFIG_IFX_PCIE_PHY_36MHZ_MODE
-
-#define IFX_PMU1_MODULE_PCIE_PHY   (0)
-#define IFX_PMU1_MODULE_PCIE_CTRL  (1)
-#define IFX_PMU1_MODULE_PDI        (4)
-#define IFX_PMU1_MODULE_MSI        (5)
-
-#define IFX_PMU_MODULE_PCIE_L0_CLK (31)
-
-
-#define IFX_GPIO				(KSEG1 | 0x1E100B00)
-#define ALT0			((volatile u32*)(IFX_GPIO + 0x007c))
-#define ALT1			((volatile u32*)(IFX_GPIO + 0x0080))
-#define OD			((volatile u32*)(IFX_GPIO + 0x0084))
-#define DIR			((volatile u32*)(IFX_GPIO + 0x0078))
-#define OUT			((volatile u32*)(IFX_GPIO + 0x0070))
-
-
-static inline void pcie_ep_gpio_rst_init(int pcie_port)
-{
-
-	gpio_request(IFX_PCIE_GPIO_RESET, "pcie-reset");
-	gpio_direction_output(IFX_PCIE_GPIO_RESET, 1);
-	gpio_set_value(IFX_PCIE_GPIO_RESET, 1);
-
-/*    ifx_gpio_pin_reserve(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
-    ifx_gpio_output_set(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
-    ifx_gpio_dir_out_set(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
-    ifx_gpio_altsel0_clear(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
-    ifx_gpio_altsel1_clear(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
-    ifx_gpio_open_drain_set(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);*/
-}
-
-static inline void pcie_ahb_pmu_setup(void) 
-{
-	/* Enable AHB bus master/slave */
-	struct clk *clk;
-	clk = clk_get_sys("1d900000.pcie", "ahb");
-	clk_enable(clk);
-
-    //AHBM_PMU_SETUP(IFX_PMU_ENABLE);
-    //AHBS_PMU_SETUP(IFX_PMU_ENABLE);
-}
-
-static inline void pcie_rcu_endian_setup(int pcie_port)
-{
-    u32 reg;
-
-    reg = IFX_REG_R32(IFX_RCU_AHB_ENDIAN);
-#ifdef CONFIG_IFX_PCIE_HW_SWAP
-    reg |= IFX_RCU_AHB_BE_PCIE_M;
-    reg |= IFX_RCU_AHB_BE_PCIE_S;
-    reg &= ~IFX_RCU_AHB_BE_XBAR_M;
-#else 
-    reg |= IFX_RCU_AHB_BE_PCIE_M;
-    reg &= ~IFX_RCU_AHB_BE_PCIE_S;
-    reg &= ~IFX_RCU_AHB_BE_XBAR_M;
-#endif /* CONFIG_IFX_PCIE_HW_SWAP */
-    IFX_REG_W32(reg, IFX_RCU_AHB_ENDIAN);
-    IFX_PCIE_PRINT(PCIE_MSG_REG, "%s IFX_RCU_AHB_ENDIAN: 0x%08x\n", __func__, IFX_REG_R32(IFX_RCU_AHB_ENDIAN));
-}
-
-static inline void pcie_phy_pmu_enable(int pcie_port)
-{
-	struct clk *clk;
-	clk = clk_get_sys("1d900000.pcie", "phy");
-	clk_enable(clk);
-
-	//PCIE_PHY_PMU_SETUP(IFX_PMU_ENABLE);
-}
-
-static inline void pcie_phy_pmu_disable(int pcie_port)
-{
-	struct clk *clk;
-	clk = clk_get_sys("1d900000.pcie", "phy");
-	clk_disable(clk);
-
-//    PCIE_PHY_PMU_SETUP(IFX_PMU_DISABLE);
-}
-
-static inline void pcie_pdi_big_endian(int pcie_port)
-{
-    u32 reg;
-
-    /* SRAM2PDI endianness control. */
-    reg = IFX_REG_R32(IFX_RCU_AHB_ENDIAN);
-    /* Config AHB->PCIe and PDI endianness */
-    reg |= IFX_RCU_AHB_BE_PCIE_PDI;
-    IFX_REG_W32(reg, IFX_RCU_AHB_ENDIAN);
-}
-
-static inline void pcie_pdi_pmu_enable(int pcie_port)
-{
-    /* Enable PDI to access PCIe PHY register */
-	struct clk *clk;
-	clk = clk_get_sys("1d900000.pcie", "pdi");
-	clk_enable(clk);
-    //PDI_PMU_SETUP(IFX_PMU_ENABLE);
-}
-
-static inline void pcie_core_rst_assert(int pcie_port)
-{
-    u32 reg;
-
-    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-
-    /* Reset PCIe PHY & Core, bit 22, bit 26 may be affected if write it directly  */
-    reg |= 0x00400000;
-    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-}
-
-static inline void pcie_core_rst_deassert(int pcie_port)
-{
-    u32 reg;
-
-    /* Make sure one micro-second delay */
-    udelay(1);
-
-    /* Reset PCIe PHY & Core, bit 22 */
-    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-    reg &= ~0x00400000;
-    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-}
-
-static inline void pcie_phy_rst_assert(int pcie_port)
-{
-    u32 reg;
-
-    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-    reg |= 0x00001000; /* Bit 12 */
-    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-}
-
-static inline void pcie_phy_rst_deassert(int pcie_port)
-{
-    u32 reg;
-
-    /* Make sure one micro-second delay */
-    udelay(1);
-
-    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-    reg &= ~0x00001000; /* Bit 12 */
-    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-}
-
-static inline void pcie_device_rst_assert(int pcie_port)
-{
-	printk("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
-	gpio_set_value(IFX_PCIE_GPIO_RESET, 0);
-//    ifx_gpio_output_clear(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
-}
-
-static inline void pcie_device_rst_deassert(int pcie_port)
-{
-    mdelay(100);
-    printk("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
-	gpio_direction_output(IFX_PCIE_GPIO_RESET, 1);
-//    gpio_set_value(IFX_PCIE_GPIO_RESET, 1);
-    //ifx_gpio_output_set(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
-}
-
-static inline void pcie_core_pmu_setup(int pcie_port)
-{
-	struct clk *clk;
-	clk = clk_get_sys("1d900000.pcie", "ctl");
-	clk_enable(clk);
-	clk = clk_get_sys("1d900000.pcie", "bus");
-	clk_enable(clk);
-
-    /* PCIe Core controller enabled */
-//    PCIE_CTRL_PMU_SETUP(IFX_PMU_ENABLE);
-
-    /* Enable PCIe L0 Clock */
-//  PCIE_L0_CLK_PMU_SETUP(IFX_PMU_ENABLE);
-}
-
-static inline void pcie_msi_init(int pcie_port)
-{
-	struct clk *clk;
-	pcie_msi_pic_init(pcie_port);
-	clk = clk_get_sys("ltq_pcie", "msi");
-	clk_enable(clk);
-//    MSI_PMU_SETUP(IFX_PMU_ENABLE);
-}
-
-static inline u32
-ifx_pcie_bus_nr_deduct(u32 bus_number, int pcie_port)
-{
-    u32 tbus_number = bus_number;
-
-#ifdef CONFIG_IFX_PCI
-    if (pcibios_host_nr() > 1) {
-        tbus_number -= pcibios_1st_host_bus_nr();
-    }
-#endif /* CONFIG_IFX_PCI */
-    return tbus_number;
-}
-
-static inline u32
-ifx_pcie_bus_enum_hack(struct pci_bus *bus, u32 devfn, int where, u32 value, int pcie_port, int read)
-{
-    struct pci_dev *pdev;
-    u32 tvalue = value;
-
-    /* Sanity check */
-    pdev = pci_get_slot(bus, devfn);
-    if (pdev == NULL) {
-        return tvalue;
-    }
-
-    /* Only care about PCI bridge */
-    if (pdev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {
-        return tvalue;
-    }
-
-    if (read) { /* Read hack */
-    #ifdef CONFIG_IFX_PCI
-        if (pcibios_host_nr() > 1) {
-            tvalue = ifx_pcie_bus_enum_read_hack(where, tvalue);
-        }
-    #endif /* CONFIG_IFX_PCI */  
-    }
-    else { /* Write hack */
-    #ifdef CONFIG_IFX_PCI    
-        if (pcibios_host_nr() > 1) {
-            tvalue = ifx_pcie_bus_enum_write_hack(where, tvalue);
-        }
-    #endif
-    }
-    return tvalue;
-}
-
-#endif /* IFXMIPS_PCIE_VR9_H */
-
diff --git a/arch/mips/pci/pci-lantiq-boot-dev-fw.h b/arch/mips/pci/pci-lantiq-boot-dev-fw.h
new file mode 100755
--- /dev/null
+++ b/arch/mips/pci/pci-lantiq-boot-dev-fw.h
@@ -0,0 +1,589 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2011~2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+
+#ifndef PCI_LANTIQ_BOOT_DEV_FW_H
+#define PCI_LANTIQ_BOOT_DEV_FW_H
+
+static const u32 pci_dev_bm_fw[] = {
+	0x40806000, 0x40809000, 0x40809800, 0x3c0bbf40,
+	0x356b0430, 0x240c0004, 0xad6c0000, 0x3c1dbe22,
+	0x37bd7ff0, 0x0f88800c, 0x0b88800a, 0x00000000,
+	0x27bdffe8, 0xafbf0010, 0x0f8883f0, 0x00000000,
+	0x3c04be22, 0x24841570, 0x0f8883e0, 0x00402821,
+	0x0f8883f5, 0x00000000, 0x3c04be22, 0x24841580,
+	0x0f8883e0, 0x00402821, 0x0f888402, 0x00000000,
+	0x3c04be22, 0x24841598, 0x0f8883e0, 0x00402821,
+	0x0f888409, 0x00000000, 0x3c04be22, 0x248415b4,
+	0x0f8883e0, 0x00402821, 0x0f888416, 0x00000000,
+	0x3c04be22, 0x248415cc, 0x0f8883e0, 0x00402821,
+	0x0f88841d, 0x00000000, 0x0f888439, 0x00000000,
+	0x3c04be22, 0x0f8883e0, 0x248415e8, 0x0f888453,
+	0x00000000, 0x0f88846f, 0x00000000, 0x3c04be22,
+	0x0f8883e0, 0x248415f8, 0x3c029e22, 0x34422000,
+	0x0040f809, 0x00000000, 0x00001021, 0x8fbf0010,
+	0x00000000, 0x03e00008, 0x27bd0018, 0x00000000,
+	0x27bdffe8, 0xafbf0014, 0xafb00010, 0x3c10be22,
+	0x8e041620, 0x00000000, 0x8c820000, 0x2403fffd,
+	0x00431024, 0xac820000, 0x8e041620, 0x00000000,
+	0x8c830000, 0x3c02ffff, 0x344200ff, 0x00621824,
+	0xac830000, 0x8e031620, 0x00000000, 0x8c620000,
+	0x00000000, 0x34420100, 0xac620000, 0x8e021620,
+	0x00000000, 0xac400010, 0x8e021620, 0x00000000,
+	0xac400004, 0x8e031620, 0x00000000, 0x8c620044,
+	0x2404c0ff, 0x00441024, 0xac620044, 0x8e031620,
+	0x00000000, 0x8c620044, 0x00000000, 0x34420100,
+	0xac620044, 0x8e031620, 0x00000000, 0x8c620044,
+	0x00000000, 0x34420001, 0xac620044, 0x8e031620,
+	0x00000000, 0x8c620044, 0x00000000, 0x00441024,
+	0xac620044, 0x8e031620, 0x00000000, 0x8c620044,
+	0x00000000, 0x34420100, 0xac620044, 0x8e031620,
+	0x00000000, 0x8c620040, 0x00000000, 0x34420001,
+	0xac620040, 0x0f888093, 0x00000000, 0x8e041620,
+	0x00000000, 0x8c830018, 0x3c02001a, 0x34420002,
+	0x00621825, 0xac830018, 0x00001021, 0x8fbf0014,
+	0x8fb00010, 0x03e00008, 0x27bd0018, 0x3c02bf10,
+	0x34423010, 0x8c420000, 0x00000000, 0x30430059,
+	0x24020011, 0x1062004a, 0x2c620012, 0x10400012,
+	0x24020048, 0x24020008, 0x10620042, 0x2c620009,
+	0x10400007, 0x24020009, 0x10600029, 0x24020001,
+	0x10620024, 0x3c04be22, 0x10000040, 0x00000000,
+	0x10620023, 0x24020010, 0x10620024, 0x3c04be22,
+	0x1000003a, 0x00000000, 0x10620011, 0x2c620049,
+	0x10400008, 0x24020049, 0x24020040, 0x10620012,
+	0x24020041, 0x1062000d, 0x3c04be22, 0x1000002f,
+	0x00000000, 0x1062000c, 0x24020080, 0x1462002b,
+	0x3c04be22, 0x240701c5, 0x10000028, 0x24060077,
+	0x240701c5, 0x10000024, 0x2406003b, 0x240701fe,
+	0x10000021, 0x2406001d, 0x240701e7, 0x1000001e,
+	0x2406002a, 0x24070044, 0x1000001b, 0x24060007,
+	0x240701b4, 0x10000018, 0x2406004c, 0x3c02bf10,
+	0x34423008, 0x8c430000, 0x240701b4, 0x3c029800,
+	0x3442f25f, 0x10620010, 0x2406004c, 0x3c02bf10,
+	0x34423008, 0x8c430000, 0x240701f8, 0x3c029d26,
+	0x3442f017, 0x10620008, 0x24060068, 0x10000006,
+	0x240701c0, 0x24070097, 0x10000003, 0x24060027,
+	0x240701ba, 0x24060044, 0x3c04be22, 0x8c851620,
+	0x00000000, 0x8ca30010, 0x3c02ffff, 0x34427fff,
+	0x00621824, 0xaca30010, 0x8c831620, 0x00000000,
+	0x8c620010, 0x00000000, 0x34420200, 0xac620010,
+	0x8c831620, 0x30e201ff, 0xac620058, 0x8c821620,
+	0x00000000, 0xac460050, 0x8c831620, 0x00000000,
+	0x8c620010, 0x00000000, 0x34428000, 0xac620010,
+	0x03e00008, 0x00000000, 0x27bdffe8, 0xafbf0014,
+	0xafb00010, 0x00048600, 0x00108603, 0x2402000a,
+	0x16020004, 0x3c02be22, 0x0f888102, 0x2404000d,
+	0x3c02be22, 0x8c431620, 0x24040010, 0x8c620048,
+	0x00000000, 0x30423f00, 0x00021202, 0x1044fffb,
+	0x00000000, 0x3c03be22, 0x8c621620, 0x00000000,
+	0xac500020, 0x8c641620, 0x00000000, 0x8c820014,
+	0x3c030010, 0x00431024, 0x10400005, 0x00000000,
+	0x8c820018, 0x00000000, 0x34420040, 0xac820018,
+	0x8fbf0014, 0x8fb00010, 0x03e00008, 0x27bd0018,
+	0x27bdffe8, 0xafbf0014, 0xafb00010, 0x80820000,
+	0x00000000, 0x10400008, 0x00808021, 0x82040000,
+	0x0f888102, 0x26100001, 0x82020000, 0x00000000,
+	0x1440fffa, 0x00000000, 0x8fbf0014, 0x8fb00010,
+	0x03e00008, 0x27bd0018, 0x3c02be22, 0x8c431620,
+	0x00000000, 0x8c620048, 0x00000000, 0x3042003f,
+	0x1040fffc, 0x3c02be22, 0x8c421620, 0x00000000,
+	0x8c420024, 0x00000000, 0x00021600, 0x03e00008,
+	0x00021603, 0x3c02be22, 0x8c431620, 0x00000000,
+	0x8c620048, 0x00000000, 0x3042003f, 0x1040fffc,
+	0x3c02be22, 0x8c421620, 0x00000000, 0x8c420024,
+	0x00000000, 0x00021600, 0x03e00008, 0x00021603,
+	0x3c02be22, 0x8c421620, 0x00000000, 0x8c420048,
+	0x00000000, 0x3042003f, 0x03e00008, 0x0002102b,
+	0x03e00008, 0x24020001, 0x03e00008, 0x24020001,
+	0x27bdff78, 0xafbf0080, 0xafb3007c, 0xafb20078,
+	0xafb10074, 0xafb00070, 0x00809021, 0x00a09821,
+	0x00c08021, 0x00e08821, 0x82020000, 0x00000000,
+	0x0002182b, 0x38420025, 0x0002102b, 0x00621824,
+	0x1060000a, 0x02003021, 0x26100001, 0x82020000,
+	0x00000000, 0x0002182b, 0x38420025, 0x0002102b,
+	0x00621824, 0x1460fff8, 0x00000000, 0x02061023,
+	0x2c420051, 0x14400007, 0x02602021, 0x3c05be22,
+	0x24a51360, 0x0240f809, 0x24060018, 0x1000ffff,
+	0x00000000, 0x00c02821, 0x0240f809, 0x02063023,
+	0x82020000, 0x00000000, 0x10400158, 0x26100001,
+	0x82030000, 0x2402006c, 0x14620003, 0x00002021,
+	0x24040001, 0x26100001, 0x00003021, 0x00004021,
+	0x82030000, 0x2402002d, 0x14620004, 0x24090020,
+	0x24080001, 0x26100001, 0x82030000, 0x24020030,
+	0x14620003, 0x00000000, 0x24090030, 0x26100001,
+	0x92020000, 0x00000000, 0x2442ffd0, 0x304200ff,
+	0x2c42000a, 0x1040000f, 0x00061080, 0x00461021,
+	0x00021040, 0x82030000, 0x00000000, 0x00431021,
+	0x2446ffd0, 0x26100001, 0x92020000, 0x00000000,
+	0x2442ffd0, 0x304200ff, 0x2c42000a, 0x1440fff3,
+	0x00061080, 0x82030000, 0x2402002e, 0x14620014,
+	0x2c620079, 0x26100001, 0x92020000, 0x00000000,
+	0x2442ffd0, 0x304200ff, 0x2c42000a, 0x10400009,
+	0x00000000, 0x26100001, 0x92020000, 0x00000000,
+	0x2442ffd0, 0x304200ff, 0x2c42000a, 0x1440fff9,
+	0x00000000, 0x82030000, 0x00000000, 0x2c620079,
+	0x10400110, 0x00003821, 0x00031080, 0x3c03be22,
+	0x24631380, 0x00431021, 0x8c420000, 0x00000000,
+	0x00400008, 0x00000000, 0x10800007, 0x2402fffc,
+	0x26310003, 0x02228824, 0x02201021, 0x8c450000,
+	0x10000006, 0x26310004, 0x26310003, 0x02228824,
+	0x02201021, 0x26310004, 0x8c450000, 0xafa60010,
+	0xafa80014, 0xafa90018, 0xafa0001c, 0x27a40020,
+	0x24060002, 0x0f888358, 0x00003821, 0x00403021,
+	0x2c420051, 0x14400007, 0x02602021, 0x3c05be22,
+	0x24a51360, 0x0240f809, 0x24060018, 0x1000ffff,
+	0x00000000, 0x0240f809, 0x27a50020, 0x1000ff72,
+	0x26100001, 0x10800007, 0x2402fffc, 0x26310003,
+	0x02228824, 0x02201021, 0x8c450000, 0x10000007,
+	0x26310004, 0x26310003, 0x02228824, 0x02201021,
+	0x26310004, 0x8c450000, 0x00000000, 0x04a10003,
+	0x00000000, 0x00052823, 0x24070001, 0xafa60010,
+	0xafa80014, 0xafa90018, 0xafa0001c, 0x27a40020,
+	0x0f888358, 0x2406000a, 0x00403021, 0x2c420051,
+	0x14400007, 0x02602021, 0x3c05be22, 0x24a51360,
+	0x0240f809, 0x24060018, 0x1000ffff, 0x00000000,
+	0x0240f809, 0x27a50020, 0x1000ff4b, 0x26100001,
+	0x10800007, 0x2402fffc, 0x26310003, 0x02228824,
+	0x02201021, 0x8c450000, 0x10000006, 0x26310004,
+	0x26310003, 0x02228824, 0x02201021, 0x26310004,
+	0x8c450000, 0xafa60010, 0xafa80014, 0xafa90018,
+	0xafa0001c, 0x27a40020, 0x24060008, 0x0f888358,
+	0x00003821, 0x00403021, 0x2c420051, 0x14400007,
+	0x02602021, 0x3c05be22, 0x24a51360, 0x0240f809,
+	0x24060018, 0x1000ffff, 0x00000000, 0x0240f809,
+	0x27a50020, 0x1000ff28, 0x26100001, 0x10800007,
+	0x2402fffc, 0x26310003, 0x02228824, 0x02201021,
+	0x8c450000, 0x10000006, 0x26310004, 0x26310003,
+	0x02228824, 0x02201021, 0x26310004, 0x8c450000,
+	0xafa60010, 0xafa80014, 0xafa90018, 0xafa0001c,
+	0x27a40020, 0x2406000a, 0x0f888358, 0x00003821,
+	0x00403021, 0x2c420051, 0x14400007, 0x02602021,
+	0x3c05be22, 0x24a51360, 0x0240f809, 0x24060018,
+	0x1000ffff, 0x00000000, 0x0240f809, 0x27a50020,
+	0x1000ff05, 0x26100001, 0x10800007, 0x2402fffc,
+	0x26310003, 0x02228824, 0x02201021, 0x8c450000,
+	0x10000006, 0x26310004, 0x26310003, 0x02228824,
+	0x02201021, 0x26310004, 0x8c450000, 0xafa60010,
+	0xafa80014, 0xafa90018, 0xafa0001c, 0x27a40020,
+	0x24060010, 0x0f888358, 0x00003821, 0x00403021,
+	0x2c420051, 0x14400007, 0x02602021, 0x3c05be22,
+	0x24a51360, 0x0240f809, 0x24060018, 0x1000ffff,
+	0x00000000, 0x0240f809, 0x27a50020, 0x1000fee2,
+	0x26100001, 0x10800007, 0x2402fffc, 0x26310003,
+	0x02228824, 0x02201021, 0x8c450000, 0x10000006,
+	0x26310004, 0x26310003, 0x02228824, 0x02201021,
+	0x26310004, 0x8c450000, 0xafa60010, 0xafa80014,
+	0xafa90018, 0x24020001, 0xafa2001c, 0x27a40020,
+	0x24060010, 0x0f888358, 0x00003821, 0x00403021,
+	0x2c420051, 0x14400007, 0x02602021, 0x3c05be22,
+	0x24a51360, 0x0240f809, 0x24060018, 0x1000ffff,
+	0x00000000, 0x0240f809, 0x27a50020, 0x1000febe,
+	0x26100001, 0x26310003, 0x2402fffc, 0x02228824,
+	0x02201021, 0x26310004, 0x27a40020, 0x80450003,
+	0x0f8882f3, 0x01003821, 0x00403021, 0x2c420051,
+	0x14400007, 0x02602021, 0x3c05be22, 0x24a51360,
+	0x0240f809, 0x24060018, 0x1000ffff, 0x00000000,
+	0x0240f809, 0x27a50020, 0x1000fea7, 0x26100001,
+	0x26310003, 0x2402fffc, 0x02228824, 0x02201021,
+	0x26310004, 0x27a40020, 0x8c450000, 0x0f888315,
+	0x01003821, 0x00403021, 0x2c420051, 0x14400007,
+	0x02602021, 0x3c05be22, 0x24a51360, 0x0240f809,
+	0x24060018, 0x1000ffff, 0x00000000, 0x0240f809,
+	0x27a50020, 0x1000fe90, 0x26100001, 0x10000005,
+	0x2610ffff, 0x02602021, 0x02002821, 0x0240f809,
+	0x24060001, 0x1000fe88, 0x26100001, 0x02602021,
+	0x3c05be22, 0x24a5137c, 0x0240f809, 0x24060001,
+	0x8fbf0080, 0x8fb3007c, 0x8fb20078, 0x8fb10074,
+	0x8fb00070, 0x03e00008, 0x27bd0088, 0x00052e00,
+	0x1cc00002, 0x00052e03, 0x24060001, 0x10e0000e,
+	0x24c2ffff, 0x24030001, 0x0066102a, 0x10400016,
+	0xa0850000, 0x24050020, 0x00831021, 0xa0450000,
+	0x24630001, 0x0066102a, 0x1440fffb, 0x00c01021,
+	0x1000000e, 0x00000000, 0x00403821, 0x18400008,
+	0x00001821, 0x24080020, 0x00831021, 0xa0480000,
+	0x24630001, 0x0067102a, 0x1440fffb, 0x00000000,
+	0x00861021, 0xa045ffff, 0x00c01021, 0x03e00008,
+	0x00000000, 0x00004021, 0x80a20000, 0x00000000,
+	0x10400006, 0x24a30001, 0x25080001, 0x90620000,
+	0x00000000, 0x1440fffc, 0x24630001, 0x00c8102a,
+	0x10400002, 0x00000000, 0x01003021, 0x10e00018,
+	0x00c81023, 0x1900000a, 0x00003821, 0x00871821,
+	0x00a71021, 0x90420000, 0x00000000, 0xa0620000,
+	0x24e70001, 0x00e8102a, 0x1440fff9, 0x00871821,
+	0x0106102a, 0x10400023, 0x01003821, 0x24030020,
+	0x00871021, 0xa0430000, 0x24e70001, 0x00e6102a,
+	0x1440fffb, 0x00c01021, 0x1000001b, 0x00000000,
+	0x00401821, 0x18400008, 0x00003821, 0x24090020,
+	0x00871021, 0xa0490000, 0x24e70001, 0x00e3102a,
+	0x1440fffc, 0x00871021, 0x00c83823, 0x00e6102a,
+	0x1040000d, 0x00c01021, 0x00871821, 0x00e61023,
+	0x00451021, 0x00481021, 0x90420000, 0x00000000,
+	0xa0620000, 0x24e70001, 0x00e6102a, 0x1440fff7,
+	0x00871821, 0x00c01021, 0x03e00008, 0x00000000,
+	0x00804821, 0x8fa80010, 0x8fac0014, 0x8fab001c,
+	0x83aa001b, 0x00a6001b, 0x14c00002, 0x00000000,
+	0x0007000d, 0x00001810, 0x2862000a, 0x10400004,
+	0x24620030, 0xa0820000, 0x10000009, 0x24840001,
+	0x11600005, 0x24620057, 0x24620037, 0xa0820000,
+	0x10000003, 0x24840001, 0xa0820000, 0x24840001,
+	0x00a6001b, 0x14c00002, 0x00000000, 0x0007000d,
+	0x00002812, 0x14a0ffe7, 0x00000000, 0x10e00003,
+	0x2402002d, 0xa0820000, 0x24840001, 0x00892023,
+	0x0104102a, 0x10400002, 0x00000000, 0x00804021,
+	0x11800002, 0x0007102b, 0x240a0020, 0x2d830001,
+	0x00431024, 0x10400013, 0x0088102a, 0x24020030,
+	0x15420010, 0x0088102a, 0x2483ffff, 0x2502ffff,
+	0x00402821, 0x0062102a, 0x10400006, 0x01231021,
+	0xa04a0000, 0x24630001, 0x0065102a, 0x1440fffc,
+	0x01231021, 0x01281821, 0x2402002d, 0x10000009,
+	0xa062ffff, 0x10400007, 0x00801821, 0x01231021,
+	0xa04a0000, 0x24630001, 0x0068102a, 0x1440fffc,
+	0x01231021, 0x00003821, 0x15800002, 0x2486ffff,
+	0x2506ffff, 0x00e6102a, 0x1040000c, 0x00000000,
+	0x01272021, 0x80850000, 0x01261821, 0x90620000,
+	0x00000000, 0xa0820000, 0x24e70001, 0x24c6ffff,
+	0x00e6102a, 0x1440fff6, 0xa0650000, 0x03e00008,
+	0x01001021, 0x00000000, 0x00000000, 0x00000000,
+	0x27bdffd8, 0xafbf0024, 0xafb40020, 0xafb3001c,
+	0xafb20018, 0xafb10014, 0xafb00010, 0x00a0a021,
+	0x24020001, 0x14c20005, 0x00c09021, 0x80a20000,
+	0x00000000, 0x10400012, 0x00000000, 0x1a400010,
+	0x00008821, 0x2413000a, 0x02918021, 0x82040000,
+	0x0f888102, 0x00000000, 0x82020000, 0x00000000,
+	0x14530003, 0x00000000, 0x0f888102, 0x2404000d,
+	0x26310001, 0x0232102a, 0x1440fff4, 0x02918021,
+	0x8fbf0024, 0x8fb40020, 0x8fb3001c, 0x8fb20018,
+	0x8fb10014, 0x8fb00010, 0x03e00008, 0x27bd0028,
+	0x27bdffe8, 0xafbf0010, 0xafa5001c, 0xafa60020,
+	0xafa70024, 0x00803021, 0x3c04be22, 0x24840ee0,
+	0x00002821, 0x0f888164, 0x27a7001c, 0x8fbf0010,
+	0x00000000, 0x03e00008, 0x27bd0018, 0x00000000,
+	0x40027800, 0x00000000, 0x00021202, 0x03e00008,
+	0x304200ff, 0x40038001, 0x00000000, 0x00032402,
+	0x30840007, 0x24840001, 0x00031d82, 0x30630007,
+	0x24020040, 0x00621004, 0x00820018, 0x00001012,
+	0x03e00008, 0x00000000, 0x40028001, 0x00000000,
+	0x000214c2, 0x30420007, 0x24030002, 0x03e00008,
+	0x00431004, 0x40038001, 0x00000000, 0x30640380,
+	0x000421c2, 0x24840001, 0x3063e000, 0x00031b42,
+	0x24020040, 0x00621004, 0x00820018, 0x00001012,
+	0x03e00008, 0x00000000, 0x40028001, 0x00000000,
+	0x30421c00, 0x00021282, 0x24030002, 0x03e00008,
+	0x00431004, 0x27bdffe0, 0xafbf001c, 0xafb20018,
+	0xafb10014, 0x0f888402, 0xafb00010, 0x00409021,
+	0x0f8883f5, 0x3c108000, 0x00520018, 0x00008812,
+	0x0f8883f0, 0x02308821, 0x4080e000, 0x0211102b,
+	0x10400006, 0x00000000, 0xbe080000, 0x02128021,
+	0x0211102b, 0x1440fffc, 0x00000000, 0x8fbf001c,
+	0x8fb20018, 0x8fb10014, 0x8fb00010, 0x03e00008,
+	0x27bd0020, 0x27bdffe0, 0xafbf0018, 0xafb10014,
+	0x0f888402, 0xafb00010, 0x0f8883f5, 0x00408821,
+	0x00510018, 0x00008012, 0x3c029fc0, 0x0f8883f0,
+	0x02028021, 0x3c039fc0, 0x0203102b, 0x14400006,
+	0x00000000, 0xbc7c0000, 0x00711821, 0x0203102b,
+	0x1040fffc, 0x00000000, 0x8fbf0018, 0x8fb10014,
+	0x8fb00010, 0x03e00008, 0x27bd0020, 0x27bdffe0,
+	0xafbf001c, 0xafb20018, 0xafb10014, 0x0f888416,
+	0xafb00010, 0x00409021, 0x0f888409, 0x3c109fc0,
+	0x00520018, 0x00008812, 0x0f8883f0, 0x02308821,
+	0x4080e002, 0x0211102b, 0x10400006, 0x00000000,
+	0xbe090000, 0x02128021, 0x0211102b, 0x1440fffc,
+	0x00000000, 0x8fbf001c, 0x8fb20018, 0x8fb10014,
+	0x8fb00010, 0x03e00008, 0x27bd0020, 0x27bdffe0,
+	0xafbf0018, 0xafb10014, 0x0f888416, 0xafb00010,
+	0x0f888409, 0x00408821, 0x00510018, 0x00008012,
+	0x3c029fc0, 0x0f8883f0, 0x02028021, 0x3c039fc0,
+	0x0203102b, 0x14400006, 0x00000000, 0xbc7d0000,
+	0x00711821, 0x0203102b, 0x1040fffc, 0x00000000,
+	0x8fbf0018, 0x8fb10014, 0x8fb00010, 0x03e00008,
+	0x27bd0020, 0x27bdffe0, 0xafbf0018, 0xafb10014,
+	0xafb00010, 0x00808021, 0x0f888416, 0x00a08821,
+	0x00402021, 0x00021823, 0x00701824, 0x02118021,
+	0x2610ffff, 0x00021023, 0x02028024, 0xbc750000,
+	0xbc700000, 0x1470fffd, 0x00641821, 0x8fbf0018,
+	0x8fb10014, 0x8fb00010, 0x03e00008, 0x27bd0020,
+	0x27bdffe0, 0xafbf0018, 0xafb10014, 0xafb00010,
+	0x00808021, 0x0f888416, 0x00a08821, 0x00402021,
+	0x00021823, 0x00701824, 0x2631ffff, 0x00021023,
+	0x02228824, 0xbc750000, 0x1471fffe, 0x00641821,
+	0x8fbf0018, 0x8fb10014, 0x8fb00010, 0x03e00008,
+	0x27bd0020, 0x27bdffe0, 0xafbf0018, 0xafb10014,
+	0xafb00010, 0x00808021, 0x0f888416, 0x00a08821,
+	0x00402021, 0x00021823, 0x00701824, 0x2631ffff,
+	0x00021023, 0x02228824, 0xbc710000, 0x1471fffe,
+	0x00641821, 0x8fbf0018, 0x8fb10014, 0x8fb00010,
+	0x03e00008, 0x27bd0020, 0x8fa20010, 0x40871000,
+	0x00000000, 0x40852800, 0x00000000, 0x40821800,
+	0x00000000, 0x40865000, 0x00000000, 0x40840000,
+	0x42000002, 0x03e00008, 0x00000000, 0x00000000,
+	0x66617461, 0x6c206572, 0x726f7220, 0x696e206c,
+	0x705f5072, 0x696e7421, 0x00000000, 0x00000000,
+	0xbe220b7c, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe2207f4, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220890,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe22091c, 0xbe220b84, 0xbe220b84,
+	0xbe220a34, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220768, 0xbe220ac4,
+	0xbe2207f4, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b84,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220890,
+	0xbe220b84, 0xbe220b84, 0xbe220b84, 0xbe220b20,
+	0xbe220b84, 0xbe22091c, 0xbe220b84, 0xbe220b84,
+	0xbe2209a8, 0x00000000, 0x00000000, 0x00000000,
+	0x6370755f, 0x69643d30, 0x78253038, 0x780a0000,
+	0x69636163, 0x68655f6c, 0x696e6573, 0x3d307825,
+	0x3038780a, 0x00000000, 0x69636163, 0x68655f6c,
+	0x696e655f, 0x73697a65, 0x3d307825, 0x3038780a,
+	0x00000000, 0x64636163, 0x68655f6c, 0x696e6573,
+	0x3d307825, 0x3038780a, 0x00000000, 0x64636163,
+	0x68655f6c, 0x696e655f, 0x73697a65, 0x3d307825,
+	0x3038780a, 0x00000000, 0x69636163, 0x6865206c,
+	0x6f636b65, 0x64210a00, 0x64636163, 0x6865206c,
+	0x6f636b65, 0x64210a00, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0xbe100c00, 0x01b4004c, 0x01a30024, 0x01c5003f,
+	0x01c5001f, 0x01f5003a, 0x01fe001d, 0x01a30000,
+	0x01c50013, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x3c0bbf40, 0x356b0430, 0x240c0004, 0xad6c0000,
+	0x10000003, 0x00000000, 0x00000000, 0x00000000,
+	0x3c089fc0, 0x35082000, 0x251d0000, 0x3c1c9e22,
+	0x279c23e0, 0x3c089e22, 0x250823e0, 0x3c099fc0,
+	0x25290000, 0x3c0a9fc0, 0x254a0000, 0x112a000e,
+	0x00000000, 0x8d0b0000, 0x21080004, 0xad2b0000,
+	0x152afffc, 0x21290004, 0x3c089fc0, 0x25080000,
+	0x3c099fc0, 0x25290000, 0x2529fffc, 0xad000000,
+	0x1509fffe, 0x21080004, 0x3c199e22, 0x27392098,
+	0x03200008, 0x00000000, 0x3c09bf10, 0x27bdffe0,
+	0x352b201c, 0xafbf0018, 0x8d620000, 0x2404fdff,
+	0x00441824, 0xad630000, 0x8d780000, 0x3c1fce13,
+	0x37f9ffff, 0x03197824, 0xad6f0000, 0x8d6d0000,
+	0x240effdf, 0x01ae6024, 0xad6c0000, 0x8d670000,
+	0x3c0a0c00, 0x3548004d, 0x00e82825, 0xad650000,
+	0x8d660000, 0x3c1f0003, 0x34c40180, 0xad640000,
+	0x8d620000, 0x37f98000, 0x34431800, 0xad630000,
+	0x8d780000, 0x3c0e8210, 0x03197825, 0xad6f0000,
+	0x8d6d0000, 0x35272024, 0x01ae6025, 0xad6c0000,
+	0x8cea0000, 0x35232100, 0x35480001, 0x35262204,
+	0x240500ff, 0x24040010, 0x24020012, 0xace80000,
+	0xacc50000, 0xac640000, 0xac620000, 0xafa00010,
+	0x8fab0010, 0x29690064, 0x11200005, 0x00000000,
+	0x8fa50010, 0x24a60001, 0x1000fff9, 0xafa60010,
+	0x0f888865, 0x00000000, 0x42000020, 0x1000fffe,
+	0x00000000, 0x3c09bf10, 0x27bdfff8, 0x24020001,
+	0x35253020, 0x3527300c, 0x35263010, 0x24080032,
+	0x3c040001, 0xace80000, 0xacc40000, 0xaca20000,
+	0xafa00000, 0x3c030003, 0x8fa20000, 0x3463ffff,
+	0x0062502a, 0x15400007, 0x00000000, 0x8fac0000,
+	0x258b0001, 0xafab0000, 0x8fa20000, 0x1000fff9,
+	0x0062502a, 0x3c0abf40, 0x35470430, 0x8ce80000,
+	0x2409fffd, 0x01091024, 0x3c05bf10, 0xace20000,
+	0x34ad3024, 0x8da30000, 0x3c04fffe, 0x3486ffff,
+	0x3c19fe0f, 0x00667824, 0x3738ffff, 0x01f87024,
+	0xadae0000, 0x34b93038, 0x8f2a0000, 0x3c0c7fff,
+	0x358bffff, 0x3c09ff1f, 0x014b3824, 0x3528ffff,
+	0x3c06be10, 0x00e82024, 0x3c020080, 0x00821825,
+	0x34cd5430, 0x34cf5400, 0x24180002, 0x240e0103,
+	0xaf230000, 0xadf80000, 0xadae0000, 0xafa00000,
+	0x8fac0000, 0x298b000a, 0x11600006, 0x3c19000e,
+	0x8fad0000, 0x25a50001, 0xafa50000, 0x1000fff8,
+	0x00000000, 0x3c18be10, 0x372f0c01, 0x370e5480,
+	0xadcf0000, 0xafa00000, 0x8fa60000, 0x28c3000a,
+	0x10600006, 0x3c03be10, 0x8fa70000, 0x24e40001,
+	0xafa40000, 0x1000fff8, 0x00000000, 0x346554c0,
+	0x346954c4, 0x346854c8, 0x3c18b800, 0x3c0ab840,
+	0x3c02b880, 0xacb80000, 0xad2a0000, 0xad020000,
+	0x3c080100, 0x346c5430, 0x346754cc, 0x347954d0,
+	0x346f54d4, 0x346e54d8, 0x346b54dc, 0x346d54e8,
+	0x3c04b8c0, 0x3c06b900, 0x3c18b940, 0x3c05b980,
+	0x3c0ab9c0, 0x24090303, 0x35020103, 0xace40000,
+	0xaf260000, 0xadf80000, 0xadc50000, 0xad6a0000,
+	0xada90000, 0xad820000, 0xafa00000, 0x8fad0000,
+	0x29ac0064, 0x11800006, 0x3c04bf20, 0x8fae0000,
+	0x25cb0001, 0xafab0000, 0x1000fff8, 0x00000000,
+	0x348f3028, 0x8de60000, 0x2407fffe, 0x00c7c824,
+	0xadf90000, 0xafa00000, 0x8fa20000, 0x28480064,
+	0x11000006, 0x3c03bf40, 0x8faa0000, 0x25490001,
+	0xafa90000, 0x1000fff8, 0x00000000, 0x34650430,
+	0x8cac0000, 0x27bd0008, 0x35980002, 0xacb80000,
+	0x03e00008, 0x00000000, 0xffffffff, 0xffffffff,
+};
+#endif /* PCI_LANTIQ_BOOT_DEV_FW_H */
+
diff --git a/arch/mips/pci/pci-lantiq-boot.c b/arch/mips/pci/pci-lantiq-boot.c
new file mode 100755
--- /dev/null
+++ b/arch/mips/pci/pci-lantiq-boot.c
@@ -0,0 +1,498 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2011~2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/of_pci.h>
+
+#include <linux/gpio.h>
+#include <asm/addrspace.h>
+
+#include <lantiq.h>
+#include <lantiq_soc.h>
+#include <lantiq_irq.h>
+
+#include "pci-lantiq-boot-dev-fw.h"
+
+
+#define ltq_pci_w32(x, y)	ltq_w32((x), ltq_pci_membase + (y))
+#define ltq_pci_r32(x)		ltq_r32(ltq_pci_membase + (x))
+
+#define ltq_pci_w32_mask(clr, set, off)			\
+	ltq_pci_w32((ltq_pci_r32(off) & ~(clr))		\
+		| (set), (off));			\
+
+
+#define ltq_pci_cfg_w32(x, y)	ltq_w32((x), ltq_pci_mapped_cfg + (y))
+#define ltq_pci_cfg_r32(x)	ltq_r32(ltq_pci_mapped_cfg + (x))
+
+#define MS(_v, _f)  (((_v) & (_f)) >> _f##_S)
+#define SM(_v, _f)  (((_v) << _f##_S) & (_f))
+
+
+/* Bonding daughter board IDSEL 30, family board IDSEL 29 */
+#define PCI_BOOT_DEV_IDSEL			30
+/*
+ * FPI ==> PCI MEM address mapping
+ * base: 0xb8000000 == > 0x1e000001
+ * size: 8x4M = 32M
+ */
+#define PCI_BOOT_FPI_BASE			0x1E000001
+#define PCI_BOOT_SRAM_BASE			0x1F000000
+#define PCI_BOOT_BLOCK_SIZE			0x00400000
+
+/* The following three window base must match PCI device outbound
+   window configuration */
+#define PCI_INBOUND_WINDOW_ONE_BASE		0xB8000000
+#define PCI_INBOUND_WINDOW_TWO_BASE		0xB9000000
+#define PCI_INBOUND_WINDOW_THREE_BASE		0xB9400000
+
+#define PCI_INBOUND_WINDOW_ONE_16MB_DDR_BASE	0x01000000
+#define PCI_INBOUND_WINDOW_ONE_14MB_DDR_BASE	0x0e000000
+
+#define PCI_INBOUND_WINDOW_TWO_SRAM_BASE	0x1f000000
+#define PCI_INBOUND_WINDOW_THREE_FPI_BASE	0x1e000000
+
+#define PCI_BOOT_DEV_BAR2_BASE			0x10000000
+
+#define PCI_DEV_PPE_ADDR			0xb8220000 /* 0x1e220000 */
+#define PCI_DEV_PPE_LOCAL_ADDR			0xbe220000
+/*
+ * Access PCI device MPS register 0xbf2001c0 which is equal to 0x1f2001c0
+ * ->host side  0xb92001c0 as the miniloader entry address 0xbe220000
+ */
+#define PCI_BOOT_DEV_MPS_ENTRY			(u32 *)(0xb92001c0)
+
+/*
+ * Program PCI device PCI_RDY bit so that bootrom can start miniloader
+ * PCI device RDY is in 0xbf203028 which mapped into host side as 0xb9203028
+ */
+#define PCI_BOOT_DEV_RDY			(u32 *)(0xb9203028)
+#define PCI_BOOT_READY				0x00000001
+
+#define PCI_BOOT_POR_OUT			(u32 *)(0xbe100b10)
+#define PCI_BOOT_PORT_RST			0x00008000
+
+
+/* PCI Host Controller Register */
+#define PCI_CLK_CTRL				0x0000
+
+#define PCI_CLK_CTRL_FPI_CLK_DIS		BIT(0)
+#define PCI_CLK_CTRL_EBU_PCI_SWITCH_EN		BIT(1)
+#define PCI_CLK_CTRL_FIXED_ARB_EN		BIT(2)
+#define PCI_CLK_CTRL_FPI_NORMAL_ACK		BIT(3)
+
+#define PCI_MOD					0x0030
+#define PCI_MOD_CFG_OK				BIT(24)
+
+#define PCI_BAR11MASK				0x0044
+#define PCI_BAR12MASK				0x0048
+#define PCI_BAR13MASK				0x004C
+
+#define PCI_ADDR_MAP11				0x0064
+#define PCI_ADDR_MAP12				0x0068
+#define PCI_ADDR_MAP13				0x006C
+#define PCI_ADDR_MAP_SUPERVISOR			BIT(0)
+
+#define PCI_ARB					0x0080
+
+#define PCI_ARB_INTERNAL_EN			0x00000001
+#define PCI_ARB_FIXED_EN			0x00000002
+#define PCI_ARB_MASTER_REQ0			0x0000000C
+#define PCI_ARB_MASTER_REQ0_S			2
+#define PCI_ARB_MASTER_REQ1			0x00000030
+#define PCI_ARB_MASTER_REQ1_S			4
+#define PCI_ARB_MASTER_REQ2			0x000000C0
+#define PCI_ARB_MASTER_REQ2_S			6
+#define PCI_ARB_PCI_MASTER_REQ0			0x00000300
+#define PCI_ARB_PCI_MASTER_REQ0_S		8
+#define PCI_ARB_PCI_MASTER_REQ1			0x00000C00
+#define PCI_ARB_PCI_MASTER_REQ1_S		10
+#define PCI_ARB_PCI_MASTER_REQ2			0x00003000
+#define PCI_ARB_PCI_MASTER_REQ2_S		12
+#define PCI_ARB_PCI_PORT_ARB			0x000F0000
+#define PCI_ARB_PCI_PORT_ARB_S			16
+#define PCI_ARB_PCI_NOT_READY			0x00100000
+#define PCI_ARB_PCI_NO_FRM			0x00200000
+#define PCI_ARB_EBU_IDLE			0x00400000
+#define PCI_ART_PCI_IDLE			\
+	(PCI_ARB_PCI_NOT_READY | PCI_ARB_PCI_NO_FRM)
+
+#define PCI_FPI_ADDR_MAP0			0x00C0
+#define PCI_FPI_ADDR_MAP1			0x00C4
+#define PCI_FPI_ADDR_MAP2			0x00C8
+#define PCI_FPI_ADDR_MAP3			0x00CC
+#define PCI_FPI_ADDR_MAP4			0x00D0
+#define PCI_FPI_ADDR_MAP5			0x00D4
+#define PCI_FPI_ADDR_MAP6			0x00D8
+#define PCI_FPI_ADDR_MAP7			0x00DC
+#define PCI_FPI_BURST_LENGTH			0x00E8
+#define PCI_FPI_RD_BURST_LEN		0x00000003
+#define PCI_FPI_RD_BURST_LEN_S		0
+#define PCI_FPI_WR_BURST_LEN		0x00000300
+#define PCI_FPI_WR_BURST_LEN_S		8
+
+enum {
+	PCI_FPI_BURST_LEN1 = 0,
+	PCI_FPI_BURST_LEN2,
+	PCI_FPI_BURST_LEN4,
+	PCI_FPI_BURST_LEN8,
+};
+
+/* Configuration space */
+#define PCI_CMD				0x0004
+#define PCI_CMD_IO_EN			BIT(0)
+#define PCI_CMD_MEM_EN			BIT(1)
+#define PCI_CMD_MASTER_EN		BIT(2)
+#define PCI_BAR1			0x0010
+#define PCI_BAR2			0x0014
+#define PCI_BAR3			0x0018
+
+
+static __iomem void *ltq_pci_mapped_cfg;
+static __iomem void *ltq_pci_membase;
+
+#define PCI_BOOT_VER "2.0.0"
+
+static int pci_dev_rst(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	int reset_gpio;
+
+	reset_gpio = of_get_named_gpio(node, "gpio-reset", 0);
+	if (gpio_is_valid(reset_gpio)) {
+		int ret = devm_gpio_request(&pdev->dev,
+						reset_gpio, "pci-reset");
+		if (ret) {
+			dev_err(&pdev->dev,
+				"failed to request gpio %d\n", reset_gpio);
+			return ret;
+		}
+		gpio_direction_output(reset_gpio, 1);
+		__gpio_set_value(reset_gpio, 1);
+		mdelay(1);
+		if (gpio_is_valid(reset_gpio)) {
+			__gpio_set_value(reset_gpio, 0);
+			wmb();
+			mdelay(5);
+			__gpio_set_value(reset_gpio, 1);
+				smp_wmb();
+			mdelay(1);
+		}
+		return 0;
+	}
+	return -EIO;
+}
+
+static void pci_host_por_out(void)
+{
+	u32 reg;
+	reg = ltq_r32(PCI_BOOT_POR_OUT);
+	reg |= PCI_BOOT_PORT_RST;
+	ltq_w32(reg, PCI_BOOT_POR_OUT);
+	mdelay(5);
+}
+
+#define CGU_PCI_CR		0x0038
+#define PCI_DELAY_SHIFT		21
+#define PCI_DELAY_MASK		(0x7 << PCI_DELAY_SHIFT)
+#define LTQ_PCI_RESET_DOMAIN	BIT(13)
+
+static int pci_host_init(struct platform_device *pdev)
+{
+	u32 reg;
+	u32 devaddr;
+	struct device_node *node = pdev->dev.of_node;
+	const __be32 *bus_clk, *delay_hi;
+	struct clk *clk_pci, *clk_external;
+
+	/* get our clocks */
+	clk_pci = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(clk_pci)) {
+		dev_err(&pdev->dev, "failed to get pci clock\n");
+		return PTR_ERR(clk_pci);
+	}
+
+	clk_external = clk_get(&pdev->dev, "external");
+	if (IS_ERR(clk_external)) {
+		clk_put(clk_pci);
+		dev_err(&pdev->dev, "failed to get external pci clock\n");
+		return PTR_ERR(clk_external);
+	}
+	if (of_find_property(node, "lantiq,external-clock", NULL))
+		clk_enable(clk_external);
+	else
+		clk_disable(clk_external);
+
+	/* read the bus speed that we want */
+	bus_clk = of_get_property(node, "lantiq,bus-clock", NULL);
+	if (bus_clk)
+		clk_set_rate(clk_pci, *bus_clk);
+
+	ltq_hw_reset(LTQ_PCI_RESET_DOMAIN);
+	/* and enable the clocks */
+	clk_enable(clk_pci);
+
+	delay_hi = of_get_property(node, "lantiq,delay-hi", NULL);
+	if (delay_hi)
+		ltq_cgu_w32((ltq_cgu_r32(CGU_PCI_CR) & ~PCI_DELAY_MASK)
+			| *delay_hi, CGU_PCI_CR);
+	udelay(1);
+
+	reg = PCI_CLK_CTRL_EBU_PCI_SWITCH_EN | PCI_CLK_CTRL_FPI_NORMAL_ACK;
+	/* Enable auto-switching between PCI and EBU, normal ack */
+	ltq_pci_w32(reg, PCI_CLK_CTRL);
+
+	/* Configuration mode, i.e. configuration is not done,
+	   PCI access has to be retried */
+	ltq_pci_w32_mask(PCI_MOD_CFG_OK, 0, PCI_MOD);
+	smp_wmb();
+	reg = ltq_pci_r32(PCI_ARB);
+
+	/* Enable external 1 PCI master, ie, PCI device */
+	reg &= ~(SM(1, PCI_ARB_PCI_PORT_ARB));
+
+	/* Enable internal PCI master reqest */
+	reg &= ~(SM(3, PCI_ARB_PCI_MASTER_REQ0));
+
+	/*
+	 * Enable EBU reqest for NOR and NAND boot on SMB and u-boot
+	 * needs to put MB in reset through POR_OUT <GPIO 15>
+	 * For SPI boot, we can disable it.
+	 */
+	reg |= (SM(3, PCI_ARB_PCI_MASTER_REQ1));
+
+	/* reg &= ~(SM(3, PCI_ARB_PCI_MASTER_REQ1)); */
+
+	/* Enable all external masters request */
+	reg &= ~(SM(3, PCI_ARB_PCI_MASTER_REQ2));
+
+	/* Enable internal arbiter, only host has arbiter */
+	reg |= PCI_ARB_INTERNAL_EN;
+	ltq_pci_w32(reg, PCI_ARB);
+	smp_wmb();
+
+	/* PCI host outbound memory window configuration to access pci
+	   device register bank */
+	reg = PCI_BOOT_FPI_BASE;
+	ltq_pci_w32(reg, PCI_FPI_ADDR_MAP0);
+	reg += PCI_BOOT_BLOCK_SIZE;
+	ltq_pci_w32(reg, PCI_FPI_ADDR_MAP1);
+	reg += PCI_BOOT_BLOCK_SIZE;
+	ltq_pci_w32(reg, PCI_FPI_ADDR_MAP2);
+	reg += PCI_BOOT_BLOCK_SIZE;
+	ltq_pci_w32(reg, PCI_FPI_ADDR_MAP3);
+	reg = PCI_BOOT_SRAM_BASE;
+	ltq_pci_w32(reg, PCI_FPI_ADDR_MAP4);
+	reg += PCI_BOOT_BLOCK_SIZE;
+	ltq_pci_w32(reg, PCI_FPI_ADDR_MAP5);
+	reg += PCI_BOOT_BLOCK_SIZE;
+	ltq_pci_w32(reg, PCI_FPI_ADDR_MAP6);
+	reg += PCI_BOOT_BLOCK_SIZE;
+	ltq_pci_w32(reg, PCI_FPI_ADDR_MAP7);
+	/* PCI host inbound memory window configuration for pci device
+	   to access host ddr */
+#if defined(CONFIG_LANTIQ_PPE_E5_OFFCHIP_BONDING)
+	reg = 0x0f000008; /* BAR1 MASK, 16MB, prefetchable */
+	ltq_pci_w32(reg, PCI_BAR11MASK);
+
+	/* DDR from 16~32MMB */
+	ltq_pci_w32(PCI_INBOUND_WINDOW_ONE_16MB_DDR_BASE,
+		PCI_ADDR_MAP11);
+
+#else /*  */
+	reg = 0x0fe00008; /* BAR1 MASK, 2MB, prefetchable */
+	ltq_pci_w32(reg, PCI_BAR11MASK);
+
+	/* DDR from 14~16:MB */
+	ltq_pci_w32(PCI_INBOUND_WINDOW_ONE_14MB_DDR_BASE,
+		PCI_ADDR_MAP11);
+
+#endif /*  */
+	/* BAR1 value, it should cover PCI device bus address */
+	ltq_pci_cfg_w32(PCI_INBOUND_WINDOW_ONE_BASE, PCI_BAR1);
+	/* PCI host inbound memory window configuration for pci device
+	   to access host register bank */
+#if defined(CONFIG_LANTIQ_PPE_E5_OFFCHIP_BONDING)
+	reg = 0x0fc00000; /* BAR2 MASK, 4MB, non-prefetchable */
+	ltq_pci_w32(reg, PCI_BAR12MASK);
+
+#else /*  */
+	reg = 0x0f000000; /* BAR2 MASK, 16MB, non-prefetchable */
+	ltq_pci_w32(reg, PCI_BAR12MASK);
+
+#endif /*  */
+	reg = PCI_INBOUND_WINDOW_TWO_SRAM_BASE;
+	reg |= PCI_ADDR_MAP_SUPERVISOR;
+	/* Register bank, supervisor mode */
+	ltq_pci_w32(reg, PCI_ADDR_MAP12);
+
+	/* BAR2 value, it should cover PCI device bus address */
+	ltq_pci_cfg_w32(PCI_INBOUND_WINDOW_TWO_BASE, PCI_BAR2);
+#if defined(CONFIG_LANTIQ_PPE_E5_OFFCHIP_BONDING)
+	/* PCI host inbound memory window configuration for pci device to
+	   access host PPE share buffer */
+	reg = 0x0fc00000; /* BAR3 MASK, 4MB, non-prefetchable */
+	ltq_pci_w32(reg, PCI_BAR13MASK);
+	reg = PCI_INBOUND_WINDOW_THREE_FPI_BASE;
+	reg |= PCI_ADDR_MAP_SUPERVISOR;
+	/* PPE share buffer, supervisor mode */
+	ltq_pci_w32(reg, PCI_ADDR_MAP13);
+
+	/* BAR3 value, it should cover PCI device bus address */
+	ltq_pci_cfg_w32(PCI_INBOUND_WINDOW_THREE_BASE, PCI_BAR3);
+
+#endif /*  */
+	reg = SM(PCI_FPI_BURST_LEN8, PCI_FPI_RD_BURST_LEN)
+		| SM(PCI_FPI_BURST_LEN8, PCI_FPI_WR_BURST_LEN);
+	ltq_pci_w32(reg, PCI_FPI_BURST_LENGTH);
+
+	/* Enable bus master/IO/MEM access */
+	reg = ltq_pci_cfg_r32(PCI_CMD);
+	reg |= PCI_CMD_IO_EN | PCI_CMD_MEM_EN |
+		PCI_CMD_MASTER_EN;
+	ltq_pci_cfg_w32(reg, PCI_CMD);
+	/* Configuration OK. */
+	ltq_pci_w32_mask(0, PCI_MOD_CFG_OK, PCI_MOD);
+	smp_wmb();
+	mdelay(1);
+
+	/* Get PCI POR <whole chip> out of reset */
+	pci_host_por_out();
+	/* Reset PCI device here, IMO */
+	pci_dev_rst(pdev);
+
+	/* PCI device BAR configuration */
+	devaddr = (u32)ltq_pci_mapped_cfg
+		+ (PCI_BOOT_DEV_IDSEL - 16) * 0x800;
+	ltq_w32(PCI_BOOT_DEV_BAR2_BASE,
+		(u32 *) (devaddr + 0x14));
+	/* PCI device IO/memory/bus master enabled */
+	reg = ltq_r32((u32 *) (devaddr + 0x04));
+	reg |= PCI_CMD_IO_EN | PCI_CMD_MEM_EN | PCI_CMD_MASTER_EN;
+	ltq_w32(reg, (u32 *) (devaddr + 0x04));
+	udelay(10);
+	return 0;
+}
+
+static int pci_host_load_dev_fw(void)
+{
+	int i;
+	u32 reg;
+	u32 devaddr;
+
+	/* Load miniFW from host to PCI device */
+
+	/* Device PPE share buffer address 0x1e220000 */
+	devaddr = PCI_DEV_PPE_ADDR;
+	for (i = 0; i < ARRAY_SIZE(pci_dev_bm_fw); i++) {
+		ltq_w32(pci_dev_bm_fw[i],
+			(u32 *) (devaddr + (i << 2)));
+	}
+
+	/* Read back and check if download is successful */
+	for (i = 0; i < ARRAY_SIZE(pci_dev_bm_fw); i++) {
+		if (ltq_r32((u32 *) (devaddr + (i << 2))) !=
+			pci_dev_bm_fw[i]) {
+			pr_err("%s miniloader download check failed!!!!!\n",
+				__func__);
+			return -1;
+		}
+	}
+	ltq_w32(PCI_DEV_PPE_LOCAL_ADDR, PCI_BOOT_DEV_MPS_ENTRY);
+	reg = ltq_r32(PCI_BOOT_DEV_RDY);
+	reg |= PCI_BOOT_READY;
+	ltq_w32(reg, PCI_BOOT_DEV_RDY);
+
+	/* Disable arbiter to improve throughput */
+	ltq_pci_w32_mask(PCI_MOD_CFG_OK, 0,  PCI_MOD);
+	reg = ltq_pci_r32(PCI_ARB);
+	reg |= PCI_ARB_PCI_PORT_ARB;
+	reg &= ~PCI_ARB_INTERNAL_EN;
+	ltq_pci_w32(reg, PCI_ARB);
+	ltq_pci_w32_mask(0, PCI_MOD_CFG_OK, PCI_MOD);
+	smp_wmb();
+
+	/* Wait for PCI device to be reconfigured */
+	mdelay(100);
+
+	/* PCI device should be up and running, wait for PCI device
+	   to identify it is ready */
+	while ((ltq_r32(PCI_BOOT_DEV_RDY) & PCI_BOOT_READY) != 0)
+		;
+
+	return 0;
+}
+
+static int ltq_pci_boot_probe(struct platform_device *pdev)
+{
+	struct resource *res_cfg, *res_bridge;
+
+	pci_clear_flags(PCI_PROBE_ONLY);
+
+	res_cfg = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	res_bridge = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res_cfg || !res_bridge) {
+		dev_err(&pdev->dev, "missing memory reources\n");
+		return -EINVAL;
+	}
+
+	ltq_pci_membase = devm_ioremap_resource(&pdev->dev, res_bridge);
+	if (IS_ERR(ltq_pci_membase))
+		return PTR_ERR(ltq_pci_membase);
+
+	ltq_pci_mapped_cfg = devm_ioremap_resource(&pdev->dev, res_cfg);
+	if (IS_ERR(ltq_pci_mapped_cfg))
+		return PTR_ERR(ltq_pci_mapped_cfg);
+
+	pci_host_init(pdev);
+	if (pci_host_load_dev_fw() != 0)
+		return -1;
+
+	pr_info("Lantiq PCI Bonding Boot Driver Version %s", PCI_BOOT_VER);
+
+	return 0;
+}
+
+static const struct of_device_id ltq_pci_boot_match[] = {
+	{ .compatible = "lantiq,pci-boot-xrx200" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ltq_pci_boot_match);
+
+static struct platform_driver ltq_pci_boot_driver = {
+	.probe = ltq_pci_boot_probe,
+	.driver = {
+		.name = "pci-boot-xrx200",
+		.owner = THIS_MODULE,
+		.of_match_table = ltq_pci_boot_match,
+	},
+};
+
+int __init pci_boot_init(void)
+{
+	int ret = platform_driver_register(&ltq_pci_boot_driver);
+	if (ret)
+		pr_info("pci-boot-xrx200: Error registering platform driver!");
+	return ret;
+}
+
+arch_initcall(pci_boot_init);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Lei Chuanhua, chuanhua.lei@lantiq.com");
+MODULE_SUPPORTED_DEVICE("Lantiq XRX200 PCI bonding devices");
+MODULE_DESCRIPTION("Lantiq XRX200 PCI bonding boot up driver");
+
diff --git a/arch/mips/pci/pci-lantiq.c b/arch/mips/pci/pci-lantiq.c
old mode 100644
new mode 100755
--- a/arch/mips/pci/pci-lantiq.c
+++ b/arch/mips/pci/pci-lantiq.c
@@ -4,6 +4,7 @@
  *  by the Free Software Foundation.
  *
  *  Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ *  Copyright (C) 2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
  */
 
 #include <linux/types.h>
@@ -20,10 +21,11 @@
 #include <linux/of_irq.h>
 #include <linux/of_pci.h>
 
-#include <asm/pci.h>
-#include <asm/gpio.h>
+#include <linux/pci.h>
+#include <linux/gpio.h>
 #include <asm/addrspace.h>
 
+#include <lantiq.h>
 #include <lantiq_soc.h>
 #include <lantiq_irq.h>
 
@@ -57,6 +59,7 @@
 
 #define LTQ_CGU_IFCCR		0x0018
 #define LTQ_CGU_PCICR		0x0034
+#define LTQ_PCI_RESET_DOMAIN	BIT(13)
 
 #define ltq_pci_w32(x, y)	ltq_w32((x), ltq_pci_membase + (y))
 #define ltq_pci_r32(x)		ltq_r32(ltq_pci_membase + (x))
@@ -114,19 +117,19 @@ static int ltq_pci_startup(struct platfo
 		dev_err(&pdev->dev, "failed to get external pci clock\n");
 		return PTR_ERR(clk_external);
 	}
+	if (of_find_property(node, "lantiq,external-clock", NULL))
+		clk_enable(clk_external);
+	else
+		clk_disable(clk_external);
 
 	/* read the bus speed that we want */
 	bus_clk = of_get_property(node, "lantiq,bus-clock", NULL);
 	if (bus_clk)
 		clk_set_rate(clk_pci, *bus_clk);
 
+	ltq_hw_reset(LTQ_PCI_RESET_DOMAIN);
 	/* and enable the clocks */
 	clk_enable(clk_pci);
-	if (of_find_property(node, "lantiq,external-clock", NULL))
-		clk_enable(clk_external);
-	else
-		clk_disable(clk_external);
-
 	/* setup reset gpio used by pci */
 	reset_gpio = of_get_named_gpio(node, "gpio-reset", 0);
 	if (gpio_is_valid(reset_gpio)) {
@@ -138,6 +141,7 @@ static int ltq_pci_startup(struct platfo
 			return ret;
 		}
 		gpio_direction_output(reset_gpio, 1);
+		__gpio_set_value(reset_gpio, 1);
 	}
 
 	/* enable auto-switching between PCI and EBU */
@@ -203,7 +207,7 @@ static int ltq_pci_startup(struct platfo
 	if (gpio_is_valid(reset_gpio)) {
 		__gpio_set_value(reset_gpio, 0);
 		wmb();
-		mdelay(1);
+		mdelay(5);
 		__gpio_set_value(reset_gpio, 1);
 	}
 	return 0;
diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -266,31 +266,6 @@ static int __init pcibios_init(void)
 
 subsys_initcall(pcibios_init);
 
-int pcibios_host_nr(void)
-{
-    int count;
-    struct pci_controller *hose;
-    for (count = 0, hose = hose_head; hose; hose = hose->next, count++) {
-        ;
-    }
-    return count;
-}
-EXPORT_SYMBOL(pcibios_host_nr);
-
-int pcibios_1st_host_bus_nr(void)
-{
-    int bus_nr = 0;
-    struct pci_controller *hose = hose_head;
-
-    if (hose != NULL) {
-        if (hose->bus != NULL) {
-            bus_nr = hose->bus->number + 1;
-        }
-    }
-    return bus_nr;
-}
-EXPORT_SYMBOL(pcibios_1st_host_bus_nr);
-
 static int pcibios_enable_resources(struct pci_dev *dev, int mask)
 {
 	u16 cmd, old_cmd;
diff --git a/arch/mips/pci/pcie-lantiq-msi.c b/arch/mips/pci/pcie-lantiq-msi.c
new file mode 100755
--- /dev/null
+++ b/arch/mips/pci/pcie-lantiq-msi.c
@@ -0,0 +1,410 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2009~2015 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+
+/*!
+ \file pcie-lantiq-msi.c
+ \ingroup PCIE
+ \brief PCIe MSI OS interface file
+*/
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/msi.h>
+#include <linux/of_irq.h>
+#include <lantiq_irq.h>
+
+#include "pcie-lantiq.h"
+
+/* MSI PIC */
+#define MSI_PIC_BIG_ENDIAN		1
+#define MSI_PIC_LITTLE_ENDIAN		0
+
+#define MSI_PCI_INT_DISABLE		0x80000000
+#define MSI_PIC_INT_LINE		0x70000000
+#define MSI_PIC_INT_LINE_S		28
+#define MSI_PIC_MSG_ADDR		0x0FFF0000
+#define MSI_PIC_MSG_ADDR_S		16
+#define MSI_PIC_MSG_DATA		0x0000FFFF
+#define MSI_PIC_MSG_DATA_S		0x0
+
+#define PCIE_MSI_MAX_IRQ_NUM_PER_RC	8
+
+/* Keep base data lower bits as zero since MSI has maximum 32 vectors */
+#define PCIE_MSI_BASE_DATA  0x4AE0
+
+void pcie_msi_pic_init(struct ltq_pcie_port *lpp)
+{
+	int i;
+	int ret;
+	int irq_num;
+	struct resource  msi_irqs[PCIE_MSI_MAX_IRQ_NUM_PER_RC];
+	struct device *dev = lpp->dev;
+	struct device_node *np = dev->of_node;
+	struct msi_irq *lmsi = &lpp->msi_irqs;
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
+
+	spin_lock_init(&lmsi->msi_lock);
+	lmsi->msi_pic_p = (struct ltq_msi_pic *)lpp->msi_pic;
+	lmsi->msi_phy_base = lpp->msi_base;
+	lmsi->msi_free_irq_bitmask = 0;
+	lmsi->msi_multiple_irq_bitmask = 0;
+	irq_num = of_irq_count(np);
+	irq_num--; /* last one is ir interrupt */
+	ret = of_irq_to_resource_table(np,
+				msi_irqs, irq_num);
+	if (ret != irq_num)
+		panic("failed to load msi irq resources\n");
+
+	if (ret > soc->per_rc_max_msi_irqs) {
+		dev_err(lpp->dev, "Beyong the supported interrupts\n");
+		return;
+	}
+
+	for (i = 0; i < soc->per_rc_max_msi_irqs; i++) {
+		lmsi->msi_irq_idx[i].irq = msi_irqs[i].start;
+		lmsi->msi_irq_idx[i].idx = i;
+	}
+
+	spin_lock(&lmsi->msi_lock);
+	if (lpp->inbound_swap)
+		lmsi->msi_pic_p->pic_endian = MSI_PIC_BIG_ENDIAN;
+	else
+		lmsi->msi_pic_p->pic_endian = MSI_PIC_LITTLE_ENDIAN;
+
+	spin_unlock(&lmsi->msi_lock);
+}
+
+static void ltq_msi_unmask_irq(struct msi_desc *desc, u32 mask)
+{
+	u32 mask_bits = desc->masked;
+
+	if (!desc->msi_attrib.maskbit)
+		return;
+	mask_bits &= ~mask;
+	pci_write_config_dword(desc->dev, desc->mask_pos, mask_bits);
+}
+
+/**
+ * \fn int ltq_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
+ * \brief Called when a driver request MSI interrupts instead of the
+ * legacy INT A-D. This routine will allocate multiple interrupts
+ * for MSI devices that support them. A device can override this by
+ * programming the MSI control bits [6:4] before calling
+ * pci_enable_msi().
+ *
+ * \param[in] pdev   Device requesting MSI interrupts
+ * \param[in] desc   MSI descriptor
+ *
+ * \return   -EINVAL Invalid pcie root port or invalid msi bit
+ * \return    0        OK
+ * \ingroup PCIE_MSI
+ */
+static int ltq_setup_msi_irq(struct pci_dev *pdev,
+	struct msi_desc *desc, int nvec)
+{
+	int i;
+	int irq_base;
+	int pos;
+	u16 control;
+	int irq_idx;
+	int irq_step;
+	int configured_private_bits;
+	int request_private_bits;
+	struct msi_msg msg;
+	u16 search_mask;
+	u16 msi_base_data;
+	struct msi_irq *lmsi;
+	u32 msi_mask;
+	struct ltq_pcie_port *lpp = bus_to_ltq_pcie_port(pdev->bus);
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
+	lmsi = &lpp->msi_irqs;
+	BUG_ON(nvec <= 0);
+	dev_dbg(lpp->dev, "%s %s port %d enter\n",
+		__func__, pci_name(pdev), lpp->id);
+
+	/* Skip RC and switch ports since we have limited
+	 * interrupt resource available */
+	if (pci_pcie_type(pdev) != PCI_EXP_TYPE_ENDPOINT) {
+		dev_dbg(lpp->dev,
+			"%s RC %d or Switch Port doesn't use MSI interrupt\n",
+			__func__, lpp->id);
+		return -EINVAL;
+	}
+	/*
+	 * Read the MSI config to figure out how many IRQs this device
+	 * wants.  Most devices only want 1, which will give
+	 * configured_private_bits and request_private_bits equal 0.
+	 */
+	pci_read_config_word(pdev, desc->msi_attrib.pos + PCI_MSI_FLAGS,
+				&control);
+
+	/*
+	 * If the number of private bits has been configured then use
+	 * that value instead of the requested number. This gives the
+	 * driver the chance to override the number of interrupts
+	 * before calling pci_enable_msi().
+	 */
+	configured_private_bits = (control & PCI_MSI_FLAGS_QSIZE) >> 4;
+
+	if (configured_private_bits == 0) {
+		/* Nothing is configured, so use the hardware requested size */
+		request_private_bits =
+			(control & PCI_MSI_FLAGS_QMASK) >> 1;
+	} else {
+		/*
+		 * Use the number of configured bits, assuming the
+		 * driver wanted to override the hardware request
+		 * value.
+		 */
+		request_private_bits = configured_private_bits;
+	}
+
+	/*
+	 * The PCI 2.3 spec mandates that there are at most 32
+	 * interrupts. If this device asks for more, only give it one.
+	 */
+	if (request_private_bits > 5)
+		request_private_bits = 0;
+again:
+	/*
+	 * The IRQs have to be aligned on a power of two based on the
+	 * number being requested.
+	 */
+	irq_step = (1 << request_private_bits);
+
+	/* NB: Pick up the minimun one for usage */
+	irq_step = min(irq_step, nvec);
+
+	msi_mask = (1 << (1 << request_private_bits)) - 1;
+	/* If device supports more than RC supported, fall back to single MSI */
+	if (irq_step > soc->per_rc_max_msi_irqs) {
+		irq_step = 1;
+		request_private_bits = 0;
+		dev_info(lpp->dev, "Requested interrupts more than RC supported, fall back to single MSI!!!\n");
+	}
+
+	/* Mask with one bit for each IRQ */
+	search_mask = (1 << irq_step) - 1;
+
+	/*
+	 * We're going to search msi_free_irq_bitmask_lock for zero
+	 * bits. This represents an MSI interrupt number that isn't in
+	 * use.
+	 */
+	spin_lock(&lmsi->msi_lock);
+	for (pos = 0; pos < MSI_IRQ_PIC_TABLE_SZ; pos += irq_step) {
+		if ((lmsi->msi_free_irq_bitmask & (search_mask << pos)) == 0) {
+			lmsi->msi_free_irq_bitmask |= search_mask << pos;
+			lmsi->msi_multiple_irq_bitmask |=
+				(search_mask >> 1) << pos;
+			break;
+		}
+	}
+	spin_unlock(&lmsi->msi_lock);
+
+	/* Make sure the search for available interrupts didn't fail */
+	if (pos >= MSI_IRQ_PIC_TABLE_SZ) {
+		if (request_private_bits) {
+			dev_dbg(lpp->dev,
+				"%s: Unable to find %d free interrupts, trying just one",
+				__func__,
+				1 << request_private_bits);
+			request_private_bits = 0;
+			goto again;
+		} else {
+			dev_err(lpp->dev,
+				"%s: Unable to find a free MSI interrupt\n",
+				__func__);
+			return -EINVAL;
+		}
+	}
+
+	/* Only assign the base irq to msi entry */
+	irq_base = lmsi->msi_irq_idx[pos].irq;
+	irq_idx = lmsi->msi_irq_idx[pos].idx;
+
+	dev_dbg(lpp->dev, "pos %d, irq %d irq_idx %d\n",
+		pos, irq_base, irq_idx);
+
+	/*
+	 * Initialize MSI. This has to match the memory-write endianess
+	 * from the device
+	 * Address bits [23:12]
+	 * For multiple MSI, we have to assign and enable sequence MSI data
+	 * Make sure that base data lower bits as zero since multiple MSI
+	 * just modify lower several bits to generate different interrupts
+	 */
+	msi_base_data = PCIE_MSI_BASE_DATA & (~(irq_step - 1));
+	spin_lock(&lmsi->msi_lock);
+	for (i = 0; i < irq_step; i++) {
+		lmsi->msi_pic_p->pic_table[pos + i] =
+			SM((irq_idx + i) % soc->per_rc_max_msi_irqs,
+				MSI_PIC_INT_LINE)
+			| SM((lmsi->msi_phy_base >> 12), MSI_PIC_MSG_ADDR)
+			| SM((msi_base_data + i), MSI_PIC_MSG_DATA);
+		/* Enable this entry */
+		lmsi->msi_pic_p->pic_table[pos + i] &= ~MSI_PCI_INT_DISABLE;
+		dev_dbg(lpp->dev, "pic_table[%d]: 0x%08x\n",
+			(pos + i), lmsi->msi_pic_p->pic_table[pos + i]);
+	}
+	spin_unlock(&lmsi->msi_lock);
+
+	/* Update multiple MSI property */
+	desc->msi_attrib.multiple = request_private_bits;
+	/* Assign base irq and base data to the first MSI entry */
+	irq_set_msi_desc(irq_base, desc);
+	msg.address_hi = 0x0;
+	msg.address_lo = lmsi->msi_phy_base;
+	msg.data = SM(msi_base_data, MSI_PIC_MSG_DATA);
+	dev_dbg(lpp->dev,
+		"base msi_data: pos %d data 0x%08x irq %d-%d\n",
+		pos, msg.data, irq_base, irq_base + irq_step - 1);
+
+	write_msi_msg(irq_base, &msg);
+
+	/* Unmask optional per-vector MSI, some advanced card supported */
+	ltq_msi_unmask_irq(desc, msi_mask);
+
+	dev_dbg(lpp->dev, "%s port %d exit\n", __func__, lpp->id);
+	return 0;
+}
+
+static int ltq_setup_msi_irqs(struct msi_chip *chip, struct pci_dev *dev,
+		int nvec, int type)
+{
+	struct msi_desc *entry;
+	int ret;
+
+	/*
+	 * MSI-X is not supported.
+	 */
+	if (type == PCI_CAP_ID_MSIX)
+		return -EINVAL;
+
+	list_for_each_entry(entry, &dev->msi_list, list) {
+		ret = ltq_setup_msi_irq(dev, entry, nvec);
+		if (ret < 0)
+			return ret;
+		if (ret > 0)
+			return -ENOSPC;
+	}
+	return 0;
+}
+
+/**
+ * \fn void ltq_teardown_msi_irqs(struct msi_chip *chip, struct pci_dev *pdev)
+ * \brief Called when a device no longer needs its MSI interrupts. All
+ * MSI interrupts for the device are freed.
+ *
+ * \param irq   The devices first irq number. There may be multple in sequence.
+ * \return none
+ * \ingroup PCIE_MSI
+ */
+static void ltq_teardown_msi_irqs(struct msi_chip *chip, struct pci_dev *pdev)
+{
+	int i;
+	int pos;
+	int number_irqs;
+	u16 bitmask;
+	struct msi_desc *desc;
+	int irq;
+	struct ltq_pcie_port *lpp;
+	struct msi_irq *lmsi;
+
+	lpp = bus_to_ltq_pcie_port(pdev->bus);
+	lmsi = &lpp->msi_irqs;
+
+	/* Skip RC and switch ports since we have limited
+	 * interrupt resource available
+	 */
+	if (pci_pcie_type(pdev) != PCI_EXP_TYPE_ENDPOINT) {
+		dev_dbg(lpp->dev,
+			"%s RC %d or Switch Port doesn't use MSI interrupt\n",
+			__func__, lpp->id);
+		return;
+	}
+
+	BUG_ON(list_empty(&pdev->msi_list));
+	desc = list_first_entry(&pdev->msi_list, struct msi_desc, list);
+
+	/* NB pdev->irq has been restored, retrieve msi irq number */
+	irq = desc->irq;
+
+	dev_dbg(lpp->dev, "%s port %d irq %d enter\n",
+		__func__, lpp->id, irq);
+
+	if (irq == 0)
+		return;
+	/* Shift the mask to the correct bit location, not always correct
+	 * Probally, the first match will be chosen.
+	 */
+	for (pos = 0; pos < MSI_IRQ_PIC_TABLE_SZ; pos++) {
+		if ((lmsi->msi_irq_idx[pos].irq == irq)
+			&& (lmsi->msi_free_irq_bitmask & (1 << pos)))
+			break;
+	}
+
+	if (pos >= MSI_IRQ_PIC_TABLE_SZ) {
+		dev_err(lpp->dev,
+			"%s: Unable to find a matched MSI interrupt %d\n",
+			__func__, irq);
+		return;
+	}
+	/*
+	 * Count the number of IRQs we need to free by looking at the
+	 * msi_multiple_irq_bitmask. Each bit set means that the next
+	 * IRQ is also owned by this device.
+	 */
+	number_irqs = 0;
+	while (((pos + number_irqs) < MSI_IRQ_PIC_TABLE_SZ)
+		&& (lmsi->msi_multiple_irq_bitmask
+		& (1 << (pos + number_irqs))))
+		number_irqs++;
+
+	number_irqs++;
+
+	/* Disable entries if multiple MSI  */
+	spin_lock(&lmsi->msi_lock);
+	for (i = 0; i < number_irqs; i++) {
+		lmsi->msi_pic_p->pic_table[pos + i] |= MSI_PCI_INT_DISABLE;
+		lmsi->msi_pic_p->pic_table[pos + i] &=
+			~(MSI_PIC_INT_LINE | MSI_PIC_MSG_ADDR |
+			MSI_PIC_MSG_DATA);
+	}
+	spin_unlock(&lmsi->msi_lock);
+
+	/* Mask with one bit for each IRQ */
+	bitmask = (1 << number_irqs) - 1;
+
+	bitmask <<= pos;
+	if ((lmsi->msi_free_irq_bitmask & bitmask) != bitmask) {
+		dev_err(lpp->dev,
+			"%s: Attempted to teardown MSI interrupt %d not in use\n",
+			__func__, irq);
+		return;
+	}
+
+	/* Checks are done, update the in use bitmask */
+	spin_lock(&lmsi->msi_lock);
+	lmsi->msi_free_irq_bitmask &= ~bitmask;
+	lmsi->msi_multiple_irq_bitmask &= ~(bitmask >> 1);
+	spin_unlock(&lmsi->msi_lock);
+
+	dev_dbg(lpp->dev, "%s port %d exit\n", __func__, lpp->id);
+}
+
+struct msi_chip ltq_msi_chip = {
+	.setup_irqs = ltq_setup_msi_irqs,
+	.teardown_irqs = ltq_teardown_msi_irqs,
+};
+
+MODULE_LICENSE("GPL V2");
+MODULE_AUTHOR("Lei Chuanhua <Chuanhua.Lei@lantiq.com>");
+MODULE_SUPPORTED_DEVICE("Lqntiq PCIe IP builtin MSI PIC module");
+MODULE_DESCRIPTION("Lantiq PCIe IP builtin MSI PIC driver");
diff --git a/arch/mips/pci/pcie-lantiq-phy.c b/arch/mips/pci/pcie-lantiq-phy.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/pci/pcie-lantiq-phy.c
@@ -0,0 +1,680 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2009~2015 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+/*!
+ \file pcie-lantiq-phy.c
+ \ingroup PCIE
+ \brief PCIe PHY PLL register programming source file
+*/
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/paccess.h>
+#include <linux/delay.h>
+
+#include "pcie-lantiq.h"
+
+enum {
+	PCIE_PHY_36MHZ = 0,
+	PCIE_PHY_36MHZ_SSC,
+	PCIE_PHY_25MHZ,
+	PCIE_PHY_25MHZ_SSC,
+	PCIE_PHY_100MHZ,
+	PCIE_PHY_100MHZ_SSC,
+	PCIE_PHY_MAX,
+};
+
+/* PCIe PDI only supports 16 bit operation */
+
+#define LTQ_PCIE_PLL_TIMEOUT 1000 /* Tunnable */
+
+static bool lcpll_ssc_init;
+
+static inline u16 pcie_phy_r16(struct ltq_pcie_port *lpp, unsigned int reg)
+{
+	return ltq_r16(lpp->phy_base + reg);
+}
+
+static inline void pcie_phy_w16(struct ltq_pcie_port *lpp,
+	u16 val, unsigned int reg)
+{
+	ltq_w16(val, lpp->phy_base + reg);
+}
+
+static inline void pcie_phy_mask(struct ltq_pcie_port *lpp,
+	unsigned int reg, u16 val, u16 mask)
+{
+	u16 data;
+
+	data = pcie_phy_r16(lpp, reg);
+	data = (data & (~mask)) | (val & mask);
+	pcie_phy_w16(lpp, data, reg);
+}
+
+static inline u32 pcie_phy_r32(struct ltq_pcie_port *lpp, unsigned int reg)
+{
+	return ltq_r32(lpp->phy_base + reg);
+}
+
+static inline void pcie_phy_w32(struct ltq_pcie_port *lpp,
+	u32 val, unsigned int reg)
+{
+	ltq_w32(val, lpp->phy_base + reg);
+}
+
+static inline void pcie_phy_w32_mask(struct ltq_pcie_port *lpp, u32 clr,
+	u32 set, u32 reg)
+{
+	ltq_w32_mask(clr, set, lpp->phy_base + reg);
+}
+
+/* #define LTQ_PCIE_PHY_REG_DUMP */
+
+#ifdef LTQ_PCIE_PHY_REG_DUMP
+static void pcie_phy_reg_dump(struct ltq_pcie_port *lpp)
+{
+	dev_info(lpp->dev, "Port %d PLL REGFILE\n", lpp->id);
+	dev_info(lpp->dev, "PCIE_PHY_PLL_CTRL1    0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_PLL_CTRL1));
+	dev_info(lpp->dev, "PCIE_PHY_PLL_CTRL2    0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_PLL_CTRL2));
+	dev_info(lpp->dev, "PCIE_PHY_PLL_CTRL3    0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_PLL_CTRL3));
+	dev_info(lpp->dev, "PCIE_PHY_PLL_CTRL4    0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_PLL_CTRL4));
+	dev_info(lpp->dev, "PCIE_PHY_PLL_CTRL5    0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_PLL_CTRL5));
+	dev_info(lpp->dev, "PCIE_PHY_PLL_CTRL6    0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_PLL_CTRL6));
+	dev_info(lpp->dev, "PCIE_PHY_PLL_CTRL7    0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_PLL_CTRL7));
+	dev_info(lpp->dev, "PCIE_PHY_PLL_A_CTRL1  0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_PLL_A_CTRL1));
+	dev_info(lpp->dev, "PCIE_PHY_PLL_A_CTRL2  0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_PLL_A_CTRL2));
+	dev_info(lpp->dev, "PCIE_PHY_PLL_A_CTRL3  0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_PLL_A_CTRL3));
+	dev_info(lpp->dev, "PCIE_PHY_PLL_STATUS   0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_PLL_STATUS));
+
+	dev_info(lpp->dev, "TX1 REGFILE\n");
+	dev_info(lpp->dev, "PCIE_PHY_TX1_CTRL1    0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_TX1_CTRL1));
+	dev_info(lpp->dev, "PCIE_PHY_TX1_CTRL2    0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_TX1_CTRL2));
+	dev_info(lpp->dev, "PCIE_PHY_TX1_CTRL3    0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_TX1_CTRL3));
+	dev_info(lpp->dev, "PCIE_PHY_TX1_A_CTRL1  0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_TX1_A_CTRL1));
+	dev_info(lpp->dev, "PCIE_PHY_TX1_A_CTRL2  0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_TX1_A_CTRL2));
+	dev_info(lpp->dev, "PCIE_PHY_TX1_MOD1     0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_TX1_MOD1));
+	dev_info(lpp->dev, "PCIE_PHY_TX1_MOD2     0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_TX1_MOD2));
+	dev_info(lpp->dev, "PCIE_PHY_TX1_MOD3     0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_TX1_MOD3));
+
+	dev_info(lpp->dev, "TX2 REGFILE\n");
+	dev_info(lpp->dev, "PCIE_PHY_TX2_CTRL1    0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_TX2_CTRL1));
+	dev_info(lpp->dev, "PCIE_PHY_TX2_CTRL2    0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_TX2_CTRL2));
+	dev_info(lpp->dev, "PCIE_PHY_TX2_A_CTRL1  0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_TX2_A_CTRL1));
+	dev_info(lpp->dev, "PCIE_PHY_TX2_A_CTRL2  0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_TX2_A_CTRL2));
+	dev_info(lpp->dev, "PCIE_PHY_TX2_MOD1     0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_TX2_MOD1));
+	dev_info(lpp->dev, "PCIE_PHY_TX2_MOD2     0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_TX2_MOD2));
+	dev_info(lpp->dev, "PCIE_PHY_TX2_MOD3     0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_TX2_MOD3));
+
+	dev_info(lpp->dev, "RX1 REGFILE\n");
+	dev_info(lpp->dev, "PCIE_PHY_RX1_CTRL1    0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_RX1_CTRL1));
+	dev_info(lpp->dev, "PCIE_PHY_RX1_CTRL2    0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_RX1_CTRL2));
+	dev_info(lpp->dev, "PCIE_PHY_RX1_CDR      0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_RX1_CDR));
+	dev_info(lpp->dev, "PCIE_PHY_RX1_EI       0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_RX1_EI));
+	dev_info(lpp->dev, "PCIE_PHY_RX1_A_CTRL   0x%04x\n",
+		pcie_phy_r16(lpp, PCIE_PHY_RX1_A_CTRL));
+}
+#endif /* LTQ_PCIE_PHY_REG_DUMP */
+
+static void pcie_phy_comm_setup(struct ltq_pcie_port *lpp)
+{
+	/* PLL Setting */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_A_CTRL1, 0x120e, 0xFFFF);
+	/* increase the bias reference voltage */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_A_CTRL2, 0x39D7, 0xFFFF);
+
+	/* Endcnt */
+	pcie_phy_mask(lpp, PCIE_PHY_RX1_EI, 0x0004, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_RX1_A_CTRL, 0x6803, 0xFFFF);
+
+	/* force */
+	pcie_phy_mask(lpp, PCIE_PHY_TX1_CTRL1, 0x0008, 0x0008);
+
+	/* predrv_ser_en */
+	pcie_phy_mask(lpp, PCIE_PHY_TX1_A_CTRL2, 0x0706, 0xFFFF);
+	/* ctrl_lim */
+	pcie_phy_mask(lpp, PCIE_PHY_TX1_CTRL3, 0x1FFF, 0xFFFF);
+	/* ctrl */
+	pcie_phy_mask(lpp, PCIE_PHY_TX1_A_CTRL1, 0x0810, 0xFFFF);
+	/* predrv_ser_en */
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_A_CTRL2, 0x4702, 0x7F00);
+
+	/* RTERM */
+	pcie_phy_mask(lpp, PCIE_PHY_TX1_CTRL2, 0x2e00, 0xFFFF);
+
+	/* Improved 100MHz clock output  */
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_CTRL2, 0x3096, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_A_CTRL2, 0x4707, 0xFFFF);
+	/* Reduced CDR BW to avoid glitches */
+	pcie_phy_mask(lpp, PCIE_PHY_RX1_CDR, 0x0235, 0xFFFF);
+}
+
+static int pcie_ppm_enabled;
+
+static int __init setup_pcie_ppm(char *str)
+{
+	if (!strcmp(str, "off"))
+		pcie_ppm_enabled = 0;
+	else if (!strcmp(str, "on"))
+		pcie_ppm_enabled = 1;
+	else
+		return 0;
+	return 1;
+}
+
+__setup("pcie_ppm=", setup_pcie_ppm);
+
+int pcie_phy_clock_ppm_enabled(void)
+{
+	return pcie_ppm_enabled;
+}
+
+static void pcie_phy_36mhz_mode_setup(struct ltq_pcie_port *lpp)
+{
+	int rc_port = lpp->id;
+
+	dev_dbg(lpp->dev, "%s pcie_port %d ppm %s enter\n",
+		__func__, rc_port,
+		pcie_ppm_enabled ? "enable" : "disable");
+#ifdef LTQ_PCIE_PHY_REG_DUMP
+	dev_dbg(lpp->dev, "Initial PHY register dump\n");
+	pcie_phy_reg_dump(lpp);
+#endif
+	if (pcie_ppm_enabled) {
+		int p0_ppm = 400;
+		int p1_ppm = -400;
+		u16 sdm_val1 = 0x38e4;
+		u16 sdm_val2 = 0xee;
+
+		/* en_ext_mmd_div_ratio */
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL3, 0x0000, 0xFFFF);
+
+		/* pll_ensdm */
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL2, 0x0300, 0xFF00);
+
+		/* en_const_sdm */
+		/* mmd */
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_A_CTRL3, 0x2900,
+				 0xFFFF);
+
+		/* lf_mode */
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_A_CTRL2, 0x0000,
+				 0x4000);
+
+		if (rc_port == LTQ_PCIE_PORT0) {
+			if (p0_ppm == 200) {
+				sdm_val1 = 0xaaa9;
+				sdm_val2 = 0xee;
+			} else if (p0_ppm == 300) {
+				sdm_val1 = 0xe38d;
+				sdm_val2 = 0xee;
+			} else if (p0_ppm == 350) {
+				sdm_val1 = 0xffff;
+				sdm_val2 = 0xee;
+			} else if (p0_ppm == 400) {
+				sdm_val1 = 0x1c70;
+				sdm_val2 = 0xef;
+			} else if (p0_ppm == 500) {
+				sdm_val1 = 0x5554;
+				sdm_val2 = 0xef;
+			} else {
+				/* default 0 ppm */
+				sdm_val1 = 0x38e4;
+				sdm_val2 = 0xee;
+			}
+		}
+
+		if (rc_port == LTQ_PCIE_PORT1) {
+			if (p1_ppm == -200) {
+				sdm_val1 = 0xc71b;
+				sdm_val2 = 0xed;
+			} else if (p1_ppm == -300) {
+				sdm_val1 = 0x8e37;
+				sdm_val2 = 0xed;
+			} else if (p1_ppm == -350) {
+				sdm_val1 = 0x71c6;
+				sdm_val2 = 0xed;
+			} else if (p1_ppm == -400) {
+				sdm_val1 = 0x5554;
+				sdm_val2 = 0xed;
+			} else if (p1_ppm == -500) {
+				sdm_val1 = 0x1c70;
+				sdm_val2 = 0xed;
+			} else {
+				/* default 0 ppm */
+				sdm_val1 = 0x38e4;
+				sdm_val2 = 0xee;
+			}
+		}
+		/* const_sdm */
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL1, sdm_val1, 0xFFFF);
+		/* const sdm */
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL2, sdm_val2, 0x00FF);
+
+		/* pllmod */
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL7, 0x0002, 0xFFFF);
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL6, 0x3a04, 0xFFFF);
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL5, 0xfae3, 0xFFFF);
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL4, 0x1b72, 0xFFFF);
+	} else {
+		/* en_ext_mmd_div_ratio */
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL3, 0x0000, 0xFFFF);
+		/* const sdm */
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL2, 0x03ee, 0xFFFF);
+
+		/* mmd */
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_A_CTRL3, 0x2900, 0xFFFF);
+
+		/* lf_mode */
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_A_CTRL2, 0x0000, 0x4000);
+		/* const_sdm */
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL1, 0x38e4, 0xFFFF);
+		/* pllmod */
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL7, 0x0002, 0xFFFF);
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL6, 0x3a04, 0xFFFF);
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL5, 0xfae3, 0xFFFF);
+		pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL4, 0x1b72, 0xFFFF);
+	}
+	dev_dbg(lpp->dev, "%s pcie_port %d ppm %s exit\n", __func__,
+		rc_port, pcie_ppm_enabled ? "enable" : "disable");
+}
+
+static void pcie_phy_36mhz_ssc_mode_setup(struct ltq_pcie_port *lpp)
+{
+	dev_dbg(lpp->dev, "%s pcie_port %d enter\n", __func__, lpp->id);
+#ifdef LTQ_PCIE_PHY_REG_DUMP
+	dev_dbg(lpp->dev, "Initial PHY register dump\n");
+	pcie_phy_reg_dump(lpp);
+#endif
+	/* Increase the bias reference voltage */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_A_CTRL2, 0x39D7, 0xFFFF);
+	/* Endcnt */
+	pcie_phy_mask(lpp, PCIE_PHY_RX1_EI, 0x0004, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_RX1_A_CTRL, 0x6803, 0xFFFF);
+	/* Force */
+	pcie_phy_mask(lpp, PCIE_PHY_TX1_CTRL1, 0x0008, 0x0008);
+	/* Predrv_ser_en */
+	pcie_phy_mask(lpp, PCIE_PHY_TX1_A_CTRL2, 0x0706, 0xFFFF);
+	/* ctrl_lim */
+	pcie_phy_mask(lpp, PCIE_PHY_TX1_CTRL3, 0x1FFF, 0xFFFF);
+	/* ctrl */
+	pcie_phy_mask(lpp, PCIE_PHY_TX1_A_CTRL1, 0x0810, 0xFFFF);
+	/* predrv_ser_en */
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_A_CTRL2, 0x4702, 0x7F00);
+	/* RTERM */
+	pcie_phy_mask(lpp, PCIE_PHY_TX1_CTRL2, 0x2e00, 0xFFFF);
+	/* en_ext_mmd_div_ratio */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL3, 0x0000, 0xFFFF);
+	/* const sdm */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL2, 0x06ee, 0xFFFF);
+	/* ext_mmd_div_ratio */
+	/* pll_ensdm */
+	/* mmd */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_A_CTRL3, 0x2900, 0xFFFF);
+	/* lf_mode */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_A_CTRL2, 0x0000, 0x4000);
+	/* const_sdm */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL1, 0x38e4, 0xFFFF);
+	/* pllmod */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL7, 0x0002, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL6, 0x3a04, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL5, 0xfae3, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL4, 0x1c72, 0xFFFF);
+	/* improved 100MHz clock output  */
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_CTRL2, 0x3096, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_A_CTRL2, 0x4707, 0xFFFF);
+	/* reduced CDR BW to avoid glitches */
+	pcie_phy_mask(lpp, PCIE_PHY_RX1_CDR, 0x0235, 0xFFFF);
+
+	dev_dbg(lpp->dev, "%s pcie_port %d exit\n", __func__, lpp->id);
+}
+
+static void pcie_phy_25mhz_mode_setup(struct ltq_pcie_port *lpp)
+{
+	dev_dbg(lpp->dev, "%s pcie_port %d enter\n", __func__, lpp->id);
+#ifdef LTQ_PCIE_PHY_REG_DUMP
+	dev_dbg(lpp->dev, "Initial PHY register dump\n");
+	pcie_phy_reg_dump(lpp);
+#endif
+	/* en_const_sdm */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_A_CTRL1, 0x130e, 0xFFFF);
+	/* en_ext_mmd_div_ratio */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL3, 0x0042, 0xFFFF);
+	/* pll_ensdm */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL2, 0x0183, 0x0200);
+	/* ext_mmd_div_ratio */
+	/* mmd */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_A_CTRL3, 0x6900, 0xFFFF);
+	/* lf_mode */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_A_CTRL2, 0x4000, 0x4000);
+
+	dev_dbg(lpp->dev, "%s pcie_port %d exit\n", __func__, lpp->id);
+}
+
+static void pcie_phy_25mhz_ssc_mode_setup(struct ltq_pcie_port *lpp)
+{
+	dev_dbg(lpp->dev, "%s pcie_port %d enter\n",
+		__func__, lpp->id);
+#ifdef LTQ_PCIE_PHY_REG_DUMP
+	dev_dbg(lpp->dev, "Initial PHY register dump\n");
+	pcie_phy_reg_dump(lpp);
+#endif
+	/* en_const_sdm */
+	/* pll_wavegen */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL2, 0x0683, 0x0400);
+	/* en_ext_mmd_div_ratio */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL3, 0x0040, 0xFFFF);
+	/* ext_mmd_div_ratio */
+	/* mmd */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_A_CTRL3, 0x6900, 0xFFFF);
+	/* lf_mode */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_A_CTRL2, 0x4000, 0x4000);
+	/* pll_mod */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL7, 0x0001, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL6, 0x8C0A, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL5, 0x52F0, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL4, 0x0000, 0xFFFF);
+
+	dev_dbg(lpp->dev, "%s pcie_port %d exit\n", __func__, lpp->id);
+}
+
+static void pcie_phy_100mhz_mode_setup(struct ltq_pcie_port *lpp)
+{
+	dev_dbg(lpp->dev, "%s pcie_port %d enter\n", __func__, lpp->id);
+#ifdef LTQ_PCIE_PHY_REG_DUMP
+	dev_dbg(lpp->dev, "Initial PHY register dump\n");
+	pcie_phy_reg_dump(lpp);
+#endif
+	/* en_ext_mmd_div_ratio */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL3, 0x0000, 0xFFFF);
+	/* const sdm */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL2, 0x00ee, 0xFFFF);
+	/* ext_mmd_div_ratio */
+	/* pll_ensdm */
+	/* mmd */
+	/* ref_clk_sel */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_A_CTRL3, 0x8B00, 0xFFFF);
+	/* lf_mode */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_A_CTRL2, 0x4000, 0x4000);
+	/* const_sdm */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL1, 0x38e4, 0xFFFF);
+	/* pllmod */
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL7, 0x0002, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL6, 0x3a04, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL5, 0xfae3, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_PLL_CTRL4, 0x1b72, 0xFFFF);
+	/* Tx2 settings required to receive the external differential clock */
+	/* rxck_en =1; pd =1; */
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_A_CTRL1, 0x4000, 0x4000);
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_CTRL1, 0x0000, 0x0001);
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_CTRL1, 0x0004, 0x0004);
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_A_CTRL1, 0x1000, 0x1000);
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_A_CTRL2, 0x8000, 0x8000);
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_A_CTRL1, 0x0000, 0x0001);
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_A_CTRL1, 0x0000, 0x0010);
+	dev_dbg(lpp->dev, "%s pcie_port %d exit\n", __func__, lpp->id);
+}
+
+
+static int pcie_phy_wait_startup_ready(struct ltq_pcie_port *lpp)
+{
+	int i;
+
+	for (i = 0; i < LTQ_PCIE_PLL_TIMEOUT; i++) {
+		if ((pcie_phy_r16(lpp, PCIE_PHY_PLL_STATUS)
+			& 0x0070) == 0x0070) {
+			break;
+		}
+		udelay(10);
+	}
+	if (i >= LTQ_PCIE_PLL_TIMEOUT) {
+		dev_err(lpp->dev, "%s port %d PLL Link timeout\n", __func__,
+			lpp->id);
+		return -1;
+	}
+	return 0;
+}
+
+static void pcie_phy_load_enable(struct ltq_pcie_port *lpp, int slice)
+{
+	/* Set the load_en of tx/rx slice to '1' */
+	switch (slice) {
+	case 1:
+		pcie_phy_mask(lpp, PCIE_PHY_TX1_CTRL1, 0x0010, 0x0010);
+		break;
+	case 2:
+		pcie_phy_mask(lpp, PCIE_PHY_TX2_CTRL1, 0x0010, 0x0010);
+		break;
+	case 3:
+		pcie_phy_mask(lpp, PCIE_PHY_RX1_CTRL1, 0x0002, 0x0002);
+		break;
+	}
+}
+
+static void pcie_phy_load_disable(struct ltq_pcie_port *lpp, int slice)
+{
+	/* set the load_en of tx/rx slice to '0' */
+	switch (slice) {
+	case 1:
+		pcie_phy_mask(lpp, PCIE_PHY_TX1_CTRL1, 0x0000, 0x0010);
+		break;
+	case 2:
+		pcie_phy_mask(lpp, PCIE_PHY_TX2_CTRL1, 0x0000, 0x0010);
+		break;
+	case 3:
+		pcie_phy_mask(lpp, PCIE_PHY_RX1_CTRL1, 0x0000, 0x0002);
+		break;
+	}
+}
+
+static void pcie_phy_load_war(struct ltq_pcie_port *lpp)
+{
+	int slice;
+
+	for (slice = 1; slice < 4; slice++) {
+		pcie_phy_load_enable(lpp, slice);
+		udelay(1);
+		pcie_phy_load_disable(lpp, slice);
+	}
+}
+
+static void pcie_phy_tx2_modulation(struct ltq_pcie_port *lpp)
+{
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_MOD1, 0x1FFE, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_MOD2, 0xFFFE, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_MOD3, 0x0601, 0xFFFF);
+	mdelay(1);
+	pcie_phy_mask(lpp, PCIE_PHY_TX2_MOD3, 0x0001, 0xFFFF);
+}
+
+static void pcie_phy_tx1_modulation(struct ltq_pcie_port *lpp)
+{
+	pcie_phy_mask(lpp, PCIE_PHY_TX1_MOD1, 0x1FFE, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_TX1_MOD2, 0xFFFE, 0xFFFF);
+	pcie_phy_mask(lpp, PCIE_PHY_TX1_MOD3, 0x0601, 0xFFFF);
+	mdelay(1);
+	pcie_phy_mask(lpp, PCIE_PHY_TX1_MOD3, 0x0001, 0xFFFF);
+}
+
+static void pcie_phy_tx_modulation_war(struct ltq_pcie_port *lpp)
+{
+	int i;
+
+#define PCIE_PHY_MODULATION_NUM 5
+	for (i = 0; i < PCIE_PHY_MODULATION_NUM; i++) {
+		pcie_phy_tx2_modulation(lpp);
+		pcie_phy_tx1_modulation(lpp);
+	}
+#undef PCIE_PHY_MODULATION_NUM
+}
+
+#ifdef LTQ_PCIE_PHY_REG_DUMP
+static void pcie_lcpll_reg_dump(struct ltq_pcie_port *lpp)
+{
+	dev_info(lpp->dev, "PCIE_LCPLL_CFG0    0x%08x\n",
+		ltq_cgu_r32(PCIE_LCPLL_CFG0));
+	dev_info(lpp->dev, "PCIE_LCPLL_CFG1    0x%08x\n",
+		ltq_cgu_r32(PCIE_LCPLL_CFG1));
+	dev_info(lpp->dev, "PCIE_LCPLL_SSC_CTRL    0x%08x\n",
+		ltq_cgu_r32(PCIE_LCPLL_SSC_CTRL));
+	dev_info(lpp->dev, "PCIE_LCPLL_SSC_SCALE    0x%08x\n",
+		ltq_cgu_r32(PCIE_LCPLL_SSC_SCALE));
+	dev_info(lpp->dev, "PCIE_LCPLL_COEF_0    0x%08x\n",
+		ltq_cgu_r32(PCIE_LCPLL_COEF_0));
+	dev_info(lpp->dev, "PCIE_LCPLL_COEF_1    0x%08x\n",
+		ltq_cgu_r32(PCIE_LCPLL_COEF_1));
+	dev_info(lpp->dev, "PCIE_LCPLL_COEF_2    0x%08x\n",
+		ltq_cgu_r32(PCIE_LCPLL_COEF_2));
+	dev_info(lpp->dev, "PCIE_LCPLL_COEF_3    0x%08x\n",
+		ltq_cgu_r32(PCIE_LCPLL_COEF_3));
+	dev_info(lpp->dev, "PCIE_LCPLL_COEF_4    0x%08x\n",
+		ltq_cgu_r32(PCIE_LCPLL_COEF_4));
+	dev_info(lpp->dev, "PCIE_LCPLL_COEF_5    0x%08x\n",
+		ltq_cgu_r32(PCIE_LCPLL_COEF_5));
+	dev_info(lpp->dev, "PCIE_LCPLL_COEF_6    0x%08x\n",
+		ltq_cgu_r32(PCIE_LCPLL_COEF_6));
+	dev_info(lpp->dev, "PCIE_LCPLL_COEF_7    0x%08x\n",
+		ltq_cgu_r32(PCIE_LCPLL_COEF_7));
+}
+#endif /* LTQ_PCIE_PHY_REG_DUMP */
+
+#define PCIE_LCPLL_LOOP_CNT	100
+
+static void pcie_phy_power_down(struct ltq_pcie_port *lpp)
+{
+	pcie_phy_w32_mask(lpp, 0, PCIE_PHY_PIPE_PD_O, PCIE_PHY_CFG4);
+	mdelay(1);
+}
+
+static void pcie_phy_power_up(struct ltq_pcie_port *lpp)
+{
+	pcie_phy_w32_mask(lpp, PCIE_PHY_PIPE_PD_O, 0, PCIE_PHY_CFG4);
+	mdelay(1);
+}
+
+void pcie_lcpll_init(struct ltq_pcie_port *lpp)
+{
+	pcie_phy_power_down(lpp);
+
+	if (lpp->phy_mode == PCIE_PHY_100MHZ_SSC) {
+		int i;
+
+		if (lcpll_ssc_init)
+			goto out;
+		/* Enable SSC and LCPLL */
+		ltq_cgu_w32(0x10003004, PCIE_LCPLL_CFG1);
+		ltq_cgu_w32(0x10103004, PCIE_LCPLL_CFG1);
+
+		/* Need to bit 0 from 0 to 1 */
+		ltq_cgu_w32(0x00000190, PCIE_LCPLL_CFG0);
+		ltq_cgu_w32(0x00000191, PCIE_LCPLL_CFG0);
+
+		for (i = 0; i < PCIE_LCPLL_LOOP_CNT; i++) {
+			if ((ltq_cgu_r32(PCIE_LCPLL_CFG0) & LCPLL_CFG0_LOCKED))
+				break;
+			mdelay(1);
+		}
+		if (i >= PCIE_LCPLL_LOOP_CNT)
+			pr_info("%s LCPLL not locked yet\n", __func__);
+
+		/* Fixed Coefficient parameters */
+		ltq_cgu_w32(0x0000FF60, PCIE_LCPLL_COEF_0);
+		ltq_cgu_w32(0x0000FF60, PCIE_LCPLL_COEF_1);
+		ltq_cgu_w32(0x0000FF60, PCIE_LCPLL_COEF_2);
+		ltq_cgu_w32(0x0000FF60, PCIE_LCPLL_COEF_3);
+		ltq_cgu_w32(0x000000A0, PCIE_LCPLL_COEF_4);
+		ltq_cgu_w32(0x000000A0, PCIE_LCPLL_COEF_5);
+		ltq_cgu_w32(0x000000A0, PCIE_LCPLL_COEF_6);
+		ltq_cgu_w32(0x000000A0, PCIE_LCPLL_COEF_7);
+
+		/* Program DIV and len parameters */
+		ltq_cgu_w32(0x0000FF1C, PCIE_LCPLL_SSC_CTRL);
+		ltq_cgu_w32(0x0000FF1F, PCIE_LCPLL_SSC_CTRL);
+		ltq_cgu_w32(0x0000FF1C, PCIE_LCPLL_SSC_CTRL);
+		ltq_cgu_w32(0x0000FF1D, PCIE_LCPLL_SSC_CTRL);
+		mdelay(1);
+#ifdef LTQ_PCIE_PHY_REG_DUMP
+		pcie_lcpll_reg_dump(lpp);
+#endif /* LTQ_PCIE_PHY_REG_DUMP */
+		lcpll_ssc_init = true;
+		pr_info("PCIe LCPLL SSC Mode Enabled\n");
+	}
+out:
+	pcie_phy_power_up(lpp);
+}
+
+int pcie_phy_clock_mode_setup(struct ltq_pcie_port *lpp)
+{
+	/* Enable PDI to access PCIe PHY register */
+	pcie_pdi_pmu_enable(lpp);
+
+	/* Configure PLL and PHY clock */
+	pcie_phy_comm_setup(lpp);
+
+	switch (lpp->phy_mode) {
+	case PCIE_PHY_36MHZ:
+	default:
+		pcie_phy_36mhz_mode_setup(lpp);
+		break;
+	case PCIE_PHY_36MHZ_SSC:
+		pcie_phy_36mhz_ssc_mode_setup(lpp);
+		break;
+	case PCIE_PHY_25MHZ:
+		pcie_phy_25mhz_mode_setup(lpp);
+		break;
+	case PCIE_PHY_25MHZ_SSC:
+		pcie_phy_25mhz_ssc_mode_setup(lpp);
+		break;
+	case PCIE_PHY_100MHZ:
+		pcie_phy_100mhz_mode_setup(lpp);
+		break;
+	}
+	/* Enable PCIe PHY and make PLL setting take effect */
+	pcie_phy_pmu_enable(lpp);
+	/* Check if we are in startup_ready status */
+	if (pcie_phy_wait_startup_ready(lpp) != 0)
+		return -1;
+
+	pcie_phy_load_war(lpp);
+
+	/* Apply TX modulation workarounds */
+	pcie_phy_tx_modulation_war(lpp);
+
+#ifdef LTQ_PCIE_PHY_REG_DUMP
+	dev_dbg(lpp->dev, "Modified PHY register dump\n");
+	pcie_phy_reg_dump(lpp);
+#endif
+	return 0;
+}
diff --git a/arch/mips/pci/pcie-lantiq.c b/arch/mips/pci/pcie-lantiq.c
new file mode 100644
--- /dev/null
+++ b/arch/mips/pci/pcie-lantiq.c
@@ -0,0 +1,1976 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2009~2015 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ *  Copyright (C) 2013 John Crispin <blogic@openwrt.org>
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/pci_regs.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_pci.h>
+#include <linux/of_irq.h>
+#include <lantiq.h>
+#include <lantiq_irq.h>
+#include <lantiq_soc.h>
+
+#include "pcie-lantiq.h"
+
+#define ltq_pcie_r32		ltq_r32
+#define ltq_pcie_w32		ltq_w32
+#define ltq_pcie_w32_mask	ltq_w32_mask
+
+/* #define LTQ_PCIE_PHY_DBG */
+
+/* Enable 32bit io due to its mem mapped io nature */
+#define LTQ_PCIE_IO_32BIT
+
+static int pcie_read_config(struct pci_bus *bus, u32 devfn,
+				int where, int size, u32 *value);
+static int pcie_write_config(struct pci_bus *bus, u32 devfn,
+				 int where, int size, u32 value);
+
+static int pcie_force_gen1;
+
+static struct pci_ops pcie_ops = {
+	.read = pcie_read_config,
+	.write = pcie_write_config,
+};
+
+#if defined(LTQ_PCIE_DBG)
+static u32 pcie_debug_flag = PCIE_MSG_ANY & (~PCIE_MSG_CFG);
+static void pcie_debug(const char *fmt, ...)
+{
+	static char buf[256] = { 0 }; /* XXX */
+	va_list ap;
+
+	va_start(ap, fmt);
+	vsnprintf(buf, sizeof(buf), fmt, ap);
+	va_end(ap);
+
+	pr_info("%s", buf);
+}
+#define pcie_dbg(_m, _fmt, args...) do {	\
+	if (pcie_debug_flag & (_m))		\
+		pcie_debug((_fmt), ##args);	\
+} while (0)
+
+#else
+#define pcie_dbg(_m, _fmt, args...)	do {} while (0)
+#endif
+
+static int __init setup_pcie_gen1(char *str)
+{
+	if (!strcmp(str, "off"))
+		pcie_force_gen1 = 0;
+	else if (!strcmp(str, "on"))
+		pcie_force_gen1 = 1;
+	else
+		return 0;
+	return 1;
+}
+__setup("pcie_force_gen1=", setup_pcie_gen1);
+
+static inline u32 pcie_cfg_rd(struct ltq_pcie_port *lpp, u32 reg)
+{
+	return ltq_pcie_r32(lpp->devcfg_base + reg);
+}
+
+static inline  void pcie_cfg_wr(struct ltq_pcie_port *lpp,
+	u32 val, unsigned int reg)
+{
+	ltq_pcie_w32(val, lpp->devcfg_base + reg);
+}
+
+static inline u32 pcie_app_rd(struct ltq_pcie_port *lpp, u32 reg)
+{
+	return ltq_pcie_r32(lpp->app_base + reg);
+}
+
+static inline void pcie_app_wr(struct ltq_pcie_port *lpp,
+	u32 val, unsigned int reg)
+{
+	ltq_pcie_w32(val, lpp->app_base + reg);
+}
+
+static inline void pcie_app_wr_mask(struct ltq_pcie_port *lpp,
+	u32 clear, u32 set, unsigned int reg)
+{
+	pcie_app_wr(lpp, (pcie_app_rd(lpp, reg) & ~(clear)) | (set), reg);
+}
+
+static inline u32 pcie_rc_cfg_rd(struct ltq_pcie_port *lpp, u32 reg)
+{
+	return ltq_pcie_r32(lpp->mem_base + reg);
+}
+
+static inline void pcie_rc_cfg_wr(struct ltq_pcie_port *lpp,
+	 u32 val, unsigned int reg)
+{
+	ltq_pcie_w32(val, lpp->mem_base + reg);
+}
+
+static inline void pcie_rc_cfg_wr_mask(struct ltq_pcie_port *lpp,
+	u32 clear, u32 set, unsigned int reg)
+{
+	pcie_rc_cfg_wr(lpp,
+		(pcie_rc_cfg_rd(lpp, reg) & ~(clear)) | (set), reg);
+}
+
+struct ltq_pcie_port *
+	bus_to_ltq_pcie_port(struct pci_bus *bus)
+{
+	struct pci_controller *hose;
+
+	hose = (struct pci_controller *) bus->sysdata;
+	return container_of(hose, struct ltq_pcie_port, pcic);
+}
+#ifdef LTQ_PCI_PHY_DBG
+/* Generate hot reset, XXX must catpure to verify */
+static void pcie_secondary_bus_reset(struct ltq_pcie_port *lpp)
+{
+	int i;
+#define PCIE_RESET_TIME		20
+
+	/* Assert Secondary Bus Reset */
+	pcie_rc_cfg_wr_mask(lpp, 0, PCIE_INTRBCTRL_RST_SECONDARY_BUS,
+		PCIE_INTRBCTRL);
+
+	/* De-assert Secondary Bus Reset */
+	pcie_rc_cfg_wr_mask(lpp, PCIE_INTRBCTRL_RST_SECONDARY_BUS, 0,
+		PCIE_INTRBCTRL);
+
+	/* XXX, wait at least 100 ms, then restore again */
+	for (i = 0; i < PCIE_RESET_TIME; i++)
+		mdelay(10);
+#undef PCIE_RESET_TIME
+}
+
+/* Error or L0s to L0 */
+static int pcie_retrain_link(struct ltq_pcie_port *lpp)
+{
+	int i;
+#define PCIE_RETRAIN_TIME  1000
+
+	pcie_rc_cfg_wr_mask(lpp, 0, PCIE_LCTLSTS_RETRIAN_LINK, PCIE_LCTLSTS);
+
+	/* Wait for the link to come up */
+	for (i = 0; i < PCIE_RETRAIN_TIME; i++) {
+		if (!(pcie_rc_cfg_rd(lpp, PCIE_LCTLSTS)
+			& PCIE_LCTLSTS_RETRAIN_PENDING))
+			break;
+		udelay(100);
+	}
+	if (i >= PCIE_RETRAIN_TIME) {
+		dev_err(lpp->dev, "%s retrain timeout\n", __func__);
+		return -1;
+	}
+	return 0;
+#undef PCIE_RETRAIN_TIME
+}
+
+static void pcie_disable_scrambling(struct ltq_pcie_port *lpp)
+{
+	pcie_rc_cfg_wr_mask(lpp, 0, PCIE_PLCR_SCRAMBLE_DISABLE, PCIE_PLCR);
+}
+#endif /* LTQ_PCI_PHY_DBG */
+
+static int pcie_ltssm_enable(struct ltq_pcie_port *lpp)
+{
+	int i;
+#define PCIE_LTSSM_ENABLE_TIMEOUT 10
+	/* Enable LTSSM */
+	pcie_app_wr(lpp, PCIE_RC_CCR_LTSSM_ENABLE, PCIE_RC_CCR);
+
+	/* Wait for the link to come up */
+	for (i = 0; i < PCIE_LTSSM_ENABLE_TIMEOUT; i++) {
+		if (!(pcie_rc_cfg_rd(lpp, PCIE_LCTLSTS)
+			& PCIE_LCTLSTS_RETRAIN_PENDING))
+			break;
+		udelay(10);
+	}
+	if (i >= PCIE_LTSSM_ENABLE_TIMEOUT) {
+		dev_err(lpp->dev, "%s link timeout!!!!!\n", __func__);
+		return -1;
+	}
+	return 0;
+#undef PCIE_LTSSM_ENABLE_TIMEOUT
+}
+
+static void pcie_ltssm_disable(struct ltq_pcie_port *lpp)
+{
+	pcie_app_wr(lpp, 0, PCIE_RC_CCR); /* Disable LTSSM */
+	dev_dbg(lpp->dev, "%s PCIE_RC_CCR 0x%08x\n",
+		__func__, pcie_app_rd(lpp, PCIE_RC_CCR));
+}
+
+static void pcie_ahb_bus_error_suppress(struct ltq_pcie_port *lpp)
+{
+	pcie_app_wr(lpp, PCIE_AHB_CTRL_BUS_ERROR_SUPPRESS, PCIE_AHB_CTRL);
+}
+
+static void pcie_status_register_clear(struct ltq_pcie_port *lpp)
+{
+	/* Clear the status register, XXX, seperate function */
+	pcie_app_wr(lpp, 0, PCIE_RC_DR);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_PCICMDSTS);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_DCTLSTS);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_LCTLSTS);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_SLCTLSTS);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_RSTS);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_UES_R);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_UEMR);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_UESR);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_CESR);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_CEMR);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_RESR);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_PVCCRSR);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_VC0_RSR0);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_TPFCS);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_TNPFCS);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_TCFCS);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_QSR);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_IOBLSECS);
+}
+
+/*
+ * Must be done after ltssm due to based on negotiated link
+ * width and payload size
+ * Update the Replay Time Limit. Empirically, some PCIe
+ * devices take a little longer to respond than expected under
+ * load. As a workaround for this we configure the Replay Time
+ * Limit to the value expected for a 512 byte MPS instead of
+ * our actual 128 byte MPS. The numbers below are directly
+ * from the PCIe spec table 3-4/5.
+ * Please note, our PIPE interface is 16b/125MHz, so the table
+ * value has to be divided by 2
+ */
+static  void pcie_replay_time_update(struct ltq_pcie_port *lpp)
+{
+	u32 reg;
+	int nlw;
+	int rtl;
+
+	reg = pcie_rc_cfg_rd(lpp, PCIE_LCTLSTS);
+	nlw = MS(reg, PCIE_LCTLSTS_NEGOTIATED_LINK_WIDTH);
+	switch (nlw) {
+	case PCIE_MAX_LENGTH_WIDTH_X1:
+		if (pcie_phy_clock_ppm_enabled())
+			rtl = 6215; /* 4KB replay timeout */
+		else
+			rtl = 839; /* 512B replay timeout */
+
+		break;
+	case PCIE_MAX_LENGTH_WIDTH_X2:
+		rtl = 818;
+		break;
+	case PCIE_MAX_LENGTH_WIDTH_X4:
+		rtl = 423;
+		break;
+	case PCIE_MAX_LENGTH_WIDTH_X8:
+		rtl = 225;
+		break;
+	default:
+		rtl = 1606;
+		break;
+	}
+	reg = pcie_rc_cfg_rd(lpp, PCIE_ALTRT);
+	reg &= ~PCIE_ALTRT_REPLAY_TIME_LIMIT;
+	reg |= SM(rtl, PCIE_ALTRT_REPLAY_TIME_LIMIT);
+	pcie_rc_cfg_wr(lpp, reg, PCIE_ALTRT);
+	dev_dbg(lpp->dev, "%s PCIE_ALTRT 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_ALTRT));
+}
+
+static int pcie_link_up(struct ltq_pcie_port *lpp)
+{
+	return (pcie_app_rd(lpp, PCIE_PHY_SR) &
+		PCIE_PHY_SR_PHY_LINK_UP) ? 1 : 0;
+}
+
+#ifdef LTQ_PCIE_DBG
+static void pcie_status_registers_dump(struct ltq_pcie_port *lpp)
+{
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_PCICMDSTS: 0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_PCICMDSTS));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_RC_DR:     0x%08x\n",
+		pcie_app_rd(lpp, PCIE_RC_DR));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_DCTLSTS:   0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_DCTLSTS));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_LCTLSTS:   0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_LCTLSTS));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_SLCTLSTS:  0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_SLCTLSTS));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_RSTS:      0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_RSTS));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_UES_R:     0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_UES_R));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_UEMR:      0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_UEMR));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_UESR:      0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_UESR));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_CESR:      0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_CESR));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_CEMR:      0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_CEMR));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_RESR:      0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_RESR));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_ESIR:      0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_ESIR));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_PVCCRSR:   0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_PVCCRSR));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_VC0_RSR0:  0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_VC0_RSR0));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_TPFCS:     0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_TPFCS));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_TNPFCS:    0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_TNPFCS));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_TCFCS:     0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_TCFCS));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_QSR:       0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_QSR));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_VCTAR1:    0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_VCTAR1));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_VCTAR2:    0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_VCTAR2));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_IOBLSECS:  0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_IOBLSECS));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_ALTRT:     0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_ALTRT));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_SNR:       0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_SNR));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_DBR0:      0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_DBR0));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_DBR1:      0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_DBR1));
+}
+
+static void pcie_post_dump(struct ltq_pcie_port *lpp)
+{
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_PCICMDSTS:  0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_PCICMDSTS));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_MBML:       0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_MBML));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_PBML:       0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_PMBL));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_IOBLSECS:   0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_IOBLSECS));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_IO_BANDL:   0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_IO_BANDL));
+	pcie_dbg(PCIE_MSG_INIT, "PCIe_INTRBCTRL:  0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_INTRBCTRL));
+	pcie_dbg(PCIE_MSG_INIT, "Power State:     D%1d\n",
+		pcie_rc_cfg_rd(lpp, PCIE_PM_CSR) &
+			PCIE_PM_CSR_POWER_STATE);
+	pcie_dbg(PCIE_MSG_INIT, "Negotiated Link Width: %d\n",
+		MS(pcie_rc_cfg_rd(lpp, PCIE_LCTLSTS),
+			PCIE_LCTLSTS_NEGOTIATED_LINK_WIDTH));
+	pcie_dbg(PCIE_MSG_INIT, "Number of VCs:    %d\n",
+		pcie_rc_cfg_rd(lpp, PCIE_PVC1) & PCIE_PVC1_EXT_VC_CNT);
+	pcie_dbg(PCIE_MSG_INIT, "Low-priority VCs: %d\n",
+		MS(pcie_rc_cfg_rd(lpp, PCIE_PVC1),
+			PCIE_PVC1_LOW_PRI_EXT_VC_CNT));
+	pcie_dbg(PCIE_MSG_INIT, "VC Arbitration:   0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_PVC2) & PCIE_PVC2_VC_ARB_WRR);
+	pcie_dbg(PCIE_MSG_INIT, "Port Arbitration: 0x%08x\n",
+		pcie_rc_cfg_rd(lpp, PCIE_VC0_RC) & PCIE_VC0_RC_PORT_ARB);
+
+	if (pcie_link_up(lpp))
+		pcie_dbg(PCIE_MSG_INIT, "PCIe PHY Link is UP\n");
+	else
+		pcie_dbg(PCIE_MSG_INIT, "PCIe PHY Link is DOWN!\n");
+
+	if ((pcie_app_rd(lpp, PCIE_RC_DR) & PCIE_RC_DR_DLL_UP))
+		pcie_dbg(PCIE_MSG_INIT, "PCIe DLL is UP\n");
+	else
+		pcie_dbg(PCIE_MSG_INIT, "PCIe DLL is DOWN!\n");
+
+	if ((pcie_rc_cfg_rd(lpp, PCIE_LCTLSTS) & PCIE_LCTLSTS_DLL_ACTIVE))
+		pcie_dbg(PCIE_MSG_INIT, "PCIE_LCTLSTS in DL_Active state!\n");
+	else
+		pcie_dbg(PCIE_MSG_INIT,
+			"PCIE_LCTLSTS NOT in DL_Active state!\n");
+}
+#endif /* LTQ_PCIE_DBG */
+
+/* XXX, this function is not needed in fact */
+static void pcie_mem_io_setup(struct ltq_pcie_port *lpp)
+{
+	u32 reg;
+	/*
+	 * BAR[0:1] readonly register
+	 * RC contains only minimal BARs for packets mapped to this device
+	 * Mem/IO filters defines a range of memory occupied by memory mapped
+	 * IO devices that reside on the downstream side fo the bridge.
+	 */
+	reg = SM(((lpp->mem_phys_base + lpp->mem_size - 1) >> 20),
+		 PCIE_MBML_MEM_LIMIT_ADDR)
+		| SM((lpp->mem_phys_base >> 20), PCIE_MBML_MEM_BASE_ADDR);
+
+	pcie_rc_cfg_wr(lpp, reg, PCIE_MBML);
+
+	dev_dbg(lpp->dev, "%s PCIE_MBML: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_MBML));
+
+#ifdef LTQ_PCIE_PREFETCH_MEM_64BIT
+	reg = SM(((lpp->mem_phys_base + lpp->mem_size - 1) >> 20),
+		PCIE_PMBL_END_ADDR)
+		| SM((lpp->mem_phys_base >> 20),
+		PCIE_PMBL_UPPER_12BIT) | PCIE_PMBL_64BIT_ADDR;
+	pcie_rc_cfg_wr(lpp, reg, PCIE_PMBL);
+
+	/* Must configure upper 32bit */
+	pcie_rc_cfg_wr(lpp, 0, PCIE_PMBU32);
+	pcie_rc_cfg_wr(lpp, 0, PCIE_PMLU32);
+#else
+	/* PCIe_PBML, same as MBML */
+	pcie_rc_cfg_wr(lpp, pcie_rc_cfg_rd(lpp, PCIE_MBML),
+		PCIE_PMBL);
+#endif
+	dev_dbg(lpp->dev, "%s PCIE_PMBL: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_PMBL));
+
+	/* IO Address Range */
+	reg = SM(((lpp->io_phys_base + lpp->io_size - 1) >> 12),
+		 PCIE_IOBLSECS_IO_LIMIT_ADDR)
+		| SM((lpp->io_phys_base >> 12),
+			PCIE_IOBLSECS_IO_BASE_ADDR);
+#ifdef LTQ_PCIE_IO_32BIT
+	reg |= PCIE_IOBLSECS_32BIT_IO_ADDR;
+#endif /* LTQ_PCIE_IO_32BIT */
+	pcie_rc_cfg_wr(lpp, reg, PCIE_IOBLSECS);
+
+	dev_dbg(lpp->dev, "%s PCIE_IOBLSECS: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_IOBLSECS));
+#ifdef LTQ_PCIE_IO_32BIT
+	reg = SM(((lpp->io_phys_base + lpp->io_size - 1) >> 16),
+		 PCIE_IO_BANDL_UPPER_16BIT_IO_LIMIT)
+		| SM((lpp->io_phys_base >> 16),
+			PCIE_IO_BANDL_UPPER_16BIT_IO_BASE);
+	pcie_rc_cfg_wr(lpp, reg, PCIE_IO_BANDL);
+
+	dev_dbg(lpp->dev, "%s PCIE_IO_BANDL: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_IO_BANDL));
+#endif /* LTQ_PCIE_IO_32BIT */
+}
+
+static void pcie_msi_setup(struct ltq_pcie_port *lpp)
+{
+	u32 reg;
+
+	/* XXX, MSI stuff should only apply to EP */
+	/* MSI Capability: Only enable 32-bit addresses */
+	reg = pcie_rc_cfg_rd(lpp, PCIE_MCAPR);
+	reg &= ~PCIE_MCAPR_ADDR64_CAP;
+
+	reg |= PCIE_MCAPR_MSI_ENABLE;
+
+	/* Disable multiple message */
+	reg &= ~(PCIE_MCAPR_MULTI_MSG_CAP | PCIE_MCAPR_MULTI_MSG_ENABLE);
+	pcie_rc_cfg_wr(lpp, reg, PCIE_MCAPR);
+	dev_dbg(lpp->dev, "%s PCIE_MCAPR: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_MCAPR));
+}
+
+static void pcie_pm_setup(struct ltq_pcie_port *lpp)
+{
+	/* Enable PME, Soft reset enabled */
+	pcie_rc_cfg_wr_mask(lpp, 0, PCIE_PM_CSR_PME_ENABLE | PCIE_PM_CSR_SW_RST,
+		PCIE_PM_CSR);
+	dev_dbg(lpp->dev, "%s PCIE_PM_CSR: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_PM_CSR));
+}
+
+static void pcie_bus_setup(struct ltq_pcie_port *lpp)
+{
+	u32 reg;
+
+	reg = SM(0, PCIE_BNR_PRIMARY_BUS_NUM)
+		| SM(1, PCIE_PNR_SECONDARY_BUS_NUM)
+		| SM(0xFF, PCIE_PNR_SUB_BUS_NUM);
+	pcie_rc_cfg_wr(lpp, reg, PCIE_BNR);
+	dev_dbg(lpp->dev, "%s PCIE_BNR: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_BNR));
+}
+
+static void pcie_device_setup(struct ltq_pcie_port *lpp)
+{
+	u32 reg;
+
+	/* Device capability register, set up Maximum payload size */
+	reg = pcie_rc_cfg_rd(lpp, PCIE_DCAP);
+	reg |= PCIE_DCAP_ROLE_BASE_ERR_REPORT;
+	reg |= SM(PCIE_MAX_PAYLOAD_128, PCIE_DCAP_MAX_PAYLOAD_SIZE);
+
+	/* Only available for EP */
+	reg &= ~(PCIE_DCAP_EP_L0S_LATENCY | PCIE_DCAP_EP_L1_LATENCY);
+	pcie_rc_cfg_wr(lpp, reg, PCIE_DCAP);
+	dev_dbg(lpp->dev, "%s PCIE_DCAP: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_DCAP));
+
+	/* Device control and status register */
+	/* Set Maximum Read Request size for the device as a Requestor */
+	reg = pcie_rc_cfg_rd(lpp, PCIE_DCTLSTS);
+
+	/*
+	 * Request size can be larger than the MPS used, but the completions
+	 * returned for the read will be bounded by the MPS size.
+	 * In our system, Max request size depends on AHB/DMA burst size.
+	 * It is 64 bytes. but we set it as 128 as minimum one.
+	 */
+	reg |= SM(PCIE_MAX_PAYLOAD_128, PCIE_DCTLSTS_MAX_READ_SIZE)
+		| SM(PCIE_MAX_PAYLOAD_128, PCIE_DCTLSTS_MAX_PAYLOAD_SIZE);
+
+	/* Enable relaxed ordering, no snoop, and all kinds of errors */
+	reg |= PCIE_DCTLSTS_RELAXED_ORDERING_EN | PCIE_DCTLSTS_ERR_EN |
+		PCIE_DCTLSTS_NO_SNOOP_EN;
+
+	pcie_rc_cfg_wr(lpp, reg, PCIE_DCTLSTS);
+	dev_dbg(lpp->dev, "%s PCIE_DCTLSTS: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_DCTLSTS));
+}
+
+static void pcie_link_setup(struct ltq_pcie_port *lpp)
+{
+	u32 reg;
+#ifdef CONFIG_PCIEASPM
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
+#endif
+	/*
+	 * XXX, Link capability register, bit 18 for EP CLKREQ# dynamic
+	 * clock management for L1, L2/3 CPM  L0s is reported during
+	 * link training via TS1 order set by N_FTS
+	 */
+	reg = pcie_rc_cfg_rd(lpp, PCIE_LCAP);
+	reg &= ~PCIE_LCAP_L0S_EIXT_LATENCY;
+	reg |= SM(3, PCIE_LCAP_L0S_EIXT_LATENCY);
+	pcie_rc_cfg_wr(lpp, reg, PCIE_LCAP);
+	dev_dbg(lpp->dev, "%s PCIE_LCAP: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_LCAP));
+
+	/* Link control and status register */
+	reg = pcie_rc_cfg_rd(lpp, PCIE_LCTLSTS);
+
+	/* Link Enable, ASPM enabled  */
+	reg &= ~PCIE_LCTLSTS_LINK_DISABLE;
+
+	/*
+	 * We use the same physical reference clock that the platform
+	 * provides on the connector It paved the way for ASPM to calculate
+	 * the new exit Latency
+	 */
+	reg |= PCIE_LCTLSTS_SLOT_CLK_CFG;
+	reg |= PCIE_LCTLSTS_COM_CLK_CFG;
+	reg &= ~PCIE_LCTLSTS_ASPM_ENABLE;
+#ifdef CONFIG_PCIEASPM
+	/*
+	 * We should disable ASPM by default except that we have dedicated
+	 * power management support  Enable ASPM will cause the system
+	 * hangup/instability, performance degration
+	 */
+	if (soc->has_gen2)
+		reg |= PCIE_LCTLSTS_ASPM_ENABLE;
+	/* All other jobs left to ASPM module */
+#endif /* CONFIG_PCIEASPM */
+
+	/*
+	 * The maximum size of any completion with data packet is bounded
+	 * by the MPS setting in  device control register
+	 */
+
+	/*
+	 * RCB may cause multiple split transactions, two options available,
+	 * we use 64 byte RCB
+	 */
+	reg &= ~PCIE_LCTLSTS_RCB128;
+
+	pcie_rc_cfg_wr(lpp, reg, PCIE_LCTLSTS);
+	dev_dbg(lpp->dev, "%s PCIE_LCTLSTS: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_LCTLSTS));
+}
+
+static void pcie_link_gen1_setup(struct ltq_pcie_port *lpp)
+{
+	u32 reg;
+
+	reg = pcie_rc_cfg_rd(lpp, PCIE_LCTLSTS2);
+	dev_dbg(lpp->dev, "%s PCIE_LCTLSTS2 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_LCTLSTS2));
+
+	reg &= ~PCIE_LCTLSTS2_TGT_LINK_SPEED;
+	reg |= PCIE_LCTLSTS2_HW_AUTO_DIS |
+		SM(PCIE_LCTLSTS2_TGT_LINK_SPEED_25GT,
+		PCIE_LCTLSTS2_TGT_LINK_SPEED);
+	pcie_rc_cfg_wr(lpp, reg, PCIE_LCTLSTS2);
+	dev_dbg(lpp->dev, "%s PCIE_LCTLSTS2 0x%08x 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_LCTLSTS2), reg);
+}
+
+static void pcie_error_setup(struct ltq_pcie_port *lpp)
+{
+	/*
+	 * Forward ERR_COR, ERR_NONFATAL, ERR_FATAL to the backbone
+	 * Poisoned write TLPs and completions indicating poisoned TLPs
+	 * will set the PCIe_PCICMDSTS.MDPE
+	 */
+	pcie_rc_cfg_wr_mask(lpp, 0, PCIE_INTRBCTRL_SERR_ENABLE |
+		PCIE_INTRBCTRL_PARITY_ERR_RESP_ENABLE,
+		PCIE_INTRBCTRL);
+	dev_dbg(lpp->dev, "%s PCIE_INTRBCTRL: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_INTRBCTRL));
+
+	/*
+	 * Uncorrectable Error Mask Register, Unmask <enable> all bits
+	 * in PCIE_UESR
+	 */
+	pcie_rc_cfg_wr_mask(lpp, PCIE_ALL_UNCORRECTABLE_ERR, 0, PCIE_UEMR);
+	dev_dbg(lpp->dev, "%s PCIE_UEMR: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_UEMR));
+
+	/* Uncorrectable Error Severity Register, ALL errors are FATAL */
+	pcie_rc_cfg_wr(lpp, PCIE_ALL_UNCORRECTABLE_ERR, PCIE_UESR);
+	dev_dbg(lpp->dev, "%s PCIE_UESR: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_UESR));
+
+	/* Correctable Error Mask Register, unmask <enable> all bits */
+	pcie_rc_cfg_wr_mask(lpp, PCIE_CORRECTABLE_ERR, 0, PCIE_CEMR);
+	dev_dbg(lpp->dev, "%s PCIE_CEMR: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_CEMR));
+
+	/* Advanced Error Capabilities and Control Register */
+	/* plat_dev_init will do the related stuff */
+}
+
+static void pcie_root_setup(struct ltq_pcie_port *lpp)
+{
+	/* plat_dev_init will do the related stuff */
+}
+
+static void pcie_vc_setup(struct ltq_pcie_port *lpp)
+{
+	/* Port VC Capability Register 2 */
+	pcie_rc_cfg_wr_mask(lpp, PCIE_PVC2_VC_ARB_WRR,
+		PCIE_PVC2_VC_ARB_16P_FIXED_WRR, PCIE_PVC2);
+	dev_dbg(lpp->dev, "%s PCIE_PVC2: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_PVC2));
+
+	/* VC0 Resource Capability Register */
+	pcie_rc_cfg_wr_mask(lpp, PCIE_VC0_RC_REJECT_SNOOP, 0, PCIE_VC0_RC);
+	dev_dbg(lpp->dev, "%s PCIE_VC0_RC: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_VC0_RC));
+}
+
+static void pcie_speed_change_setup(struct ltq_pcie_port *lpp)
+{
+	u32 reg;
+
+	reg = pcie_rc_cfg_rd(lpp, PCIE_GEN2_CTRL);
+	reg |= PCIE_GEN2_CTRL_SPEED_CHANGE;
+	reg &= ~PCIE_GEN2_CTRL_FTS;
+	reg |= SM(PCIE_GEN2_DEFAULT_FTS_NUM, PCIE_GEN2_CTRL_FTS);
+	pcie_rc_cfg_wr(lpp, reg, PCIE_GEN2_CTRL);
+	dev_dbg(lpp->dev, "%s PCIE_GEN2_CTRL: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_GEN2_CTRL));
+}
+
+static void pcie_port_logic_setup(struct ltq_pcie_port *lpp)
+{
+	u32 reg;
+
+	/*
+	 * FTS number, default 12, increase to 127, may increase
+	 * time from/to L0s to L0
+	 */
+	reg = pcie_rc_cfg_rd(lpp, PCIE_AFR);
+	reg &= ~(PCIE_AFR_FTS_NUM | PCIE_AFR_COM_FTS_NUM);
+	reg |= SM(PCIE_AFR_FTS_NUM_DEFAULT, PCIE_AFR_FTS_NUM)
+		| SM(PCIE_AFR_FTS_NUM_DEFAULT, PCIE_AFR_COM_FTS_NUM);
+	/* L0s and L1 entry latency */
+	reg &= ~(PCIE_AFR_L0S_ENTRY_LATENCY | PCIE_AFR_L1_ENTRY_LATENCY);
+	reg |= SM(PCIE_AFR_L0S_ENTRY_LATENCY_DEFAULT,
+		  PCIE_AFR_L0S_ENTRY_LATENCY)
+		| SM(PCIE_AFR_L1_ENTRY_LATENCY_DEFAULT,
+			PCIE_AFR_L1_ENTRY_LATENCY);
+	pcie_rc_cfg_wr(lpp, reg, PCIE_AFR);
+
+	dev_dbg(lpp->dev, "%s PCIE_AFR: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_AFR));
+
+	/* Port Link Control Register */
+	pcie_rc_cfg_wr_mask(lpp, 0, PCIE_PLCR_DLL_LINK_EN, PCIE_PLCR);
+	dev_dbg(lpp->dev, "%s PCIE_PLCR: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_PLCR));
+
+	/* Lane Skew Register */
+	pcie_rc_cfg_wr_mask(lpp,
+		PCIE_LSR_ACKNAK_DISABLE | PCIE_LSR_FC_DISABLE, 0, PCIE_LSR);
+	dev_dbg(lpp->dev, "%s PCIE_LSR: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_LSR));
+
+	/* Symbol Timer Register and Filter Mask Register 1 */
+	reg =  pcie_rc_cfg_rd(lpp, PCIE_STRFMR);
+
+	/* Default SKP interval is very accurate already, 5us */
+	/* Enable IO/CFG transaction */
+	reg |= PCIE_STRFMR_RX_CFG_TRANS_ENABLE |
+		PCIE_STRFMR_RX_IO_TRANS_ENABLE;
+	/* Disable FC WDT */
+	reg &= ~PCIE_STRFMR_FC_WDT_DISABLE;
+	pcie_rc_cfg_wr(lpp, reg, PCIE_STRFMR);
+	dev_dbg(lpp->dev, "%s PCIE_STRFMR: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_STRFMR));
+
+	/* Filter Masker Register 2 */
+	pcie_rc_cfg_wr_mask(lpp, 0, PCIE_FMR2_VENDOR_MSG1_PASSED_TO_TRGT1 |
+		PCIE_FMR2_VENDOR_MSG0_PASSED_TO_TRGT1, PCIE_FMR2);
+	dev_dbg(lpp->dev, "%s PCIE_FMR2: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_FMR2));
+
+	/* VC0 Completion Receive Queue Control Register */
+	reg = pcie_rc_cfg_rd(lpp, PCIE_VC0_CRQCR);
+	reg &= ~PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE;
+	reg |= SM(PCIE_VC0_TLP_QUEUE_MODE_BYPASS,
+			PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE);
+	pcie_rc_cfg_wr(lpp, reg, PCIE_VC0_CRQCR);
+	dev_dbg(lpp->dev, "%s PCIE_VC0_CRQCR: 0x%08x\n",
+		__func__, pcie_rc_cfg_rd(lpp, PCIE_VC0_CRQCR));
+}
+
+static void pcie_rc_cfg_reg_setup(struct ltq_pcie_port *lpp)
+{
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
+
+	pcie_ltssm_disable(lpp);
+	pcie_mem_io_setup(lpp);
+	pcie_msi_setup(lpp);
+	pcie_pm_setup(lpp);
+	pcie_bus_setup(lpp);
+	pcie_device_setup(lpp);
+	pcie_link_setup(lpp);
+	if (soc->has_gen2) {
+		pcie_speed_change_setup(lpp);
+		if (pcie_force_gen1)
+			pcie_link_gen1_setup(lpp);
+	}
+	pcie_error_setup(lpp);
+	pcie_root_setup(lpp);
+	pcie_vc_setup(lpp);
+	pcie_port_logic_setup(lpp);
+}
+
+static int pcie_wait_phy_link_up(struct ltq_pcie_port *lpp)
+{
+#define PCIE_PHY_LINK_UP_TIMEOUT	3000 /* XXX, tunable */
+#define PCIE_DLL_TIMEOUT		10
+	int i;
+	int rc_port = lpp->id;
+
+	/* Wait for PHY link is up */
+	for (i = 0; i < PCIE_PHY_LINK_UP_TIMEOUT; i++) {
+		if (pcie_link_up(lpp))
+			break;
+
+		udelay(100);
+	}
+	if (i >= PCIE_PHY_LINK_UP_TIMEOUT) {
+		pr_err("%s port %d timeout\n", __func__, rc_port);
+		return -1;
+	}
+	/* Check data link up or not */
+	for (i = 0; i < PCIE_DLL_TIMEOUT; i++) {
+		if ((pcie_app_rd(lpp, PCIE_RC_DR) & PCIE_RC_DR_DLL_UP))
+			break;
+		udelay(1);
+	}
+	if (i >= PCIE_DLL_TIMEOUT) {
+		pr_err("%s port %d DLL link is still down\n",
+			__func__, rc_port);
+		return -1;
+	}
+
+	/* Check Data link active or not */
+	if (!(pcie_rc_cfg_rd(lpp, PCIE_LCTLSTS)
+		& PCIE_LCTLSTS_DLL_ACTIVE)) {
+		pr_err("%s port %d DLL is not active\n",
+			__func__, rc_port);
+		return -1;
+	}
+	return 0;
+#undef PCIE_DLL_TIMEOUT
+#undef PCIE_PHY_LINK_UP_TIMEOUT
+}
+
+static int pcie_app_loigc_setup(struct ltq_pcie_port *lpp)
+{
+#ifdef LTQ_PCIE_PHY_DBG
+	pcie_disable_scrambling(lpp);
+#endif /* LTQ_PCIE_PHY_DBG */
+	pcie_ahb_bus_error_suppress(lpp);
+	/* Pull PCIe EP out of reset */
+	pcie_device_rst_deassert(lpp);
+	/* Start LTSSM training between RC and EP */
+	pcie_ltssm_enable(lpp);
+	/* Check PHY status after enabling LTSSM */
+	if (pcie_wait_phy_link_up(lpp) != 0)
+		return -1;
+
+	return 0;
+}
+
+/*
+ * Table 359 Enhanced Configuration Address Mapping1)
+ * 1) This table is defined in Table 7-1, page 341, PCI Express
+ * Base Specification v1.1
+ * Memory Address PCI Express Configuration Space
+ * A[(20+n-1):20] Bus Number 1 < n < 8
+ * A[19:15] Device Number
+ * A[14:12] Function Number
+ * A[11:8] Extended Register Number
+ * A[7:2] Register Number
+ * A[1:0] Along with size of the access, used to generate Byte Enables
+ * For VR9, only the address bits [22:0] are mapped to the configuration space:
+ * . Address bits [22:20] select the target bus (1-of-8)1)
+ * . Address bits [19:15] select the target device (1-of-32) on the bus
+ * . Address bits [14:12] select the target function (1-of-8) within the device.
+ * . Address bits [11:2] selects the target dword (1-of-1024) within
+ *   the selected function.s configuration space
+ * .Address bits [1:0] define the start byte location within the selected dword.
+ */
+static u32 pcie_bus_addr(u8 bus_num, u16 devfn, int where)
+{
+	u32 addr;
+	u8 bus;
+
+	if (!bus_num) {
+		/* type 0 */
+		addr = ((PCI_SLOT(devfn) & 0x1F) << 15)
+		| ((PCI_FUNC(devfn) & 0x7) << 12)
+		| ((where & 0xFFF) & ~3);
+	} else {
+		bus = bus_num;
+		/* type 1, only support 8 buses */
+		addr = ((bus & 0x7) << 20)
+		| ((PCI_SLOT(devfn) & 0x1F) << 15)
+		| ((PCI_FUNC(devfn) & 0x7) << 12)
+		| ((where & 0xFFF) & ~3);
+	}
+	pcie_dbg(PCIE_MSG_CFG,
+		"%s: bus addr : %02x:%02x.%01x/%02x, addr=%08x\n",
+		__func__, bus_num, PCI_SLOT(devfn), PCI_FUNC(devfn),
+		where, addr);
+	return addr;
+}
+
+static int pcie_valid_config(struct ltq_pcie_port *lpp, int bus, int dev)
+{
+	/* RC itself */
+	if ((bus == 0) && (dev == 0))
+		return 1;
+
+	/* No physical link */
+	if (!pcie_link_up(lpp))
+		return 0;
+
+	/* Bus zero only has RC itself
+	 * XXX, check if EP will be integrated
+	 */
+	if ((bus == 0) && (dev != 0))
+		return 0;
+
+	/* Maximum 8 buses supported */
+	if (bus > 8)
+		return 0;
+
+	/*
+	 * PCIe is PtP link, one bus only supports only one device
+	 * except bus zero and PCIe switch which is virtual bus device
+	 * The following two conditions really depends on the system design
+	 * and attached the device.
+	 * XXX, how about more new switch
+	 */
+	if ((bus == 1) && (dev != 0))
+		return 0;
+
+	if ((bus >= 3) && (dev != 0))
+		return 0;
+	return 1;
+}
+
+static u32 pcie_bus_enum_read_hack(int bus_nr_offset, int where, u32 value)
+{
+	u32 tvalue = value;
+
+	if (where == PCI_PRIMARY_BUS) {
+		u8 primary, secondary, subordinate;
+
+		primary = tvalue & 0xFF;
+		secondary = (tvalue >> 8) & 0xFF;
+		subordinate = (tvalue >> 16) & 0xFF;
+		primary += bus_nr_offset;
+		secondary += bus_nr_offset;
+		subordinate += bus_nr_offset;
+		tvalue = (tvalue & 0xFF000000) | (u32) primary |
+			(u32) (secondary << 8) | (u32) (subordinate << 16);
+	}
+	return tvalue;
+}
+
+static u32 pcie_bus_enum_write_hack(int bus_nr_offset, int where, u32 value)
+{
+	u32 tvalue = value;
+
+	if (where == PCI_PRIMARY_BUS) {
+		u8 primary, secondary, subordinate;
+
+		primary = tvalue & 0xFF;
+		secondary = (tvalue >> 8) & 0xFF;
+		subordinate = (tvalue >> 16) & 0xFF;
+		if (primary > 0 && primary != 0xFF)
+			primary -= bus_nr_offset;
+
+		if (secondary > 0 && secondary != 0xFF)
+			secondary -= bus_nr_offset;
+
+		if (subordinate > 0 && subordinate != 0xFF)
+			subordinate -= bus_nr_offset;
+
+		tvalue = (tvalue & 0xFF000000) | (u32) primary |
+			(u32) (secondary << 8) | (u32) (subordinate << 16);
+	} else if (where == PCI_SUBORDINATE_BUS) {
+		u8 subordinate = tvalue & 0xFF;
+
+		subordinate =
+			subordinate > 0 ? subordinate - bus_nr_offset : 0;
+		tvalue = subordinate;
+	}
+	return tvalue;
+}
+
+static int pcie_dev_header_type_bridge(struct pci_bus *bus, u32 devfn)
+{
+	int ret = 1;
+	struct pci_dev *pdev;
+
+	/* Sanity check */
+	pdev = pci_get_slot(bus, devfn);
+	if (pdev == NULL) {
+		ret = 0;
+		goto out;
+	}
+
+	/* Only care about PCI bridge */
+	if (pdev->hdr_type != PCI_HEADER_TYPE_BRIDGE)
+		ret = 0;
+
+out:
+	return ret;
+}
+
+/**
+ * \fn static int pcie_read_config(struct pci_bus *bus, u32 devfn,
+ *                   int where, int size, u32 *value)
+ * \brief Read a value from configuration space
+ *
+ * \param[in] bus    Pointer to pci bus
+ * \param[in] devfn  PCI device function number
+ * \param[in] where  PCI register number
+ * \param[in] size   Register read size
+ * \param[out] value    Pointer to return value
+ * \return  PCIBIOS_BAD_REGISTER_NUMBER Invalid register number
+ * \return  PCIBIOS_FUNC_NOT_SUPPORTED  PCI function not supported
+ * \return  PCIBIOS_DEVICE_NOT_FOUND    PCI device not found
+ * \return  PCIBIOS_SUCCESSFUL          OK
+ * \ingroup PCIE_OS
+ */
+static int
+pcie_read_config(struct pci_bus *bus, u32 devfn,
+		int where, int size, u32 *value)
+{
+	u32 data = 0;
+	int bus_number = bus->number;
+	int bus_nr_offset;
+	static const u32 mask[8] = { 0, 0xff, 0xffff, 0, 0xffffffff, 0, 0, 0 };
+	int ret = PCIBIOS_SUCCESSFUL;
+	unsigned long flags;
+	struct ltq_pcie_port *lpp = bus_to_ltq_pcie_port(bus);
+
+
+	if (unlikely(size != 1 && size != 2 && size != 4)) {
+		ret = PCIBIOS_BAD_REGISTER_NUMBER;
+		goto out;
+	}
+
+	/* Make sure the address is aligned to natural boundary */
+	if (unlikely(((size - 1) & where))) {
+		ret = PCIBIOS_BAD_REGISTER_NUMBER;
+		goto out;
+	}
+
+	/*
+	 * If we are not the first controller, we have to deduce the bus number
+	 * before the current bus so that it assume its bus number starts
+	 * from 0 in host controller
+	 */
+	bus_nr_offset = pci_find_preexist_bus_nr(bus);
+	bus_number -= bus_nr_offset;
+
+	/*
+	 * We need to force the bus number to be zero on the root
+	 * bus. Linux numbers the 2nd root bus to start after all
+	 * busses on root 0.
+	 */
+	if (bus->parent == NULL)
+		bus_number = 0;
+
+
+	/*
+	 * PCIe only has a single device connected to it. It is
+	 * always device ID 0. Don't bother doing reads for other
+	 * device IDs on the first segment.
+	 */
+	if ((bus_number == 0) && (PCI_SLOT(devfn) != 0)) {
+		ret = PCIBIOS_FUNC_NOT_SUPPORTED;
+		goto out;
+	}
+
+	if (pcie_valid_config(lpp, bus_number, PCI_SLOT(devfn)) == 0) {
+		*value = 0xffffffff;
+		ret = PCIBIOS_DEVICE_NOT_FOUND;
+		goto out;
+	}
+
+	pcie_dbg(PCIE_MSG_READ_CFG, "%s: %02x:%02x.%01x/%02x:%01d\n",
+		__func__, bus_number, PCI_SLOT(devfn),
+		PCI_FUNC(devfn), where, size);
+
+	spin_lock_irqsave(&lpp->lock, flags);
+	if (bus_number == 0) { /* RC itself */
+		u32 t;
+
+		t = (where & ~3);
+		data = pcie_rc_cfg_rd(lpp, t);
+		pcie_dbg(PCIE_MSG_READ_CFG,
+			"%s: rd local cfg, offset:%08x, data:%08x\n",
+			__func__, t, data);
+	} else {
+		u32 addr = pcie_bus_addr(bus_number, devfn, where);
+
+		data = pcie_cfg_rd(lpp, addr);
+		if (lpp->outbound_swap)
+			data = le32_to_cpu(data);
+	}
+
+	/* To get a correct PCI topology, we have to restore
+	 * the bus number to OS */
+	if (pcie_dev_header_type_bridge(bus, devfn))
+		data = pcie_bus_enum_read_hack(bus_nr_offset, where, data);
+
+	spin_unlock_irqrestore(&lpp->lock, flags);
+	pcie_dbg(PCIE_MSG_READ_CFG,
+		"%s: read config: data=%08x raw=%08x\n", __func__,
+		(data >> (8 * (where & 3))) & mask[size & 7], data);
+
+	*value = (data >> (8 * (where & 3))) & mask[size & 7];
+out:
+	return ret;
+}
+
+static u32 pcie_size_to_value(int where, int size, u32 data, u32 value)
+{
+	u32 shift;
+	u32 tdata = data;
+
+	switch (size) {
+	case 1:
+		shift = (where & 0x3) << 3;
+		tdata &= ~(0xffU << shift);
+		tdata |= ((value & 0xffU) << shift);
+		break;
+	case 2:
+		shift = (where & 3) << 3;
+		tdata &= ~(0xffffU << shift);
+		tdata |= ((value & 0xffffU) << shift);
+		break;
+	case 4:
+		tdata = value;
+		break;
+	}
+	return tdata;
+}
+
+/**
+ * \fn static static int pcie_write_config(struct pci_bus *bus, u32 devfn,
+ *                 int where, int size, u32 value)
+ * \brief Write a value to PCI configuration space
+ *
+ * \param[in] bus    Pointer to pci bus
+ * \param[in] devfn  PCI device function number
+ * \param[in] where  PCI register number
+ * \param[in] size   The register size to be written
+ * \param[in] value  The valule to be written
+ * \return PCIBIOS_BAD_REGISTER_NUMBER Invalid register number
+ * \return PCIBIOS_DEVICE_NOT_FOUND    PCI device not found
+ * \return PCIBIOS_SUCCESSFUL          OK
+ * \ingroup PCIE_OS
+ */
+static int
+pcie_write_config(struct pci_bus *bus, u32 devfn,
+		      int where, int size, u32 value)
+{
+	int bus_number = bus->number;
+	int bus_nr_offset;
+	int ret = PCIBIOS_SUCCESSFUL;
+	struct ltq_pcie_port *lpp = bus_to_ltq_pcie_port(bus);
+	u32 tvalue = value;
+	u32 data;
+	unsigned long flags;
+
+	/* Make sure the address is aligned to natural boundary */
+	if (unlikely(((size - 1) & where))) {
+		ret = PCIBIOS_BAD_REGISTER_NUMBER;
+		goto out;
+	}
+
+	/*
+	 * If we are not the first controller, we have to deduce
+	 * the bus number before the current bus
+	 * so that it assume its bus number starts from 0 in host controller
+	 */
+	bus_nr_offset = pci_find_preexist_bus_nr(bus);
+	bus_number -= bus_nr_offset;
+
+	/*
+	 * We need to force the bus number to be zero on the root
+	 * bus. Linux numbers the 2nd root bus to start after all
+	 * busses on root 0.
+	 */
+	if (bus->parent == NULL)
+		bus_number = 0;
+
+	if (pcie_valid_config(lpp, bus_number, PCI_SLOT(devfn)) == 0) {
+		ret = PCIBIOS_DEVICE_NOT_FOUND;
+		goto out;
+	}
+
+	pcie_dbg(PCIE_MSG_WRITE_CFG,
+		"%s: %02x:%02x.%01x/%02x:%01d value=%08x\n",
+		__func__, bus_number, PCI_SLOT(devfn),
+		PCI_FUNC(devfn), where, size, value);
+
+	/* XXX, some PCIe device may need some delay */
+	spin_lock_irqsave(&lpp->lock, flags);
+	/*
+	 * To configure the correct bus topology using native way,
+	 * we have to cheat Os so that it can configure the PCIe
+	 * hardware correctly.
+	 */
+	if (pcie_dev_header_type_bridge(bus, devfn))
+		tvalue = pcie_bus_enum_write_hack(bus_nr_offset,
+			where, value);
+
+	if (bus_number == 0) {/* RC itself */
+		u32 t;
+
+		t = (where & ~3);
+		pcie_dbg(PCIE_MSG_WRITE_CFG,
+			"%s: wr local cfg, offset:%08x, fill:%08x\n",
+			__func__, t, value);
+		data = pcie_rc_cfg_rd(lpp, t);
+		pcie_dbg(PCIE_MSG_WRITE_CFG,
+			"%s: rd local cfg, offset:%08x, data:%08x\n",
+			__func__, t, data);
+
+		data = pcie_size_to_value(where, size, data, tvalue);
+
+		pcie_dbg(PCIE_MSG_WRITE_CFG,
+			"%s: wr local cfg, offset:%08x, value:%08x\n",
+			__func__, t, data);
+		pcie_rc_cfg_wr(lpp, data, t);
+		pcie_dbg(PCIE_MSG_WRITE_CFG,
+			"%s: rd local cfg, offset:%08x, value:%08x\n",
+			__func__, t, pcie_rc_cfg_rd(lpp, t));
+	} else {
+		u32 addr = pcie_bus_addr(bus_number, devfn, where);
+
+		pcie_dbg(PCIE_MSG_WRITE_CFG,
+			"%s: wr cfg, offset:%08x, fill:%08x\n",
+			__func__, addr, value);
+		data = pcie_cfg_rd(lpp, addr);
+
+		if (lpp->outbound_swap)
+			data = le32_to_cpu(data);
+
+		pcie_dbg(PCIE_MSG_WRITE_CFG,
+			"%s: rd cfg, offset:%08x, data:%08x\n",
+			__func__, addr, data);
+
+		data = pcie_size_to_value(where, size, data, tvalue);
+		if (lpp->outbound_swap)
+			data = cpu_to_le32(data);
+		pcie_dbg(PCIE_MSG_WRITE_CFG,
+			"%s: wr cfg, offset:%08x, value:%08x\n",
+			__func__, addr, data);
+		pcie_cfg_wr(lpp, data, addr);
+		pcie_dbg(PCIE_MSG_WRITE_CFG,
+			"%s: rd cfg, offset:%08x, value:%08x\n",
+			__func__, addr, pcie_cfg_rd(lpp, addr));
+	}
+	spin_unlock_irqrestore(&lpp->lock, flags);
+out:
+	return ret;
+}
+
+#ifdef LTQ_PCIE_BASIC_ERROR_INT
+
+#ifdef LTQ_PCIE_DBG
+static const char * const pcie_err_str[] = {
+	"AER",
+	"AER-MSI(X)",
+	"PME interrupt",
+	"Hotplug",
+	"Vendor Msg",
+	"Correctable Error",
+	"Non-Fatal Error",
+	"Fatal Error",
+	"PME Msg",
+	"PME Turn Off Ack",
+	"AHB Fatal Error",
+	"Link Auto BW",
+	"BW Mgmt",
+	"INTA",
+	"INTB",
+	"INTC",
+	"INTD",
+	"Wakeup"
+};
+
+static const char *pcie_errno_to_str(u32 value)
+{
+	/* If multiple interrupt bits set, only the first low bit reported */
+	if (ffs(value) > ARRAY_SIZE(pcie_err_str))
+		return "Spurious Interrupt";
+	else
+		return pcie_err_str[ffs(value) - 1];
+}
+#endif /* LTQ_PCIE_DBG */
+
+static void pcie_core_int_clear_all(int irq, struct pci_dev *dev, void *context)
+{
+	u32 reg;
+	struct ltq_pcie_port *lpp;
+	lpp = bus_to_ltq_pcie_port(dev->bus);
+
+	reg = pcie_app_rd(lpp, PCIE_IRNCR);
+#ifdef LTQ_PCIE_DBG
+	dev_dbg(lpp->dev, "%s port %d PCIE_IRNCR: %s\n",
+		__func__, lpp->id,
+		pcie_errno_to_str(pcie_app_rd(lpp, PCIE_IRNCR)));
+#endif
+#ifdef LTQ_PCIE_AER_REPORT
+	if ((reg & PCIE_IRN_AER_REPORT) != 0)
+		aer_irq(irq, context);
+
+#endif /* LTQ_PCIE_AER_REPORT */
+	reg &= PCIE_RC_CORE_COMBINED_INT;
+	pcie_app_wr(lpp, reg, PCIE_IRNCR);
+}
+
+static irqreturn_t
+pcie_rc_core_isr(int irq, void *context)
+{
+	struct pci_dev *dev = aer_dev_to_pci_dev(context);
+	pcie_core_int_clear_all(irq, dev, context);
+	return IRQ_HANDLED;
+}
+
+static void pcie_rc_core_int_init(struct ltq_pcie_port *lpp)
+{
+	/* Disable core interrupt */
+	pcie_app_wr_mask(lpp, PCIE_RC_CORE_COMBINED_INT, 0, PCIE_IRNEN);
+	dev_dbg(lpp->dev, "%s PCIE_IRNEN: 0x%08x\n",
+		__func__, pcie_app_rd(lpp, PCIE_IRNEN));
+
+	/* Clear it first */
+	pcie_app_wr_mask(lpp, PCIE_RC_CORE_COMBINED_INT,
+		PCIE_RC_CORE_COMBINED_INT,  PCIE_IRNCR);
+	dev_dbg(lpp->dev, "%s PCIE_IRNCR: 0x%08x\n",
+		__func__, pcie_app_rd(lpp, PCIE_IRNCR));
+}
+
+int pcie_rc_aer_irq_register(struct pci_dev *dev, void *context)
+{
+	int ret = 0;
+	struct ltq_pcie_port *lpp;
+	struct platform_device *pdev;
+
+	lpp = bus_to_ltq_pcie_port(dev->bus);
+	pdev = to_platform_device(lpp->dev);
+	lpp->err_irq = platform_get_irq_byname(pdev, "ir");
+	if (lpp->err_irq  <= 0) {
+		dev_err(&pdev->dev, "failed to get pcie err irq\n");
+		return -ENODEV;
+	}
+	sprintf(lpp->irq_name, "pci_ir%d", lpp->id);
+	ret = devm_request_irq(&pdev->dev, lpp->err_irq,
+		pcie_rc_core_isr, IRQF_DISABLED, lpp->irq_name, context);
+	if (ret) {
+		dev_err(&pdev->dev, "%s request irq %d failed\n",
+			__func__, lpp->err_irq);
+		return -ENODEV;
+	}
+	/* Enable error interrupts */
+	pcie_app_wr_mask(lpp, PCIE_RC_CORE_COMBINED_INT,
+		PCIE_RC_CORE_COMBINED_INT, PCIE_IRNEN);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pcie_rc_aer_irq_register);
+#endif /* LTQ_PCIE_BASIC_ERROR_INT */
+
+/**
+ * \fn int ltq_pcie_bios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+ * \brief Map a PCI device to the appropriate interrupt line
+ *
+ * \param[in] dev    The Linux PCI device structure for the device to map
+ * \param[in] slot   The slot number for this device on __BUS 0__. Linux
+ *                   enumerates through all the bridges and figures out the
+ *                   slot on Bus 0 where this device eventually hooks to.
+ * \param[in] pin    The PCI interrupt pin read from the device, then swizzled
+ *                   as it goes through each bridge.
+ * \return Interrupt number for the device
+ * \ingroup PCIE_OS
+ */
+static int ltq_pcie_bios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	struct of_irq dev_irq;
+	u32 irq_bit = 0;
+	int irq = 0;
+	struct ltq_pcie_port *lpp;
+	lpp = bus_to_ltq_pcie_port(dev->bus);
+
+	dev_dbg(lpp->dev,
+		"%s port %d dev %s slot %d pin %d\n", __func__,
+		lpp->id, pci_name(dev), slot, pin);
+
+	if ((pin == PCIE_LEGACY_DISABLE) || (pin > PCIE_LEGACY_INT_MAX)) {
+		dev_warn(lpp->dev, "WARNING: dev %s: invalid interrupt pin %d\n",
+			pci_name(dev), pin);
+		return -1;
+	}
+	if (of_irq_map_pci(dev, &dev_irq)) {
+		dev_err(lpp->dev,
+		"trying to map irq for unknown slot:%d pin:%d\n",
+			slot, pin);
+		return 0;
+	}
+	irq = irq_create_of_mapping(dev_irq.controller,
+		dev_irq.specifier, dev_irq.size);
+
+	/* Pin to irq offset bit position */
+	irq_bit = BIT((pin + PCIE_INTX_OFFSET));
+
+	/* Clear possible pending interrupts first */
+	pcie_app_wr_mask(lpp, 0, irq_bit, PCIE_IRNCR);
+	dev_dbg(lpp->dev, "%s PCIE_IRNCR: 0x%08x\n",
+		__func__, pcie_app_rd(lpp, PCIE_IRNCR));
+
+	pcie_app_wr_mask(lpp, 0, irq_bit, PCIE_IRNEN);
+	dev_dbg(lpp->dev,  "%s PCIE_IRNEN: 0x%08x\n",
+		__func__, pcie_app_rd(lpp, PCIE_IRNEN));
+	dev_dbg(lpp->dev, "%s dev %s irq %d assigned\n",
+		__func__, pci_name(dev), irq);
+	dev_dbg(lpp->dev, "%s dev %s: exit\n", __func__, pci_name(dev));
+	return irq;
+}
+
+/**
+ * \fn int ltq_pcie_bios_plat_dev_init(struct pci_dev *dev)
+ * \brief Called to perform platform specific PCI setup
+ *
+ * \param[in] dev The Linux PCI device structure for the device to map
+ * \return OK
+ * \ingroup PCIE_OS
+ */
+static int ltq_pcie_bios_plat_dev_init(struct pci_dev *dev)
+{
+	u16 config;
+#ifdef LTQ_PCIE_BASIC_ERROR_INT
+	int pos;
+#ifdef LTQ_PCIE_AER_REPORT
+	u32 dconfig;
+#endif /* LTQ_PCIE_AER_REPORT */
+#endif /* LTQ_PCIE_BASIC_ERROR_INT */
+	struct ltq_pcie_port *lpp;
+	const struct ltq_pcie_soc_data *soc;
+
+	lpp = bus_to_ltq_pcie_port(dev->bus);
+	soc = lpp->soc_data;
+
+	/* Enable reporting System errors and parity errors on all devices */
+	/* Enable parity checking and error reporting */
+	pci_read_config_word(dev, PCI_COMMAND, &config);
+	config |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR
+		/*| PCI_COMMAND_INVALIDATE | PCI_COMMAND_FAST_BACK */;
+	pci_write_config_word(dev, PCI_COMMAND, config);
+
+	if (dev->subordinate) {
+		/* Set latency timers on sub bridges */
+		pci_write_config_byte(dev, PCI_SEC_LATENCY_TIMER, 0x40);
+		/* More bridge error detection */
+		pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &config);
+		config |= PCI_BRIDGE_CTL_PARITY | PCI_BRIDGE_CTL_SERR;
+		pci_write_config_word(dev, PCI_BRIDGE_CONTROL, config);
+	}
+#ifdef LTQ_PCIE_BASIC_ERROR_INT
+	/* Enable the PCIe normal error reporting */
+	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (pos) {
+		/* Disable system error generation in response
+		   to error messages */
+		pci_read_config_word(dev, pos + PCI_EXP_RTCTL, &config);
+		config &= ~(PCI_EXP_RTCTL_SECEE
+			| PCI_EXP_RTCTL_SENFEE | PCI_EXP_RTCTL_SEFEE);
+		pci_write_config_word(dev, pos + PCI_EXP_RTCTL, config);
+
+		/* Clear PCIE Capability's Device Status */
+		pci_read_config_word(dev, pos + PCI_EXP_DEVSTA, &config);
+		pci_write_config_word(dev, pos + PCI_EXP_DEVSTA, config);
+
+		/* Update Device Control */
+		pci_read_config_word(dev, pos + PCI_EXP_DEVCTL, &config);
+		/* Correctable Error Reporting */
+		config |= PCI_EXP_DEVCTL_CERE;
+		/* Non-Fatal Error Reporting */
+		config |= PCI_EXP_DEVCTL_NFERE;
+		/* Fatal Error Reporting */
+		config |= PCI_EXP_DEVCTL_FERE;
+		/* Unsupported Request */
+		config |= PCI_EXP_DEVCTL_URRE;
+		pci_write_config_word(dev, pos + PCI_EXP_DEVCTL, config);
+	}
+#ifdef LTQ_PCIE_AER_REPORT
+	/* Find the Advanced Error Reporting capability */
+	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
+	if (pos) {
+		/* Clear Uncorrectable Error Status */
+		pci_read_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS,
+				&dconfig);
+		pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS,
+				dconfig);
+		/* Enable reporting of all uncorrectable errors */
+		/* Uncorrectable Error Mask - turned on bits disable errors */
+		pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, 0);
+		/*
+		 * Leave severity at HW default. This only controls if
+		 * errors are reported as uncorrectable or
+		 * correctable, not if the error is reported.
+		 */
+		/* PCI_ERR_UNCOR_SEVER - Uncorrectable Error Severity */
+		/* Clear Correctable Error Status */
+		pci_read_config_dword(dev, pos + PCI_ERR_COR_STATUS,
+				&dconfig);
+		pci_write_config_dword(dev, pos + PCI_ERR_COR_STATUS,
+				dconfig);
+		/* Enable reporting of all correctable errors */
+		/* Correctable Error Mask - turned on bits disable errors */
+		pci_write_config_dword(dev, pos + PCI_ERR_COR_MASK, 0);
+		/* Advanced Error Capabilities */
+		pci_read_config_dword(dev, pos + PCI_ERR_CAP, &dconfig);
+		/* ECRC Generation Enable */
+		if (dconfig & PCI_ERR_CAP_ECRC_GENC)
+			dconfig |= PCI_ERR_CAP_ECRC_GENE;
+
+		/* ECRC Check Enable */
+		if (dconfig & PCI_ERR_CAP_ECRC_CHKC)
+			dconfig |= PCI_ERR_CAP_ECRC_CHKE;
+
+		pci_write_config_dword(dev, pos + PCI_ERR_CAP, dconfig);
+
+		/* PCI_ERR_HEADER_LOG - Header Log Register (16 bytes) */
+		/* Enable Root Port's interrupt in response to error messages */
+		pci_write_config_dword(dev, pos + PCI_ERR_ROOT_COMMAND,
+				PCI_ERR_ROOT_CMD_COR_EN |
+				PCI_ERR_ROOT_CMD_NONFATAL_EN |
+				PCI_ERR_ROOT_CMD_FATAL_EN);
+		/* Clear the Root status register */
+		pci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS,
+			&dconfig);
+		pci_write_config_dword(dev, pos + PCI_ERR_ROOT_STATUS,
+			dconfig);
+	}
+#endif /* LTQ_PCIE_AER_REPORT */
+#endif /* LTQ_PCIE_BASIC_ERROR_INT */
+	/* WAR, only 128 MRRS is supported, force all EPs to support
+	 * this value for all legacy SoCs */
+	if (!soc->has_gen2)
+		pcie_set_readrq(dev, 128);
+	return 0;
+}
+
+static void pcie_phy_rst(struct ltq_pcie_port *lpp)
+{
+	pcie_phy_rst_assert(lpp);
+	pcie_phy_rst_deassert(lpp);
+
+	/* Make sure PHY PLL is stable */
+	udelay(20);
+}
+
+static int pcie_rc_initialize(struct ltq_pcie_port *lpp)
+{
+	int i;
+	int loopcnt;
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
+
+#define PCIE_PHY_LOOP_CNT	5
+
+	if (soc->has_gen2)
+		loopcnt = 1;
+	else
+		loopcnt = PCIE_PHY_LOOP_CNT;
+
+	pcie_ahb_pmu_setup(lpp);
+
+	pcie_rcu_endian_setup(lpp);
+
+	pcie_ep_rst_init(lpp);
+
+#ifndef CONFIG_USE_EMULATOR
+	if (soc->has_gen2)
+		pcie_lcpll_init(lpp);
+#endif /* CONFIG_USE_EMULATION */
+	/*
+	 * XXX, PCIe elastic buffer bug will cause not to be detected. One more
+	 * reset PCIe PHY will solve this issue
+	 */
+	for (i = 0; i < loopcnt; i++) {
+		/* Disable PCIe PHY Analog part for sanity check */
+		pcie_phy_pmu_disable(lpp);
+		pcie_phy_rst(lpp);
+		/* PCIe Core reset enabled, low active, sw programmed */
+		pcie_core_rst_assert(lpp);
+		/* Put PCIe EP in reset status */
+		pcie_device_rst_assert(lpp);
+		/* PCI PHY & Core reset disabled, high active, sw programmed */
+		pcie_core_rst_deassert(lpp);
+	#ifndef CONFIG_USE_EMULATOR
+		/* Already in a quiet state, program PLL, enable PHY,
+		 * check ready bit */
+		if (!soc->has_gen2) {
+			if (pcie_phy_clock_mode_setup(lpp) != 0)
+				return -EIO;
+		}
+	#endif /* CONFIG_USE_EMULATOR */
+
+		/* Enable PCIe PHY and Clock */
+		pcie_core_pmu_setup(lpp);
+
+		pcie_phy_clk_out(lpp);
+
+		/* Clear status registers */
+		pcie_status_register_clear(lpp);
+
+		if (IS_ENABLED(CONFIG_PCI_MSI))
+			pcie_msi_init(lpp);
+
+		pcie_rc_cfg_reg_setup(lpp);
+
+		/* Once link is up, break out */
+		if (pcie_app_loigc_setup(lpp) == 0)
+			break;
+	}
+	if (i >= loopcnt) {
+		pr_err("%s port %d link up failed!!!!!\n",
+			__func__, lpp->id);
+		return -EIO;
+	}
+	/* NB, don't increase ACK/NACK timer timeout value, which will
+	 * cause a lot of COR errors */
+	pcie_replay_time_update(lpp);
+#ifdef LTQ_PCIE_DBG
+	pcie_post_dump(lpp);
+	pcie_status_registers_dump(lpp);
+#endif /* LTQ_PCIE_DBG */
+	return 0;
+}
+
+static int ltq_pcie_clks_get(struct ltq_pcie_port *lpp)
+{
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
+
+	if (soc->has_phy_clk) {
+		lpp->phy_clk = devm_clk_get(lpp->dev, "phy");
+		if (IS_ERR(lpp->phy_clk))
+			return PTR_ERR(lpp->phy_clk);
+	}
+
+	lpp->core_clk = devm_clk_get(lpp->dev, "ctl");
+	if (IS_ERR(lpp->core_clk))
+		return PTR_ERR(lpp->core_clk);
+
+	if (soc->has_msi_clk) {
+		lpp->msi_clk = devm_clk_get(lpp->dev, "msi");
+		if (IS_ERR(lpp->msi_clk))
+			return PTR_ERR(lpp->msi_clk);
+	}
+
+	if (soc->has_pdi_clk) {
+		lpp->pdi_clk = devm_clk_get(lpp->dev, "pdi");
+		if (IS_ERR(lpp->pdi_clk))
+			return PTR_ERR(lpp->pdi_clk);
+	}
+
+	if (soc->has_ahb_clk) {
+		lpp->ahb_clk = clk_get(NULL, "ahb");
+		if (IS_ERR(lpp->ahb_clk))
+			return PTR_ERR(lpp->ahb_clk);
+	}
+
+	if (soc->has_bus_clk) {
+		lpp->bus_clk = devm_clk_get(lpp->dev, "bus");
+		if (IS_ERR(lpp->bus_clk))
+			return PTR_ERR(lpp->bus_clk);
+	}
+	return 0;
+}
+
+static int ltq_pcie_resets_get(struct ltq_pcie_port *lpp)
+{
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
+
+	lpp->phy_rst = devm_reset_control_get(lpp->dev, "phy");
+	if (IS_ERR(lpp->phy_rst))
+		return PTR_ERR(lpp->phy_rst);
+
+	if (soc->has_core_rst) {
+		lpp->core_rst = devm_reset_control_get(lpp->dev, "core");
+		if (IS_ERR(lpp->core_rst))
+			return PTR_ERR(lpp->core_rst);
+	}
+	return 0;
+}
+
+static int pcie_parse_dt(struct ltq_pcie_port *lpp)
+{
+	u32 prop;
+	struct resource *res;
+	struct device *dev = lpp->dev;
+	struct device_node *np = dev->of_node;
+	struct platform_device *pdev;
+
+	pdev = to_platform_device(lpp->dev);
+
+	if (!of_property_read_u32(np, "lantiq,rst-high-active", &prop))
+		lpp->high_active_rst = prop;
+
+	if (!of_property_read_u32(np, "lantiq,rst-interval", &prop))
+		lpp->rst_interval = prop;
+
+	if (!of_property_read_u32(np, "lantiq,inbound-swap", &prop))
+		lpp->inbound_swap = prop;
+
+	if (!of_property_read_u32(np, "lantiq,outbound-swap", &prop))
+		lpp->outbound_swap = prop;
+
+	if (!of_property_read_u32(np, "lantiq,phy-mode", &prop))
+		lpp->phy_mode = prop;
+	dev_dbg(dev,
+		"rst %d rst_interval %d inbound_swap %d, outbound_swap %d phy_mode %d\n",
+		lpp->high_active_rst, lpp->rst_interval,
+		lpp->inbound_swap, lpp->outbound_swap, lpp->phy_mode);
+
+	if (!of_property_read_u32(np, "lantiq,inbound-shift", &prop))
+		lpp->inbound_shift = prop;
+
+	if (!of_property_read_u32(np, "lantiq,outbound-shift", &prop))
+		lpp->outbound_shift = prop;
+
+	if (!of_property_read_u32(np, "lantiq,clkout", &prop))
+		lpp->clk_out_pin = prop;
+
+	dev_dbg(dev,
+		"inbound-shift %d outbound-shift %d clk_out_pin %d\n",
+		lpp->inbound_shift, lpp->outbound_shift, lpp->clk_out_pin);
+
+	/* Controller Cfg Register */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "csr");
+	if (!res)
+		return -EINVAL;
+	lpp->mem_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(lpp->mem_base))
+		return PTR_ERR(lpp->mem_base);
+	dev_dbg(dev, "%s rc %d csr %p\n", __func__, lpp->id, lpp->mem_base);
+
+	/* dev cfg space */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "cfg");
+	if (!res)
+		return -EINVAL;
+	lpp->devcfg_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(lpp->devcfg_base))
+		return PTR_ERR(lpp->devcfg_base);
+	dev_dbg(dev, "%s rc cfg %p\n", __func__, lpp->devcfg_base);
+
+	/* Applicaton logic */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "app");
+	if (!res)
+		return -EINVAL;
+	lpp->app_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(lpp->app_base))
+		return PTR_ERR(lpp->app_base);
+	dev_dbg(dev, "%s rc app_base %p\n", __func__, lpp->app_base);
+
+	/* phy reg */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phy");
+	if (!res)
+		return -EINVAL;
+	lpp->phy_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(lpp->phy_base))
+		return PTR_ERR(lpp->phy_base);
+	dev_dbg(dev, "%s rc phy_base %p\n", __func__, lpp->phy_base);
+
+	/* msi physical space */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "msi");
+	if (!res)
+		return -EINVAL;
+	lpp->msi_base = res->start;
+	dev_dbg(dev, "%s rc msi_base 0x%08x\n", __func__, (u32)lpp->msi_base);
+
+	/* msi pic base */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pic");
+	if (!res)
+		return -EINVAL;
+	lpp->msi_pic = devm_ioremap_resource(dev, res);
+	if (IS_ERR(lpp->msi_pic))
+		return PTR_ERR(lpp->msi_pic);
+	dev_dbg(dev, "%s rc msi_pic %p\n", __func__, lpp->msi_pic);
+	return 0;
+}
+
+static int pcie_get_resources(struct platform_device *pdev)
+{
+	int err;
+	struct ltq_pcie_port *lpp;
+
+	lpp = platform_get_drvdata(pdev);
+
+	err = ltq_pcie_clks_get(lpp);
+	if (err) {
+		dev_err(&pdev->dev, "failed to get clks: %d\n", err);
+		return err;
+	}
+
+	err = ltq_pcie_resets_get(lpp);
+	if (err) {
+		dev_err(&pdev->dev, "failed to get resets: %d\n", err);
+		return err;
+	}
+
+	return pcie_parse_dt(lpp);
+}
+
+static const struct ltq_pcie_soc_data xrx200_pcie_data = {
+	.num_ports = 1,
+	.has_phy_clk = true,
+	.has_ahb_clk = true,
+	.has_bus_clk = true,
+	.has_pdi_clk = true,
+	.has_msi_clk = true,
+	.has_core_rst = true,
+	.has_clk_out = false,
+	.has_gen2 = false,
+	.has_ahb2m_endian = true,
+	.has_ahb4s_endian = false,
+	.has_ahb3m_endian = false,
+	.ahb2m_endian_ctrl_shift = 1,
+	.ahb4s_endian_ctrl_shift = 0,
+	.ahb3m_endian_ctrl_shift = 0,
+	.per_rc_max_msi_irqs = 4,
+};
+
+static const struct ltq_pcie_soc_data xrx300_pcie_data = {
+	.num_ports = 2,
+	.has_phy_clk = true,
+	.has_ahb_clk = false,
+	.has_bus_clk = false,
+	.has_pdi_clk = true,
+	.has_msi_clk = true,
+	.has_core_rst = true,
+	.has_clk_out = false,
+	.has_gen2 = false,
+	.has_ahb2m_endian = false,
+	.has_ahb4s_endian = true,
+	.has_ahb3m_endian = true,
+	.ahb2m_endian_ctrl_shift = 0,
+	.ahb4s_endian_ctrl_shift = 0,
+	.ahb3m_endian_ctrl_shift = 1,
+	.per_rc_max_msi_irqs = 4,
+};
+
+static const struct ltq_pcie_soc_data xrx330_pcie_data = {
+	.num_ports = 3,
+	.has_phy_clk = true,
+	.has_ahb_clk = false,
+	.has_bus_clk = false,
+	.has_pdi_clk = true,
+	.has_msi_clk = true,
+	.has_core_rst = true,
+	.has_clk_out = false,
+	.has_gen2 = false,
+	.has_ahb2m_endian = false,
+	.has_ahb4s_endian = true,
+	.has_ahb3m_endian = true,
+	.ahb2m_endian_ctrl_shift = 0,
+	.ahb4s_endian_ctrl_shift = 0,
+	.ahb3m_endian_ctrl_shift = 1,
+	.per_rc_max_msi_irqs = 4,
+};
+
+static const struct ltq_pcie_soc_data xrx500_pcie_data = {
+	.num_ports = 3,
+	.has_phy_clk = false,
+	.has_ahb_clk = false,
+	.has_bus_clk = false,
+	.has_pdi_clk = false,
+	.has_msi_clk = false,
+	.has_core_rst = false,
+	.has_clk_out = true,
+	.has_gen2 = true,
+	.has_ahb2m_endian = false,
+	.has_ahb4s_endian = false,
+	.has_ahb3m_endian = false,
+	.ahb2m_endian_ctrl_shift = 0,
+	.ahb4s_endian_ctrl_shift = 0,
+	.ahb3m_endian_ctrl_shift = 0,
+	.per_rc_max_msi_irqs = 8,
+};
+
+static const struct of_device_id of_ltq_pcie_match[] = {
+	{ .compatible = "lantiq,pcie-xrx200", .data = &xrx200_pcie_data },
+	{ .compatible = "lantiq,pcie-xrx300", .data = &xrx300_pcie_data },
+	{ .compatible = "lantiq,pcie-xrx330", .data = &xrx330_pcie_data },
+	{ .compatible = "lantiq,pcie-xrx500", .data = &xrx500_pcie_data },
+
+	{}
+};
+MODULE_DEVICE_TABLE(of, of_ltq_pcie_match);
+
+static int ltq_pcie_probe(struct platform_device *pdev)
+{
+	int id;
+	int ret;
+	const struct of_device_id *match;
+	void __iomem *io_map_base;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct ltq_pcie_port *lpp;
+
+	ltq_pci_map_irq = ltq_pcie_bios_map_irq;
+	ltq_pci_plat_arch_init = ltq_pcie_bios_plat_dev_init;
+	ltq_pci_plat_dev_init = NULL;
+
+	match = of_match_device(of_ltq_pcie_match, &pdev->dev);
+	if (!match)
+		return -ENODEV;
+
+	lpp = devm_kzalloc(dev, sizeof(*lpp), GFP_KERNEL);
+	if (!lpp)
+		return -ENOMEM;
+
+	/* SoC specific data */
+	lpp->soc_data = match->data;
+
+	id = of_alias_get_id(np, "pcie");
+	if (id < 0) {
+		dev_err(&pdev->dev, "failed to get alias id, errno %d\n", id);
+		ret = id;
+		goto err;
+	}
+
+	if (id > (lpp->soc_data->num_ports - 1)) {
+		dev_err(&pdev->dev, "Port out of range %d\n", id);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	lpp->id = id;
+
+	lpp->dev = dev;
+
+	platform_set_drvdata(pdev, lpp);
+
+	pcie_get_resources(pdev);
+
+	lpp->pcic.pci_ops = &pcie_ops;
+	lpp->pcic.io_resource = &lpp->io;
+	lpp->pcic.mem_resource = &lpp->mem;
+#ifdef CONFIG_PCI_MSI
+	lpp->pcic.msi_chip = &ltq_msi_chip;
+#endif
+	/* Load PCI I/O and memory resources from DT */
+	pci_load_of_ranges(&lpp->pcic, np);
+	lpp->mem_phys_base = lpp->mem.start;
+	lpp->mem_size = resource_size(&lpp->mem);
+	lpp->io_phys_base = lpp->io.start;
+	lpp->io_size = resource_size(&lpp->io);
+
+	if (pcie_rc_initialize(lpp) == 0) {
+		/* Otherwise, warning will pop up */
+		io_map_base =
+			ioremap(lpp->io.start, lpp->io_size);
+		if (io_map_base == NULL) {
+			dev_err(lpp->dev, "%s io space ioremap failed\n",
+				__func__);
+			ret = -ENOMEM;
+			goto err;
+		}
+		spin_lock_init(&lpp->lock);
+		lpp->pcic.io_map_base = (unsigned long) io_map_base;
+		lpp->io_base = lpp->pcic.io_map_base;
+		register_pci_controller(&lpp->pcic);
+
+	#ifdef LTQ_PCIE_BASIC_ERROR_INT
+		pcie_rc_core_int_init(lpp);
+	#endif /* LTQ_PCIE_BASIC_ERROR_INT */
+	}
+	pr_info("Lantiq PCIe Root Complex Port %d Init Done\n", lpp->id);
+	return 0;
+err:
+	devm_kfree(dev, lpp);
+	return ret;
+}
+
+static void ltq_pcie_shutdown(struct platform_device *pdev)
+{
+}
+
+static struct platform_driver ltq_pcie_driver = {
+	.probe		= ltq_pcie_probe,
+	.driver = {
+		.name	= "ltq-pcie",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_ltq_pcie_match,
+	},
+	.shutdown	= ltq_pcie_shutdown,
+};
+
+static int __init ltq_pcie_bios_init(void)
+{
+	int ret = platform_driver_register(&ltq_pcie_driver);
+	if (ret)
+		pr_info("pcie: Error registering pcie platform driver!\b");
+	return ret;
+}
+
+arch_initcall(ltq_pcie_bios_init);
+
+MODULE_LICENSE("GPL V2");
+MODULE_AUTHOR("Lei Chuanhua <Chuanhua.Lei@lantiq.com>");
+MODULE_SUPPORTED_DEVICE("Lantiq builtin PCIe Controller");
+MODULE_DESCRIPTION("Lantiq builtin PCIe Controller Driver");
diff --git a/arch/mips/pci/pcie-lantiq.h b/arch/mips/pci/pcie-lantiq.h
--- a/arch/mips/pci/pcie-lantiq.h
+++ b/arch/mips/pci/pcie-lantiq.h
@@ -1,1305 +1,1545 @@
-/******************************************************************************
-**
-** FILE NAME    : ifxmips_pcie_reg.h
-** PROJECT      : IFX UEIP for VRX200
-** MODULES      : PCIe module
-**
-** DATE         : 02 Mar 2009
-** AUTHOR       : Lei Chuanhua
-** DESCRIPTION  : PCIe Root Complex Driver
-** COPYRIGHT    :       Copyright (c) 2009
-**                      Infineon Technologies AG
-**                      Am Campeon 1-12, 85579 Neubiberg, Germany
-**
-**    This program is free software; you can redistribute it and/or modify
-**    it under the terms of the GNU General Public License as published by
-**    the Free Software Foundation; either version 2 of the License, or
-**    (at your option) any later version.
-** HISTORY
-** $Version $Date        $Author         $Comment
-** 0.0.1    17 Mar,2009  Lei Chuanhua    Initial version
-*******************************************************************************/
-#ifndef IFXMIPS_PCIE_REG_H
-#define IFXMIPS_PCIE_REG_H
-#include <linux/version.h>
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2009~2015 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+#ifndef PCIE_LANTIQ_H
+#define PCIE_LANTIQ_H
 #include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/reset.h>
 #include <linux/pci.h>
 #include <linux/interrupt.h>
+#include <linux/spinlock.h>
+
+#include <lantiq.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <lantiq_soc.h>
+
+
 /*!
- \file ifxmips_pcie_reg.h
- \ingroup IFX_PCIE  
- \brief header file for PCIe module register definition
+ \defgroup PCIE  PCI Express bus driver module
+ \brief  PCI Express IP module support VRX200/ARX300/HN
 */
-/* PCIe Address Mapping Base */
-#define PCIE_CFG_PHY_BASE        0x1D000000UL
-#define PCIE_CFG_BASE           (KSEG1 + PCIE_CFG_PHY_BASE)
-#define PCIE_CFG_SIZE           (8 * 1024 * 1024)
 
-#define PCIE_MEM_PHY_BASE        0x1C000000UL
-#define PCIE_MEM_BASE           (KSEG1 + PCIE_MEM_PHY_BASE)
-#define PCIE_MEM_SIZE           (16 * 1024 * 1024)
-#define PCIE_MEM_PHY_END        (PCIE_MEM_PHY_BASE + PCIE_MEM_SIZE - 1)
+/*!
+ \defgroup PCIE_OS OS APIs
+ \ingroup PCIE
+ \brief PCIe bus driver OS interface functions
+*/
 
-#define PCIE_IO_PHY_BASE         0x1D800000UL
-#define PCIE_IO_BASE            (KSEG1 + PCIE_IO_PHY_BASE)
-#define PCIE_IO_SIZE            (1 * 1024 * 1024)
-#define PCIE_IO_PHY_END         (PCIE_IO_PHY_BASE + PCIE_IO_SIZE - 1)
+/*!
+ \file pcie-lantiq.h
+ \ingroup PCIE
+ \brief header file for PCIe module common header file
+*/
 
-#define PCIE_RC_CFG_BASE        (KSEG1 + 0x1D900000)
-#define PCIE_APP_LOGIC_REG      (KSEG1 + 0x1E100900)
-#define PCIE_MSI_PHY_BASE        0x1F600000UL
+#define MS(_v, _f)  (((_v) & (_f)) >> _f##_S)
+#define SM(_v, _f)  (((_v) << _f##_S) & (_f))
 
-#define PCIE_PDI_PHY_BASE        0x1F106800UL
-#define PCIE_PDI_BASE           (KSEG1 + PCIE_PDI_PHY_BASE)
-#define PCIE_PDI_SIZE            0x400
+/* Debug option, more will be coming */
 
-#define PCIE1_CFG_PHY_BASE        0x19000000UL
-#define PCIE1_CFG_BASE           (KSEG1 + PCIE1_CFG_PHY_BASE)
-#define PCIE1_CFG_SIZE           (8 * 1024 * 1024)
+#define PCIE_MSG_MSI		0x00000001
+#define PCIE_MSG_ISR		0x00000002
+#define PCIE_MSG_FIXUP		0x00000004
+#define PCIE_MSG_READ_CFG	0x00000008
+#define PCIE_MSG_WRITE_CFG	0x00000010
+#define PCIE_MSG_CFG		(PCIE_MSG_READ_CFG | PCIE_MSG_WRITE_CFG)
+#define PCIE_MSG_REG		0x00000020
+#define PCIE_MSG_INIT		0x00000040
+#define PCIE_MSG_ERR		0x00000080
+#define PCIE_MSG_PHY		0x00000100
+#define PCIE_MSG_ANY		0x000001ff
 
-#define PCIE1_MEM_PHY_BASE        0x18000000UL
-#define PCIE1_MEM_BASE           (KSEG1 + PCIE1_MEM_PHY_BASE)
-#define PCIE1_MEM_SIZE           (16 * 1024 * 1024)
-#define PCIE1_MEM_PHY_END        (PCIE1_MEM_PHY_BASE + PCIE1_MEM_SIZE - 1)
+/* #define LTQ_PCIE_DBG */
 
-#define PCIE1_IO_PHY_BASE         0x19800000UL
-#define PCIE1_IO_BASE            (KSEG1 + PCIE1_IO_PHY_BASE)
-#define PCIE1_IO_SIZE            (1 * 1024 * 1024)
-#define PCIE1_IO_PHY_END         (PCIE1_IO_PHY_BASE + PCIE1_IO_SIZE - 1)
+/* Reuse kernel stuff, but we need to differentiate baseline
+ * error reporting and AEE */
+#ifdef CONFIG_PCIEAER
+#define LTQ_PCIE_BASIC_ERROR_INT
+#endif /* CONFIG_PCIEAER */
 
-#define PCIE1_RC_CFG_BASE        (KSEG1 + 0x19900000)
-#define PCIE1_APP_LOGIC_REG      (KSEG1 + 0x1E100700)
-#define PCIE1_MSI_PHY_BASE        0x1F400000UL
+/* XXX, should be only enabled after LTQ_PCIE_BASIC_ERROR_INT */
+#define LTQ_PCIE_AER_REPORT
 
-#define PCIE1_PDI_PHY_BASE        0x1F700400UL
-#define PCIE1_PDI_BASE           (KSEG1 + PCIE1_PDI_PHY_BASE)
-#define PCIE1_PDI_SIZE            0x400
+/* Always report fatal error */
+#define PCIE_KASSERT(exp, msg) do {	\
+	if (unlikely(!(exp))) {	\
+		printk msg;		\
+		BUG();			\
+	}				\
+} while (0)
 
-#define PCIE_CFG_PORT_TO_BASE(X)     ((X) > 0 ? (PCIE1_CFG_BASE) : (PCIE_CFG_BASE))
-#define PCIE_MEM_PORT_TO_BASE(X)     ((X) > 0 ? (PCIE1_MEM_BASE) : (PCIE_MEM_BASE))
-#define PCIE_IO_PORT_TO_BASE(X)      ((X) > 0 ? (PCIE1_IO_BASE) : (PCIE_IO_BASE))
-#define PCIE_MEM_PHY_PORT_TO_BASE(X) ((X) > 0 ? (PCIE1_MEM_PHY_BASE) : (PCIE_MEM_PHY_BASE))
-#define PCIE_MEM_PHY_PORT_TO_END(X)  ((X) > 0 ? (PCIE1_MEM_PHY_END) : (PCIE_MEM_PHY_END))
-#define PCIE_IO_PHY_PORT_TO_BASE(X)  ((X) > 0 ? (PCIE1_IO_PHY_BASE) : (PCIE_IO_PHY_BASE))
-#define PCIE_IO_PHY_PORT_TO_END(X)   ((X) > 0 ? (PCIE1_IO_PHY_END) : (PCIE_IO_PHY_END))
-#define PCIE_APP_PORT_TO_BASE(X)     ((X) > 0 ? (PCIE1_APP_LOGIC_REG) : (PCIE_APP_LOGIC_REG))
-#define PCIE_RC_PORT_TO_BASE(X)      ((X) > 0 ? (PCIE1_RC_CFG_BASE) : (PCIE_RC_CFG_BASE))
-#define PCIE_PHY_PORT_TO_BASE(X)     ((X) > 0 ? (PCIE1_PDI_BASE) : (PCIE_PDI_BASE))
+/* Port number definition */
+enum {
+	LTQ_PCIE_PORT0 = 0,
+	LTQ_PCIE_PORT1,
+	LTQ_PCIE_PORT2,
+};
+
+#define MSI_IRQ_PIC_TABLE_SZ		16
+
+/* Interrupt related stuff */
+#define PCIE_LEGACY_DISABLE		0
+#define PCIE_LEGACY_INTA		1
+#define PCIE_LEGACY_INTB		2
+#define PCIE_LEGACY_INTC		3
+#define PCIE_LEGACY_INTD		4
+#define PCIE_LEGACY_INT_MAX		PCIE_LEGACY_INTD
+
+struct msi_irq_idx {
+	int irq;
+	int idx;
+};
+
+struct ltq_msi_pic {
+	volatile u32 pic_table[MSI_IRQ_PIC_TABLE_SZ];
+	volatile u32 pic_endian; /* 0x40  */
+};
+
+struct msi_irq {
+	struct ltq_msi_pic *msi_pic_p;
+	u32 msi_phy_base;
+	struct msi_irq_idx msi_irq_idx[MSI_IRQ_PIC_TABLE_SZ];
+	spinlock_t msi_lock;
+	/*
+	 * Each bit in msi_free_irq_bitmask represents a MSI interrupt that is
+	 * in use.
+	 */
+	u16 msi_free_irq_bitmask;
+
+	/*
+	 * Each bit in msi_multiple_irq_bitmask tells that the device using
+	 * this bit in msi_free_irq_bitmask is also using the next bit. This
+	 * is used so we can disable all of the MSI interrupts when a device
+	 * uses multiple.
+	 */
+	u16 msi_multiple_irq_bitmask;
+};
+
+/* used to differentiate between Lantiq  SoC generations */
+struct ltq_pcie_soc_data {
+	unsigned int num_ports;
+	bool has_phy_clk;
+	bool has_ahb_clk;
+	bool has_bus_clk;
+	bool has_pdi_clk;
+	bool has_msi_clk;
+	bool has_core_rst;
+	bool has_clk_out;
+	bool has_gen2;
+	bool has_ahb2m_endian;
+	bool has_ahb4s_endian;
+	bool has_ahb3m_endian;
+	int ahb2m_endian_ctrl_shift;
+	int ahb4s_endian_ctrl_shift;
+	int ahb3m_endian_ctrl_shift;
+	unsigned int per_rc_max_msi_irqs;
+};
+
+/** Structure used to extract physical Root Complex index number,
+ * it is shared between RC and EP for the first two fields */
+struct ltq_pcie_port {
+	/*!< PCI controller information used as system specific information */
+	struct pci_controller pcic;
+	void __iomem	*app_base;
+	int id; /* Physical RC Index */
+	struct device	*dev;
+	spinlock_t lock; /*!< Per controller lock */
+	 /*!< RC specific, per host bus information */
+	void __iomem	*mem_base;
+	void __iomem	*devcfg_base;
+	phys_addr_t	cfg_phy_base;
+
+	void __iomem	*phy_base;
+	phys_addr_t	msi_base;
+	void __iomem	*msi_pic;
+	u32		io_base;
+	phys_addr_t	io_phys_base;
+	u32		io_size;
+	phys_addr_t	mem_phys_base;
+	u32		mem_size;
+	struct resource		io;
+	struct resource		mem;
+	struct resource		prefetch;
+	int		reset_gpio;
+	bool		high_active_rst;
+	u32		rst_interval;
+	bool		inbound_swap;
+	u32		inbound_shift;
+	bool		outbound_swap;
+	u32		outbound_shift;
+	u32		clk_out_pin;
+	int		err_irq;
+	char		irq_name[16];
+	struct msi_irq	msi_irqs;
+	int		phy_mode;
+	struct clk *phy_clk;
+	struct clk *core_clk;
+	struct clk *msi_clk;
+	struct clk *pdi_clk;
+	struct clk *ahb_clk;
+	struct clk *bus_clk;
+	struct reset_control *phy_rst;
+	struct reset_control *core_rst;
+	const struct ltq_pcie_soc_data *soc_data;
+};
+
+extern int pcie_phy_clock_ppm_enabled(void);
+extern int pcie_phy_clock_mode_setup(struct ltq_pcie_port *lpp);
+extern void pcie_lcpll_init(struct ltq_pcie_port *lpp);
+extern void pcie_msi_pic_init(struct ltq_pcie_port *lpp);
+extern struct ltq_pcie_port *bus_to_ltq_pcie_port(struct pci_bus *bus);
+
+extern int (*ltq_pci_plat_dev_init)(struct pci_dev *dev);
+extern int (*ltq_pci_plat_arch_init) (struct pci_dev *dev);
+extern int (*ltq_pci_map_irq) (const struct pci_dev *dev, u8 slot, u8 pin);
+#ifdef LTQ_PCIE_BASIC_ERROR_INT
+extern struct pci_dev *aer_dev_to_pci_dev(void *context);
+extern irqreturn_t aer_irq(int irq, void *context);
+#endif /* LTQ_PCIE_BASIC_ERROR_INT */
 
 /* PCIe Application Logic Register */
 /* RC Core Control Register */
-#define PCIE_RC_CCR(X)                      (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x10)
+#define PCIE_RC_CCR		0x10
+
 /* This should be enabled after initializing configuratin registers
  * Also should check link status retraining bit
  */
-#define PCIE_RC_CCR_LTSSM_ENABLE             0x00000001    /* Enable LTSSM to continue link establishment */
+/* Enable LTSSM to continue link establishment */
+#define PCIE_RC_CCR_LTSSM_ENABLE	0x00000001
+/* RC Core Debug Register */
+#define PCIE_RC_DR		0x14
 
-/* RC Core Debug Register */
-#define PCIE_RC_DR(X)                       (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x14)
-#define PCIE_RC_DR_DLL_UP                    0x00000001  /* Data Link Layer Up */
-#define PCIE_RC_DR_CURRENT_POWER_STATE       0x0000000E  /* Current Power State */
-#define PCIE_RC_DR_CURRENT_POWER_STATE_S     1
-#define PCIE_RC_DR_CURRENT_LTSSM_STATE       0x000001F0  /* Current LTSSM State */
-#define PCIE_RC_DR_CURRENT_LTSSM_STATE_S     4
+#define PCIE_RC_DR_DLL_UP			0x00000001
+#define PCIE_RC_DR_CURRENT_POWER_STATE		0x0000000E
+#define PCIE_RC_DR_CURRENT_POWER_STATE_S	1
+#define PCIE_RC_DR_CURRENT_LTSSM_STATE		0x000001F0
+#define PCIE_RC_DR_CURRENT_LTSSM_STATE_S	4
 
-#define PCIE_RC_DR_PM_DEV_STATE              0x00000E00  /* Power Management D-State */
-#define PCIE_RC_DR_PM_DEV_STATE_S            9
+#define PCIE_RC_DR_PM_DEV_STATE			0x00000E00
+#define PCIE_RC_DR_PM_DEV_STATE_S		9
 
-#define PCIE_RC_DR_PM_ENABLED                0x00001000  /* Power Management State from PMU */
-#define PCIE_RC_DR_PME_EVENT_ENABLED         0x00002000  /* Power Management Event Enable State */
-#define PCIE_RC_DR_AUX_POWER_ENABLED         0x00004000  /* Auxiliary Power Enable */
+#define PCIE_RC_DR_PM_ENABLED			0x00001000
+#define PCIE_RC_DR_PME_EVENT_ENABLED		0x00002000
+#define PCIE_RC_DR_AUX_POWER_ENABLED		0x00004000
 
 /* Current Power State Definition */
 enum {
-    PCIE_RC_DR_D0 = 0,
-    PCIE_RC_DR_D1,   /* Not supported */
-    PCIE_RC_DR_D2,   /* Not supported */
-    PCIE_RC_DR_D3,
-    PCIE_RC_DR_UN,
+	PCIE_RC_DR_D0 = 0,
+	PCIE_RC_DR_D1, /* Not supported */
+	PCIE_RC_DR_D2, /* Not supported */
+	PCIE_RC_DR_D3,
+	PCIE_RC_DR_UN,
 };
 
 /* PHY Link Status Register */
-#define PCIE_PHY_SR(X)                      (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x18)
-#define PCIE_PHY_SR_PHY_LINK_UP              0x00000001   /* PHY Link Up/Down Indicator */
+#define PCIE_PHY_SR		0x18
+
+#define PCIE_PHY_SR_PHY_LINK_UP		0x00000001
 
 /* Electromechanical Control Register */
-#define PCIE_EM_CR(X)                       (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x1C)
-#define PCIE_EM_CR_CARD_IS_PRESENT           0x00000001  /* Card Presence Detect State */
-#define PCIE_EM_CR_MRL_OPEN                  0x00000002  /* MRL Sensor State */
-#define PCIE_EM_CR_POWER_FAULT_SET           0x00000004  /* Power Fault Detected */
-#define PCIE_EM_CR_MRL_SENSOR_SET            0x00000008  /* MRL Sensor Changed */
-#define PCIE_EM_CR_PRESENT_DETECT_SET        0x00000010  /* Card Presense Detect Changed */
-#define PCIE_EM_CR_CMD_CPL_INT_SET           0x00000020  /* Command Complete Interrupt */
-#define PCIE_EM_CR_SYS_INTERLOCK_SET         0x00000040  /* System Electromechanical IterLock Engaged */
-#define PCIE_EM_CR_ATTENTION_BUTTON_SET      0x00000080  /* Attention Button Pressed */
+#define PCIE_EM_CR		0x1C
+
+#define PCIE_EM_CR_CARD_IS_PRESENT		0x00000001
+#define PCIE_EM_CR_MRL_OPEN			0x00000002
+#define PCIE_EM_CR_POWER_FAULT_SET		0x00000004
+#define PCIE_EM_CR_MRL_SENSOR_SET		0x00000008
+#define PCIE_EM_CR_PRESENT_DETECT_SET		0x00000010
+#define PCIE_EM_CR_CMD_CPL_INT_SET		0x00000020
+#define PCIE_EM_CR_SYS_INTERLOCK_SET		0x00000040
+#define PCIE_EM_CR_ATTENTION_BUTTON_SET		0x00000080
 
 /* Interrupt Status Register */
-#define PCIE_IR_SR(X)                       (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x20)
-#define PCIE_IR_SR_PME_CAUSE_MSI             0x00000002  /* MSI caused by PME */
-#define PCIE_IR_SR_HP_PME_WAKE_GEN           0x00000004  /* Hotplug PME Wake Generation */
-#define PCIE_IR_SR_HP_MSI                    0x00000008  /* Hotplug MSI */
-#define PCIE_IR_SR_AHB_LU_ERR                0x00000030  /* AHB Bridge Lookup Error Signals */
-#define PCIE_IR_SR_AHB_LU_ERR_S              4
-#define PCIE_IR_SR_INT_MSG_NUM               0x00003E00  /* Interrupt Message Number */
-#define PCIE_IR_SR_INT_MSG_NUM_S             9
-#define PCIE_IR_SR_AER_INT_MSG_NUM           0xF8000000  /* Advanced Error Interrupt Message Number */
-#define PCIE_IR_SR_AER_INT_MSG_NUM_S         27
+#define PCIE_IR_SR		0x20
+
+#define PCIE_IR_SR_PME_CAUSE_MSI		0x00000002
+#define PCIE_IR_SR_HP_PME_WAKE_GEN		0x00000004
+#define PCIE_IR_SR_HP_MSI			0x00000008
+#define PCIE_IR_SR_AHB_LU_ERR			0x00000030
+#define PCIE_IR_SR_AHB_LU_ERR_S			4
+#define PCIE_IR_SR_INT_MSG_NUM			0x00003E00
+#define PCIE_IR_SR_INT_MSG_NUM_S		9
+#define PCIE_IR_SR_AER_INT_MSG_NUM		0xF8000000
+#define PCIE_IR_SR_AER_INT_MSG_NUM_S		27
 
 /* Message Control Register */
-#define PCIE_MSG_CR(X)                      (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x30)
-#define PCIE_MSG_CR_GEN_PME_TURN_OFF_MSG     0x00000001  /* Generate PME Turn Off Message */
-#define PCIE_MSG_CR_GEN_UNLOCK_MSG           0x00000002  /* Generate Unlock Message */
+#define PCIE_MSG_CR		0x30
 
-#define PCIE_VDM_DR(X)                      (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x34)
+#define PCIE_MSG_CR_GEN_PME_TURN_OFF_MSG	0x00000001
+#define PCIE_MSG_CR_GEN_UNLOCK_MSG		0x00000002
+
+#define PCIE_VDM_DR		0x34
 
 /* Vendor-Defined Message Requester ID Register */
-#define PCIE_VDM_RID(X)                     (PCIE_APP_PORT_TO_BASE (X) + 0x38)
-#define PCIE_VDM_RID_VENROR_MSG_REQ_ID       0x0000FFFF
-#define PCIE_VDM_RID_VDMRID_S                0
+#define PCIE_VDM_RID		0x38
+
+#define PCIE_VDM_RID_VENROR_MSG_REQ_ID		0x0000FFFF
+#define PCIE_VDM_RID_VDMRID_S			0
 
 /* ASPM Control Register */
-#define PCIE_ASPM_CR(X)                     (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x40)
-#define PCIE_ASPM_CR_HOT_RST                 0x00000001  /* Hot Reset Request to the downstream device */
-#define PCIE_ASPM_CR_REQ_EXIT_L1             0x00000002  /* Request to Exit L1 */
-#define PCIE_ASPM_CR_REQ_ENTER_L1            0x00000004  /* Request to Enter L1 */
+#define PCIE_ASPM_CR		0x40
+
+#define PCIE_ASPM_CR_HOT_RST			0x00000001
+#define PCIE_ASPM_CR_REQ_EXIT_L1		0x00000002
+#define PCIE_ASPM_CR_REQ_ENTER_L1		0x00000004
 
 /* Vendor Message DW0 Register */
-#define PCIE_VM_MSG_DW0(X)                  (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x50)
-#define PCIE_VM_MSG_DW0_TYPE                 0x0000001F  /* Message type */
-#define PCIE_VM_MSG_DW0_TYPE_S               0
-#define PCIE_VM_MSG_DW0_FORMAT               0x00000060  /* Format */
-#define PCIE_VM_MSG_DW0_FORMAT_S             5
-#define PCIE_VM_MSG_DW0_TC                   0x00007000  /* Traffic Class */
-#define PCIE_VM_MSG_DW0_TC_S                 12
-#define PCIE_VM_MSG_DW0_ATTR                 0x000C0000  /* Atrributes */
-#define PCIE_VM_MSG_DW0_ATTR_S               18
-#define PCIE_VM_MSG_DW0_EP_TLP               0x00100000  /* Poisoned TLP */
-#define PCIE_VM_MSG_DW0_TD                   0x00200000  /* TLP Digest */
-#define PCIE_VM_MSG_DW0_LEN                  0xFFC00000  /* Length */
-#define PCIE_VM_MSG_DW0_LEN_S                22
+#define PCIE_VM_MSG_DW0		0x50
+
+#define PCIE_VM_MSG_DW0_TYPE		0x0000001F /* Message type */
+#define PCIE_VM_MSG_DW0_TYPE_S		0
+#define PCIE_VM_MSG_DW0_FORMAT		0x00000060 /* Format */
+#define PCIE_VM_MSG_DW0_FORMAT_S	5
+#define PCIE_VM_MSG_DW0_TC		0x00007000 /* Traffic Class */
+#define PCIE_VM_MSG_DW0_TC_S		12
+#define PCIE_VM_MSG_DW0_ATTR		0x000C0000 /* Atrributes */
+#define PCIE_VM_MSG_DW0_ATTR_S		18
+#define PCIE_VM_MSG_DW0_EP_TLP		0x00100000 /* Poisoned TLP */
+#define PCIE_VM_MSG_DW0_TD		0x00200000 /* TLP Digest */
+#define PCIE_VM_MSG_DW0_LEN		0xFFC00000 /* Length */
+#define PCIE_VM_MSG_DW0_LEN_S		22
 
 /* Format Definition */
 enum {
-    PCIE_VM_MSG_FORMAT_00 = 0,  /* 3DW Hdr, no data*/
-    PCIE_VM_MSG_FORMAT_01,      /* 4DW Hdr, no data */
-    PCIE_VM_MSG_FORMAT_10,      /* 3DW Hdr, with data */
-    PCIE_VM_MSG_FORMAT_11,      /* 4DW Hdr, with data */
+	PCIE_VM_MSG_FORMAT_00 = 0, /* 3DW Hdr, no data */
+	PCIE_VM_MSG_FORMAT_01, /* 4DW Hdr, no data */
+	PCIE_VM_MSG_FORMAT_10, /* 3DW Hdr, with data */
+	PCIE_VM_MSG_FORMAT_11, /* 4DW Hdr, with data */
 };
 
 /* Traffic Class Definition */
 enum {
-    PCIE_VM_MSG_TC0 = 0,
-    PCIE_VM_MSG_TC1,
-    PCIE_VM_MSG_TC2,
-    PCIE_VM_MSG_TC3,
-    PCIE_VM_MSG_TC4,
-    PCIE_VM_MSG_TC5,
-    PCIE_VM_MSG_TC6,
-    PCIE_VM_MSG_TC7,
+	PCIE_VM_MSG_TC0 = 0,
+	PCIE_VM_MSG_TC1,
+	PCIE_VM_MSG_TC2,
+	PCIE_VM_MSG_TC3,
+	PCIE_VM_MSG_TC4,
+	PCIE_VM_MSG_TC5,
+	PCIE_VM_MSG_TC6,
+	PCIE_VM_MSG_TC7,
 };
 
 /* Attributes Definition */
 enum {
-    PCIE_VM_MSG_ATTR_00 = 0,   /* RO and No Snoop cleared */
-    PCIE_VM_MSG_ATTR_01,       /* RO cleared , No Snoop set */
-    PCIE_VM_MSG_ATTR_10,       /* RO set, No Snoop cleared*/
-    PCIE_VM_MSG_ATTR_11,       /* RO and No Snoop set */
+	PCIE_VM_MSG_ATTR_00 = 0, /* RO and No Snoop cleared */
+	PCIE_VM_MSG_ATTR_01, /* RO cleared , No Snoop set */
+	PCIE_VM_MSG_ATTR_10, /* RO set, No Snoop cleared */
+	PCIE_VM_MSG_ATTR_11, /* RO and No Snoop set */
 };
 
 /* Payload Size Definition */
-#define PCIE_VM_MSG_LEN_MIN  0
-#define PCIE_VM_MSG_LEN_MAX  1024
+#define PCIE_VM_MSG_LEN_MIN		0
+#define PCIE_VM_MSG_LEN_MAX		1024
 
 /* Vendor Message DW1 Register */
-#define PCIE_VM_MSG_DW1(X)                 (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x54)
-#define PCIE_VM_MSG_DW1_FUNC_NUM            0x00000070  /* Function Number */
-#define PCIE_VM_MSG_DW1_FUNC_NUM_S          8
-#define PCIE_VM_MSG_DW1_CODE                0x00FF0000  /* Message Code */
-#define PCIE_VM_MSG_DW1_CODE_S              16
-#define PCIE_VM_MSG_DW1_TAG                 0xFF000000  /* Tag */
-#define PCIE_VM_MSG_DW1_TAG_S               24
+#define PCIE_VM_MSG_DW1		0x54
 
-#define PCIE_VM_MSG_DW2(X)                  (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x58)
-#define PCIE_VM_MSG_DW3(X)                  (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x5C)
+#define PCIE_VM_MSG_DW1_FUNC_NUM	0x00000070 /* Function Number */
+#define PCIE_VM_MSG_DW1_FUNC_NUM_S	8
+#define PCIE_VM_MSG_DW1_CODE		0x00FF0000 /* Message Code */
+#define PCIE_VM_MSG_DW1_CODE_S		16
+#define PCIE_VM_MSG_DW1_TAG		0xFF000000 /* Tag */
+#define PCIE_VM_MSG_DW1_TAG_S		24
+
+#define PCIE_VM_MSG_DW2		0x58
+
+#define PCIE_VM_MSG_DW3		0x5C
 
 /* Vendor Message Request Register */
-#define PCIE_VM_MSG_REQR(X)                 (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x60)
-#define PCIE_VM_MSG_REQR_REQ                 0x00000001  /* Vendor Message Request */
+#define PCIE_VM_MSG_REQR	0x60
 
+#define PCIE_VM_MSG_REQR_REQ		0x00000001
 
 /* AHB Slave Side Band Control Register */
-#define PCIE_AHB_SSB(X)                     (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x70)
-#define PCIE_AHB_SSB_REQ_BCM                0x00000001 /* Slave Reques BCM filed */
-#define PCIE_AHB_SSB_REQ_EP                 0x00000002 /* Slave Reques EP filed */
-#define PCIE_AHB_SSB_REQ_TD                 0x00000004 /* Slave Reques TD filed */
-#define PCIE_AHB_SSB_REQ_ATTR               0x00000018 /* Slave Reques Attribute number */
-#define PCIE_AHB_SSB_REQ_ATTR_S             3
-#define PCIE_AHB_SSB_REQ_TC                 0x000000E0 /* Slave Request TC Field */
-#define PCIE_AHB_SSB_REQ_TC_S               5
+#define PCIE_AHB_SSB		0x70
+
+#define PCIE_AHB_SSB_REQ_BCM		0x00000001
+#define PCIE_AHB_SSB_REQ_EP		0x00000002
+#define PCIE_AHB_SSB_REQ_TD		0x00000004
+#define PCIE_AHB_SSB_REQ_ATTR		0x00000018
+#define PCIE_AHB_SSB_REQ_ATTR_S		3
+#define PCIE_AHB_SSB_REQ_TC		0x000000E0
+#define PCIE_AHB_SSB_REQ_TC_S		5
 
 /* AHB Master SideBand Ctrl Register */
-#define PCIE_AHB_MSB(X)                     (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x74)
-#define PCIE_AHB_MSB_RESP_ATTR               0x00000003 /* Master Response Attribute number */
-#define PCIE_AHB_MSB_RESP_ATTR_S             0
-#define PCIE_AHB_MSB_RESP_BAD_EOT            0x00000004 /* Master Response Badeot filed */
-#define PCIE_AHB_MSB_RESP_BCM                0x00000008 /* Master Response BCM filed */
-#define PCIE_AHB_MSB_RESP_EP                 0x00000010 /* Master Response EP filed */
-#define PCIE_AHB_MSB_RESP_TD                 0x00000020 /* Master Response TD filed */
-#define PCIE_AHB_MSB_RESP_FUN_NUM            0x000003C0 /* Master Response Function number */
-#define PCIE_AHB_MSB_RESP_FUN_NUM_S          6
+#define PCIE_AHB_MSB			0x74
 
-/* AHB Control Register, fixed bus enumeration exception */
-#define PCIE_AHB_CTRL(X)                     (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x78)
-#define PCIE_AHB_CTRL_BUS_ERROR_SUPPRESS     0x00000001 
+#define PCIE_AHB_MSB_RESP_ATTR		0x00000003
+#define PCIE_AHB_MSB_RESP_ATTR_S	0
+#define PCIE_AHB_MSB_RESP_BAD_EOT	0x00000004
+#define PCIE_AHB_MSB_RESP_BCM		0x00000008
+#define PCIE_AHB_MSB_RESP_EP		0x00000010
+#define PCIE_AHB_MSB_RESP_TD		0x00000020
+#define PCIE_AHB_MSB_RESP_FUN_NUM	0x000003C0
+#define PCIE_AHB_MSB_RESP_FUN_NUM_S	6
+
+/* AHB Control Register, fixed bus enumeration exception
+ * It happens to the same as PCIE_CLK_CTRL
+ */
+#define PCIE_AHB_CTRL			0x78
+
+#define PCIE_AHB_CTRL_BUS_ERROR_SUPPRESS	0x00000001
+
+/* PCIe 2.0 */
+#define PCIE_DBG_EI			0x80
+#define PCIE_DBG_INFO_L			0x84
+#define PCIE_DBG_INFO_H			0x88
 
 /* Interrupt Enalbe Register */
-#define PCIE_IRNEN(X)                        (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0xF4)
-#define PCIE_IRNCR(X)                        (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0xF8)
-#define PCIE_IRNICR(X)                       (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0xFC)
+#define PCIE_IRNEN			0xF4
+
+#define PCIE_IRNCR			0xF8
+
+#define PCIE_IRNICR			0xFC
 
 /* PCIe interrupt enable/control/capture register definition */
-#define PCIE_IRN_AER_REPORT                 0x00000001  /* AER Interrupt */
-#define PCIE_IRN_AER_MSIX                   0x00000002  /* Advanced Error MSI-X Interrupt */
-#define PCIE_IRN_PME                        0x00000004  /* PME Interrupt */
-#define PCIE_IRN_HOTPLUG                    0x00000008  /* Hotplug Interrupt */
-#define PCIE_IRN_RX_VDM_MSG                 0x00000010  /* Vendor-Defined Message Interrupt */
-#define PCIE_IRN_RX_CORRECTABLE_ERR_MSG     0x00000020  /* Correctable Error Message Interrupt */
-#define PCIE_IRN_RX_NON_FATAL_ERR_MSG       0x00000040  /* Non-fatal Error Message */
-#define PCIE_IRN_RX_FATAL_ERR_MSG           0x00000080  /* Fatal Error Message */
-#define PCIE_IRN_RX_PME_MSG                 0x00000100  /* PME Message Interrupt */
-#define PCIE_IRN_RX_PME_TURNOFF_ACK         0x00000200  /* PME Turnoff Ack Message Interrupt */
-#define PCIE_IRN_AHB_BR_FATAL_ERR           0x00000400  /* AHB Fatal Error Interrupt */
-#define PCIE_IRN_LINK_AUTO_BW_STATUS        0x00000800  /* Link Auto Bandwidth Status Interrupt */
-#define PCIE_IRN_BW_MGT                     0x00001000  /* Bandwidth Managment Interrupt */
-#define PCIE_IRN_INTA                       0x00002000  /* INTA */
-#define PCIE_IRN_INTB                       0x00004000  /* INTB */
-#define PCIE_IRN_INTC                       0x00008000  /* INTC */
-#define PCIE_IRN_INTD                       0x00010000  /* INTD */
-#define PCIE_IRN_WAKEUP                     0x00020000  /* Wake up Interrupt */
+#define PCIE_IRN_AER_REPORT		0x00000001
+#define PCIE_IRN_AER_MSIX		0x00000002
+#define PCIE_IRN_PME			0x00000004
+#define PCIE_IRN_HOTPLUG		0x00000008
+#define PCIE_IRN_RX_VDM_MSG		0x00000010
+#define PCIE_IRN_RX_CORRECTABLE_ERR_MSG	0x00000020
+#define PCIE_IRN_RX_NON_FATAL_ERR_MSG	0x00000040
+#define PCIE_IRN_RX_FATAL_ERR_MSG	0x00000080
+#define PCIE_IRN_RX_PME_MSG		0x00000100
+#define PCIE_IRN_RX_PME_TURNOFF_ACK	0x00000200
+#define PCIE_IRN_AHB_BR_FATAL_ERR	0x00000400
+#define PCIE_IRN_LINK_AUTO_BW_STATUS	0x00000800
+#define PCIE_IRN_BW_MGT			0x00001000
+#define PCIE_IRN_INTA			0x00002000 /* INTA */
+#define PCIE_IRN_INTB			0x00004000 /* INTB */
+#define PCIE_IRN_INTC			0x00008000 /* INTC */
+#define PCIE_IRN_INTD			0x00010000 /* INTD */
+#define PCIE_IRN_WAKEUP			0x00020000 /* Wake up Interrupt */
+#define PCIE_IRN_LINK_BW_MGT		0x00080000 /* PCIe 2.0 BW status */
+#define PCIE_IRN_LINK_AUTO_BW		0x00100000 /* PCIe 2.0 BW request */
+#define PCIE_INTX_OFFSET		12
 
-#define PCIE_RC_CORE_COMBINED_INT    (PCIE_IRN_AER_REPORT |  PCIE_IRN_AER_MSIX | PCIE_IRN_PME | \
-                                      PCIE_IRN_HOTPLUG | PCIE_IRN_RX_VDM_MSG | PCIE_IRN_RX_CORRECTABLE_ERR_MSG |\
-                                      PCIE_IRN_RX_NON_FATAL_ERR_MSG | PCIE_IRN_RX_FATAL_ERR_MSG | \
-                                      PCIE_IRN_RX_PME_MSG | PCIE_IRN_RX_PME_TURNOFF_ACK | PCIE_IRN_AHB_BR_FATAL_ERR | \
-                                      PCIE_IRN_LINK_AUTO_BW_STATUS | PCIE_IRN_BW_MGT)
+#define PCIE_RC_CORE_COMBINED_INT  (PCIE_IRN_AER_REPORT | PCIE_IRN_AER_MSIX \
+		| PCIE_IRN_PME | PCIE_IRN_HOTPLUG | PCIE_IRN_RX_VDM_MSG \
+		| PCIE_IRN_RX_CORRECTABLE_ERR_MSG \
+		| PCIE_IRN_RX_NON_FATAL_ERR_MSG | PCIE_IRN_RX_FATAL_ERR_MSG \
+		| PCIE_IRN_RX_PME_MSG | PCIE_IRN_RX_PME_TURNOFF_ACK \
+		| PCIE_IRN_AHB_BR_FATAL_ERR | PCIE_IRN_LINK_AUTO_BW_STATUS\
+		| PCIE_IRN_BW_MGT)
+
 /* PCIe RC Configuration Register */
-#define PCIE_VDID(X)                (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x00)
+#define PCIE_VDID		0x00
 
 /* Bit definition from pci_reg.h */
-#define PCIE_PCICMDSTS(X)           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x04)
-#define PCIE_CCRID(X)               (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x08)
-#define PCIE_CLSLTHTBR(X)           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x0C) /* EP only */
-/* BAR0, BAR1,Only necessary if the bridges implements a device-specific register set or memory buffer */
-#define PCIE_BAR0(X)                (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x10) /* Not used*/
-#define PCIE_BAR1(X)                (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x14) /* Not used */
+#define PCIE_PCICMDSTS		0x04
+#define PCIE_CCRID		0x08
 
-#define PCIE_BNR(X)                 (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x18) /* Mandatory */
+#define PCIE_CLSLTHTBR		0x0C
+
+/* BAR0, BAR1,Only necessary if the bridges implements a device-specific
+   register set or memory buffer */
+#define PCIE_BAR0		0x10
+
+#define PCIE_BAR1		0x14
+
+#define PCIE_BNR		0x18
 /* Bus Number Register bits */
-#define PCIE_BNR_PRIMARY_BUS_NUM             0x000000FF
-#define PCIE_BNR_PRIMARY_BUS_NUM_S           0
-#define PCIE_PNR_SECONDARY_BUS_NUM           0x0000FF00
-#define PCIE_PNR_SECONDARY_BUS_NUM_S         8
-#define PCIE_PNR_SUB_BUS_NUM                 0x00FF0000
-#define PCIE_PNR_SUB_BUS_NUM_S               16
+#define PCIE_BNR_PRIMARY_BUS_NUM	0x000000FF
+#define PCIE_BNR_PRIMARY_BUS_NUM_S	0
+#define PCIE_PNR_SECONDARY_BUS_NUM	0x0000FF00
+#define PCIE_PNR_SECONDARY_BUS_NUM_S	8
+#define PCIE_PNR_SUB_BUS_NUM	0x00FF0000
+#define PCIE_PNR_SUB_BUS_NUM_S	16
 
 /* IO Base/Limit Register bits */
-#define PCIE_IOBLSECS(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x1C)  /* RC only */
-#define PCIE_IOBLSECS_32BIT_IO_ADDR             0x00000001
-#define PCIE_IOBLSECS_IO_BASE_ADDR              0x000000F0
-#define PCIE_IOBLSECS_IO_BASE_ADDR_S            4
-#define PCIE_IOBLSECS_32BIT_IOLIMT              0x00000100
-#define PCIE_IOBLSECS_IO_LIMIT_ADDR             0x0000F000
-#define PCIE_IOBLSECS_IO_LIMIT_ADDR_S           12
+#define PCIE_IOBLSECS			0x1C
+
+#define PCIE_IOBLSECS_32BIT_IO_ADDR	0x00000001
+#define PCIE_IOBLSECS_IO_BASE_ADDR	0x000000F0
+#define PCIE_IOBLSECS_IO_BASE_ADDR_S	4
+#define PCIE_IOBLSECS_32BIT_IOLIMT	0x00000100
+#define PCIE_IOBLSECS_IO_LIMIT_ADDR	0x0000F000
+#define PCIE_IOBLSECS_IO_LIMIT_ADDR_S	12
 
 /* Non-prefetchable Memory Base/Limit Register bit */
-#define PCIE_MBML(X)                           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x20)  /* RC only */
-#define PCIE_MBML_MEM_BASE_ADDR                 0x0000FFF0
-#define PCIE_MBML_MEM_BASE_ADDR_S               4
-#define PCIE_MBML_MEM_LIMIT_ADDR                0xFFF00000
-#define PCIE_MBML_MEM_LIMIT_ADDR_S              20
+#define PCIE_MBML			0x20
+
+#define PCIE_MBML_MEM_BASE_ADDR		0x0000FFF0
+#define PCIE_MBML_MEM_BASE_ADDR_S	4
+#define PCIE_MBML_MEM_LIMIT_ADDR	0xFFF00000
+#define PCIE_MBML_MEM_LIMIT_ADDR_S	20
 
 /* Prefetchable Memory Base/Limit Register bit */
-#define PCIE_PMBL(X)                           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x24)  /* RC only */
-#define PCIE_PMBL_64BIT_ADDR                    0x00000001
-#define PCIE_PMBL_UPPER_12BIT                   0x0000FFF0
-#define PCIE_PMBL_UPPER_12BIT_S                 4
-#define PCIE_PMBL_E64MA                         0x00010000
-#define PCIE_PMBL_END_ADDR                      0xFFF00000
-#define PCIE_PMBL_END_ADDR_S                    20
-#define PCIE_PMBU32(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x28)  /* RC only */
-#define PCIE_PMLU32(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x2C)  /* RC only */
+#define PCIE_PMBL			0x24
+#define PCIE_PMBL_64BIT_ADDR		0x00000001
+#define PCIE_PMBL_UPPER_12BIT		0x0000FFF0
+#define PCIE_PMBL_UPPER_12BIT_S		4
+#define PCIE_PMBL_E64MA			0x00010000
+#define PCIE_PMBL_END_ADDR		0xFFF00000
+#define PCIE_PMBL_END_ADDR_S		20
+
+#define PCIE_PMBU32			0x28
+
+#define PCIE_PMLU32			0x2C
 
 /* I/O Base/Limit Upper 16 bits register */
-#define PCIE_IO_BANDL(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x30)  /* RC only */
-#define PCIE_IO_BANDL_UPPER_16BIT_IO_BASE        0x0000FFFF
-#define PCIE_IO_BANDL_UPPER_16BIT_IO_BASE_S      0
-#define PCIE_IO_BANDL_UPPER_16BIT_IO_LIMIT       0xFFFF0000
-#define PCIE_IO_BANDL_UPPER_16BIT_IO_LIMIT_S     16
+#define PCIE_IO_BANDL			0x30
 
-#define PCIE_CPR(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x34)
-#define PCIE_EBBAR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x38)
+#define PCIE_IO_BANDL_UPPER_16BIT_IO_BASE	0x0000FFFF
+#define PCIE_IO_BANDL_UPPER_16BIT_IO_BASE_S	0
+#define PCIE_IO_BANDL_UPPER_16BIT_IO_LIMIT	0xFFFF0000
+#define PCIE_IO_BANDL_UPPER_16BIT_IO_LIMIT_S	16
+
+#define PCIE_CPR			0x34
+
+#define PCIE_EBBAR			0x38
 
 /* Interrupt and Secondary Bridge Control Register */
-#define PCIE_INTRBCTRL(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x3C)
+#define PCIE_INTRBCTRL			0x3C
 
-#define PCIE_INTRBCTRL_INT_LINE                 0x000000FF
-#define PCIE_INTRBCTRL_INT_LINE_S               0
-#define PCIE_INTRBCTRL_INT_PIN                  0x0000FF00
-#define PCIE_INTRBCTRL_INT_PIN_S                8
-#define PCIE_INTRBCTRL_PARITY_ERR_RESP_ENABLE   0x00010000    /* #PERR */
-#define PCIE_INTRBCTRL_SERR_ENABLE              0x00020000    /* #SERR */
-#define PCIE_INTRBCTRL_ISA_ENABLE               0x00040000    /* ISA enable, IO 64KB only */
-#define PCIE_INTRBCTRL_VGA_ENABLE               0x00080000    /* VGA enable */
-#define PCIE_INTRBCTRL_VGA_16BIT_DECODE         0x00100000    /* VGA 16bit decode */
-#define PCIE_INTRBCTRL_RST_SECONDARY_BUS        0x00400000    /* Secondary bus rest, hot rest, 1ms */
+#define PCIE_INTRBCTRL_INT_LINE			0x000000FF
+#define PCIE_INTRBCTRL_INT_LINE_S		0
+#define PCIE_INTRBCTRL_INT_PIN			0x0000FF00
+#define PCIE_INTRBCTRL_INT_PIN_S		8
+#define PCIE_INTRBCTRL_PARITY_ERR_RESP_ENABLE	0x00010000
+#define PCIE_INTRBCTRL_SERR_ENABLE		0x00020000
+#define PCIE_INTRBCTRL_ISA_ENABLE		0x00040000
+#define PCIE_INTRBCTRL_VGA_ENABLE		0x00080000
+#define PCIE_INTRBCTRL_VGA_16BIT_DECODE		0x00100000
+#define PCIE_INTRBCTRL_RST_SECONDARY_BUS	0x00400000
 /* Others are read only */
 enum {
-    PCIE_INTRBCTRL_INT_NON = 0,
-    PCIE_INTRBCTRL_INTA,
-    PCIE_INTRBCTRL_INTB,
-    PCIE_INTRBCTRL_INTC,
-    PCIE_INTRBCTRL_INTD,
+	PCIE_INTRBCTRL_INT_NON = 0,
+	PCIE_INTRBCTRL_INTA,
+	PCIE_INTRBCTRL_INTB,
+	PCIE_INTRBCTRL_INTC,
+	PCIE_INTRBCTRL_INTD,
 };
 
-#define PCIE_PM_CAPR(X)                  (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x40)
+#define PCIE_PM_CAPR			0x40
 
 /* Power Management Control and Status Register */
-#define PCIE_PM_CSR(X)                   (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x44)
+#define PCIE_PM_CSR			0x44
 
-#define PCIE_PM_CSR_POWER_STATE           0x00000003   /* Power State */
-#define PCIE_PM_CSR_POWER_STATE_S         0
-#define PCIE_PM_CSR_SW_RST                0x00000008   /* Soft Reset Enabled */
-#define PCIE_PM_CSR_PME_ENABLE            0x00000100   /* PME Enable */
-#define PCIE_PM_CSR_PME_STATUS            0x00008000   /* PME status */
+#define PCIE_PM_CSR_POWER_STATE		0x00000003 /* Power State */
+#define PCIE_PM_CSR_POWER_STATE_S	0
+#define PCIE_PM_CSR_SW_RST		0x00000008 /* Soft Reset Enabled */
+#define PCIE_PM_CSR_PME_ENABLE		0x00000100 /* PME Enable */
+#define PCIE_PM_CSR_PME_STATUS		0x00008000 /* PME status */
 
 /* MSI Capability Register for EP */
-#define PCIE_MCAPR(X)                    (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x50)
+#define PCIE_MCAPR			0x50
 
-#define PCIE_MCAPR_MSI_CAP_ID             0x000000FF  /* MSI Capability ID */
-#define PCIE_MCAPR_MSI_CAP_ID_S           0
-#define PCIE_MCAPR_MSI_NEXT_CAP_PTR       0x0000FF00  /* Next Capability Pointer */
-#define PCIE_MCAPR_MSI_NEXT_CAP_PTR_S     8
-#define PCIE_MCAPR_MSI_ENABLE             0x00010000  /* MSI Enable */
-#define PCIE_MCAPR_MULTI_MSG_CAP          0x000E0000  /* Multiple Message Capable */
-#define PCIE_MCAPR_MULTI_MSG_CAP_S        17
-#define PCIE_MCAPR_MULTI_MSG_ENABLE       0x00700000  /* Multiple Message Enable */
-#define PCIE_MCAPR_MULTI_MSG_ENABLE_S     20
-#define PCIE_MCAPR_ADDR64_CAP             0X00800000  /* 64-bit Address Capable */
+#define PCIE_MCAPR_MSI_CAP_ID		0x000000FF
+#define PCIE_MCAPR_MSI_CAP_ID_S		0
+#define PCIE_MCAPR_MSI_NEXT_CAP_PTR	0x0000FF00
+#define PCIE_MCAPR_MSI_NEXT_CAP_PTR_S	8
+#define PCIE_MCAPR_MSI_ENABLE		0x00010000
+#define PCIE_MCAPR_MULTI_MSG_CAP	0x000E0000
+#define PCIE_MCAPR_MULTI_MSG_CAP_S	17
+#define PCIE_MCAPR_MULTI_MSG_ENABLE	0x00700000
+#define PCIE_MCAPR_MULTI_MSG_ENABLE_S	20
+#define PCIE_MCAPR_ADDR64_CAP		0X00800000
 
 /* MSI Message Address Register */
-#define PCIE_MA(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x54)
+#define PCIE_MA				0x54
 
-#define PCIE_MA_ADDR_MASK                 0xFFFFFFFC  /* Message Address */
+#define PCIE_MA_ADDR_MASK		0xFFFFFFFC /* Message Address */
 
 /* MSI Message Upper Address Register */
-#define PCIE_MUA(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x58)
+#define PCIE_MUA			0x58
 
 /* MSI Message Data Register */
-#define PCIE_MD(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x5C)
+#define PCIE_MD				0x5C
 
-#define PCIE_MD_DATA                      0x0000FFFF  /* Message Data */
-#define PCIE_MD_DATA_S                    0
+#define PCIE_MD_DATA			0x0000FFFF /* Message Data */
+#define PCIE_MD_DATA_S			0
 
 /* PCI Express Capability Register */
-#define PCIE_XCAP(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x70)
+#define PCIE_XCAP			0x70
 
-#define PCIE_XCAP_ID                      0x000000FF  /* PCI Express Capability ID */
-#define PCIE_XCAP_ID_S                    0
-#define PCIE_XCAP_NEXT_CAP                0x0000FF00  /* Next Capability Pointer */
-#define PCIE_XCAP_NEXT_CAP_S              8
-#define PCIE_XCAP_VER                     0x000F0000  /* PCI Express Capability Version */
-#define PCIE_XCAP_VER_S                   16
-#define PCIE_XCAP_DEV_PORT_TYPE           0x00F00000  /* Device Port Type */
-#define PCIE_XCAP_DEV_PORT_TYPE_S         20
-#define PCIE_XCAP_SLOT_IMPLEMENTED        0x01000000  /* Slot Implemented */
-#define PCIE_XCAP_MSG_INT_NUM             0x3E000000  /* Interrupt Message Number */
-#define PCIE_XCAP_MSG_INT_NUM_S           25
+#define PCIE_XCAP_ID			0x000000FF
+#define PCIE_XCAP_ID_S			0
+#define PCIE_XCAP_NEXT_CAP		0x0000FF00
+#define PCIE_XCAP_NEXT_CAP_S		8
+#define PCIE_XCAP_VER			0x000F0000
+#define PCIE_XCAP_VER_S			16
+#define PCIE_XCAP_DEV_PORT_TYPE		0x00F00000
+#define PCIE_XCAP_DEV_PORT_TYPE_S	20
+#define PCIE_XCAP_SLOT_IMPLEMENTED	0x01000000
+#define PCIE_XCAP_MSG_INT_NUM		0x3E000000
+#define PCIE_XCAP_MSG_INT_NUM_S		25
 
 /* Device Capability Register */
-#define PCIE_DCAP(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x74)
+#define PCIE_DCAP			0x74
 
-#define PCIE_DCAP_MAX_PAYLOAD_SIZE        0x00000007   /* Max Payload size */
-#define PCIE_DCAP_MAX_PAYLOAD_SIZE_S      0
-#define PCIE_DCAP_PHANTOM_FUNC            0x00000018   /* Phanton Function, not supported */
-#define PCIE_DCAP_PHANTOM_FUNC_S          3
-#define PCIE_DCAP_EXT_TAG                 0x00000020   /* Extended Tag Field */
-#define PCIE_DCAP_EP_L0S_LATENCY          0x000001C0   /* EP L0s latency only */
-#define PCIE_DCAP_EP_L0S_LATENCY_S        6
-#define PCIE_DCAP_EP_L1_LATENCY           0x00000E00   /* EP L1 latency only */
-#define PCIE_DCAP_EP_L1_LATENCY_S         9
-#define PCIE_DCAP_ROLE_BASE_ERR_REPORT    0x00008000   /* Role Based ERR */
+#define PCIE_DCAP_MAX_PAYLOAD_SIZE	0x00000007
+#define PCIE_DCAP_MAX_PAYLOAD_SIZE_S	0
+#define PCIE_DCAP_PHANTOM_FUNC		0x00000018
+#define PCIE_DCAP_PHANTOM_FUNC_S	3
+#define PCIE_DCAP_EXT_TAG		0x00000020
+#define PCIE_DCAP_EP_L0S_LATENCY	0x000001C0
+#define PCIE_DCAP_EP_L0S_LATENCY_S	6
+#define PCIE_DCAP_EP_L1_LATENCY		0x00000E00
+#define PCIE_DCAP_EP_L1_LATENCY_S	9
+#define PCIE_DCAP_ROLE_BASE_ERR_REPORT	0x00008000
 
 /* Maximum payload size supported */
 enum {
-    PCIE_MAX_PAYLOAD_128 = 0,
-    PCIE_MAX_PAYLOAD_256,
-    PCIE_MAX_PAYLOAD_512,
-    PCIE_MAX_PAYLOAD_1024,
-    PCIE_MAX_PAYLOAD_2048,
-    PCIE_MAX_PAYLOAD_4096,
+	PCIE_MAX_PAYLOAD_128 = 0,
+	PCIE_MAX_PAYLOAD_256,
+	PCIE_MAX_PAYLOAD_512,
+	PCIE_MAX_PAYLOAD_1024,
+	PCIE_MAX_PAYLOAD_2048,
+	PCIE_MAX_PAYLOAD_4096,
 };
 
 /* Device Control and Status Register */
-#define PCIE_DCTLSTS(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x78)
+#define PCIE_DCTLSTS				0x78
 
-#define PCIE_DCTLSTS_CORRECTABLE_ERR_EN        0x00000001   /* COR-ERR */
-#define PCIE_DCTLSTS_NONFATAL_ERR_EN           0x00000002   /* Non-fatal ERR */
-#define PCIE_DCTLSTS_FATAL_ERR_EN              0x00000004   /* Fatal ERR */
-#define PCIE_DCTLSYS_UR_REQ_EN                 0x00000008   /* UR ERR */
-#define PCIE_DCTLSTS_RELAXED_ORDERING_EN       0x00000010   /* Enable relaxing ordering */
-#define PCIE_DCTLSTS_MAX_PAYLOAD_SIZE          0x000000E0   /* Max payload mask */
-#define PCIE_DCTLSTS_MAX_PAYLOAD_SIZE_S        5
-#define PCIE_DCTLSTS_EXT_TAG_EN                0x00000100   /* Extended tag field */
-#define PCIE_DCTLSTS_PHANTOM_FUNC_EN           0x00000200   /* Phantom Function Enable */
-#define PCIE_DCTLSTS_AUX_PM_EN                 0x00000400   /* AUX Power PM Enable */
-#define PCIE_DCTLSTS_NO_SNOOP_EN               0x00000800   /* Enable no snoop, except root port*/
-#define PCIE_DCTLSTS_MAX_READ_SIZE             0x00007000   /* Max Read Request size*/
-#define PCIE_DCTLSTS_MAX_READ_SIZE_S           12
-#define PCIE_DCTLSTS_CORRECTABLE_ERR           0x00010000   /* COR-ERR Detected */
-#define PCIE_DCTLSTS_NONFATAL_ERR              0x00020000   /* Non-Fatal ERR Detected */
-#define PCIE_DCTLSTS_FATAL_ER                  0x00040000   /* Fatal ERR Detected */
-#define PCIE_DCTLSTS_UNSUPPORTED_REQ           0x00080000   /* UR Detected */
-#define PCIE_DCTLSTS_AUX_POWER                 0x00100000   /* Aux Power Detected */
-#define PCIE_DCTLSTS_TRANSACT_PENDING          0x00200000   /* Transaction pending */
+#define PCIE_DCTLSTS_CORRECTABLE_ERR_EN		0x00000001
+#define PCIE_DCTLSTS_NONFATAL_ERR_EN		0x00000002
+#define PCIE_DCTLSTS_FATAL_ERR_EN		0x00000004
+#define PCIE_DCTLSYS_UR_REQ_EN			0x00000008
+#define PCIE_DCTLSTS_RELAXED_ORDERING_EN	0x00000010
+#define PCIE_DCTLSTS_MAX_PAYLOAD_SIZE		0x000000E0
+#define PCIE_DCTLSTS_MAX_PAYLOAD_SIZE_S		5
+#define PCIE_DCTLSTS_EXT_TAG_EN			0x00000100
+#define PCIE_DCTLSTS_PHANTOM_FUNC_EN		0x00000200
+#define PCIE_DCTLSTS_AUX_PM_EN			0x00000400
+#define PCIE_DCTLSTS_NO_SNOOP_EN		0x00000800
+#define PCIE_DCTLSTS_MAX_READ_SIZE		0x00007000
+#define PCIE_DCTLSTS_MAX_READ_SIZE_S		12
+#define PCIE_DCTLSTS_CORRECTABLE_ERR		0x00010000
+#define PCIE_DCTLSTS_NONFATAL_ERR		0x00020000
+#define PCIE_DCTLSTS_FATAL_ER			0x00040000
+#define PCIE_DCTLSTS_UNSUPPORTED_REQ		0x00080000
+#define PCIE_DCTLSTS_AUX_POWER			0x00100000
+#define PCIE_DCTLSTS_TRANSACT_PENDING	0x00200000
 
-#define PCIE_DCTLSTS_ERR_EN      (PCIE_DCTLSTS_CORRECTABLE_ERR_EN | \
-                                  PCIE_DCTLSTS_NONFATAL_ERR_EN | PCIE_DCTLSTS_FATAL_ERR_EN | \
-                                  PCIE_DCTLSYS_UR_REQ_EN)
+#define PCIE_DCTLSTS_ERR_EN	(PCIE_DCTLSTS_CORRECTABLE_ERR_EN | \
+		PCIE_DCTLSTS_NONFATAL_ERR_EN | PCIE_DCTLSTS_FATAL_ERR_EN \
+		| PCIE_DCTLSYS_UR_REQ_EN)
 
 /* Link Capability Register */
-#define PCIE_LCAP(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x7C)
-#define PCIE_LCAP_MAX_LINK_SPEED               0x0000000F  /* Max link speed, 0x1 by default */
-#define PCIE_LCAP_MAX_LINK_SPEED_S             0
-#define PCIE_LCAP_MAX_LENGTH_WIDTH             0x000003F0  /* Maxium Length Width */
-#define PCIE_LCAP_MAX_LENGTH_WIDTH_S           4
-#define PCIE_LCAP_ASPM_LEVEL                   0x00000C00  /* Active State Link PM Support */
-#define PCIE_LCAP_ASPM_LEVEL_S                 10
-#define PCIE_LCAP_L0S_EIXT_LATENCY             0x00007000  /* L0s Exit Latency */
-#define PCIE_LCAP_L0S_EIXT_LATENCY_S           12
-#define PCIE_LCAP_L1_EXIT_LATENCY              0x00038000  /* L1 Exit Latency */
-#define PCIE_LCAP_L1_EXIT_LATENCY_S            15
-#define PCIE_LCAP_CLK_PM                       0x00040000  /* Clock Power Management */
-#define PCIE_LCAP_SDER                         0x00080000  /* Surprise Down Error Reporting */
-#define PCIE_LCAP_DLL_ACTIVE_REPROT            0x00100000  /* Data Link Layer Active Reporting Capable */
-#define PCIE_LCAP_PORT_NUM                     0xFF0000000  /* Port number */
-#define PCIE_LCAP_PORT_NUM_S                   24
+#define PCIE_LCAP				0x7C
+#define PCIE_LCAP_MAX_LINK_SPEED		0x0000000F
+#define PCIE_LCAP_MAX_LINK_SPEED_S		0
+#define PCIE_LCAP_MAX_LENGTH_WIDTH		0x000003F0
+#define PCIE_LCAP_MAX_LENGTH_WIDTH_S		4
+#define PCIE_LCAP_ASPM_LEVEL			0x00000C00
+#define PCIE_LCAP_ASPM_LEVEL_S			10
+#define PCIE_LCAP_L0S_EIXT_LATENCY		0x00007000
+#define PCIE_LCAP_L0S_EIXT_LATENCY_S		12
+#define PCIE_LCAP_L1_EXIT_LATENCY		0x00038000
+#define PCIE_LCAP_L1_EXIT_LATENCY_S		15
+#define PCIE_LCAP_CLK_PM			0x00040000
+#define PCIE_LCAP_SDER				0x00080000
+#define PCIE_LCAP_DLL_ACTIVE_REPROT		0x00100000
+#define PCIE_LCAP_PORT_NUM			0xFF000000
+#define PCIE_LCAP_PORT_NUM_S			24
 
 /* Maximum Length width definition */
-#define PCIE_MAX_LENGTH_WIDTH_RES  0x00
-#define PCIE_MAX_LENGTH_WIDTH_X1   0x01  /* Default */
-#define PCIE_MAX_LENGTH_WIDTH_X2   0x02
-#define PCIE_MAX_LENGTH_WIDTH_X4   0x04
-#define PCIE_MAX_LENGTH_WIDTH_X8   0x08
-#define PCIE_MAX_LENGTH_WIDTH_X12  0x0C
-#define PCIE_MAX_LENGTH_WIDTH_X16  0x10
-#define PCIE_MAX_LENGTH_WIDTH_X32  0x20
+#define PCIE_MAX_LENGTH_WIDTH_RES		0x00
+#define PCIE_MAX_LENGTH_WIDTH_X1		0x01 /* Default */
+#define PCIE_MAX_LENGTH_WIDTH_X2		0x02
+#define PCIE_MAX_LENGTH_WIDTH_X4		0x04
+#define PCIE_MAX_LENGTH_WIDTH_X8		0x08
+#define PCIE_MAX_LENGTH_WIDTH_X12		0x0C
+#define PCIE_MAX_LENGTH_WIDTH_X16		0x10
+#define PCIE_MAX_LENGTH_WIDTH_X32		0x20
 
 /* Active State Link PM definition */
 enum {
-    PCIE_ASPM_RES0                = 0,
-    PCIE_ASPM_L0S_ENTRY_SUPPORT,        /* L0s */
-    PCIE_ASPM_RES1,
-    PCIE_ASPM_L0S_L1_ENTRY_SUPPORT,     /* L0s and L1, default */
+	PCIE_ASPM_RES0 = 0,
+	PCIE_ASPM_L0S_ENTRY_SUPPORT, /* L0s */
+	PCIE_ASPM_RES1,
+	PCIE_ASPM_L0S_L1_ENTRY_SUPPORT, /* L0s and L1, default */
 };
 
 /* L0s Exit Latency definition */
 enum {
-    PCIE_L0S_EIXT_LATENCY_L64NS    = 0, /* < 64 ns */
-    PCIE_L0S_EIXT_LATENCY_B64A128,      /* > 64 ns < 128 ns */
-    PCIE_L0S_EIXT_LATENCY_B128A256,     /* > 128 ns < 256 ns */
-    PCIE_L0S_EIXT_LATENCY_B256A512,     /* > 256 ns < 512 ns */
-    PCIE_L0S_EIXT_LATENCY_B512TO1U,     /* > 512 ns < 1 us */
-    PCIE_L0S_EIXT_LATENCY_B1A2U,        /* > 1 us < 2 us */
-    PCIE_L0S_EIXT_LATENCY_B2A4U,        /* > 2 us < 4 us */
-    PCIE_L0S_EIXT_LATENCY_M4US,         /* > 4 us  */
+	PCIE_L0S_EIXT_LATENCY_L64NS = 0, /* < 64 ns */
+	PCIE_L0S_EIXT_LATENCY_B64A128,  /* > 64 ns < 128 ns */
+	PCIE_L0S_EIXT_LATENCY_B128A256, /* > 128 ns < 256 ns */
+	PCIE_L0S_EIXT_LATENCY_B256A512, /* > 256 ns < 512 ns */
+	PCIE_L0S_EIXT_LATENCY_B512TO1U, /* > 512 ns < 1 us */
+	PCIE_L0S_EIXT_LATENCY_B1A2U, /* > 1 us < 2 us */
+	PCIE_L0S_EIXT_LATENCY_B2A4U, /* > 2 us < 4 us */
+	PCIE_L0S_EIXT_LATENCY_M4US, /* > 4 us  */
 };
 
 /* L1 Exit Latency definition */
 enum {
-    PCIE_L1_EXIT_LATENCY_L1US  = 0,  /* < 1 us */
-    PCIE_L1_EXIT_LATENCY_B1A2,       /* > 1 us < 2 us */
-    PCIE_L1_EXIT_LATENCY_B2A4,       /* > 2 us < 4 us */
-    PCIE_L1_EXIT_LATENCY_B4A8,       /* > 4 us < 8 us */
-    PCIE_L1_EXIT_LATENCY_B8A16,      /* > 8 us < 16 us */
-    PCIE_L1_EXIT_LATENCY_B16A32,     /* > 16 us < 32 us */
-    PCIE_L1_EXIT_LATENCY_B32A64,     /* > 32 us < 64 us */
-    PCIE_L1_EXIT_LATENCY_M64US,      /* > 64 us */
+	PCIE_L1_EXIT_LATENCY_L1US = 0, /* < 1 us */
+	PCIE_L1_EXIT_LATENCY_B1A2,     /* > 1 us < 2 us */
+	PCIE_L1_EXIT_LATENCY_B2A4,     /* > 2 us < 4 us */
+	PCIE_L1_EXIT_LATENCY_B4A8,     /* > 4 us < 8 us */
+	PCIE_L1_EXIT_LATENCY_B8A16,    /* > 8 us < 16 us */
+	PCIE_L1_EXIT_LATENCY_B16A32,   /* > 16 us < 32 us */
+	PCIE_L1_EXIT_LATENCY_B32A64,   /* > 32 us < 64 us */
+	PCIE_L1_EXIT_LATENCY_M64US,    /* > 64 us */
 };
 
 /* Link Control and Status Register */
-#define PCIE_LCTLSTS(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x80)
-#define PCIE_LCTLSTS_ASPM_ENABLE            0x00000003  /* Active State Link PM Control */
-#define PCIE_LCTLSTS_ASPM_ENABLE_S          0
-#define PCIE_LCTLSTS_RCB128                 0x00000008  /* Read Completion Boundary 128*/
-#define PCIE_LCTLSTS_LINK_DISABLE           0x00000010  /* Link Disable */
-#define PCIE_LCTLSTS_RETRIAN_LINK           0x00000020  /* Retrain Link */
-#define PCIE_LCTLSTS_COM_CLK_CFG            0x00000040  /* Common Clock Configuration */
-#define PCIE_LCTLSTS_EXT_SYNC               0x00000080  /* Extended Synch */
-#define PCIE_LCTLSTS_CLK_PM_EN              0x00000100  /* Enable Clock Powerm Management */
-#define PCIE_LCTLSTS_LINK_SPEED             0x000F0000  /* Link Speed */
-#define PCIE_LCTLSTS_LINK_SPEED_S           16
-#define PCIE_LCTLSTS_NEGOTIATED_LINK_WIDTH  0x03F00000  /* Negotiated Link Width */
-#define PCIE_LCTLSTS_NEGOTIATED_LINK_WIDTH_S 20
-#define PCIE_LCTLSTS_RETRAIN_PENDING        0x08000000  /* Link training is ongoing */
-#define PCIE_LCTLSTS_SLOT_CLK_CFG           0x10000000  /* Slot Clock Configuration */
-#define PCIE_LCTLSTS_DLL_ACTIVE             0x20000000  /* Data Link Layer Active */
+#define PCIE_LCTLSTS				0x80
+#define PCIE_LCTLSTS_ASPM_ENABLE		0x00000003
+#define PCIE_LCTLSTS_ASPM_ENABLE_S		0
+#define PCIE_LCTLSTS_RCB128			0x00000008
+#define PCIE_LCTLSTS_LINK_DISABLE		0x00000010
+#define PCIE_LCTLSTS_RETRIAN_LINK		0x00000020
+#define PCIE_LCTLSTS_COM_CLK_CFG		0x00000040
+#define PCIE_LCTLSTS_EXT_SYNC			0x00000080
+#define PCIE_LCTLSTS_CLK_PM_EN			0x00000100
+/* PCIe 2.0 */
+#define PCIE_LCTLSTS_HW_AW_DIS			0x00000200
+#define PCIE_LCTLSTS_LINK_ABM_IRQ_EN		0x00000400
+#define PCIE_LCTLSTS_LINK_AB_IRQ_EN		0x00000800
+
+#define PCIE_LCTLSTS_LINK_SPEED			0x000F0000
+#define PCIE_LCTLSTS_LINK_SPEED_S		16
+#define PCIE_LCTLSTS_NEGOTIATED_LINK_WIDTH	0x03F00000
+#define PCIE_LCTLSTS_NEGOTIATED_LINK_WIDTH_S	20
+#define PCIE_LCTLSTS_RETRAIN_PENDING		0x08000000
+#define PCIE_LCTLSTS_SLOT_CLK_CFG		0x10000000
+#define PCIE_LCTLSTS_DLL_ACTIVE			0x20000000
+/* PCIe 2.0 */
+#define PCIE_LCTLSTS_LINK_BMS			0x40000000
+#define PCIE_LCTLSTS_LINK_ABS			0x80000000
 
 /* Slot Capabilities Register */
-#define PCIE_SLCAP(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x84)
+#define PCIE_SLCAP				0x84
 
 /* Slot Capabilities */
-#define PCIE_SLCTLSTS(X)                    (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x88)
+#define PCIE_SLCTLSTS				0x88
 
 /* Root Control and Capability Register */
-#define PCIE_RCTLCAP(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x8C)
-#define PCIE_RCTLCAP_SERR_ON_CORRECTABLE_ERR  0x00000001   /* #SERR on COR-ERR */
-#define PCIE_RCTLCAP_SERR_ON_NONFATAL_ERR     0x00000002   /* #SERR on Non-Fatal ERR */
-#define PCIE_RCTLCAP_SERR_ON_FATAL_ERR        0x00000004   /* #SERR on Fatal ERR */
-#define PCIE_RCTLCAP_PME_INT_EN               0x00000008   /* PME Interrupt Enable */
-#define PCIE_RCTLCAP_SERR_ENABLE    (PCIE_RCTLCAP_SERR_ON_CORRECTABLE_ERR | \
-                                     PCIE_RCTLCAP_SERR_ON_NONFATAL_ERR | PCIE_RCTLCAP_SERR_ON_FATAL_ERR)
+#define PCIE_RCTLCAP				0x8C
+
+#define PCIE_RCTLCAP_SERR_ON_CORRECTABLE_ERR	0x00000001
+#define PCIE_RCTLCAP_SERR_ON_NONFATAL_ERR	0x00000002
+#define PCIE_RCTLCAP_SERR_ON_FATAL_ERR		0x00000004
+#define PCIE_RCTLCAP_PME_INT_EN			0x00000008
+#define PCIE_RCTLCAP_SERR_ENABLE	(PCIE_RCTLCAP_SERR_ON_CORRECTABLE_ERR \
+		| PCIE_RCTLCAP_SERR_ON_NONFATAL_ERR \
+		| PCIE_RCTLCAP_SERR_ON_FATAL_ERR)
 /* Root Status Register */
-#define PCIE_RSTS(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x90)
-#define PCIE_RSTS_PME_REQ_ID                   0x0000FFFF   /* PME Request ID */
-#define PCIE_RSTS_PME_REQ_ID_S                 0
-#define PCIE_RSTS_PME_STATUS                   0x00010000   /* PME Status */
-#define PCIE_RSTS_PME_PENDING                  0x00020000   /* PME Pending */
+#define PCIE_RSTS			0x90
+
+#define PCIE_RSTS_PME_REQ_ID		0x0000FFFF
+#define PCIE_RSTS_PME_REQ_ID_S		0
+#define PCIE_RSTS_PME_STATUS		0x00010000
+#define PCIE_RSTS_PME_PENDING		0x00020000
+
+/* PCIe 2.0 specific stuff */
+#define PCIE_DCAP2			0x94
+
+#define PCIE_DCTLSTS2			0x98
+
+#define PCIE_CPL_TIMEOUT_RANGE		0x0000000F
+#define PCIE_CPL_TIMEOUT_RANGE_S	0
+#define PCIE_CPL_TIMEOUT_DIS		0x00000010 /* Root Port optional */
+
+/*
+ * Range A: 50us to 10ms
+ * Range B: 10ms to 250ms
+ * Range C: 250ms to 4s
+ * Range D: 4s to 64 s
+*/
+#define PCIE_CPL_TIMEOUT_RANGE_S	0
+#define PCIE_CPL_TIMEOUT_RANGE_A	1
+#define PCIE_CPL_TIMEOUT_RANGE_B	2
+#define PCIE_CPL_TIMEOUT_RANGE_AB	3
+#define PCIE_CPL_TIMEOUT_RANGE_BC	6
+#define PCIE_CPL_TIMEOUT_RANGE_ABC	7
+#define PCIE_CPL_TIMEOUT_RANGE_BCD	14
+#define PCIE_CPL_TIMEOUT_RANGE_ABCD	15
+
+#define PCIE_LCAP2			0x9C
+#define PCIE_LCTLSTS2			0xA0
+
+#define PCIE_LCTLSTS2_TGT_LINK_SPEED	0x0000000F
+#define PCIE_LCTLSTS2_TGT_LINK_SPEED_S	0
+#define PCIE_LCTLSTS2_TGT_LINK_SPEED_25GT	1
+#define PCIE_LCTLSTS2_TGT_LINK_SPEED_5GT	2
+#define PCIE_LCTLSTS2_ENTER_COMPLIACE	0x00000010
+#define PCIE_LCTLSTS2_HW_AUTO_DIS	0x00000020
+#define PCIE_LCTLSTS2_DE_EMPHASIS_35DB	0x00000040 /* 0 -6DB */
+#define PCIE_LCTLSTS2_TX_MARGIN		0x00000380
+#define PCIE_LCTLSTS2_TX_MARGIN_S	7
+
+#define PCIE_LCTLSTS2_MF_COMP_ENTER	0x00000400 /* LTSSM substate */
+
+#define PCIE_LCTLSTS2_COMPLIANCE_SOS	0x00000800
+#define PCIE_LCTLSTS2_COMP_DE_EM35DB	0x00001000
+
+#define PCIE_LCTLSTS2_CUR_DE_EM35DB	0x00010000
+
+
 
 /* PCI Express Enhanced Capability Header */
-#define PCIE_ENHANCED_CAP(X)                (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x100)
-#define PCIE_ENHANCED_CAP_ID                 0x0000FFFF  /* PCI Express Extended Capability ID */
-#define PCIE_ENHANCED_CAP_ID_S               0
-#define PCIE_ENHANCED_CAP_VER                0x000F0000  /* Capability Version */
-#define PCIE_ENHANCED_CAP_VER_S              16
-#define PCIE_ENHANCED_CAP_NEXT_OFFSET        0xFFF00000  /* Next Capability Offset */
-#define PCIE_ENHANCED_CAP_NEXT_OFFSET_S      20
+#define PCIE_ENHANCED_CAP		0x100
+
+#define PCIE_ENHANCED_CAP_ID			0x0000FFFF
+#define PCIE_ENHANCED_CAP_ID_S			0
+#define PCIE_ENHANCED_CAP_VER			0x000F0000
+#define PCIE_ENHANCED_CAP_VER_S			16
+#define PCIE_ENHANCED_CAP_NEXT_OFFSET		0xFFF00000
+#define PCIE_ENHANCED_CAP_NEXT_OFFSET_S		20
 
 /* Uncorrectable Error Status Register */
-#define PCIE_UES_R(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x104)
-#define PCIE_DATA_LINK_PROTOCOL_ERR          0x00000010  /* Data Link Protocol Error Status */
-#define PCIE_SURPRISE_DOWN_ERROR             0x00000020  /* Surprise Down Error Status */
-#define PCIE_POISONED_TLP                    0x00001000  /* Poisoned TLP Status */
-#define PCIE_FC_PROTOCOL_ERR                 0x00002000  /* Flow Control Protocol Error Status */
-#define PCIE_COMPLETION_TIMEOUT              0x00004000  /* Completion Timeout Status */
-#define PCIE_COMPLETOR_ABORT                 0x00008000  /* Completer Abort Error */
-#define PCIE_UNEXPECTED_COMPLETION           0x00010000  /* Unexpected Completion Status */
-#define PCIE_RECEIVER_OVERFLOW               0x00020000  /* Receive Overflow Status */
-#define PCIE_MALFORNED_TLP                   0x00040000  /* Malformed TLP Stauts */
-#define PCIE_ECRC_ERR                        0x00080000  /* ECRC Error Stauts */
-#define PCIE_UR_REQ                          0x00100000  /* Unsupported Request Error Status */
-#define PCIE_ALL_UNCORRECTABLE_ERR    (PCIE_DATA_LINK_PROTOCOL_ERR | PCIE_SURPRISE_DOWN_ERROR | \
-                         PCIE_POISONED_TLP | PCIE_FC_PROTOCOL_ERR | PCIE_COMPLETION_TIMEOUT |   \
-                         PCIE_COMPLETOR_ABORT | PCIE_UNEXPECTED_COMPLETION | PCIE_RECEIVER_OVERFLOW |\
-                         PCIE_MALFORNED_TLP | PCIE_ECRC_ERR | PCIE_UR_REQ)
+#define PCIE_UES_R			0x104
+
+#define PCIE_DATA_LINK_PROTOCOL_ERR		0x00000010
+#define PCIE_SURPRISE_DOWN_ERROR		0x00000020
+#define PCIE_POISONED_TLP			0x00001000
+#define PCIE_FC_PROTOCOL_ERR			0x00002000
+#define PCIE_COMPLETION_TIMEOUT			0x00004000
+#define PCIE_COMPLETOR_ABORT			0x00008000
+#define PCIE_UNEXPECTED_COMPLETION		0x00010000
+#define PCIE_RECEIVER_OVERFLOW			0x00020000
+#define PCIE_MALFORNED_TLP			0x00040000
+#define PCIE_ECRC_ERR				0x00080000
+#define PCIE_UR_REQ				0x00100000
+#define PCIE_ALL_UNCORRECTABLE_ERR	(PCIE_DATA_LINK_PROTOCOL_ERR |\
+		PCIE_SURPRISE_DOWN_ERROR | PCIE_POISONED_TLP |\
+		PCIE_FC_PROTOCOL_ERR | PCIE_COMPLETION_TIMEOUT | \
+		PCIE_COMPLETOR_ABORT | PCIE_UNEXPECTED_COMPLETION |\
+		PCIE_RECEIVER_OVERFLOW | PCIE_MALFORNED_TLP | \
+		PCIE_ECRC_ERR | PCIE_UR_REQ)
 
 /* Uncorrectable Error Mask Register, Mask means no report */
-#define PCIE_UEMR(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x108)
+#define PCIE_UEMR			0x108
 
 /* Uncorrectable Error Severity Register */
-#define PCIE_UESR(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x10C)
+#define PCIE_UESR			0x10C
 
 /* Correctable Error Status Register */
-#define PCIE_CESR(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x110)
-#define PCIE_RX_ERR                          0x00000001  /* Receive Error Status */
-#define PCIE_BAD_TLP                         0x00000040  /* Bad TLP Status */
-#define PCIE_BAD_DLLP                        0x00000080  /* Bad DLLP Status */
-#define PCIE_REPLAY_NUM_ROLLOVER             0x00000100  /* Replay Number Rollover Status */
-#define PCIE_REPLAY_TIMER_TIMEOUT_ERR        0x00001000  /* Reply Timer Timeout Status */
-#define PCIE_ADVISORY_NONFTAL_ERR            0x00002000  /* Advisory Non-Fatal Error Status */
-#define PCIE_CORRECTABLE_ERR        (PCIE_RX_ERR | PCIE_BAD_TLP | PCIE_BAD_DLLP | PCIE_REPLAY_NUM_ROLLOVER |\
-                                     PCIE_REPLAY_TIMER_TIMEOUT_ERR | PCIE_ADVISORY_NONFTAL_ERR)
+#define PCIE_CESR			0x110
+#define PCIE_RX_ERR			0x00000001
+#define PCIE_BAD_TLP			0x00000040
+#define PCIE_BAD_DLLP			0x00000080
+#define PCIE_REPLAY_NUM_ROLLOVER	0x00000100
+#define PCIE_REPLAY_TIMER_TIMEOUT_ERR	0x00001000
+#define PCIE_ADVISORY_NONFTAL_ERR	0x00002000
+#define PCIE_CORRECTABLE_ERR	(PCIE_RX_ERR | PCIE_BAD_TLP | PCIE_BAD_DLLP \
+		| PCIE_REPLAY_NUM_ROLLOVER | PCIE_REPLAY_TIMER_TIMEOUT_ERR\
+		| PCIE_ADVISORY_NONFTAL_ERR)
 
 /* Correctable Error Mask Register */
-#define PCIE_CEMR(X)                        (volatile u32*)(PCIE_RC_CFG_BASE + 0x114)
+#define PCIE_CEMR			0x114
 
 /* Advanced Error Capabilities and Control Register */
-#define PCIE_AECCR(X)                       (volatile u32*)(PCIE_RC_CFG_BASE + 0x118)
-#define PCIE_AECCR_FIRST_ERR_PTR            0x0000001F  /* First Error Pointer */
-#define PCIE_AECCR_FIRST_ERR_PTR_S          0
-#define PCIE_AECCR_ECRC_GEN_CAP             0x00000020  /* ECRC Generation Capable */
-#define PCIE_AECCR_ECRC_GEN_EN              0x00000040  /* ECRC Generation Enable */
-#define PCIE_AECCR_ECRC_CHECK_CAP           0x00000080  /* ECRC Check Capable */
-#define PCIE_AECCR_ECRC_CHECK_EN            0x00000100  /* ECRC Check Enable */
+#define PCIE_AECCR			0x118
+
+#define PCIE_AECCR_FIRST_ERR_PTR		0x0000001F
+#define PCIE_AECCR_FIRST_ERR_PTR_S		0
+#define PCIE_AECCR_ECRC_GEN_CAP			0x00000020
+#define PCIE_AECCR_ECRC_GEN_EN			0x00000040
+#define PCIE_AECCR_ECRC_CHECK_CAP		0x00000080
+#define PCIE_AECCR_ECRC_CHECK_EN		0x00000100
 
 /* Header Log Register 1 */
-#define PCIE_HLR1(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x11C)
+#define PCIE_HLR1			0x11C
 
 /* Header Log Register 2 */
-#define PCIE_HLR2(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x120)
+#define PCIE_HLR2			0x120
 
 /* Header Log Register 3 */
-#define PCIE_HLR3(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x124)
+#define PCIE_HLR3			0x124
 
 /* Header Log Register 4 */
-#define PCIE_HLR4(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x128)
+#define PCIE_HLR4			0x128
 
 /* Root Error Command Register */
-#define PCIE_RECR(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x12C)
-#define PCIE_RECR_CORRECTABLE_ERR_REPORT_EN  0x00000001 /* COR-ERR */
-#define PCIE_RECR_NONFATAL_ERR_REPORT_EN     0x00000002 /* Non-Fatal ERR */
-#define PCIE_RECR_FATAL_ERR_REPORT_EN        0x00000004 /* Fatal ERR */
-#define PCIE_RECR_ERR_REPORT_EN  (PCIE_RECR_CORRECTABLE_ERR_REPORT_EN | \
-                PCIE_RECR_NONFATAL_ERR_REPORT_EN | PCIE_RECR_FATAL_ERR_REPORT_EN)
+#define PCIE_RECR			0x12C
+
+#define PCIE_RECR_CORRECTABLE_ERR_REPORT_EN	0x00000001 /* COR-ERR */
+#define PCIE_RECR_NONFATAL_ERR_REPORT_EN	0x00000002 /* Non-Fatal ERR */
+#define PCIE_RECR_FATAL_ERR_REPORT_EN		0x00000004 /* Fatal ERR */
+#define PCIE_RECR_ERR_REPORT_EN	(PCIE_RECR_CORRECTABLE_ERR_REPORT_EN\
+		| PCIE_RECR_NONFATAL_ERR_REPORT_EN |\
+		PCIE_RECR_FATAL_ERR_REPORT_EN)
 
 /* Root Error Status Register */
-#define PCIE_RESR(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x130)
-#define PCIE_RESR_CORRECTABLE_ERR                0x00000001   /* COR-ERR Receveid */
-#define PCIE_RESR_MULTI_CORRECTABLE_ERR          0x00000002   /* Multiple COR-ERR Received */
-#define PCIE_RESR_FATAL_NOFATAL_ERR              0x00000004   /* ERR Fatal/Non-Fatal Received */
-#define PCIE_RESR_MULTI_FATAL_NOFATAL_ERR        0x00000008   /* Multiple ERR Fatal/Non-Fatal Received */
-#define PCIE_RESR_FIRST_UNCORRECTABLE_FATAL_ERR  0x00000010   /* First UN-COR Fatal */
-#define PCIR_RESR_NON_FATAL_ERR                  0x00000020   /* Non-Fatal Error Message Received */
-#define PCIE_RESR_FATAL_ERR                      0x00000040   /* Fatal Message Received */
-#define PCIE_RESR_AER_INT_MSG_NUM                0xF8000000   /* Advanced Error Interrupt Message Number */
-#define PCIE_RESR_AER_INT_MSG_NUM_S              27
+#define PCIE_RESR			0x130
+
+#define PCIE_RESR_CORRECTABLE_ERR		0x00000001
+#define PCIE_RESR_MULTI_CORRECTABLE_ERR		0x00000002
+#define PCIE_RESR_FATAL_NOFATAL_ERR		0x00000004
+#define PCIE_RESR_MULTI_FATAL_NOFATAL_ERR	0x00000008
+#define PCIE_RESR_FIRST_UNCORRECTABLE_FATAL_ERR	0x00000010
+#define PCIR_RESR_NON_FATAL_ERR			0x00000020
+#define PCIE_RESR_FATAL_ERR			0x00000040
+#define PCIE_RESR_AER_INT_MSG_NUM		0xF8000000
+#define PCIE_RESR_AER_INT_MSG_NUM_S		27
 
 /* Error Source Indentification Register */
-#define PCIE_ESIR(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x134)
-#define PCIE_ESIR_CORRECTABLE_ERR_SRC_ID         0x0000FFFF
-#define PCIE_ESIR_CORRECTABLE_ERR_SRC_ID_S       0
-#define PCIE_ESIR_FATAL_NON_FATAL_SRC_ID         0xFFFF0000
-#define PCIE_ESIR_FATAL_NON_FATAL_SRC_ID_S       16
+#define PCIE_ESIR			0x134
+
+#define PCIE_ESIR_CORRECTABLE_ERR_SRC_ID	0x0000FFFF
+#define PCIE_ESIR_CORRECTABLE_ERR_SRC_ID_S	0
+#define PCIE_ESIR_FATAL_NON_FATAL_SRC_ID	0xFFFF0000
+#define PCIE_ESIR_FATAL_NON_FATAL_SRC_ID_S	16
 
 /* VC Enhanced Capability Header */
-#define PCIE_VC_ECH(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x140)
+#define PCIE_VC_ECH			0x140
 
 /* Port VC Capability Register */
-#define PCIE_PVC1(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x144)
-#define PCIE_PVC1_EXT_VC_CNT                    0x00000007  /* Extended VC Count */
-#define PCIE_PVC1_EXT_VC_CNT_S                  0
-#define PCIE_PVC1_LOW_PRI_EXT_VC_CNT            0x00000070  /* Low Priority Extended VC Count */
-#define PCIE_PVC1_LOW_PRI_EXT_VC_CNT_S          4
-#define PCIE_PVC1_REF_CLK                       0x00000300  /* Reference Clock */
-#define PCIE_PVC1_REF_CLK_S                     8
-#define PCIE_PVC1_PORT_ARB_TAB_ENTRY_SIZE       0x00000C00  /* Port Arbitration Table Entry Size */
-#define PCIE_PVC1_PORT_ARB_TAB_ENTRY_SIZE_S     10
+#define PCIE_PVC1			0x144
+
+#define PCIE_PVC1_EXT_VC_CNT			0x00000007
+#define PCIE_PVC1_EXT_VC_CNT_S			0
+#define PCIE_PVC1_LOW_PRI_EXT_VC_CNT		0x00000070
+#define PCIE_PVC1_LOW_PRI_EXT_VC_CNT_S		4
+#define PCIE_PVC1_REF_CLK			0x00000300
+#define PCIE_PVC1_REF_CLK_S			8
+#define PCIE_PVC1_PORT_ARB_TAB_ENTRY_SIZE	0x00000C00
+#define PCIE_PVC1_PORT_ARB_TAB_ENTRY_SIZE_S	10
 
 /* Extended Virtual Channel Count Defintion */
-#define PCIE_EXT_VC_CNT_MIN   0
-#define PCIE_EXT_VC_CNT_MAX   7
+#define PCIE_EXT_VC_CNT_MIN		0
+#define PCIE_EXT_VC_CNT_MAX		7
 
 /* Port Arbitration Table Entry Size Definition */
 enum {
-    PCIE_PORT_ARB_TAB_ENTRY_SIZE_S1BIT = 0,
-    PCIE_PORT_ARB_TAB_ENTRY_SIZE_S2BIT,
-    PCIE_PORT_ARB_TAB_ENTRY_SIZE_S4BIT,
-    PCIE_PORT_ARB_TAB_ENTRY_SIZE_S8BIT,
+	PCIE_PORT_ARB_TAB_ENTRY_SIZE_S1BIT = 0,
+	PCIE_PORT_ARB_TAB_ENTRY_SIZE_S2BIT,
+	PCIE_PORT_ARB_TAB_ENTRY_SIZE_S4BIT,
+	PCIE_PORT_ARB_TAB_ENTRY_SIZE_S8BIT,
 };
 
 /* Port VC Capability Register 2 */
-#define PCIE_PVC2(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x148)
-#define PCIE_PVC2_VC_ARB_16P_FIXED_WRR      0x00000001  /* HW Fixed arbitration, 16 phase WRR */
-#define PCIE_PVC2_VC_ARB_32P_WRR            0x00000002  /* 32 phase WRR */
-#define PCIE_PVC2_VC_ARB_64P_WRR            0x00000004  /* 64 phase WRR */
-#define PCIE_PVC2_VC_ARB_128P_WRR           0x00000008  /* 128 phase WRR */
-#define PCIE_PVC2_VC_ARB_WRR                0x0000000F
-#define PCIE_PVC2_VC_ARB_TAB_OFFSET         0xFF000000  /* VC arbitration table offset, not support */
-#define PCIE_PVC2_VC_ARB_TAB_OFFSET_S       24
+#define PCIE_PVC2			0x148
 
-/* Port VC Control and Status Register */     
-#define PCIE_PVCCRSR(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x14C)
-#define PCIE_PVCCRSR_LOAD_VC_ARB_TAB         0x00000001  /* Load VC Arbitration Table */
-#define PCIE_PVCCRSR_VC_ARB_SEL              0x0000000E  /* VC Arbitration Select */
-#define PCIE_PVCCRSR_VC_ARB_SEL_S            1
-#define PCIE_PVCCRSR_VC_ARB_TAB_STATUS       0x00010000  /* Arbitration Status */
+#define PCIE_PVC2_VC_ARB_16P_FIXED_WRR		0x00000001
+#define PCIE_PVC2_VC_ARB_32P_WRR		0x00000002
+#define PCIE_PVC2_VC_ARB_64P_WRR		0x00000004
+#define PCIE_PVC2_VC_ARB_128P_WRR		0x00000008
+#define PCIE_PVC2_VC_ARB_WRR			0x0000000F
+#define PCIE_PVC2_VC_ARB_TAB_OFFSET		0xFF000000
+#define PCIE_PVC2_VC_ARB_TAB_OFFSET_S		24
+
+/* Port VC Control and Status Register */
+#define PCIE_PVCCRSR			0x14C
+
+#define PCIE_PVCCRSR_LOAD_VC_ARB_TAB		0x00000001
+#define PCIE_PVCCRSR_VC_ARB_SEL			0x0000000E
+#define PCIE_PVCCRSR_VC_ARB_SEL_S		1
+#define PCIE_PVCCRSR_VC_ARB_TAB_STATUS		0x00010000
 
 /* VC0 Resource Capability Register */
-#define PCIE_VC0_RC(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x150)
-#define PCIE_VC0_RC_PORT_ARB_HW_FIXED        0x00000001  /* HW Fixed arbitration */
-#define PCIE_VC0_RC_PORT_ARB_32P_WRR         0x00000002  /* 32 phase WRR */
-#define PCIE_VC0_RC_PORT_ARB_64P_WRR         0x00000004  /* 64 phase WRR */
-#define PCIE_VC0_RC_PORT_ARB_128P_WRR        0x00000008  /* 128 phase WRR */
-#define PCIE_VC0_RC_PORT_ARB_TM_128P_WRR     0x00000010  /* Time-based 128 phase WRR */
-#define PCIE_VC0_RC_PORT_ARB_TM_256P_WRR     0x00000020  /* Time-based 256 phase WRR */
-#define PCIE_VC0_RC_PORT_ARB          (PCIE_VC0_RC_PORT_ARB_HW_FIXED | PCIE_VC0_RC_PORT_ARB_32P_WRR |\
-                        PCIE_VC0_RC_PORT_ARB_64P_WRR | PCIE_VC0_RC_PORT_ARB_128P_WRR | \
-                        PCIE_VC0_RC_PORT_ARB_TM_128P_WRR | PCIE_VC0_RC_PORT_ARB_TM_256P_WRR)
+#define PCIE_VC0_RC			0x150
 
-#define PCIE_VC0_RC_REJECT_SNOOP             0x00008000  /* Reject Snoop Transactioin */
-#define PCIE_VC0_RC_MAX_TIMESLOTS            0x007F0000  /* Maximum time Slots */
-#define PCIE_VC0_RC_MAX_TIMESLOTS_S          16
-#define PCIE_VC0_RC_PORT_ARB_TAB_OFFSET      0xFF000000  /* Port Arbitration Table Offset */
-#define PCIE_VC0_RC_PORT_ARB_TAB_OFFSET_S    24
+#define PCIE_VC0_RC_PORT_ARB_HW_FIXED		0x00000001
+#define PCIE_VC0_RC_PORT_ARB_32P_WRR		0x00000002
+#define PCIE_VC0_RC_PORT_ARB_64P_WRR		0x00000004
+#define PCIE_VC0_RC_PORT_ARB_128P_WRR		0x00000008
+#define PCIE_VC0_RC_PORT_ARB_TM_128P_WRR	0x00000010
+#define PCIE_VC0_RC_PORT_ARB_TM_256P_WRR	0x00000020
+#define PCIE_VC0_RC_PORT_ARB	(PCIE_VC0_RC_PORT_ARB_HW_FIXED |\
+		PCIE_VC0_RC_PORT_ARB_32P_WRR | PCIE_VC0_RC_PORT_ARB_64P_WRR |\
+		PCIE_VC0_RC_PORT_ARB_128P_WRR |\
+		PCIE_VC0_RC_PORT_ARB_TM_128P_WRR |\
+		PCIE_VC0_RC_PORT_ARB_TM_256P_WRR)
+
+#define PCIE_VC0_RC_REJECT_SNOOP		0x00008000
+#define PCIE_VC0_RC_MAX_TIMESLOTS		0x007F0000
+#define PCIE_VC0_RC_MAX_TIMESLOTS_S		16
+#define PCIE_VC0_RC_PORT_ARB_TAB_OFFSET		0xFF000000
+#define PCIE_VC0_RC_PORT_ARB_TAB_OFFSET_S	24
 
 /* VC0 Resource Control Register */
-#define PCIE_VC0_RC0(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x154)
-#define PCIE_VC0_RC0_TVM0                    0x00000001  /* TC0 and VC0 */
-#define PCIE_VC0_RC0_TVM1                    0x00000002  /* TC1 and VC1 */
-#define PCIE_VC0_RC0_TVM2                    0x00000004  /* TC2 and VC2 */
-#define PCIE_VC0_RC0_TVM3                    0x00000008  /* TC3 and VC3 */
-#define PCIE_VC0_RC0_TVM4                    0x00000010  /* TC4 and VC4 */
-#define PCIE_VC0_RC0_TVM5                    0x00000020  /* TC5 and VC5 */
-#define PCIE_VC0_RC0_TVM6                    0x00000040  /* TC6 and VC6 */
-#define PCIE_VC0_RC0_TVM7                    0x00000080  /* TC7 and VC7 */
-#define PCIE_VC0_RC0_TC_VC                   0x000000FF  /* TC/VC mask */
+#define PCIE_VC0_RC0			0x154
 
-#define PCIE_VC0_RC0_LOAD_PORT_ARB_TAB       0x00010000  /* Load Port Arbitration Table */
-#define PCIE_VC0_RC0_PORT_ARB_SEL            0x000E0000  /* Port Arbitration Select */
-#define PCIE_VC0_RC0_PORT_ARB_SEL_S          17
-#define PCIE_VC0_RC0_VC_ID                   0x07000000  /* VC ID */
-#define PCIE_VC0_RC0_VC_ID_S                 24
-#define PCIE_VC0_RC0_VC_EN                   0x80000000  /* VC Enable */
+#define PCIE_VC0_RC0_TVM0			0x00000001
+#define PCIE_VC0_RC0_TVM1			0x00000002
+#define PCIE_VC0_RC0_TVM2			0x00000004
+#define PCIE_VC0_RC0_TVM3			0x00000008
+#define PCIE_VC0_RC0_TVM4			0x00000010
+#define PCIE_VC0_RC0_TVM5			0x00000020
+#define PCIE_VC0_RC0_TVM6			0x00000040
+#define PCIE_VC0_RC0_TVM7			0x00000080
+#define PCIE_VC0_RC0_TC_VC			0x000000FF
+
+#define PCIE_VC0_RC0_LOAD_PORT_ARB_TAB		0x00010000
+#define PCIE_VC0_RC0_PORT_ARB_SEL		0x000E0000
+#define PCIE_VC0_RC0_PORT_ARB_SEL_S		17
+#define PCIE_VC0_RC0_VC_ID			0x07000000
+#define PCIE_VC0_RC0_VC_ID_S			24
+#define PCIE_VC0_RC0_VC_EN			0x80000000
 
 /* VC0 Resource Status Register */
-#define PCIE_VC0_RSR0(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x158)
-#define PCIE_VC0_RSR0_PORT_ARB_TAB_STATUS    0x00010000  /* Port Arbitration Table Status,not used */
-#define PCIE_VC0_RSR0_VC_NEG_PENDING         0x00020000  /* VC Negotiation Pending */
+#define PCIE_VC0_RSR0			0x158
+
+#define PCIE_VC0_RSR0_PORT_ARB_TAB_STATUS	0x00010000
+#define PCIE_VC0_RSR0_VC_NEG_PENDING		0x00020000
 
 /* Ack Latency Timer and Replay Timer Register */
-#define PCIE_ALTRT(X)                         (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x700)
-#define PCIE_ALTRT_ROUND_TRIP_LATENCY_LIMIT   0x0000FFFF  /* Round Trip Latency Time Limit */
-#define PCIE_ALTRT_ROUND_TRIP_LATENCY_LIMIT_S 0
-#define PCIE_ALTRT_REPLAY_TIME_LIMIT          0xFFFF0000  /* Replay Time Limit */
-#define PCIE_ALTRT_REPLAY_TIME_LIMIT_S        16
+#define PCIE_ALTRT			0x700
+
+#define PCIE_ALTRT_ROUND_TRIP_LATENCY_LIMIT	0x0000FFFF
+#define PCIE_ALTRT_ROUND_TRIP_LATENCY_LIMIT_S	0
+#define PCIE_ALTRT_REPLAY_TIME_LIMIT		0xFFFF0000
+#define PCIE_ALTRT_REPLAY_TIME_LIMIT_S		16
 
 /* Other Message Register */
-#define PCIE_OMR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x704)
+#define PCIE_OMR			0x704
 
 /* Port Force Link Register */
-#define PCIE_PFLR(X)                         (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x708)
-#define PCIE_PFLR_LINK_NUM                   0x000000FF  /* Link Number */
-#define PCIE_PFLR_LINK_NUM_S                 0
-#define PCIE_PFLR_FORCE_LINK                 0x00008000  /* Force link */
-#define PCIE_PFLR_LINK_STATE                 0x003F0000  /* Link State */
-#define PCIE_PFLR_LINK_STATE_S               16
-#define PCIE_PFLR_LOW_POWER_ENTRY_CNT        0xFF000000  /* Low Power Entrance Count, only for EP */
-#define PCIE_PFLR_LOW_POWER_ENTRY_CNT_S      24
+#define PCIE_PFLR			0x708
+
+#define PCIE_PFLR_LINK_NUM			0x000000FF
+#define PCIE_PFLR_LINK_NUM_S			0
+#define PCIE_PFLR_FORCE_LINK			0x00008000
+#define PCIE_PFLR_LINK_STATE			0x003F0000
+#define PCIE_PFLR_LINK_STATE_S			16
+#define PCIE_PFLR_LOW_POWER_ENTRY_CNT		0xFF000000
+#define PCIE_PFLR_LOW_POWER_ENTRY_CNT_S		24
 
 /* Ack Frequency Register */
-#define PCIE_AFR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x70C)
-#define PCIE_AFR_AF                          0x000000FF  /* Ack Frequency */
-#define PCIE_AFR_AF_S                        0
-#define PCIE_AFR_FTS_NUM                     0x0000FF00  /* The number of Fast Training Sequence from L0S to L0 */
-#define PCIE_AFR_FTS_NUM_S                   8
-#define PCIE_AFR_COM_FTS_NUM                 0x00FF0000  /* N_FTS; when common clock is used*/
-#define PCIE_AFR_COM_FTS_NUM_S               16
-#define PCIE_AFR_L0S_ENTRY_LATENCY           0x07000000  /* L0s Entrance Latency */
-#define PCIE_AFR_L0S_ENTRY_LATENCY_S         24
-#define PCIE_AFR_L1_ENTRY_LATENCY            0x38000000  /* L1 Entrance Latency */
-#define PCIE_AFR_L1_ENTRY_LATENCY_S          27
-#define PCIE_AFR_FTS_NUM_DEFAULT             32
-#define PCIE_AFR_L0S_ENTRY_LATENCY_DEFAULT   7
-#define PCIE_AFR_L1_ENTRY_LATENCY_DEFAULT    5
+#define PCIE_AFR			0x70C
+
+#define PCIE_AFR_AF			0x000000FF
+#define PCIE_AFR_AF_S			0
+#define PCIE_AFR_FTS_NUM		0x0000FF00
+#define PCIE_AFR_FTS_NUM_S		8
+#define PCIE_AFR_COM_FTS_NUM		0x00FF0000
+#define PCIE_AFR_COM_FTS_NUM_S		16
+#define PCIE_AFR_L0S_ENTRY_LATENCY	0x07000000
+#define PCIE_AFR_L0S_ENTRY_LATENCY_S	24
+#define PCIE_AFR_L1_ENTRY_LATENCY	0x38000000
+#define PCIE_AFR_L1_ENTRY_LATENCY_S	27
+#define PCIE_AFR_FTS_NUM_DEFAULT	127
+#define PCIE_AFR_L0S_ENTRY_LATENCY_DEFAULT	7
+#define PCIE_AFR_L1_ENTRY_LATENCY_DEFAULT	5
 
 /* Port Link Control Register */
-#define PCIE_PLCR(X)                         (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x710)
-#define PCIE_PLCR_OTHER_MSG_REQ              0x00000001  /* Other Message Request */
-#define PCIE_PLCR_SCRAMBLE_DISABLE           0x00000002  /* Scramble Disable */  
-#define PCIE_PLCR_LOOPBACK_EN                0x00000004  /* Loopback Enable */
-#define PCIE_PLCR_LTSSM_HOT_RST              0x00000008  /* Force LTSSM to the hot reset */
-#define PCIE_PLCR_DLL_LINK_EN                0x00000020  /* Enable Link initialization */
-#define PCIE_PLCR_FAST_LINK_SIM_EN           0x00000080  /* Sets all internal timers to fast mode for simulation purposes */
-#define PCIE_PLCR_LINK_MODE                  0x003F0000  /* Link Mode Enable Mask */
-#define PCIE_PLCR_LINK_MODE_S                16
-#define PCIE_PLCR_CORRUPTED_CRC_EN           0x02000000  /* Enabled Corrupt CRC */
+#define PCIE_PLCR			0x710
+
+#define PCIE_PLCR_OTHER_MSG_REQ		0x00000001
+#define PCIE_PLCR_SCRAMBLE_DISABLE	0x00000002
+#define PCIE_PLCR_LOOPBACK_EN		0x00000004
+#define PCIE_PLCR_LTSSM_HOT_RST		0x00000008
+#define PCIE_PLCR_DLL_LINK_EN		0x00000020
+#define PCIE_PLCR_FAST_LINK_SIM_EN	0x00000080
+#define PCIE_PLCR_LINK_MODE		0x003F0000
+#define PCIE_PLCR_LINK_MODE_S		16
+#define PCIE_PLCR_CORRUPTED_CRC_EN	0x02000000
 
 /* Lane Skew Register */
-#define PCIE_LSR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x714)
-#define PCIE_LSR_LANE_SKEW_NUM               0x00FFFFFF  /* Insert Lane Skew for Transmit, not applicable */
-#define PCIE_LSR_LANE_SKEW_NUM_S             0
-#define PCIE_LSR_FC_DISABLE                  0x01000000  /* Disable of Flow Control */
-#define PCIE_LSR_ACKNAK_DISABLE              0x02000000  /* Disable of Ack/Nak */
-#define PCIE_LSR_LANE_DESKEW_DISABLE         0x80000000  /* Disable of Lane-to-Lane Skew */
+#define PCIE_LSR			0x714
+
+#define PCIE_LSR_LANE_SKEW_NUM		0x00FFFFFF
+#define PCIE_LSR_LANE_SKEW_NUM_S	0
+#define PCIE_LSR_FC_DISABLE		0x01000000
+#define PCIE_LSR_ACKNAK_DISABLE		0x02000000
+#define PCIE_LSR_LANE_DESKEW_DISABLE	0x80000000
 
 /* Symbol Number Register */
-#define PCIE_SNR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x718)
-#define PCIE_SNR_TS                          0x0000000F  /* Number of TS Symbol */
-#define PCIE_SNR_TS_S                        0
-#define PCIE_SNR_SKP                         0x00000700  /* Number of SKP Symbol */
-#define PCIE_SNR_SKP_S                       8
-#define PCIE_SNR_REPLAY_TIMER                0x0007C000  /* Timer Modifier for Replay Timer */
-#define PCIE_SNR_REPLAY_TIMER_S              14
-#define PCIE_SNR_ACKNAK_LATENCY_TIMER        0x00F80000  /* Timer Modifier for Ack/Nak Latency Timer */
-#define PCIE_SNR_ACKNAK_LATENCY_TIMER_S      19
-#define PCIE_SNR_FC_TIMER                    0x1F000000  /* Timer Modifier for Flow Control Watchdog Timer */
-#define PCIE_SNR_FC_TIMER_S                  28
+#define PCIE_SNR			0x718
+
+#define PCIE_SNR_TS			0x0000000F
+#define PCIE_SNR_TS_S			0
+#define PCIE_SNR_SKP			0x00000700
+#define PCIE_SNR_SKP_S			8
+#define PCIE_SNR_REPLAY_TIMER		0x0007C000
+#define PCIE_SNR_REPLAY_TIMER_S		14
+#define PCIE_SNR_ACKNAK_LATENCY_TIMER	0x00F80000
+#define PCIE_SNR_ACKNAK_LATENCY_TIMER_S	19
+#define PCIE_SNR_FC_TIMER		0x1F000000
+#define PCIE_SNR_FC_TIMER_S		28
 
 /* Symbol Timer Register and Filter Mask Register 1 */
-#define PCIE_STRFMR(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x71C)
-#define PCIE_STRFMR_SKP_INTERVAL            0x000007FF  /* SKP lnterval Value */
-#define PCIE_STRFMR_SKP_INTERVAL_S          0
-#define PCIE_STRFMR_FC_WDT_DISABLE          0x00008000  /* Disable of FC Watchdog Timer */
-#define PCIE_STRFMR_TLP_FUNC_MISMATCH_OK    0x00010000  /* Mask Function Mismatch Filtering for Incoming Requests */
-#define PCIE_STRFMR_POISONED_TLP_OK         0x00020000  /* Mask Poisoned TLP Filtering */
-#define PCIE_STRFMR_BAR_MATCH_OK            0x00040000  /* Mask BAR Match Filtering */
-#define PCIE_STRFMR_TYPE1_CFG_REQ_OK        0x00080000  /* Mask Type 1 Configuration Request Filtering */
-#define PCIE_STRFMR_LOCKED_REQ_OK           0x00100000  /* Mask Locked Request Filtering */
-#define PCIE_STRFMR_CPL_TAG_ERR_RULES_OK    0x00200000  /* Mask Tag Error Rules for Received Completions */
-#define PCIE_STRFMR_CPL_REQUESTOR_ID_MISMATCH_OK 0x00400000  /* Mask Requester ID Mismatch Error for Received Completions */
-#define PCIE_STRFMR_CPL_FUNC_MISMATCH_OK         0x00800000  /* Mask Function Mismatch Error for Received Completions */
-#define PCIE_STRFMR_CPL_TC_MISMATCH_OK           0x01000000  /* Mask Traffic Class Mismatch Error for Received Completions */
-#define PCIE_STRFMR_CPL_ATTR_MISMATCH_OK         0x02000000  /* Mask Attribute Mismatch Error for Received Completions */
-#define PCIE_STRFMR_CPL_LENGTH_MISMATCH_OK       0x04000000  /* Mask Length Mismatch Error for Received Completions */
-#define PCIE_STRFMR_TLP_ECRC_ERR_OK              0x08000000  /* Mask ECRC Error Filtering */
-#define PCIE_STRFMR_CPL_TLP_ECRC_OK              0x10000000  /* Mask ECRC Error Filtering for Completions */
-#define PCIE_STRFMR_RX_TLP_MSG_NO_DROP           0x20000000  /* Send Message TLPs */
-#define PCIE_STRFMR_RX_IO_TRANS_ENABLE           0x40000000  /* Mask Filtering of received I/O Requests */
-#define PCIE_STRFMR_RX_CFG_TRANS_ENABLE          0x80000000  /* Mask Filtering of Received Configuration Requests */
+#define PCIE_STRFMR			0x71C
 
-#define PCIE_DEF_SKP_INTERVAL    700             /* 1180 ~1538 , 125MHz * 2, 250MHz * 1 */
+#define PCIE_STRFMR_SKP_INTERVAL		0x000007FF
+#define PCIE_STRFMR_SKP_INTERVAL_S		0
+#define PCIE_STRFMR_FC_WDT_DISABLE		0x00008000
+#define PCIE_STRFMR_TLP_FUNC_MISMATCH_OK	0x00010000
+#define PCIE_STRFMR_POISONED_TLP_OK		0x00020000
+#define PCIE_STRFMR_BAR_MATCH_OK		0x00040000
+#define PCIE_STRFMR_TYPE1_CFG_REQ_OK		0x00080000
+#define PCIE_STRFMR_LOCKED_REQ_OK		0x00100000
+#define PCIE_STRFMR_CPL_TAG_ERR_RULES_OK	0x00200000
+#define PCIE_STRFMR_CPL_REQUESTOR_ID_MISMATCH_OK	0x00400000
+#define PCIE_STRFMR_CPL_FUNC_MISMATCH_OK	0x00800000
+#define PCIE_STRFMR_CPL_TC_MISMATCH_OK		0x01000000
+#define PCIE_STRFMR_CPL_ATTR_MISMATCH_OK	0x02000000
+#define PCIE_STRFMR_CPL_LENGTH_MISMATCH_OK	0x04000000
+#define PCIE_STRFMR_TLP_ECRC_ERR_OK		0x08000000
+#define PCIE_STRFMR_CPL_TLP_ECRC_OK		0x10000000
+#define PCIE_STRFMR_RX_TLP_MSG_NO_DROP		0x20000000
+#define PCIE_STRFMR_RX_IO_TRANS_ENABLE		0x40000000
+#define PCIE_STRFMR_RX_CFG_TRANS_ENABLE		0x80000000
+
+#define PCIE_DEF_SKP_INTERVAL	700 /* 1180 ~1538 , 125MHz * 2, 250MHz * 1 */
 
 /* Filter Masker Register 2 */
-#define PCIE_FMR2(X)                             (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x720)
-#define PCIE_FMR2_VENDOR_MSG0_PASSED_TO_TRGT1    0x00000001  /* Mask RADM Filtering and Error Handling Rules */
-#define PCIE_FMR2_VENDOR_MSG1_PASSED_TO_TRGT1    0x00000002  /* Mask RADM Filtering and Error Handling Rules */
+#define PCIE_FMR2			0x720
+
+#define PCIE_FMR2_VENDOR_MSG0_PASSED_TO_TRGT1	0x00000001
+#define PCIE_FMR2_VENDOR_MSG1_PASSED_TO_TRGT1	0x00000002
+
+/* PCIe 2.0 AXI */
+#define PCIE_AMBA_MUTLI_REQ		0x724
 
 /* Debug Register 0 */
-#define PCIE_DBR0(X)                              (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x728)
+#define PCIE_DBR0			0x728
 
 /* Debug Register 1 */
-#define PCIE_DBR1(X)                              (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x72C)
+#define PCIE_DBR1			0x72C
 
 /* Transmit Posted FC Credit Status Register */
-#define PCIE_TPFCS(X)                             (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x730)
-#define PCIE_TPFCS_TX_P_DATA_FC_CREDITS           0x00000FFF /* Transmit Posted Data FC Credits */
-#define PCIE_TPFCS_TX_P_DATA_FC_CREDITS_S         0
-#define PCIE_TPFCS_TX_P_HDR_FC_CREDITS            0x000FF000 /* Transmit Posted Header FC Credits */
-#define PCIE_TPFCS_TX_P_HDR_FC_CREDITS_S          12
+#define PCIE_TPFCS			0x730
+
+#define PCIE_TPFCS_TX_P_DATA_FC_CREDITS		0x00000FFF
+#define PCIE_TPFCS_TX_P_DATA_FC_CREDITS_S	0
+#define PCIE_TPFCS_TX_P_HDR_FC_CREDITS		0x000FF000
+#define PCIE_TPFCS_TX_P_HDR_FC_CREDITS_S	12
 
 /* Transmit Non-Posted FC Credit Status */
-#define PCIE_TNPFCS(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x734)
-#define PCIE_TNPFCS_TX_NP_DATA_FC_CREDITS         0x00000FFF /* Transmit Non-Posted Data FC Credits */
-#define PCIE_TNPFCS_TX_NP_DATA_FC_CREDITS_S       0
-#define PCIE_TNPFCS_TX_NP_HDR_FC_CREDITS          0x000FF000 /* Transmit Non-Posted Header FC Credits */
-#define PCIE_TNPFCS_TX_NP_HDR_FC_CREDITS_S        12
+#define PCIE_TNPFCS			0x734
+
+#define PCIE_TNPFCS_TX_NP_DATA_FC_CREDITS	0x00000FFF
+#define PCIE_TNPFCS_TX_NP_DATA_FC_CREDITS_S	0
+#define PCIE_TNPFCS_TX_NP_HDR_FC_CREDITS	0x000FF000
+#define PCIE_TNPFCS_TX_NP_HDR_FC_CREDITS_S	12
 
 /* Transmit Complete FC Credit Status Register */
-#define PCIE_TCFCS(X)                             (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x738)
-#define PCIE_TCFCS_TX_CPL_DATA_FC_CREDITS         0x00000FFF /* Transmit Completion Data FC Credits */
-#define PCIE_TCFCS_TX_CPL_DATA_FC_CREDITS_S       0
-#define PCIE_TCFCS_TX_CPL_HDR_FC_CREDITS          0x000FF000 /* Transmit Completion Header FC Credits */
-#define PCIE_TCFCS_TX_CPL_HDR_FC_CREDITS_S        12
+#define PCIE_TCFCS			0x738
+
+#define PCIE_TCFCS_TX_CPL_DATA_FC_CREDITS	0x00000FFF
+#define PCIE_TCFCS_TX_CPL_DATA_FC_CREDITS_S	0
+#define PCIE_TCFCS_TX_CPL_HDR_FC_CREDITS	0x000FF000
+#define PCIE_TCFCS_TX_CPL_HDR_FC_CREDITS_S	12
 
 /* Queue Status Register */
-#define PCIE_QSR(X)                              (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x73C)
-#define PCIE_QSR_WAIT_UPDATE_FC_DLL               0x00000001 /* Received TLP FC Credits Not Returned */
-#define PCIE_QSR_TX_RETRY_BUF_NOT_EMPTY           0x00000002 /* Transmit Retry Buffer Not Empty */
-#define PCIE_QSR_RX_QUEUE_NOT_EMPTY               0x00000004 /* Received Queue Not Empty */
+#define PCIE_QSR			0x73C
+
+#define PCIE_QSR_WAIT_UPDATE_FC_DLL		0x00000001
+#define PCIE_QSR_TX_RETRY_BUF_NOT_EMPTY		0x00000002
+#define PCIE_QSR_RX_QUEUE_NOT_EMPTY		0x00000004
 
 /* VC Transmit Arbitration Register 1 */
-#define PCIE_VCTAR1(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x740)
-#define PCIE_VCTAR1_WRR_WEIGHT_VC0               0x000000FF /* WRR Weight for VC0 */
-#define PCIE_VCTAR1_WRR_WEIGHT_VC1               0x0000FF00 /* WRR Weight for VC1 */
-#define PCIE_VCTAR1_WRR_WEIGHT_VC2               0x00FF0000 /* WRR Weight for VC2 */
-#define PCIE_VCTAR1_WRR_WEIGHT_VC3               0xFF000000 /* WRR Weight for VC3 */
+#define PCIE_VCTAR1			0x740
+
+#define PCIE_VCTAR1_WRR_WEIGHT_VC0		0x000000FF
+#define PCIE_VCTAR1_WRR_WEIGHT_VC1		0x0000FF00
+#define PCIE_VCTAR1_WRR_WEIGHT_VC2		0x00FF0000
+#define PCIE_VCTAR1_WRR_WEIGHT_VC3		0xFF000000
 
 /* VC Transmit Arbitration Register 2 */
-#define PCIE_VCTAR2(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x744)
-#define PCIE_VCTAR2_WRR_WEIGHT_VC4               0x000000FF /* WRR Weight for VC4 */
-#define PCIE_VCTAR2_WRR_WEIGHT_VC5               0x0000FF00 /* WRR Weight for VC5 */
-#define PCIE_VCTAR2_WRR_WEIGHT_VC6               0x00FF0000 /* WRR Weight for VC6 */
-#define PCIE_VCTAR2_WRR_WEIGHT_VC7               0xFF000000 /* WRR Weight for VC7 */
+#define PCIE_VCTAR2			0x744
+
+#define PCIE_VCTAR2_WRR_WEIGHT_VC4		0x000000FF
+#define PCIE_VCTAR2_WRR_WEIGHT_VC5		0x0000FF00
+#define PCIE_VCTAR2_WRR_WEIGHT_VC6		0x00FF0000
+#define PCIE_VCTAR2_WRR_WEIGHT_VC7		0xFF000000
 
 /* VC0 Posted Receive Queue Control Register */
-#define PCIE_VC0_PRQCR(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x748)
-#define PCIE_VC0_PRQCR_P_DATA_CREDITS            0x00000FFF /* VC0 Posted Data Credits */
-#define PCIE_VC0_PRQCR_P_DATA_CREDITS_S          0
-#define PCIE_VC0_PRQCR_P_HDR_CREDITS             0x000FF000 /* VC0 Posted Header Credits */
-#define PCIE_VC0_PRQCR_P_HDR_CREDITS_S           12
-#define PCIE_VC0_PRQCR_P_TLP_QUEUE_MODE          0x00E00000 /* VC0 Posted TLP Queue Mode */
-#define PCIE_VC0_PRQCR_P_TLP_QUEUE_MODE_S        20
-#define PCIE_VC0_PRQCR_TLP_RELAX_ORDER           0x40000000 /* TLP Type Ordering for VC0 */    
-#define PCIE_VC0_PRQCR_VC_STRICT_ORDER           0x80000000 /* VC0 Ordering for Receive Queues */
+#define PCIE_VC0_PRQCR			0x748
+
+#define PCIE_VC0_PRQCR_P_DATA_CREDITS		0x00000FFF
+#define PCIE_VC0_PRQCR_P_DATA_CREDITS_S		0
+#define PCIE_VC0_PRQCR_P_HDR_CREDITS		0x000FF000
+#define PCIE_VC0_PRQCR_P_HDR_CREDITS_S		12
+#define PCIE_VC0_PRQCR_P_TLP_QUEUE_MODE		0x00E00000
+#define PCIE_VC0_PRQCR_P_TLP_QUEUE_MODE_S	20
+#define PCIE_VC0_PRQCR_TLP_RELAX_ORDER		0x40000000
+#define PCIE_VC0_PRQCR_VC_STRICT_ORDER		0x80000000
 
 /* VC0 Non-Posted Receive Queue Control */
-#define PCIE_VC0_NPRQCR(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x74C)
-#define PCIE_VC0_NPRQCR_NP_DATA_CREDITS          0x00000FFF /* VC0 Non-Posted Data Credits */
-#define PCIE_VC0_NPRQCR_NP_DATA_CREDITS_S        0
-#define PCIE_VC0_NPRQCR_NP_HDR_CREDITS           0x000FF000 /* VC0 Non-Posted Header Credits */
-#define PCIE_VC0_NPRQCR_NP_HDR_CREDITS_S         12
-#define PCIE_VC0_NPRQCR_NP_TLP_QUEUE_MODE        0x00E00000 /* VC0 Non-Posted TLP Queue Mode */
-#define PCIE_VC0_NPRQCR_NP_TLP_QUEUE_MODE_S      20
+#define PCIE_VC0_NPRQCR			0x74C
+
+#define PCIE_VC0_NPRQCR_NP_DATA_CREDITS		0x00000FFF
+#define PCIE_VC0_NPRQCR_NP_DATA_CREDITS_S	0
+#define PCIE_VC0_NPRQCR_NP_HDR_CREDITS		0x000FF000
+#define PCIE_VC0_NPRQCR_NP_HDR_CREDITS_S	12
+#define PCIE_VC0_NPRQCR_NP_TLP_QUEUE_MODE	0x00E00000
+#define PCIE_VC0_NPRQCR_NP_TLP_QUEUE_MODE_S	20
 
 /* VC0 Completion Receive Queue Control */
-#define PCIE_VC0_CRQCR(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x750)
-#define PCIE_VC0_CRQCR_CPL_DATA_CREDITS          0x00000FFF /* VC0 Completion TLP Queue Mode */
-#define PCIE_VC0_CRQCR_CPL_DATA_CREDITS_S        0
-#define PCIE_VC0_CRQCR_CPL_HDR_CREDITS           0x000FF000 /* VC0 Completion Header Credits */
-#define PCIE_VC0_CRQCR_CPL_HDR_CREDITS_S         12
-#define PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE        0x00E00000 /* VC0 Completion Data Credits */
-#define PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE_S      21
+#define PCIE_VC0_CRQCR			0x750
+
+#define PCIE_VC0_CRQCR_CPL_DATA_CREDITS		0x00000FFF
+#define PCIE_VC0_CRQCR_CPL_DATA_CREDITS_S	0
+#define PCIE_VC0_CRQCR_CPL_HDR_CREDITS		0x000FF000
+#define PCIE_VC0_CRQCR_CPL_HDR_CREDITS_S	12
+#define PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE	0x00E00000
+#define PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE_S	21
 
 /* Applicable to the above three registers */
 enum {
-    PCIE_VC0_TLP_QUEUE_MODE_STORE_FORWARD = 1,
-    PCIE_VC0_TLP_QUEUE_MODE_CUT_THROUGH   = 2,
-    PCIE_VC0_TLP_QUEUE_MODE_BYPASS        = 4,
+	PCIE_VC0_TLP_QUEUE_MODE_STORE_FORWARD = 1,
+	PCIE_VC0_TLP_QUEUE_MODE_CUT_THROUGH = 2,
+	PCIE_VC0_TLP_QUEUE_MODE_BYPASS = 4,
 };
 
 /* VC0 Posted Buffer Depth Register */
-#define PCIE_VC0_PBD(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x7A8)
-#define PCIE_VC0_PBD_P_DATA_QUEUE_ENTRIES       0x00003FFF /* VC0 Posted Data Queue Depth */
-#define PCIE_VC0_PBD_P_DATA_QUEUE_ENTRIES_S     0
-#define PCIE_VC0_PBD_P_HDR_QUEUE_ENTRIES        0x03FF0000 /* VC0 Posted Header Queue Depth */
-#define PCIE_VC0_PBD_P_HDR_QUEUE_ENTRIES_S      16
+#define PCIE_VC0_PBD			0x7A8
+
+#define PCIE_VC0_PBD_P_DATA_QUEUE_ENTRIES	0x00003FFF
+#define PCIE_VC0_PBD_P_DATA_QUEUE_ENTRIES_S	0
+#define PCIE_VC0_PBD_P_HDR_QUEUE_ENTRIES	0x03FF0000
+#define PCIE_VC0_PBD_P_HDR_QUEUE_ENTRIES_S	16
 
 /* VC0 Non-Posted Buffer Depth Register */
-#define PCIE_VC0_NPBD(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x7AC)
-#define PCIE_VC0_NPBD_NP_DATA_QUEUE_ENTRIES     0x00003FFF /* VC0 Non-Posted Data Queue Depth */
-#define PCIE_VC0_NPBD_NP_DATA_QUEUE_ENTRIES_S   0
-#define PCIE_VC0_NPBD_NP_HDR_QUEUE_ENTRIES      0x03FF0000 /* VC0 Non-Posted Header Queue Depth */
-#define PCIE_VC0_NPBD_NP_HDR_QUEUE_ENTRIES_S    16
+#define PCIE_VC0_NPBD			0x7AC
+
+#define PCIE_VC0_NPBD_NP_DATA_QUEUE_ENTRIES	0x00003FFF
+#define PCIE_VC0_NPBD_NP_DATA_QUEUE_ENTRIES_S	0
+#define PCIE_VC0_NPBD_NP_HDR_QUEUE_ENTRIES	0x03FF0000
+#define PCIE_VC0_NPBD_NP_HDR_QUEUE_ENTRIES_S	16
 
 /* VC0 Completion Buffer Depth Register */
-#define PCIE_VC0_CBD(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x7B0)
-#define PCIE_VC0_CBD_CPL_DATA_QUEUE_ENTRIES     0x00003FFF /* C0 Completion Data Queue Depth */
-#define PCIE_VC0_CBD_CPL_DATA_QUEUE_ENTRIES_S   0
-#define PCIE_VC0_CBD_CPL_HDR_QUEUE_ENTRIES      0x03FF0000 /* VC0 Completion Header Queue Depth */
-#define PCIE_VC0_CBD_CPL_HDR_QUEUE_ENTRIES_S    16
+#define PCIE_VC0_CBD			0x7B0
 
-/* PHY Status Register, all zeros in VR9 */
-#define PCIE_PHYSR(X)                           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x810)
+#define PCIE_VC0_CBD_CPL_DATA_QUEUE_ENTRIES	0x00003FFF
+#define PCIE_VC0_CBD_CPL_DATA_QUEUE_ENTRIES_S	0
+#define PCIE_VC0_CBD_CPL_HDR_QUEUE_ENTRIES	0x03FF0000
+#define PCIE_VC0_CBD_CPL_HDR_QUEUE_ENTRIES_S	16
 
-/* PHY Control Register, all zeros in VR9 */
-#define PCIE_PHYCR(X)                           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x814)
+/* PCIE 2.0 important configuration register */
+#define PCIE_GEN2_CTRL			0x80C
+#define PCIE_GEN2_CTRL_FTS		0x000000FF
+#define PCIE_GEN2_CTRL_FTS_S		0
+#define PCIE_GEN2_DEFAULT_FTS_NUM	127
+#define PCIE_GEN2_CTRL_LANES_NR		0x0001FF00
+#define PCIE_GEN2_CTRL_LANES_NR_S	8
+#define PCIE_GEN2_CTRL_SPEED_CHANGE	BIT(17)
+#define PCIE_GEN2_CTRL_TX_PHY_CHANGE	BIT(18)
+#define PCIE_GEN2_CTRL_TX_COMP_RX	BIT(19)
+#define PCIE_GEN2_CTRL_SEL_DEEMP_LOW	BIT(20)
+#define PCIE_GEN2_CTRL_GEN1_EI_INFER	BIT(21)
 
-/* 
- * PCIe PDI PHY register definition, suppose all the following 
- * stuff is confidential. 
+/* PHY Status Register,*/
+#define PCIE_PHYSR			0x810
+
+/* PHY Control Register */
+#define PCIE_PHYCR			0x814
+
+/*
+ * legacy PCIe PDI PHY register definition, suppose all the following
+ * stuff is confidential.
  * XXX, detailed bit definition
  */
-#define	PCIE_PHY_PLL_CTRL1(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x22 << 1))
-#define	PCIE_PHY_PLL_CTRL2(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x23 << 1))
-#define	PCIE_PHY_PLL_CTRL3(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x24 << 1))
-#define	PCIE_PHY_PLL_CTRL4(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x25 << 1))
-#define	PCIE_PHY_PLL_CTRL5(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x26 << 1))
-#define	PCIE_PHY_PLL_CTRL6(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x27 << 1))
-#define	PCIE_PHY_PLL_CTRL7(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x28 << 1))
-#define	PCIE_PHY_PLL_A_CTRL1(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x29 << 1))
-#define	PCIE_PHY_PLL_A_CTRL2(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x2A << 1))
-#define	PCIE_PHY_PLL_A_CTRL3(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x2B << 1))
-#define	PCIE_PHY_PLL_STATUS(X)      (PCIE_PHY_PORT_TO_BASE(X) + (0x2C << 1))
- 
-#define PCIE_PHY_TX1_CTRL1(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x30 << 1))
-#define PCIE_PHY_TX1_CTRL2(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x31 << 1))
-#define PCIE_PHY_TX1_CTRL3(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x32 << 1))
-#define PCIE_PHY_TX1_A_CTRL1(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x33 << 1))
-#define PCIE_PHY_TX1_A_CTRL2(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x34 << 1))
-#define PCIE_PHY_TX1_MOD1(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x35 << 1))
-#define PCIE_PHY_TX1_MOD2(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x36 << 1))
-#define PCIE_PHY_TX1_MOD3(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x37 << 1))
+#define	PCIE_PHY_PLL_CTRL1		(0x22 << 1)
+#define	PCIE_PHY_PLL_CTRL2		(0x23 << 1)
+#define	PCIE_PHY_PLL_CTRL3		(0x24 << 1)
+#define	PCIE_PHY_PLL_CTRL4		(0x25 << 1)
+#define	PCIE_PHY_PLL_CTRL5		(0x26 << 1)
+#define	PCIE_PHY_PLL_CTRL6		(0x27 << 1)
+#define	PCIE_PHY_PLL_CTRL7		(0x28 << 1)
+#define	PCIE_PHY_PLL_A_CTRL1		(0x29 << 1)
+#define	PCIE_PHY_PLL_A_CTRL2		(0x2A << 1)
+#define	PCIE_PHY_PLL_A_CTRL3		(0x2B << 1)
+#define	PCIE_PHY_PLL_STATUS		(0x2C << 1)
 
-#define PCIE_PHY_TX2_CTRL1(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x38 << 1))
-#define PCIE_PHY_TX2_CTRL2(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x39 << 1))
-#define PCIE_PHY_TX2_A_CTRL1(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x3B << 1))
-#define PCIE_PHY_TX2_A_CTRL2(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x3C << 1))
-#define PCIE_PHY_TX2_MOD1(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x3D << 1))
-#define PCIE_PHY_TX2_MOD2(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x3E << 1))
-#define PCIE_PHY_TX2_MOD3(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x3F << 1))
+#define PCIE_PHY_TX1_CTRL1		(0x30 << 1)
+#define PCIE_PHY_TX1_CTRL2		(0x31 << 1)
+#define PCIE_PHY_TX1_CTRL3		(0x32 << 1)
+#define PCIE_PHY_TX1_A_CTRL1		(0x33 << 1)
+#define PCIE_PHY_TX1_A_CTRL2		(0x34 << 1)
+#define PCIE_PHY_TX1_MOD1		(0x35 << 1)
+#define PCIE_PHY_TX1_MOD2		(0x36 << 1)
+#define PCIE_PHY_TX1_MOD3		(0x37 << 1)
 
-#define PCIE_PHY_RX1_CTRL1(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x50 << 1))
-#define PCIE_PHY_RX1_CTRL2(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x51 << 1))
-#define PCIE_PHY_RX1_CDR(X)         (PCIE_PHY_PORT_TO_BASE(X) + (0x52 << 1))
-#define PCIE_PHY_RX1_EI(X)          (PCIE_PHY_PORT_TO_BASE(X) + (0x53 << 1))
-#define PCIE_PHY_RX1_A_CTRL(X)      (PCIE_PHY_PORT_TO_BASE(X) + (0x55 << 1))
+#define PCIE_PHY_TX2_CTRL1		(0x38 << 1)
+#define PCIE_PHY_TX2_CTRL2		(0x39 << 1)
+#define PCIE_PHY_TX2_A_CTRL1		(0x3B << 1)
+#define PCIE_PHY_TX2_A_CTRL2		(0x3C << 1)
+#define PCIE_PHY_TX2_MOD1		(0x3D << 1)
+#define PCIE_PHY_TX2_MOD2		(0x3E << 1)
+#define PCIE_PHY_TX2_MOD3		(0x3F << 1)
 
-/* Interrupt related stuff */
-#define PCIE_LEGACY_DISABLE 0
-#define PCIE_LEGACY_INTA  1
-#define PCIE_LEGACY_INTB  2
-#define PCIE_LEGACY_INTC  3
-#define PCIE_LEGACY_INTD  4
-#define PCIE_LEGACY_INT_MAX PCIE_LEGACY_INTD
+#define PCIE_PHY_RX1_CTRL1		(0x50 << 1)
+#define PCIE_PHY_RX1_CTRL2		(0x51 << 1)
+#define PCIE_PHY_RX1_CDR		(0x52 << 1)
+#define PCIE_PHY_RX1_EI			(0x53 << 1)
+#define PCIE_PHY_RX1_A_CTRL		(0x55 << 1)
 
-#define PCIE_IRQ_LOCK(lock) do {             \
-    unsigned long flags;                     \
-    spin_lock_irqsave(&(lock), flags);
-#define PCIE_IRQ_UNLOCK(lock)                \
-    spin_unlock_irqrestore(&(lock), flags);  \
-} while (0)
+/* PCIe 2.0 PDI PHY register definition */
+#define PCIE_PHY_CFG0			0xc004
+#define PCIE_PHY_CFG1			0xc008
+#define PCIE_PHY_CFG2			0xc00c
+#define PCIE_PHY_CFG3			0xc010
+#define PCIE_PHY_CFG4			0xc014
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
-#define IRQF_SHARED SA_SHIRQ
+/* PCIe PHY CFG0 */
+#define PCIE_PHY_RX_EQ			0x00000007
+#define PCIE_PHY_RX_EQ_S		0
+
+#define PCIE_PHY_TX_DE_6DB		0x000001F8
+#define PCIE_PHY_TX_DE_6DB_S		3
+
+#define PCIE_PHY_TX_SWING_LOW		0x0000FE00
+#define PCIE_PHY_TX_SWING_LOW_S		9
+
+/* PCIe PHY CFG1 */
+#define PCIE_PHY_TX_DE_3DB		0x0000003F
+#define PCIE_PHY_TX_DE_3DB_S		0
+
+#define PCIE_PHY_TX_TERM		0x000007C0
+#define PCIE_PHY_TX_TERM_S		6
+
+/* PCIe PHY CFG2 */
+#define PCIE_PHY_TX_DE_GEN1		0x0000003F
+#define PCIE_PHY_TX_DE_GEN1_S		0
+
+#define PCIE_PHY_TX_SWING_FULL		0x00001FC0
+#define PCIE_PHY_TX_SWING_FULL_S	6
+
+/* PCIe PHY CFG3 */
+#define PCIE_PHY_PIPE_EN		BIT(0)
+#define PCIE_PHY_CM_CLK_SEL		BIT(1)
+#define PCIE_PHY_MPLL_M			0x00003F80
+#define PCIE_PHY_MPLL_M_S		7
+#define PCIE_PHY_REF_CLK_DIV2		0x0000C000
+#define PCIE_PHY_REF_CLK_DIV2_S		14
+
+/* PCIe PHY CFG4 */
+#define PCIE_PHY_REF_CLK_PAD		BIT(0)
+#define PCIE_PHY_LOS_BIAS		0x0000000E
+#define PCIE_PHY_LOS_BIAS_S		1
+#define PCIE_PHY_LOS_LEVEL		0x000001F0
+#define PCIE_PHY_IOS_LEVEL_S		4
+#define PCIE_PHY_TX_VBOOST		0x00000E00
+#define PCIE_PHY_TX_VBOOST_S		9
+#define PCIE_PHY_VREG_BYPASS		BIT(12)
+#define PCIE_PHY_PIPE_PD		BIT(14)
+#define PCIE_PHY_PIPE_PD_O		BIT(15)
+
+/* xRX500 LCPLL SSC */
+#define PCIE_LCPLL_CFG0		0x0094
+#define LCPLL_CFG0_LOCKED	BIT(1)
+#define PCIE_LCPLL_CFG1		0x0098
+#define PCIE_LCPLL_SSC_CTRL	0x009C
+#define PCIE_LCPLL_SSC_SCALE	0x00A0
+#define PCIE_LCPLL_COEF_0	0x00A4
+#define PCIE_LCPLL_COEF_1	0x00A8
+#define PCIE_LCPLL_COEF_2	0x00AC
+#define PCIE_LCPLL_COEF_3	0x00B0
+#define PCIE_LCPLL_COEF_4	0x00B4
+#define PCIE_LCPLL_COEF_5	0x00B8
+#define PCIE_LCPLL_COEF_6	0x00BC
+#define PCIE_LCPLL_COEF_7	0x00C0
+
+#ifdef CONFIG_PCI_MSI
+extern struct msi_chip ltq_msi_chip;
 #endif
 
-#define PCIE_MSG_MSI        0x00000001
-#define PCIE_MSG_ISR        0x00000002
-#define PCIE_MSG_FIXUP      0x00000004
-#define PCIE_MSG_READ_CFG   0x00000008
-#define PCIE_MSG_WRITE_CFG  0x00000010
-#define PCIE_MSG_CFG        (PCIE_MSG_READ_CFG | PCIE_MSG_WRITE_CFG)
-#define PCIE_MSG_REG        0x00000020
-#define PCIE_MSG_INIT       0x00000040
-#define PCIE_MSG_ERR        0x00000080
-#define PCIE_MSG_PHY        0x00000100
-#define PCIE_MSG_ANY        0x000001ff
+static inline void pcie_ep_rst_init(struct ltq_pcie_port *lpp)
+{
+	struct device *dev = lpp->dev;
+	struct device_node *np = dev->of_node;
 
-#define IFX_PCIE_PORT0      0
-#define IFX_PCIE_PORT1      1
+	lpp->reset_gpio = of_get_named_gpio(np, "reset-gpio", 0);
+	dev_dbg(lpp->dev, "gpio %d\n", lpp->reset_gpio);
+	if (gpio_is_valid(lpp->reset_gpio)) {
+		int ret = devm_gpio_request(lpp->dev,
+				lpp->reset_gpio, "pcie-reset");
+		if (ret) {
+			dev_err(lpp->dev, "%s failed to request gpio %d\n",
+				__func__, lpp->reset_gpio);
+			return;
+		}
+		gpio_direction_output(lpp->reset_gpio, 1);
+	}
 
-#ifdef CONFIG_IFX_PCIE_2ND_CORE
-#define IFX_PCIE_CORE_NR    2
-#else
-#define IFX_PCIE_CORE_NR    1
-#endif
+	if (lpp->high_active_rst)
+		gpio_set_value(lpp->reset_gpio, 0);
+	else
+		gpio_set_value(lpp->reset_gpio, 1);
 
-//#define IFX_PCIE_ERROR_INT
-
-//#define IFX_PCIE_DBG
-
-#if defined(IFX_PCIE_DBG)
-#define IFX_PCIE_PRINT(_m, _fmt, args...) do {   \
-    if (g_pcie_debug_flag & (_m)) {              \
-        ifx_pcie_debug((_fmt), ##args);          \
-    }                                            \
-} while (0)
-
-#define INLINE 
-#else
-#define IFX_PCIE_PRINT(_m, _fmt, args...)   \
-    do {} while(0)
-#define INLINE inline
-#endif
-
-struct ifx_pci_controller {
-	struct pci_controller   pcic;
-    
-	/* RC specific, per host bus information */
-	u32   port;  /* Port index, 0 -- 1st core, 1 -- 2nd core */
-};
-
-typedef struct ifx_pcie_ir_irq {
-    const unsigned int irq;
-    const char name[16];
-}ifx_pcie_ir_irq_t;
-
-typedef struct ifx_pcie_legacy_irq{
-    const u32 irq_bit;
-    const int irq;
-}ifx_pcie_legacy_irq_t;
-
-typedef struct ifx_pcie_irq {
-    ifx_pcie_ir_irq_t ir_irq;
-    ifx_pcie_legacy_irq_t legacy_irq[PCIE_LEGACY_INT_MAX];
-}ifx_pcie_irq_t;
-
-extern u32 g_pcie_debug_flag;
-extern void ifx_pcie_debug(const char *fmt, ...);
-extern void pcie_phy_clock_mode_setup(int pcie_port);
-extern void pcie_msi_pic_init(int pcie_port);
-extern u32 ifx_pcie_bus_enum_read_hack(int where, u32 value);
-extern u32 ifx_pcie_bus_enum_write_hack(int where, u32 value);
-
-
-#include <linux/types.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/clk.h>
-
-#include <lantiq_soc.h>
-
-#define IFX_PCIE_GPIO_RESET  38
-#define IFX_REG_R32	ltq_r32
-#define IFX_REG_W32	ltq_w32
-#define CONFIG_IFX_PCIE_HW_SWAP
-#define IFX_RCU_AHB_ENDIAN                      ((volatile u32*)(IFX_RCU + 0x004C))
-#define IFX_RCU_RST_REQ                         ((volatile u32*)(IFX_RCU + 0x0010))
-#define IFX_RCU_AHB_BE_PCIE_PDI                  0x00000080  /* Configure PCIE PDI module in big endian*/
-
-#define IFX_RCU                                 (KSEG1 | 0x1F203000)
-#define IFX_RCU_AHB_BE_PCIE_M                    0x00000001  /* Configure AHB master port that connects to PCIe RC in big endian */
-#define IFX_RCU_AHB_BE_PCIE_S                    0x00000010  /* Configure AHB slave port that connects to PCIe RC in little endian */
-#define IFX_RCU_AHB_BE_XBAR_M                    0x00000002  /* Configure AHB master port that connects to XBAR in big endian */
-#define CONFIG_IFX_PCIE_PHY_36MHZ_MODE
-
-#define IFX_PMU1_MODULE_PCIE_PHY   (0)
-#define IFX_PMU1_MODULE_PCIE_CTRL  (1)
-#define IFX_PMU1_MODULE_PDI        (4)
-#define IFX_PMU1_MODULE_MSI        (5)
-
-#define IFX_PMU_MODULE_PCIE_L0_CLK (31)
-
-
-static inline void pcie_ep_gpio_rst_init(int pcie_port)
-{
+	mdelay(100);
 }
 
-static inline void pcie_ahb_pmu_setup(void)
+static inline int pcie_ahb_pmu_setup(struct ltq_pcie_port *lpp)
 {
-	struct clk *clk;
-	clk = clk_get_sys("ltq_pcie", "ahb");
-	clk_enable(clk);
-	//ltq_pmu_enable(PMU_AHBM | PMU_AHBS);
+	int err;
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
+
+	if (soc->has_ahb_clk) {
+		err = clk_prepare_enable(lpp->ahb_clk);
+		if (err < 0) {
+			dev_err(lpp->dev,
+				"failed to enable ahb clock: %d\n", err);
+			return err;
+		}
+	}
+	return 0;
 }
 
-static inline void pcie_rcu_endian_setup(int pcie_port)
+static inline void pcie_rcu_endian_setup(struct ltq_pcie_port *lpp)
 {
-    u32 reg;
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
+#ifdef CONFIG_CPU_BIG_ENDIAN
+	if (soc->has_ahb2m_endian)
+		ltq_endian_clr(soc->ahb2m_endian_ctrl_shift);
 
-    reg = IFX_REG_R32(IFX_RCU_AHB_ENDIAN);
-#ifdef CONFIG_IFX_PCIE_HW_SWAP
-    reg |= IFX_RCU_AHB_BE_PCIE_M;
-    reg |= IFX_RCU_AHB_BE_PCIE_S;
-    reg &= ~IFX_RCU_AHB_BE_XBAR_M;
-#else 
-    reg |= IFX_RCU_AHB_BE_PCIE_M;
-    reg &= ~IFX_RCU_AHB_BE_PCIE_S;
-    reg &= ~IFX_RCU_AHB_BE_XBAR_M;
-#endif /* CONFIG_IFX_PCIE_HW_SWAP */
-    IFX_REG_W32(reg, IFX_RCU_AHB_ENDIAN);
-    IFX_PCIE_PRINT(PCIE_MSG_REG, "%s IFX_RCU_AHB_ENDIAN: 0x%08x\n", __func__, IFX_REG_R32(IFX_RCU_AHB_ENDIAN));
+	if (soc->has_ahb4s_endian)
+		ltq_endian_set(soc->ahb4s_endian_ctrl_shift);
+
+	if (soc->has_ahb3m_endian)
+		ltq_endian_clr(soc->ahb3m_endian_ctrl_shift);
+
+	if (lpp->outbound_swap)
+		ltq_endian_set(lpp->outbound_shift);
+	else
+		ltq_endian_clr(lpp->outbound_shift);
+	if (lpp->inbound_swap)
+		ltq_endian_set(lpp->inbound_shift);
+	else
+		ltq_endian_clr(lpp->inbound_shift);
+#else
+	if (soc->has_ahb2m_endian)
+		ltq_endian_clr(soc->ahb2m_endian_ctrl_shift);
+
+	if (soc->has_ahb4s_endian)
+		ltq_endian_clr(soc->ahb4s_endian_ctrl_shift);
+
+	if (soc->has_ahb3m_endian)
+		ltq_endian_clr(soc->ahb3m_endian_ctrl_shift);
+	ltq_endian_clr(lpp->outbound_shift);
+	ltq_endian_clr(lpp->inbound_shift);
+#endif /* CONFIG_CPU_BIG_ENDIAN */
 }
 
-static inline void pcie_phy_pmu_enable(int pcie_port)
+static inline int pcie_phy_pmu_enable(struct ltq_pcie_port *lpp)
 {
-	struct clk *clk;
-	clk = clk_get_sys("ltq_pcie", "phy");
-	clk_enable(clk);
-	//ltq_pmu1_enable(1<<IFX_PMU1_MODULE_PCIE_PHY);
+	int err;
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
+
+	if (soc->has_phy_clk) {
+		err = clk_prepare_enable(lpp->phy_clk);
+		if (err < 0) {
+			dev_err(lpp->dev,
+				"failed to enable PHY clock: %d\n", err);
+			return err;
+		}
+	}
+	return 0;
 }
 
-static inline void pcie_phy_pmu_disable(int pcie_port)
+static inline void pcie_phy_pmu_disable(struct ltq_pcie_port *lpp)
 {
-	struct clk *clk;
-	clk = clk_get_sys("ltq_pcie", "phy");
-	clk_disable(clk);
-	//ltq_pmu1_disable(1<<IFX_PMU1_MODULE_PCIE_PHY);
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
+
+	if (soc->has_phy_clk)
+		clk_disable_unprepare(lpp->phy_clk);
 }
 
-static inline void pcie_pdi_big_endian(int pcie_port)
+static inline int pcie_pdi_pmu_enable(struct ltq_pcie_port *lpp)
 {
-    u32 reg;
+	int err;
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
 
-    /* SRAM2PDI endianness control. */
-    reg = IFX_REG_R32(IFX_RCU_AHB_ENDIAN);
-    /* Config AHB->PCIe and PDI endianness */
-    reg |= IFX_RCU_AHB_BE_PCIE_PDI;
-    IFX_REG_W32(reg, IFX_RCU_AHB_ENDIAN);
+	if (soc->has_pdi_clk) {
+		err = clk_prepare_enable(lpp->pdi_clk);
+		if (err < 0) {
+			dev_err(lpp->dev,
+				"failed to enable PDI clock: %d\n", err);
+			return err;
+		}
+	}
+	return 0;
 }
 
-static inline void pcie_pdi_pmu_enable(int pcie_port)
+static inline void pcie_phy_clk_out(struct ltq_pcie_port *lpp)
 {
-	struct clk *clk;
-	clk = clk_get_sys("ltq_pcie", "pdi");
-	clk_enable(clk);
-	//ltq_pmu1_enable(1<<IFX_PMU1_MODULE_PDI);
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
+
+	if (soc->has_clk_out)
+		ltq_pcie_clk_out(lpp->clk_out_pin);
 }
 
-static inline void pcie_core_rst_assert(int pcie_port)
+static inline void pcie_core_rst_assert(struct ltq_pcie_port *lpp)
 {
-    u32 reg;
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
 
-    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-
-    /* Reset PCIe PHY & Core, bit 22, bit 26 may be affected if write it directly  */
-    reg |= 0x00400000;
-    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
+	if (soc->has_core_rst)
+		reset_control_assert(lpp->core_rst);
 }
 
-static inline void pcie_core_rst_deassert(int pcie_port)
+static inline void pcie_core_rst_deassert(struct ltq_pcie_port *lpp)
 {
-    u32 reg;
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
 
-    /* Make sure one micro-second delay */
-    udelay(1);
-
-    /* Reset PCIe PHY & Core, bit 22 */
-    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-    reg &= ~0x00400000;
-    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
+	if (soc->has_core_rst) {
+		/* Make sure one micro-second delay */
+		udelay(1);
+		reset_control_deassert(lpp->core_rst);
+	}
 }
 
-static inline void pcie_phy_rst_assert(int pcie_port)
+static inline void pcie_phy_rst_assert(struct ltq_pcie_port *lpp)
 {
-    u32 reg;
-
-    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-    reg |= 0x00001000; /* Bit 12 */
-    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
+	reset_control_assert(lpp->phy_rst);
 }
 
-static inline void pcie_phy_rst_deassert(int pcie_port)
+static inline void pcie_phy_rst_deassert(struct ltq_pcie_port *lpp)
 {
-    u32 reg;
-
-    /* Make sure one micro-second delay */
-    udelay(1);
-
-    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-    reg &= ~0x00001000; /* Bit 12 */
-    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
+	/* Make sure one micro-second delay */
+	udelay(1);
+	reset_control_deassert(lpp->phy_rst);
 }
 
-static inline void pcie_device_rst_assert(int pcie_port)
+static inline void pcie_device_rst_assert(struct ltq_pcie_port *lpp)
 {
-	gpio_set_value(IFX_PCIE_GPIO_RESET, 0);
-  //  ifx_gpio_output_clear(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
+	if (lpp->high_active_rst)
+		gpio_set_value(lpp->reset_gpio, 1);
+	else
+		gpio_set_value(lpp->reset_gpio, 0);
 }
 
-static inline void pcie_device_rst_deassert(int pcie_port)
+static inline void pcie_device_rst_deassert(struct ltq_pcie_port *lpp)
 {
-    mdelay(100);
-	gpio_set_value(IFX_PCIE_GPIO_RESET, 1);
-//    ifx_gpio_output_set(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
+	mdelay(lpp->rst_interval);
+	if (lpp->high_active_rst)
+		gpio_set_value(lpp->reset_gpio, 0);
+	else
+		gpio_set_value(lpp->reset_gpio, 1);
 }
 
-static inline void pcie_core_pmu_setup(int pcie_port)
+static inline int pcie_core_pmu_setup(struct ltq_pcie_port *lpp)
 {
-	struct clk *clk;
-	clk = clk_get_sys("ltq_pcie", "ctl");
-	clk_enable(clk);
-	clk = clk_get_sys("ltq_pcie", "bus");
-	clk_enable(clk);
+	int err;
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
 
-	//ltq_pmu1_enable(1 << IFX_PMU1_MODULE_PCIE_CTRL);
-	//ltq_pmu_enable(1 << IFX_PMU_MODULE_PCIE_L0_CLK);
+	if (soc->has_bus_clk) {
+		err = clk_prepare_enable(lpp->bus_clk);
+		if (err < 0) {
+			dev_err(lpp->dev, "failed to enable bus clock: %d\n",
+				err);
+			return err;
+		}
+	}
+
+	err = clk_prepare_enable(lpp->core_clk);
+	if (err < 0) {
+		dev_err(lpp->dev, "failed to enable core clock: %d\n", err);
+		return err;
+	}
+	return 0;
 }
 
-static inline void pcie_msi_init(int pcie_port)
+static inline int pcie_msi_init(struct ltq_pcie_port *lpp)
 {
-	struct clk *clk;
-    pcie_msi_pic_init(pcie_port);
-	clk = clk_get_sys("ltq_pcie", "msi");
-	clk_enable(clk);
-	//ltq_pmu1_enable(1 << IFX_PMU1_MODULE_MSI);
+	int err;
+	const struct ltq_pcie_soc_data *soc = lpp->soc_data;
+
+	if (soc->has_msi_clk) {
+		err = clk_prepare_enable(lpp->msi_clk);
+		if (err < 0) {
+			dev_err(lpp->dev,
+				"failed to enable MSI clock: %d\n", err);
+			return err;
+		}
+	}
+	pcie_msi_pic_init(lpp);
+	return 0;
 }
 
-static inline u32
-ifx_pcie_bus_nr_deduct(u32 bus_number, int pcie_port)
-{
-    u32 tbus_number = bus_number;
-
-#ifdef CONFIG_IFX_PCI
-    if (pcibios_host_nr() > 1) {
-        tbus_number -= pcibios_1st_host_bus_nr();
-    }
-#endif /* CONFIG_IFX_PCI */
-    return tbus_number;
-}
-
-static inline u32
-ifx_pcie_bus_enum_hack(struct pci_bus *bus, u32 devfn, int where, u32 value, int pcie_port, int read)
-{
-    struct pci_dev *pdev;
-    u32 tvalue = value;
-
-    /* Sanity check */
-    pdev = pci_get_slot(bus, devfn);
-    if (pdev == NULL) {
-        return tvalue;
-    }
-
-    /* Only care about PCI bridge */
-    if (pdev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {
-        return tvalue;
-    }
-
-    if (read) { /* Read hack */
-    #ifdef CONFIG_IFX_PCI
-        if (pcibios_host_nr() > 1) {
-            tvalue = ifx_pcie_bus_enum_read_hack(where, tvalue);
-        }
-    #endif /* CONFIG_IFX_PCI */  
-    }
-    else { /* Write hack */
-    #ifdef CONFIG_IFX_PCI    
-        if (pcibios_host_nr() > 1) {
-            tvalue = ifx_pcie_bus_enum_write_hack(where, tvalue);
-        }
-    #endif
-    }
-    return tvalue;
-}
-
-#endif /* IFXMIPS_PCIE_VR9_H */
-
+#endif /* PCIE_LANTIQ_H */
diff --git a/drivers/pci/pcie/aer/aerdrv.c b/drivers/pci/pcie/aer/aerdrv.c
old mode 100644
new mode 100755
--- a/drivers/pci/pcie/aer/aerdrv.c
+++ b/drivers/pci/pcie/aer/aerdrv.c
@@ -293,6 +293,14 @@ static void aer_remove(struct pcie_devic
 	}
 }
 
+struct pci_dev *aer_dev_to_pci_dev(void *context)
+{
+	struct pcie_device *dev = (struct pcie_device *)context;
+
+	return dev->port;
+}
+EXPORT_SYMBOL_GPL(aer_dev_to_pci_dev);
+
 /**
  * aer_probe - initialize resources
  * @dev: pointer to the pcie_dev data structure
@@ -319,6 +327,13 @@ static int aer_probe(struct pcie_device 
 		return -ENOMEM;
 	}
 
+#if defined(CONFIG_PCIE_LANTIQ)
+	{
+		extern int pcie_rc_aer_irq_register(struct pci_dev *dev,
+			void *context);
+		pcie_rc_aer_irq_register(dev->port, dev);
+	}
+#else
 	/* Request IRQ ISR */
 	status = request_irq(dev->irq, aer_irq, IRQF_SHARED, "aerdrv", dev);
 	if (status) {
@@ -326,7 +341,7 @@ static int aer_probe(struct pcie_device 
 		aer_remove(dev);
 		return status;
 	}
-
+#endif
 	rpc->isr = 1;
 
 	aer_enable_rootport(rpc);
diff --git a/drivers/pci/search.c b/drivers/pci/search.c
old mode 100644
new mode 100755
--- a/drivers/pci/search.c
+++ b/drivers/pci/search.c
@@ -17,6 +17,30 @@
 DECLARE_RWSEM(pci_bus_sem);
 EXPORT_SYMBOL_GPL(pci_bus_sem);
 
+#if defined(CONFIG_PCIE_LANTIQ)
+static DEFINE_SPINLOCK(pci_bus_spinlock);
+static unsigned long pci_bus_lock_flags;
+#endif /* CONFIG_LANTIQ_PCIE */
+
+static void pci_bus_lock(void)
+{
+#if defined(CONFIG_PCIE_LANTIQ)
+	spin_lock_irqsave(&pci_bus_spinlock, pci_bus_lock_flags);
+#else
+	WARN_ON(in_interrupt());
+	down_read(&pci_bus_sem);
+#endif
+}
+
+static void pci_bus_unlock(void)
+{
+#if defined(CONFIG_PCIE_LANTIQ)
+	spin_unlock_irqrestore(&pci_bus_spinlock, pci_bus_lock_flags);
+#else
+	WARN_ON(in_interrupt());
+	up_read(&pci_bus_sem);
+#endif
+}
 /*
  * find the upstream PCIe-to-PCI bridge of a PCI device
  * if the device is PCIE, return NULL
@@ -117,6 +141,30 @@ pci_find_next_bus(const struct pci_bus *
 }
 
 /**
+ * pci_find_preexist_bus_nr - find the maximum bus number before the current bus
+ * @from: the current bus number.
+ *
+ * Iterates through the list of known PCI busses and return the maximum bus number
+ * in front of the current bus.
+ */
+int pci_find_preexist_bus_nr(const struct pci_bus *from)
+{
+	struct pci_bus *bus = NULL;
+	int max = 0; /* If only one host controller existed */
+
+	pci_bus_lock();
+	list_for_each_entry(bus, &pci_root_buses, node) {
+		if (bus->sysdata == from->sysdata) { /* Hit the same host controller,skip */
+		break;
+		}
+		max = pci_bus_max_busnr(bus) + 1;
+	}
+	pci_bus_unlock();
+	return max;
+}
+EXPORT_SYMBOL(pci_find_preexist_bus_nr);
+
+/**
  * pci_get_slot - locate PCI device for a given PCI slot
  * @bus: PCI bus on which desired PCI device resides
  * @devfn: encodes number of PCI slot in which the desired PCI 
@@ -134,8 +182,7 @@ struct pci_dev *pci_get_slot(struct pci_
 {
 	struct pci_dev *dev;
 
-	WARN_ON(in_interrupt());
-	down_read(&pci_bus_sem);
+	pci_bus_lock();
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		if (dev->devfn == devfn)
@@ -145,7 +192,7 @@ struct pci_dev *pci_get_slot(struct pci_
 	dev = NULL;
  out:
 	pci_dev_get(dev);
-	up_read(&pci_bus_sem);
+	pci_bus_unlock();
 	return dev;
 }
 
diff --git a/include/linux/pci.h b/include/linux/pci.h
old mode 100644
new mode 100755
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -1082,8 +1082,7 @@ void pci_walk_bus(struct pci_bus *top, i
 int pci_cfg_space_size_ext(struct pci_dev *dev);
 int pci_cfg_space_size(struct pci_dev *dev);
 unsigned char pci_bus_max_busnr(struct pci_bus *bus);
-int pcibios_host_nr(void);
-int pcibios_1st_host_bus_nr(void);
+int pci_find_preexist_bus_nr(const struct pci_bus *from);
 void pci_setup_bridge(struct pci_bus *bus);
 resource_size_t pcibios_window_alignment(struct pci_bus *bus,
 					 unsigned long type);
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
old mode 100644
new mode 100755
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -1042,11 +1042,6 @@
 #define PCI_DEVICE_ID_SGI_LITHIUM	0x1002
 #define PCI_DEVICE_ID_SGI_IOC4		0x100a
 
-#define PCI_VENDOR_ID_INFINEON		0x15D1
-#define PCI_DEVICE_ID_INFINEON_DANUBE	0x000F
-#define PCI_DEVICE_ID_INFINEON_PCIE	0x0011
-#define PCI_VENDOR_ID_LANTIQ		0x1BEF
-#define PCI_DEVICE_ID_LANTIQ_PCIE	0x00
 
 #define PCI_VENDOR_ID_WINBOND		0x10ad
 #define PCI_DEVICE_ID_WINBOND_82C105	0x0105
