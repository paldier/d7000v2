# HG changeset patch
# Parent 3ff3382ea6eac32a2b67d9a30a53d88c7604d854

diff --git a/drivers/net/ethernet/lantiq/Kconfig b/drivers/net/ethernet/lantiq/Kconfig
--- a/drivers/net/ethernet/lantiq/Kconfig
+++ b/drivers/net/ethernet/lantiq/Kconfig
@@ -63,5 +63,6 @@ config HAPS_CPU_LOOPBACK_TEST
 source "drivers/net/ethernet/lantiq/switch-api/Kconfig"
 source "drivers/net/ethernet/lantiq/tmu/Kconfig"
 source "drivers/net/ethernet/lantiq/cbm/Kconfig"
+source "drivers/net/ethernet/lantiq/vrx318/Kconfig"
 
 endif # NET_VENDOR_LANTIQ
diff --git a/drivers/net/ethernet/lantiq/Makefile b/drivers/net/ethernet/lantiq/Makefile
--- a/drivers/net/ethernet/lantiq/Makefile
+++ b/drivers/net/ethernet/lantiq/Makefile
@@ -5,3 +5,4 @@ obj-$(CONFIG_LTQ_TMU) += tmu/
 obj-$(CONFIG_LTQ_CBM) += cbm/
 obj-$(CONFIG_LTQ_ETH_XRX500) += ltq_eth_drv_xrx500.o
 obj-$(CONFIG_LTQ_TOE_DRIVER) += ltq_toe_drv.o
+obj-$(CONFIG_VRX318_DATAPATH) += vrx318/
diff --git a/drivers/net/ethernet/lantiq/vrx318/Kconfig b/drivers/net/ethernet/lantiq/vrx318/Kconfig
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/Kconfig
@@ -0,0 +1,27 @@
+#
+#VRX318 driver
+#
+menu "VRX318"
+
+config VRX318_DATAPATH
+	bool "VRX318 datapath driver"
+	depends on LTQ_DATAPATH && LTQ_CBM && LANTIQ_VRX318
+	default n
+	---help---
+	  VRX318 is PCIe endpoint providing ATM/PTM/PTM bonding functions.
+	  datapth built in kernel to provide consistent API support for
+	  MEI driver or other SoC required API support.
+	  Supporting APIs for differnt SoC platforms should be put
+	  in this part.
+
+config VRX318_TC
+	tristate "VRX318 ATM/PTM/BONDING TC"
+	depends on VRX318_DATAPATH
+	default n
+	---help---
+	  Support ATM/PTM/Bonding TC based on VRX318 datapath framework
+	  it merged ATM/PTM/Bonding function in one module.
+	  TC switch from ATM to PTM/Bonding or vice versa can be requested via
+	  API call or proc.
+
+endmenu
diff --git a/drivers/net/ethernet/lantiq/vrx318/Makefile b/drivers/net/ethernet/lantiq/vrx318/Makefile
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for VRX318 driver
+#
+obj-$(CONFIG_VRX318_DATAPATH) += vrx318_common.o
+obj-$(CONFIG_VRX318_TC) += vrx318_tc.o
+
+
+vrx318_tc-objs = vrx318.o vrx318_atm_tc.o vrx318_ptm_tc.o vrx318_api.o vrx318_proc.o
+
diff --git a/drivers/net/ethernet/lantiq/vrx318/fw/vrx318_a1plus.h b/drivers/net/ethernet/lantiq/vrx318/fw/vrx318_a1plus.h
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/fw/vrx318_a1plus.h
@@ -0,0 +1,636 @@
+#ifndef __VRX218_A1PLUS_FW_H
+#define __VRX218_A1PLUS_FW_H
+
+/******************************************************************************
+** FILE NAME    : ifxmips_ppa_datapath_fw_vrx218_a1plus.h
+** PROJECT      : PPA
+** PLATFORM     : VRX218
+** MODULES     	: A1PLUS
+**
+** DATE         : 06/03/2015
+** AUTHOR       : Lantiq PPE FW Team
+** DESCRIPTION  : VRX218 A1PLUS PPE Firmware Binary
+** COPYRIGHT    : 	   Copyright (c) 2015
+**			        Lantiq Deutschland GmbH
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** FW VERSION [31:0] : 0x91030204
+** MERCURIAL TAG     :
+**
+** HISTORY
+** $Date         $Author                   $Comment
+** 06/03/2015    Lantiq PPE FW Team        VRX218 A1PLUS PPE Firmware Binary
+*******************************************************************************/
+
+static u32 vrx218_a1plus_fw_code[] = {
+ 0x800001c0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x8000ffe0, 0x00000000, 0x00000000, 0x00000000,
+ 0xc1000002, 0xd90c00f8, 0x98c00ac0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x94000001, 0x00000000,
+ 0xc1020002, 0xd90c00f8, 0xc0004004, 0xcbc000f8, 0x98c01d20, 0x00000000, 0x5bfc0002, 0xcfc000f8,
+ 0x80007098, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x94000001, 0x00000000,
+ 0xc3e1fffe, 0x597dfffe, 0xc3e1fffe, 0x593dfff8, 0x90000201, 0x00000000, 0x00000000, 0x00000000,
+ 0x90cc0181, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0xc3c00000, 0xdbc800f9, 0xc1400008, 0xc1900000, 0x71588000, 0x14100100, 0xc140000a, 0xc1900002,
+ 0x71588000, 0x14100100, 0xc140000c, 0xc1900004, 0x71588000, 0x14100100, 0xc1400004, 0xc1900006,
+ 0x71588000, 0x14100100, 0xc1400006, 0xc1900008, 0x71588000, 0x14100100, 0xc140000e, 0xc190000a,
+ 0x71588000, 0x14100100, 0xc1400000, 0xc190000c, 0x71588000, 0x14100100, 0xc1400002, 0xc190000e,
+ 0x71588000, 0x14100100, 0xc0400000, 0xc11c0000, 0xc000e82c, 0xcd05ce00, 0xc11c0002, 0xc000e82c,
+ 0xcd05ce00, 0xc0400002, 0xc11c0000, 0xc000e82c, 0xcd05ce00, 0xc11c0002, 0xc000e82c, 0xcd05ce00,
+ 0xc000e824, 0x00000000, 0xcbc000f9, 0xcb8000f9, 0xcb4000f9, 0xcb0000f8, 0xc000abf8, 0x5bfc4000,
+ 0xcfc000f9, 0x5bb84000, 0xcf8000f9, 0x5b744000, 0xcf4000f9, 0x5b304000, 0xcf0000f8, 0xc000ea10,
+ 0x00000000, 0xcbc000f9, 0xcb8000f8, 0xc000abe0, 0x5bfc4000, 0xcfc000f9, 0x5bb84000, 0xcf8000f8,
+ 0xc30001fe, 0xc000f416, 0xcf0000f8, 0xc3000000, 0x7f018000, 0xc000e42e, 0xcf0000f8, 0xc3c1fffe,
+ 0xc000a28e, 0xcfc00078, 0xc000a2ac, 0xcfc00078, 0xc000a2a4, 0xcfc00038, 0xc000a292, 0xcfc00038,
+ 0xc000a2e6, 0xcfc00038, 0xc000a2e8, 0xcfc00078, 0xc000a2ea, 0xcfc00078, 0xc3c00000, 0xc2800020,
+ 0xc3000000, 0x7f018000, 0xc3600000, 0x6ff86000, 0x6fd42000, 0x4395c000, 0x5bb89800, 0x5838000a,
+ 0xcf0000f8, 0x5838000c, 0xcf4000f8, 0x5bfc0002, 0xb7e8ffb8, 0x00000000, 0xc3c00000, 0xc2800020,
+ 0xc348001a, 0xc3000000, 0x7f018000, 0x6ff88000, 0x6fd46000, 0x417ca000, 0x4395c000, 0x5bb80002,
+ 0x5bb87400, 0x58380004, 0xcf408418, 0xc1100004, 0xcd010810, 0x58380006, 0xcf0000f8, 0x5bfc0002,
+ 0xb7e8ff98, 0x00000000, 0x00000000, 0xc3c1fffe, 0xc000a3a6, 0xcfc000f8, 0xc3e12206, 0x5bfc0408,
+ 0xc0004002, 0xcfc000f8, 0xc0004024, 0xcbc000f8, 0x00000000, 0xc3800000, 0xc7fa0078, 0xc1000000,
+ 0xd90400f9, 0xdb840078, 0xc1000006, 0xd90400f9, 0xc000403c, 0xcf8000f8, 0xc3c04ac0, 0xc398002c,
+ 0xc3603ce0, 0x5b7414d8, 0x6f744010, 0x583c0004, 0xcf8000f8, 0x583c0006, 0xcf4000f8, 0x583c000c,
+ 0xcf8000f8, 0x583c000e, 0xcf4000f8, 0xc3990038, 0xc10046a0, 0x5d104000, 0x4391c000, 0xc3603ce0,
+ 0x5b7414e0, 0x6f744010, 0x583c0008, 0xcf8000f8, 0x583c000a, 0xcf4000f8, 0xc3990038, 0xc10046b0,
+ 0x5d104000, 0x4391c000, 0xc3603ce0, 0x5b7414e0, 0x6f744010, 0x583c0010, 0xcf8000f8, 0x583c0012,
+ 0xcf4000f8, 0xc0214b4a, 0xc1000408, 0x70108000, 0xc000fb86, 0xcd0000f8, 0xc1000000, 0xc000fb84,
+ 0xcd000000, 0xc1000002, 0xc0004008, 0xcd0000f8, 0x00000000, 0xc121fffe, 0x5911fff8, 0x14100000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xc1000000, 0xc000a3c0,
+ 0xcd0000f8, 0xc0004040, 0xd28000f8, 0xc0004044, 0xc1000000, 0xcd0000f8, 0x98c08358, 0xc0004030,
+ 0xc84000f8, 0x00000000, 0x98c09090, 0xc3c04ac0, 0x583c0000, 0x4b800008, 0xc000fb80, 0x4b000010,
+ 0xc000fba0, 0x4ac00010, 0xc3800000, 0xc7384000, 0xc6f84100, 0x5d380000, 0x8400031a, 0xc1400000,
+ 0xc1800000, 0xc7140000, 0xc7182000, 0x7559a000, 0xc6d40000, 0xc6d82000, 0x75588000, 0xc000fb84,
+ 0x4bc00000, 0xc5340100, 0x7779a000, 0xc000fb82, 0x4a800000, 0x5d3c0002, 0x84000062, 0x5d280002,
+ 0x8400028a, 0x47788000, 0x84000278, 0xc1000002, 0xc000fb84, 0xcd000000, 0xc1000000, 0xc0004008,
+ 0xcd0000f8, 0x80000240, 0xc0004008, 0xc90000f8, 0x00000000, 0x00000000, 0x5d100002, 0x84000212,
+ 0x47788000, 0x84000018, 0x5d280002, 0x840001f0, 0xc0004024, 0x4a820078, 0xc1000002, 0xc0004008,
+ 0xcd0000f8, 0x6ea86000, 0xc1000000, 0xd90000f9, 0xda800078, 0xc1000004, 0xd90000f9, 0x80000190,
+ 0xc000ea28, 0x49400038, 0xc000ea2a, 0x49800038, 0x5d140000, 0x840000f0, 0x5d180000, 0x840000e0,
+ 0xc1404f30, 0x5814000a, 0xc98000f8, 0x58140008, 0x4a400008, 0x5d180000, 0x840000a8, 0x5d240006,
+ 0x84000098, 0xc1404f20, 0x5814000a, 0xc98000f8, 0x58140008, 0x4a000008, 0x5d180000, 0x84000060,
+ 0x5d200006, 0x84000050, 0xc000696e, 0xc94000f8, 0xc1000000, 0xc000fb84, 0xcd000000, 0x59540002,
+ 0xc000696e, 0xcd4000f8, 0x80000058, 0xc0004024, 0x4a820078, 0x00000000, 0x00000000, 0x6ea86000,
+ 0xc1000000, 0xd90000f9, 0xda800078, 0xc1000004, 0xd90000f9, 0x9cc00000, 0x00000000, 0x00000000,
+ 0x00000000, 0x98c07a08, 0xc0400000, 0xc000abc0, 0xc88400f8, 0x98c07a08, 0xc0400002, 0xc000abc0,
+ 0xc88400f8, 0xc0004a10, 0xd81c00f9, 0xc94000f8, 0xc0000000, 0xc3c00000, 0xa57e03b0, 0xc57c0078,
+ 0xcafc00f8, 0xddc000f9, 0xc94000f8, 0x583c0004, 0x49820078, 0xc3400000, 0xc6f40078, 0x4359a000,
+ 0xc0000000, 0xca7400f8, 0xc1800000, 0xc55a0018, 0x7a6c8000, 0xa53e033a, 0x00000000, 0xc1000002,
+ 0xc000a3c0, 0xcd0000f8, 0xc1c00000, 0xc55e8018, 0xc1400000, 0xc6566018, 0x755ca000, 0x4158a000,
+ 0x6d502000, 0x5b905fc0, 0x58380000, 0x49800078, 0x58380002, 0x49c00078, 0x6d686000, 0x5aa84060,
+ 0x419d8000, 0xc1800000, 0xc6580078, 0x583c000c, 0xc9c000f9, 0xc88000f8, 0x00000000, 0x59dc0002,
+ 0x40984000, 0xcc8000f8, 0x5c000002, 0xcdc000f8, 0x58280000, 0xc9c000f9, 0xc88000f8, 0x00000000,
+ 0x59dc0002, 0x40984000, 0xcc8000f8, 0x5c000002, 0xcdc000f8, 0xc0000000, 0xca3000f8, 0x98c01090,
+ 0xc0400000, 0xc0004026, 0x49c00078, 0x5d040000, 0x84000062, 0xc0004022, 0x49c00078, 0xc1bc0002,
+ 0x76d88000, 0xc65c00fa, 0xc59c1e02, 0x7e412000, 0xc65fff00, 0xc0000000, 0xcdf400f8, 0x80000080,
+ 0x98c01168, 0x00000000, 0x58300002, 0xc88000f8, 0x6d506000, 0x58105d00, 0x58000008, 0xc90000f8,
+ 0x00000000, 0x00000000, 0x59100002, 0xcd0000f8, 0xc0004044, 0xc1020002, 0xcd002100, 0xc000404c,
+ 0xc9c000f8, 0x58144d00, 0xc98000f8, 0xc1000000, 0xc5d10038, 0x4590c000, 0x88000062, 0xc0004a18,
+ 0xc98000f8, 0xc1c00002, 0x69d4e000, 0x75d88000, 0x84000030, 0x719cc000, 0xc0004a18, 0xcd8000f8,
+ 0xc000e400, 0xcdc000f8, 0x583c0004, 0x49420078, 0xc1800000, 0xc6da0138, 0x59540004, 0x45948000,
+ 0xc1000000, 0xc51400fe, 0xcd401078, 0x8000fc70, 0xddc000f9, 0x58000002, 0xc1004a12, 0x45008000,
+ 0x8800fc10, 0x80000230, 0x58144d00, 0xc88000f8, 0x459c8000, 0x88000028, 0xa63e0098, 0x58280008,
+ 0xc0400002, 0x80000040, 0xc0004026, 0x49c20078, 0xa63e0022, 0x5828000c, 0x449c8000, 0x88000052,
+ 0xc0400004, 0xc9c000f9, 0xc88000f8, 0x00000000, 0x59dc0002, 0x40984000, 0xcc8000f8, 0x5c000002,
+ 0xcdc000f8, 0x9cc00000, 0x00000000, 0x00000000, 0x00000000, 0x58340002, 0xc98000f8, 0xc1000002,
+ 0xc5241f00, 0xc0004022, 0x49c00078, 0xc07c0002, 0x76c48000, 0xc61c00fa, 0xc45c1e02, 0x7ec08000,
+ 0xc51fff00, 0x58300002, 0xcd8000f8, 0x5c000002, 0xce4000f8, 0x58340002, 0xcc8000f8, 0x5c000002,
+ 0xcdc000f8, 0xc0000000, 0x49fa0139, 0x49b80078, 0xc1000002, 0x69148000, 0xd9300078, 0x58144d00,
+ 0xc88000f8, 0x59980004, 0x45d88000, 0xc1000000, 0xc51800fe, 0x58880002, 0xcc8000f8, 0xc1000002,
+ 0xc000a3c0, 0xcd0000f8, 0xc0000000, 0x9cc00000, 0xcdb80078, 0x00000000, 0x5fb80002, 0xc3c05e00,
+ 0xc7c000f8, 0xcb8000f8, 0x583c0008, 0xcac000f8, 0xc3400000, 0xc7b40078, 0x5d340000, 0x84000b2a,
+ 0xc74000f8, 0xcb0000f8, 0xc000ec00, 0xde83e000, 0x4a400020, 0x583c001e, 0xca0000f8, 0x5d240004,
+ 0x8800006a, 0x583c0008, 0x4ac00078, 0x583c001c, 0xc90000f8, 0xa7be0022, 0x00000000, 0x45208000,
+ 0x8400002a, 0x98c01690, 0xc0400000, 0x58340000, 0x49400078, 0x583c001c, 0xca4000f8, 0x583c0002,
+ 0xcac000f8, 0x00000000, 0xc2800000, 0xc6eba010, 0x583c0014, 0xc80000f8, 0x5d280004, 0x84000050,
+ 0xa43e01e2, 0x00000000, 0x98c018f8, 0x597c0020, 0xc1800000, 0xc6d80078, 0xc0004044, 0xc1000002,
+ 0xcd000000, 0x5d280000, 0x84000190, 0xc1400000, 0xc1800000, 0xa7be0082, 0xc71a0038, 0xa7bc0168,
+ 0x4660e000, 0x459ce000, 0xc1000010, 0x451c8000, 0x88000140, 0xc1c00000, 0xc6dc0078, 0x6ddc2010,
+ 0x459ce000, 0xc1400008, 0x45d48000, 0xc5d400fc, 0x80000070, 0x4624e000, 0x6d882010, 0x45c88000,
+ 0x880000e2, 0xc0800000, 0xc6c80078, 0x6c882010, 0x45884000, 0xc1400008, 0x44948000, 0xc49400fc,
+ 0x5d140000, 0x8400009a, 0x6d542000, 0xc56c1060, 0xc1000004, 0xc52c1d10, 0x98c01cd0, 0x583c000e,
+ 0xc94000f8, 0xc1a16000, 0x583c0018, 0xc94000f8, 0x583c0002, 0xcec000f8, 0x59540002, 0x583c0018,
+ 0xcd4000f8, 0xc0004044, 0xc1000002, 0xcd000000, 0x5bfc0040, 0x5d3c5f7e, 0x8800fcd2, 0x88000828,
+ 0xc6d40078, 0xc6da0060, 0xc71e0138, 0x4158a000, 0x45d48000, 0x7954a006, 0x6d902010, 0x42110000,
+ 0x583c001e, 0xce0000f8, 0xc56c0078, 0xc1800000, 0xc5ac1060, 0xc2800000, 0x9cc00000, 0xc6ac1d10,
+ 0x583c0008, 0xcec000f8, 0x583c000e, 0xca8000f8, 0xc1000000, 0xc7120138, 0x4150c000, 0x452c8000,
+ 0x7aed6006, 0x583c0002, 0x48000078, 0xa7be0022, 0xc6d00078, 0x45008000, 0x4140c006, 0xc000ec04,
+ 0xde83e000, 0xce8000f8, 0xc100c000, 0xc6904050, 0xc52800f8, 0xdeabeb00, 0xc0000000, 0x416ca000,
+ 0xc9d400f9, 0xc89400f9, 0x42ad4000, 0x79f08000, 0x79388000, 0xa53e0168, 0x00000000, 0x5aec0004,
+ 0x58440002, 0x5a200002, 0x58280002, 0xc0004a0e, 0x49000000, 0x00000000, 0x58280002, 0x5d100000,
+ 0x840000aa, 0xc1204000, 0x44904000, 0xa7be0022, 0x00000000, 0x7f808000, 0x80000040, 0xc1000008,
+ 0xc51c1710, 0xc1000000, 0xc5d00078, 0x5d100008, 0xc51c0078, 0xc79000f8, 0xc51e1f00, 0xc100000e,
+ 0xc51c1c10, 0x80000020, 0x00000000, 0x00000000, 0x00000000, 0xcc8000f8, 0x58280000, 0xcdc000f8,
+ 0x45588000, 0x88000048, 0x5aa80004, 0x5e640004, 0x5d240004, 0x8800002a, 0xc0000000, 0xc9d400f9,
+ 0xc89400f9, 0x8000fe90, 0x583c001e, 0x9cc00000, 0xce0000f8, 0x583c0008, 0xcec00078, 0xc1000000,
+ 0xc7100078, 0x4190c000, 0xc1c00000, 0xc6de0060, 0xc0400000, 0xc0000000, 0x445c8000, 0x88000128,
+ 0xc89400f9, 0xc91400f9, 0x00000000, 0x00000000, 0x5d100000, 0x840000fa, 0x78b80000, 0xc0800000,
+ 0xc78a1f00, 0x78080000, 0xa43e00d2, 0x00000000, 0xc0004a0e, 0x48801f00, 0xc0000000, 0x00000000,
+ 0xc483fd00, 0x41008000, 0xc0000000, 0x5d540004, 0xc89400f8, 0x59540004, 0x59980002, 0xcd1800f8,
+ 0x5d980002, 0xc71000f8, 0xa7be0028, 0x00000000, 0xc1000000, 0xc5081710, 0x7f008000, 0xc50bff00,
+ 0xcc9800f9, 0x59980002, 0x58440004, 0x8000fed0, 0x5d040000, 0x84000078, 0xc1000000, 0xc5381e00,
+ 0x583c0000, 0xcd001e00, 0xc0800000, 0xc78ac018, 0xc0000000, 0xc7824018, 0x58880002, 0x44088000,
+ 0xc40800fc, 0x583c0000, 0xcc801618, 0x80000150, 0x6c502010, 0x42512000, 0x583c001c, 0xce4000f8,
+ 0xc1400000, 0xc6d40078, 0x4144a000, 0xc0800000, 0xc70a0138, 0x44948000, 0x4548a006, 0xc56c0078,
+ 0xa7be004a, 0x58340008, 0xc88000f8, 0x6c502010, 0x00000000, 0x40904000, 0x58340008, 0xcc8000f8,
+ 0x80000040, 0x5834000c, 0xc88000f8, 0x6c502010, 0x00000000, 0x40904000, 0x5834000c, 0xcc8000f8,
+ 0xc0800000, 0xc78ac018, 0x6c882010, 0xc1000002, 0x70904000, 0x583c0000, 0xcc801618, 0xc0800002,
+ 0x5d040010, 0x78884004, 0xc4b81e00, 0x583c0000, 0xcc801e00, 0xc1000000, 0xc52c1060, 0xc2800000,
+ 0xc6ac1d10, 0x583c0002, 0xcec000f8, 0xc121e000, 0x59100080, 0x583c0014, 0xcd0000f8, 0x583c0020,
+ 0xc1000000, 0xcd0000f9, 0xcd0000f9, 0xcd0000f9, 0xcd0000f9, 0xcd0000f9, 0x9cc00000, 0xcd0000f9,
+ 0xcd0000f9, 0xcd0000f9, 0xc6da0260, 0xc0800000, 0xc6c80278, 0x4148e000, 0x583c0006, 0xcdc000f8,
+ 0x9cc00000, 0x583c0004, 0xcd8000f8, 0x00000000, 0xc1405e00, 0xc54000f8, 0xc98000f8, 0xc0800000,
+ 0xc1c00000, 0xc5880078, 0x5d080000, 0x840000aa, 0xc0800000, 0xc59f4018, 0xc58ac018, 0x449c8000,
+ 0xc49c00fc, 0xc1000002, 0x451c8000, 0x8800003a, 0x58140000, 0xcc801a18, 0x58140000, 0xc13c0002,
+ 0xcd03de00, 0x80000020, 0x5ddc0002, 0x58140000, 0xcdc01a18, 0x59540040, 0x5d145f7e, 0x8800ff32,
+ 0x9cc00000, 0x00000000, 0x00000000, 0x00000000, 0xc3c04f20, 0xc7c000f8, 0xcb8000f8, 0x583c0006,
+ 0x4b420038, 0x4b010038, 0x583c0002, 0x4ac10038, 0x583c0002, 0x4a820078, 0x47708000, 0x84000112,
+ 0xc0004044, 0xc10a0002, 0xcd00a500, 0x42ad4000, 0x58280006, 0xca4000f8, 0xc2000000, 0xc1400000,
+ 0xc6558018, 0xc6620078, 0x5d140004, 0x88000030, 0x98c01fa8, 0x58200000, 0x49400078, 0x49820078,
+ 0x80000008, 0x583c0000, 0x49420038, 0x5b740002, 0xc10001fe, 0x7751a000, 0x5aec000c, 0x456c8000,
+ 0x7aed6006, 0x583c0006, 0xcf401038, 0x583c0002, 0xcec00838, 0x583c0002, 0x4a820078, 0x47708000,
+ 0x8400ff00, 0x5bfc0010, 0x5d3c4f40, 0x8800fe92, 0x80000160, 0xc0000000, 0xc9d400f8, 0xd9641079,
+ 0xd9a81079, 0x5818000e, 0xc88000f8, 0xc1000000, 0xc5d00078, 0x40904000, 0x5818000e, 0xcc8000f8,
+ 0xc5d3ff00, 0x7d008000, 0x58140000, 0xcd03ff00, 0x58200002, 0x49400078, 0x49820079, 0xd24000f8,
+ 0xc0000000, 0xc9d77b20, 0xc1000000, 0x00000000, 0xc5d2e008, 0xc51c1710, 0xd9640079, 0xd9a80079,
+ 0x5818000a, 0xc88000f8, 0xc1000000, 0xc5d00078, 0x40904000, 0x5818000a, 0xcc8000f8, 0xc5d3ff00,
+ 0x7d008000, 0xc51fff00, 0x58140000, 0xcdc000f8, 0x9cc00000, 0x00000000, 0x00000000, 0x00000000,
+ 0xc3c04a14, 0xc0404f20, 0x58040006, 0x49400038, 0x49820038, 0x5804000a, 0xc90000f8, 0x58040000,
+ 0x49c30028, 0x4150a000, 0x45584000, 0xc10001fe, 0x74904000, 0x45c9c000, 0xdb9c00f9, 0xc000ec00,
+ 0xde83e000, 0x48000020, 0x5d380004, 0x88000182, 0x5d00000c, 0x88000172, 0xc7c000f8, 0x4b420078,
+ 0x4b000078, 0x00000000, 0x5d340000, 0x84000142, 0x98c07248, 0xc0400000, 0x5834000c, 0xc94000f8,
+ 0x5d040000, 0x840000fa, 0x98c072f8, 0xc0400000, 0x5830000c, 0xc94000f8, 0x5d040000, 0x840000ca,
+ 0x98c073d8, 0xc1780000, 0x59544f20, 0x00000000, 0x98c07790, 0xc1404f20, 0x58140000, 0x49820038,
+ 0x98c076b0, 0x58340004, 0x49820078, 0x58340000, 0xc0004044, 0xc1080002, 0xcd008400, 0x5fb80002,
+ 0xc000ec00, 0xde83e000, 0x48000020, 0x5d380004, 0x8800003a, 0x5d00000c, 0x8800002a, 0x8000fee8,
+ 0x5bfc0002, 0x5d3c4a18, 0x8800fe6a, 0x98c07890, 0xc0603ce0, 0x58441300, 0xc1404f20, 0x80000278,
+ 0x58140002, 0x49c00038, 0x583c000c, 0xc88000f8, 0xd9f800f8, 0x419cc000, 0xc000ec04, 0xde83e000,
+ 0xc1203c14, 0x59104000, 0xcd0000f8, 0xde9beb00, 0x583c000a, 0xc9c000f8, 0x58880008, 0x58180008,
+ 0xcc8000f8, 0x59dc0008, 0x58180004, 0xcdc000f8, 0x583c0008, 0x48420260, 0xc0980006, 0xc7c81078,
+ 0x58140000, 0xc883c000, 0x5c440008, 0x58180002, 0xcc4000f8, 0x58140002, 0x48420078, 0xdf9c00f8,
+ 0xc58000f8, 0xcc8000f8, 0x583c0008, 0xc8820038, 0x9cc00000, 0x405c2000, 0x58040006, 0xcc8000f8,
+ 0x58140002, 0x49c00038, 0x583c000c, 0xc88000f8, 0xd9f800f8, 0x419cc000, 0xc000ec04, 0xde83e000,
+ 0xc1203c14, 0x59104000, 0xcd0000f8, 0xde9beb00, 0x583c000a, 0xc9c000f8, 0x58180008, 0xcc8000f8,
+ 0x58180004, 0xcdc000f8, 0x58180002, 0xc1000008, 0xcd0000f8, 0xc0980004, 0xc7c81078, 0x58140000,
+ 0xc883c000, 0x58140002, 0x48420078, 0xdf9c00f8, 0xc58000f8, 0xcc8000f8, 0xc58000f8, 0xcc8000f8,
+ 0x583c0008, 0xc8820038, 0x9cc00000, 0x405c2000, 0x58040006, 0xcc8000f8, 0xc3c04680, 0xc000a2f4,
+ 0xc98000f8, 0xdf140078, 0x7d40a000, 0xc101fffe, 0x7d80c000, 0x7558a000, 0x7550a000, 0x8400035a,
+ 0x6140c028, 0x43d9e000, 0x00000000, 0xd97800f8, 0xc0404f30, 0x58040006, 0x49400038, 0x49820038,
+ 0x5804000a, 0xc90000f8, 0x58040000, 0x49c30028, 0x4150a000, 0x45584000, 0xc10001fe, 0x74904000,
+ 0x45c9c000, 0xdb9c00f9, 0xc000ec00, 0xde83e000, 0x48000020, 0x5d380004, 0x880002a2, 0x5d00000c,
+ 0x88000292, 0xc0004008, 0xc90000f8, 0xc7c000f8, 0x4b420078, 0x5d100002, 0x84000262, 0x4b000078,
+ 0x5d340000, 0x8400024a, 0x98c07248, 0xc0400000, 0x5834000c, 0xc94000f8, 0x5d040000, 0x840001c2,
+ 0x98c072f8, 0xc0400000, 0x5830000c, 0xc94000f8, 0x5d040000, 0x84000192, 0x98c073d8, 0xc1780002,
+ 0x59544f30, 0x00000000, 0x98c07790, 0xc1404f30, 0x58140000, 0x49820038, 0x98c076b0, 0x58340004,
+ 0x49820078, 0x58340000, 0xc0004044, 0xc1060002, 0xcd006300, 0x5d7c4680, 0x6d506000, 0x59105c00,
+ 0x58100008, 0xc98000f8, 0x5810000c, 0xc9c000f8, 0x58100000, 0x48020038, 0x459cc000, 0xc1c00002,
+ 0x4580c000, 0x79dce004, 0xc000a2f4, 0xc98000f8, 0x69d4e000, 0xc1000002, 0x69148000, 0x7d008000,
+ 0x7590c000, 0x719cc000, 0xcd8000f8, 0xc1200002, 0x69148000, 0xd93000f8, 0x5fb80002, 0xc000ec00,
+ 0xde83e000, 0x48000020, 0x5d380004, 0x8800007a, 0x5d00000c, 0x8800006a, 0x8000fe20, 0x00000000,
+ 0x00000000, 0x00000000, 0xdf9400f8, 0x6140c028, 0x84000032, 0x00000000, 0x00000000, 0x5bd84680,
+ 0xd97800f8, 0x8000fd48, 0x98c07890, 0xc0603ce0, 0x58441340, 0xc1404f30, 0x80000130, 0x58140002,
+ 0x49c00038, 0x583c0006, 0xc88000f8, 0xd9f800f8, 0x419cc000, 0xc000ec04, 0xde83e000, 0xc1203c14,
+ 0x59104000, 0xcd0000f8, 0xde9beb00, 0x583c0004, 0xc9c000f8, 0x58180008, 0xcc8000f8, 0x58180004,
+ 0xcdc000f8, 0x583c0002, 0x48420260, 0xc0980008, 0xc7c81078, 0x58140000, 0xc883c000, 0x58180002,
+ 0xcc4000f8, 0x58140002, 0x48420078, 0xdf9c00f8, 0xc58000f8, 0xcc8000f8, 0x583c0002, 0xc8820038,
+ 0x9cc00000, 0x405c2000, 0x58040006, 0xcc8000f8, 0x98c08358, 0xc0004030, 0xc84000f8, 0x00000000,
+ 0x98c09090, 0xc3c04ac0, 0x583c0000, 0x4b800008, 0xc0004008, 0xc90000f8, 0x00000000, 0x00000000,
+ 0x5d100002, 0x8400266a, 0xc000a2d8, 0xc84000f8, 0x00000000, 0xc3c00002, 0x787c2000, 0xcc4000f8,
+ 0xc000abc8, 0xcb8400f8, 0xc000abc4, 0xc88400f8, 0x5fb80000, 0x8400260a, 0xc000abfc, 0xc80400f8,
+ 0x00000000, 0x00000000, 0x40080000, 0xca0000f8, 0xc42400f8, 0x00000000, 0xa63c2492, 0x00000000,
+ 0xc000abf8, 0xc80400f8, 0x6c908000, 0x45088000, 0x45088000, 0x40100000, 0xca0000f8, 0xc42400f8,
+ 0x00000000, 0xc000a2b4, 0xce0000f8, 0xc2800002, 0xc4681c08, 0xc62821d0, 0xc2600010, 0x5a650d80,
+ 0xc0004020, 0xcb4000f8, 0xc2200400, 0x5a200d40, 0xc7601040, 0xc000f220, 0xce8000f8, 0xc000f200,
+ 0xce4000f8, 0xc000f202, 0xce0000f8, 0xc000f240, 0xcb4000f8, 0x00000000, 0x00000000, 0xa754ffe0,
+ 0xc2000000, 0xc7600040, 0xa7520042, 0x00000000, 0x00000000, 0x990079e8, 0xc0009de2, 0xc94000f8,
+ 0xc1800002, 0x80002338, 0x58204dc0, 0xc2000000, 0xca000018, 0xc2400000, 0xca414000, 0xc2800000,
+ 0xca812000, 0xc2c00000, 0xcac20018, 0xc000a2b8, 0xce0000f8, 0xc000a2a0, 0xce4000f8, 0xc000a296,
+ 0xce8000f8, 0xc000a2a2, 0xcec000f8, 0xa64005c0, 0x00000000, 0xc000a2b8, 0xcbc000f8, 0x00000000,
+ 0xc3800000, 0x6ff46000, 0x6fd42000, 0x4355a000, 0x5b749800, 0xc3800002, 0xc000a29a, 0xcf8000f8,
+ 0xc000402a, 0xca8000f8, 0xc2000002, 0x6a390000, 0x76a14000, 0x5ea80000, 0x84000502, 0xc34041d0,
+ 0xc74000f8, 0xcbf400f8, 0x58340008, 0xcac000f8, 0x5834000c, 0xca8000f8, 0x58340004, 0x4a400078,
+ 0xc2000000, 0xc7e20038, 0x46e88000, 0x45208000, 0x88000490, 0xc2800000, 0xc7e80078, 0x42a54000,
+ 0x5a640004, 0x6e202000, 0x46248000, 0xc1000000, 0xc52400fe, 0xc68000f8, 0xca0000f8, 0x00000000,
+ 0x00000000, 0x7be1e000, 0xa7fe0420, 0x5aec0002, 0x58340008, 0xcec000f8, 0x58340004, 0xce400078,
+ 0x58280002, 0xca4000f8, 0xc000a2b0, 0xce0000f8, 0xc000a2b2, 0xce4000f8, 0xc2000000, 0xdf610048,
+ 0x5e6001e8, 0x8800ffe8, 0xc2000002, 0xc2400466, 0xc2a00000, 0x5aa80000, 0xc000f006, 0xce0000f8,
+ 0xc000f008, 0xce4000f8, 0xc000f00a, 0xce8000f8, 0x990085d0, 0xc1a0fffe, 0xc000e824, 0xc9840070,
+ 0xc000a2b4, 0xca4000f8, 0xc2000000, 0xc2800002, 0x990086d8, 0xda9800f8, 0xc61400f8, 0xc65800f8,
+ 0xc000a2a2, 0xca001118, 0xc3c00000, 0xc3800000, 0xc000a2b0, 0xce023118, 0xc000a2b2, 0xcbc000e0,
+ 0xc2800000, 0xc000a29e, 0x6ffc4010, 0xcfc000f8, 0xc000a31e, 0xca800060, 0xc3a0001a, 0x5bb94000,
+ 0xc6b80060, 0xc000a29c, 0xcf8000f8, 0x990087c0, 0xc000a29c, 0xc1400000, 0xc9420048, 0x00000000,
+ 0x00000000, 0x00000000, 0xa8e2ffe8, 0xc2000000, 0xc1220002, 0xd90c00f8, 0xdf600038, 0x5e600020,
+ 0x8400fff2, 0xc000a29c, 0xca0000f8, 0xc000a29e, 0xca4000f8, 0x00000000, 0x00000000, 0x99008b38,
+ 0xda1800f8, 0xda5800f9, 0x00000000, 0xc000a296, 0xca8000f8, 0xc2c00000, 0xdfec0048, 0xc2400000,
+ 0x466d2000, 0x8400004a, 0x5ea80000, 0x8400003a, 0xc2600002, 0x990079e8, 0xc0009dee, 0xc94000f8,
+ 0xc1800002, 0x80000030, 0xc2600000, 0x990079e8, 0xc0009dec, 0xc94000f8, 0xc1800002, 0xc2000068,
+ 0xc6240078, 0xc000a2b0, 0xce400080, 0xc000a29a, 0xc98000f8, 0xc000a31e, 0xc94000f8, 0x59d89f00,
+ 0x99008848, 0xd95800f8, 0xd99800f9, 0xd9d400f8, 0x990087c0, 0xc000a29c, 0xc1400000, 0xc9420048,
+ 0xc2000000, 0xc2400020, 0xdf600038, 0xb624ffea, 0xc000a29c, 0xca4000f8, 0xc000a29e, 0xca8000f8,
+ 0x99008b38, 0xda5800f8, 0xda9800f9, 0x00000000, 0x80001d20, 0x00000000, 0x990079e8, 0xc0009dea,
+ 0xc94000f8, 0xc1800002, 0x80001cf0, 0xc000a2b8, 0xcbc000f8, 0x00000000, 0x00000000, 0x6ff86000,
+ 0x6fd42000, 0x4395c000, 0x5bb89800, 0x58380008, 0xca0000f8, 0x00000000, 0x00000000, 0xa600034a,
+ 0x00000000, 0xc000a2b8, 0xcbc000f8, 0xc3000000, 0x00000000, 0x6ff86000, 0x6fd42000, 0x4395c000,
+ 0x5bb89800, 0xc3000000, 0xc2000000, 0x58380008, 0xca020078, 0x5838000c, 0xcac000f8, 0x5838000e,
+ 0xca4000f8, 0xc000a29a, 0xcf0000f8, 0xc000a2b0, 0xcec000f8, 0xc000a2bc, 0xce0000f8, 0xc000a2b2,
+ 0xce4000f8, 0x58380008, 0xc98000f8, 0x5e200000, 0x840001d0, 0xc2800000, 0xa58e0030, 0xc1000000,
+ 0x00000000, 0x00000000, 0xcd00e700, 0x80000140, 0xc28041c0, 0xc68000f8, 0xcae800f8, 0x58280008,
+ 0xca4000f8, 0x5828000c, 0xca0000f8, 0x58280004, 0x49800078, 0xc1c00000, 0xc6de0038, 0x46608000,
+ 0x451c8000, 0x88000160, 0xc2000000, 0xc6e00078, 0x42190000, 0x59980004, 0x6ddc2000, 0x45d88000,
+ 0xc1000000, 0xc51800fe, 0xc60000f8, 0xc9c000f8, 0x00000000, 0x00000000, 0x7add6000, 0xa6fe00f0,
+ 0x5a640002, 0x58280008, 0xce4000f8, 0x58280004, 0xcd800078, 0x58200002, 0xc98000f8, 0xc000a2b0,
+ 0xcdc000f8, 0xc000a2b2, 0xcd8000f8, 0xc000a2b0, 0xcac000f8, 0xc000a2b2, 0xca4000f8, 0xc7ec1118,
+ 0xc000a2b0, 0xcec000f8, 0x5838000c, 0xcec000f8, 0x58000002, 0xce4000f8, 0xc000a2b4, 0xca0000f8,
+ 0xc2400002, 0x6e642000, 0x76612000, 0x80000060, 0x00000000, 0xc0009de4, 0xca0000f8, 0xc2400002,
+ 0x6e640000, 0x5a200002, 0xce0000f8, 0x58380008, 0xce400000, 0x80000018, 0x00000000, 0x80000048,
+ 0xc000a2b4, 0xca0000f8, 0x00000000, 0x00000000, 0xa60218da, 0x00000000, 0x00000000, 0x80001908,
+ 0xc000a2bc, 0xca0000f8, 0x00000000, 0x00000000, 0x5e200000, 0x84000500, 0xc2000000, 0x58380000,
+ 0xca010000, 0xc000abf8, 0xc80400f8, 0x6c908000, 0x45088000, 0x45088000, 0x40100000, 0xc90000f8,
+ 0xc43400f8, 0x00000000, 0x58340004, 0xc9c000f8, 0xc1800000, 0xc000a380, 0xcd8000f8, 0x58380008,
+ 0xc5900400, 0xcd008400, 0xc3000000, 0x5e200000, 0x84000282, 0xc2215554, 0x5a200600, 0x45e08000,
+ 0x84000212, 0x58340006, 0xc9c000f8, 0x00000000, 0x00000000, 0x6dda0010, 0x5d180042, 0x8400004a,
+ 0x5d1800ae, 0x84000052, 0xc2400014, 0xc3000000, 0xc2c0001e, 0xc2800000, 0x597c0080, 0x800000d8,
+ 0xc2400004, 0xc3001000, 0x8000ffd0, 0xc240000c, 0xc3010dba, 0x8000ffb8, 0xc1800000, 0xc2400000,
+ 0xc5d80078, 0x5d180002, 0xc1000002, 0xc52400fa, 0xc1800000, 0x58380000, 0xc9818000, 0xc2800004,
+ 0xc2c00018, 0x5d980000, 0xc1000016, 0xc52c00fa, 0x80000030, 0xc3000000, 0x597c0180, 0xc2c0001e,
+ 0xc2800004, 0xc2400006, 0xc000a382, 0xce8000f8, 0xc000a384, 0xce4000f8, 0xc000a38e, 0xcf0000f8,
+ 0xc000a390, 0xcd4000f8, 0x5dac0002, 0x5d280000, 0xc1000002, 0x4190c002, 0xc000a386, 0xcd8000f8,
+ 0x58380008, 0xc6900808, 0xcd010808, 0x58380008, 0xc6500508, 0xcd00a508, 0x58380008, 0xc6d00a20,
+ 0xcd014a20, 0x80000218, 0x58340006, 0xc9c000f8, 0x00000000, 0x00000000, 0x6dda0010, 0x5d190184,
+ 0x8400fe72, 0x00000000, 0x00000000, 0x8000fed0, 0xc2000000, 0x58380000, 0xca014008, 0x00000000,
+ 0x00000000, 0x5d200004, 0x8800007a, 0x5d200006, 0x8400014a, 0xc1800000, 0x6dda0010, 0x5d180042,
+ 0x840000e2, 0x00000000, 0x5d1800ae, 0x840000fa, 0x00000000, 0x00000000, 0x5a600010, 0xc3000000,
+ 0x800000b0, 0xc62400f8, 0xc1800000, 0x58380000, 0xc9818000, 0xc2800004, 0xc2c0001c, 0x5d980000,
+ 0xc100001a, 0xc52c00fa, 0x8000fe00, 0xc62400f8, 0xc3001000, 0xc2c00022, 0xc2800004, 0x597c0100,
+ 0x8000fdd0, 0x5a600008, 0xc3010dba, 0x8000ffd0, 0xc62400f8, 0xc3001000, 0xc2c00020, 0xc2800000,
+ 0x597c0000, 0x8000fd88, 0x5a600008, 0xc3010dba, 0x8000ffd0, 0xc1800000, 0xc5db8018, 0x5d180008,
+ 0x8400ff5a, 0x00000000, 0x00000000, 0x8000ff70, 0x00000000, 0xc2800000, 0xc2000080, 0xc240001a,
+ 0xdf690048, 0x46294000, 0x46a54000, 0x8800faaa, 0xc2000006, 0xc2600982, 0x5a643b6e, 0x5838000a,
+ 0xca8000f8, 0xc000f006, 0xce0000f8, 0xc000f008, 0xce4000f8, 0xc000f00a, 0xce8000f8, 0xc000a2bc,
+ 0xca0000f8, 0x00000000, 0x00000000, 0x5e200000, 0x8400010a, 0x00000000, 0xc1000000, 0xc000a38a,
+ 0xcd0000f8, 0x990085d0, 0xc1a0fffe, 0xc000e824, 0xc9840070, 0xc2000000, 0x58380008, 0xca010008,
+ 0xc1c00000, 0x58380008, 0xc9c14020, 0x00000000, 0x00000000, 0x5ddc0002, 0x5d200000, 0xc1000002,
+ 0x41d0e002, 0xc000a386, 0xcdc000f8, 0x58380012, 0xca4000f8, 0x00000000, 0xc2800000, 0x990086d8,
+ 0xda9800f8, 0xc61400f8, 0xc65800f8, 0x800000b0, 0x00000000, 0xc1000002, 0xc000a38a, 0xcd0000f8,
+ 0x99008610, 0xc1a0fffe, 0xc000e824, 0xc9840070, 0xc000a386, 0xca4000f8, 0xc000a382, 0xca8000f8,
+ 0x5d240014, 0x6d204000, 0x42290000, 0xc2400000, 0xc2800000, 0x99008650, 0xda9800f8, 0xc61400f8,
+ 0xc65800f8, 0xc000a2b4, 0xca0000f8, 0x00000000, 0x00000000, 0xa6020022, 0x00000000, 0x00000000,
+ 0x80000358, 0xc000a2b8, 0xcbc000f8, 0xc000abf8, 0xc80400f8, 0x6c908000, 0x45088000, 0x45088000,
+ 0x40100000, 0xca0000f8, 0xc42400f8, 0x00000000, 0x58240018, 0xca0000f8, 0x6ff86000, 0x6fd42000,
+ 0x4395c000, 0x5bb89800, 0xc3000000, 0xc3400002, 0xc2c00000, 0xc62c0078, 0xc2400000, 0x58380008,
+ 0xca410008, 0xc000a386, 0xca0000f8, 0x42e4e000, 0x00000000, 0x5d200014, 0x6d104000, 0x41d0e000,
+ 0x5ddc0010, 0xc000a38c, 0xcdc000f8, 0xc6270038, 0xc000a2c0, 0xce400038, 0xc6260038, 0xc000a2c2,
+ 0xce400038, 0xc000a2bc, 0xca0000f8, 0x5ddc0000, 0x84000162, 0x5a5c0010, 0x46254000, 0x88000168,
+ 0x5a600076, 0x45e54000, 0x88000150, 0x58380006, 0xca8000f8, 0xc000a2c0, 0xca0000f8, 0xc2400000,
+ 0xc6a70038, 0x7e412000, 0x76612000, 0xc2000000, 0xc6a10038, 0x46250000, 0x84000110, 0xc000a2c2,
+ 0xca0000f8, 0xc2400000, 0xc6a60038, 0x7e412000, 0x76612000, 0xc2000000, 0xc6a00038, 0x58380002,
+ 0xca8000f8, 0x46250000, 0x840000c0, 0xc2400000, 0xc6a60078, 0x465d0000, 0x880000b2, 0xc2400000,
+ 0xc6a40078, 0x58380008, 0xca8000f8, 0x45e50000, 0x88000092, 0x00000000, 0x00000000, 0x80000080,
+ 0xc7700200, 0xc000a2bc, 0xcac000f8, 0x80000060, 0xc7700300, 0xc000a2bc, 0xcac000f8, 0x80000040,
+ 0xc7700900, 0x80000030, 0xc7700800, 0x80000020, 0xc7700700, 0x80000010, 0xc7700500, 0xc000a2c4,
+ 0xcf0000f8, 0xc000a2be, 0xcec000f8, 0xc000a2b8, 0xca4000f8, 0xc000a2bc, 0xcb8000f8, 0xc000a2be,
+ 0xcb4000f8, 0xc3000000, 0x6e606000, 0x6e542000, 0x42150000, 0x5a209800, 0x59e00000, 0x5aa00008,
+ 0x58200004, 0xcb000078, 0xc2400000, 0x58200008, 0xca410008, 0xc000a2b4, 0xca0000f8, 0xc000a386,
+ 0xc90000f8, 0xc3c00018, 0x5fb80000, 0x00000000, 0xc53c00fa, 0xa6020210, 0x00000000, 0xc1000000,
+ 0x581c0008, 0xc9008000, 0x00000000, 0x00000000, 0x5d100000, 0x84000130, 0xc000a386, 0xc90000f8,
+ 0x43656000, 0x00000000, 0x5d100014, 0x6d104000, 0x42d16000, 0x5eec0010, 0xc1000000, 0x581c0008,
+ 0xc900a008, 0x00000000, 0xc3c00002, 0x5d100002, 0xc1000000, 0xc53c00fa, 0x6fd04000, 0x412c8000,
+ 0x5d100008, 0xc000a388, 0xcd0000f8, 0x47ad0000, 0x88000050, 0x46f96000, 0x6ee04010, 0x43e1e000,
+ 0xc2000000, 0xc6e00008, 0x5e200000, 0x840000e2, 0x5bfc0002, 0x800000d0, 0x5a2c0008, 0x47a10000,
+ 0x880000ba, 0x5fb80008, 0x800000a8, 0x43656000, 0x592c0008, 0xc000a388, 0xcd0000f8, 0x47ad0000,
+ 0x88000050, 0x46f96000, 0x6ee04010, 0x5be00004, 0xc2000000, 0xc6e00008, 0x5e200000, 0x84000042,
+ 0x5bfc0002, 0x80000030, 0xc3c00004, 0x5a2c0008, 0x47a10000, 0x88000012, 0x5fb80008, 0x6fe04000,
+ 0x42390000, 0x47212000, 0x88000068, 0xc2400000, 0xc000a2b0, 0xca42e008, 0xc2060002, 0xc68000f8,
+ 0xce006300, 0x6fe04000, 0x4721c000, 0x5f700010, 0x4765a000, 0xc2000000, 0xc6340008, 0xc25a000a,
+ 0xc000a29a, 0xca401c18, 0xc2800000, 0xc000a2b2, 0xca8000e0, 0xc000a31e, 0xca400060, 0x43a90000,
+ 0x6e204010, 0xc000a29e, 0xce0000f8, 0xc7e41048, 0xc000a29c, 0xce4000f8, 0x6fe04000, 0x43a1c000,
+ 0xc000a2bc, 0xcf8000f8, 0xc000a2ba, 0xcfc000f8, 0x80000008, 0x00000000, 0x00000000, 0x00000000,
+ 0xc2000000, 0xdce000f8, 0xa622ffd8, 0xc1220002, 0xd90c00f8, 0xc000a38a, 0xca0000f8, 0x00000000,
+ 0x00000000, 0x5d200002, 0x840002a0, 0xc000a2b8, 0xcbc000f8, 0xc000a380, 0xcb0000f8, 0x6ff86000,
+ 0x6fd42000, 0x4395c000, 0x5bb89800, 0xc000a384, 0xcac000f8, 0xc340a320, 0x00000000, 0x5d2c0004,
+ 0x880000b2, 0x58340006, 0xc1000000, 0xcd0000f9, 0xcd0000f9, 0xc000a390, 0xc98000f8, 0xc000a38e,
+ 0xc9c000f8, 0x5834000a, 0xcd8000f8, 0xc2400000, 0xc100000c, 0xc5241810, 0xc1000002, 0xc5240000,
+ 0x5ddc0000, 0x840000da, 0x5834000c, 0xc5d01078, 0xcd021078, 0x800000b8, 0x58380000, 0xc98000f8,
+ 0xc2400000, 0xc100000e, 0xc5241810, 0xc1000000, 0xc5240000, 0xa5980078, 0x58340008, 0x00000000,
+ 0xc94000f9, 0xc90000f9, 0xc8c000f8, 0x58340006, 0x00000000, 0xcd4000f9, 0xcd0000f9, 0xccc000f8,
+ 0xc1610200, 0xc5960078, 0x5834000c, 0xcd4000f8, 0x58340004, 0xc1000004, 0xc5241008, 0xc7e40818,
+ 0xce4000f8, 0xc2c00000, 0x58380008, 0xcac14020, 0xc000a31e, 0xc90000f8, 0xc000a320, 0x5b400004,
+ 0xc000ab40, 0x40118000, 0x5eac0002, 0xc0000000, 0xca7400f9, 0x00000000, 0x00000000, 0xce7000f9,
+ 0x5d30abc0, 0xc1000080, 0x47118002, 0x5ea80002, 0x8800ffc0, 0x00000000, 0xc000a2b8, 0xcbc000f8,
+ 0xc000a2c4, 0xcb4000f8, 0xc000a31e, 0xcb0000f8, 0xc000a2b4, 0xca0000f8, 0x6ff86000, 0x6fd42000,
+ 0x4395c000, 0x5bb89800, 0xa6020308, 0xc2400000, 0x58380008, 0xca406000, 0xdfe800f8, 0xc2218e08,
+ 0x5a21baf6, 0x46a14000, 0x84000022, 0xc2080002, 0x7361a000, 0x80000058, 0x5e640000, 0x84000022,
+ 0xc20c0002, 0x7361a000, 0x80000030, 0xc2000000, 0xc760e710, 0xc7604218, 0x5e200000, 0x84000372,
+ 0xc2200002, 0xc000a2b0, 0xce021000, 0x990079e8, 0xc0009de8, 0xc94000f8, 0xc1800002, 0x800001e0,
+ 0xc1000000, 0x58380008, 0xc9008000, 0x00000000, 0x00000000, 0x5d100000, 0x84000078, 0xc000a388,
+ 0xc9c000f8, 0xc2400000, 0x5838000c, 0xce4000f8, 0x5e5c0004, 0x990079e8, 0xc0009df0, 0xc94000f8,
+ 0xc65800f8, 0xc000a2b0, 0xc5d00078, 0xcd000078, 0x80000248, 0xc000a2c0, 0xca8000f8, 0xc000a2c2,
+ 0xca4000f8, 0xc7600078, 0xc6a01838, 0xc6601038, 0xc000a2ba, 0xca4000f8, 0xc000a2b4, 0xca8000f8,
+ 0xc000ab40, 0x40300000, 0x40240000, 0x5c000004, 0x5ec0abc0, 0x88000012, 0x5c000080, 0xce0000f8,
+ 0x58000002, 0x5ec0abc0, 0x88000012, 0x5c000080, 0xce8000f8, 0xc000a388, 0xca0000f8, 0xc2400000,
+ 0x5838000c, 0xce4000f8, 0x5e600004, 0x990079e8, 0xc0009df0, 0xc94000f8, 0xc65800f8, 0xc000a2b0,
+ 0xc6100078, 0xcd000078, 0x80000118, 0xc2400002, 0x58380008, 0xce400000, 0xc24e0002, 0xce40e700,
+ 0xc000a2c4, 0xcf4000f8, 0x80000328, 0xc000a2bc, 0xca4000f8, 0xdfe800f8, 0xc000a38a, 0xc98000f8,
+ 0xc000a386, 0xc90000f8, 0xc1c00018, 0x5d980002, 0x00000000, 0xc51c00fa, 0x431d0000, 0xc1000080,
+ 0x4520c000, 0x00000000, 0x46110006, 0xc000ab40, 0x40200000, 0xca0000f8, 0x58380008, 0xc6501078,
+ 0xcd021078, 0x5838000a, 0xce8000f8, 0x58380012, 0xce0000f8, 0xc000a2c4, 0xcf4000f8, 0x990087c0,
+ 0xc000a29c, 0xc1400000, 0xc9420048, 0x80000098, 0x00000000, 0x990079e8, 0xc0009de6, 0xc94000f8,
+ 0xc1800002, 0xc000a388, 0xca8000f8, 0x6fec2000, 0x5aec9e00, 0x990079e8, 0x582c0000, 0xc94000f8,
+ 0xc1800002, 0x990079e8, 0x582c0002, 0xc94000f8, 0xc69800f8, 0x8000fc58, 0xc2000000, 0xc2400020,
+ 0xdf600038, 0xb624ffea, 0xc000a29c, 0xca4000f8, 0xc000a29e, 0xca8000f8, 0x99008b38, 0xda5800f8,
+ 0xda9800f9, 0x00000000, 0xc000a2b4, 0xca0000f8, 0x00000000, 0xc2800000, 0xa6020150, 0xc2400004,
+ 0xc2000080, 0xdf690048, 0x46294000, 0x46a54000, 0x8800ffda, 0x00000000, 0xc000a29a, 0xc98000f8,
+ 0xc000a31e, 0xc94000f8, 0x59d89f00, 0x99008848, 0xd95800f8, 0xd99800f9, 0xd9d400f8, 0x990087c0,
+ 0xc000a29c, 0xc1400000, 0xc9420048, 0xc2000000, 0xc2400020, 0xdf600038, 0xb624ffea, 0xc000a29c,
+ 0xca4000f8, 0xc000a29e, 0xca8000f8, 0x99008b38, 0xda5800f8, 0xda9800f9, 0x00000000, 0x58380008,
+ 0xca4000f8, 0xc2000000, 0xce000018, 0xc2a1fffe, 0x5aa9fffe, 0xce021078, 0x5838000a, 0xce8000f8,
+ 0xc1000002, 0xc000a3c0, 0xcd0000f8, 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000, 0xc000e838,
+ 0xc2500002, 0xce450800, 0xc000abc8, 0xcb8400f8, 0xc2000000, 0xc000e82c, 0xca040038, 0x5fb80002,
+ 0xc000abc8, 0xcf8400f8, 0x58880002, 0xb6080018, 0x00000000, 0xc0800000, 0xc000abc4, 0xcc8400f8,
+ 0x00000000, 0xc121fffe, 0x5911fff8, 0x14100000, 0x80000050, 0x00000000, 0x98c08358, 0xc0004030,
+ 0xc84000f8, 0x00000000, 0x98c09090, 0xc3c04ac0, 0x583c0000, 0x4b800008, 0xc2000000, 0xdf600038,
+ 0x5e200020, 0x8400054a, 0x00000000, 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000, 0xc000a28e,
+ 0xca0000f8, 0xc000a3a6, 0xca4000f8, 0xc000a2ea, 0xcb0000f8, 0xc000a2d6, 0xcac000f8, 0x00000000,
+ 0xc121fffe, 0x5911fff8, 0x14100000, 0x77218000, 0x77258000, 0xc2c00000, 0xc2400000, 0x6ef48000,
+ 0x6ed46000, 0x416ca000, 0x4355a000, 0x5b740002, 0x5b747400, 0x5834002e, 0x6ee06000, 0x5a205c00,
+ 0xc60000f8, 0xc98000f8, 0x58200004, 0x4a820078, 0xc1c00000, 0xc59c0078, 0xc1000000, 0xc5920038,
+ 0x5d100000, 0x84000072, 0x41e80000, 0xcbc000f9, 0xcb8000f8, 0x00000000, 0x79bc8000, 0xa53e0042,
+ 0xc1000002, 0x692c8000, 0x72512000, 0x58340008, 0x00000000, 0xcfc000f9, 0xcf8000f8, 0x5aec0002,
+ 0x5d2c0020, 0x8800fef2, 0x77258000, 0x8400037a, 0x63016008, 0xc000a2d6, 0xcec000f8, 0x6ef48000,
+ 0x6ed46000, 0x416ca000, 0x4355a000, 0x5b740002, 0x5b747400, 0x58340000, 0xc9c000f8, 0xc2400000,
+ 0x5c340002, 0xca400078, 0xc000a3a6, 0xca0000f8, 0xc3000000, 0xc5f04018, 0x7e412000, 0x76250000,
+ 0xce0000f8, 0xc000a360, 0x40300000, 0xcec000f8, 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000,
+ 0xc000a2ea, 0xca4000f8, 0xc2000002, 0x6a2d0000, 0x7e010000, 0x76612000, 0xce4000f8, 0x00000000,
+ 0xc121fffe, 0x5911fff8, 0x14100000, 0x6ef48000, 0x6ed46000, 0x416ca000, 0x4355a000, 0x5b740002,
+ 0x5b747400, 0x58340008, 0xca0000f8, 0x00000000, 0x00000000, 0xa63400ca, 0x00000000, 0xc1000000,
+ 0xa6240022, 0x5834002a, 0xc9018028, 0x00000000, 0xc000a398, 0xcd0000f8, 0x58340004, 0xc3000000,
+ 0xcb008018, 0x58340004, 0xc1c00000, 0xc9c10010, 0x5834002a, 0xc2000000, 0xca000058, 0x58340004,
+ 0xc2800000, 0xca820078, 0x00000000, 0x6e204000, 0x46a12000, 0x80000048, 0xc1000000, 0xc000a398,
+ 0xcd0000f8, 0xc300001e, 0xc1c00000, 0x58340004, 0xc2400000, 0xca420078, 0x5834000a, 0xc2000000,
+ 0xca0000d8, 0x58340008, 0xc2800000, 0xca82e010, 0xc000a398, 0xc98000f8, 0x6e644010, 0x4225e000,
+ 0x42994000, 0x6ea84010, 0x43e9e000, 0xc39a8008, 0xc7381048, 0x6ee08000, 0x6ee46000, 0x42250000,
+ 0x422d0000, 0x5a200008, 0x5a203406, 0x421d0000, 0xc6380060, 0xc6f81c18, 0x99008b38, 0xdb9800f8,
+ 0xdbd800f9, 0x00000000, 0xc000a2da, 0xc84000f8, 0x00000000, 0xc3c00002, 0x787c2000, 0xcc4000f8,
+ 0xc000ea28, 0xc3800000, 0xcb840038, 0xc000ea14, 0xc3400000, 0xcb440038, 0xc0009f70, 0xcb0400f8,
+ 0xb7b41a02, 0x5804f802, 0xcac000f8, 0xc000a2f0, 0xca4400f8, 0x00000000, 0xc1000002, 0x62410008,
+ 0x5ce00020, 0x88000040, 0x69208000, 0x7d008000, 0x76512000, 0xce4000f8, 0xc62800f8, 0x80000050,
+ 0x00000000, 0xa6c81978, 0xc1000000, 0xc6d00018, 0xc000a360, 0x40100000, 0xca8000f8, 0x00000000,
+ 0x00000000, 0xc1000002, 0xc000a3c0, 0xcd0000f8, 0x6ea08000, 0x6e946000, 0x4168a000, 0x42150000,
+ 0x5a200002, 0x5a207400, 0x58200008, 0xca0000f8, 0xc000a2c6, 0xce8000f8, 0xa63402f0, 0x00000000,
+ 0xc2200060, 0xc000a2c8, 0xce000008, 0xce021038, 0xc240000a, 0xc000a2ca, 0xce4000f8, 0xc2b60002,
+ 0xc000a2e4, 0xce837b00, 0x99008e38, 0xc0009f74, 0xc88400f8, 0x00000000, 0xc000a2c6, 0xcbc000f8,
+ 0x00000000, 0x00000000, 0x6ff88000, 0x6fd46000, 0x417ca000, 0x4395c000, 0x5bb80002, 0x5bb87400,
+ 0x99008bc8, 0xdbd800f8, 0xdb9800f9, 0x00000000, 0x6ff88000, 0x6fd46000, 0x417ca000, 0x4395c000,
+ 0x5bb80002, 0x5bb87400, 0x5838000c, 0xca0000f8, 0xc000abe0, 0xc80400f8, 0x6c908000, 0x45088000,
+ 0x45088000, 0x40100000, 0xca4000f8, 0xc43400f8, 0x00000000, 0xc74000f8, 0xce0000f8, 0xc161fffe,
+ 0x5955fffe, 0x14140000, 0x00000000, 0xc000a28e, 0xca4000f8, 0xc2800002, 0x6abd4000, 0x72692000,
+ 0xce4000f8, 0x00000000, 0xc121fffe, 0x5911fff8, 0x14100000, 0x990079e8, 0xc0009df6, 0xc94000f8,
+ 0xc1800002, 0x00000000, 0x00000000, 0x00000000, 0xa8e2ffe8, 0x00000000, 0x5c380002, 0xc90000f8,
+ 0xc000a3a6, 0xca0000f8, 0xc2800000, 0xc5280078, 0x72290000, 0xce0000f8, 0xc1220002, 0xd90c00f8,
+ 0xc2000000, 0xc000ea14, 0xca040038, 0xc000ea28, 0xc2500002, 0xce450800, 0x58880002, 0xb6080018,
+ 0xc0009f74, 0xc0800000, 0xcc8400f8, 0x800015e8, 0xc000a2c6, 0xcbc000f8, 0xc2400000, 0xc2000000,
+ 0x6ff88000, 0x6fd46000, 0x417ca000, 0x4395c000, 0x5bb80002, 0x5bb87400, 0xc000a396, 0xce4000f8,
+ 0xc1c00000, 0x58380008, 0xc9c24000, 0x58380004, 0xca420078, 0x58380004, 0xca006000, 0xc000a394,
+ 0xcdc000f8, 0x5d1c0000, 0x84000042, 0x58380008, 0xc98000f8, 0x58380004, 0x00000000, 0xc59aeb20,
+ 0xcd816b20, 0x80000b28, 0x5d240050, 0x88000b18, 0x5d200002, 0x8400079a, 0xc2060002, 0x58380004,
+ 0xce006300, 0x58380008, 0xca4000f8, 0x00000000, 0xc3000000, 0xc672e008, 0x5d300000, 0x840000a2,
+ 0x58380010, 0xc42c00f8, 0xc9c000f9, 0xc2400012, 0x6f186000, 0xc1000040, 0x4518a000, 0xc5e000f8,
+ 0xc9c000f8, 0x00000000, 0x6a190000, 0x69d54010, 0x42a14000, 0xc6c000f8, 0xce8000f8, 0x5aec0002,
+ 0x582c0002, 0x5e640002, 0x8400ffa8, 0xc3400000, 0xc2c00000, 0x5a380016, 0x58380016, 0xc9c000f8,
+ 0xc241fffe, 0xc2a1fffe, 0x75e8e000, 0xc1a10200, 0x45d88000, 0x84000080, 0x5a200002, 0xc60000f8,
+ 0xc9c000f8, 0xc000a392, 0xc1000002, 0xcd0000f8, 0x75e8e000, 0x45d88000, 0x84000038, 0x5a200002,
+ 0xc60000f8, 0xc9c000f8, 0x00000000, 0x00000000, 0x75e8e000, 0xc1800bb8, 0x00000000, 0x6dde0010,
+ 0x459c8000, 0x00000000, 0x8000006e, 0xc60000f8, 0x00000000, 0xc98000f9, 0x5a200002, 0xc9c000f8,
+ 0x75a48000, 0x5d115554, 0x840000d0, 0xc1600600, 0x59540000, 0xb5d400b8, 0x5a200002, 0x58200000,
+ 0xc9c000f8, 0x00000000, 0xc1a01000, 0x75e8a000, 0x45948000, 0x84000052, 0xc1a10dba, 0x45948000,
+ 0x84000060, 0x5e200010, 0x46390000, 0x6e2c4000, 0x5aec0004, 0xc3400004, 0x80000030, 0x5e200010,
+ 0x46390000, 0x6e2c4000, 0x5aec0004, 0xc3400002, 0x5838002a, 0xc98000f8, 0x00000000, 0x00000000,
+ 0xc6d81828, 0xc7581e08, 0xcd8000f8, 0xc000a3a4, 0xcec000f8, 0xc2000000, 0x58380000, 0xca002000,
+ 0xc3400000, 0x58380008, 0xcb420008, 0xc3000000, 0x5838002a, 0xcb030028, 0x5e200000, 0x84000132,
+ 0x5d340004, 0x8800005a, 0x5d300000, 0x84000062, 0x5d340006, 0x84000022, 0x5ef0000c, 0xc2800000,
+ 0x80000158, 0x5ef00010, 0xc2800000, 0x80000140, 0xc2c00000, 0xc2800014, 0x80000128, 0xc000a396,
+ 0xc1000002, 0xcd0000f8, 0xc000a2cc, 0xcd0000f8, 0xc000a2c6, 0xcbc000f8, 0xc161fffe, 0x5955fffe,
+ 0x14140000, 0x00000000, 0xc000a28e, 0xc90000f8, 0xc1c00002, 0x69fce000, 0x711c8000, 0xcd0000f8,
+ 0x00000000, 0xc121fffe, 0x5911fff8, 0x14100000, 0x80000af8, 0x5d340004, 0x8800005a, 0x5d300000,
+ 0x8400ff3a, 0x5d340006, 0x84000022, 0x5ef00004, 0xc2800000, 0x80000030, 0xc2800000, 0x5ef00000,
+ 0x80000018, 0xc2c00000, 0xc2800004, 0x58380008, 0xc94000f8, 0x5eec0000, 0x8400004a, 0xc2400000,
+ 0xc566e010, 0xc200001a, 0xc1c00004, 0x426c8000, 0xc1800000, 0xc5180008, 0x800000b0, 0xc2400000,
+ 0xc566e010, 0xc1000006, 0x75248000, 0xc1400006, 0x4550a000, 0x41688000, 0x6d104010, 0xc200001a,
+ 0x46110000, 0x5838002a, 0xc5100058, 0xcd000058, 0xc1c0001e, 0x45e0e000, 0x59540002, 0x41688000,
+ 0xc1400006, 0x7550a000, 0xc1800008, 0x4594c000, 0x5838002a, 0xc6d00c28, 0xcd018c28, 0x5838002a,
+ 0xc6901228, 0xcd025228, 0x58380004, 0xc94000f8, 0x00000000, 0x00000000, 0xc6140418, 0xc5d40810,
+ 0xc5940b20, 0xcd4000f8, 0xc000a39e, 0xcdc000f8, 0xc000a3a0, 0xcd8000f8, 0xc000a396, 0xc1000000,
+ 0xcd0000f8, 0x58380004, 0xca4000f8, 0xc100001a, 0x4520c000, 0x6d984000, 0xc5a41078, 0xce4000f8,
+ 0x00000000, 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000, 0xc000a28e, 0xc90000f8, 0xc1c00002,
+ 0x69fce000, 0x711c8000, 0xcd0000f8, 0x00000000, 0xc121fffe, 0x5911fff8, 0x14100000, 0x80000d40,
+ 0xc2000000, 0x58380000, 0xca002000, 0xc3400000, 0x58380008, 0xcb420008, 0xc3000000, 0x5838002a,
+ 0xcb03c008, 0xc000a3a2, 0x00000000, 0xcf0000f8, 0x5e200000, 0x8400015a, 0x5d340004, 0x880000f2,
+ 0x5d340006, 0x84000072, 0xc2c0000c, 0xc000a200, 0xc221fdfc, 0x5a20079e, 0xce0000f9, 0x5d300002,
+ 0x84000022, 0xc22000ae, 0xce0000f8, 0x80000178, 0xc2200042, 0xce0000f8, 0x80000160, 0xc2c00010,
+ 0xc000a200, 0xc2215554, 0x5a200600, 0xce0000f9, 0xc2200000, 0x5d300002, 0x84000022, 0x5a210dba,
+ 0xce0000f8, 0x80000108, 0x5a201000, 0xce0000f8, 0x800000f0, 0xc2c00014, 0xc000a200, 0xc2215554,
+ 0x5a200600, 0xce0000f9, 0xc2210184, 0x5a20000e, 0xce0000f9, 0xc2200000, 0xce0000f8, 0x80000098,
+ 0x5d340004, 0x8800006a, 0x5d340006, 0x84000192, 0xc2c00004, 0xc000a200, 0x5d300002, 0x84000022,
+ 0xc22000ae, 0xce0000f8, 0x80000040, 0xc2200042, 0xce0000f8, 0x80000028, 0xc2c00004, 0xc2200000,
+ 0xc000a200, 0xce0000f8, 0xc260fffe, 0x58380010, 0x5c004000, 0x42412000, 0xc220fffe, 0xc000a200,
+ 0x5c004000, 0x42010000, 0xc000f00c, 0xce4000f8, 0xc000f00e, 0xce0000f8, 0xc1f0003a, 0xc1000000,
+ 0x58380004, 0xc9016008, 0x00000000, 0x00000000, 0xc51c0070, 0xc000f010, 0xcdc000f8, 0xc1b00012,
+ 0xc6d81038, 0xc1000000, 0xc5180070, 0xc000f012, 0xcd8000f8, 0x00000000, 0x00000000, 0x00000000,
+ 0xa8e2ffe8, 0x00000000, 0x00000000, 0xc1220002, 0xd90c00f8, 0x00000000, 0xc000a2c6, 0xcbc000f8,
+ 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000, 0xc000a28e, 0xc90000f8, 0xc1c00002, 0x69fce000,
+ 0x711c8000, 0xcd0000f8, 0x00000000, 0xc121fffe, 0x5911fff8, 0x14100000, 0x6ff88000, 0x6fd46000,
+ 0x417ca000, 0x4395c000, 0x5bb80002, 0x5bb87400, 0x58380004, 0xca0000f8, 0x58380008, 0xca4000f8,
+ 0xc3400000, 0xc6340000, 0xc000a2ce, 0xcf4000f8, 0xc3000000, 0xc6320078, 0xc1800000, 0xc6188018,
+ 0xc000a39c, 0xcd8000f8, 0x6d904000, 0x43118000, 0xc000a2bc, 0xcf0000f8, 0x5838002a, 0xc9c000f8,
+ 0xc1800000, 0xc2800000, 0xc5ea4028, 0xc5d98028, 0xc000a398, 0xcd8000f8, 0xc000a39a, 0xce8000f8,
+ 0xc2c00000, 0xc66c0078, 0x42e96000, 0x46d96000, 0xc000a2d0, 0xcec000f8, 0xc1000000, 0xc6116020,
+ 0xc000a2d4, 0xcd0000f8, 0x5f740000, 0x84000160, 0x5e300018, 0x46e12000, 0x8400012a, 0x46e12000,
+ 0x88000112, 0x5e300008, 0x46e12000, 0x8800002a, 0x46e12000, 0x84000022, 0x00000000, 0x800000a0,
+ 0x00000000, 0xc3400002, 0xc000a2ce, 0xcf4000f8, 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000,
+ 0xc000a28e, 0xca4000f8, 0xc1000002, 0x693c8000, 0x7d008000, 0x76512000, 0xce4000f8, 0x00000000,
+ 0xc121fffe, 0x5911fff8, 0x14100000, 0xc2200060, 0xc000a2c8, 0xce021038, 0xc2000000, 0xc000a2cc,
+ 0xce0000f8, 0x80000060, 0x00000000, 0x99008f78, 0xdbd800f8, 0xdb9800f9, 0xc78000f8, 0xc2200058,
+ 0xc000a2c8, 0xce021038, 0xc2000002, 0xc000a2cc, 0xce0000f8, 0xc2000006, 0xc000f006, 0xce0000f8,
+ 0x58380006, 0xca4000f8, 0xc2200982, 0x5a203b6e, 0xc000f008, 0xce0000f8, 0xc000f00a, 0xce4000f8,
+ 0xc000a2d4, 0xc90000f8, 0xc200000c, 0xc000a2ca, 0xce0000f8, 0xc000a2c8, 0xcd000008, 0xc1360000,
+ 0xc000a2e4, 0xcd0000f8, 0x99008e38, 0xc0009f74, 0xc88400f8, 0x00000000, 0xc000a2c6, 0xcbc000f8,
+ 0xc000a2cc, 0xca0000f8, 0x6ff88000, 0x6fd46000, 0x417ca000, 0x4395c000, 0x5bb80002, 0x5bb87400,
+ 0x5e200000, 0x84000032, 0x00000000, 0x99008bc8, 0xdbd800f8, 0xdb9800f9, 0x00000000, 0xc000a2bc,
+ 0xca8000f8, 0xc000a2ce, 0xcac000f8, 0xc3000018, 0xc3400006, 0xc2400000, 0xc000a3a0, 0xc9c000f8,
+ 0x5e200000, 0x84000042, 0xc2800000, 0xc2c00000, 0xc300001a, 0xc3400004, 0xc2400000, 0x5838002a,
+ 0xce4000f8, 0xc6ac1078, 0xc72c0418, 0xc76c0810, 0xc66c0300, 0xc5ec0b20, 0x58380002, 0xca8000f8,
+ 0x58380004, 0xcec000f8, 0xc6280100, 0xc000abe0, 0xc80400f8, 0x6c908000, 0x45088000, 0x45088000,
+ 0x40100000, 0xcb0000f8, 0xc43400f8, 0x00000000, 0xc74000f8, 0xce8000f8, 0xc000a2d2, 0xce8000f8,
+ 0xc000a396, 0xca0000f8, 0x00000000, 0x00000000, 0x5d200002, 0x84000020, 0xc2000000, 0xce0000f8,
+ 0x80000378, 0x00000000, 0x00000000, 0x00000000, 0xa8e2ffe8, 0x00000000, 0xc000a2cc, 0xca0000f8,
+ 0xc000a2d0, 0xcac000f8, 0x5e200000, 0x840000fa, 0x5c380002, 0xc90000f8, 0xc000a3a6, 0xcb0000f8,
+ 0xc2800000, 0xc5280078, 0x73298000, 0xcf0000f8, 0xdfe800f8, 0x7e814000, 0x5834001a, 0xce8000f8,
+ 0x990079e8, 0xc0009df4, 0xc94000f8, 0xc1800002, 0x6fe82000, 0x5aa89e80, 0x990079e8, 0x58280000,
+ 0xc94000f8, 0xc1800002, 0x990079e8, 0x58280002, 0xc94000f8, 0xc6d800f8, 0x990079e8, 0xc0009df8,
+ 0xc94000f8, 0xc6d800f8, 0xc1220002, 0xd90c00f8, 0x5e200000, 0x84000040, 0x58380028, 0xcb0000f8,
+ 0xdfe800f8, 0x00000000, 0x58380010, 0xcf0000f8, 0x80000018, 0xc2a1fffe, 0x5aa9fffe, 0x58380006,
+ 0xce8000f8, 0xc3000000, 0xc000ea14, 0xcb040038, 0xc2d00002, 0xc000ea28, 0xcec50800, 0xc000a2ce,
+ 0xca8000f8, 0x58880002, 0xb4b00018, 0xc0009f74, 0xc0800000, 0xcc8400f8, 0x5ea80000, 0x84000142,
+ 0x5e200000, 0x84000130, 0xc000a2bc, 0xca8000f8, 0x00000000, 0x00000000, 0x5aa80060, 0xce8000f8,
+ 0x99008f78, 0xdbd800f8, 0xdb9800f9, 0xc78000f8, 0x58380000, 0xcac000f8, 0x00000000, 0xc2000000,
+ 0xc6e04018, 0xc000a2d2, 0xcac000f8, 0x58380000, 0xca8000f8, 0xc30c0002, 0xc6300018, 0xc161fffe,
+ 0x5955fffe, 0x14140000, 0x00000000, 0xc000f800, 0xca0000f8, 0x00000000, 0x00000000, 0xa60cffea,
+ 0xc6f00500, 0xc6b0c400, 0xcf0000f8, 0x00000000, 0xc121fffe, 0x5911fff8, 0x14100000, 0x80000008,
+ 0xc0004028, 0xcbc000f8, 0xc000a3c0, 0xcb8000f8, 0xa7c00050, 0x00000000, 0x5d380000, 0x84000038,
+ 0xc1000004, 0xc000a3c0, 0xcd0000f8, 0xc1000002, 0xc000e070, 0xcd000000, 0xc100021c, 0x8d180000,
+ 0x00000000, 0x00000000, 0x00000000, 0xc000a3c0, 0xcac000f8, 0xc000a3c2, 0xca8000f8, 0x5d2c0004,
+ 0x84000038, 0xc2c00000, 0xc000a3c0, 0xcec000f8, 0x5aa80002, 0xc000a3c2, 0xce8000f8, 0x80008f18,
+ 0x00000000, 0x58340008, 0xc98000f8, 0xc74000f8, 0xc9c000f8, 0x45588000, 0xa53e0068, 0x58340004,
+ 0x48820078, 0xc2c00000, 0xc5ec0078, 0x42c96000, 0xc6c000f8, 0xca4000f8, 0x58340002, 0x49400078,
+ 0x7a5c8000, 0x7d008000, 0xc507e000, 0x9cc00000, 0x6c882010, 0x4148a000, 0xd9641078, 0x58300008,
+ 0xc98000f8, 0xc70000f8, 0xc9c000f8, 0x45944000, 0xc1000000, 0xc5d20038, 0x5c3c46a0, 0xc0000002,
+ 0x78000006, 0x45008000, 0x44908000, 0x88000060, 0x58300004, 0x48800078, 0xc2800000, 0xc5e80078,
+ 0x42894000, 0xc68000f8, 0xca0000f8, 0x58300002, 0x49400078, 0x7a1c8000, 0xc507e000, 0x9cc00000,
+ 0x6c882010, 0x4148a000, 0xd9640078, 0x58140002, 0x48400038, 0x58140002, 0x49c20078, 0x58140000,
+ 0x49800078, 0x41c4e000, 0x00000000, 0x4184c000, 0x6f520000, 0x412c8000, 0xc5c000f8, 0xcd0000f9,
+ 0x6f120000, 0x41288000, 0xcd0000f9, 0xd64000f8, 0xc000ec04, 0xde83e000, 0xc1203c14, 0x59104000,
+ 0xcd0000f8, 0xde9beb00, 0x582c0002, 0xc88000f8, 0xc1000000, 0xc652e010, 0x40904000, 0xc0400000,
+ 0xc6440078, 0xc1000006, 0x75088000, 0x40502000, 0x58440006, 0xc121fffe, 0x5911fff8, 0x74502000,
+ 0x74904000, 0x58180004, 0xcc8000f8, 0xc1000000, 0xc5538018, 0x5d100002, 0x84000050, 0x00000000,
+ 0xc1000006, 0x74508000, 0x84000018, 0x00000000, 0x58440008, 0xc121fffe, 0x5911fff8, 0x74502000,
+ 0x58180002, 0xcc4000f8, 0x58280002, 0xc88000f8, 0xc101fffe, 0x75508000, 0x5d104f30, 0x00000000,
+ 0x6c884002, 0xc1000000, 0xc612e010, 0x40904000, 0xc121fffe, 0x5911fff8, 0x74904000, 0x58180008,
+ 0xcc8000f8, 0x58140000, 0x4903c000, 0xc0800000, 0xc54b8c18, 0x5814000a, 0xc84000f8, 0xc5c81078,
+ 0xc5080000, 0x5d040000, 0x84000022, 0xc58000f8, 0xcc8000f8, 0x80000028, 0x5814000c, 0xcd8000f8,
+ 0x5814000e, 0xcc8000f8, 0x9cc00000, 0x00000000, 0x581c0006, 0xcc8000f8, 0x49c20138, 0x5834000c,
+ 0xc88000f8, 0x59980004, 0x45d88000, 0xc1000000, 0xc51800fe, 0x58340004, 0xcd801078, 0x58880002,
+ 0x5834000c, 0xcc8000f8, 0x58300004, 0x49800078, 0x58300000, 0x49c20138, 0x58300008, 0xc88000f8,
+ 0x59980004, 0x45d88000, 0xc1000000, 0xc51800fe, 0x58300004, 0xcd800078, 0x9cc00000, 0x58880002,
+ 0x58300008, 0xcc8000f8, 0x58140002, 0x49c00038, 0x5814000a, 0xc88000f8, 0x59dc000c, 0x58140000,
+ 0x4843c000, 0x45d88000, 0x88000092, 0xc000ec04, 0xde83e000, 0xc1203c14, 0x59104000, 0xcd0000f8,
+ 0xc1c00000, 0xc000cd80, 0x5d144f20, 0xc100cf80, 0xc50000fa, 0xde83eb00, 0xc100000c, 0xc4500000,
+ 0xcd0000f8, 0x7c402000, 0x58140000, 0xcc401e00, 0x58140002, 0xcdc00038, 0x9cc00000, 0x58880002,
+ 0x5814000a, 0xcc8000f8, 0x5814000a, 0xc98000f8, 0x58140008, 0x49c00008, 0x5d180000, 0x84000112,
+ 0x5d1c0006, 0x84000100, 0x5814000c, 0xc9c000f8, 0x5814000e, 0xc88000f8, 0xc000ec04, 0xde83e000,
+ 0xc1203c14, 0x59104000, 0xcd0000f8, 0xde9feb00, 0x58140006, 0x49000038, 0xc5c000f8, 0xcc8000f8,
+ 0x41188000, 0x58140006, 0xcd000038, 0x5814000a, 0xc1000000, 0xcd0000f8, 0xc1800000, 0xc000ec04,
+ 0xde83e000, 0xcc4000f8, 0xc000c000, 0xde83eb00, 0xc4404050, 0xcd8000f8, 0x58140008, 0xc1000002,
+ 0xcd000008, 0x9cc00000, 0x00000000, 0x00000000, 0x00000000, 0x9d000000, 0x4158a000, 0xcd4000f8,
+ 0x00000000, 0xc2c80002, 0x6ac56000, 0xdacc00f8, 0xc000abd4, 0xcb4400f8, 0xc000abc8, 0xcb8400f8,
+ 0xc000e838, 0xc3c00000, 0xcbc40038, 0x5ef40004, 0x84000022, 0xc3000000, 0xc000facc, 0xcf042100,
+ 0x47f98000, 0x84000042, 0xc1000002, 0xc000a3c0, 0xcd0000f8, 0x47f98000, 0x88000030, 0xc1006e8c,
+ 0x80008580, 0xc000abc0, 0xcc8400f8, 0x80000080, 0xc000fac0, 0xcac400f8, 0xc000abd4, 0xcb4400f8,
+ 0xa6c0052a, 0x00000000, 0x5ef40000, 0x84000062, 0x5ef40002, 0x840002f2, 0x5ef40004, 0x840004f2,
+ 0xc1006ce8, 0x800084f8, 0x00000000, 0x9cc00000, 0x00000000, 0x00000000, 0x00000000, 0xc000abfc,
+ 0xc80400f8, 0x00000000, 0x00000000, 0x40080000, 0xcbc000f8, 0xc43800f8, 0x00000000, 0xc000402e,
+ 0xca0000f8, 0xc000abd8, 0xcb4400f8, 0x00000000, 0x00000000, 0x47610000, 0x880000b0, 0x00000000,
+ 0xa7c00048, 0xc000abd4, 0xc1000002, 0xcd0400f8, 0xc11c0000, 0xc000e82c, 0xcd05ce00, 0x800000d8,
+ 0x00000000, 0xa7d20138, 0x00000000, 0xc7e14040, 0xc2400000, 0xc6246028, 0xc200006a, 0x46250000,
+ 0xc6240030, 0xc000e810, 0xce440030, 0x8000ff70, 0xc2000000, 0xc000e808, 0xca040010, 0xc11c0000,
+ 0xc000e82c, 0xcd05ce00, 0x5a200002, 0x5e600010, 0x84000010, 0xc2000000, 0xc000e808, 0xce040010,
+ 0xc3400000, 0x80000028, 0xc1200002, 0xc000e818, 0xcd061000, 0x5b740002, 0xc000abd8, 0xcf4400f8,
+ 0x990085a8, 0xc000abc8, 0xc94400f8, 0xc1800000, 0xc11c0002, 0xc000e82c, 0xcd05ce00, 0x8000fc90,
+ 0x5b740002, 0xc000abd8, 0xcf4400f8, 0xc78000f8, 0xc13c0002, 0xcd03de00, 0xc000abc8, 0xc94400f8,
+ 0xc1800000, 0xc000e82c, 0xc9840038, 0x59540002, 0xc000abc8, 0xcd4400f8, 0x58880002, 0xb498fc10,
+ 0x00000000, 0xc0800000, 0x8000fbf8, 0xc000abfc, 0xc80400f8, 0x00000000, 0x00000000, 0x40080000,
+ 0xcbc000f8, 0xc42800f8, 0x00000000, 0xa7c00130, 0xc000abcc, 0xca0400f8, 0xc2400000, 0xc000faec,
+ 0xca440018, 0x5a200002, 0xc000abcc, 0xce0400f8, 0xb624008a, 0xc68000f8, 0xc13c0002, 0xcd03de00,
+ 0xc000abc8, 0xc94400f8, 0xc1800000, 0xc000e82c, 0xc9840038, 0x59540002, 0xc000abc8, 0xcd4400f8,
+ 0x58880002, 0xb498fb00, 0x00000000, 0xc0800000, 0x8000fae8, 0xc000abd4, 0xc1000004, 0xcd0400f8,
+ 0xc000e820, 0xc2000002, 0xce0400f8, 0xc2000000, 0xc000abcc, 0xce0400f8, 0xc000abd8, 0xce0400f8,
+ 0x8000ff28, 0xc000abd4, 0xc1000000, 0xcd0400f8, 0xc11c0000, 0xc000e82c, 0xcd05ce00, 0x990085a8,
+ 0xc000abc8, 0xc94400f8, 0xc1800000, 0xc1200000, 0xc000e818, 0xcd061000, 0xc11c0002, 0xc000e82c,
+ 0xcd05ce00, 0xc2000000, 0xc000abcc, 0xce0400f8, 0x8000f9e8, 0xc000fac0, 0xcb8400f8, 0xc000abfc,
+ 0xc80400f8, 0x00000000, 0x00000000, 0x40080000, 0xcbc000f8, 0xc42800f8, 0x00000000, 0xa780024a,
+ 0x00000000, 0x00000000, 0xa7c0020a, 0x00000000, 0xc000fb60, 0xc2060006, 0xce046308, 0xa7e801c2,
+ 0x00000000, 0xc000abd0, 0xca0400f8, 0xc2400000, 0xc000faec, 0xca448018, 0x5a200002, 0xc000abd0,
+ 0xce0400f8, 0xb62400aa, 0x00000000, 0xc68000f8, 0xc13c0002, 0xcd03de00, 0xc000facc, 0xc2000002,
+ 0xce040000, 0xc000abc8, 0xc94400f8, 0xc1800000, 0xc000e82c, 0xc9840038, 0x59540002, 0xc000abc8,
+ 0xcd4400f8, 0x58880002, 0xb498f878, 0x00000000, 0xc0800000, 0x8000f860, 0xc000abd4, 0xc1000000,
+ 0xcd0400f8, 0xc11c0000, 0xc000e82c, 0xcd05ce00, 0x990085a8, 0xc000abc8, 0xc94400f8, 0xc1800000,
+ 0xc2000000, 0xc000e820, 0xce0400f8, 0xc1200000, 0xc000e818, 0xcd061000, 0xc11c0002, 0xc000e82c,
+ 0xcd05ce00, 0xc000abd0, 0xce0400f8, 0xc2000002, 0xc000facc, 0xce040008, 0x8000f798, 0xc2000002,
+ 0xc000abd0, 0xce0400f8, 0x8000fe88, 0xc2000000, 0xc000abd0, 0xce0400f8, 0xa7e60032, 0x00000000,
+ 0xc2000002, 0xc000fb60, 0xce040000, 0x8000fe70, 0x00000000, 0xa7860052, 0x00000000, 0xc68000f8,
+ 0xc13c0002, 0xcd03de00, 0xc2020002, 0xc7e2a540, 0xc000fb60, 0xce0400f8, 0x8000fe18, 0xc2040002,
+ 0xc000fb60, 0xce044200, 0x8000fdf8, 0xc0800000, 0xc000f414, 0xc88000f8, 0x00000000, 0x00000000,
+ 0x5d080000, 0x840001e2, 0xc1000002, 0xc000a3c0, 0xcd0000f8, 0xa4880178, 0xc2c00000, 0xc000f418,
+ 0xcac20018, 0xc000a28e, 0xca4000f8, 0xc2800002, 0x6aad4000, 0x7e810000, 0x76612000, 0xce4000f8,
+ 0xc000a2ea, 0xc9c000f8, 0x00000000, 0x00000000, 0x71e8e000, 0xc000a2ea, 0xcdc000f8, 0x6ef08000,
+ 0x6ed46000, 0x416ca000, 0x43158000, 0x5b300002, 0x5b307400, 0x58300000, 0xca0000f8, 0x58300004,
+ 0xca4000f8, 0xc2800000, 0xc6284018, 0xa6460048, 0xc000a2f0, 0xc600c000, 0xca4000f8, 0xc1000002,
+ 0x692c8000, 0x72512000, 0xce4000f8, 0x80000048, 0xc24c0002, 0xc6a40018, 0xc624c400, 0x5830000c,
+ 0xca400500, 0x00000000, 0xc000f800, 0xce4000f8, 0xa48c0048, 0xc1404ac0, 0x58140016, 0xc98000f8,
+ 0x00000000, 0x00000000, 0x59980002, 0x58140016, 0xcd8000f8, 0xc000f414, 0xcc8000f8, 0xc10e0002,
+ 0xd90c00f8, 0x9cc00000, 0x00000000, 0x00000000, 0x00000000, 0xc4980928, 0x9d000000, 0xc5580038,
+ 0xc000e838, 0xcd8400f8, 0xc1440080, 0xc1c06b40, 0xc55c0f80, 0xc000f00e, 0x9d000000, 0xcd8000f8,
+ 0xc000f00c, 0xcdc000f8, 0xc1440040, 0xc1c06320, 0xc55c0f80, 0xc000f00e, 0x9d000000, 0xcd8000f8,
+ 0xc000f00c, 0xcdc000f8, 0xc000a320, 0x58000004, 0xcd8000f8, 0xc1f0000a, 0x715ca000, 0xc000f010,
+ 0xcd4000f8, 0x6c9c8000, 0x45c8e000, 0x45c8e000, 0x59dc0004, 0xc1601260, 0xc5d40260, 0x9d000000,
+ 0xc000f012, 0xcd4000f8, 0x00000000, 0xc000a31e, 0xc9c000f8, 0x00000000, 0x00000000, 0xd9d800f9,
+ 0xc000ab40, 0x401c0000, 0x5dc0abc0, 0x88000012, 0x5c000080, 0xcd8000f8, 0xc1f0000a, 0x715ca000,
+ 0xdd9800f8, 0xdd9c00f9, 0x41d8e000, 0xc5d40260, 0xc000f010, 0xcd4000f8, 0x6c9c8000, 0x45c8e000,
+ 0x45c8e000, 0x59dc0004, 0xc1601260, 0xc5d40260, 0x9d000000, 0xc000f012, 0xcd4000f8, 0x00000000,
+ 0xc000a31e, 0xc98000f8, 0x00000000, 0xc1c00080, 0x4194c000, 0x459ce000, 0x88000012, 0xc5d800f8,
+ 0xc000a31e, 0xcd8000f8, 0xc000f406, 0xc98000f8, 0xc1c00002, 0x9d000000, 0xc5d80a00, 0xc5581048,
+ 0xcd8000f8, 0xc000a2b0, 0xc98000f8, 0xc000a2b2, 0xc9c000f8, 0xc140000e, 0xc5581c18, 0xc00041c0,
+ 0xc983ff00, 0x00000000, 0xc1400000, 0xc5940078, 0x5d540080, 0xc1400080, 0xc558007c, 0xdd9400f8,
+ 0xc000ab40, 0x40140000, 0x5d40abc0, 0x88000012, 0x5c000080, 0xcd8000f8, 0x58000002, 0x5d40abc0,
+ 0x88000012, 0x5c000080, 0xcdc000f8, 0xc1c00000, 0xdd4000f8, 0xc9c20078, 0xdd9400f9, 0x6d546000,
+ 0x595441c0, 0x58140000, 0x49400078, 0xc0200f10, 0x5800c000, 0x40140000, 0x401ca000, 0xc000a29e,
+ 0xcd4000f8, 0xdd9800f8, 0xc1c00022, 0xc5d80d70, 0xdd9400f9, 0xc5581c18, 0xc000a29c, 0xcd8000f8,
+ 0xc1400000, 0xdd4000f8, 0xc9420078, 0xdd9800f9, 0x6d986000, 0x599841c0, 0x58180000, 0x49820138,
+ 0x00000000, 0x59540004, 0x4594c000, 0xc1800000, 0xc59400fe, 0xdd4000f8, 0xc5501078, 0xcd021078,
+ 0xdd9800f9, 0xc1400002, 0x6958a000, 0xc000e408, 0xcd4000f8, 0x9d000000, 0x00000000, 0x00000000,
+ 0x00000000, 0xc1c00000, 0xdf5c0038, 0x5d1c0020, 0x8800ffe8, 0xc000a31c, 0xc9c000f8, 0x00000000,
+ 0x00000000, 0x581cab00, 0xcd4000f9, 0xcd8000f9, 0x59dc0004, 0xc1020020, 0x451c8000, 0xc1000000,
+ 0xc51c00fe, 0xc000a31c, 0xcdc000f8, 0x9cc00000, 0xc1100002, 0xc000f402, 0xcd010800, 0xc000a31c,
+ 0xc94000f8, 0xc1820020, 0xc1d00002, 0x5814ab00, 0xd58000f8, 0x58000002, 0xd58000f9, 0x59540004,
+ 0xb5580018, 0xc000a31c, 0xc1400000, 0xcd4000f8, 0xdd9800f9, 0x9d000000, 0xdd9400f8, 0xc000f402,
+ 0xcdc10800, 0xd91400f8, 0x00000000, 0xdd9400f8, 0x6d546000, 0x59545c00, 0xc54000f8, 0xc9c000f8,
+ 0x58140004, 0x49820078, 0xc1000000, 0xc5d00078, 0xd9b800f8, 0x4190c000, 0x7dc08000, 0xc58000f8,
+ 0xcd03ff00, 0xc1000000, 0xc5d20138, 0xdf8000f8, 0x58000004, 0x45008000, 0xc1000000, 0xc50000fe,
+ 0xc41000f8, 0x58140004, 0xcd001078, 0x58180000, 0x49800078, 0x5814000e, 0xc90000f8, 0x5814000c,
+ 0xc9c000f8, 0x41188000, 0x5814000e, 0xcd0000f8, 0x58140008, 0xc98000f8, 0x59dc0002, 0x5814000c,
+ 0xcdc000f8, 0xdd9400f8, 0x58144d00, 0xc98000f8, 0xc000404c, 0xc9c000f8, 0x5d980002, 0x58144d00,
+ 0xcd8000f8, 0xc1000000, 0xc5d00038, 0x45188000, 0x88000072, 0xc0004a18, 0xc98000f8, 0xc1c00002,
+ 0x69d4e000, 0x75d88000, 0x84000042, 0xc000e400, 0x6dde0000, 0xcdc000f8, 0x7dc0e000, 0x759cc000,
+ 0xc0004a18, 0xcd8000f8, 0xc1400000, 0xc000a2f4, 0xc9c000f8, 0xdd9800f8, 0xc1000002, 0x69188000,
+ 0x7d008000, 0x75d0e000, 0xdd5000f8, 0x9d000000, 0x6958a000, 0x71d4e000, 0xcdc000f8, 0xc160fffe,
+ 0xc000ea10, 0xc9440070, 0xc1a0fffe, 0x59983406, 0xc000f00c, 0xcd4000f8, 0xc000f00e, 0xcd8000f8,
+ 0xc000a2e4, 0xc98000f8, 0x00000000, 0xc170000a, 0x7158a000, 0x6c988000, 0x4588c000, 0x4588c000,
+ 0x59980004, 0xc5940270, 0xc000f010, 0xcd4000f8, 0xc000a2c6, 0xc94000f8, 0x00000000, 0x00000000,
+ 0x6d588000, 0x6d5c6000, 0x419cc000, 0x4194c000, 0xc000a2ca, 0xc94000f8, 0xc000a2c8, 0xc9c000f8,
+ 0x4194c000, 0xc1400012, 0xc55c1818, 0x9d000000, 0xc59c0268, 0xc000f012, 0xcdc000f8, 0x58000000,
+ 0xc94000f8, 0xc1c00000, 0xc000a2d4, 0xc9c00008, 0xc000a2d0, 0xc9400078, 0xdd8000f9, 0x58000024,
+ 0x5d9c0000, 0x84000052, 0x5d9c0002, 0x84000052, 0x5d9c0004, 0x8400006a, 0xc55b0038, 0xc55c08b8,
+ 0xcd800039, 0xcdc108b8, 0x80000060, 0xcd4000f8, 0x80000050, 0xc55900b8, 0xc55c1838, 0xcd8000b9,
+ 0xcdc31838, 0x80000028, 0xc55a0078, 0xc55c1078, 0xcd800079, 0xcdc21078, 0x9d000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x583c0000, 0x4b404000, 0xd8f800f8, 0x5d380000, 0x84000248, 0xc1000002,
+ 0x7b51a000, 0x7751a000, 0x583c0000, 0xcf400200, 0x6f706000, 0x5b304f20, 0x58300008, 0x49400008,
+ 0x00000000, 0x00000000, 0x5d140002, 0x84000530, 0xc0004044, 0xc10c0002, 0xcd00c600, 0xc1400000,
+ 0xdf550048, 0xc1800080, 0x45588000, 0x8800ffe0, 0xc000a31e, 0xc9c000f8, 0x6f53e000, 0x00000000,
+ 0x581cab40, 0xcd0000f8, 0x599c0002, 0xc1000080, 0x45188000, 0xc1000000, 0xc51800fe, 0xc000a31e,
+ 0xcd8000f8, 0xc000f406, 0xc98000f8, 0xc1000002, 0x00000000, 0xc5180a00, 0xc5181048, 0xcd8000f8,
+ 0x583c0004, 0x6f504000, 0x40100000, 0xc94000f9, 0x98c08a88, 0xc98000f8, 0xc5d40060, 0x00000000,
+ 0x583c0008, 0x6f504000, 0x40100000, 0xc94000f9, 0xc98000f8, 0x98c08a88, 0x59540002, 0x5998000e,
+ 0x00000000, 0x98c08a88, 0x5d540002, 0x5d98000e, 0x00000000, 0x583c0014, 0xc94000f8, 0x00000000,
+ 0x00000000, 0x59540004, 0xcd4000f8, 0x583c0000, 0xc1000004, 0xcd000008, 0x80000358, 0x6f706000,
+ 0x5b304f20, 0x5d380004, 0x84000338, 0x583c0014, 0xc94000f8, 0x583c0016, 0xc98000f8, 0x00000000,
+ 0x00000000, 0x45588000, 0x840002f8, 0xc0004044, 0xc10c0002, 0xcd00c600, 0x583c0000, 0xc1000000,
+ 0xcd000008, 0xc00046a0, 0x58000002, 0xc7400300, 0xc94000f8, 0x58300000, 0x4a020038, 0x58300004,
+ 0xc98000f8, 0x58300006, 0x49c30038, 0x45592000, 0x6e644010, 0x58300006, 0xce401838, 0xc00046a0,
+ 0xc7400300, 0x4940a008, 0x58344a20, 0xc98000f8, 0x5d140006, 0x840000da, 0x58344a24, 0xc94000f8,
+ 0x45a48000, 0x840000b8, 0xc0004a28, 0xc90000f8, 0x59540002, 0x00000000, 0x5d100000, 0xc0000040,
+ 0xc41000fa, 0x45148000, 0x88000058, 0xc1400000, 0xc000e408, 0xc1000010, 0xcd0000f8, 0xc0004a2c,
+ 0xc90000f8, 0x00000000, 0x00000000, 0x59100002, 0xcd0000f8, 0x58344a24, 0xcd4000f8, 0x80000030,
+ 0x58344a20, 0xce4000f8, 0xc1400000, 0x58344a24, 0xcd4000f8, 0x465d2000, 0x42612004, 0x58300006,
+ 0x4ac10038, 0x6e642010, 0x6e544010, 0x6e508010, 0x4150a000, 0x6d508010, 0x4150a000, 0x6d582000,
+ 0x4194c000, 0x4658c000, 0x6da46000, 0x6d904000, 0x42512000, 0x46592000, 0x6e64a010, 0x42552000,
+ 0x42e56000, 0x58300006, 0xcec00838, 0x58300006, 0x49400038, 0xc00046a0, 0xc7400300, 0x4980a008,
+ 0xc10001fe, 0x76d16000, 0x46d48000, 0x84000030, 0x5d180006, 0x84000020, 0x58300008, 0xcd800008,
+ 0x00000000, 0xdf8c00f8, 0x9cc00000, 0x00000000, 0x00000000, 0x00000000,};
+
+static u32 vrx218_a1plus_fw_data[] = {
+};
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/vrx318/fw/vrx318_e1.h b/drivers/net/ethernet/lantiq/vrx318/fw/vrx318_e1.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/fw/vrx318_e1.h
@@ -0,0 +1,623 @@
+#ifndef __VRX218_E1_FW_H
+#define __VRX218_E1_FW_H
+
+/******************************************************************************
+** FILE NAME    : ifxmips_ppa_datapath_fw_vrx218_e1.h
+** PROJECT      : PPA
+** PLATFORM     : VRX218
+** MODULES     	: E1
+**
+** DATE         : 06/03/2015
+** AUTHOR       : Lantiq PPE FW Team
+** DESCRIPTION  : VRX218 E1 PPE Firmware Binary
+** COPYRIGHT    : 	   Copyright (c) 2015
+**			        Lantiq Deutschland GmbH
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** FW VERSION [31:0] : 0x92030202
+** MERCURIAL TAG     :
+**
+** HISTORY
+** $Date         $Author                   $Comment
+** 06/03/2015    Lantiq PPE FW Team        VRX218 E1 PPE Firmware Binary
+*******************************************************************************/
+
+static u32 vrx218_e1_fw_code[] = {
+ 0x800002a8, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x8000ffe0, 0x00000000, 0x00000000, 0x00000000,
+ 0xc1c00002, 0xd9cc00f8, 0x98403480, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x94000001, 0x00000000,
+ 0xc1c20002, 0xd9cc00f8, 0xc0004004, 0xcbc000f8, 0xc1c00000, 0xde9d0000, 0x5ddc0002, 0x984057f2,
+ 0x5bfc0002, 0xcfc000f8, 0x00000000, 0xaa80003a, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0xc0004024, 0x48c00000, 0xc0004034, 0x4bc000a0, 0xa4c000d0, 0x00000000,
+ 0x63c1c028, 0xa78a00ba, 0x6fb44000, 0x5b746840, 0x58340006, 0x4b020038, 0x4ac00078, 0x00000000,
+ 0x5f300002, 0x84000060, 0x58340002, 0x4a800078, 0x58340002, 0x4a020078, 0x58340000, 0x4b030038,
+ 0x42e92000, 0x4624e000, 0xc62400fc, 0x58340006, 0xce400078, 0x58340006, 0xcf001038, 0x8000ff48,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x94000001, 0xc0214b4a, 0xc1c00404, 0x701ce000,
+ 0xc000fb86, 0xcdc000f8, 0xc1c00000, 0xc000fb84, 0xcdc00000, 0xc1c00002, 0xc0004008, 0xcdc000f8,
+ 0xc0004040, 0xd28000f8, 0x00000000, 0x00000000, 0x00000000, 0xc00070b8, 0xde83e000, 0xc8c000f8,
+ 0x00000000, 0x00000000, 0x58cc0002, 0xccc000f8, 0xc0004010, 0xd14000f8, 0xc3e12406, 0x5bfc0404,
+ 0xc0004000, 0xcfc000f8, 0xc3e16000, 0x5bfc0000, 0xc0004002, 0xcfc000f8, 0xc3c00000, 0xc0004024,
+ 0xcbc20078, 0x00000000, 0x00000000, 0xc0c00000, 0xde8fe000, 0xc00068f2, 0xc90000f8, 0x00000000,
+ 0x00000000, 0x44d0e000, 0x8400ffd8, 0x59100002, 0xc00068f2, 0xcd0000f8, 0x00000000, 0x00000000,
+ 0x00000000, 0xc00068f2, 0xc90000f8, 0x00000000, 0x00000000, 0x5dd00004, 0x8400ffd8, 0xc1c00000,
+ 0xd9c400f9, 0xdbc40078, 0xc1c00006, 0xd9c400f9, 0xc000403c, 0xcfc000f8, 0xc3c00000, 0xc3400000,
+ 0xc3000040, 0xc2c00080, 0x6ff8a000, 0x5bb87d00, 0x5838001c, 0xcf4000f8, 0x5838001e, 0xcec000f8,
+ 0x58380020, 0xcf4000f8, 0x58380022, 0xcf0000f8, 0x5bfc0002, 0x5ebc0004, 0x8400ffa0, 0xc33e0000,
+ 0xc000bf80, 0xcf0000f8, 0xc33e0002, 0xc000bf82, 0xcf0000f8, 0xc3c04ac0, 0xc3800036, 0xc1c00008,
+ 0xc5f81648, 0xc3400002, 0xc2e03ce0, 0x5aec14d8, 0xc6f402e0, 0x583c0004, 0xc3000000, 0x6f1c4000,
+ 0xc5f80b50, 0xcf8000f9, 0xcf4000f9, 0x5b300002, 0x58000004, 0xc1c00002, 0x45f0e000, 0x8800ffc0,
+ 0xc2e03ce0, 0x5aec14e0, 0xc6f402e0, 0x583c0008, 0xc3000000, 0xc1c00008, 0xc5f81648, 0x6f1ca000,
+ 0xc5f80b50, 0xcf8000f9, 0xcf4000f9, 0x5b300002, 0x58000004, 0xc1c00002, 0x45f0e000, 0x8800ffc0,
+ 0x984074c0, 0x583c000c, 0xc8c000f9, 0xc90000f8, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xc000f414, 0xc8c000f8, 0x00000000, 0x00000000,
+ 0xa4c2ffa0, 0xc1c20002, 0x75cce000, 0xc000f414, 0xcdc000f8, 0x00000000, 0xc1e1fffe, 0x59ddfff8,
+ 0x141c0000, 0xc0004010, 0xd14000f8, 0xc1c00000, 0xc000691c, 0xcdc000f8, 0xc0004040, 0xd28000f8,
+ 0x00000000, 0x00000000, 0xaa820618, 0xc0004a10, 0xd81c00f9, 0xc8c000f8, 0xc0000000, 0xc3c00000,
+ 0xa4fe0378, 0xc4fc0078, 0xcafc00f8, 0xddc000f9, 0xc8c000f8, 0x583c0004, 0x49020078, 0xc3400000,
+ 0xc6f40078, 0x4351a000, 0xc0000000, 0xca7400f8, 0xc1000000, 0xc4d20018, 0x7a6ce000, 0xa5fe0302,
+ 0x00000000, 0xc1c00002, 0xc0006920, 0xcdc000f8, 0xc1400000, 0xc4d68018, 0xc0c00000, 0xc64e6018,
+ 0x74d46000, 0x40d06000, 0x6cdc2000, 0x5b9c5fc0, 0x58380000, 0x49000078, 0x58380002, 0x49400078,
+ 0x6ce86000, 0x5aa84060, 0x41158000, 0xc1000000, 0xc6500078, 0x583c000c, 0xc94000f9, 0xc98000f8,
+ 0x00000000, 0x59540002, 0x4190c000, 0xcd8000f8, 0x5c000002, 0xcd4000f8, 0x58280000, 0xc94000f9,
+ 0xc98000f8, 0x00000000, 0x59540002, 0x4190c000, 0xcd8000f8, 0x5c000002, 0xcd4000f8, 0xc0000000,
+ 0xca3000f8, 0x98400b68, 0xc0800000, 0xc0004026, 0x49400078, 0x5dc80000, 0x84000062, 0xc0004022,
+ 0x49400078, 0xc13c0002, 0x76d0e000, 0xc65400fa, 0xc5141e02, 0x7e412000, 0xc657ff00, 0xc0000000,
+ 0xcd7400f8, 0x80000048, 0x98400c40, 0x00000000, 0x58300002, 0xc98000f8, 0xc0004044, 0xde83e000,
+ 0xc1c20002, 0xcdc02100, 0xc000404c, 0xc94000f8, 0x580c4d00, 0xc90000f8, 0xc1c00000, 0xc55d0038,
+ 0x451c8000, 0x88000062, 0xc0004a18, 0xc90000f8, 0xc1400002, 0x694ca000, 0x7550e000, 0x84000030,
+ 0x71148000, 0xc0004a18, 0xcd0000f8, 0xc000e400, 0xcd4000f8, 0x583c0004, 0x48c20078, 0xc1000000,
+ 0xc6d20138, 0x58cc0004, 0x450ce000, 0xc1c00000, 0xc5cc00fe, 0xccc01078, 0x8000fca8, 0xddc000f9,
+ 0x58000002, 0xc1c04a12, 0x45c0e000, 0x8800fc48, 0x80000248, 0x580c4d00, 0xc98000f8, 0x4514e000,
+ 0x88000028, 0xa63e0098, 0x58280008, 0xc0800002, 0x80000040, 0xc0004026, 0x49420078, 0xa63e0022,
+ 0x5828000c, 0x4594e000, 0x88000052, 0xc0800004, 0xc94000f9, 0xc98000f8, 0x00000000, 0x59540002,
+ 0x4190c000, 0xcd8000f8, 0x5c000002, 0xcd4000f8, 0x9c400000, 0x00000000, 0x00000000, 0x00000000,
+ 0x58340002, 0xc90000f8, 0xc1c00002, 0xc5e41f00, 0xc0004022, 0x49400078, 0xc0bc0002, 0x76c8e000,
+ 0xc61400fa, 0xc4941e02, 0x7ec0e000, 0xc5d7ff00, 0x58300002, 0xcd0000f8, 0x5c000002, 0xce4000f8,
+ 0x58340002, 0xcd8000f8, 0x5c000002, 0xcd4000f8, 0xc0000000, 0x497a0139, 0x49380078, 0xc1c00002,
+ 0x69cce000, 0xd9f00078, 0x580c4d00, 0xc98000f8, 0x59100004, 0x4550e000, 0xc1c00000, 0xc5d000fe,
+ 0x59980002, 0xcd8000f8, 0xc1c00002, 0xc0006920, 0xcdc000f8, 0xc1c00002, 0xc000691c, 0xcdc000f8,
+ 0xc0000000, 0x9c400000, 0xcd380078, 0x00000000, 0x5fb80002, 0xaa840d60, 0xc3c04aa0, 0xc3000000,
+ 0xdf300078, 0x7f018000, 0xc1c1fffe, 0x75f0e000, 0x84000d2a, 0xc7c000f8, 0xcb8000f9, 0x58000002,
+ 0xcb4000f8, 0xc0c00000, 0xc78e0078, 0x5dcc0000, 0x8400056a, 0x770d8000, 0x583c0004, 0x4ac00078,
+ 0x63014008, 0xa68a0542, 0x582c0000, 0x4a400078, 0x582c0004, 0x4a000078, 0xc0000000, 0x48efff00,
+ 0x42612000, 0xc92400f8, 0xc0004024, 0x49400000, 0x790ce000, 0xa5fe04e0, 0xc5780000, 0xa540010a,
+ 0x984013a8, 0x6e802000, 0x58005fc0, 0xc90000f9, 0xc0004044, 0xde83e000, 0xc1c40002, 0xcdc04200,
+ 0xc1e00002, 0x69e8e000, 0xd9f000f8, 0x6e8c6000, 0x58cc4060, 0x580c0004, 0xc90000f9, 0xc94000f8,
+ 0x00000000, 0x59100002, 0x4148a000, 0xcd4000f8, 0x5c000002, 0xcd0000f8, 0x582c0008, 0xc90000f9,
+ 0xc94000f8, 0x00000000, 0x59100002, 0x4148a000, 0xcd4000f8, 0x5c000002, 0xcd0000f8, 0x800003d0,
+ 0xc0004034, 0xc90000f8, 0xc0800006, 0xc0c00000, 0xc74f2020, 0xc1c00002, 0x69cce000, 0x75d0e000,
+ 0xc48be102, 0xc0c00000, 0xc74e8020, 0xc1c00002, 0x69cce000, 0x75d0e000, 0xc48be002, 0xc1c00000,
+ 0x583c0002, 0xcdc000f8, 0x5dc80000, 0x8400002a, 0x984015a8, 0xc0004022, 0x48c00078, 0xc1c00000,
+ 0xa7820098, 0x583c0006, 0x48c00078, 0xc0004034, 0x48800078, 0x7cc0e000, 0x771c8000, 0x75088000,
+ 0x5dd00000, 0x84000052, 0x984016a0, 0x00000000, 0x00000000, 0x00000000, 0x583c0006, 0xccc00078,
+ 0x63014008, 0xa68a0282, 0x00000000, 0xa7840138, 0xc0004036, 0x48c00078, 0x49020078, 0xc0800000,
+ 0x00000000, 0x61006028, 0x00000000, 0x00000000, 0x8400005a, 0xcd001078, 0x6cc04000, 0x58006840,
+ 0x58000000, 0x488000b8, 0x00000000, 0x00000000, 0x58000004, 0xcc8000b8, 0x8000ff70, 0xc0004036,
+ 0x48c00078, 0xc1400000, 0xc7960078, 0x583c0006, 0x49020078, 0x74d46000, 0x74f0a000, 0x7550e000,
+ 0x45d4e000, 0x84000028, 0x98401770, 0x00000000, 0x00000000, 0xc1000000, 0x98401830, 0x63006028,
+ 0xc4e800f8, 0xc1000000, 0x984013a8, 0x6e802000, 0x58005fc0, 0xc90000f9, 0xc0004044, 0xde83e000,
+ 0xc1c40002, 0xcdc04200, 0xc1e00002, 0x69e8e000, 0xd9f000f8, 0x6e8c6000, 0x58cc4060, 0x580c0004,
+ 0xc90000f9, 0xc94000f8, 0x00000000, 0x59100002, 0x4148a000, 0xcd4000f8, 0x5c000002, 0xcd0000f8,
+ 0x582c0008, 0xc90000f9, 0xc94000f8, 0x00000000, 0x59100002, 0x4148a000, 0xcd4000f8, 0x5c000002,
+ 0xcd0000f8, 0x984018d8, 0x00000000, 0x00000000, 0x00000000, 0xc0004044, 0xde83e000, 0xc1c40002,
+ 0xcdc04200, 0x5bfc0008, 0x5dfc4abe, 0x8800fa22, 0x80000768, 0x49420078, 0xc0c00000, 0xc50c0078,
+ 0x40d46000, 0xc1800000, 0xc51a0138, 0x59540004, 0x4594e000, 0xc1c00000, 0xc5d400fe, 0xcd401078,
+ 0xc0000000, 0xc92400f9, 0xc96400f8, 0x49efe000, 0xc98c00f9, 0xc88c00f8, 0x00000000, 0xc5d81f00,
+ 0xc1c00000, 0xc5d01f00, 0xcca400f8, 0x5e640002, 0xcda400f8, 0x49ee0138, 0xc0800000, 0xc5880078,
+ 0x5a200004, 0x45e0e000, 0xc1c00000, 0xc5e000fe, 0x59ec0004, 0xce1c0078, 0xcd4c00f8, 0x5ccc0002,
+ 0xcd0c00f8, 0x58284d00, 0xc90000f8, 0xc000404c, 0xc94000f8, 0x5d100002, 0x58284d00, 0xcd0000f8,
+ 0xc1c00000, 0xc55c0038, 0x45d0e000, 0x88000072, 0xc0004a18, 0xc90000f8, 0xc1400002, 0x6968a000,
+ 0x7550e000, 0x84000042, 0xc000e400, 0x6d5e0000, 0xcdc000f8, 0x7d40a000, 0x75148000, 0xc0004a18,
+ 0xcd0000f8, 0x9c400000, 0x00000000, 0x00000000, 0x00000000, 0xc1610000, 0xa4820040, 0xc1c00000,
+ 0xc75f2220, 0x59dc6840, 0x581c0006, 0x49400078, 0x583c0002, 0xcdc01078, 0xc1a10000, 0xa4800040,
+ 0xc1c00000, 0xc75e8220, 0x59dc6840, 0x581c0006, 0x49800078, 0x583c0002, 0xcdc00078, 0xc1c00000,
+ 0xc79d0038, 0x40dc6000, 0x7158e000, 0xa5defd32, 0x4594e000, 0xc59400fc, 0x454ce000, 0x8800fd12,
+ 0x9c400000, 0x00000000, 0x00000000, 0x00000000, 0x61014028, 0xc1c0003e, 0x45e8e000, 0x9c400004,
+ 0x6e802000, 0x58005fc0, 0x49c00079, 0x49420078, 0x6e884000, 0x58886840, 0x41d40000, 0x49400078,
+ 0x58080006, 0x49800078, 0xc0800000, 0xc7890038, 0x4148a000, 0xc0800002, 0x68a84000, 0x70c86000,
+ 0x4594e000, 0x8800ff58, 0x7c804000, 0x77098000, 0x74c86000, 0x8000ff38, 0x60c14028, 0xa68a009a,
+ 0x6e944000, 0x59546840, 0x58140004, 0x498000b8, 0x58140000, 0x488000b8, 0x58140004, 0xa5aeffb8,
+ 0xcc8000b8, 0xc1e1fe00, 0x719cc000, 0x4188c000, 0xa5aeff90, 0xcd8000b8, 0xc0000002, 0x68280000,
+ 0x71008000, 0x8000ff68, 0x9c400000, 0x00000000, 0x583c0006, 0xcd001078, 0xc0a000fe, 0x6cd44000,
+ 0x59546840, 0x58140004, 0x498000b8, 0xc1c1fffe, 0x709c4000, 0x4588e000, 0xc4e800fa, 0x9c400002,
+ 0x88000020, 0x4518e000, 0xc59000fc, 0xc4e800fc, 0x63006028, 0x5dcc0040, 0x8800ff8a, 0x9c400000,
+ 0x00000000, 0x00000000, 0x00000000, 0x583c0000, 0x48c10038, 0x6e904000, 0x59106840, 0xa78400a0,
+ 0x40c86000, 0xc0004036, 0x49400078, 0xc0800002, 0x68a84000, 0x7548e000, 0x8400006a, 0x58100004,
+ 0x498000b8, 0x583c0006, 0x49c20078, 0xc0000002, 0x68280000, 0x71c0e000, 0x583c0006, 0x458cc000,
+ 0xcdc0107e, 0x58100004, 0xcd8000b8, 0xa7820090, 0xc0800002, 0x68a84000, 0xc0004034, 0x49400078,
+ 0x58100006, 0x49800078, 0x7548e000, 0x84000052, 0x583c0006, 0x49400078, 0x458cc000, 0x58100006,
+ 0xcd800078, 0x7c80e000, 0x755ca000, 0x583c0006, 0xcd400078, 0x583c0002, 0xcb4000f8, 0x00000000,
+ 0x00000000, 0x5df40000, 0x9c400002, 0xc7560078, 0x5dd40000, 0x8400003a, 0x58140006, 0x49800078,
+ 0x00000000, 0x00000000, 0x458cc000, 0xcd800078, 0xc7540078, 0x5dd40000, 0x9c400002, 0x58140006,
+ 0x49800078, 0x00000000, 0x00000000, 0x458cc000, 0xcd800078, 0x9c400000, 0x00000000, 0x00000000,
+ 0x00000000, 0xc0006968, 0xcbc000f8, 0x00000000, 0x00000000, 0x5dfc0000, 0x84000042, 0x00000000,
+ 0x00000000, 0x00000000, 0x90406af9, 0x00000000, 0x00000000, 0x00000000, 0x90801b91, 0x00000000,
+ 0x00000000, 0x00000000, 0xc0004008, 0xc9c000f8, 0x00000000, 0x00000000, 0x5ddc0002, 0x8400167a,
+ 0xab64002a, 0xc3c00000, 0xab66001a, 0xc3c00002, 0x80001650, 0xc1c00002, 0xc000691c, 0xcdc000f8,
+ 0xc0004044, 0xde83e000, 0xc1d00002, 0xcdc10800, 0xc1c00002, 0xc0006920, 0xcdc000f8, 0x6ff8a000,
+ 0x5bb87d00, 0x58380004, 0xcb4000f8, 0xc2800000, 0x58380000, 0xca820008, 0xc000e824, 0xc3000000,
+ 0xcb3c0070, 0x6f5c8000, 0x41f4e000, 0x431d8000, 0x5b304000, 0xc000e828, 0xc1c00000, 0xc9fc0070,
+ 0x00000000, 0xc0004000, 0x41f4e000, 0x401c0000, 0xcac000f8, 0x5de80004, 0x84000d40, 0xa6c60caa,
+ 0x00000000, 0x6fe42000, 0xc6e4a000, 0x6e60a000, 0x5a207b00, 0xc1800000, 0x58200000, 0xc9800000,
+ 0xc2800000, 0xc6e80010, 0x5dd80000, 0x8400003a, 0x5de80008, 0xc6a82012, 0xc1c00004, 0x45e8e000,
+ 0x88000030, 0x800009f0, 0x5de80004, 0xc6a8010a, 0x5de80008, 0x840009d0, 0x58380000, 0xc1c00002,
+ 0xcdc00000, 0x58200000, 0xc1c00002, 0xcdc00000, 0x5de80002, 0xcdc00002, 0xc000ea14, 0xc1e20000,
+ 0xcdfe3100, 0xc000fb60, 0xc1c00002, 0xcdfc0000, 0xc0006940, 0xc9c000f8, 0x403c0000, 0x00000000,
+ 0x59dc0002, 0xcdc000f8, 0xc1c00004, 0x45e8e000, 0x8800020a, 0x58200020, 0xc9c000f8, 0xc0c00018,
+ 0xc1000000, 0xa5c0002a, 0xc1400080, 0x5de80000, 0xc6ccf930, 0xc54c1932, 0x5de80000, 0xc1c0000a,
+ 0xc5cc1230, 0xc5cc3202, 0x58200022, 0xc9c000f8, 0xc74c0b30, 0xc7cc0008, 0xc5cc0528, 0xc1800000,
+ 0xc6982000, 0xc1c00000, 0xc69c0000, 0x71d8e000, 0xc5cc0400, 0x984074c0, 0xc5d00000, 0x7d80e000,
+ 0xc5d00100, 0xc0406400, 0xc1c00000, 0xc4dca328, 0x405c2000, 0x5804000a, 0x49400078, 0xc0800000,
+ 0xc4ca4030, 0x5dd40004, 0x880000c8, 0x5dd40002, 0x8400005a, 0x6c9c4010, 0x431c0000, 0xc94000f8,
+ 0xc1c00000, 0xc49c0308, 0x695ca000, 0x6d570010, 0x5804000a, 0xcd401838, 0x58880002, 0x6c9c4010,
+ 0x431c0000, 0xc94000f8, 0xc1c00000, 0xc49c0308, 0x695ca000, 0x6d570010, 0x5804000a, 0xcd401038,
+ 0x5804000a, 0xc1c00004, 0xcdc00078, 0x5dd80002, 0x84000710, 0xc1c00000, 0xc6ddc030, 0x59dc0006,
+ 0xc5ec0e30, 0xc0c00018, 0xc1000004, 0x59dc0002, 0xc5cc1230, 0xc74c0b30, 0xc7cc0008, 0xc0000088,
+ 0x441ce000, 0xc5cc1930, 0xa6cc04f0, 0x583cfac0, 0xc94000f8, 0xc1c80002, 0x70dc6000, 0xa55000c2,
+ 0x58380024, 0xc94000f8, 0x00000000, 0x00000000, 0x59540002, 0x58380024, 0xcd4000f8, 0xc0c00010,
+ 0x984074c0, 0xc74c0b30, 0xc7cc0008, 0xc1000004, 0x58200000, 0xc1c00000, 0xcdc00000, 0x58380026,
+ 0xc94000f8, 0x00000000, 0x00000000, 0x59540002, 0x58380026, 0xcd4000f8, 0x80000408, 0xc1400000,
+ 0xc6d5c030, 0x5d540002, 0x6d5c4010, 0x431c0000, 0xc88000f8, 0xc1c00000, 0xc55c0008, 0xc0000006,
+ 0x441ce000, 0x6ddc6000, 0x689c4010, 0xc1c001fe, 0x749c4000, 0x59540002, 0xc1c000fe, 0x749c4000,
+ 0x5c880020, 0xc48c1930, 0x5dc80002, 0x8800fee2, 0xc1c0007c, 0x45c8e000, 0x8800feca, 0x4148c000,
+ 0x59980002, 0x5dd80088, 0x8800002a, 0x58200000, 0xc1c00000, 0xcdc00000, 0x800000c8, 0xc1400000,
+ 0x6d9c4010, 0x431c0000, 0xc94000f8, 0xc1c00000, 0xc59c0008, 0xc0000006, 0x441ce000, 0x6ddc6000,
+ 0x695ca010, 0xc1c001fe, 0x755ca000, 0x00000000, 0x00000000, 0x5dd40000, 0x84000018, 0x59980002,
+ 0x8000ff48, 0x59980002, 0xc0800002, 0x5dd400a0, 0xc4902100, 0xc4ac2602, 0x4588c002, 0xc1c008f2,
+ 0xc000696a, 0xcdc000f8, 0xdbc800f9, 0xda4800f8, 0xda1000f9, 0x90406851, 0x00000000, 0x00000000,
+ 0x00000000, 0x58200020, 0xc9c000f8, 0x58200022, 0xc94000f8, 0x5ddc0002, 0xc1c00000, 0xc5cc1932,
+ 0xc6ddc030, 0x59dc0002, 0x984074c0, 0xc5cc1230, 0xc54c0528, 0xc4d08000, 0xc0800000, 0xc4ca4030,
+ 0x5dc80088, 0x88000100, 0xc0406400, 0xc1c00000, 0xc4dca328, 0x405c2000, 0x6c9c4010, 0x431c0000,
+ 0xc94000f8, 0xc1c00000, 0xc49c0308, 0x695ca000, 0x6d570010, 0x5804000a, 0xcd401838, 0x5804000a,
+ 0xc1c00002, 0xcdc00078, 0x58880002, 0x5dc80088, 0x88000068, 0x6c9c4010, 0x431c0000, 0xc94000f8,
+ 0xc1c00000, 0xc49c0308, 0x695ca000, 0x6d570010, 0x5804000a, 0xcd401038, 0x5804000a, 0xc1c00004,
+ 0xcdc00078, 0xa5020072, 0xc1c00002, 0xc5d00100, 0xc5ac0e30, 0xa6ccfc52, 0xc1c00000, 0xc5cc0400,
+ 0xc1c00086, 0x45d8e000, 0xc5cc1930, 0x8000fde0, 0x00000000, 0x00000000, 0x00000000, 0x800001b8,
+ 0xc1c00984, 0xc000696a, 0xcdc000f8, 0xdbc800f9, 0xda4800f8, 0xda1000f9, 0x90406851, 0x00000000,
+ 0x00000000, 0x00000000, 0x58200022, 0xc98000f8, 0x58200020, 0xc9c000f8, 0x00000000, 0x984074c0,
+ 0x5ddc0002, 0xc58c0528, 0xc5cc1932, 0xc0800000, 0xc4ca4030, 0x5dc80088, 0x88000100, 0xc0406400,
+ 0xc1c00000, 0xc4dca328, 0x405c2000, 0x6c9c4010, 0x431c0000, 0xc94000f8, 0xc1c00000, 0xc49c0308,
+ 0x695ca000, 0x6d570010, 0x5804000a, 0xcd401838, 0x5804000a, 0xc1c00002, 0xcdc00078, 0x58880002,
+ 0x5dc80088, 0x88000068, 0x6c9c4010, 0x431c0000, 0xc94000f8, 0xc1c00000, 0xc49c0308, 0x695ca000,
+ 0x6d570010, 0x5804000a, 0xcd401038, 0x5804000a, 0xc1c00004, 0xcdc00078, 0x80000228, 0xc1400000,
+ 0xc000403e, 0xc9400000, 0xc1800000, 0x58200000, 0xc9800000, 0x5dd40002, 0x84000020, 0x5dd80002,
+ 0x84000010, 0x80000138, 0x5de80006, 0x84000088, 0x58380000, 0xc1c00002, 0xcdc00000, 0xc000ea14,
+ 0xc1e20000, 0xcdfe3100, 0xc000fb60, 0xc1c20002, 0xcdfc2100, 0xc0006944, 0xc9c000f8, 0x403c0000,
+ 0x00000000, 0x59dc0002, 0xcdc000f8, 0x80000118, 0x5de8000a, 0x84000098, 0x58380000, 0xc1c00000,
+ 0xcdc00000, 0xc000ea14, 0xc0004008, 0xc9c000f8, 0x00000000, 0x00000000, 0xc000ea14, 0x7dc0e000,
+ 0xcdfe3100, 0xc000fb60, 0xc1c20002, 0xcdfc2100, 0xc000facc, 0xc1c00002, 0xcdfc0000, 0x80000078,
+ 0xa6ca0040, 0xc000facc, 0xc1ca0002, 0xcdfca500, 0xc000fb64, 0xc1c60002, 0xcdfc6300, 0x80000038,
+ 0xc000facc, 0xc1c80002, 0xcdfc8400, 0xc000fb64, 0xc1c40002, 0xcdfc4200, 0xc0c00010, 0x984074c0,
+ 0xc7cc0008, 0xc74c0b30, 0xc1000004, 0x80000830, 0xc1c00002, 0x58380008, 0xcdc000f8, 0x58380000,
+ 0xc1e00006, 0xcdc21008, 0xc000facc, 0xc1c80002, 0xcdfc8400, 0xc000fb64, 0xc1c40002, 0xcdfc4200,
+ 0xc0c00010, 0x984074c0, 0xc7cc0008, 0xc74c0b30, 0xc1000004, 0x800007a0, 0x5de80006, 0x84000198,
+ 0xa6c60032, 0x00000000, 0x58380000, 0xc1e00004, 0xcdc21008, 0x8000f2a0, 0x58380008, 0xca8000f8,
+ 0xc2400000, 0x58380002, 0xca420078, 0x00000000, 0x5aa80002, 0x58380008, 0xce8000f8, 0x46a4e000,
+ 0x880000b2, 0x58380000, 0xc1e00002, 0xcdc21008, 0x58380000, 0xc1c00000, 0xcdc00000, 0xc000facc,
+ 0xc1c20002, 0xcdfc2100, 0xc1e1e1a2, 0xc000ea1c, 0xcdfc00f8, 0xc000ea14, 0xc0004008, 0xc9c000f8,
+ 0x00000000, 0x00000000, 0xc000ea14, 0x7dc0e000, 0xcdfe3100, 0x80000038, 0xc000facc, 0xc1c80002,
+ 0xcdfc8400, 0xc000fb64, 0xc1c40002, 0xcdfc4200, 0xc0c00010, 0x984074c0, 0xc7cc0008, 0xc74c0b30,
+ 0xc1000004, 0x80000600, 0x5de80002, 0x84000150, 0xa6c6004a, 0x00000000, 0x58380000, 0xc1e00004,
+ 0xcdc21008, 0xc1f8001e, 0xc000ea1c, 0xcdfc00f8, 0x8000f0e8, 0x58380008, 0xca8000f8, 0xc2400000,
+ 0x58380002, 0xca400078, 0xc000facc, 0xc1c20002, 0xcdfc2100, 0x5aa80002, 0x58380008, 0xce8000f8,
+ 0x46a4e000, 0x88000072, 0x58380000, 0xc1e00000, 0xcdc21008, 0xc1c00000, 0x58380006, 0xcdc000f8,
+ 0xc000e82c, 0xc1c00000, 0xcdfdce00, 0xc000e820, 0xc1c00000, 0xcdfc0000, 0x80000300, 0xc0c00010,
+ 0x984074c0, 0xc7cc0008, 0xc74c0b30, 0xc1000004, 0x800004a8, 0x5838001c, 0xca8000f8, 0x5838001e,
+ 0xca4000f8, 0x5aa80002, 0x5838001c, 0xce8000f8, 0x4668e000, 0x88000098, 0x58380022, 0xca4000f8,
+ 0x58380020, 0xca0000f8, 0xc000e82c, 0xc1c00000, 0xcdfdce00, 0xc000e810, 0xce7c0030, 0xc2800000,
+ 0x5838001c, 0xce8000f8, 0x5a200002, 0x58380020, 0xce0000f8, 0xc000e82c, 0xc1dc0002, 0xcdfdce00,
+ 0x58380006, 0xc8c000f8, 0x5830001c, 0xca8000f9, 0xca4000f9, 0xc2000000, 0xca000001, 0x5dcc0006,
+ 0x88000028, 0x58cc0002, 0x58380006, 0xccc000f8, 0x80000250, 0x5838000a, 0xc8c000f9, 0xc90000f9,
+ 0xc1400000, 0xc9400001, 0x74e86000, 0x75248000, 0x7560a000, 0x58380010, 0xca8000f9, 0xca4000f9,
+ 0xc2000000, 0xca000001, 0x98407690, 0x74e86000, 0x75248000, 0x7560a000, 0x5dc800a0, 0x840001ba,
+ 0x58380016, 0xca8000f9, 0xca4000f9, 0xc2000000, 0xca000001, 0x98407690, 0x74e86000, 0x75248000,
+ 0x7560a000, 0x5dc800a0, 0x84000162, 0x58380000, 0xc1e00004, 0xcdc21008, 0x5838001c, 0xc1c00000,
+ 0xcdc000f8, 0xc000e82c, 0xc1c00000, 0xcdfdce00, 0xc1f8001e, 0xc000ea1c, 0xcdfc00f8, 0xc000e820,
+ 0xc1c00002, 0xcdfc0000, 0xc1c00082, 0x45c8e000, 0xc000e810, 0xcdfc0030, 0xc2400000, 0xc000e82c,
+ 0xca7c0038, 0xc000e83c, 0xc2800000, 0xcabc0038, 0xc0c00010, 0x984074c0, 0xc7cc0008, 0xc74c0b30,
+ 0xc1000004, 0x5b740002, 0x4674e000, 0xc1c00000, 0xc5f400fe, 0x5ea80002, 0x8400ffb0, 0xc000e83c,
+ 0xc1c00000, 0xcdfc0038, 0xc000e82c, 0xc1dc0002, 0xcdfdce00, 0x80000178, 0x58380010, 0xca8000f9,
+ 0xca4000f9, 0xc2000000, 0xca000001, 0x58380016, 0xce8000f9, 0xce4000f9, 0xce000001, 0x5838000a,
+ 0xca8000f9, 0xca4000f9, 0xc2000000, 0xca000001, 0x58380010, 0xce8000f9, 0xce4000f9, 0xce000001,
+ 0x5830001c, 0xca8000f9, 0xca4000f9, 0xc2000000, 0xca000001, 0x5838000a, 0xce8000f9, 0xce4000f9,
+ 0xce000001, 0xc000facc, 0xc1c20002, 0xcdfc2100, 0xc0c00010, 0x984074c0, 0xc7cc0008, 0xc74c0b30,
+ 0xc1000004, 0xc000e83c, 0xc1d00002, 0xcdfd0800, 0xc0c00000, 0xc000e82c, 0xc8fc0038, 0x5b740002,
+ 0x00000000, 0x44f4e000, 0xc1c00000, 0xc5f400fe, 0x58380004, 0xcf4000f8, 0x90003251, 0x00000000,
+ 0x00000000, 0x00000000, 0x98407768, 0xc1c00000, 0xc00068f4, 0xcdc000f8, 0x98408e68, 0xc0007d00,
+ 0xcac000f8, 0x58000040, 0xc000fb80, 0x4b000010, 0xc000fba0, 0x4ac00010, 0xc3800000, 0xc7384000,
+ 0xc6f84100, 0x5df80000, 0x840002f2, 0xc0c00000, 0xc1000000, 0xc70c0000, 0xc7102000, 0x74d1a000,
+ 0xc6cc0000, 0xc6d02000, 0x74d0e000, 0xc000fb84, 0x4bc00000, 0xc5f40100, 0x7779a000, 0xc000fb82,
+ 0x4a800000, 0x5dfc0002, 0x84000062, 0x5de80002, 0x84000262, 0x4778e000, 0x84000250, 0xc1c00002,
+ 0xc000fb84, 0xcdc00000, 0xc1c00000, 0xc0004008, 0xcdc000f8, 0x80000218, 0xc0004008, 0xc9c000f8,
+ 0x00000000, 0x00000000, 0x5ddc0002, 0x840001ea, 0x4778e000, 0x84000018, 0x5de80002, 0x840001c8,
+ 0xc0004024, 0x4a820078, 0xc1c00002, 0xc0004008, 0xcdc000f8, 0x6ea86000, 0xc1c00000, 0xd9c000f9,
+ 0xda800078, 0xc1c00004, 0xd9c000f9, 0xc000ea14, 0xc1c00000, 0xcdc23101, 0xcdc23100, 0x80000148,
+ 0xc000ea28, 0x48c00038, 0xc000ea2a, 0x49000038, 0x5dcc0000, 0x840000a8, 0x5dd00000, 0x84000098,
+ 0xc0c04f30, 0x580c000a, 0xc90000f8, 0x580c0008, 0x4a400008, 0x5dd00000, 0x84000060, 0x5de40006,
+ 0x84000050, 0xc000696e, 0xc8c000f8, 0xc1c00000, 0xc000fb84, 0xcdc00000, 0x58cc0002, 0xc000696e,
+ 0xccc000f8, 0x80000058, 0xc0004024, 0x4a820078, 0x00000000, 0x00000000, 0x6ea86000, 0xc1c00000,
+ 0xd9c000f9, 0xda800078, 0xc1c00004, 0xd9c000f9, 0x9c400000, 0x00000000, 0x00000000, 0x00000000,
+ 0x984089c8, 0xc3c04ac0, 0x583c0000, 0x4b800008, 0xc3c00000, 0x6ff8a000, 0x5bb87d80, 0xc1c00002,
+ 0xc000691c, 0xcdc000f8, 0x583cfb50, 0xc2800000, 0xca80c030, 0xc2400000, 0x58380000, 0xca400078,
+ 0x58380006, 0xca0000f8, 0x583cea28, 0xc9c000f8, 0xc0c00000, 0x00000000, 0xc5cc0038, 0x420c8000,
+ 0x4268a000, 0x4514e000, 0x8800012a, 0x58380004, 0xca4000f8, 0x5de00080, 0x8800007a, 0xc000ea28,
+ 0xc1d2007e, 0xcdfd2928, 0xc000ea28, 0xc1d00002, 0xcdfd0800, 0x5de0007e, 0xc000ea28, 0x6ddd2000,
+ 0xcdfd2928, 0xc000ea28, 0xc1d00002, 0xcdfd0800, 0x80000038, 0xc000ea28, 0x6e1d2000, 0xcdfd2928,
+ 0xc000ea28, 0xc1d00002, 0xcdfd0800, 0x583c6948, 0xc9c000f8, 0x00000000, 0x00000000, 0x41e0e000,
+ 0xcdc000f8, 0x46612000, 0x58380004, 0xce4000f8, 0x58380006, 0xc1c00000, 0xcdc000f8, 0x58380004,
+ 0xca4000f8, 0x583cea28, 0xc9c000f8, 0xc0c00000, 0x00000000, 0xc5cc0038, 0xc1400000, 0x58380000,
+ 0xc9420078, 0x424d0000, 0x00000000, 0x42948000, 0x4520e000, 0x8800143a, 0xc000fa40, 0xc9bc00f8,
+ 0x6ff42000, 0xc3000000, 0xc5b4e000, 0xc2c07c00, 0x6f5ca000, 0x42dd6000, 0x582c0022, 0xc98000f8,
+ 0x00000000, 0x00000000, 0x5dd80000, 0x840003d2, 0x582c0026, 0xca8000f8, 0x5838000a, 0xc98000f8,
+ 0xc000ea10, 0xc2400000, 0xca7c0070, 0x6d9c8000, 0x41d8e000, 0x425d2000, 0x5a644000, 0x582c0032,
+ 0xc9c000f8, 0x582c002e, 0xc98000f8, 0x582c0030, 0xc94000f8, 0x00000000, 0x41d8e000, 0x41d4e000,
+ 0xd9f800f8, 0x5ddc0080, 0x880000a2, 0x00000000, 0xa7400018, 0xc180001e, 0xc180015e, 0xc1400000,
+ 0x6d5c4010, 0x425c0000, 0xc1c00006, 0x755c8000, 0x5dd00000, 0xcd80183a, 0x5dd00002, 0xcd80103a,
+ 0x5dd00004, 0xcd80083a, 0x5dd00006, 0xcd80003a, 0x5b300008, 0x80000278, 0x58240002, 0xc1800000,
+ 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9,
+ 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9,
+ 0xa7400018, 0xc18001e0, 0xc18001ea, 0xc1400000, 0x6d5c4010, 0x425c0000, 0xc90000f8, 0xc1c00000,
+ 0xc55c0308, 0x691c8008, 0xc5901838, 0x691c8018, 0xcd0000f8, 0x6d5c4010, 0x425c0000, 0xc1c00006,
+ 0x755c8000, 0x5dd00000, 0xcd80183a, 0x5dd00002, 0xcd80103a, 0x5dd00004, 0xcd80083a, 0x5dd00006,
+ 0xcd80003a, 0x5b300008, 0xdf9400f8, 0xc1009540, 0x6d5c4010, 0x411c0000, 0xc98000f8, 0xc1c00000,
+ 0xc55c0308, 0x699cc000, 0x6d9b0010, 0x6f1c4010, 0x425c0000, 0xc94000f8, 0xc1c00000, 0xc71c0308,
+ 0x695ca008, 0xc5941838, 0x695ca018, 0xcd4000f8, 0x6f1c4010, 0x425c0000, 0xc1c00006, 0x771ca000,
+ 0x5dd40000, 0xcd80183a, 0x5dd40002, 0xcd80103a, 0x5dd40004, 0xcd80083a, 0x5dd40006, 0xcd80003a,
+ 0x5b300002, 0x582c0022, 0xc1c00000, 0xcdc000f8, 0x80000958, 0xc2805c00, 0x6f5c6000, 0x429d4000,
+ 0x58280008, 0xc90000f8, 0x5828000c, 0xc8c000f8, 0xc68000f8, 0xca4000f8, 0x450ce000, 0x84000e82,
+ 0x58280004, 0x48820078, 0x58280002, 0x48400078, 0xc1c00000, 0xc65c0078, 0x41c90000, 0xc60000f8,
+ 0xc90000f9, 0xc94000f9, 0x58cc0002, 0x7924e000, 0xa5fe0e1a, 0x582c0032, 0xc1c00000, 0xcdc000f8,
+ 0x582c002a, 0xce0000f8, 0x582c0034, 0xcd0000f8, 0x582c0036, 0xcd4000f8, 0xa9440050, 0xa946004a,
+ 0x6c9c2010, 0x405c0000, 0xc98000f8, 0x582c0032, 0xc1c00004, 0xcdc000f8, 0x582c0038, 0xcd8000f8,
+ 0x5828000c, 0xccc000f8, 0x5828000e, 0xc94000f8, 0xc1800000, 0xc5180078, 0x4158a000, 0x5828000e,
+ 0xcd4000f8, 0xc1400000, 0xc6560138, 0x58880004, 0x4548e000, 0xc1c00000, 0xc5c800fe, 0x58280004,
+ 0xcc801078, 0xc0004044, 0xde83e000, 0xc1ce0002, 0xcdc0e700, 0xc0006910, 0xc8c000f9, 0xc90000f8,
+ 0xc1c00000, 0xc1400040, 0x60c04000, 0x7494e000, 0x8400007a, 0xc1400080, 0x61004000, 0x58880040,
+ 0x7494e000, 0x84000052, 0x00000000, 0xab6c0002, 0x00000000, 0x00000000, 0x98406ee0, 0xc0006902,
+ 0xc8c000f8, 0xc3c00000, 0x8000ff58, 0xc0006910, 0xc1c00000, 0xc49ca000, 0x401c0000, 0xc8c000f8,
+ 0xc1000002, 0xc1400000, 0xc4940020, 0x6914e000, 0x70dc6000, 0xccc000f8, 0x582c0020, 0xcc8000f8,
+ 0xc1c00002, 0x582c0022, 0xcdc000f8, 0xc2409c00, 0x6c9c6000, 0x425d2000, 0xc2807600, 0x6c9c6000,
+ 0x429d4000, 0x582c002c, 0xc98000f8, 0x582c0026, 0xce8000f8, 0x582c0028, 0xce4000f8, 0x58240008,
+ 0xcd8000f8, 0x5838000a, 0xc98000f8, 0xc000ea10, 0xc2000000, 0xca3c0070, 0x6d9c8000, 0x41d8e000,
+ 0x421d0000, 0x5a204000, 0x582c002a, 0xc98000f8, 0xc1400000, 0xc1000000, 0xc58000f8, 0xc9c000f8,
+ 0x5824000a, 0xcd8000f8, 0x5824000c, 0xcdc000f8, 0x59ac0034, 0x58180000, 0xc942e010, 0x58180002,
+ 0xc90000f8, 0x58280002, 0xc1c00000, 0xcdc00078, 0x41148000, 0x58280004, 0xcd0000e0, 0x58a40000,
+ 0x586c0008, 0xc44000f8, 0xc8c000f9, 0xc90000f9, 0xc94000f8, 0xc48000f8, 0xccc000f9, 0xcd0000f9,
+ 0xcd4000f9, 0x5df00000, 0x84000138, 0x58200000, 0xc1800000, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9,
+ 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9,
+ 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xc18001ea, 0xc1c00002,
+ 0x75f4e000, 0xc1c001e0, 0xc5d800fa, 0xc1400000, 0x6d5c4010, 0x421c0000, 0xc1c00006, 0x755c8000,
+ 0x5dd00000, 0xcd80183a, 0x5dd00002, 0xcd80103a, 0x5dd00004, 0xcd80083a, 0x5dd00006, 0xcd80003a,
+ 0x5b300008, 0xc000fa40, 0xc93c00f8, 0xc1400000, 0x582c0002, 0xc9428018, 0xc0400000, 0xc0800080,
+ 0x44944000, 0xc45800f8, 0xc1c00200, 0x75d0e000, 0xc49c00f8, 0xc5d800fa, 0x582c0030, 0xcd4000f8,
+ 0xd97800f8, 0x59ec0034, 0xc0c00000, 0x582c0002, 0xc8c10038, 0xc1000000, 0x581c0000, 0xc9000078,
+ 0x00000000, 0x00000000, 0xc50800f8, 0x4518e000, 0xc59c00f8, 0xc5c800fc, 0xc4d400f8, 0x44c8e000,
+ 0xc49c00f8, 0xc5d400fc, 0x582c002e, 0xcd4000f8, 0x582c0032, 0xc88000f8, 0xdf9000f8, 0x4150e000,
+ 0x41c8e000, 0xd9f800f8, 0x41f0e000, 0x5ddc0086, 0x88000082, 0xc18000a0, 0x6f1c4010, 0x421c0000,
+ 0xc1c00006, 0x771ca000, 0x5dd40000, 0xcd80183a, 0x5dd40002, 0xcd80103a, 0x5dd40004, 0xcd80083a,
+ 0x5dd40006, 0xcd80003a, 0x5b300002, 0x80000158, 0x00000000, 0x00000000, 0x00000000, 0xdf9400f8,
+ 0xc1009540, 0x6d5c4010, 0x411c0000, 0xc98000f8, 0xc1c00000, 0xc55c0308, 0x699cc000, 0x6d9b0010,
+ 0x6f1c4010, 0x421c0000, 0xc1c00006, 0x771c6000, 0x5dcc0000, 0xcd80183a, 0x5dcc0002, 0xcd80103a,
+ 0x5dcc0004, 0xcd80083a, 0x5dcc0006, 0xcd80003a, 0x5b300002, 0xc18000a0, 0x6f1c4010, 0x421c0000,
+ 0xc1c00006, 0x771ca000, 0x5dd40000, 0xcd80183a, 0x5dd40002, 0xcd80103a, 0x5dd40004, 0xcd80083a,
+ 0x5dd40006, 0xcd80003a, 0x5b300002, 0x582c0022, 0xc1c00000, 0xcdc000f8, 0x00000000, 0x5df00088,
+ 0x88000578, 0x582c0032, 0xca0000f8, 0x582c0038, 0xc8c000f8, 0x5de00000, 0x8400004a, 0x582c0020,
+ 0xc98000f8, 0x98404928, 0xc2840002, 0xc5a80528, 0xc2400000, 0x5df00088, 0x88000508, 0x582c0020,
+ 0xc98000f8, 0xc2800000, 0xc2400000, 0xc5a80528, 0x582c002e, 0xc98000f8, 0xc1000088, 0x45308000,
+ 0xc51400f8, 0x4590e000, 0xc59c00f8, 0xc5d400fc, 0xc5681930, 0x5838000a, 0xc90000f8, 0xc7281230,
+ 0xc7e80008, 0xc5280b30, 0xd93800f8, 0xc1c00002, 0xc5e80400, 0x4594e000, 0x8400001a, 0xc1c00000,
+ 0xc5e80400, 0x5dd80000, 0x8400002a, 0xc1c00002, 0xc5e80300, 0xc1c00002, 0xc5e80200, 0x582c0022,
+ 0xc94000f8, 0xc7640e08, 0x00000000, 0x5d540002, 0x8400001a, 0xc1c00002, 0xc5e40d00, 0xc0c00000,
+ 0xc68f2030, 0x430c8000, 0xc5241838, 0xc0800088, 0x44904000, 0xc1c00000, 0xc5c800fc, 0x582c0030,
+ 0xc94000f8, 0xc0400000, 0x582c0002, 0xc8420018, 0xc49000f8, 0x4548e000, 0xc55c00f8, 0xc5d000fc,
+ 0xc5241418, 0x44546000, 0xc4e41018, 0x4550a000, 0x582c0030, 0xcd4000f8, 0xc0c00000, 0xc68f2030,
+ 0x458cc000, 0x582c002e, 0xcd8000f8, 0x43118000, 0x430d8000, 0xdf9800f8, 0xc000ea10, 0xc1400000,
+ 0xc97c0070, 0x6d9c8000, 0x41d8e000, 0x415ca000, 0x59544000, 0x00000000, 0xc1000000, 0xc0000000,
+ 0xc9140038, 0x00000000, 0x00000000, 0x59100002, 0xcd140038, 0x984075a8, 0xc68c00f8, 0xc65000f8,
+ 0x00000000, 0x5df00088, 0x8800f35a, 0x00000000, 0x80000218, 0xd87800f8, 0xc1000088, 0x45308000,
+ 0xc51400f8, 0x4610e000, 0xc61c00f8, 0xc5d400fc, 0xc5681930, 0x46150000, 0x582c0032, 0xce0000f8,
+ 0xc56000f8, 0x5838000a, 0xc94000f8, 0xc7281230, 0xc7e80008, 0xc5680b30, 0xc000ea10, 0xc1000000,
+ 0xc93c0070, 0x6d5c8000, 0x41d4e000, 0x411c8000, 0x59104000, 0x6f1c4010, 0x411c0000, 0xc94000f8,
+ 0xc1c00000, 0xc71c0308, 0x695ca008, 0xc4d71838, 0x695ca018, 0xcd4000f8, 0x5b300002, 0x5e200002,
+ 0x84000062, 0x6ccd0000, 0x6f1c4010, 0x411c0000, 0xc94000f8, 0xc1c00000, 0xc71c0308, 0x695ca008,
+ 0xc4d71838, 0x695ca018, 0xcd4000f8, 0x5b300002, 0x6ccd0000, 0x582c0038, 0xccc000f8, 0xc1400000,
+ 0xc0000000, 0xc9500038, 0x00000000, 0x00000000, 0x59540002, 0xcd500038, 0xdfa000f8, 0x984075a8,
+ 0xc68c00f8, 0xc65000f8, 0x00000000, 0x9e000000, 0x00000000, 0x00000000, 0x00000000, 0x5df00000,
+ 0x840000f2, 0xc1c00002, 0xc000691c, 0xcdc000f8, 0xc0004044, 0xde83e000, 0xc1ce0002, 0xcdc0e700,
+ 0xc1c00002, 0xc0006920, 0xcdc000f8, 0x5838000a, 0xc94000f8, 0xc1000000, 0xc000ea14, 0xc93c0038,
+ 0x59540002, 0x00000000, 0x4514e000, 0xc1c00000, 0xc5d400fe, 0x5838000a, 0xcd4000f8, 0x58380004,
+ 0xc94000f8, 0x00000000, 0x00000000, 0x59540002, 0x58380004, 0xcd4000f8, 0x5df00000, 0x84000058,
+ 0xa7400020, 0x00000000, 0x6ff42000, 0x8000ec00, 0x5bfc0002, 0x5dfc0002, 0x8400e97a, 0x00000000,
+ 0x00000000, 0x00000000, 0xab6c0052, 0x98406ee0, 0xc0006902, 0xc8c000f8, 0xc3c00000, 0xab6c002a,
+ 0x98406ee0, 0xc0006902, 0xc8c000f8, 0xc3c00000, 0x98408e68, 0xc0007d00, 0xcac000f8, 0x58000040,
+ 0x984089c8, 0xc3c04ac0, 0x583c0000, 0x4b800008, 0xaa900bd0, 0xc3c05e00, 0xc7c000f8, 0xcb8000f8,
+ 0x583c0008, 0xcac000f8, 0xc3400000, 0xc7b40078, 0x5df40000, 0x84000b8a, 0xc74000f8, 0xcb0000f8,
+ 0xc000ec00, 0xde83e000, 0x4a400020, 0x583c001e, 0xca0000f8, 0x5de40004, 0x8800009a, 0x583c0008,
+ 0x4ac00078, 0x583c001c, 0xc9c000f8, 0xa7be0022, 0x00000000, 0x45e0e000, 0x8400005a, 0x58340008,
+ 0xc9c000f8, 0x00000000, 0x00000000, 0x45e0e000, 0x8400002a, 0x98405140, 0xc0800000, 0x58340000,
+ 0x48c00078, 0x583c001c, 0xca4000f8, 0x583c0002, 0xcac000f8, 0x00000000, 0xc2800000, 0xc6eba010,
+ 0x583c0014, 0xc80000f8, 0x5de80004, 0x84000058, 0xa43e01f2, 0x00000000, 0x984053c0, 0x58fc0020,
+ 0xc1000000, 0xc6d00078, 0xc0004044, 0xde83e000, 0xc1c00002, 0xcdc00000, 0x5de80000, 0x84000198,
+ 0xc0c00000, 0xc1000000, 0xa7be0082, 0xc7120038, 0xa7bc0170, 0x4660a000, 0x4514a000, 0xc1c00010,
+ 0x45d4e000, 0x88000148, 0xc1400000, 0xc6d40078, 0x6d542010, 0x4514a000, 0xc0c00008, 0x454ce000,
+ 0xc54c00fc, 0x80000070, 0x4624a000, 0x6d182010, 0x4558e000, 0x880000ea, 0xc1800000, 0xc6d80078,
+ 0x6d982010, 0x4518c000, 0xc0c00008, 0x458ce000, 0xc58c00fc, 0x5dcc0000, 0x840000a2, 0x6ccc2000,
+ 0xc4ec1060, 0xc1c00004, 0xc5ec1d10, 0x984057a0, 0x583c000e, 0xc8c000f8, 0xc1216000, 0x583c0018,
+ 0xc8c000f8, 0x583c0002, 0xcec000f8, 0x58cc0002, 0x583c0018, 0xccc000f8, 0xc0004044, 0xde83e000,
+ 0xc1c00002, 0xcdc00000, 0x5bfc0040, 0x5dfc5f7e, 0x8800fc92, 0x88000848, 0xc6cc0078, 0xc6d20060,
+ 0xc7160138, 0x40d06000, 0x454ce000, 0x78cc6006, 0x6d1c2010, 0x421d0000, 0x583c001e, 0xce0000f8,
+ 0xc4ec0078, 0xc1000000, 0xc52c1060, 0xc2800000, 0x9c400000, 0xc6ac1d10, 0x583c0008, 0xcec000f8,
+ 0x583c000e, 0xca8000f8, 0xc1c00000, 0xc71e0138, 0x40dc8000, 0x45ece000, 0x7aed6006, 0x583c0002,
+ 0x48000078, 0xa7be0022, 0xc6dc0078, 0x45c0e000, 0x40c08006, 0xc000ec04, 0xde83e000, 0xce8000f8,
+ 0xc1c0c000, 0xc69c4050, 0xc5e800f8, 0xdeabeb00, 0xc0000000, 0x40ec6000, 0xc94c00f9, 0xc98c00f9,
+ 0x42ad4000, 0x7970e000, 0x79f8e000, 0xa5fe0180, 0x00000000, 0x5aec0004, 0x58880002, 0x5a200002,
+ 0x58280002, 0xc0004a0e, 0x49c00000, 0x00000000, 0x58280002, 0x5ddc0000, 0x8400006a, 0xc1e04000,
+ 0x459cc000, 0xa7be001a, 0x00000000, 0x7f80e000, 0xc5d61f00, 0xc1c0000e, 0xc5d41c10, 0x80000038,
+ 0x00000000, 0x00000000, 0x00000000, 0xc1c00000, 0xc79ffd00, 0x459cc000, 0xcd8000f8, 0x58280000,
+ 0xcd4000f8, 0x44d0e000, 0x88000088, 0x5aa80004, 0x5e640004, 0x5de40004, 0x8800006a, 0xa7be0040,
+ 0x00000000, 0x58340008, 0xc9c000f8, 0x00000000, 0x00000000, 0x45e0e000, 0x8400002a, 0xc0000000,
+ 0xc94c00f9, 0xc98c00f9, 0x8000fe78, 0x583c001e, 0x9c400000, 0xce0000f8, 0x583c0008, 0xcec00078,
+ 0xc1c00000, 0xc71c0078, 0x411c8000, 0xc1400000, 0xc6d60060, 0xc0800000, 0xc0000000, 0x4494e000,
+ 0x88000130, 0xc98c00f9, 0xc9cc00f9, 0x00000000, 0x00000000, 0x5ddc0000, 0x84000102, 0x79b80000,
+ 0xc1800000, 0xc79a1f00, 0x78180000, 0xa43e00da, 0x00000000, 0xc0004a0e, 0x49801f00, 0xc0000000,
+ 0x00000000, 0x71b8c000, 0xc583fd00, 0x41c0e000, 0xc0000000, 0x5ccc0004, 0xc98c00f8, 0x58cc0004,
+ 0x59100002, 0xcdd000f8, 0x5d100002, 0xc71c00f8, 0xa7be0028, 0x00000000, 0xc1c00000, 0xc5d81710,
+ 0x7f00e000, 0xc5dbff00, 0xcd9000f9, 0x59100002, 0x58880004, 0x8000fec8, 0x5dc80000, 0x84000078,
+ 0xc1c00000, 0xc5f81e00, 0x583c0000, 0xcdc01e00, 0xc1800000, 0xc79ac018, 0xc0000000, 0xc7824018,
+ 0x59980002, 0x4418e000, 0xc41800fc, 0x583c0000, 0xcd801618, 0x80000150, 0x6c9c2010, 0x425d2000,
+ 0x583c001c, 0xce4000f8, 0xc0c00000, 0xc6cc0078, 0x40c86000, 0xc1800000, 0xc71a0138, 0x458ce000,
+ 0x44d86006, 0xc4ec0078, 0xa7be004a, 0x58340008, 0xc98000f8, 0x6c9c2010, 0x00000000, 0x419cc000,
+ 0x58340008, 0xcd8000f8, 0x80000040, 0x5834000c, 0xc98000f8, 0x6c9c2010, 0x00000000, 0x419cc000,
+ 0x5834000c, 0xcd8000f8, 0xc1800000, 0xc79ac018, 0x6d982010, 0xc1c00002, 0x719cc000, 0x583c0000,
+ 0xcd801618, 0xc1800002, 0x5dc80010, 0x7998c004, 0xc5b81e00, 0x583c0000, 0xcd801e00, 0xc1c00000,
+ 0xc5ec1060, 0xc2800000, 0xc6ac1d10, 0x583c0002, 0xcec000f8, 0xc1e1e000, 0x59dc0080, 0x583c0014,
+ 0xcdc000f8, 0x583c0020, 0xc1c00000, 0xcdc000f9, 0xcdc000f9, 0xcdc000f9, 0xcdc000f9, 0xcdc000f9,
+ 0x9c400000, 0xcdc000f9, 0xcdc000f9, 0xcdc000f9, 0xc6d20260, 0xc1800000, 0xc6d80278, 0x40d8a000,
+ 0x583c0006, 0xcd4000f8, 0x9c400000, 0x583c0004, 0xcd0000f8, 0x00000000, 0xc0c05e00, 0xc4c000f8,
+ 0xc90000f8, 0xc1800000, 0xc1400000, 0xc5180078, 0x5dd80000, 0x840000aa, 0xc1800000, 0xc5174018,
+ 0xc51ac018, 0x4594e000, 0xc59400fc, 0xc1c00002, 0x45d4e000, 0x8800003a, 0x580c0000, 0xcd801a18,
+ 0x580c0000, 0xc1fc0002, 0xcdc3de00, 0x80000020, 0x5d540002, 0x580c0000, 0xcd401a18, 0x58cc0040,
+ 0x5dcc5f7e, 0x8800ff32, 0x9c400000, 0x00000000, 0x00000000, 0x00000000, 0xc00046a0, 0x4b400078,
+ 0xc00046a0, 0x4b820078, 0x00000000, 0x5df40000, 0x8400052a, 0x5df80000, 0x8400051a, 0x58340008,
+ 0xc8c000f8, 0x5834000c, 0xc90000f8, 0x58340000, 0x4b020038, 0x44d0e000, 0x00000000, 0x45f0e000,
+ 0x880004c8, 0x58380008, 0xc8c000f8, 0x5838000c, 0xc90000f8, 0xc74000f8, 0xcb0000f8, 0x450ce000,
+ 0xa5fe0488, 0xc1c00002, 0xc0006920, 0xcdc000f8, 0xc1c00002, 0xc000691c, 0xcdc000f8, 0x58340004,
+ 0x49000078, 0x58340002, 0x4a800078, 0xc2c00000, 0xc72c0078, 0x42d16000, 0x6d1c2010, 0x429d4000,
+ 0xc6c000f8, 0xca4000f9, 0xca0000f9, 0x5834000a, 0xc94000f8, 0x7a70e000, 0xa5fe03da, 0x00000000,
+ 0x6d1c2010, 0x581c7f40, 0x48c00008, 0x00000000, 0x00000000, 0x5dcc0000, 0x8400003a, 0xc1c00000,
+ 0xc65c0078, 0x45cc6000, 0xc4e40078, 0x582c0000, 0xccc00078, 0xc0c00000, 0xc70e0038, 0x6ccc2000,
+ 0x59100004, 0x44d0e000, 0xc1c00000, 0xc5d000fe, 0x58340004, 0xcd000078, 0x58340008, 0xcb0000f8,
+ 0xc0400000, 0xc6440078, 0x4144a000, 0x5834000a, 0xcd4000f8, 0x5b300002, 0xa940002a, 0x00000000,
+ 0x58340008, 0xcf0000f8, 0x800001c0, 0x58380002, 0x48c00078, 0x58380004, 0x49020078, 0x00000000,
+ 0x00000000, 0x6d102010, 0x40d00000, 0xc94000f8, 0x58340000, 0x49030010, 0xc0004048, 0xc8c000f8,
+ 0xc68000f8, 0xcd4000f8, 0x58340008, 0xcf0000f8, 0xc1c00006, 0x45d0e000, 0x88000122, 0xc000ec00,
+ 0xde83e000, 0x49000020, 0x00000000, 0x00000000, 0x5dd00008, 0x8800ffd2, 0x6ea84000, 0x40e94000,
+ 0xc000ec04, 0xde83e000, 0xce8000f8, 0xc000c000, 0xde83eb00, 0xc6804050, 0xcd4000f8, 0x6eec4000,
+ 0x40ed6000, 0x5aec0008, 0xc000c000, 0xde83eb00, 0xc6c04050, 0xce0000f8, 0x5eec0008, 0xc000c000,
+ 0xde83eb00, 0xc6c04050, 0xce4000f8, 0x59f40008, 0x6ddc4000, 0x40dce000, 0xc000c000, 0xde83eb00,
+ 0xc5c04050, 0xcf0000f8, 0xc78000f8, 0xcb0000f8, 0x58380004, 0x4a820078, 0xc2c00000, 0xc72c0078,
+ 0x42e96000, 0xc6c000f8, 0xca4000f8, 0x5838000e, 0xc8c000f8, 0x7a70e000, 0xa5fe0098, 0xc2000000,
+ 0xc7220038, 0x6e202000, 0x5aa80004, 0x4628e000, 0xc1c00000, 0xc5e800fe, 0x58380004, 0xce801078,
+ 0x5838000c, 0xca0000f8, 0x40c46000, 0x5838000e, 0xccc000f8, 0x5a200002, 0x5838000c, 0xce0000f8,
+ 0x8000faf8, 0xaa860610, 0xc3c04f20, 0xc7c000f8, 0xcb8000f8, 0x583c0006, 0x4b420038, 0x4b010038,
+ 0x583c0002, 0x4ac10038, 0x583c0002, 0x4a820078, 0x4770e000, 0x8400011a, 0xc0004044, 0xde83e000,
+ 0xc1ca0002, 0xcdc0a500, 0x42ad4000, 0x58280006, 0xca4000f8, 0xc2000000, 0xc0c00000, 0xc64d8018,
+ 0xc6620078, 0x5dcc0004, 0x88000030, 0x98405fe0, 0x58200000, 0x48c00078, 0x49020078, 0x80000008,
+ 0x583c0000, 0x48c20038, 0x5b740002, 0xc1c001fe, 0x775da000, 0x5aec000c, 0x44ece000, 0x7aed6006,
+ 0x583c0006, 0xcf401038, 0x583c0002, 0xcec00838, 0x583c0002, 0x4a820078, 0x4770e000, 0x8400fef8,
+ 0x5bfc0010, 0x5dfc4f40, 0x8800fe8a, 0x80000480, 0xc0000000, 0xc94c00f8, 0xd8e41079, 0xd9281079,
+ 0x5810000e, 0xc98000f8, 0xc1c00000, 0xc55c0078, 0x419cc000, 0x5810000e, 0xcd8000f8, 0xc55fff00,
+ 0x7dc0e000, 0x580c0000, 0xcdc3ff00, 0x58200002, 0x48c00078, 0x49020079, 0xd24000f8, 0xc0000000,
+ 0xc94f7b20, 0xc1c00000, 0x00000000, 0xc55ee008, 0xc5d41710, 0xd8e40079, 0xd9280079, 0x5810000a,
+ 0xc98000f8, 0xc1c00000, 0xc55c0078, 0x419cc000, 0x5810000a, 0xcd8000f8, 0xc55fff00, 0x7dc0e000,
+ 0xc5d7ff00, 0xde420078, 0xc9c000f8, 0xde400078, 0x00000000, 0xcdc000f8, 0x580c0000, 0xcd4000f8,
+ 0xc5cc00f8, 0xa94002f0, 0x00000000, 0xa7be01b2, 0xc0000000, 0xde800079, 0x58000000, 0x49830010,
+ 0xde400079, 0xc90000f9, 0xc1c00006, 0x45d8e000, 0x9c400004, 0xc94000f8, 0xc0004048, 0xc98000f8,
+ 0xc0800000, 0xde480278, 0x40984000, 0xc000ec04, 0xde83e000, 0xcc8000f8, 0xc000c000, 0xde83eb00,
+ 0xc4804050, 0xccc000f8, 0xc0800000, 0xde480279, 0x40984000, 0x58880008, 0xc000c000, 0xde83eb00,
+ 0xc4804050, 0xcd4000f8, 0x5c880008, 0xc000c000, 0xde83eb00, 0xc4804050, 0xcd0000f8, 0xde800079,
+ 0x58000008, 0xc8c000f8, 0xc0800000, 0xc4080078, 0x6c884000, 0x40984000, 0xc000ec04, 0xde83e000,
+ 0xcc8000f8, 0xc000c000, 0xde83eb00, 0xc4804050, 0xccc000f8, 0x9c400000, 0x00000000, 0x00000000,
+ 0x00000000, 0xc0000000, 0xde820079, 0x58000000, 0x49830010, 0xde420079, 0xc94000f9, 0x5dd80008,
+ 0x9c400004, 0xc0004048, 0xc8c000f8, 0xc1000000, 0xde520279, 0x410c8000, 0xc000ec04, 0xde83e000,
+ 0xcd0000f8, 0xc000c000, 0xde83eb00, 0xc5004050, 0xcd4000f8, 0xde820079, 0x5800000c, 0xc94000f8,
+ 0xc1000000, 0xc4100078, 0x6d104000, 0x410c8000, 0xc000ec04, 0xde83e000, 0xcd0000f8, 0xc000c000,
+ 0xde83eb00, 0xc5004050, 0xcd4000f8, 0x9c400000, 0x00000000, 0x00000000, 0x00000000, 0x9c400000,
+ 0x00000000, 0x00000000, 0x00000000, 0xaa880398, 0xc3c04680, 0xc0804f30, 0x58080006, 0x48c00038,
+ 0x49020038, 0x5808000a, 0xc9c000f8, 0x58080000, 0x49430028, 0x40dc6000, 0x44d0c000, 0xc1c001fe,
+ 0x759cc000, 0x4559c000, 0xdb9c00f9, 0xc000ec00, 0xde83e000, 0x48000020, 0x5df80004, 0x880001aa,
+ 0x5dc0000c, 0x8800019a, 0xc0004008, 0xc9c000f8, 0xc7c000f8, 0x4b420078, 0xa944001a, 0x5ddc0002,
+ 0x84000162, 0x4b000078, 0x5df40000, 0x8400014a, 0x98407ec0, 0xc0800000, 0x5834000c, 0xc8c000f8,
+ 0x5dc80000, 0x84000102, 0x98407f70, 0xc0800000, 0x5830000c, 0xc8c000f8, 0x5dc80000, 0x840000d2,
+ 0x98408038, 0xc0f80002, 0x58cc4f30, 0x00000000, 0x984083e0, 0xc0c04f30, 0x580c0000, 0x49020038,
+ 0x98408300, 0x58340004, 0x49020078, 0x58340000, 0xc0004044, 0xde83e000, 0xc1c60002, 0xcdc06300,
+ 0x5fb80002, 0xc000ec00, 0xde83e000, 0x48000020, 0x5df80004, 0x8800003a, 0x5dc0000c, 0x8800002a,
+ 0x8000fee0, 0x5bfc0002, 0x5dfc46a0, 0x8800fe42, 0x984084e0, 0xc0a03ce0, 0x58881340, 0xc0c04f30,
+ 0x80000130, 0x580c0002, 0x49400038, 0x583c0006, 0xc98000f8, 0xd97800f8, 0x41148000, 0xc000ec04,
+ 0xde83e000, 0xc1e03c14, 0x59dc4000, 0xcdc000f8, 0xde93eb00, 0x583c0004, 0xc94000f8, 0x58100008,
+ 0xcd8000f8, 0x58100004, 0xcd4000f8, 0x583c0002, 0x48820260, 0xc1980008, 0xc7d81078, 0x580c0000,
+ 0xc983c000, 0x58100002, 0xcc8000f8, 0x580c0002, 0x48820078, 0xdf9400f8, 0xc50000f8, 0xcd8000f8,
+ 0x583c0002, 0xc9820038, 0x9c400000, 0x40944000, 0x58080006, 0xcd8000f8, 0xc0004028, 0xcbc000f8,
+ 0xc000691c, 0xcb8000f8, 0xa7c09f38, 0x00000000, 0x5df80000, 0x84009f20, 0xc1c00002, 0xc000e070,
+ 0xcdc00000, 0x80009f00, 0xdcbc00f9, 0xdcb800f8, 0xdd3400f9, 0xc2400040, 0xc000690c, 0xc8c000f9,
+ 0xc90000f8, 0xc1c00000, 0x60c18000, 0x7724e000, 0x84000052, 0x61018000, 0x7724e000, 0x84000032,
+ 0x98407768, 0xc1c00000, 0xc00068f4, 0xcdc000f8, 0x8000ff90, 0x5b300040, 0xc2c06400, 0x6f1c6000,
+ 0x42dd6000, 0xc2809800, 0x429d4000, 0x58340022, 0xcf0000f8, 0x582c0008, 0xcf8000f8, 0xc000690c,
+ 0xc1c00000, 0xc71ca000, 0x401c0000, 0xc8c000f8, 0xc2000002, 0x6a30e000, 0x70dc6000, 0xccc000f8,
+ 0xc1c00000, 0x582c000a, 0xcdc000f8, 0x58340008, 0xc8c000f9, 0xc90000f9, 0xc94000f9, 0x582c0000,
+ 0xccc000f9, 0xcd0000f9, 0xcd4000f9, 0x58340010, 0xc9c000f9, 0xc8c000f9, 0xc90000f9, 0xc94000f9,
+ 0xc98000f9, 0xc84000f9, 0xc88000f9, 0x58280000, 0xcdc000f9, 0xccc000f9, 0xcd0000f9, 0xcd4000f9,
+ 0xcd8000f9, 0xcc4000f9, 0xcc8000f9, 0xc1c00000, 0x5828000e, 0xc9c3e000, 0x00000000, 0x00000000,
+ 0x5ddc0002, 0x840003a2, 0xa944006a, 0x00000000, 0xc2404980, 0x58240008, 0xc8c000f8, 0x5824000c,
+ 0xc90000f8, 0x58240000, 0x49c20038, 0x44d06000, 0x58cc0008, 0x44dce000, 0x88000260, 0xc24041c0,
+ 0x58240008, 0xc88000f8, 0x5824000c, 0xc8c000f8, 0xc64000f8, 0xca0000f8, 0x448c8000, 0xc0400000,
+ 0xc6060038, 0x4504e000, 0x88000200, 0x58240004, 0x48c00078, 0xc1000000, 0xc6100078, 0x410c0000,
+ 0xc94000f9, 0xc98000f9, 0x58880002, 0x7960e000, 0xa5fe01b0, 0x58240008, 0xcc8000f8, 0xdf9c00f8,
+ 0x59dc0002, 0xc000691e, 0xcdc000f8, 0x58cc0004, 0x6c442000, 0x444ce000, 0xc1c00000, 0xc5cc00fe,
+ 0x58240004, 0xccc00078, 0xc0004022, 0x48c20008, 0xc1000000, 0xc59000f8, 0x5828000e, 0xcd0000e0,
+ 0x410c8000, 0x58280004, 0xcd0000e0, 0x5828000e, 0xc1fe0002, 0xcdc3ff00, 0x5828000e, 0xc1fc0000,
+ 0xcdc3de00, 0x58340020, 0xc1c00000, 0xcdc000f8, 0xc0004044, 0xde83e000, 0xc1d00002, 0xcdc10800,
+ 0xc000696a, 0xc8c000f8, 0xc1c00000, 0xc0006968, 0xcdc000f8, 0x5dcc08f2, 0x84000042, 0x00000000,
+ 0x00000000, 0x00000000, 0x90802611, 0x00000000, 0x00000000, 0x00000000, 0x908023c9, 0x00000000,
+ 0x00000000, 0x00000000, 0xc000696c, 0xc8c000f8, 0xc1c00002, 0xc0006968, 0xcdc000f8, 0x58cc0002,
+ 0xc000696c, 0xccc000f8, 0x90003251, 0x00000000, 0x00000000, 0x00000000, 0xc0c06800, 0x6f9c6000,
+ 0x40dc6000, 0x580c0004, 0xc90000f8, 0x5828000e, 0xc1fc0002, 0xcdc3de00, 0x58340020, 0xc1c00002,
+ 0xcdc000f8, 0x59100002, 0x580c0004, 0xcd0000f8, 0x800000b8, 0xc0c00000, 0xc0004022, 0xc8c20008,
+ 0xc1000000, 0x5828000e, 0xc90000e0, 0x5828000e, 0xc1fc0000, 0xcdc3de00, 0x58340020, 0xc1c00000,
+ 0xcdc000f8, 0x410ce000, 0xc1400000, 0xdc941078, 0x7d40a000, 0x75d4e000, 0xc1400000, 0xdc961078,
+ 0x71d4e000, 0x58280004, 0xcdc000e0, 0x94000000, 0xc1c00002, 0xc000691c, 0xcdc000f8, 0xc0004044,
+ 0xde83e000, 0xc1ce0002, 0xcdc0e700, 0xc1c00002, 0xc0006920, 0xcdc000f8, 0xd87800f8, 0xc3800000,
+ 0x580c7400, 0xca4000f9, 0xca0000f8, 0xc3400000, 0xc3c00000, 0xc67c0008, 0x5dfc0004, 0x8800005a,
+ 0x5dfc0004, 0x8400049a, 0xc0004ac0, 0x58000016, 0xc8c000f8, 0x00000000, 0x00000000, 0x58cc0002,
+ 0xccc000f8, 0x80000458, 0xc639c008, 0xc674a028, 0xc0c00000, 0xc64d6030, 0xc000ea10, 0xc3000000,
+ 0xcb3c0070, 0x6cdc8000, 0x41cce000, 0x431d8000, 0x5b304000, 0x6faca000, 0x5aec7c00, 0xc0c00000,
+ 0xc0000000, 0xc8f00038, 0x6f686000, 0x5aa89c00, 0x5ccc0002, 0xccf00038, 0xc1000000, 0xc6128018,
+ 0x5dd00000, 0x840000f2, 0xc1800000, 0xc0800000, 0xc61a0018, 0xc60b0038, 0xc1c40002, 0x419cc000,
+ 0x6d9c4010, 0x429c0000, 0xc94000f8, 0xc1c00000, 0xc59c0308, 0x695ca000, 0x6d570010, 0x59980002,
+ 0x6c9c4010, 0x431c0000, 0xc1c00006, 0x749c2000, 0x5dc40000, 0xcd40183a, 0x5dc40002, 0xcd40103a,
+ 0x5dc40004, 0xcd40083a, 0x5dc40006, 0xcd40003a, 0x58880002, 0x5d100002, 0x8400ff50, 0xa61a00c0,
+ 0x5828000a, 0xc90000f8, 0x5828000c, 0xc94000f8, 0xc0000000, 0xc1c00000, 0xc5d41f00, 0xcd5000f8,
+ 0xc1000002, 0x58280008, 0xc94000f8, 0x5df40040, 0xc0006912, 0x44100004, 0xc98000f8, 0x6934e000,
+ 0x7dc0e000, 0x759cc000, 0xcd8000f8, 0xa9440022, 0xc1b00002, 0x6994c000, 0xd9b000f8, 0x5ccc0000,
+ 0x840001e0, 0x6fcca000, 0x58cc7d80, 0x580c0006, 0xc90000f8, 0xc1400000, 0xc615a000, 0x59100002,
+ 0x580c0006, 0xcd0000f8, 0xc1c00000, 0x7d40a000, 0xc55c0000, 0x582c0024, 0xcdc000f8, 0xa61a0168,
+ 0x7f80e000, 0xc5f80000, 0x6faca000, 0x5aec7c00, 0x582c0024, 0xc94000f8, 0x580c0004, 0xc98000f8,
+ 0x5dd40002, 0x8400011a, 0x5dd00080, 0x8800007a, 0xc000ea28, 0xc1d2007e, 0xcdfd2928, 0xc000ea28,
+ 0xc1d00002, 0xcdfd0800, 0x5dd0007e, 0xc000ea28, 0x6ddd2000, 0xcdfd2928, 0xc000ea28, 0xc1d00002,
+ 0xcdfd0800, 0x80000038, 0xc000ea28, 0x6d1d2000, 0xcdfd2928, 0xc000ea28, 0xc1d00002, 0xcdfd0800,
+ 0x583c6948, 0xc9c000f8, 0x00000000, 0x00000000, 0x41d0e000, 0xcdc000f8, 0x4590c000, 0x580c0004,
+ 0xcd8000f8, 0x580c0006, 0xc1c00000, 0xcdc000f8, 0xc0006902, 0xc8c000f8, 0x00000000, 0x00000000,
+ 0x58cc0004, 0xc1c00200, 0x45cce000, 0xc1c00000, 0xc5cc00fe, 0xccc000f8, 0xc000f01e, 0xc0d00002,
+ 0xc1c00002, 0xc5cc1018, 0xccc000f8, 0xdf8400f8, 0x9c400000, 0x00000000, 0x00000000, 0x00000000,
+ 0xc0006904, 0xc94000f8, 0xc000fe08, 0x49c00040, 0x00000000, 0x00000000, 0x5ddc0100, 0x8800ffd8,
+ 0xab68008a, 0x00000000, 0x58147200, 0xccc000f9, 0xcd0000f9, 0xc000f016, 0xc1d00002, 0xcdc10800,
+ 0x59540004, 0xc1c00200, 0x45d4e000, 0xc1c00000, 0xc5d400fe, 0x9c400000, 0xc0006904, 0xcd4000f8,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x8000ff30, 0xc0006906, 0xc94000f8, 0xc000fe0a,
+ 0x49c00040, 0x00000000, 0x00000000, 0x5ddc0100, 0x8800ffd8, 0xab6a008a, 0x00000000, 0x58147400,
+ 0xccc000f9, 0xcd0000f9, 0xc000f404, 0xc1d00002, 0xcdc10800, 0x59540004, 0xc1c00200, 0x45d4e000,
+ 0xc1c00000, 0xc5d400fe, 0x9c400000, 0xc0006906, 0xcd4000f8, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x8000ff30, 0xc08000a0, 0x74d0c000, 0x84000090, 0x78d0c000, 0x8400006a, 0x61800018,
+ 0x6180e008, 0x441cc000, 0x84000060, 0x5d940000, 0x84000050, 0x60c04008, 0xa48a0040, 0x9c400000,
+ 0x61004008, 0x58880040, 0x00000000, 0xa5400018, 0x00000000, 0xc0800080, 0x9c400000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xc000f412, 0xc9c000f8, 0xc1800000,
+ 0xc0800000, 0xa5c00718, 0xc5d82028, 0xc0004044, 0xde83e000, 0xc1d20002, 0xcdc12900, 0x6d886000,
+ 0x59089800, 0x5810000e, 0xc9c3c000, 0x59486400, 0xd9b800f8, 0xa5c0065a, 0x58140008, 0xc98000f8,
+ 0xc0c07b00, 0xc0800000, 0x6d9ca000, 0x40dc6000, 0xd9b800f8, 0x580c0002, 0xc8808000, 0x00000000,
+ 0x00000000, 0xa480004a, 0x580c0004, 0xc98000f8, 0x58140002, 0xc88000f8, 0x00000000, 0x00000000,
+ 0x4498e000, 0x84000110, 0xc1c00000, 0x580c0002, 0xc9c04000, 0x00000000, 0x00000000, 0xa5c0004a,
+ 0x580c0006, 0xc98000f8, 0x58140004, 0xc88000f8, 0x00000000, 0x00000000, 0x4498e000, 0x840000a0,
+ 0xc0800000, 0x58100002, 0xc8800078, 0x580c001e, 0xc94000f8, 0xc1800000, 0x580c0002, 0xc9810038,
+ 0x40944000, 0xa4be0052, 0xc1400000, 0x4498e000, 0x88000118, 0x580c0002, 0xc940e000, 0x00000000,
+ 0x00000000, 0xa54000ca, 0xc1c00000, 0x00000000, 0x00000000, 0x00000000, 0xdf9400f8, 0x00000000,
+ 0x00000000, 0xc1800000, 0xc5582000, 0xa5400042, 0xc000fb64, 0xc1c00002, 0xcdd80000, 0xc000facc,
+ 0xc1c40002, 0xcdd84200, 0x80000430, 0xc000fb64, 0xc1c20002, 0xcdd82100, 0xc000facc, 0xc1c60002,
+ 0xcdd86300, 0x800003f8, 0x580c0002, 0xc9c10038, 0x00000000, 0x00000000, 0x589c0000, 0xc000690a,
+ 0xc94000f8, 0xc00041c0, 0x48c00078, 0x49820139, 0x49c00078, 0xa9440030, 0x00000000, 0x6d402010,
+ 0x41c0e000, 0x00000000, 0xd9f800f8, 0x40d46000, 0x59540004, 0x4594e000, 0xc1c00000, 0xc5d400fe,
+ 0xc000690a, 0xcd4000f8, 0xc1400000, 0x5810000e, 0xc94000e0, 0xa9440022, 0xc1800000, 0xc4c000f8,
+ 0xc98000f8, 0x580c0002, 0xcd4000f8, 0xc00046a2, 0xcd4000f9, 0xccc000f8, 0xc00046a6, 0xc8c000f8,
+ 0xc1c00008, 0xc1400006, 0x7548a000, 0x8400001a, 0x45d4a000, 0x40944000, 0x580c7f40, 0xcd400008,
+ 0x58cc0002, 0xc1c00040, 0x45cce000, 0xc1c00000, 0xc5cc00fe, 0xc00046a6, 0xccc000f8, 0xc00046a2,
+ 0xc94000f9, 0xc8c000f8, 0xc4980078, 0xa94400a0, 0x00000000, 0x00000000, 0x00000000, 0xa9460082,
+ 0xdf9c00f8, 0x5c109800, 0x58006400, 0x5800000a, 0x48820078, 0xc000ec04, 0xcd4000f8, 0xc5c000f8,
+ 0xcc8000f8, 0xa4820030, 0xc000404a, 0xc9c000f8, 0xc000c000, 0xc5404050, 0xcdc000f8, 0xdf9400f8,
+ 0xc1f80006, 0xc5db9c18, 0x00000000, 0xc5581008, 0xc00041c0, 0x58000000, 0x49c3e000, 0x00000000,
+ 0x00000000, 0xc5d81f00, 0xc4c000f8, 0xcd8000f8, 0xc000e408, 0xc1c00002, 0xcdc000f8, 0xc000691e,
+ 0xc98000f8, 0x5810000e, 0xc1fe0000, 0xcdc3ff00, 0x5d980002, 0xc000691e, 0xcd8000f8, 0xc1800000,
+ 0x58100002, 0xc9800078, 0x6d486000, 0x58886800, 0x58080006, 0xc9c000f8, 0x00000000, 0x00000000,
+ 0x419cc000, 0x58080006, 0xcd8000f8, 0xc1c00002, 0xc00068f4, 0xcdc000f8, 0xc1800000, 0xc5582000,
+ 0xa540002a, 0xc000fb60, 0xc1c40002, 0xcdd84200, 0x80000020, 0xc000fb60, 0xc1c60002, 0xcdd86300,
+ 0xdf9400f8, 0xc1800002, 0x00000000, 0x00000000, 0x5dd40040, 0xc000690e, 0x44180004, 0xc88000f8,
+ 0x6994e000, 0x7dc0e000, 0x749c4000, 0xcc8000f8, 0x9c400000, 0x00000000, 0x00000000, 0x00000000,
+ 0x58340008, 0xc90000f8, 0xc74000f8, 0xc94000f8, 0x44d0e000, 0xa5fe0068, 0x58340004, 0x49820078,
+ 0xc2c00000, 0xc56c0078, 0x42d96000, 0xc6c000f8, 0xca4000f8, 0x58340002, 0x48c00078, 0x7a54e000,
+ 0x7dc0e000, 0xc5cbe000, 0x9c400000, 0x6d982010, 0x40d86000, 0xd8e41078, 0x58300008, 0xc90000f8,
+ 0xc70000f8, 0xc94000f8, 0x450cc000, 0xc1c00000, 0xc55e0038, 0x5ddc0002, 0x459ce000, 0x88000060,
+ 0x58300004, 0x49800078, 0xc2800000, 0xc5680078, 0x42994000, 0xc68000f8, 0xca0000f8, 0x58300002,
+ 0x48c00078, 0x7a14e000, 0xc5cbe000, 0x9c400000, 0x6d982010, 0x40d86000, 0xd8e40078, 0x580c0002,
+ 0x48800038, 0x580c0002, 0x49420078, 0x580c0000, 0x49000078, 0x4148a000, 0x00000000, 0x41088000,
+ 0x6f5e0000, 0x41ece000, 0xc54000f8, 0xcdc000f9, 0x6f1e0000, 0x41e8e000, 0xcdc000f9, 0xd64000f8,
+ 0xc000ec04, 0xde83e000, 0xc1e03c14, 0x59dc4000, 0xcdc000f8, 0xde93eb00, 0x582c0002, 0xc98000f8,
+ 0xc1c00000, 0xc65ee010, 0x419cc000, 0xc0800000, 0xc6480078, 0xc1c00000, 0xdd5c4100, 0x409c4000,
+ 0xc1c00006, 0x75d8e000, 0x409c4000, 0x58880006, 0xc1e1fffe, 0x59ddfff8, 0x749c4000, 0x759cc000,
+ 0x58100004, 0xcd8000f8, 0xc1c00000, 0xc4df8018, 0x5ddc0002, 0x84000050, 0x00000000, 0xc1c00006,
+ 0x749ce000, 0x84000018, 0x00000000, 0x58880008, 0xc1e1fffe, 0x59ddfff8, 0x749c4000, 0x58100002,
+ 0xcc8000f8, 0x58280002, 0xc98000f8, 0xc1c00000, 0xc61ee010, 0x419cc000, 0xc1e1fffe, 0x59ddfff8,
+ 0x759cc000, 0x58100008, 0xcd8000f8, 0x580c0000, 0x49c3c000, 0xc1800000, 0xc4db8c18, 0x580c000a,
+ 0xc88000f8, 0xc5581078, 0xc5d80000, 0x5dc80000, 0x84000022, 0xc50000f8, 0xcd8000f8, 0x80000028,
+ 0x580c000c, 0xcd0000f8, 0x580c000e, 0xcd8000f8, 0x9c400000, 0x00000000, 0x58140006, 0xcd8000f8,
+ 0x49420138, 0x5834000c, 0xc98000f8, 0x59100004, 0x4550e000, 0xc1c00000, 0xc5d000fe, 0x58340004,
+ 0xcd001078, 0x59980002, 0x5834000c, 0xcd8000f8, 0x58300004, 0x49000078, 0x58300000, 0x49420138,
+ 0x58300008, 0xc98000f8, 0x59100004, 0x4550e000, 0xc1c00000, 0xc5d000fe, 0x58300004, 0xcd000078,
+ 0x9c400000, 0x59980002, 0x58300008, 0xcd8000f8, 0x580c0002, 0x49400038, 0x580c000a, 0xc98000f8,
+ 0x5954000c, 0x580c0000, 0x4883c000, 0x4550e000, 0x88000092, 0xc000ec04, 0xde83e000, 0xc1e03c14,
+ 0x59dc4000, 0xcdc000f8, 0xc1400000, 0xc000cd80, 0x5dcc4f20, 0xc1c0cf80, 0xc5c000fa, 0xde83eb00,
+ 0xc1c0000c, 0xc49c0000, 0xcdc000f8, 0x7c804000, 0x580c0000, 0xcc801e00, 0x580c0002, 0xcd400038,
+ 0x9c400000, 0x59980002, 0x580c000a, 0xcd8000f8, 0x580c000a, 0xc90000f8, 0x580c0008, 0x49400008,
+ 0x5dd00000, 0x84000112, 0x5dd40006, 0x84000100, 0x580c000c, 0xc94000f8, 0x580c000e, 0xc98000f8,
+ 0xc000ec04, 0xde83e000, 0xc1e03c14, 0x59dc4000, 0xcdc000f8, 0xde97eb00, 0x580c0006, 0x49c00038,
+ 0xc54000f8, 0xcd8000f8, 0x41d0e000, 0x580c0006, 0xcdc00038, 0x580c000a, 0xc1c00000, 0xcdc000f8,
+ 0xc1000000, 0xc000ec04, 0xde83e000, 0xcc8000f8, 0xc000c000, 0xde83eb00, 0xc4804050, 0xcd0000f8,
+ 0x580c0008, 0xc1c00002, 0xcdc00008, 0x9c400000, 0x00000000, 0x00000000, 0x00000000, 0xcd0000f9,
+ 0xcd0000f9, 0xcd0000f9, 0xcd0000f9, 0xcd0000f9, 0xcd0000f9, 0xcd0000f9, 0xcd0000f9, 0x5ccc0010,
+ 0x8400ffb8, 0x9c400000, 0x00000000, 0x00000000, 0x00000000, 0xc45400f8, 0x98408638, 0xc1000000,
+ 0xc0004ae0, 0xc0c00020, 0x98408638, 0xc1000000, 0xc000b000, 0xc0c00800, 0xc54400f8, 0x9c400000,
+ 0x00000000, 0x00000000, 0x00000000, 0xc0004ae0, 0xc99000f8, 0x5dd00020, 0x88000278, 0xc0000080,
+ 0x44180000, 0x80000266, 0x4414e000, 0xc41400fc, 0x5dd40000, 0x84000242, 0xc000b000, 0xc1c0226a,
+ 0x45d4e000, 0x8ddc0000, 0x6d1cc000, 0x401c0000, 0x00000000, 0xccd800f9, 0xccd800f9, 0xccd800f9,
+ 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9,
+ 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9,
+ 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9,
+ 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9,
+ 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9,
+ 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9,
+ 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9,
+ 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0xccd800f9, 0x9c400000, 0x58104ae0, 0xcd8000f8,
+ 0x00000000, 0xc3400002, 0xc3004f30, 0xd87800f8, 0x5df80000, 0x84000110, 0x58300008, 0x48c00008,
+ 0x00000000, 0x00000000, 0x5dcc0002, 0x84000428, 0xc0004044, 0xde83e000, 0xc1cc0002, 0xcdc0c600,
+ 0x583c0010, 0xc8c000f9, 0xc90000f8, 0xc1d60008, 0x984075a8, 0x40dc6000, 0xc1c40038, 0x411c8000,
+ 0x583c0010, 0x984075a8, 0xc8c000f9, 0xc90000f8, 0x00000000, 0x583c0014, 0xc8c000f8, 0x00000000,
+ 0x00000000, 0x58cc0004, 0xccc000f8, 0x583c0000, 0xc1c00004, 0xcdc00008, 0x80000350, 0x5df80004,
+ 0x84000340, 0x583c0014, 0xc8c000f8, 0x583c0016, 0xc90000f8, 0x00000000, 0x00000000, 0x44d0e000,
+ 0x84000300, 0xc0004044, 0xde83e000, 0xc1cc0002, 0xcdc0c600, 0x583c0000, 0xc1c00000, 0xcdc00008,
+ 0xc000bfc0, 0x58000002, 0xc7400300, 0xc8c000f8, 0x58300000, 0x4a020038, 0x58300004, 0xc90000f8,
+ 0x58300006, 0x49430038, 0x44d12000, 0x6e644010, 0x58300006, 0xce401838, 0xc000bfc0, 0xc7400300,
+ 0x48c0a008, 0x58344a20, 0xc90000f8, 0x5dcc0006, 0x840000da, 0x58344a24, 0xc8c000f8, 0x4524e000,
+ 0x840000b8, 0xc0004a28, 0xc9c000f8, 0x58cc0002, 0x00000000, 0x5ddc0000, 0xc0000040, 0xc41c00fa,
+ 0x45cce000, 0x88000058, 0xc0c00000, 0xc000e408, 0xc1c00010, 0xcdc000f8, 0xc0004a2c, 0xc9c000f8,
+ 0x00000000, 0x00000000, 0x59dc0002, 0xcdc000f8, 0x58344a24, 0xccc000f8, 0x80000030, 0x58344a20,
+ 0xce4000f8, 0xc0c00000, 0x58344a24, 0xccc000f8, 0x46552000, 0x42612004, 0x58300006, 0x4ac10038,
+ 0x6e642010, 0x6e4c4010, 0x6e5c8010, 0x40dc6000, 0x6cdc8010, 0x40dc6000, 0x6cd02000, 0x410c8000,
+ 0x46508000, 0x6d246000, 0x6d1c4000, 0x425d2000, 0x46512000, 0x6e64a010, 0x424d2000, 0x42e56000,
+ 0x58300006, 0xcec00838, 0x58300006, 0x48c00038, 0xc000bfc0, 0xc7400300, 0x4900a008, 0xc1c001fe,
+ 0x76dd6000, 0x46cce000, 0x84000030, 0x5dd00006, 0x84000020, 0x58300008, 0xcd000008, 0x00000000,
+ 0xdf8400f8, 0x9c400000, 0x00000000, 0x00000000, 0x00000000, 0xca8000f8, 0xc000fb82, 0x4b800000,
+ 0x00000000, 0xc3c00000, 0xa7800188, 0xc0006960, 0xcfc000f8, 0xc0004048, 0xcb4000f8, 0xc3046962,
+ 0x00000000, 0x5df40000, 0x84000100, 0xc0004018, 0xcfc000f8, 0xc0c00000, 0xc000e40c, 0xc90000f8,
+ 0xc1603c20, 0x59544908, 0xc000ec04, 0xde83e000, 0xcd4000f8, 0xc000c000, 0xde83eb00, 0xc5404050,
+ 0xc98000f8, 0x5dcdfffe, 0x8400006a, 0x58cc0002, 0xa508ff92, 0x00000000, 0xa580ff80, 0xc0004032,
+ 0xc90000f8, 0xc000e408, 0xc1c00020, 0xcdc000f8, 0x59100002, 0xc0004032, 0xcd0000f8, 0xc0004030,
+ 0xccc000f8, 0x80000350, 0x43358000, 0xc000ec04, 0xde83e000, 0xcf0000f8, 0xc000c000, 0xde83eb00,
+ 0xc7004050, 0xcfc000f8, 0x80000308, 0xc0006960, 0x4b000058, 0xc1e00002, 0x7dc0e000, 0x76dd6000,
+ 0x769d4000, 0xc2620002, 0x5a640002, 0xc3400000, 0xc2000006, 0x46e4e000, 0xc634000a, 0x46a4e000,
+ 0xc634020a, 0xc000fb80, 0xcac000f8, 0xc000fba0, 0xca8000f8, 0xc2400000, 0xc2000000, 0xc6e40000,
+ 0xc6e40100, 0xc6a40200, 0xc6a40300, 0xc6e02000, 0xc6e02100, 0xc6a02200, 0xc6a02300, 0x7765a000,
+ 0x7761a000, 0xc6740818, 0xc0004038, 0xc8c000f9, 0xc000403a, 0xc90000f8, 0x474ce000, 0x84000030,
+ 0x59100002, 0xcd0000f8, 0x5dd007d0, 0x8400003a, 0x800001b8, 0xc1c00000, 0xc0004038, 0xcf4000f9,
+ 0xcdc000f8, 0x80000190, 0x7b716000, 0x84000182, 0xc0006960, 0xcf4000f8, 0xc0004048, 0xcac000f8,
+ 0xc2846962, 0x00000000, 0x5dec0000, 0x84000100, 0xc0004018, 0xcf4000f8, 0xc0c00000, 0xc000e40c,
+ 0xc90000f8, 0xc1603c20, 0x59544908, 0xc000ec04, 0xde83e000, 0xcd4000f8, 0xc000c000, 0xde83eb00,
+ 0xc5404050, 0xc98000f8, 0x5dcdfffe, 0x8400006a, 0x58cc0002, 0xa508ff92, 0x00000000, 0xa580ff80,
+ 0xc000401c, 0xc90000f8, 0xc000e408, 0xc1c00020, 0xcdc000f8, 0x59100002, 0xc000401c, 0xcd0000f8,
+ 0xc000401a, 0xccc000f8, 0x80000048, 0x42ad4000, 0xc000ec04, 0xde83e000, 0xce8000f8, 0xc000c000,
+ 0xde83eb00, 0xc6804050, 0xcf4000f8, 0x9c400000, 0x00000000, 0x00000000, 0x00000000,};
+
+static u32 vrx218_e1_fw_data[] = {
+};
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/vrx318/fw/vrx318_pp32_1.h b/drivers/net/ethernet/lantiq/vrx318/fw/vrx318_pp32_1.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/fw/vrx318_pp32_1.h
@@ -0,0 +1,417 @@
+#ifndef __VRX218_PP32_1_FW_H
+#define __VRX218_PP32_1_FW_H
+
+/******************************************************************************
+** FILE NAME    : ifxmips_ppa_datapath_fw_vrx218_pp32_1.h
+** PROJECT      : PPA
+** PLATFORM     : VRX218
+** MODULES     	: PP32_1
+**
+** DATE         : 06/03/2015
+** AUTHOR       : Lantiq PPE FW Team
+** DESCRIPTION  : VRX218 PP32 1 PPE Firmware Binary
+** COPYRIGHT    : 	   Copyright (c) 2015
+**			        Lantiq Deutschland GmbH
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** FW VERSION [31:0] : 0x92030202
+** MERCURIAL TAG     :
+**
+** HISTORY
+** $Date         $Author                   $Comment
+** 06/03/2015    Lantiq PPE FW Team        VRX218 PP32 1 PPE Firmware Binary
+*******************************************************************************/
+
+static u32 vrx218_pp32_1_fw_code[] = {
+ 0x800002b8, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x8000ffe0, 0x00000000, 0x00000000, 0x00000000,
+ 0x94000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0xc1020002, 0xd90c00f8, 0xc0004006, 0xcbc000f8, 0xc1000000, 0xde910000, 0x5d100002, 0x98c0234a,
+ 0x5bfc0002, 0xcfc000f8, 0x00000000, 0x800052c8, 0x00000000, 0xaa80003a, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x94000001, 0x00000000, 0xc0004024, 0x49400000, 0xc0004034, 0x4bc000a0,
+ 0xa54000d0, 0x00000000, 0x63c1c028, 0xa78a00ba, 0x6fb44000, 0x5b746840, 0x58340006, 0x4b020038,
+ 0x4ac00078, 0x00000000, 0x5f300002, 0x84000060, 0x58340002, 0x4a800078, 0x58340002, 0x4a020078,
+ 0x58340000, 0x4b030038, 0x42e92000, 0x46248000, 0xc62400fc, 0x58340006, 0xce400078, 0x58340006,
+ 0xcf001038, 0x8000ff48, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x94000001, 0xc0004042,
+ 0xd28000f8, 0x00000000, 0x00000000, 0x00000000, 0xc00070b8, 0xde83e000, 0xc94000f8, 0x00000000,
+ 0x00000000, 0x59540002, 0xcd4000f8, 0xc121fffe, 0x5911fffa, 0x14100000, 0xc0004042, 0xd28000f8,
+ 0xc3e12406, 0x5bfc0404, 0xc0004000, 0xcfc000f8, 0xc3e16000, 0x5bfc0000, 0xc0004002, 0xcfc000f8,
+ 0xc0006240, 0xc1000020, 0xcd0000f9, 0xcd0000f9, 0xcd0000f9, 0xcd0000f9, 0xcd0000f9, 0xcd0000f9,
+ 0xcd0000f9, 0xcd0000f9, 0xc0004024, 0xcbc000f8, 0x00000000, 0xc3800000, 0xc7fa0078, 0xc1400000,
+ 0xde97e000, 0xc00068f2, 0xc98000f8, 0x00000000, 0x00000000, 0x45588000, 0x8400ffd8, 0x59980002,
+ 0xc00068f2, 0xcd8000f8, 0x00000000, 0x00000000, 0x00000000, 0xc00068f2, 0xc98000f8, 0x00000000,
+ 0x00000000, 0x5d180004, 0x8400ffd8, 0xc1000000, 0xd90400f9, 0xdb840078, 0xc1000006, 0xd90400f9,
+ 0xc000403c, 0xcf8000f8, 0xc1000000, 0xc0006920, 0xcd0000f8, 0xc0004042, 0xd28000f8, 0xc0004010,
+ 0xd14000f8, 0x00000000, 0x00000000, 0xaa820600, 0xc0004a10, 0xd81c00f9, 0xc94000f8, 0xc0000000,
+ 0xc3c00000, 0xa57e0378, 0xc57c0078, 0xcafc00f8, 0xddc000f9, 0xc94000f8, 0x583c0004, 0x49820078,
+ 0xc3400000, 0xc6f40078, 0x4359a000, 0xc0000000, 0xca7400f8, 0xc1800000, 0xc55a0018, 0x7a6c8000,
+ 0xa53e0302, 0x00000000, 0xc1000002, 0xc0006920, 0xcd0000f8, 0xc1c00000, 0xc55e8018, 0xc1400000,
+ 0xc6566018, 0x755ca000, 0x4158a000, 0x6d502000, 0x5b905fc0, 0x58380000, 0x49800078, 0x58380002,
+ 0x49c00078, 0x6d686000, 0x5aa84060, 0x419d8000, 0xc1800000, 0xc6580078, 0x583c000c, 0xc9c000f9,
+ 0xc88000f8, 0x00000000, 0x59dc0002, 0x40984000, 0xcc8000f8, 0x5c000002, 0xcdc000f8, 0x58280000,
+ 0xc9c000f9, 0xc88000f8, 0x00000000, 0x59dc0002, 0x40984000, 0xcc8000f8, 0x5c000002, 0xcdc000f8,
+ 0xc0000000, 0xca3000f8, 0x98c008f0, 0xc0400000, 0xc0004026, 0x49c00078, 0x5d040000, 0x84000062,
+ 0xc0004022, 0x49c00078, 0xc1bc0002, 0x76d88000, 0xc65c00fa, 0xc59c1e02, 0x7e412000, 0xc65fff00,
+ 0xc0000000, 0xcdf400f8, 0x80000048, 0x98c009c8, 0x00000000, 0x58300002, 0xc88000f8, 0xc0004044,
+ 0xde83e000, 0xc1020002, 0xcd002100, 0xc000404c, 0xc9c000f8, 0x58144d00, 0xc98000f8, 0xc1000000,
+ 0xc5d10038, 0x4590c000, 0x88000062, 0xc0004a18, 0xc98000f8, 0xc1c00002, 0x69d4e000, 0x75d88000,
+ 0x84000030, 0x719cc000, 0xc0004a18, 0xcd8000f8, 0xc000e400, 0xcdc000f8, 0x583c0004, 0x49420078,
+ 0xc1800000, 0xc6da0138, 0x59540004, 0x45948000, 0xc1000000, 0xc51400fe, 0xcd401078, 0x8000fca8,
+ 0xddc000f9, 0x58000002, 0xc1004a12, 0x45008000, 0x8800fc48, 0x80000230, 0x58144d00, 0xc88000f8,
+ 0x459c8000, 0x88000028, 0xa63e0098, 0x58280008, 0xc0400002, 0x80000040, 0xc0004026, 0x49c20078,
+ 0xa63e0022, 0x5828000c, 0x449c8000, 0x88000052, 0xc0400004, 0xc9c000f9, 0xc88000f8, 0x00000000,
+ 0x59dc0002, 0x40984000, 0xcc8000f8, 0x5c000002, 0xcdc000f8, 0x9cc00000, 0x00000000, 0x00000000,
+ 0x00000000, 0x58340002, 0xc98000f8, 0xc1000002, 0xc5241f00, 0xc0004022, 0x49c00078, 0xc07c0002,
+ 0x76c48000, 0xc61c00fa, 0xc45c1e02, 0x7ec08000, 0xc51fff00, 0x58300002, 0xcd8000f8, 0x5c000002,
+ 0xce4000f8, 0x58340002, 0xcc8000f8, 0x5c000002, 0xcdc000f8, 0xc0000000, 0x49fa0139, 0x49b80078,
+ 0xc1000002, 0x69148000, 0xd9300078, 0x58144d00, 0xc88000f8, 0x59980004, 0x45d88000, 0xc1000000,
+ 0xc51800fe, 0x58880002, 0xcc8000f8, 0xc1000002, 0xc0006920, 0xcd0000f8, 0xc0000000, 0x9cc00000,
+ 0xcdb80078, 0x00000000, 0x5fb80002, 0xaa840d60, 0xc3c04aa0, 0xc3000000, 0xdf300078, 0x7f018000,
+ 0xc101fffe, 0x75308000, 0x84000d2a, 0xc7c000f8, 0xcb8000f9, 0x58000002, 0xcb4000f8, 0xc1400000,
+ 0xc7960078, 0x5d140000, 0x8400056a, 0x77158000, 0x583c0004, 0x4ac00078, 0x63014008, 0xa68a0542,
+ 0x582c0000, 0x4a400078, 0x582c0004, 0x4a000078, 0xc0000000, 0x496fff00, 0x42612000, 0xc9a400f8,
+ 0xc0004024, 0x49c00000, 0x79948000, 0xa53e04e0, 0xc5f80000, 0xa5c0010a, 0x98c01118, 0x6e802000,
+ 0x58005fc0, 0xc98000f9, 0xc0004044, 0xde83e000, 0xc1040002, 0xcd004200, 0xc1200002, 0x69288000,
+ 0xd93000f8, 0x6e946000, 0x59544060, 0x58140004, 0xc98000f9, 0xc9c000f8, 0x00000000, 0x59980002,
+ 0x41c4e000, 0xcdc000f8, 0x5c000002, 0xcd8000f8, 0x582c0008, 0xc98000f9, 0xc9c000f8, 0x00000000,
+ 0x59980002, 0x41c4e000, 0xcdc000f8, 0x5c000002, 0xcd8000f8, 0x800003d0, 0xc0004034, 0xc98000f8,
+ 0xc0400006, 0xc1400000, 0xc7572020, 0xc1000002, 0x69148000, 0x75188000, 0xc447e102, 0xc1400000,
+ 0xc7568020, 0xc1000002, 0x69148000, 0x75188000, 0xc447e002, 0xc1000000, 0x583c0002, 0xcd0000f8,
+ 0x5d040000, 0x8400002a, 0x98c01318, 0xc0004022, 0x49400078, 0xc1000000, 0xa7820098, 0x583c0006,
+ 0x49400078, 0xc0004034, 0x48400078, 0x7d408000, 0x7710c000, 0x7584c000, 0x5d180000, 0x84000052,
+ 0x98c01410, 0x00000000, 0x00000000, 0x00000000, 0x583c0006, 0xcd400078, 0x63014008, 0xa68a0282,
+ 0x00000000, 0xa7840138, 0xc0004036, 0x49400078, 0x49820078, 0xc0400000, 0x00000000, 0x6180a028,
+ 0x00000000, 0x00000000, 0x8400005a, 0xcd801078, 0x6d404000, 0x58006840, 0x58000000, 0x484000b8,
+ 0x00000000, 0x00000000, 0x58000004, 0xcc4000b8, 0x8000ff70, 0xc0004036, 0x49400078, 0xc1c00000,
+ 0xc79e0078, 0x583c0006, 0x49820078, 0x755ca000, 0x7570e000, 0x75d88000, 0x451c8000, 0x84000028,
+ 0x98c014e0, 0x00000000, 0x00000000, 0xc1800000, 0x98c015a0, 0x6300a028, 0xc56800f8, 0xc1800000,
+ 0x98c01118, 0x6e802000, 0x58005fc0, 0xc98000f9, 0xc0004044, 0xde83e000, 0xc1040002, 0xcd004200,
+ 0xc1200002, 0x69288000, 0xd93000f8, 0x6e946000, 0x59544060, 0x58140004, 0xc98000f9, 0xc9c000f8,
+ 0x00000000, 0x59980002, 0x41c4e000, 0xcdc000f8, 0x5c000002, 0xcd8000f8, 0x582c0008, 0xc98000f9,
+ 0xc9c000f8, 0x00000000, 0x59980002, 0x41c4e000, 0xcdc000f8, 0x5c000002, 0xcd8000f8, 0x98c01648,
+ 0x00000000, 0x00000000, 0x00000000, 0xc0004044, 0xde83e000, 0xc1040002, 0xcd004200, 0x5bfc0008,
+ 0x5d3c4abe, 0x8800fa22, 0x80000768, 0x49c20078, 0xc1400000, 0xc5940078, 0x415ca000, 0xc0800000,
+ 0xc58a0138, 0x59dc0004, 0x449c8000, 0xc1000000, 0xc51c00fe, 0xcdc01078, 0xc0000000, 0xc9a400f9,
+ 0xc9e400f8, 0x492fe000, 0xc89400f9, 0xc85400f8, 0x00000000, 0xc5081f00, 0xc1000000, 0xc5181f00,
+ 0xcc6400f8, 0x5e640002, 0xcca400f8, 0x492e0138, 0xc0400000, 0xc4840078, 0x5a200004, 0x45208000,
+ 0xc1000000, 0xc52000fe, 0x592c0004, 0xce100078, 0xcdd400f8, 0x5d540002, 0xcd9400f8, 0x58284d00,
+ 0xc98000f8, 0xc000404c, 0xc9c000f8, 0x5d980002, 0x58284d00, 0xcd8000f8, 0xc1000000, 0xc5d00038,
+ 0x45188000, 0x88000072, 0xc0004a18, 0xc98000f8, 0xc1c00002, 0x69e8e000, 0x75d88000, 0x84000042,
+ 0xc000e400, 0x6dd20000, 0xcd0000f8, 0x7dc0e000, 0x759cc000, 0xc0004a18, 0xcd8000f8, 0x9cc00000,
+ 0x00000000, 0x00000000, 0x00000000, 0xc1e10000, 0xa4420040, 0xc1000000, 0xc7532220, 0x59106840,
+ 0x58100006, 0x49c00078, 0x583c0002, 0xcd001078, 0xc0a10000, 0xa4400040, 0xc1000000, 0xc7528220,
+ 0x59106840, 0x58100006, 0x48800078, 0x583c0002, 0xcd000078, 0xc1000000, 0xc7910038, 0x4150a000,
+ 0x71c88000, 0xa51efd32, 0x449c8000, 0xc49c00fc, 0x45d48000, 0x8800fd12, 0x9cc00000, 0x00000000,
+ 0x00000000, 0x00000000, 0x61814028, 0xc100003e, 0x45288000, 0x9cc00004, 0x6e802000, 0x58005fc0,
+ 0x49000079, 0x49c20078, 0x6e844000, 0x58446840, 0x411c0000, 0x49c00078, 0x58040006, 0x48800078,
+ 0xc0400000, 0xc7850038, 0x41c4e000, 0xc0400002, 0x68682000, 0x7144a000, 0x449c8000, 0x8800ff58,
+ 0x7c402000, 0x77058000, 0x7544a000, 0x8000ff38, 0x61414028, 0xa68a009a, 0x6e9c4000, 0x59dc6840,
+ 0x581c0004, 0x488000b8, 0x581c0000, 0x484000b8, 0x581c0004, 0xa4aeffb8, 0xcc4000b8, 0xc121fe00,
+ 0x70904000, 0x40844000, 0xa4aeff90, 0xcc8000b8, 0xc0000002, 0x68280000, 0x7180c000, 0x8000ff68,
+ 0x9cc00000, 0x00000000, 0x583c0006, 0xcd801078, 0xc06000fe, 0x6d5c4000, 0x59dc6840, 0x581c0004,
+ 0x488000b8, 0xc101fffe, 0x70502000, 0x44848000, 0xc56800fa, 0x9cc00002, 0x88000020, 0x45888000,
+ 0xc49800fc, 0xc56800fc, 0x6300a028, 0x5d140040, 0x8800ff8a, 0x9cc00000, 0x00000000, 0x00000000,
+ 0x00000000, 0x583c0000, 0x49410038, 0x6e984000, 0x59986840, 0xa78400a0, 0x4144a000, 0xc0004036,
+ 0x49c00078, 0xc0400002, 0x68682000, 0x75c48000, 0x8400006a, 0x58180004, 0x488000b8, 0x583c0006,
+ 0x49020078, 0xc0000002, 0x68280000, 0x71008000, 0x583c0006, 0x44944000, 0xcd00107e, 0x58180004,
+ 0xcc8000b8, 0xa7820090, 0xc0400002, 0x68682000, 0xc0004034, 0x49c00078, 0x58180006, 0x48800078,
+ 0x75c48000, 0x84000052, 0x583c0006, 0x49c00078, 0x44944000, 0x58180006, 0xcc800078, 0x7c408000,
+ 0x75d0e000, 0x583c0006, 0xcdc00078, 0x583c0002, 0xcb4000f8, 0x00000000, 0x00000000, 0x5d340000,
+ 0x9cc00002, 0xc75e0078, 0x5d1c0000, 0x8400003a, 0x581c0006, 0x48800078, 0x00000000, 0x00000000,
+ 0x44944000, 0xcc800078, 0xc75c0078, 0x5d1c0000, 0x9cc00002, 0x581c0006, 0x48800078, 0x00000000,
+ 0x00000000, 0x44944000, 0xcc800078, 0x9cc00000, 0x00000000, 0x00000000, 0x00000000, 0xaa900bd0,
+ 0xc3c05e00, 0xc7c000f8, 0xcb8000f8, 0x583c0008, 0xcac000f8, 0xc3400000, 0xc7b40078, 0x5d340000,
+ 0x84000b8a, 0xc74000f8, 0xcb0000f8, 0xc000ec00, 0xde83e000, 0x4a400020, 0x583c001e, 0xca0000f8,
+ 0x5d240004, 0x8800009a, 0x583c0008, 0x4ac00078, 0x583c001c, 0xc90000f8, 0xa7be0022, 0x00000000,
+ 0x45208000, 0x8400005a, 0x58340008, 0xc90000f8, 0x00000000, 0x00000000, 0x45208000, 0x8400002a,
+ 0x98c01c98, 0xc0400000, 0x58340000, 0x49400078, 0x583c001c, 0xca4000f8, 0x583c0002, 0xcac000f8,
+ 0x00000000, 0xc2800000, 0xc6eba010, 0x583c0014, 0xc80000f8, 0x5d280004, 0x84000058, 0xa43e01f2,
+ 0x00000000, 0x98c01f18, 0x597c0020, 0xc1800000, 0xc6d80078, 0xc0004044, 0xde83e000, 0xc1000002,
+ 0xcd000000, 0x5d280000, 0x84000198, 0xc1400000, 0xc1800000, 0xa7be0082, 0xc71a0038, 0xa7bc0170,
+ 0x4660e000, 0x459ce000, 0xc1000010, 0x451c8000, 0x88000148, 0xc1c00000, 0xc6dc0078, 0x6ddc2010,
+ 0x459ce000, 0xc1400008, 0x45d48000, 0xc5d400fc, 0x80000070, 0x4624e000, 0x6d882010, 0x45c88000,
+ 0x880000ea, 0xc0800000, 0xc6c80078, 0x6c882010, 0x45884000, 0xc1400008, 0x44948000, 0xc49400fc,
+ 0x5d140000, 0x840000a2, 0x6d542000, 0xc56c1060, 0xc1000004, 0xc52c1d10, 0x98c022f8, 0x583c000e,
+ 0xc94000f8, 0xc1a16000, 0x583c0018, 0xc94000f8, 0x583c0002, 0xcec000f8, 0x59540002, 0x583c0018,
+ 0xcd4000f8, 0xc0004044, 0xde83e000, 0xc1000002, 0xcd000000, 0x5bfc0040, 0x5d3c5f7e, 0x8800fc92,
+ 0x88000848, 0xc6d40078, 0xc6da0060, 0xc71e0138, 0x4158a000, 0x45d48000, 0x7954a006, 0x6d902010,
+ 0x42110000, 0x583c001e, 0xce0000f8, 0xc56c0078, 0xc1800000, 0xc5ac1060, 0xc2800000, 0x9cc00000,
+ 0xc6ac1d10, 0x583c0008, 0xcec000f8, 0x583c000e, 0xca8000f8, 0xc1000000, 0xc7120138, 0x4150c000,
+ 0x452c8000, 0x7aed6006, 0x583c0002, 0x48000078, 0xa7be0022, 0xc6d00078, 0x45008000, 0x4140c006,
+ 0xc000ec04, 0xde83e000, 0xce8000f8, 0xc100c000, 0xc6904050, 0xc52800f8, 0xdeabeb00, 0xc0000000,
+ 0x416ca000, 0xc9d400f9, 0xc89400f9, 0x42ad4000, 0x79f08000, 0x79388000, 0xa53e0180, 0x00000000,
+ 0x5aec0004, 0x58440002, 0x5a200002, 0x58280002, 0xc0004a0e, 0x49000000, 0x00000000, 0x58280002,
+ 0x5d100000, 0x8400006a, 0xc1204000, 0x44904000, 0xa7be001a, 0x00000000, 0x7f808000, 0xc51e1f00,
+ 0xc100000e, 0xc51c1c10, 0x80000038, 0x00000000, 0x00000000, 0x00000000, 0xc1000000, 0xc793fd00,
+ 0x44904000, 0xcc8000f8, 0x58280000, 0xcdc000f8, 0x45588000, 0x88000088, 0x5aa80004, 0x5e640004,
+ 0x5d240004, 0x8800006a, 0xa7be0040, 0x00000000, 0x58340008, 0xc90000f8, 0x00000000, 0x00000000,
+ 0x45208000, 0x8400002a, 0xc0000000, 0xc9d400f9, 0xc89400f9, 0x8000fe78, 0x583c001e, 0x9cc00000,
+ 0xce0000f8, 0x583c0008, 0xcec00078, 0xc1000000, 0xc7100078, 0x4190c000, 0xc1c00000, 0xc6de0060,
+ 0xc0400000, 0xc0000000, 0x445c8000, 0x88000130, 0xc89400f9, 0xc91400f9, 0x00000000, 0x00000000,
+ 0x5d100000, 0x84000102, 0x78b80000, 0xc0800000, 0xc78a1f00, 0x78080000, 0xa43e00da, 0x00000000,
+ 0xc0004a0e, 0x48801f00, 0xc0000000, 0x00000000, 0x70b84000, 0xc483fd00, 0x41008000, 0xc0000000,
+ 0x5d540004, 0xc89400f8, 0x59540004, 0x59980002, 0xcd1800f8, 0x5d980002, 0xc71000f8, 0xa7be0028,
+ 0x00000000, 0xc1000000, 0xc5081710, 0x7f008000, 0xc50bff00, 0xcc9800f9, 0x59980002, 0x58440004,
+ 0x8000fec8, 0x5d040000, 0x84000078, 0xc1000000, 0xc5381e00, 0x583c0000, 0xcd001e00, 0xc0800000,
+ 0xc78ac018, 0xc0000000, 0xc7824018, 0x58880002, 0x44088000, 0xc40800fc, 0x583c0000, 0xcc801618,
+ 0x80000150, 0x6c502010, 0x42512000, 0x583c001c, 0xce4000f8, 0xc1400000, 0xc6d40078, 0x4144a000,
+ 0xc0800000, 0xc70a0138, 0x44948000, 0x4548a006, 0xc56c0078, 0xa7be004a, 0x58340008, 0xc88000f8,
+ 0x6c502010, 0x00000000, 0x40904000, 0x58340008, 0xcc8000f8, 0x80000040, 0x5834000c, 0xc88000f8,
+ 0x6c502010, 0x00000000, 0x40904000, 0x5834000c, 0xcc8000f8, 0xc0800000, 0xc78ac018, 0x6c882010,
+ 0xc1000002, 0x70904000, 0x583c0000, 0xcc801618, 0xc0800002, 0x5d040010, 0x78884004, 0xc4b81e00,
+ 0x583c0000, 0xcc801e00, 0xc1000000, 0xc52c1060, 0xc2800000, 0xc6ac1d10, 0x583c0002, 0xcec000f8,
+ 0xc121e000, 0x59100080, 0x583c0014, 0xcd0000f8, 0x583c0020, 0xc1000000, 0xcd0000f9, 0xcd0000f9,
+ 0xcd0000f9, 0xcd0000f9, 0xcd0000f9, 0x9cc00000, 0xcd0000f9, 0xcd0000f9, 0xcd0000f9, 0xc6da0260,
+ 0xc0800000, 0xc6c80278, 0x4148e000, 0x583c0006, 0xcdc000f8, 0x9cc00000, 0x583c0004, 0xcd8000f8,
+ 0x00000000, 0xc1405e00, 0xc54000f8, 0xc98000f8, 0xc0800000, 0xc1c00000, 0xc5880078, 0x5d080000,
+ 0x840000aa, 0xc0800000, 0xc59f4018, 0xc58ac018, 0x449c8000, 0xc49c00fc, 0xc1000002, 0x451c8000,
+ 0x8800003a, 0x58140000, 0xcc801a18, 0x58140000, 0xc13c0002, 0xcd03de00, 0x80000020, 0x5ddc0002,
+ 0x58140000, 0xcdc01a18, 0x59540040, 0x5d145f7e, 0x8800ff32, 0x9cc00000, 0x00000000, 0x00000000,
+ 0x00000000, 0xaa860610, 0xc3c04f20, 0xc7c000f8, 0xcb8000f8, 0x583c0006, 0x4b420038, 0x4b010038,
+ 0x583c0002, 0x4ac10038, 0x583c0002, 0x4a820078, 0x47708000, 0x8400011a, 0xc0004044, 0xde83e000,
+ 0xc10a0002, 0xcd00a500, 0x42ad4000, 0x58280006, 0xca4000f8, 0xc2000000, 0xc1400000, 0xc6558018,
+ 0xc6620078, 0x5d140004, 0x88000030, 0x98c025e0, 0x58200000, 0x49400078, 0x49820078, 0x80000008,
+ 0x583c0000, 0x49420038, 0x5b740002, 0xc10001fe, 0x7751a000, 0x5aec000c, 0x456c8000, 0x7aed6006,
+ 0x583c0006, 0xcf401038, 0x583c0002, 0xcec00838, 0x583c0002, 0x4a820078, 0x47708000, 0x8400fef8,
+ 0x5bfc0010, 0x5d3c4f40, 0x8800fe8a, 0x80000480, 0xc0000000, 0xc9d400f8, 0xd9641079, 0xd9a81079,
+ 0x5818000e, 0xc88000f8, 0xc1000000, 0xc5d00078, 0x40904000, 0x5818000e, 0xcc8000f8, 0xc5d3ff00,
+ 0x7d008000, 0x58140000, 0xcd03ff00, 0x58200002, 0x49400078, 0x49820079, 0xd24000f8, 0xc0000000,
+ 0xc9d77b20, 0xc1000000, 0x00000000, 0xc5d2e008, 0xc51c1710, 0xd9640079, 0xd9a80079, 0x5818000a,
+ 0xc88000f8, 0xc1000000, 0xc5d00078, 0x40904000, 0x5818000a, 0xcc8000f8, 0xc5d3ff00, 0x7d008000,
+ 0xc51fff00, 0xde420078, 0xc90000f8, 0xde400078, 0x00000000, 0xcd0000f8, 0x58140000, 0xcdc000f8,
+ 0xc51400f8, 0xa94002f0, 0x00000000, 0xa7be01b2, 0xc0000000, 0xde800079, 0x58000000, 0x48830010,
+ 0xde400079, 0xc98000f9, 0xc1000006, 0x45088000, 0x9cc00004, 0xc9c000f8, 0xc0004048, 0xc88000f8,
+ 0xc0400000, 0xde440278, 0x40482000, 0xc000ec04, 0xde83e000, 0xcc4000f8, 0xc000c000, 0xde83eb00,
+ 0xc4404050, 0xcd4000f8, 0xc0400000, 0xde440279, 0x40482000, 0x58440008, 0xc000c000, 0xde83eb00,
+ 0xc4404050, 0xcdc000f8, 0x5c440008, 0xc000c000, 0xde83eb00, 0xc4404050, 0xcd8000f8, 0xde800079,
+ 0x58000008, 0xc94000f8, 0xc0400000, 0xc4040078, 0x6c444000, 0x40482000, 0xc000ec04, 0xde83e000,
+ 0xcc4000f8, 0xc000c000, 0xde83eb00, 0xc4404050, 0xcd4000f8, 0x9cc00000, 0x00000000, 0x00000000,
+ 0x00000000, 0xc0000000, 0xde820079, 0x58000000, 0x48830010, 0xde420079, 0xc9c000f9, 0x5d080008,
+ 0x9cc00004, 0xc0004048, 0xc94000f8, 0xc1800000, 0xde5a0279, 0x4194c000, 0xc000ec04, 0xde83e000,
+ 0xcd8000f8, 0xc000c000, 0xde83eb00, 0xc5804050, 0xcdc000f8, 0xde820079, 0x5800000c, 0xc9c000f8,
+ 0xc1800000, 0xc4180078, 0x6d984000, 0x4194c000, 0xc000ec04, 0xde83e000, 0xcd8000f8, 0xc000c000,
+ 0xde83eb00, 0xc5804050, 0xcdc000f8, 0x9cc00000, 0x00000000, 0x00000000, 0x00000000, 0x9cc00000,
+ 0x00000000, 0x00000000, 0x00000000, 0xaa880398, 0xc3c04680, 0xc0404f30, 0x58040006, 0x49400038,
+ 0x49820038, 0x5804000a, 0xc90000f8, 0x58040000, 0x49c30028, 0x4150a000, 0x45584000, 0xc10001fe,
+ 0x74904000, 0x45c9c000, 0xdb9c00f9, 0xc000ec00, 0xde83e000, 0x48000020, 0x5d380004, 0x880001aa,
+ 0x5d00000c, 0x8800019a, 0xc0004008, 0xc90000f8, 0xc7c000f8, 0x4b420078, 0xa944001a, 0x5d100002,
+ 0x84000162, 0x4b000078, 0x5d340000, 0x8400014a, 0x98c05490, 0xc0400000, 0x5834000c, 0xc94000f8,
+ 0x5d040000, 0x84000102, 0x98c05540, 0xc0400000, 0x5830000c, 0xc94000f8, 0x5d040000, 0x840000d2,
+ 0x98c05608, 0xc1780002, 0x59544f30, 0x00000000, 0x98c059b0, 0xc1404f30, 0x58140000, 0x49820038,
+ 0x98c058d0, 0x58340004, 0x49820078, 0x58340000, 0xc0004044, 0xde83e000, 0xc1060002, 0xcd006300,
+ 0x5fb80002, 0xc000ec00, 0xde83e000, 0x48000020, 0x5d380004, 0x8800003a, 0x5d00000c, 0x8800002a,
+ 0x8000fee0, 0x5bfc0002, 0x5d3c46a0, 0x8800fe42, 0x98c05ab0, 0xc0603ce0, 0x58441340, 0xc1404f30,
+ 0x80000130, 0x58140002, 0x49c00038, 0x583c0006, 0xc88000f8, 0xd9f800f8, 0x419cc000, 0xc000ec04,
+ 0xde83e000, 0xc1203c14, 0x59104000, 0xcd0000f8, 0xde9beb00, 0x583c0004, 0xc9c000f8, 0x58180008,
+ 0xcc8000f8, 0x58180004, 0xcdc000f8, 0x583c0002, 0x48420260, 0xc0980008, 0xc7c81078, 0x58140000,
+ 0xc883c000, 0x58180002, 0xcc4000f8, 0x58140002, 0x48420078, 0xdf9c00f8, 0xc58000f8, 0xcc8000f8,
+ 0x583c0002, 0xc8820038, 0x9cc00000, 0x405c2000, 0x58040006, 0xcc8000f8, 0xaabc0b40, 0xc0004010,
+ 0xcbc000f8, 0xc3800000, 0x6fa04000, 0x58207e00, 0xcb4000f8, 0xc42000f8, 0x00000000, 0xa75e0042,
+ 0xc0400000, 0x98c03278, 0x58200006, 0x4b000078, 0xc1800000, 0x5d040000, 0x840001e2, 0xc7440070,
+ 0xc0006960, 0x49c00019, 0x49000418, 0xc44000f8, 0xcb0000f8, 0x71d0e000, 0xc0004014, 0xc94000f8,
+ 0x6f986000, 0xc10001fe, 0x69596010, 0x76d16000, 0x76dd6000, 0x8400016a, 0x98c03098, 0xc0800000,
+ 0xc2800000, 0xc6d400f8, 0xc1000004, 0x45088000, 0x88000130, 0x5c880002, 0x58286240, 0xcc8000f8,
+ 0x98c03108, 0x58200004, 0xc94000f8, 0x00000000, 0x98c03448, 0x6e9c6000, 0x59dc4300, 0x00000000,
+ 0x99005c08, 0x58286200, 0xc94000f8, 0xc1800002, 0xc1c06210, 0xc5c000f8, 0xc94000f8, 0xc1000002,
+ 0x69288000, 0x7150a000, 0xcd4000f8, 0xc1400000, 0xc7160028, 0x59540002, 0xc5701028, 0xc44000f8,
+ 0xcf0000f8, 0x98c031c8, 0x58200002, 0xc1000000, 0xc5341100, 0xa760fec8, 0xc1000000, 0xc5340f00,
+ 0x58200000, 0xcf4000f8, 0x5bb80002, 0xc1400000, 0xc7d48010, 0x47948000, 0x8800fda2, 0x800006a8,
+ 0x00000000, 0x00000000, 0x00000000, 0x6140e028, 0x581c6240, 0xc98000f8, 0x5d1c0010, 0x88000030,
+ 0x44988000, 0x8800ffd0, 0xc5e800f8, 0xc58800f8, 0x8000ffb8, 0x9cc00000, 0x00000000, 0x00000000,
+ 0x00000000, 0xc1c00000, 0xc7de0078, 0xc1800000, 0xc5580078, 0x45d88000, 0x8800003a, 0xc5a400f8,
+ 0xc1000002, 0xc5341000, 0xc1000002, 0xc5301600, 0x80000048, 0x595c0080, 0x45588000, 0x8800002a,
+ 0x6d942010, 0xc101ffc0, 0x75512000, 0x80000010, 0xc5e400f8, 0x9cc00000, 0x00000000, 0x00000000,
+ 0x00000000, 0xc9c000f9, 0xc98000f8, 0x58200000, 0xc1400000, 0xc7564068, 0x59540002, 0xc5741268,
+ 0xcf4000f9, 0x41e4e000, 0xcdc000f9, 0xc1400000, 0xc5940078, 0x4564a000, 0xc5580078, 0x9cc00000,
+ 0x00000000, 0xc6981010, 0xcd8000f9, 0x9d000000, 0x4558a000, 0xcd4000f8, 0x00000000, 0x58200006,
+ 0x4b000078, 0xc1800000, 0xc2800000, 0x5830000c, 0xc9c000f8, 0x58300008, 0xc94000f8, 0xc70000f8,
+ 0xcac000f8, 0x45d48000, 0x9cc00002, 0xc0400000, 0x58300004, 0x48820078, 0xc6e80078, 0xc6da0138,
+ 0x42880000, 0xca4000f9, 0xc94000f9, 0x5e800004, 0x7a6c8000, 0xa53e0020, 0x58880004, 0x00000000,
+ 0x9cc00000, 0x45888000, 0xc1000000, 0xc50800fe, 0x58300004, 0xcc801078, 0x59dc0002, 0x5830000c,
+ 0xcdc000f8, 0x5830000e, 0xc9c000f8, 0xc1800000, 0xc6580078, 0x41d8e000, 0x5830000e, 0xcdc000f8,
+ 0xc1000000, 0xc68000f8, 0xcd021030, 0xc0400002, 0xc1c00000, 0xc45c1100, 0xc45c0f00, 0xc69c0070,
+ 0x58200000, 0xcdc00088, 0xc5f40088, 0x58200002, 0xcd4000f8, 0x9cc00000, 0x58000002, 0xcd8000f8,
+ 0x00000000, 0x581c0004, 0x48800078, 0x581c0002, 0x49800078, 0x581c0000, 0x49400078, 0x48020138,
+ 0x6c902010, 0x4190c000, 0x4148a000, 0x58880004, 0x44088000, 0xc1000000, 0xc50800fe, 0x581c0004,
+ 0xcc800078, 0x581c0008, 0xc88000f8, 0x581c000a, 0xc90000f8, 0x58880002, 0x581c0008, 0xcc8000f8,
+ 0x41248000, 0x581c000a, 0xcd0000f8, 0x581c0000, 0x49c3ff00, 0xc1000000, 0xc1000002, 0xc5100f00,
+ 0xc4500070, 0xc7521078, 0xc58000f8, 0xcd0000f8, 0x58200002, 0xc90000f8, 0x00000000, 0x58140002,
+ 0xcd0000f8, 0xc65c0078, 0xc100000e, 0x5d280008, 0x9cc00004, 0xc49c1c10, 0xc54000f8, 0xcdc000f8,
+ 0xc0004048, 0xc88000f8, 0xc58000f8, 0xc90000f8, 0x6d984000, 0x4188c000, 0xc000ec04, 0xde83e000,
+ 0xcd8000f8, 0xc000c000, 0xde83eb00, 0xc5804050, 0xcd0000f8, 0x58200002, 0xc98000f8, 0x6d544000,
+ 0x4094a000, 0x59540008, 0xc000c000, 0xde83eb00, 0xc5404050, 0xcd8000f8, 0x5d540008, 0xc000c000,
+ 0xde83eb00, 0xc5404050, 0xcdc000f8, 0x6e946000, 0x59544300, 0x58140008, 0xc98000f8, 0x6c1c4000,
+ 0x41c8e000, 0xc000ec04, 0xde83e000, 0xcdc000f8, 0xc000c000, 0xde83eb00, 0xc5c04050, 0xcd8000f8,
+ 0x9cc00000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xc2800000, 0x58286230, 0xcbc000f8,
+ 0x6e9c6000, 0x59dc4300, 0x581c0002, 0x48800078, 0x581c0000, 0x48400078, 0x6e806000, 0x58004300,
+ 0x49c20038, 0xc0000000, 0x40bd8000, 0xcaf000f8, 0x6fd02000, 0x4051c000, 0xcb7800f8, 0xa6de0148,
+ 0x00000000, 0x00000000, 0xa77e0132, 0x00000000, 0xc1000000, 0xc52c0f00, 0xcef000f8, 0x5bfc0002,
+ 0x45fc8000, 0xc1000000, 0xc53c00fe, 0x59286230, 0xcfd000f8, 0xc2000000, 0xc6e00070, 0xca6000f8,
+ 0xc1c00000, 0x00000000, 0xc65e0028, 0x5ddc0002, 0xc5e41028, 0xce6000f8, 0x99005c08, 0x58286240,
+ 0xc94000f8, 0xc1800002, 0x99005c08, 0x58286250, 0xc94000f8, 0xc1800002, 0x5d1c0000, 0x8400feb8,
+ 0xa66cfeb0, 0xc1000000, 0xc5241600, 0xc1000000, 0xc5241f00, 0xc60000f8, 0xce4000f8, 0x8000fe78,
+ 0x5aa80002, 0x5d280010, 0x8800fe22, 0x00000000, 0x00000000, 0x00000000, 0xaaae1a58, 0xc1000002,
+ 0xc0006920, 0xcd0000f8, 0xc0006964, 0x4b400038, 0xc0006960, 0x4b010419, 0x49010018, 0xc3c00000,
+ 0x00000000, 0x73118000, 0x47708000, 0x840000b2, 0xc0006964, 0xcf0000f8, 0x7b716000, 0x7f408000,
+ 0x76d16000, 0x84000082, 0xc0004016, 0xca8000f8, 0xc0004010, 0x4a408010, 0x76ac8000, 0x84000032,
+ 0x6ff86000, 0x5bb87fc0, 0x58380000, 0xc13e0002, 0xcd03ff00, 0x5bfc0002, 0x6ea90010, 0x47e48000,
+ 0x8800ffb2, 0xc3c00000, 0x6fe06000, 0x5a2041e0, 0xc60000f8, 0xc84000f8, 0x58200008, 0xc94000f8,
+ 0x5820000c, 0xc98000f8, 0x58200004, 0x4a420078, 0x45588000, 0x840005c2, 0xc3800000, 0xc4780078,
+ 0x43a5c000, 0xc78000f8, 0xc8c000f8, 0xc1c00000, 0xc45e0138, 0x78c48000, 0xa53e057a, 0x58200002,
+ 0x49400078, 0x6e502010, 0x00000000, 0x41500000, 0xd24000f8, 0xd82800f9, 0x5a640004, 0x45e48000,
+ 0xc1000000, 0xc52400fe, 0x58200004, 0xce401078, 0x59980002, 0x5820000c, 0xcd8000f8, 0xc3400000,
+ 0xc4f6a008, 0x6fd04000, 0x4351a000, 0x6f708000, 0x5b305d00, 0x58300000, 0xc94000f8, 0x58300002,
+ 0xc98000f8, 0x58380000, 0x49c00078, 0x59540002, 0x58300000, 0xcd4000f8, 0x6f684000, 0x5aa84d50,
+ 0x58280002, 0x48c00070, 0x58280004, 0x49430038, 0xc2c04d48, 0x582c0002, 0x48800070, 0x419cc000,
+ 0x58300002, 0xcd8000f8, 0x44d48000, 0x88000380, 0x5d080000, 0x84000372, 0x582c0000, 0x49400078,
+ 0x582c0002, 0x4a000070, 0xc0004010, 0x4b020078, 0x58140000, 0x4a420078, 0x5e200002, 0x582c0002,
+ 0xce000070, 0x582c0000, 0xce400078, 0x58380002, 0xc84000f8, 0x58140002, 0xc88000f8, 0x58380000,
+ 0x4a400078, 0x58140002, 0xcc4000f8, 0x58380002, 0xcc8000f8, 0x58140000, 0xce400078, 0x58280002,
+ 0x48c00070, 0xc1a10000, 0x5b300040, 0xc7180078, 0xc0000000, 0xcdb800f8, 0x5d0c0000, 0x84000070,
+ 0xc0004006, 0xc88000f8, 0x58280004, 0x4a000078, 0x58280002, 0xc11e0000, 0xcd01ef00, 0x58280000,
+ 0xcd400078, 0x42090000, 0x58280006, 0xce0000f8, 0x80000038, 0x58280000, 0x49c20078, 0x00000000,
+ 0x00000000, 0x581c0000, 0xcd401078, 0x58280000, 0xcd401078, 0x58cc0002, 0x58280002, 0xccc00070,
+ 0xc0006304, 0xca0000f8, 0xc2400002, 0x6a752000, 0x72250000, 0xce0000f8, 0x5c145800, 0x6c002010,
+ 0x58009560, 0xd64000f8, 0x5d3c0000, 0x84000138, 0xc000ec00, 0xde83e000, 0x49000020, 0x00000000,
+ 0x00000000, 0x5d100008, 0x8800ffd2, 0xc0004048, 0xc9c000f8, 0x58380002, 0xc94000f8, 0x6c104000,
+ 0x41d08000, 0xc000ec04, 0xde83e000, 0xcd0000f8, 0xc000c000, 0xde83eb00, 0xc5004050, 0xcd4000f8,
+ 0x5d100008, 0xc000c000, 0xde83eb00, 0xc5004050, 0xcd8000f8, 0x6fc06000, 0x580041e0, 0x5800000c,
+ 0xc94000f8, 0x6c104000, 0x411c8000, 0xc000ec04, 0xde83e000, 0xcd0000f8, 0xc000c000, 0xde83eb00,
+ 0xc5004050, 0xcd4000f8, 0x80000098, 0x58300004, 0xc94000f8, 0x58300006, 0xc98000f8, 0x59540002,
+ 0x58300004, 0xcd4000f8, 0xc0004010, 0x48820078, 0x419cc000, 0x58300006, 0xcd8000f8, 0x58880040,
+ 0x58380000, 0xcc800078, 0x58380000, 0xc13e0002, 0xcd03ff00, 0x5bfc0002, 0x5d3c0004, 0x8800f9da,
+ 0xc3c00000, 0x6ff86000, 0x5bb87fc0, 0xa94601f0, 0xc0004016, 0xc94000f8, 0xc0006304, 0xc98000f8,
+ 0x6fd06000, 0x6950a010, 0xc10001fe, 0x7550a000, 0x7558a000, 0x8400019a, 0x98c04228, 0xc0400000,
+ 0x00000000, 0x00000000, 0x5d040000, 0x8400016a, 0xc1000002, 0xc0006920, 0xcd0000f8, 0x6f344000,
+ 0x5b744d50, 0x58340000, 0x4a800078, 0x6fec8000, 0x5aec7e40, 0xc1400002, 0x98c048a8, 0x58280000,
+ 0x49800078, 0xc1c00002, 0x98c049f8, 0x5a380008, 0x58280000, 0x49420078, 0x58340002, 0x4a000070,
+ 0x58380002, 0xc1100002, 0xcd010808, 0x5d200000, 0x8400fec0, 0xc0006304, 0xc98000f8, 0xc1000002,
+ 0x69308000, 0x7d008000, 0x7590c000, 0xcd8000f8, 0x8000fe80, 0x61404028, 0x9cc00002, 0x6c984000,
+ 0x59984d50, 0x58180002, 0x49c00070, 0xc180108a, 0x8d980000, 0x445c8000, 0xc4b000fc, 0xc5c400fc,
+ 0x80000b88, 0x58380002, 0x49410008, 0x00000000, 0x00000000, 0x5d140000, 0x84000b58, 0xc0004016,
+ 0xcac000f8, 0xc0006304, 0xc94000f8, 0x6fd06000, 0x6ad16010, 0xc10001fe, 0x76d16000, 0x76d58000,
+ 0xc0400000, 0x84000af2, 0x98c04bc0, 0x00000000, 0xc72800f8, 0xc241fffe, 0xc78000f8, 0xca8000f8,
+ 0x6c488000, 0x58885d00, 0x6c744000, 0x5b744d50, 0xa6be0092, 0xc1c00000, 0xc69c4068, 0x465c8000,
+ 0x840001f2, 0xa51a0068, 0x58080008, 0xc98000f8, 0x00000000, 0x00000000, 0x59980002, 0x58080008,
+ 0xcd8000f8, 0x98c04cf8, 0x00000000, 0x58340002, 0x49800070, 0x800006f0, 0x472c8000, 0x84000078,
+ 0xa6be0172, 0x465ca000, 0xc1003ffe, 0x7550a000, 0x84000152, 0x5808000a, 0xc98000f8, 0x58380002,
+ 0xc1080002, 0xcd008400, 0x4194c000, 0x5808000a, 0xcd8000f8, 0x80000108, 0xc0004006, 0xc94000f8,
+ 0x5808000c, 0xc98000f8, 0x4560a000, 0xa57e0080, 0x58340002, 0x49400070, 0x58340004, 0x49030038,
+ 0x58340004, 0x4a020038, 0xc0400000, 0x45148000, 0xc0004d48, 0x58000002, 0x49400070, 0x45208000,
+ 0x8800001a, 0x45608000, 0x880008e8, 0xa6be005a, 0x465c2000, 0xc1003ffe, 0x74502000, 0x8400003a,
+ 0x4184c000, 0x5808000c, 0xcd8000f8, 0x58380002, 0xc1080002, 0xcd008400, 0xc1007ffe, 0x5a640002,
+ 0x76512000, 0xc6680268, 0xc529df00, 0xc78000f8, 0xce8000f8, 0x58340002, 0x49420078, 0x58380000,
+ 0x4a000100, 0x6fec8000, 0x5aec7e40, 0xc5602000, 0xc2800000, 0x58340000, 0xca800078, 0x58380004,
+ 0xc94000f8, 0x58380006, 0xc98000f8, 0x58280000, 0x48400078, 0x58380002, 0x4a400020, 0x5c440004,
+ 0x5d200000, 0x84000020, 0x59540002, 0x4184c000, 0x800000b8, 0x5d200004, 0x84000020, 0xc1000002,
+ 0xc5240100, 0x80000078, 0x5d200002, 0x84000060, 0xc1000002, 0xc5240200, 0xc65c00f8, 0x98c048a8,
+ 0xc0800002, 0x5ddc0000, 0xc49c00fa, 0x98c04920, 0x5a380008, 0x58200002, 0x49400070, 0xc6678018,
+ 0xc1400002, 0xc45800f8, 0xc6678400, 0xc0004a04, 0xc9c000f8, 0xc080003c, 0xc1000c00, 0x5ddc0000,
+ 0xc51c00fa, 0xc0400002, 0x45d88000, 0xc4640304, 0x44948000, 0xc4640304, 0x58340002, 0x49c20000,
+ 0x58380004, 0xcd4000f8, 0x58380006, 0xcd8000f8, 0x58380000, 0xcdc00000, 0x58380002, 0xce4000f8,
+ 0x5d1c0002, 0x84000080, 0xc65c00f8, 0x98c048a8, 0xc0800002, 0x5ddc0000, 0xc49c00fa, 0x5d240000,
+ 0x84000028, 0x58380002, 0xc1100002, 0xcd010808, 0x80000028, 0x98c04920, 0x5a380008, 0x58200002,
+ 0x49400070, 0x5d240000, 0x84000030, 0x98c049f8, 0x5a380008, 0x58280000, 0x49420078, 0x80000260,
+ 0x98c04cf8, 0x00000000, 0x58340002, 0x49800070, 0x80000238, 0x61c04008, 0x6c802000, 0x40804000,
+ 0x42c80000, 0xc9c000f9, 0xc88000f9, 0xc90000f8, 0x59dc0002, 0x40944000, 0x41188000, 0x5c000004,
+ 0x9cc00000, 0xcdc000f9, 0xcc8000f9, 0xcd0000f8, 0x58200000, 0x49800078, 0x5d540000, 0x9cc00002,
+ 0xc1c04d48, 0x581c0002, 0x48800070, 0x581c0000, 0x49020078, 0x4094a000, 0x581c0002, 0xcd400070,
+ 0x5c880000, 0x84000020, 0x581c0000, 0xcd800078, 0x80000018, 0x58100000, 0xcd801078, 0x58200000,
+ 0x49420078, 0xc1000000, 0x58200002, 0xcd0000f8, 0x9cc00000, 0x581c0000, 0xcd401078, 0x58340002,
+ 0x49800070, 0x58340000, 0xcd400078, 0x5d980002, 0x58340002, 0xcd800070, 0x58340002, 0xc11e0000,
+ 0xcd01ef00, 0x58200002, 0x49400070, 0x58200000, 0x49820078, 0x58200000, 0xce801078, 0x59d40002,
+ 0x58200002, 0xcdc00070, 0x5d140000, 0x84000028, 0x9cc00000, 0x00000000, 0x58200000, 0xce800078,
+ 0x9cc00000, 0x58180000, 0xce801078, 0x58340002, 0x49800070, 0x5d744d50, 0x6d544010, 0x5d180000,
+ 0x84000040, 0xc0006304, 0xc98000f8, 0xc1000002, 0x69148000, 0x7d008000, 0x7590c000, 0xcd8000f8,
+ 0xc0004006, 0xc94000f8, 0x6300c028, 0xa58a02a2, 0x6d9c4000, 0x59dc4d50, 0x581c0004, 0x48800078,
+ 0x00000000, 0x00000000, 0x41482000, 0x581c0006, 0xcc4000f8, 0x8000ffa8, 0xc0400002, 0x80000240,
+ 0x6280a028, 0x9cc00002, 0x6d744000, 0x5b744d50, 0x58340002, 0xc98000f8, 0x58340000, 0x49c00078,
+ 0x00000000, 0xa59e0052, 0x5c1c5800, 0x6c002010, 0x58009560, 0xc90000f8, 0xc0000002, 0xc4180f00,
+ 0xc5181078, 0x58340002, 0xcd8000f8, 0x6d9e4010, 0x5d25fffe, 0x84000030, 0x58340006, 0xca0000f8,
+ 0xc5e400f8, 0xc54400f8, 0x8000ff30, 0x58340006, 0xc98000f8, 0x45e48000, 0xa51a0020, 0x00000000,
+ 0xc5e400f8, 0xc54400f8, 0x45a08000, 0xa53efee8, 0x00000000, 0xc5a000f8, 0x8000fed0, 0x58340000,
+ 0x49400078, 0x5d180000, 0x9cc00002, 0x5d980002, 0x58140000, 0x48420078, 0x58340002, 0xcd800070,
+ 0x58340002, 0xc11e0000, 0xcd01ef00, 0x58340000, 0xcc400078, 0xc1804d48, 0x58180002, 0x48400070,
+ 0x58180000, 0x49020078, 0x5c440000, 0x84000020, 0x58180000, 0xcd400078, 0x80000018, 0x58100000,
+ 0xcd401078, 0x58180000, 0xcd401078, 0x9cc00000, 0x58440002, 0x58180002, 0xcc400070, 0x5d040000,
+ 0x8400f488, 0xc0004010, 0x49408010, 0x5bfc0002, 0x00000000, 0x47d48000, 0x8800f25a, 0xc2804980,
+ 0x5828000c, 0xca4000f8, 0x58280008, 0xca0000f8, 0x58280004, 0x4b800078, 0x58280000, 0x49420038,
+ 0x58280000, 0x48800078, 0x4624c000, 0x4558c000, 0x5d980008, 0x800004e6, 0x40b9a000, 0xc0006306,
+ 0xcac000f8, 0xc0006308, 0xcb0000f8, 0x5d2c0002, 0x8400009a, 0xc3000000, 0x6f3c6000, 0x5bfc7fc0,
+ 0x583c0002, 0x4a810008, 0xc0004010, 0x4a408010, 0x5d280002, 0x8400002a, 0x5b300002, 0x47248000,
+ 0x88000448, 0x8000ffa8, 0xc1000002, 0xc0006306, 0xcd0000f8, 0xc0006308, 0xcf0000f8, 0x6f3c6000,
+ 0x5bfc7fc0, 0x5b3c0008, 0x58300000, 0x4ac00078, 0x58300002, 0x4a400070, 0xc6e800f8, 0x583c0002,
+ 0x49c10008, 0x45a48000, 0x880003ba, 0x42250000, 0xc1804980, 0x58180008, 0xce0000f8, 0x43a50000,
+ 0x42250000, 0x6d542000, 0xd96800f9, 0x45608000, 0x46150006, 0x58180004, 0xce000078, 0xc1800000,
+ 0xc1400000, 0x58280000, 0x48c00078, 0x58280002, 0xc84000f8, 0xc4d40078, 0xa94600b2, 0x5d1c0002,
+ 0x84000060, 0xc1000002, 0xc5141d00, 0xc0004a0e, 0x49000000, 0x00000000, 0x00000000, 0x5d100002,
+ 0x84000022, 0x58cc0004, 0xc4d40078, 0x80000028, 0x5ccc0004, 0xc4d40078, 0xc1000008, 0xc5141720,
+ 0x5d240002, 0x84000018, 0xc1000002, 0xc5141c00, 0x58280002, 0xc84000f8, 0x58340002, 0xc9c000f8,
+ 0x58340002, 0xcc4000f8, 0x58280002, 0xcdc000f8, 0xc1000000, 0xdd507d00, 0xdd507c00, 0x7150a000,
+ 0xc0000000, 0xcd7400f8, 0x59980002, 0x5bb80004, 0xde9000f9, 0x45388000, 0xc1000000, 0xc53800fe,
+ 0x4389a000, 0x5e640002, 0x5d240000, 0x84000040, 0x583c0002, 0xc1100000, 0xcd010808, 0xc1c00000,
+ 0xc0006306, 0xcdc000f8, 0x800000a0, 0x58280000, 0x4a820078, 0xc1400000, 0x00000000, 0x58280000,
+ 0x48c00078, 0xa9460032, 0xc1000008, 0xc5141720, 0x5ccc0004, 0xc4d40078, 0x8000fe90, 0xc1000000,
+ 0xc5141720, 0xc4d40078, 0x8000fe70, 0x583c0002, 0xc1100004, 0xcd010808, 0xc2004d48, 0x58200002,
+ 0x48400070, 0x58200000, 0x49c20078, 0x00000000, 0x5d040000, 0x84000020, 0x58200000, 0xcec00078,
+ 0x80000018, 0x581c0000, 0xcec01078, 0x58200000, 0xce801078, 0x58300002, 0x4a400070, 0x58280000,
+ 0x48c20078, 0x40582000, 0x58200002, 0xcc400070, 0x46592000, 0x58300002, 0xce400070, 0x58300000,
+ 0xccc00078, 0xc0004028, 0xcbc000f8, 0xc0006920, 0xcb8000f8, 0xa7c00050, 0x00000000, 0x5d380000,
+ 0x84000038, 0xc1000004, 0xc0006920, 0xcd0000f8, 0xc1000002, 0xc000e072, 0xcd000000, 0xc3c00134,
+ 0x8ff80000, 0x00000000, 0x00000000, 0x00000000, 0xc0006920, 0xcac000f8, 0xc0006922, 0xca8000f8,
+ 0x5d2c0004, 0x84000038, 0xc2c00000, 0xc0006920, 0xcec000f8, 0x5aa80002, 0xc0006922, 0xce8000f8,
+ 0x8000ace8, 0x00000000, 0x58340008, 0xc98000f8, 0xc74000f8, 0xc9c000f8, 0x45588000, 0xa53e0068,
+ 0x58340004, 0x48820078, 0xc2c00000, 0xc5ec0078, 0x42c96000, 0xc6c000f8, 0xca4000f8, 0x58340002,
+ 0x49400078, 0x7a5c8000, 0x7d008000, 0xc507e000, 0x9cc00000, 0x6c882010, 0x4148a000, 0xd9641078,
+ 0x58300008, 0xc98000f8, 0xc70000f8, 0xc9c000f8, 0x45944000, 0xc1000000, 0xc5d20038, 0x5d100002,
+ 0x44908000, 0x88000060, 0x58300004, 0x48800078, 0xc2800000, 0xc5e80078, 0x42894000, 0xc68000f8,
+ 0xca0000f8, 0x58300002, 0x49400078, 0x7a1c8000, 0xc507e000, 0x9cc00000, 0x6c882010, 0x4148a000,
+ 0xd9640078, 0x58140002, 0x48400038, 0x58140002, 0x49c20078, 0x58140000, 0x49800078, 0x41c4e000,
+ 0x00000000, 0x4184c000, 0x6f520000, 0x412c8000, 0xc5c000f8, 0xcd0000f9, 0x6f120000, 0x41288000,
+ 0xcd0000f9, 0xd64000f8, 0xc000ec04, 0xde83e000, 0xc1203c14, 0x59104000, 0xcd0000f8, 0xde9beb00,
+ 0x582c0002, 0xc88000f8, 0xc1000000, 0xc652e010, 0x40904000, 0xc0400000, 0xc6440078, 0xc1000000,
+ 0xdd504100, 0x40502000, 0xc1000006, 0x75088000, 0x40502000, 0x58440006, 0xc121fffe, 0x5911fff8,
+ 0x74502000, 0x74904000, 0x58180004, 0xcc8000f8, 0xc1000000, 0xc5538018, 0x5d100002, 0x84000050,
+ 0x00000000, 0xc1000006, 0x74508000, 0x84000018, 0x00000000, 0x58440008, 0xc121fffe, 0x5911fff8,
+ 0x74502000, 0x58180002, 0xcc4000f8, 0x58280002, 0xc88000f8, 0xc1000000, 0xc612e010, 0x40904000,
+ 0xc121fffe, 0x5911fff8, 0x74904000, 0x58180008, 0xcc8000f8, 0x58140000, 0x4903c000, 0xc0800000,
+ 0xc54b8c18, 0x5814000a, 0xc84000f8, 0xc5c81078, 0xc5080000, 0x5d040000, 0x84000022, 0xc58000f8,
+ 0xcc8000f8, 0x80000028, 0x5814000c, 0xcd8000f8, 0x5814000e, 0xcc8000f8, 0x9cc00000, 0x00000000,
+ 0x581c0006, 0xcc8000f8, 0x49c20138, 0x5834000c, 0xc88000f8, 0x59980004, 0x45d88000, 0xc1000000,
+ 0xc51800fe, 0x58340004, 0xcd801078, 0x58880002, 0x5834000c, 0xcc8000f8, 0x58300004, 0x49800078,
+ 0x58300000, 0x49c20138, 0x58300008, 0xc88000f8, 0x59980004, 0x45d88000, 0xc1000000, 0xc51800fe,
+ 0x58300004, 0xcd800078, 0x9cc00000, 0x58880002, 0x58300008, 0xcc8000f8, 0x58140002, 0x49c00038,
+ 0x5814000a, 0xc88000f8, 0x59dc000c, 0x58140000, 0x4843c000, 0x45d88000, 0x88000092, 0xc000ec04,
+ 0xde83e000, 0xc1203c14, 0x59104000, 0xcd0000f8, 0xc1c00000, 0xc000cd80, 0x5d144f20, 0xc100cf80,
+ 0xc50000fa, 0xde83eb00, 0xc100000c, 0xc4500000, 0xcd0000f8, 0x7c402000, 0x58140000, 0xcc401e00,
+ 0x58140002, 0xcdc00038, 0x9cc00000, 0x58880002, 0x5814000a, 0xcc8000f8, 0x5814000a, 0xc98000f8,
+ 0x58140008, 0x49c00008, 0x5d180000, 0x84000112, 0x5d1c0006, 0x84000100, 0x5814000c, 0xc9c000f8,
+ 0x5814000e, 0xc88000f8, 0xc000ec04, 0xde83e000, 0xc1203c14, 0x59104000, 0xcd0000f8, 0xde9feb00,
+ 0x58140006, 0x49000038, 0xc5c000f8, 0xcc8000f8, 0x41188000, 0x58140006, 0xcd000038, 0x5814000a,
+ 0xc1000000, 0xcd0000f8, 0xc1800000, 0xc000ec04, 0xde83e000, 0xcc4000f8, 0xc000c000, 0xde83eb00,
+ 0xc4404050, 0xcd8000f8, 0x58140008, 0xc1000002, 0xcd000008, 0x9cc00000, 0x00000000, 0x00000000,
+ 0x00000000, 0x9d000000, 0x4158a000, 0xcd4000f8, 0x00000000, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9,
+ 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0xcd8000f9, 0x5d540010, 0x8400ffb8, 0x9cc00000,
+ 0x00000000, 0x00000000, 0x00000000, 0xc4dc00f8, 0x98c05c28, 0xc1800000, 0xc0004ae0, 0xc1400020,
+ 0x98c05c28, 0xc1800000, 0xc000b000, 0xc1400800, 0xc5cc00f8, 0x9cc00000, 0x00000000, 0x00000000,
+ 0x00000000, 0xc0004ae0, 0xc89800f8, 0x5d180020, 0x88000278, 0xc0000080, 0x44080000, 0x80000266,
+ 0x441c8000, 0xc41c00fc, 0x5d1c0000, 0x84000242, 0xc000b000, 0xc10017e6, 0x451c8000, 0x8d100000,
+ 0x6d90c000, 0x40100000, 0x00000000, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9,
+ 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9,
+ 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9,
+ 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9,
+ 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9,
+ 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9,
+ 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9,
+ 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0xcd4800f9,
+ 0xcd4800f9, 0xcd4800f9, 0xcd4800f9, 0x9cc00000, 0x58184ae0, 0xcc8000f8, 0x00000000,};
+
+static u32 vrx218_pp32_1_fw_data[] = {
+};
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/prograte.h b/drivers/net/ethernet/lantiq/vrx318/include/prograte.h
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/prograte.h
@@ -0,0 +1,714 @@
+/******************************************************************************
+ *
+ *                        Copyright (c) 2012, 2014, 2015
+ *                           Lantiq Deutschland GmbH
+ *
+ *  For licensing information, see the file 'LICENSE' in the root folder of
+ *  this software module.
+ *
+ ******************************************************************************/
+#ifndef __PROG_RATE_H
+#define __PROG_RATE_H
+
+#define NUM_ME_VAR 697
+struct me_cfg_def my_cfg_seq[] = {
+{0x00000020, 0x00000001, ME_DBG_WR},
+{0x00000024, 0x00000001, ME_DBG_WR},
+{0x00000028, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000542e8, ME_DBG_WR},
+{0x00000034, 0x00000001, ME_DBG_WR},
+{0x00000030, 0x000542ec, ME_DBG_WR},
+{0x00000034, 0x000050bd, ME_DBG_WR},
+{0x00000030, 0x000542f4, ME_DBG_WR},
+{0x00000034, 0x43b78b12, ME_DBG_WR},
+{0x00000030, 0x000542f8, ME_DBG_WR},
+{0x00000034, 0x11110000, ME_DBG_WR},
+{0x00000030, 0x000542fc, ME_DBG_WR},
+{0x00000034, 0x4856af00, ME_DBG_WR},
+{0x00000030, 0x00054300, ME_DBG_WR},
+{0x00000034, 0x00100005, ME_DBG_WR},
+{0x00000030, 0x00054304, ME_DBG_WR},
+{0x00000034, 0x01029d9f, ME_DBG_WR},
+{0x00000030, 0x00054308, ME_DBG_WR},
+{0x00000034, 0x000d0123, ME_DBG_WR},
+{0x00000030, 0x0005430c, ME_DBG_WR},
+{0x00000034, 0x01000002, ME_DBG_WR},
+{0x00000030, 0x00054310, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054314, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054318, ME_DBG_WR},
+{0x00000034, 0x00000050, ME_DBG_WR},
+{0x00000030, 0x0005431c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054320, ME_DBG_WR},
+{0x00000034, 0x0000008e, ME_DBG_WR},
+{0x00000030, 0x00054324, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054328, ME_DBG_WR},
+{0x00000034, 0x00795d50, ME_DBG_WR},
+{0x00000030, 0x0005432c, ME_DBG_WR},
+{0x00000034, 0x00c99b4a, ME_DBG_WR},
+{0x00000030, 0x00054330, ME_DBG_WR},
+{0x00000034, 0x00000002, ME_DBG_WR},
+{0x00000030, 0x00054334, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054338, ME_DBG_WR},
+{0x00000034, 0x00420000, ME_DBG_WR},
+{0x00000030, 0x0005433c, ME_DBG_WR},
+{0x00000034, 0x00000016, ME_DBG_WR},
+{0x00000030, 0x00054340, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054344, ME_DBG_WR},
+{0x00000034, 0x17ae0012, ME_DBG_WR},
+{0x00000030, 0x00054348, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005434c, ME_DBG_WR},
+{0x00000034, 0x883b39c1, ME_DBG_WR},
+{0x00000030, 0x00054350, ME_DBG_WR},
+{0x00000034, 0xd674a488, ME_DBG_WR},
+{0x00000030, 0x00054354, ME_DBG_WR},
+{0x00000034, 0x000053fd, ME_DBG_WR},
+{0x00000030, 0x00054358, ME_DBG_WR},
+{0x00000034, 0x0000540d, ME_DBG_WR},
+{0x00000030, 0x0005435c, ME_DBG_WR},
+{0x00000034, 0x03fd4bf4, ME_DBG_WR},
+{0x00000030, 0x00054360, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054364, ME_DBG_WR},
+{0x00000034, 0x000000a5, ME_DBG_WR},
+{0x00000030, 0x00054368, ME_DBG_WR},
+{0x00000034, 0x03fd4cf4, ME_DBG_WR},
+{0x00000030, 0x0005436c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054370, ME_DBG_WR},
+{0x00000034, 0x000000a5, ME_DBG_WR},
+{0x00000030, 0x00054374, ME_DBG_WR},
+{0x00000034, 0x03fd4df4, ME_DBG_WR},
+{0x00000030, 0x00054378, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005437c, ME_DBG_WR},
+{0x00000034, 0x000000a5, ME_DBG_WR},
+{0x00000030, 0x00054380, ME_DBG_WR},
+{0x00000034, 0x03fd4ef4, ME_DBG_WR},
+{0x00000030, 0x00054384, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054388, ME_DBG_WR},
+{0x00000034, 0x010000a5, ME_DBG_WR},
+{0x00000030, 0x0005438c, ME_DBG_WR},
+{0x00000034, 0x00010011, ME_DBG_WR},
+{0x00000030, 0x00054390, ME_DBG_WR},
+{0x00000034, 0x01193505, ME_DBG_WR},
+{0x00000030, 0x00054394, ME_DBG_WR},
+{0x00000034, 0x00007c10, ME_DBG_WR},
+{0x00000030, 0x00054398, ME_DBG_WR},
+{0x00000034, 0x000003ba, ME_DBG_WR},
+{0x00000030, 0x0005439c, ME_DBG_WR},
+{0x00000034, 0x00000035, ME_DBG_WR},
+{0x00000030, 0x000543a0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543a4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543a8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543ac, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543b0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543b4, ME_DBG_WR},
+{0x00000034, 0x01013501, ME_DBG_WR},
+{0x00000030, 0x000543b8, ME_DBG_WR},
+{0x00000034, 0x00007fcc, ME_DBG_WR},
+{0x00000030, 0x000543bc, ME_DBG_WR},
+{0x00000034, 0xfc382855, ME_DBG_WR},
+{0x00000030, 0x000543c0, ME_DBG_WR},
+{0x00000034, 0x8d577dd7, ME_DBG_WR},
+{0x00000030, 0x000543c4, ME_DBG_WR},
+{0x00000034, 0x04906540, ME_DBG_WR},
+{0x00000030, 0x000543c8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543cc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543d0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543d4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543d8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543dc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543e0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543e4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543e8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543ec, ME_DBG_WR},
+{0x00000034, 0x00000003, ME_DBG_WR},
+{0x00000030, 0x000543f0, ME_DBG_WR},
+{0x00000034, 0x51c951bd, ME_DBG_WR},
+{0x00000030, 0x000543f4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543f8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543fc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054400, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054404, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054408, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005440c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054410, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054414, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054418, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005441c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054420, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054424, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054428, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005442c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054430, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054434, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054438, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005443c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054440, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054444, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054448, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005444c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054450, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054454, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054458, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005445c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054460, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054464, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054468, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005446c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054470, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054474, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054478, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005447c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054480, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054484, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054488, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005448c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054490, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054494, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054498, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005449c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544a0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544a4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544a8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544ac, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544b0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544b4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544b8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544bc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544c0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544c4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544c8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544cc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b940, ME_DBG_WR},
+{0x00000034, 0x00000001, ME_DBG_WR},
+{0x00000030, 0x0005b944, ME_DBG_WR},
+{0x00000034, 0x00006e53, ME_DBG_WR},
+{0x00000030, 0x0005b94c, ME_DBG_WR},
+{0x00000034, 0x43b78b12, ME_DBG_WR},
+{0x00000030, 0x0005b950, ME_DBG_WR},
+{0x00000034, 0x11110000, ME_DBG_WR},
+{0x00000030, 0x0005b954, ME_DBG_WR},
+{0x00000034, 0x48560010, ME_DBG_WR},
+{0x00000030, 0x0005b958, ME_DBG_WR},
+{0x00000034, 0x00100005, ME_DBG_WR},
+{0x00000030, 0x0005b95c, ME_DBG_WR},
+{0x00000034, 0x01029d9f, ME_DBG_WR},
+{0x00000030, 0x0005b960, ME_DBG_WR},
+{0x00000034, 0x000d0123, ME_DBG_WR},
+{0x00000030, 0x0005b964, ME_DBG_WR},
+{0x00000034, 0x01000002, ME_DBG_WR},
+{0x00000030, 0x0005b968, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b96c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b970, ME_DBG_WR},
+{0x00000034, 0x00000054, ME_DBG_WR},
+{0x00000030, 0x0005b974, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b978, ME_DBG_WR},
+{0x00000034, 0x0000008e, ME_DBG_WR},
+{0x00000030, 0x0005b97c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b980, ME_DBG_WR},
+{0x00000034, 0x00795d50, ME_DBG_WR},
+{0x00000030, 0x0005b984, ME_DBG_WR},
+{0x00000034, 0x00c99b4a, ME_DBG_WR},
+{0x00000030, 0x0005b988, ME_DBG_WR},
+{0x00000034, 0x00000002, ME_DBG_WR},
+{0x00000030, 0x0005b98c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b990, ME_DBG_WR},
+{0x00000034, 0x00420000, ME_DBG_WR},
+{0x00000030, 0x0005b994, ME_DBG_WR},
+{0x00000034, 0x00000016, ME_DBG_WR},
+{0x00000030, 0x0005b998, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b99c, ME_DBG_WR},
+{0x00000034, 0x17ae0012, ME_DBG_WR},
+{0x00000030, 0x0005b9a0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9a4, ME_DBG_WR},
+{0x00000034, 0x00016ca0, ME_DBG_WR},
+{0x00000030, 0x0005b9a8, ME_DBG_WR},
+{0x00000034, 0xd674a488, ME_DBG_WR},
+{0x00000030, 0x0005b9ac, ME_DBG_WR},
+{0x00000034, 0x00007193, ME_DBG_WR},
+{0x00000030, 0x0005b9b0, ME_DBG_WR},
+{0x00000034, 0x000071a3, ME_DBG_WR},
+{0x00000030, 0x0005b9b4, ME_DBG_WR},
+{0x00000034, 0x3ffdc24c, ME_DBG_WR},
+{0x00000030, 0x0005b9b8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9bc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9c0, ME_DBG_WR},
+{0x00000034, 0x3ffdc34c, ME_DBG_WR},
+{0x00000030, 0x0005b9c4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9c8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9cc, ME_DBG_WR},
+{0x00000034, 0x3ffdc44c, ME_DBG_WR},
+{0x00000030, 0x0005b9d0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9d4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9d8, ME_DBG_WR},
+{0x00000034, 0x3ffdc54c, ME_DBG_WR},
+{0x00000030, 0x0005b9dc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9e0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9e4, ME_DBG_WR},
+{0x00000034, 0x00010011, ME_DBG_WR},
+{0x00000030, 0x0005b9e8, ME_DBG_WR},
+{0x00000034, 0x01193501, ME_DBG_WR},
+{0x00000030, 0x0005b9ec, ME_DBG_WR},
+{0x00000034, 0x00016ca0, ME_DBG_WR},
+{0x00000030, 0x0005b9f0, ME_DBG_WR},
+{0x00000034, 0x00000424, ME_DBG_WR},
+{0x00000030, 0x0005b9f4, ME_DBG_WR},
+{0x00000034, 0x0003ffff, ME_DBG_WR},
+{0x00000030, 0x0005b9f8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9fc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba00, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba04, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba08, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba0c, ME_DBG_WR},
+{0x00000034, 0x01013505, ME_DBG_WR},
+{0x00000030, 0x0005ba10, ME_DBG_WR},
+{0x00000034, 0x000170c4, ME_DBG_WR},
+{0x00000030, 0x0005ba14, ME_DBG_WR},
+{0x00000034, 0x59ff2c4b, ME_DBG_WR},
+{0x00000030, 0x0005ba18, ME_DBG_WR},
+{0x00000034, 0xe849da6d, ME_DBG_WR},
+{0x00000030, 0x0005ba1c, ME_DBG_WR},
+{0x00000034, 0xb8de14a9, ME_DBG_WR},
+{0x00000030, 0x0005ba20, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba24, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba28, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba2c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba30, ME_DBG_WR},
+{0x00000034, 0x00000088, ME_DBG_WR},
+{0x00000030, 0x0005ba34, ME_DBG_WR},
+{0x00000034, 0x000001a8, ME_DBG_WR},
+{0x00000030, 0x0005ba38, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba3c, ME_DBG_WR},
+{0x00000034, 0x11000000, ME_DBG_WR},
+{0x00000030, 0x0005ba40, ME_DBG_WR},
+{0x00000034, 0x000082a8, ME_DBG_WR},
+{0x00000030, 0x0005ba44, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba48, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba4c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba50, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba54, ME_DBG_WR},
+{0x00000034, 0x84044000, ME_DBG_WR},
+{0x00000030, 0x0005ba58, ME_DBG_WR},
+{0x00000034, 0x00000ffe, ME_DBG_WR},
+{0x00000030, 0x0005ba5c, ME_DBG_WR},
+{0x00000034, 0x00000004, ME_DBG_WR},
+{0x00000030, 0x0005ba60, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba64, ME_DBG_WR},
+{0x00000034, 0x00006f53, ME_DBG_WR},
+{0x00000030, 0x0005ba68, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba6c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba70, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba74, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba78, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba7c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba80, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba84, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba88, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba8c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba90, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba94, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba98, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba9c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005baa0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005baa4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005baa8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005baac, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bab0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bab4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bab8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005babc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bac0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bac4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bac8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bacc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bad0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bad4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bad8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005badc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bae0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bae4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bae8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005baec, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005baf0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005baf4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005baf8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bafc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb00, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb04, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb08, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb0c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb10, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb14, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb18, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb1c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb20, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb24, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb28, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb2c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb30, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb34, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb38, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb3c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020d9ec, ME_DBG_WR},
+{0x00000034, 0x00000001, ME_DBG_WR},
+{0x00000030, 0x0020d9f4, ME_DBG_WR},
+{0x00000034, 0x000050ba, ME_DBG_WR},
+{0x00000030, 0x0020d9f8, ME_DBG_WR},
+{0x00000034, 0x00001055, ME_DBG_WR},
+{0x00000030, 0x0020d9fc, ME_DBG_WR},
+{0x00000034, 0x00001055, ME_DBG_WR},
+{0x00000030, 0x0020da00, ME_DBG_WR},
+{0x00000034, 0x07ae0012, ME_DBG_WR},
+{0x00000030, 0x0020da04, ME_DBG_WR},
+{0x00000034, 0x00000a66, ME_DBG_WR},
+{0x00000030, 0x0020da08, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020da0c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020da10, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020da14, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020de38, ME_DBG_WR},
+{0x00000034, 0x00006e50, ME_DBG_WR},
+{0x00000030, 0x0020de3c, ME_DBG_WR},
+{0x00000034, 0x00001055, ME_DBG_WR},
+{0x00000030, 0x0020de40, ME_DBG_WR},
+{0x00000034, 0x00001055, ME_DBG_WR},
+{0x00000030, 0x0020de44, ME_DBG_WR},
+{0x00000034, 0x07ae0012, ME_DBG_WR},
+{0x00000030, 0x0020de48, ME_DBG_WR},
+{0x00000034, 0x00000a66, ME_DBG_WR},
+{0x00000030, 0x0020de4c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020de50, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020de54, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020de58, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020de5c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000546f4, ME_DBG_WR},
+{0x00000034, 0x6c1ac016, ME_DBG_WR},
+{0x00000030, 0x000546f8, ME_DBG_WR},
+{0x00000034, 0x405a0800, ME_DBG_WR},
+{0x00000030, 0x000546fc, ME_DBG_WR},
+{0x00000034, 0x40a20000, ME_DBG_WR},
+{0x00000030, 0x00054700, ME_DBG_WR},
+{0x00000034, 0x40580800, ME_DBG_WR},
+{0x00000030, 0x00054704, ME_DBG_WR},
+{0x00000034, 0x40a20000, ME_DBG_WR},
+{0x00000030, 0x00054708, ME_DBG_WR},
+{0x00000034, 0x80000c14, ME_DBG_WR},
+{0x00000030, 0x0005470c, ME_DBG_WR},
+{0x00000034, 0x80000c0c, ME_DBG_WR},
+{0x00000030, 0x00054710, ME_DBG_WR},
+{0x00000034, 0x80000c16, ME_DBG_WR},
+{0x00000030, 0x00054714, ME_DBG_WR},
+{0x00000034, 0x80000c0e, ME_DBG_WR},
+{0x00000030, 0x00054718, ME_DBG_WR},
+{0x00000034, 0x40320000, ME_DBG_WR},
+{0x00000030, 0x0005471c, ME_DBG_WR},
+{0x00000034, 0x00004000, ME_DBG_WR},
+{0x00000030, 0x00054720, ME_DBG_WR},
+{0x00000034, 0x40020000, ME_DBG_WR},
+{0x00000030, 0x00054724, ME_DBG_WR},
+{0x00000034, 0x6c16e000, ME_DBG_WR},
+{0x00000030, 0x00054728, ME_DBG_WR},
+{0x00000034, 0x405a0800, ME_DBG_WR},
+{0x00000030, 0x0005472c, ME_DBG_WR},
+{0x00000034, 0x40a20000, ME_DBG_WR},
+{0x00000030, 0x00054730, ME_DBG_WR},
+{0x00000034, 0x40580800, ME_DBG_WR},
+{0x00000030, 0x00054734, ME_DBG_WR},
+{0x00000034, 0x40a20000, ME_DBG_WR},
+{0x00000030, 0x00054738, ME_DBG_WR},
+{0x00000034, 0x80030c14, ME_DBG_WR},
+{0x00000030, 0x0005473c, ME_DBG_WR},
+{0x00000034, 0x80030c0c, ME_DBG_WR},
+{0x00000030, 0x00054740, ME_DBG_WR},
+{0x00000034, 0x80032c16, ME_DBG_WR},
+{0x00000030, 0x00054744, ME_DBG_WR},
+{0x00000034, 0x80032c0e, ME_DBG_WR},
+{0x00000030, 0x00054748, ME_DBG_WR},
+{0x00000034, 0x40320000, ME_DBG_WR},
+{0x00000030, 0x0005474c, ME_DBG_WR},
+{0x00000034, 0x40020000, ME_DBG_WR},
+{0x00000030, 0x00055474, ME_DBG_WR},
+{0x00000034, 0x00004000, ME_DBG_WR},
+{0x00000030, 0x00055478, ME_DBG_WR},
+{0x00000034, 0x40020000, ME_DBG_WR},
+{0x00000030, 0x0005bd4c, ME_DBG_WR},
+{0x00000034, 0x6c16c01a, ME_DBG_WR},
+{0x00000030, 0x0005bd50, ME_DBG_WR},
+{0x00000034, 0x405a0800, ME_DBG_WR},
+{0x00000030, 0x0005bd54, ME_DBG_WR},
+{0x00000034, 0x40a20000, ME_DBG_WR},
+{0x00000030, 0x0005bd58, ME_DBG_WR},
+{0x00000034, 0x40580800, ME_DBG_WR},
+{0x00000030, 0x0005bd5c, ME_DBG_WR},
+{0x00000034, 0x40a20000, ME_DBG_WR},
+{0x00000030, 0x0005bd60, ME_DBG_WR},
+{0x00000034, 0x80030c14, ME_DBG_WR},
+{0x00000030, 0x0005bd64, ME_DBG_WR},
+{0x00000034, 0x80031c0c, ME_DBG_WR},
+{0x00000030, 0x0005bd68, ME_DBG_WR},
+{0x00000034, 0x80032c16, ME_DBG_WR},
+{0x00000030, 0x0005bd6c, ME_DBG_WR},
+{0x00000034, 0x80033c0e, ME_DBG_WR},
+{0x00000030, 0x0005bd70, ME_DBG_WR},
+{0x00000034, 0x40320000, ME_DBG_WR},
+{0x00000030, 0x0005bd74, ME_DBG_WR},
+{0x00000034, 0x00004000, ME_DBG_WR},
+{0x00000030, 0x0005bd78, ME_DBG_WR},
+{0x00000034, 0x40020000, ME_DBG_WR},
+{0x00000030, 0x0005cacc, ME_DBG_WR},
+{0x00000034, 0x00004000, ME_DBG_WR},
+{0x00000030, 0x0005cad0, ME_DBG_WR},
+{0x00000034, 0x40020000, ME_DBG_WR},
+{0x00000030, 0x0020c400, ME_DBG_WR},
+{0x00000034, 0x0000003c, ME_DBG_WR},
+{0x00000030, 0x0020c404, ME_DBG_WR},
+{0x00000034, 0x00000014, ME_DBG_WR},
+{0x00000030, 0x0020c408, ME_DBG_WR},
+{0x00000034, 0x00000004, ME_DBG_WR},
+{0x00000030, 0x0020c40c, ME_DBG_WR},
+{0x00000034, 0x0007ffe1, ME_DBG_WR},
+{0x00000030, 0x0020c414, ME_DBG_WR},
+{0x00000034, 0x0cd2ac05, ME_DBG_WR},
+{0x00000030, 0x0020c424, ME_DBG_WR},
+{0x00000034, 0x1a0009e8, ME_DBG_WR},
+{0x00000030, 0x0020c434, ME_DBG_WR},
+{0x00000034, 0x34000000, ME_DBG_WR},
+{0x00000030, 0x0020c444, ME_DBG_WR},
+{0x00000034, 0x32000000, ME_DBG_WR},
+{0x00000030, 0x0020c474, ME_DBG_WR},
+{0x00000034, 0x04000040, ME_DBG_WR},
+{0x00000030, 0x0020c478, ME_DBG_WR},
+{0x00000034, 0x00000806, ME_DBG_WR},
+{0x00000030, 0x0020c47c, ME_DBG_WR},
+{0x00000034, 0x00000040, ME_DBG_WR},
+{0x00000030, 0x0020c480, ME_DBG_WR},
+{0x00000034, 0x00004800, ME_DBG_WR},
+{0x00000030, 0x0020c48c, ME_DBG_WR},
+{0x00000034, 0x04000040, ME_DBG_WR},
+{0x00000030, 0x0020c490, ME_DBG_WR},
+{0x00000034, 0x00000806, ME_DBG_WR},
+{0x00000030, 0x0020c494, ME_DBG_WR},
+{0x00000034, 0x00000040, ME_DBG_WR},
+{0x00000030, 0x0020c498, ME_DBG_WR},
+{0x00000034, 0x00004800, ME_DBG_WR},
+{0x0000002c, 0x0020c4a8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_RD},
+{0x00000030, 0x0020c4a8, ME_DBG_WR},
+{0x00000034, 0x00421a54, ME_DBG_WR},
+{0x0000002c, 0x0020c4b0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_RD},
+{0x00000030, 0x0020c4b0, ME_DBG_WR},
+{0x00000034, 0x101a09ec, ME_DBG_WR},
+{0x00000030, 0x0020c4b4, ME_DBG_WR},
+{0x00000034, 0x00400000, ME_DBG_WR},
+{0x00000030, 0x0020c4b8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020c4bc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020c4c0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020c4c4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020c4c8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020c4cc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020c4d0, ME_DBG_WR},
+{0x00000034, 0x00400000, ME_DBG_WR},
+{0x00000030, 0x0020c4d4, ME_DBG_WR},
+{0x00000034, 0x00014416, ME_DBG_WR},
+{0x00000030, 0x0020c4d8, ME_DBG_WR},
+{0x00000034, 0x0000a4d0, ME_DBG_WR},
+{0x00000030, 0x0020c4dc, ME_DBG_WR},
+{0x00000034, 0x0090deda, ME_DBG_WR},
+{0x00000030, 0x0020c4e0, ME_DBG_WR},
+{0x00000034, 0x00014d3a, ME_DBG_WR},
+{0x00000030, 0x0020c4e4, ME_DBG_WR},
+{0x00000034, 0x000bf21e, ME_DBG_WR},
+{0x00000030, 0x0020c4ec, ME_DBG_WR},
+{0x00000034, 0xb9ec4000, ME_DBG_WR},
+{0x00000030, 0x0020c4f0, ME_DBG_WR},
+{0x00000034, 0x99a376e5, ME_DBG_WR},
+{0x00000030, 0x0020c4f4, ME_DBG_WR},
+{0x00000034, 0x0013969e, ME_DBG_WR},
+{0x00000030, 0x0020c4f8, ME_DBG_WR},
+{0x00000034, 0x33900000, ME_DBG_WR},
+{0x00000030, 0x0020c4fc, ME_DBG_WR},
+{0x00000034, 0xc8078407, ME_DBG_WR},
+{0x00000030, 0x0020c500, ME_DBG_WR},
+{0x00000034, 0x30f00000, ME_DBG_WR},
+{0x00000030, 0x0020c504, ME_DBG_WR},
+{0x00000034, 0xc002e029, ME_DBG_WR},
+};
+
+#endif /* __PROG_RATE_H */
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/unified_qos_ds_be.h b/drivers/net/ethernet/lantiq/vrx318/include/unified_qos_ds_be.h
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/unified_qos_ds_be.h
@@ -0,0 +1,224 @@
+/******************************************************************************
+ *
+ *                        Copyright (c) 2012, 2014, 2015
+ *                           Lantiq Deutschland GmbH
+ *
+ *  For licensing information, see the file 'LICENSE' in the root folder of
+ *  this software module.
+ *
+ ******************************************************************************/
+#ifndef __UNIFIED_QOS_DS_BE_H_
+#define __UNIFIED_QOS_DS_BE_H_
+
+typedef struct {
+	unsigned int enq_mbox_addr;
+
+	unsigned int enq_mbox_int_q0_val;
+
+	unsigned int deq_mbox_addr;
+
+	unsigned int deq_mbox_int_q0_val;
+} qosq_event_mbox_int_cfg_t;
+
+typedef struct {
+	unsigned int time_tick:16;
+	unsigned int qosq_num:8;
+	unsigned int _res0:7;
+	unsigned int qos_en:1;
+} qos_cfg_t;
+
+typedef struct {
+	unsigned int _res0:11;
+	unsigned int port_shaper_enable_map:1;
+	unsigned int outq_shaper_enable_map:4;
+	unsigned int qosq_shaper_enable_map:16;
+} shaping_cfg_t;
+
+typedef struct {
+	unsigned int wfq_force_reload_map:16;
+	unsigned int wfq_reload_enable_map:16;
+} wfq_cfg_t;
+
+typedef struct {
+	unsigned int time_tick:16;
+	unsigned int overhd_bytes:8;
+	unsigned int eth1_eg_qnum:4;
+	unsigned int _res0:1;
+	unsigned int eth1_qss:1;
+	unsigned int shape_en:1;
+	unsigned int wfq_en:1;
+} tx_qos_cfg_t;
+
+typedef struct {
+	unsigned int mailbox_int_addr;
+	unsigned int mailbox_value;
+} desq_mbox_int_cfg_t;
+
+typedef struct {
+	unsigned int des_in_own_val:1;
+	unsigned int _res0:1;
+	unsigned int mbox_int_en:1;
+	unsigned int _res1:5;
+	unsigned int des_num:8;
+	unsigned int des_base_addr:16;
+
+	unsigned int mbox_int_cfg_ptr:16;
+	unsigned int enq_idx:16;
+} swapq_cfg_ctxt_t;
+
+typedef struct {
+	unsigned int des_in_own_val:1;
+	unsigned int fast_path:1;
+	unsigned int mbox_int_en:1;
+	unsigned int des_sync_needed:1;
+	unsigned int _res0:1;
+	unsigned int gif_id:3;
+	unsigned int des_num:8;
+	unsigned int des_base_addr:16;
+
+	unsigned int mbox_int_cfg_ptr:16;
+	unsigned int bp_des_base_addr:16;
+
+	unsigned int deq_idx:16;
+	unsigned int enq_idx:16;
+
+	unsigned int _dw_res0;
+
+	unsigned int enq_pkt_cnt;
+
+	unsigned int enq_byte_cnt;
+
+	unsigned int deq_pkt_cnt;
+
+	unsigned int deq_byte_cnt;
+} desq_cfg_ctxt_t;
+
+typedef struct {
+	unsigned int qos_en:1;
+	unsigned int _res0:7;
+	unsigned int qid_mask:4;
+	unsigned int qosq_base_qid:4;
+	unsigned int desq_cfg_ctxt:16;
+} inq_qos_cfg_t;
+
+typedef struct {
+	unsigned int threshold:8;
+	unsigned int des_num:8;
+	unsigned int des_base_addr:16;
+
+	unsigned int deq_idx:16;
+	unsigned int enq_idx:16;
+} qosq_cfg_ctxt_t;
+
+typedef struct {
+	unsigned int qmap:16;
+	unsigned int overhd_bytes:8;
+	unsigned int _res0:4;
+	unsigned int weight_reload:1;
+	unsigned int wfq_en:1;
+	unsigned int shape_en:1;
+	unsigned int qos_en:1;
+
+	unsigned int l2_shaping_cfg_ptr:16;
+	unsigned int l3_shaping_cfg_ptr:16;
+
+	unsigned int _res1:2;
+	unsigned int l2_shaping_cfg_idx:5;
+	unsigned int l3_shaping_cfg_idx:5;
+	unsigned int _res2:4;
+	unsigned int desq_cfg_ctxt:16;
+
+	unsigned int weight_negative_qmap:16;
+	unsigned int shaping_done_qmap:16;
+} outq_qos_cfg_ctxt_t;
+
+typedef struct {
+	unsigned int t:8;
+	unsigned int w:24;
+
+	unsigned int s:16;
+	unsigned int r:16;
+
+	unsigned int _res0:8;
+	unsigned int d:24;
+
+	unsigned int q_off:1;
+	unsigned int shaping_min_b_check:1;
+	unsigned int _res1:6;
+	unsigned int tick_cnt:8;
+	unsigned int b:16;
+} shaping_wfq_cfg_t;
+
+typedef struct {
+	unsigned int rx_pkt_cnt;
+
+	unsigned int rx_byte_cnt;
+
+	unsigned int tx_pkt_cnt;
+
+	unsigned int tx_byte_cnt;
+
+	unsigned int small_pkt_drop_cnt;
+
+	unsigned int small_pkt_drop_byte_cnt;
+
+	unsigned int large_pkt_drop_cnt;
+
+	unsigned int large_pkt_drop_byte_cnt;
+} qosq_mib_t;
+
+typedef struct {
+	unsigned int large_frame_drop_th:16;
+	unsigned int large_frame_size:16;
+} qosq_flow_ctrl_cfg_t;
+
+typedef struct {
+	unsigned int _res0:14;
+	unsigned int byte_off:2;
+	unsigned int data_len:16;
+} std_des_cfg_t;
+
+typedef struct {
+	unsigned int own:1;
+	unsigned int c:1;
+	unsigned int sop:1;
+	unsigned int eop:1;
+	unsigned int dic:1;
+	unsigned int pdu_type:1;
+	unsigned int byte_off:3;
+	unsigned int qos:4;
+	unsigned int mpoa_pt:1;
+	unsigned int mpoa_type:2;
+	unsigned int data_len:16;
+
+	unsigned int data_ptr:32;
+} tx_descriptor_t;
+
+typedef struct {
+	unsigned int _res0:30;
+	unsigned int data_len_adj:2;
+} des_sideband_t;
+
+typedef struct {
+	unsigned int own:1;
+	unsigned int c:1;
+	unsigned int sop:1;
+	unsigned int eop:1;
+	unsigned int dic:1;
+	unsigned int pdu_type:1;
+	unsigned int byte_off:3;
+	unsigned int qos:4;
+	unsigned int mpoa_pt:1;
+	unsigned int gid:2;
+	unsigned int data_len:16;
+
+	unsigned int data_ptr:32;
+} rx_descriptor_t;
+
+typedef struct {
+	unsigned int _res0:16;
+	unsigned int overflow_state_threshold:8;
+	unsigned int non_overflow_state_threshold:8;
+} flow_control_cfg_t;
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_a1plus_addr_def.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_a1plus_addr_def.h
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_a1plus_addr_def.h
@@ -0,0 +1,856 @@
+/******************************************************************************
+ *
+ *                        Copyright (c) 2012, 2014, 2015
+ *                           Lantiq Deutschland GmbH
+ *
+ *  For licensing information, see the file 'LICENSE' in the root folder of
+ *  this software module.
+ *
+ ******************************************************************************/
+#ifndef __VRX218_A1PLUS_ADDR_DEF_INC
+#define __VRX218_A1PLUS_ADDR_DEF_INC
+
+//=============================================================================
+// Defines for "PPE DSL Notifications" Module
+//=============================================================================
+#define __DREG_BC0_LINK_STATUS              0x7DC0
+#define __DREG_BC1_LINK_STATUS              0x7DD0
+#define __DREG_MEI_STATE                    0x7DC1
+#define __DREG_PDBRAM_S_44K_OWN             0x7DC2
+#define __DREG_SIGNATURE                    0x7DC3
+#define __SFSM_PGCNT0                       0x741C
+#define __SFSM_PGCNT1                       0x741D
+
+//=============================================================================
+// General Configuraton:  0x2000 - 0x202F
+// Need to be refined further
+//=============================================================================
+#define __FW_VER_ID                     0x2001
+#define __PP32_0_TIME                   0x2002
+#define __PP32_1_TIME                   0x2003
+
+#define __DSL_LINK_DOWN                 0x2004
+
+//Number of times DREG_PDBRAM_S_44K_OWN changes from S_44K_OWN_PPE to S_44K_OWN_DSL
+#define __PDBRAM_OWN_CHG_CNT            0x34B7
+
+#define __CFG_WRX_HTUTS                 0x2010
+#define __STD_DES_CFG                   0x2011
+#define __CFG_STD_DATA_LEN              __STD_DES_CFG
+#define __QOS_CFG                       0x2012
+#define __TX_QOS_CFG                    __QOS_CFG
+#define __QOSQ_FLOW_CTRL_CFG            0x2013
+#define __CFG_TX_QOSQ_BANDWIDTH_CTRL    __QOSQ_FLOW_CTRL_CFG
+
+#define __PSAVE_CFG                     0x2014
+
+#define __CFG_WRX_DMACH_ON              0x2015
+#define __CFG_WTX_DMACH_ON              0x2016
+#define __CFG_WRX_HUNT_BITTH            0x2017
+#define __CFG_WAN_WRDES_DELAY           0x2018
+
+#define __QOS_SHADOW_TTICK              0x201E
+#define __TX_QOS_CFG_SHADOW             __QOS_SHADOW_TTICK
+
+#define __PP32_0_TASK_CFG               0x2020
+#define __PP32_1_TASK_CFG               0x2021
+
+#define __PP32_0_MODULE_ACTIVITY        0x2022
+#define __PP32_1_MODULE_ACTIVITY        0x2023
+#define __VRX218_FLOW_CTRL_CFG           0x2026  /* new */
+
+    //*********************************************************************************
+    // MACRO to load the address to Register
+    //*********************************************************************************
+    #define xLDI_FW_VER_ID(__rd)                                ldi __rd 0 __FW_VER_ID
+    #define xLDI_CFG_WRX_HTUTS(__rd)                            ldi __rd 0 __CFG_WRX_HTUTS
+    #define xLDI_CFG_WAN_WRDES_DELAY(__rd)                      ldi __rd 0 __CFG_WAN_WRDES_DELAY
+    #define xLDI_CFG_WRX_DMACH_ON(__rd)                         ldi __rd 0 __CFG_WRX_DMACH_ON
+    #define xLDI_CFG_WTX_DMACH_ON(__rd)                         ldi __rd 0 __CFG_WTX_DMACH_ON
+    #define xLDI_CFG_WRX_HUNT_BITTH(__rd)                       ldi __rd 0 __CFG_WRX_HUNT_BITTH
+    #define xLDI_VRX218_FLOW_CTRL_CFG(__rd)                     ldi __rd 0 __VRX218_FLOW_CTRL_CFG
+
+//=============================================================================
+// Unified QoS Part
+//=============================================================================
+#define __INQ_QOS_CFG_BASE              0x2508  /* 0x2508-0x2509  2   x 1 = 2       */
+#define __US_FAST_PATH_DES_LIST_BASE    0x2580  /* 0x2580-0x25FF  64  x 2 = 128     */
+#define __US_CPU_PATH_DEST_LIST_BASE    0x3D00  /* 0x3D00-0x3D7F  64  x 2 = 128     */
+#define __QOSQ_OVERFLOW_STATE_BMAP      0x250c  /* 0x250c-0x250c  1   x 1 = 1       */
+
+#define __QOSQ_CFG_CTXT_BASE            0x2FE0  /* 0x2FE0-0x2FFF  16  x 2 = 32      */
+#define __QOSQ_PSEUDO_DES_CFG_BASE      0x2E80  /* 0x2E80-0x2EFF  16  x 8 = 128     */
+#define __US_QOSQ_DES_LIST_BASE         0x2800  /* 0x2800-0x2BFF  512 x 2 = 1024    */
+
+#define __QOSQ_PKT_CNT                  0x2680   /* 0x2680-0x268f 16   x 1 = 1       */
+
+#define __QOSQ_MIB_BASE                 0x2030  /* 0x2030-0x20AF  16  x 8 = 128     */
+#define __QOSQ_EVENT_MBOX_INT_CFG       0x3F10  /* 0x3F10-0x3F13  1   x 4 = 4       */
+#define __SWAPQ_CFG_CTXT_BASE           0x2500  /* 0x2500-0x2501  1   * 2 = 2       */
+#define __SWAPQ_DES_LIST_BASE           0x3F60  /* 0x3F60-0x3F9F  32  * 2 = 64      */
+#define __DESQ_MBOX_INT_CFG             0x3F14  /* 0x3F14-0x3F1F  6    x 2 = 12     */
+
+#define __US_FP_INQ_DES_CFG_CTXT        0x20B0  /* 0x20B0-0x20B7  1  x 8 = 8      */
+#define __US_CPU_INQ_DES_CFG_CTXT       0x20B8  /* 0x20B8-0x20BF  1  x 8 = 8      */
+
+//=============================================================================
+// Des Queues, eDMA  copy channel mgm, des_sync (SmartPhy Part)
+//=============================================================================
+#define __US_TC_LOCAL_Q_CFG_CTXT_BASE   0x2E00  /* 0x2E00-0x2E7F  16 x 8 = 128 */
+#define __US_TC_LOCAL_Q_DES_LIST_BASE   0x2360  /* 0x2360-0x238F  1  x 48= 48  */
+#define __US_EDMA_COPY_CH_CFG           0x2340  /* 0x2340-0x234F  16 x 1 = 16   */
+#define __US_EDMA_READ_CH_CFG_CTXT      0x2798  /* 0x2798-0x279F  1  x 8 = 8   */
+#if (LLE_IN_PDBRAM == 1)
+    // To optimize EDMA read/write performance, EDMA_LLE is moved to PDBRAM, EDMA_LLE_EXT
+    // size is also increased to 6 to ease FW process (Apr 24, 2012)
+    #define __US_EDMA_LLE_BASE          0x6600  /* 0x6600-0x66C5  33 x 6 = 198*/
+#else
+    #define __US_EDMA_LLE_BASE          0x2390  /* 0x2390-0x2455  33 x 6 = 198*/
+#endif
+#define __US_EDMA_LLE_FPI_BASE          0x1E0A3800  /* 0x1E0A3800-0x1E0A3B17  33 x 24 = 792 bytes*/
+#define __US_EDMA_LLE_EXT_BASE          0x3796  /* 0x3796-0x385B  33 x 6 = 198 */
+#define __DS_TC_AAL5_LOCAL_Q_CFG_CTXT   0x20E0  /* 0x20E0-0x20E7  1  x 8 = 8  */
+#define __DS_TC_OAM_LOCAL_Q_CFG_CTXT    0x20E8  /* 0x20E8-0x20EF  1  x 8 = 8  */
+#define __DS_TC_LOCAL_AAL5Q_DES_LIST_BASE   0x3F20  /* 0x3F20-0x3F5F  32  x 2 = 64  */
+#define __DS_TC_LOCAL_OAMQ_DES_LIST_BASE    0x24D0  /* 0x24D0-0x24EF  16  x 2 = 32  */
+#define __DS_PKT_DESQ_CFG_CTXT          0x20F0  /* 0x20F0-0x20F7  1  x 8 = 8   */
+#define __DS_PKT_DES_LIST_BASE          0x2600  /* 0x2600-0x263F  32 x 2 = 64*/
+#define __DS_OAM_DESQ_CFG_CTXT          0x20F8  /* 0x20F8-0x20FF  1  x 8 = 8   */
+#define __DS_OAM_DES_LIST_BASE          0x2640  /* 0x2640-0x267F  32 x 2 = 64*/
+
+#define __DS_EDMA_COPY_CH_CFG           0x250A  /* 0x250A-0x250B  2  x 1 = 2  */
+#define __DS_EDMA_WRITE_CH_CFG_CTXT     0x2790  /* 0x2790-0x2798  1  x 8 = 8  */
+#if (LLE_IN_PDBRAM == 1)
+    // To optimize EDMA read/write performance, EDMA_LLE is moved to PDBRAM, EDMA_LLE_EXT
+    // size is also increased to 6 to ease FW process (Apr 24, 2012)
+    #define __DS_EDMA_LLE_BASE          0x6700  /* 0x6700-0x67C5  33 x 6 = 198*/
+#else
+    #define __DS_EDMA_LLE_BASE          0x3600  /* 0x3600-0x36C5  33 x 6 = 198*/
+#endif
+#define __DS_EDMA_LLE_FPI_BASE          0x1E0A3C00  /* 0x1E0A3C00-0x1E0A3F17  33 x 24 = 792 bytes*/
+#define __DS_EDMA_LLE_EXT_BASE          0x36D0  /* 0x36D0-0x3795  33 x 6 = 198 */
+#define __DES_SYNC_CFG_CTXT             0x2F00  /* 0x2F00-0x2FBF  6  x 32= 192*/
+#define __CDMA_DES_SYNC_DEST_LIST_BASE  0x27A0  /* 0x27A0-0x27FF  6  x 4 x 2 x 2 = 96 */
+#define __EDMA_RD_CNT_SM                0x2560  /* 0x2560-0x256F  1  x 16= 16 */
+
+// To optimize EDMA read/write performance, EDMA_LLE is moved to PDBRAM.
+// 0x1E0A2000-0x1E0A3FFF, (second half of PDBRAM8 0x1E0A0000-0x1E0A3FFF)
+// the last 2k bytes are used for EDMA_LLE
+// __US_EDMA_LLE_BASE: 0x6600-0x66FF (FPI: 0x1E0A3800-0x1E0A3BFF)
+// __US_EDMA_LLE_BASE: 0x6700-0x67FF (FPI: 0x1E0A3C00-0x1E0A3FFF)
+#define __EDMA_LLE_BLOCK_FPI_ADDR       0x1E0A2000
+#define __EDMA_LLE_BLOCK_FPI_ADDR_Hi    0x1E0A
+#define __EDMA_LLE_BLOCK_FPI_ADDR_Lo    0x2000
+#define xLDI_edma_lle_block_fpi_addr(__rd) \
+    xLDI_dword(__rd, __EDMA_LLE_BLOCK_FPI_ADDR_Hi, __EDMA_LLE_BLOCK_FPI_ADDR_Lo)
+
+#if (LLE_IN_PDBRAM == 1)
+    #define __US_EDMA_LLE_LINK_ELEM         0x66C0  /* 0x6600-0x66C5  33 x 6 = 198*/
+    #define __DS_EDMA_LLE_LINK_ELEM         0x67C0  /* 0x6700-0x67C5  33 x 6 = 198*/
+#else
+    #define __US_EDMA_LLE_LINK_ELEM         0x2450  /* 0x2390-0x2455  33 x 6 = 198*/
+    #define __DS_EDMA_LLE_LINK_ELEM         0x36C0  /* 0x3600-0x36C5  33 x 6 = 198*/
+#endif
+
+ #define __EDMA_HANG_BENCH_RD_IDX      0x2510  /*0x2510-0x2511 0:write channel  1: read channel*/
+ #define __EDMA_HANG_DETECT_CNT        0x2512  /*0x2512-0x2513 0:write channel  1: read channel*/
+ #define __EDMA_HANG_DETECT_TH         0x2514  /* 1Dword*/
+ #define __EDMA_HANG_DETECT_MIB        0x2516  /* 1Dword*/
+//----------------------------------------------------------
+// Detailed Memory Allocation
+//----------------------------------------------------------
+
+//**********************************************
+//"Unified QoS" Module Memory Allocation - START
+//**********************************************
+
+//2 INQs; CPU Path & Fast Path
+#define __INQ_QOS_CFG_BASE              0x2508
+#define __INQ_QOS_CFG_END               0x2509
+#define __INQ_QOS_CFG_SIZE              1
+
+//16 QoSQs
+#define __QOSQ_CFG_CTXT_BASE            0x2FE0
+#define __QOSQ_CFG_CTXT_END             0x2FFF
+#define __QOSQ_CFG_CTXT_SIZE            2
+
+//16 QoSQs
+#define __QOSQ_MIB_BASE                 0x2030
+#define __QOSQ_MIB_END                  0x20AF
+#define __QOSQ_MIB_SIZE                 8
+
+
+//#define __SWAPQ_CFG_CTXT_BASE           0x2500
+#define __SWAPQ_CFG_CTXT_DW1_ADDR       0x2501
+#define __SWAPQ_CFG_CTXT_END            0x2501
+#define __SWAPQ_CFG_CTXT_SIZE           2
+
+//**********************************************
+//"Unified QoS" Module Memory Allocation - END
+//**********************************************
+
+#define __DES_SYNC_CFG_CTXT_BASE        __DES_SYNC_CFG_CTXT
+#define __DES_SYNC_CFG_CTXT_BASE_END    0x2FBF
+
+#define __DES_READ_SYNC_CFG_CTXT_BASE  __DES_SYNC_CFG_CTXT_BASE
+#define __DES_READ_SYNC_CFG_CTXT_END   __DES_SYNC_CFG_CTXT_BASE_END
+
+#define __DES_WRITE_SYNC_CFG_CTXT_BASE  __DES_SYNC_CFG_CTXT_BASE
+#define __DES_WRITE_SYNC_CFG_CTXT_END   __DES_SYNC_CFG_CTXT_BASE_END
+
+
+#define __EDMA_CH_CTXT_BASE             __DS_EDMA_WRITE_CH_CFG_CTXT
+#define __EDMA_WRITE_CH_CTXT            __DS_EDMA_WRITE_CH_CFG_CTXT
+#define __EDMA_READ_CH_CTXT             __US_EDMA_READ_CH_CFG_CTXT
+#define __EDMA_CH_CTXT_BASE_END         0x27A0
+
+
+#define __EDMA_WRITE_COPY_CH_CFG_BASE   __DS_EDMA_COPY_CH_CFG
+#define __EDMA_WRITE_COPY_CH_CFG_END    0x250C
+
+#define __EDMA_READ_COPY_CH_CFG_BASE    __US_EDMA_COPY_CH_CFG
+#define __EDMA_READ_COPY_CH_CFG_END     0x2350
+
+// SB = 0x7000
+#define __WRITE_CH_DOORBELL_EXT_ADDR    0x1E700980
+#define __WRITE_CH_DOORBELL_EXT_ADDR_hi 0x1E70
+#define __WRITE_CH_DOORBELL_EXT_ADDR_lo 0x0980
+
+// SB = 0x7001
+#define __READ_CH_DOORBELL_EXT_ADDR     0x1E709A0
+#define __READ_CH_DOORBELL_EXT_ADDR_hi  0x1E70
+#define __READ_CH_DOORBELL_EXT_ADDR_lo  0x09A0
+
+//---------------------------------------------------------------
+// EDMA_RD_CNT_SM related
+
+#define __EDMA_WRITE_CH_STATUS_SBADDR   0x2350
+#define __EDMA_READ_CH_STATUS_SBADDR    0x2358
+
+#define __EDMA_CH_CTXT_IDX_FPI_ADDR     0x1E700A6C
+#define __EDMA_CH_CTXT_IDX_FPI_hi       0x1E70
+#define __EDMA_CH_CTXT_IDX_FPI_low      0x0A6C
+#define xLDI_edma_ch_ctxt_idx_fpi_addr(__rd) \
+    xLDI_dword(__rd, __EDMA_CH_CTXT_IDX_FPI_hi, __EDMA_CH_CTXT_IDX_FPI_low)
+
+#define __EDMA_LL_PTR_LOW_FPI_ADDR      0x1E700A8C
+#define __EDMA_LL_PTR_LOW_FPI_hi        0x1E70
+#define __EDMA_LL_PTR_LOW_FPI_lo        0x0A8C
+#define xLDI_edma_ll_ptr_fpi_addr(__rd) \
+    xLDI_dword(__rd, __EDMA_LL_PTR_LOW_FPI_hi, __EDMA_LL_PTR_LOW_FPI_lo)
+
+#define __EDMA_CH_STATUS_LOW_FPI_ADDR       0x1E700A70
+#define __EDMA_CH_STATUS_LOW_FPI_hi         0x1E70
+#define __EDMA_CH_STATUS_LOW_FPI_lo         0x0A70
+#define xLDI_edma_ch_status_fpi_addr(__rd) \
+    xLDI_dword(__rd, __EDMA_CH_STATUS_LOW_FPI_hi, __EDMA_CH_STATUS_LOW_FPI_lo)
+
+#if 0
+//Prior PPA2.16
+//=============================================================================
+// Extra DS packet buffer for A1Plus to avoid DS packet drop (due to no descriptors)
+//   total 13 packets
+//   packet size = 400 DWs = 1600 bytes
+//=============================================================================
+#define __DS_SB_PKT_DATA_PTR_0  0x2100  /* 0x2100-0x228F, size = 400DW */
+#define __DS_SB_PKT_DATA_PTR_1  0x2C00  /* 0x2C00-0x2D8F, size = 400DW */
+#define __DS_SB_PKT_DATA_PTR_2  0x3000  /* 0x3000-0x318F, size = 400DW */
+#define __DS_SB_PKT_DATA_PTR_3  0x3190  /* 0x3190-0x331F, size = 400DW */
+#define __DS_SB_PKT_DATA_PTR_4  0x3D80  /* 0x3D80-0x3F0F, size = 400DW */
+#define __DS_SB_PKT_DATA_PTR_5  0x44E0  /* 0x44E0-0x466F, size = 400DW */
+#define __DS_SB_PKT_DATA_PTR_6  0x4670  /* 0x4670-0x47FF, size = 400DW */
+#define __DS_SB_PKT_DATA_PTR_7  0x4800  /* 0x4800-0x498F, size = 400DW */
+#define __DS_SB_PKT_DATA_PTR_8  0x4990  /* 0x4990-0x4B1F, size = 400DW */
+#define __DS_SB_PKT_DATA_PTR_9  0x4D40  /* 0x4D40-0x4ECF, size = 400DW */
+#define __DS_SB_PKT_DATA_PTR_10 0x5B00  /* 0x5B00-0x5C8F, size = 400DW */
+#define __DS_SB_PKT_DATA_PTR_11 0x5C90  /* 0x5C90-0x5E1F, size = 400DW */
+#define __DS_SB_PKT_DATA_PTR_12 0x5E20  /* 0x5E20-0x5FAF, size = 400DW */
+
+#else
+
+//PPA2.16 MTU
+//=============================================================================
+// Extra DS packet buffer for A1Plus to avoid DS packet drop (due to no descriptors)
+//   total 12 packets
+//   packet size = 408 DWs = 1632 bytes
+//=============================================================================
+
+#define __DS_SB_PKT_DATA_PTR_0  0x2100  /* 0x2100-0x2297, size = 408DW */
+#define __DS_SB_PKT_DATA_PTR_1  0x2C00  /* 0x2C00-0x2D97, size = 408DW */
+#define __DS_SB_PKT_DATA_PTR_2  0x3000  /* 0x3000-0x3197, size = 408DW */
+#define __DS_SB_PKT_DATA_PTR_3  0x3198  /* 0x3198-0x332F, size = 408DW */
+#define __DS_SB_PKT_DATA_PTR_4  0x44E0  /* 0x44E0-0x4677, size = 408DW */
+#define __DS_SB_PKT_DATA_PTR_5  0x4678  /* 0x4678-0x480F, size = 408DW */
+#define __DS_SB_PKT_DATA_PTR_6  0x4810  /* 0x4810-0x49A7, size = 408DW */
+#define __DS_SB_PKT_DATA_PTR_7  0x49A8  /* 0x49A8-0x4B3F, size = 408DW */
+#define __DS_SB_PKT_DATA_PTR_8  0x4D40  /* 0x4D40-0x4ED7, size = 408DW */
+#define __DS_SB_PKT_DATA_PTR_9  0x5B00  /* 0x5B00-0x5C97, size = 408DW */
+#define __DS_SB_PKT_DATA_PTR_10 0x5C98  /* 0x5C98-0x5E2F, size = 408DW */
+#define __DS_SB_PKT_DATA_PTR_11 0x5E30  /* 0x5E30-0x5EC7, size = 408DW */
+
+#endif
+//=============================================================================
+// DS OAM packet in share buffer for A1Plus
+//  total 10 packets
+//  packet size = 32 DWs = 128 bytes
+//=============================================================================
+
+#define __DS_SB_OAM_DATA_PTR_0  0x3BC0  /* 0x3BC0-0x3BDF, size = 32 DW */
+#define __DS_SB_OAM_DATA_PTR_1  0x3BE0  /* 0x3BE0-0x3BFF, size = 32 DW */
+#define __DS_SB_OAM_DATA_PTR_2  0x3C00  /* 0x3C00-0x3C1F, size = 32 DW */
+#define __DS_SB_OAM_DATA_PTR_3  0x3C20  /* 0x3C20-0x3C3F, size = 32 DW */
+#define __DS_SB_OAM_DATA_PTR_4  0x3C40  /* 0x3C40-0x3C5F, size = 32 DW */
+#define __DS_SB_OAM_DATA_PTR_5  0x3C60  /* 0x3C60-0x3C7F, size = 32 DW */
+#define __DS_SB_OAM_DATA_PTR_6  0x3C80  /* 0x3C80-0x3C9F, size = 32 DW */
+#define __DS_SB_OAM_DATA_PTR_7  0x3CA0  /* 0x3CA0-0x3CBF, size = 32 DW */
+#define __DS_SB_OAM_DATA_PTR_8  0x3CC0  /* 0x3CC0-0x3CDF, size = 32 DW */
+#define __DS_SB_OAM_DATA_PTR_9  0x3CE0  /* 0x3CE0-0x3CFF, size = 32 DW */
+
+#define __SOC_FAMILY                    0x2507
+
+//=============================================================================
+// A1+ part
+//=============================================================================
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+                                                    S_addr  E_addr  Size
+    General Context 1                               5000    51FF    512
+
+    DSL WAN MIB Length                              4EF0    4EFF    16
+    DSL WAN RX VC MIB Length (A5 Only)              4F00    4F3F    64
+    DSL WAN TX VC MIB Length (A5 Only)              4F40    4F7F    64
+    HTU table                                       26A0    26FF    96
+    WAN RX Queue Configuration/Context Length       4C00    4D3F    320
+    WAN RX DMA Channel Configuration/Context Length 4F80    4FB7    56
+    WAN TX Queue/DMA Configuration/Context Length   3A00    3BAF    432
+    WAN TX Port Configuration Length                4FB8    4FB9    2
+
+    SFSM 0 (pages) - Data                           5200    557F    896
+    SFSM 0 (pages) - Ctrl                           5A80    5ABF    64
+    FFSM 0 (pages) -  Data                          4000    422F    560
+    SFSM 1 (pages) - Data                           5640    59BF    896
+    SFSM 1 (pages) - Ctrl                           5AC0    5AFF    64
+    FFSM 1 (pages) -  Data                          42A8    44D7    560
+    EMA Command Buffer                              5580    559F    32
+    EMA Data Buffer                                 55A0    55DF    64
+
+    WAN RX Port Context                             55E0    55EF    16
+    WAN TX Port Context                             4FBA    4FBB    2
+    WAN TX&RX Port Context EXT Length               55F0    55FF    16
+    WAN RX Descriptor Prefetch Buffer               3900    39FF    256
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
+
+//********************************************
+// detailed allocation
+//********************************************
+
+    //----------------------------------
+    // WAN RX Descriptor Prefetch Buffer
+    // 0x5B00 - 0x5BFF
+    // Size = 16 * 16 = 256 dwords
+    //----------------------------------
+//    #define __WRX_DES_PREFETCH_BUF                  0x2600
+
+    // FPI dw address for PPE sharebuffer at 0x0000
+    #define xLDI_PPE_SB2000H_FPI_DW_ADDR(r_d)               \
+        ldi r_d 16 0x788                                    \
+        addi r_d r_d 0x6000
+
+    //------------------------------------
+    // WAN RX ALL5 Channel Descriptor List
+    // 0x5B00 - 0x5B3F
+    // Size = 32 * 2 = 64 dwords
+    //------------------------------------
+//    #define __WRX_PKT_DES_BUF                       0x2600
+
+    //------------------------------------
+    // WAN RX OAM Channel Descriptor List
+    // 0x5B40 - 0x5B7F
+    // Size = 32 * 2 = 64 dwords
+    //------------------------------------
+//    #define __WRX_OAM_DES_BUF                       0x2640
+
+    //---------------------------------------------
+    // DSL WAN MIB (0x4EF0 - 0x4EFF)
+    //---------------------------------------------
+    #define __WRX_DROPHTU_CELL                      0x4EF1
+    #define __WRX_DROPDES_PDU                       0x4EF2
+    #define __WRX_CORRECT_PDU                       0x4EF3
+    #define __WRX_ERR_PDU                           0x4EF4
+    #define __WRX_DROPDES_CELL                      0x4EF5
+    #define __WRX_CORRECT_CELL                      0x4EF6
+    #define __WRX_ERR_CELL                          0x4EF7
+    #define __WRX_TOTAL_BYTE                        0x4EF8
+    #define __WTX_TOTAL_PDU                         0x4EFA
+    #define __WTX_TOTAL_CELL                        0x4EFB
+    #define __WTX_TOTAL_BYTE                        0x4EFC
+
+    //--------------------------
+    // DSL WAN RX VC MIB
+    // 0x4F00 - 0x4F3F
+    // Size = 16 * 4 = 64 dwords
+    //--------------------------
+    #define __WRX_VC_MIB_BASE                       0x4F00
+    #define __WRX_VC_IG_PKTS_OFF                    0
+    #define __WRX_VC_IG_BYTES_OFF                   1
+
+    //--------------------------
+    // DSL WAN TX VC MIB
+    // 0x4F40 - 0x4F7F
+    // Size = 16 * 4 = 64 dwords
+    //--------------------------
+    #define __WTX_VC_MIB_BASE                       0x4F40
+    #define __WRX_VC_EG_PKTS_OFF                    1
+    #define __WRX_VC_EG_BYTES_OFF                   2
+
+    //----------------------------
+    // HTU Table (0x26A0 - 0x26FF)
+    //----------------------------
+    #define __HTU_ENTRY_TABLE                       0x26A0
+    #define __HTU_MASK_TABLE                        0x26C0
+    #define __HTU_RESULT_TABLE                      0x26E0
+
+    //---------------------------------------
+    // WAN RX Queue (Configuration + Context)
+    // 0x4C00 - 0x4D3F
+    //---------------------------------------
+    #define __WRX_QUEUE_CONFIG                      0x4C00
+
+    //---------------------------------------------
+    // WAN RX DMA Channel Configuration/Context
+    // 0x4F80 - 0x4FB7
+    // pkt queue descriptor rdptr, wrptr
+    // oam queue descriptor rdptr, wrptr
+    //---------------------------------------------
+    #define __WRX_QUEUE_CHANNEL_CONTEXT             0x4F80
+
+    //---------------------------------------
+    // WAN TX Queue/DMA Configuration/Context
+    //---------------------------------------
+    #define __WTX_QUEUE_CONFIG                      0x3A00
+
+    //------------------------
+    // DSL WAN RX Port Context
+    // 0x55E0 - 0x55EF
+    //------------------------
+    #define __WRXCTXT_TC_RdPtr0                     0x55E0
+    #define __WRXCTXT_TC_RdPtr1                     0x55E1
+    #define __WRXCTXT_L2_RdPtr0                     0x55E2
+    #define __WRXCTXT_L2_RdPtr1                     0x55E3
+    #define __WRXCTXT_L2Pages0                      0x55E4
+    #define __WRXCTXT_L2Pages1                      0x55E5
+    #define __WRXCTXT_MatchCells0                   0x55E6
+    #define __WRXCTXT_MatchCells1                   0x55E7
+    #define __WRXCTXT_NoMatchCells0                 0x55E8
+    #define __WRXCTXT_NoMatchCells1                 0x55E9
+    #define __WRXCTXT_PortState0                    0x55EA
+    #define __WRXCTXT_PortState1                    0x55EB
+    #define __WRXCTXT_Hunt_Cnt0                     0x55EC
+    #define __WRXCTXT_Hunt_Cnt1                     0x55ED
+
+//**************************
+//DSL WAN context definition
+//**************************
+
+    //---------------------------------------
+    // WAN EMA  CMD BUFFER  : 0x5580 - 0x559F
+    //     EMA  DATA BUFFER : 0x55A0 - 0x55DF
+    //---------------------------------------
+    #define __EMA_CMD_BUF                           0x5580
+    #define __EMA_DATA_BUF                          0x55A0
+    #define __WAN_EMA_CMD_BUF                       __EMA_CMD_BUF
+    #define __WAN_EMA_DATA_BUF                      __EMA_DATA_BUF
+
+    //--------------------------------------
+    // WAN TX Port Context (0x4FBA - 0x4FBB)
+    //--------------------------------------
+    #define __WTXCTXT_TC_WRPTR0                     0x4FBA
+    #define __WTXCTXT_TC_WRPTR1                     0x4FBB
+
+    //--------------------------------------------------
+    // WAN TX Port Context (extension) (0x55F0 - 0x55F1)
+    //--------------------------------------------------
+    #define __WTXCTXT_WtxDBufStart0                 0x55F0
+    #define __WTXCTXT_WtxDBufStart1                 0x55F1
+
+    //--------------------------------------------------
+    // WAN RX Port Context (extension) (0x55FC - 0x55FF)
+    //--------------------------------------------------
+    #define __WRXCTXT_WrxDBufStart0                 0x55FC
+    #define __WRXCTXT_WrxDBufStart1                 0x55FD
+    #define __WRXCTXT_WrxCBufStart0                 0x55FE
+    #define __WRXCTXT_WrxCBufStart1                 0x55FF
+
+    //--------------------------------------------
+    // WAN TX Port Configuration (0x4FB8 - 0x4FB9)
+    //--------------------------------------------
+    #define __WTX_PORT_CONFIG0                      0x4FB8
+    #define __WTX_PORT_CONFIG1                      0x4FB9
+
+    //=============================================
+    // General Context (0x5000 - 0x51FF)
+    // 0x5000 - 0x50FF used in addr_def_vr9.inc
+    //=============================================
+
+    //Verify
+    //----------------------------------------------------
+    // WAN TX ETH HEADER PREFETCH BUFFER (0x5100 - 0x513F)
+    //----------------------------------------------------
+    #define __WTX_ETH_HEADER_BUF_BASE               0x5100
+
+    //---------------------------------------------
+    // WAN - ATM General Context (0x5140 - 0x517F)
+    //---------------------------------------------
+    #define __FWGEN_BITS_WORD0                      0x5140
+    #define __FWGEN_WRX_WREMA_PEND_DID              0x5141
+    #define __FWGEN_WTX_WRDES_PEND_DID              0x5142
+    #define __FWGEN_WRX_WRDES_PEND_DID              0x5143
+    #define __FWGEN_WTX_WRDES_FINAL_PEND_DID        0x5144
+    #define __FWGEN_WRX_WRDES_FINAL_PEND_DID        0x5145
+    #define __FWGEN_WTX_RDDATA_PEND_QID             0x5146
+    #define __FWGEN_WTX_CELLBUF_EMPTY_STATUS        0x5147
+    #define __FWGEN_WTX_DMACH_NONEMPTY_STATUS       0x5148
+    #define __FWGEN_WRX_DMACH_NONEMPTY_STATUS       0x5149
+    #define __FWGEN_WRX_DMACH_VLD_STATUS            0x514A
+    #define __FWGEN_WRX_VEN                         0x514B
+    #define __FWGEN_WRX_DES_PREFETCH_DID            0x514C
+    #define __FWGEN_WRX_DID                         0x514D
+    #define __FWGEN_EMA_CMD0                        0x514E
+    #define __FWGEN_EMA_CMD1                        0x514F
+    #define __FWGEN_WRX_CELL_TYPE                   0x5150
+    #define __FWGEN_WRX_CELLID                      0x5151
+    #define __FWGEN_WRX_DESBUF_NONFULL_STATUS       0x5152
+    #define __FWGEN_WTX_DES_PREFETCH_QID            0x5153
+    #define __FWGEN_WTX_DES_PREFETCH_DID            0x5154
+    #define __FWGEN_WTX_CURRDES_VLD_STATUS          0x5155
+    #define __FWGEN_WTX_DESBUF_NONFULL_STATUS       0x5156
+    #define __FWGEN_VAR_DES0                        0x5158
+    #define __FWGEN_VAR_DES1                        0x5159
+    #define __FWGEN_WRX_CELL_HEADER                 0x515A
+    //#define __FWGEN_VAR_EMADATA_WRPTR               0x515B
+    #define __FWGEN_WRX_QID                         0x515C
+    #define __FWGEN_VAR_DWNUM                       0x515D
+    #define __FWGEN_VAR_CURR_LEN                    0x515E
+    #define __FWGEN_VAR_TRAILER_LEN                 0x515F
+    #define __FWGEN_VAR_TRAILER_UU                  0x5160
+    #define __FWGEN_VAR_TRAILER_CPI                 0x5161
+    #define __FWGEN_VAR_STW                         0x5162
+    #define __FWGEN_WTX_QID                         0x5163
+    #define __FWGEN_VAR_BMC_CMD0                    0x5164
+    #define __FWGEN_VAR_DW_OFF                      0x5165
+    #define __FWGEN_VAR_LAST_CELL                   0x5166
+    #define __FWGEN_VAR_FILL_CELL                   0x5167
+    #define __FWGEN_VAR_EXP_LEN                     0x5168
+    #define __FWGEN_WTX_CELL_HEADER                 0x5169
+    #define __FWGEN_VAR_BYTEOFF                     0x516A
+    #define __FWGEN_WTX_DATA_PREFETCH_QID           0x516B
+    #define __FWGEN_WRX_PID                         0x516C
+    #define __FWGEN_WTX_PID                         0x516D
+    #define __FWGEN_CELLS_QUEUED_0                  0x516E
+    #define __FWGEN_CELLS_QUEUED_1                  0x516F
+    #define __FWGEN_SPACE_PENDING0                  0x5170
+    #define __FWGEN_SPACE_PENDING1                  0x5171
+    #define __FWGEN_VAR_BMC_CMD1                    0x5172
+    #define __FWGEN_WRX_DESREQ_NONPEND_STATUS       0x5173
+    #define __FWGEN_WTX_DESREQ_NONPEND_STATUS       0x5174
+    #define __FWGEN_WTX_CELLREQ_NONPEND_STATUS      0x5175
+    #define __FWGEN_PREV_EMA_ISR                    0x5176
+    #define __FWGEN_MBOX0_ISR                       0x5177
+    #define __FWGEN_WTX_1ST_CELL_READ_FLAG0         0x5178
+    #define __FWGEN_WTX_1ST_CELL_READ_FLAG1         0x5179
+
+    // upstream local queue nonempty flag
+    // bit0 to bit15 correspond to q0 to q15
+    // if a bit is set, the corresponding queue is nonempty
+    #define __US_TC_LOCAL_Q_FULL_FLAG               0x517A
+
+    #ifdef VR9_FIRMWARE_DESCRAMBER
+        #define _FW_DESCRAMBER_POLY_H               0x517E
+        #define _FW_DESCRAMBER_POLY_L               0x517F
+    #endif
+
+    //=============================================
+    // EMA Context  (0x518E-0x518F)
+    //=============================================
+    #define __EMA_CONTEXT_CMD_WRPTR                 0x518E
+    #define __EMA_CONTEXT_DATA_WRPTR                0x518F
+    #define __WAN_EMA_CONTEXT_CMD_WRPTR             __EMA_CONTEXT_CMD_WRPTR
+    #define __WAN_EMA_CONTEXT_DATA_WRPTR            __EMA_CONTEXT_DATA_WRPTR
+
+    //-----------------------------------------------------
+    // WAN RX Decap buffer (0x5190 - 0x51AF)  //temp address
+    //-----------------------------------------------------
+    #define __WRX_DECAP_BUF_BASE                    0x5190
+    #define __WRX_DECAP_BUF_BASE_HW                 0x3190
+
+    //0x51B0 - 0x51BF
+    #define __FWGEN_WTX_QSB_VC_CONTEXT_BASE         0x51B0
+
+    //--------------------------------------
+    // WRX General Context (0x51C0 - 0x51C8)
+    //--------------------------------------
+    #define __FWGEN_WRX_2684_ORIGINAL_FLAG          0x51C0
+    #define __FWGEN_WRX_2684_CELL_ALIGN_OFF         0x51C1
+    #define __FWGEN_WRX_2684_MPOA_TYPE              0x51C2
+    #define __FWGEN_WRX_AAL5_CELL1_ROUNDDOWN_DWNUM  0x51C3
+    #define __FWGEN_WRX_DES_BYTES                   0x51C4
+    #define __FWGEN_WRX_FIRST_CELL                  0x51C5
+    #define __FWGEN_WRX_PKT_LEN_WO_FCS              0x51C6
+    #define __FWGEN_WRX_ETH_TYPE                    0x51C7
+    #define __FWGEN_WRX_MAC_BYTE                    0x51C8
+
+    //--------------------------------------
+    // WTX General Context (0x51C9 - 0x51DF)
+    //--------------------------------------
+    #define __FWGEN_WTX_ETH_IS_VLAN                 0x51C9
+    #define __FWGEN_WTX_MPOA_PT                     0x51CA
+    #define __FWGEN_WTX_ENCAP_PARSE_DROP            0x51CB
+
+    #define __FWGEN_WTX_2684_RM_LEN                 0x51CC
+    #define __FWGEN_WTX_2684_INSERT_LEN             0x51CD
+    #define __FWGEN_WTX_RDWNUM                      0x51CE
+    #define __FWGEN_WTX_SWOFF                       0x51CF
+
+    #define __FWGEN_WTX_CELL1_BYTEOFF               0x51D0
+    #define __FWGEN_WTX_ETH_IS_IPV4                 0x51D1
+    #define __FWGEN_WTX_ETH_IPOFF                   0x51D2
+
+    #define __FWGEN_WTX_QPKT_LEVEL_CONTROL          0x51D3
+
+    #define __FWGEN_WTX_ETH_HD_DONE                 0x51D4
+
+//---------------------------------------------------
+// Task pending flag for power save in A1plus
+//---------------------------------------------------
+#define __TASK_PENDING_FLAG_VRX318_PPA            0x51E0
+#define __WAKEUP_MIB_VRX318												0x51E1
+
+    //********************************************
+    // Macros to LOAD above Addresses
+    //********************************************
+
+    #define xLDI_WRX_DES_PREFETCH_BUF(__rd)         ldi __rd 0 __WRX_DES_PREFETCH_BUF
+    #define xLDI_WRX_PKT_DES_BUF(__rd)              ldi __rd 0 __WRX_PKT_DES_BUF
+    #define xLDI_WRX_OAM_DES_BUF(__rd)              ldi __rd 0 __WRX_OAM_DES_BUF
+
+    //---------------------------------------------
+    // DSL WAN MIB (total) - atm
+    //---------------------------------------------
+    #define xLDI_WRX_DROPHTU_CELL(__rd)             ldi __rd 0 __WRX_DROPHTU_CELL
+    #define xLDI_WRX_DROPDES_PDU(__rd)              ldi __rd 0 __WRX_DROPDES_PDU
+    #define xLDI_WRX_CORRECT_PDU(__rd)              ldi __rd 0 __WRX_CORRECT_PDU
+    #define xLDI_WRX_ERR_PDU(__rd)                  ldi __rd 0 __WRX_ERR_PDU
+    #define xLDI_WRX_DROPDES_CELL(__rd)             ldi __rd 0 __WRX_DROPDES_CELL
+    #define xLDI_WRX_CORRECT_CELL(__rd)             ldi __rd 0 __WRX_CORRECT_CELL
+    #define xLDI_WRX_ERR_CELL(__rd)                 ldi __rd 0 __WRX_ERR_CELL
+    #define xLDI_WRX_TOTAL_BYTE(__rd)               ldi __rd 0 __WRX_TOTAL_BYTE
+    #define xLDI_WTX_TOTAL_PDU(__rd)                ldi __rd 0 __WTX_TOTAL_PDU
+    #define xLDI_WTX_TOTAL_CELL(__rd)               ldi __rd 0 __WTX_TOTAL_CELL
+    #define xLDI_WTX_TOTAL_BYTE(__rd)               ldi __rd 0 __WTX_TOTAL_BYTE
+
+
+    //---------------------------------------------
+    // DSL WAN MIB (VC) - atm
+    //---------------------------------------------
+    #define xLDI_WRX_VC_MIB_BASE(__rd)              ldi __rd 0 __WRX_VC_MIB_BASE
+
+    //---------------------------------------------
+    // HTU Table
+    //---------------------------------------------
+    #define xLDI_HTU_ENTRY_TABLE(__rd)              ldi __rd 0 __HTU_ENTRY_TABLE
+    #define xLDI_HTU_MASK_TABLE(__rd)               ldi __rd 0 __HTU_MASK_TABLE
+    #define xLDI_HTU_RESULT_TABLE(__rd)             ldi __rd 0 __HTU_RESULT_TABLE
+
+    //---------------------------------------------
+    // WAN RX Queue (Configuration + Context)
+    //---------------------------------------------
+    #define xLDI_WRX_QUEUE_CONFIG(__rd)             ldi __rd 0 __WRX_QUEUE_CONFIG
+     #define xLDI_WRX_QUEUE_CHANNEL_CONTEXT(__rd)   ldi __rd 0 __WRX_QUEUE_CHANNEL_CONTEXT
+
+    //---------------------------------------------
+    // WAN TX Queue (Configuration + DMA + Q_Context + DES_Context)
+    //---------------------------------------------
+    #define xLDI_WTX_QUEUE_CONFIG(__rd)             ldi __rd 0 __WTX_QUEUE_CONFIG
+   //---------------------------------------------
+    // WAN TX Port Configuration
+    //---------------------------------------------
+    #define xLDI_WTX_PORT_CONFIG0(__rd)             ldi __rd 0 __WTX_PORT_CONFIG0
+    #define xLDI_WTX_PORT_CONFIG1(__rd)             ldi __rd 0 __WTX_PORT_CONFIG1
+
+   //---------------------------------------------
+    // WAN EMA Context
+    //---------------------------------------------
+    #define xLDI_WAN_EMA_CMD_BUF(__rd)              ldi __rd 0 __EMA_CMD_BUF
+    #define xLDI_WAN_EMA_DATA_BUF(__rd)             ldi __rd 0 __EMA_DATA_BUF
+
+    #define xLDI_EMA_CONTEXT_CMD_WRPTR(__rd)        ldi __rd 0 __EMA_CONTEXT_CMD_WRPTR
+    #define xLDI_EMA_CONTEXT_DATA_WRPTR(__rd)       ldi __rd 0 __EMA_CONTEXT_DATA_WRPTR
+    #define xLDI_WAN_EMA_CONTEXT_CMD_WRPTR(__rd)    ldi __rd 0 __WAN_EMA_CONTEXT_CMD_WRPTR
+    #define xLDI_WAN_EMA_CONTEXT_DATA_WRPTR(__rd)   ldi __rd 0 __WAN_EMA_CONTEXT_DATA_WRPTR
+
+    //---------------------------------------------
+    // DSL WAN RX Port Context
+    //---------------------------------------------
+    #define xLDI_WRXCTXT_TC_RdPtr0(__rd)            ldi __rd 0 __WRXCTXT_TC_RdPtr0
+    #define xLDI_WRXCTXT_TC_RdPtr1(__rd)            ldi __rd 0 __WRXCTXT_TC_RdPtr1
+    #define xLDI_WRXCTXT_L2_RdPtr0(__rd)            ldi __rd 0 __WRXCTXT_L2_RdPtr0
+    #define xLDI_WRXCTXT_L2_RdPtr1(__rd)            ldi __rd 0 __WRXCTXT_L2_RdPtr1
+    #define xLDI_WRXCTXT_L2Pages0(__rd)             ldi __rd 0 __WRXCTXT_L2Pages0
+    #define xLDI_WRXCTXT_L2Pages1(__rd)             ldi __rd 0 __WRXCTXT_L2Pages1
+    #define xLDI_WRXCTXT_MatchCells0(__rd)          ldi __rd 0 __WRXCTXT_MatchCells0
+    #define xLDI_WRXCTXT_MatchCells1(__rd)          ldi __rd 0 __WRXCTXT_MatchCells1
+    #define xLDI_WRXCTXT_NoMatchCells0(__rd)        ldi __rd 0 __WRXCTXT_NoMatchCells0
+    #define xLDI_WRXCTXT_NoMatchCells1(__rd)        ldi __rd 0 __WRXCTXT_NoMatchCells1
+    #define xLDI_WRXCTXT_PortState0(__rd)           ldi __rd 0 __WRXCTXT_PortState0
+    #define xLDI_WRXCTXT_PortState1(__rd)           ldi __rd 0 __WRXCTXT_PortState1
+    #define xLDI_WRXCTXT_Hunt_Cnt0(__rd)            ldi __rd 0 __WRXCTXT_Hunt_Cnt0
+    #define xLDI_WRXCTXT_Hunt_Cnt1(__rd)            ldi __rd 0 __WRXCTXT_Hunt_Cnt1
+
+    //---------------------------------------------
+    // WAN TX Port Context
+    //---------------------------------------------
+    #define xLDI_WTXCTXT_TC_WRPTR0(__rd)            ldi __rd 0 __WTXCTXT_TC_WRPTR0
+    #define xLDI_WTXCTXT_TC_WRPTR1(__rd)            ldi __rd 0 __WTXCTXT_TC_WRPTR1
+
+    //---------------------------------------------
+    // WAN TX Port Context (extension)
+    //---------------------------------------------
+    #define xLDI_WTXCTXT_WtxDBufStart0(__rd)        ldi __rd 0 __WTXCTXT_WtxDBufStart0
+    #define xLDI_WTXCTXT_WtxDBufStart1(__rd)        ldi __rd 0 __WTXCTXT_WtxDBufStart1
+
+    //---------------------------------------------
+    // WAN RX Port Context (extension)
+    //---------------------------------------------
+    #define xLDI_WRXCTXT_WrxDBufStart0(__rd)        ldi __rd 0 __WRXCTXT_WrxDBufStart0
+    #define xLDI_WRXCTXT_WrxDBufStart1(__rd)        ldi __rd 0 __WRXCTXT_WrxDBufStart1
+    #define xLDI_WRXCTXT_WrxCBufStart0(__rd)        ldi __rd 0 __WRXCTXT_WrxCBufStart0
+    #define xLDI_WRXCTXT_WrxCBufStart1(__rd)        ldi __rd 0 __WRXCTXT_WrxCBufStart1
+
+    //---------------------------------------------
+    // WAN - atm General Context
+    //---------------------------------------------
+    #define xLDI_FWGEN_BITS_WORD0(__rd)                 ldi __rd 0 __FWGEN_BITS_WORD0
+    #define xLDI_FWGEN_WRX_WREMA_PEND_DID(__rd)         ldi __rd 0 __FWGEN_WRX_WREMA_PEND_DID
+    #define xLDI_FWGEN_WTX_WRDES_PEND_DID(__rd)         ldi __rd 0 __FWGEN_WTX_WRDES_PEND_DID
+    #define xLDI_FWGEN_WRX_WRDES_PEND_DID(__rd)         ldi __rd 0 __FWGEN_WRX_WRDES_PEND_DID
+    #define xLDI_FWGEN_WTX_WRDES_FINAL_PEND_DID(__rd)   ldi __rd 0 __FWGEN_WTX_WRDES_FINAL_PEND_DID
+    #define xLDI_FWGEN_WRX_WRDES_FINAL_PEND_DID(__rd)   ldi __rd 0 __FWGEN_WRX_WRDES_FINAL_PEND_DID
+    #define xLDI_FWGEN_WTX_RDDATA_PEND_QID(__rd)        ldi __rd 0 __FWGEN_WTX_RDDATA_PEND_QID
+    #define xLDI_FWGEN_WTX_CELLBUF_EMPTY_STATUS(__rd)   ldi __rd 0 __FWGEN_WTX_CELLBUF_EMPTY_STATUS
+    #define xLDI_FWGEN_WTX_DMACH_NONEMPTY_STATUS(__rd)  ldi __rd 0 __FWGEN_WTX_DMACH_NONEMPTY_STATUS
+    #define xLDI_FWGEN_WRX_DMACH_NONEMPTY_STATUS(__rd)  ldi __rd 0 __FWGEN_WRX_DMACH_NONEMPTY_STATUS
+    #define xLDI_FWGEN_WRX_DMACH_VLD_STATUS(__rd)       ldi __rd 0 __FWGEN_WRX_DMACH_VLD_STATUS
+    #define xLDI_FWGEN_WRX_VEN(__rd)                    ldi __rd 0 __FWGEN_WRX_VEN
+    #define xLDI_FWGEN_WRX_DES_PREFETCH_DID(__rd)       ldi __rd 0 __FWGEN_WRX_DES_PREFETCH_DID
+    #define xLDI_FWGEN_WRX_DID(__rd)                    ldi __rd 0 __FWGEN_WRX_DID
+    #define xLDI_FWGEN_EMA_CMD0(__rd)                   ldi __rd 0 __FWGEN_EMA_CMD0
+    #define xLDI_FWGEN_EMA_CMD1(__rd)                   ldi __rd 0 __FWGEN_EMA_CMD1
+    #define xLDI_FWGEN_WRX_CELL_TYPE(__rd)              ldi __rd 0 __FWGEN_WRX_CELL_TYPE
+    #define xLDI_FWGEN_WRX_CELLID(__rd)                 ldi __rd 0 __FWGEN_WRX_CELLID
+    #define xLDI_FWGEN_WRX_DESBUF_NONFULL_STATUS(__rd)  ldi __rd 0 __FWGEN_WRX_DESBUF_NONFULL_STATUS
+    #define xLDI_FWGEN_WTX_DES_PREFETCH_QID(__rd)       ldi __rd 0 __FWGEN_WTX_DES_PREFETCH_QID
+    #define xLDI_FWGEN_WTX_DES_PREFETCH_DID(__rd)       ldi __rd 0 __FWGEN_WTX_DES_PREFETCH_DID
+    #define xLDI_FWGEN_WTX_CURRDES_VLD_STATUS(__rd)     ldi __rd 0 __FWGEN_WTX_CURRDES_VLD_STATUS
+    #define xLDI_FWGEN_WTX_DESBUF_NONFULL_STATUS(__rd)  ldi __rd 0 __FWGEN_WTX_DESBUF_NONFULL_STATUS
+    #define xLDI_FWGEN_DES0(__rd)                       ldi __rd 0 __FWGEN_VAR_DES0
+    #define xLDI_FWGEN_DES1(__rd)                       ldi __rd 0 __FWGEN_VAR_DES1
+    #define xLDI_FWGEN_WRX_CELL_HEADER(__rd)            ldi __rd 0 __FWGEN_WRX_CELL_HEADER
+    //#define xLDI_FWGEN_VAR_EMADATA_WRPTR(__rd)        ldi __rd 0 __FWGEN_VAR_EMADATA_WRPTR
+    #define xLDI_FWGEN_WRX_QID(__rd)                    ldi __rd 0 __FWGEN_WRX_QID
+    #define xLDI_FWGEN_VAR_DWNUM(__rd)                  ldi __rd 0 __FWGEN_VAR_DWNUM
+    #define xLDI_FWGEN_VAR_CURR_LEN(__rd)               ldi __rd 0 __FWGEN_VAR_CURR_LEN
+    #define xLDI_FWGEN_VAR_TRAILER_LEN(__rd)            ldi __rd 0 __FWGEN_VAR_TRAILER_LEN
+    #define xLDI_FWGEN_VAR_TRAILER_UU(__rd)             ldi __rd 0 __FWGEN_VAR_TRAILER_UU
+    #define xLDI_FWGEN_VAR_TRAILER_CPI(__rd)            ldi __rd 0 __FWGEN_VAR_TRAILER_CPI
+    #define xLDI_FWGEN_VAR_STW(__rd)                    ldi __rd 0 __FWGEN_VAR_STW
+    #define xLDI_FWGEN_WTX_QID(__rd)                    ldi __rd 0 __FWGEN_WTX_QID
+    #define xLDI_FWGEN_VAR_BMC_CMD0(__rd)               ldi __rd 0 __FWGEN_VAR_BMC_CMD0
+    #define xLDI_FWGEN_VAR_DW_OFF(__rd)                 ldi __rd 0 __FWGEN_VAR_DW_OFF
+    #define xLDI_FWGEN_VAR_LAST_CELL(__rd)              ldi __rd 0 __FWGEN_VAR_LAST_CELL
+    #define xLDI_FWGEN_VAR_FILL_CELL(__rd)              ldi __rd 0 __FWGEN_VAR_FILL_CELL
+    #define xLDI_FWGEN_VAR_EXP_LEN(__rd)                ldi __rd 0 __FWGEN_VAR_EXP_LEN
+    #define xLDI_FWGEN_WTX_CELL_HEADER(__rd)            ldi __rd 0 __FWGEN_WTX_CELL_HEADER
+    #define xLDI_FWGEN_VAR_BYTEOFF(__rd)                ldi __rd 0 __FWGEN_VAR_BYTEOFF
+    #define xLDI_FWGEN_WTX_DATA_PREFETCH_QID(__rd)      ldi __rd 0 __FWGEN_WTX_DATA_PREFETCH_QID
+    #define xLDI_FWGEN_WRX_PID(__rd)                    ldi __rd 0 __FWGEN_WRX_PID
+    #define xLDI_FWGEN_WTX_PID(__rd)                    ldi __rd 0 __FWGEN_WTX_PID
+    #define xLDI_FWGEN_CELLS_QUEUED_0(__rd)             ldi __rd 0 __FWGEN_CELLS_QUEUED_0
+    #define xLDI_FWGEN_CELLS_QUEUED_1(__rd)             ldi __rd 0 __FWGEN_CELLS_QUEUED_1
+    #define xLDI_FWGEN_SPACE_PENDING0(__rd)             ldi __rd 0 __FWGEN_SPACE_PENDING0
+    #define xLDI_FWGEN_SPACE_PENDING1(__rd)             ldi __rd 0 __FWGEN_SPACE_PENDING1
+    #define xLDI_FWGEN_VAR_BMC_CMD1(__rd)               ldi __rd 0 __FWGEN_VAR_BMC_CMD1
+    #define xLDI_FWGEN_WRX_DESREQ_NONPEND_STATUS(__rd)  ldi __rd 0 __FWGEN_WRX_DESREQ_NONPEND_STATUS
+    #define xLDI_FWGEN_WTX_DESREQ_NONPEND_STATUS(__rd)  ldi __rd 0 __FWGEN_WTX_DESREQ_NONPEND_STATUS
+    #define xLDI_FWGEN_WTX_CELLREQ_NONPEND_STATUS(__rd) ldi __rd 0 __FWGEN_WTX_CELLREQ_NONPEND_STATUS
+    #define xLDI_FWGEN_PREV_EMA_ISR(__rd)               ldi __rd 0 __FWGEN_PREV_EMA_ISR
+    #define xLDI_FWGEN_MBOX0_ISR(__rd)                  ldi __rd 0 __FWGEN_MBOX0_ISR
+    #define xLDI_FWGEN_WTX_1ST_CELL_READ_FLAG0(__rd)    ldi __rd 0 __FWGEN_WTX_1ST_CELL_READ_FLAG0
+    #define xLDI_FWGEN_WTX_1ST_CELL_READ_FLAG1(__rd)    ldi __rd 0 __FWGEN_WTX_1ST_CELL_READ_FLAG1
+
+    #define xLDI_FWGEN_WRX_2684_ORIGINAL_FLAG(__rd)     ldi __rd 0 __FWGEN_WRX_2684_ORIGINAL_FLAG
+    #define xLDI_FWGEN_WRX_2684_CELL_ALIGN_OFF(__rd)    ldi __rd 0 __FWGEN_WRX_2684_CELL_ALIGN_OFF
+    #define xLDI_FWGEN_WRX_2684_MPOA_TYPE(__rd)         ldi __rd 0 __FWGEN_WRX_2684_MPOA_TYPE
+    #define xLDI_FWGEN_WRX_AAL5_CELL1_ROUNDDOWN_DWNUM(__rd)    ldi __rd 0 __FWGEN_WRX_AAL5_CELL1_ROUNDDOWN_DWNUM
+    #define xLDI_FWGEN_WRX_DES_BYTES(__rd)              ldi __rd 0 __FWGEN_WRX_DES_BYTES
+    #define xLDI_FWGEN_WRX_FIRST_CELL(__rd)             ldi __rd 0 __FWGEN_WRX_FIRST_CELL
+    #define xLDI_FWGEN_WRX_PKT_LEN_WO_FCS(__rd)         ldi __rd 0 __FWGEN_WRX_PKT_LEN_WO_FCS
+    #define xLDI_FWGEN_WRX_ETH_TYPE(__rd)               ldi __rd 0 __FWGEN_WRX_ETH_TYPE
+    #define xLDI_FWGEN_WRX_MAC_BYTE(__rd)               ldi __rd 0 __FWGEN_WRX_MAC_BYTE
+
+    #define xLDI_WRX_DECAP_BUF_BASE(__rd)               ldi __rd 0 __WRX_DECAP_BUF_BASE
+    #define xLDI_WRX_DECAP_BUF_BASE_HW(__rd)               ldi __rd 0 __WRX_DECAP_BUF_BASE_HW
+
+    #define xLDI_FWGEN_WTX_ETH_HD_DONE(__rd)            ldi __rd 0 __FWGEN_WTX_ETH_HD_DONE
+    #define xLDI_FWGEN_WTX_2684_RM_LEN(__rd)            ldi __rd 0 __FWGEN_WTX_2684_RM_LEN
+    #define xLDI_FWGEN_WTX_2684_INSERT_LEN(__rd)        ldi __rd 0 __FWGEN_WTX_2684_INSERT_LEN
+    #define xLDI_FWGEN_WTX_ENCAP_PARSE_DROP(__rd)       ldi __rd 0 __FWGEN_WTX_ENCAP_PARSE_DROP
+    #define xLDI_FWGEN_WTX_ETH_IS_VLAN(__rd)            ldi __rd 0 __FWGEN_WTX_ETH_IS_VLAN
+    #define xLDI_FWGEN_WTX_RDWNUM(__rd)                 ldi __rd 0 __FWGEN_WTX_RDWNUM
+    #define xLDI_FWGEN_WTX_SWOFFF(__rd)                 ldi __rd 0 __FWGEN_WTX_SWOFF
+
+    #define xLDI_FWGEN_WTX_CELL1_BYTEOFF(__rd)          ldi __rd 0 __FWGEN_WTX_CELL1_BYTEOFF
+    #define xLDI_FWGEN_WTX_ETH_IS_IPV4(__rd)            ldi __rd 0 __FWGEN_WTX_ETH_IS_IPV4
+    #define xLDI_FWGEN_WTX_ETH_IPOFF(__rd)              ldi __rd 0 __FWGEN_WTX_ETH_IPOFF
+    #define xLDI_FWGEN_WTX_QPKT_LEVEL_CONTROL(__rd)     ldi __rd 0 __FWGEN_WTX_QPKT_LEVEL_CONTROL
+
+    #define xLDI_FWGEN_WTX_QSB_VC_CONTEXT_BASE(__rd)    ldi __rd 0 __FWGEN_WTX_QSB_VC_CONTEXT_BASE
+    #define xLDI_WTX_ETH_HEADER_BUF_BASE(__rd)          ldi __rd 0 __WTX_ETH_HEADER_BUF_BASE
+
+    #define xLDI_FWGEN_WTX_MPOA_PT(__rd)                ldi __rd 0 __FWGEN_WTX_MPOA_PT
+
+    #define MPOA_TYPE_EOA1                  0   //without FCS
+    #define MPOA_TYPE_EOA2                  1   //with FCS
+    #define MPOA_TYPE_PPPOA_IPV4            2
+    #define MPOA_TYPE_IPOA_IPV4             3
+    #define MPOA_TYPE_PPPOA_IPV6            6
+    #define MPOA_TYPE_IPOA_IPV6             7
+    #define MPOA_TYPE_PPPOA_OTHER           10
+    #define MPOA_TYPE_IPOA_OTHER            11
+    #define BITS_OF_BUCK_DEPTH              4
+    #define CONST_HASH_BUCKET_SIZE          16
+    #define CONST_HASH_BUCKET_NO            32
+
+    #define CONST_IPV6_CNV_TBL_SIZE         64
+
+
+//==============================================================================
+// FROM vr9 bonding
+//--------------
+//PDMA Registers
+//--------------
+#define __DMAL_BAR0_FIFO_STATUS             0x7600
+#define __DMAL_BAR1_FIFO_STATUS             0x7601
+#define __PDMA_BAR0                         0x7602
+#define __PDMA_BAR1                         0x7603
+
+#define __BAR0_WINDOW_SB_ADDR               0x6000
+#define __BAR0_WINDOW_SB_ADDR_PLUS_1        0x6001
+#define __BAR1_WINDOW_SB_ADDR               0x6800
+#define __BAR1_WINDOW_SB_ADDR_PLUS_1        0x6801
+
+
+// hardware registers
+#define __SAR_PDMA_RX_FW_DATABUF_CFG        0x7F02
+#define __SAR_PDMA_TX_FW_DATABUF_CFG        0x7F03
+#define __PDMA_IER                          0x7A0B
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_api.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_api.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_api.h
@@ -0,0 +1,99 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2015 Zhu YiXin<yixin.zhu@lantiq.com>
+ */
+
+#ifndef __VRX318_API_H__
+#define __VRX318_API_H__
+
+static inline void mbox_clr_isr(u32 mbox_idx, u32 isr_mask, u32 base)
+{
+	u32 clr_reg;
+
+	clr_reg = (mbox_idx == MBOX_IGU0) ? MBOX_IGU0_ISRC : MBOX_IGU1_ISRC;
+	vrx318_w32(isr_mask, clr_reg, base);
+}
+
+static inline void mbox_set_ier(u32 mbox_idx, u32 ier_en_mask, u32 base)
+{
+	u32 ier_reg;
+
+	ier_reg = (mbox_idx == MBOX_IGU0) ? MBOX_IGU0_IER : MBOX_IGU1_IER;
+	vrx318_w32(ier_en_mask, ier_reg, base);
+}
+
+static inline void pp32_stop(u32 base)
+{
+	u32 mask = 0x00010001;
+
+	/*  halt PP32   */
+	mask |= vrx318_r32(PP32_FREEZE, base);
+	vrx318_w32(mask, PP32_FREEZE, base);
+}
+
+static inline void pp32_start(int idx, u32 base)
+{
+	unsigned int mask;
+
+	idx = (idx == 0) ? 0x1 : 0x10000;
+	/*  run PP32    */
+	mask = vrx318_r32(PP32_FREEZE, base) & (~idx);
+	vrx318_dbg(DBG_INIT, "mask : 0x%x\n", mask);
+	vrx318_w32(mask, PP32_FREEZE, base);
+
+	/*  idle for a while to let PP32 init itself */
+	mdelay(1);
+
+	if (vrx318_r32(PP32_FREEZE, base) & idx) {
+		vrx318_dbg(DBG_ERR, "Start PP32 failed: 0x%x, idx: %d, mask:%d\n",
+			vrx318_r32(PP32_FREEZE, base), idx, mask);
+		BUG();
+	}
+}
+
+
+/* indicate TC Type to DSL FW to fast the DSL handshake */
+/* set *MUST* be called after initialization */
+static inline void vrx318_tc_indicate(enum dsl_tc_mode dsl_tc,
+					u32 base, int set)
+{
+	if (set)
+		vrx318_w32((1 << dsl_tc), DSL_TC_INDICATE, base);
+	else
+		vrx318_w32(0, DSL_TC_INDICATE, base);
+}
+
+static inline void vrx318_reset_xdsl(u32 base)
+{
+	vrx318_w32(2, MEI_RST_CTRL, base);
+	udelay(10);
+	vrx318_w32(0, MEI_RST_CTRL, base);
+}
+
+extern int pp32_download_code(u32, int, const u32 *, unsigned int,
+				const u32 *, unsigned int);
+extern void reset_ppe(u32);
+extern void enable_ppe_ema(u32);
+extern void set_ppe_clk(u32, u32);
+extern u32 get_ppe_clk(u32);
+extern void print_fw_version(char *, struct fw_ver_id *);
+extern void dword_clear(void *, int);
+extern void dword_mem_write(u32, const void *, int, u32);
+extern void dword_mem_read(void *, u32, int, u32);
+extern void dword_ep_clear(u32, int, u32);
+extern void vrx318_sb_clear(u32);
+extern int alloc_data_buffer(struct vrx318_priv *, unsigned int,
+			dma_addr_t *, unsigned int *);
+extern int free_data_buffer(dma_addr_t);
+extern void setup_dfe_loopback(struct vrx318_priv *, u32);
+extern void dfe_loopback_linkup(struct vrx318_priv *, u32);
+extern int vrx318_soc_cfg_get(struct vrx318_priv *);
+extern int vrx318_genetlink_init(void);
+extern void vrx318_genetlink_exit(void);
+extern int vrx_tc_msg_send(int, int, int, int, int);
+
+
+#endif /* __VRX318_API_H__ */
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_atm_tc.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_atm_tc.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_atm_tc.h
@@ -0,0 +1,314 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * Copyright (C) 2015 Zhu YiXin<yixin.zhu@lantiq.com>
+ */
+
+#ifndef __VRX318_ATM_TC_H__
+#define __VRX318_ATM_TC_H__
+
+#include <linux/atm.h>
+
+/* ATM Info */
+#define CELL_SIZE		ATM_AAL0_SDU
+#define ATM_PORT_NUMBER		2
+#define ATM_PVC_NUMBER		15
+#define QSB_QUEUE_NUMBER_BASE	1
+#define DEFAULT_RX_HUNT_BITTH	4
+#define DEFAULT_CELL_RATE	3200
+#define ATM_PRIO_Q_NUM		8
+
+#define ATM_PDBRAM_US_BUF_LEN	16
+#define ATM_PDBRAM_DS_OAM_LEN	10
+#define ATM_PDBRAM_DS_BUF_LEN	12
+#define ATM_SB_DS_BUF_LEN	12
+
+/* OAM Definitions */
+#define OAM_HTU_ENTRY_NUMBER	3
+#define OAM_F4_SEG_HTU_ENTRY	0
+#define OAM_F4_TOT_HTU_ENTRY	1
+#define OAM_F5_HTU_ENTRY	2
+#define OAM_F4_CELL_ID		0
+#define OAM_F5_CELL_ID		15
+
+#define HTU_ENTRY_TBL(x)	(__HTU_ENTRY_TABLE + (x)) /* x < 24 */
+#define HTU_MASK_TBL(x)		(__HTU_MASK_TABLE + (x)) /* x < 24 */
+#define HTU_RESULT_TBL(x)	(__HTU_RESULT_TABLE + (x)) /* x < 24 */
+
+#define DS_OAM_DES_NUM          32 /* MAX 32 */
+#define ATM_OAM_SIZE		64
+
+/* align is required because buffer may allocated in pdb ram */
+#define ATM_TXQ_NUM(qos_en)	((qos_en) ? (QOSQ_NUM / 2) : QOSQ_NUM)
+#define ATM_PVC_NUM(qos_en) ((qos_en) ? (QOSQ_NUM / 2) : ATM_PVC_NUMBER)
+#define DESC_QID(qid)		(((qid) & 0xF) << 3)
+/* Pass Through (No AAL5 encapsulation required) */
+#define DESC_MPOA_PT(pt)	(((pt) & 0x1) << 2)
+#define DESC_MPOA_MD(mode)	((mode) & 0x3) /* MPoA Type */
+#define ATM_DESC_SUBIF_ID(qid, pt, mode) \
+		(DESC_QID(qid) | DESC_MPOA_PT(pt) | DESC_MPOA_MD(mode))
+#define SUBIF_ID_GET(id)	(((id) & 0xF00) >> 8)
+
+#define WRX_Q_CFG(i)		(__WRX_QUEUE_CONFIG + (i) * 10) /* i < 16 */
+#define WTX_Q_CFG(i)		(__WTX_QUEUE_CONFIG + (i) * 25) /* i < 16 */
+
+/* QSB Related Registers */
+#define QSB_CONF_REG(addr)	QSB_CONF_REG_ADDR(addr)
+
+/* QSB Internal Cell Delay Variation Register */
+#define QSB_ICDV		QSB_CONF_REG(0x0007)
+
+/* QSB Scheduler Burst Limit Register */
+#define QSB_SBL			QSB_CONF_REG(0x0009)
+
+/* QSB Configuration Register */
+#define QSB_CFG			QSB_CONF_REG(0x000A)
+
+/* QSB RAM Transfer Table Register */
+#define QSB_RTM			QSB_CONF_REG(0x000B)
+
+/* QSB RAM Transfer Data Register */
+#define QSB_RTD			QSB_CONF_REG(0x000C)
+
+/* QSB RAM Access Register */
+#define QSB_RAMAC		QSB_CONF_REG(0x000D)
+
+/* QSB Queue Scheduling and Shaping Definitions */
+#define QSB_WFQ_NONUBR_MAX	0x3f00
+#define QSB_WFQ_UBR_BYPASS	0x3fff
+#define QSB_TP_TS_MAX		65472
+#define QSB_TAUS_MAX		64512
+#define QSB_GCR_MIN		18
+
+/* QSB Command Set */
+#define QSB_RAMAC_RW_READ	0
+#define QSB_RAMAC_RW_WRITE	1
+
+#define QSB_RAMAC_TSEL_QPT	0x01
+#define QSB_RAMAC_TSEL_SCT	0x02
+#define QSB_RAMAC_TSEL_SPT	0x03
+#define QSB_RAMAC_TSEL_VBR	0x08
+
+#define QSB_RAMAC_LH_LOW	0
+#define QSB_RAMAC_LH_HIGH	1
+
+#define QSB_QPT_SET_MASK	0x0
+#define QSB_QVPT_SET_MASK	0x0
+#define QSB_SET_SCT_MASK	0x0
+#define QSB_SET_SPT_MASK	0x0
+#define QSB_SET_SPT_SBVALID_MASK 0x7FFFFFFF
+
+#define QSB_RAMAC_RW_SET(x)	(((x) & 0x1) << 31)
+#define QSB_RAMAC_TSEL_SET(x)	(((x) & 0xF) << 24)
+#define QSB_RAMAC_LH_SET(x)	(((x) & 0x1) << 16)
+#define QSB_RAMAC_TESEL_SET(x)	((x) & 0x3FF)
+
+#define QSB_SPT_SBV_VALID	(1 << 31)
+#define QSB_SPT_PN_SET(x)	(((x) & 0x01) << 16)
+#define QSB_SPT_INTRATE_SET(x)	((x) & 0x3FFF)
+
+#define QSB_RTD_TTV_SET(x)	((x) & 0xFFFFFFFF)
+
+/* DSL MIB */
+#define DSL_WAN_MIB_TBL		0x4EF0
+#define DSL_Q_RX_MIB_TBL(i)	(__WRX_VC_MIB_BASE + (i) * 2) /* i < 16 */
+#define DSL_Q_TX_MIB_TBL(i)	(__WTX_VC_MIB_BASE + (i) * 2) /* i < 16 */
+
+
+struct vrx318_priv;
+
+struct htu_entry {
+	unsigned int res1:2;
+	unsigned int pid:2;
+	unsigned int vpi:8;
+	unsigned int vci:16;
+	unsigned int pti:3;
+	unsigned int vld:1;
+};
+
+struct htu_mask {
+	unsigned int set:2;
+	unsigned int pid_mask:2;
+	unsigned int vpi_mask:8;
+	unsigned int vci_mask:16;
+	unsigned int pti_mask:3;
+	unsigned int clear:1;
+};
+
+struct htu_result {
+	unsigned int res1:12;
+	unsigned int cellid:4;
+	unsigned int res2:5;
+	unsigned int type:1;
+	unsigned int ven:1;
+	unsigned int res3:5;
+	unsigned int qid:4;
+};
+
+struct dsl_wan_mib_table {
+	unsigned int res1;
+	unsigned int wrx_drophtu_cell;
+	unsigned int wrx_dropdes_pdu;
+	unsigned int wrx_correct_pdu;
+	unsigned int wrx_err_pdu;
+	unsigned int wrx_dropdes_cell;
+	unsigned int wrx_correct_cell;
+	unsigned int wrx_err_cell;
+	unsigned int wrx_total_byte;
+	unsigned int res2;
+	unsigned int wtx_total_pdu;
+	unsigned int wtx_total_cell;
+	unsigned int wtx_total_byte;
+	unsigned int res3[3];
+};
+
+struct dsl_queue_mib {
+	unsigned int pdu;
+	unsigned int bytes;
+};
+
+struct dsl_queue_drop_mib {
+	unsigned int pdu;
+};
+
+enum {
+	MPOA_TYPE_EOA_WO_FCS	= 0,
+	MPOA_TYPE_EOA_W_FCS	= 1,
+	MPOA_TYPE_PPPOA		= 2,
+	MPOA_TYPE_IPOA		= 3,
+};
+
+enum {
+	MPOA_MODE_VCMUX	= 0,
+	MPOA_MODE_LLC	= 1,
+};
+
+/* QSB Queue Parameter Table Entry and Queue VBR Parameter Table Entry */
+union qsb_queue_parameter_table {
+	struct {
+		unsigned int res1:1;
+		unsigned int vbr:1;
+		unsigned int wfqf:14;
+		unsigned int tp:16;
+	} bit;
+	unsigned int dword;
+};
+
+union qsb_queue_vbr_parameter_table {
+	struct {
+		unsigned int taus:16;
+		unsigned int ts:16;
+	} bit;
+	unsigned int dword;
+};
+
+enum mpoa_type {
+	MOPA_EOA_WO_FCS	= 0,
+	MPOA_EOA_W_FCS	= 1,
+	MPOA_PPPOA	= 2,
+	MPOA_IPOA	= 3
+};
+
+enum mpoa_mode {
+	MPOA_VCMUX_MODE	= 0,
+	MPOA_LLC_MODE	= 1
+};
+
+enum ip_ver {
+	ATM_IP_IPV4 = 0,
+	ATM_IP_IPV6 = 1
+};
+
+struct atm_oam_llst {
+	u32 *oam_des_list;
+	u32 oam_num;
+	u32 oam_idx;
+};
+
+struct atm_stats {
+	unsigned int aal5_rx_pkts;
+	unsigned int aal5_rx_bytes;
+	unsigned int aal5_rx_errors;
+	unsigned int aal5_rx_dropped;
+
+	unsigned int oam_rx_pkts;
+	unsigned int oam_rx_bytes;
+	unsigned int oam_rx_errors;
+	unsigned int oam_rx_dropped;
+
+	unsigned int aal5_tx_pkts;
+	unsigned int aal5_tx_bytes;
+	unsigned int aal5_tx_errors;
+	unsigned int aal5_tx_dropped;
+
+	unsigned int oam_tx_pkts;
+	unsigned int oam_tx_bytes;
+	unsigned int oam_tx_errors;
+	unsigned int oam_tx_dropped;
+};
+
+struct uni_cell_header {
+	unsigned int gfc:4;
+	unsigned int vpi:8;
+	unsigned int vci:16;
+	unsigned int pti:3;
+	unsigned int clp:1;
+};
+
+struct atm_port {
+	struct atm_dev *dev;
+	unsigned int tx_max_cell_rate; /* maximum cell rate */
+	unsigned int tx_used_cell_rate; /* currently used cell rate */
+};
+
+struct atm_pvc {
+	struct atm_vcc *vcc; /* opened VCC */
+	struct net_device *dev; /* net device associated with atm VCC */
+	struct timespec	access_time; /* time when last user cell arrived */
+	int prio_queue_map[ATM_PRIO_Q_NUM];
+	unsigned int prio_tx_packets[ATM_PRIO_Q_NUM];
+	struct atm_stats stats;
+	unsigned int port; /* to which port the connection belongs */
+	unsigned int sw_txq_tbl; /* Software TX Q used for this connection */
+	int subif_id;
+	int mpoa_type;
+	int mpoa_mode;
+};
+
+struct vrx318_atm_tc {
+	struct vrx318_priv *frwk;
+	int ep_id;
+	struct atm_port	port[ATM_PORT_NUMBER];
+	struct atm_pvc	conn[ATM_PVC_NUMBER]; /*conn id is same as subif id */
+	u32 pvc_tbl; /* PVC opened status, one for one connection*/
+	u32 sw_txq_tbl; /*including pvc and its sw tx queue */
+	spinlock_t atm_lock;
+	spinlock_t oam_lock;
+	struct fw_ver_id fw_ver;
+	struct proc_dir_entry *proc_dir;
+	struct atm_oam_llst oam_llst;
+	dp_cb_t	atm_cb;
+	struct atm_stats stats;
+	struct completion comp;
+};
+
+extern void (*atm_hook_mpoa_setup)(struct atm_vcc *, int,
+				int, struct net_device *);
+#if defined(CONFIG_LTQ_OAM) || defined(CONFIG_LTQ_OAM_MODULE)
+extern void ifx_push_oam(unsigned char *);
+#endif
+
+extern int atm_in_showtime(void);
+extern int proc_read_queue(struct seq_file *, void *);
+extern int proc_read_htu(struct seq_file *, void *);
+extern int sw_tx_queue_add(struct vrx318_atm_tc *, int);
+extern int sw_tx_queue_del(struct vrx318_atm_tc *, int);
+extern int find_vpivci(unsigned int, unsigned int);
+extern void print_drv_mib(struct seq_file *, struct vrx318_atm_tc *);
+extern void print_stat_mib(struct seq_file *, struct atm_stats *);
+extern int atm_power_saving(struct vrx318_atm_tc *, int, int);
+
+#endif /* __VRX318_ATM_TC_H__ */
+
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_common.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_common.h
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_common.h
@@ -0,0 +1,436 @@
+/******************************************************************************
+ *
+ *                        Copyright (c) 2012, 2014, 2015
+ *                           Lantiq Deutschland GmbH
+ *
+ *  For licensing information, see the file 'LICENSE' in the root folder of
+ *  this software module.
+ *
+ ******************************************************************************/
+#ifndef __VRX218_COMMON_H__
+#define __VRX218_COMMON_H__
+
+#include <lantiq.h>
+
+/**
+ * ####################################
+ *              Definition
+ * ####################################
+ */
+/* 8M window space */
+#define VRX318_WINDOW_SPACE		0x00800000
+#define VRX318_SMASK			(VRX318_WINDOW_SPACE - 1)
+#define vrx318_r32(reg, base)		ltq_r32((void *)(((reg) & VRX318_SMASK) + (base)))
+#define vrx318_w32(val, reg, base)	ltq_w32(val, (void *)(((reg) & VRX318_SMASK) + (base)))
+#define vrx318_w32_sb(val, reg, base)	vrx318_w32(val, SB_BUFFER(reg), base)
+#define vrx318_r32_sb(reg, base)	vrx318_r32(SB_BUFFER(reg), base)
+
+/**
+ *  Address Mapping
+ *  VRX318 FPI Configuration Bus Register and Memory Address Mapping
+ */
+#define PPE_BASE			0x1E200000
+#define PP32_DEBUG_REG_ADDR(i, x)	(PPE_BASE + (((x) + 0x000000 + (i) * 0x00010000) << 2))
+#define CDM_CODE_MEMORY(i, x)		(PPE_BASE + (((x) + 0x001000 + (i) * 0x00010000) << 2))
+#define CDM_DATA_MEMORY(i, x)		(PPE_BASE + (((x) + 0x004000 + (i) * 0x00010000) << 2))
+#define SB_RAM0_ADDR(x)			(PPE_BASE + (((x) + 0x008000) << 2))
+#define SB_RAM1_ADDR(x)			(PPE_BASE + (((x) + 0x009000) << 2))
+#define SB_RAM2_ADDR(x)			(PPE_BASE + (((x) + 0x00A000) << 2))
+#define SB_RAM3_ADDR(x)			(PPE_BASE + (((x) + 0x00B000) << 2))
+#define SB_RAM4_ADDR(x)			(PPE_BASE + (((x) + 0x00C000) << 2))
+#define PPE_REG_ADDR(x)			(PPE_BASE + (((x) + 0x00D000) << 2))
+#define QSB_CONF_REG_ADDR(x)		(PPE_BASE + (((x) + 0x00E000) << 2))
+#define SB_RAM6_ADDR(x)			(PPE_BASE + (((x) + 0x018000) << 2))
+
+/*  DWORD-Length of Memory Blocks   */
+#define PP32_DEBUG_REG_DWLEN		0x0030
+#define CDM_CODE_MEMORYN_DWLEN(n)	((n) == 0 ? 0x1000 : 0x0800)
+#define CDM_DATA_MEMORY_DWLEN		CDM_CODE_MEMORYN_DWLEN(1)
+#define SB_RAM0_DWLEN			0x1000
+#define SB_RAM1_DWLEN			0x1000
+#define SB_RAM2_DWLEN			0x1000
+#define SB_RAM3_DWLEN			0x1000
+#define SB_RAM4_DWLEN			0x1000
+#define SB_RAM6_DWLEN			0x8000
+#define QSB_CONF_REG_DWLEN		0x0100
+
+#define SB_BUFFER(__sb_addr)		((((__sb_addr) >= 0x0000) && ((__sb_addr) <= 0x1FFF)) ? PPE_REG_ADDR((__sb_addr)) :         \
+					(((__sb_addr) >= 0x2000) && ((__sb_addr) <= 0x2FFF)) ? SB_RAM0_ADDR((__sb_addr) - 0x2000) : \
+					(((__sb_addr) >= 0x3000) && ((__sb_addr) <= 0x3FFF)) ? SB_RAM1_ADDR((__sb_addr) - 0x3000) : \
+					(((__sb_addr) >= 0x4000) && ((__sb_addr) <= 0x4FFF)) ? SB_RAM2_ADDR((__sb_addr) - 0x4000) : \
+					(((__sb_addr) >= 0x5000) && ((__sb_addr) <= 0x5FFF)) ? SB_RAM3_ADDR((__sb_addr) - 0x5000) : \
+					(((__sb_addr) >= 0x6000) && ((__sb_addr) <= 0x6FFF)) ? SB_RAM4_ADDR((__sb_addr) - 0x6000) : \
+					(((__sb_addr) >= 0x7000) && ((__sb_addr) <= 0x7FFF)) ? PPE_REG_ADDR((__sb_addr) - 0x7000) : \
+					(((__sb_addr) >= 0x8000) && ((__sb_addr) <= 0xFFFF)) ? SB_RAM6_ADDR((__sb_addr) - 0x8000) : \
+					__sb_addr)
+
+#define PP32_REG_ADDR_BEGIN		0x0
+#define PP32_REG_ADDR_END		0x1FFF
+#define PP32_SB_ADDR_BEGIN		0x2000
+#define PP32_SB_ADDR_END		0xFFFF
+
+
+#define VRX318_OB_BADDR			0x20000000
+#define FW_BASE_ADDR_OFFSET		0x06000
+#define FPI_ADDR_MASK			0x3FFFFFFF
+
+/* VRX318 PPE REG */
+#define PP32_FREEZE			PPE_REG_ADDR(0x0000)
+#define PP32_SRST			PPE_REG_ADDR(0x0020)
+#define CDM_CFG				PPE_REG_ADDR(0x0100)
+
+/* RTHA /TTHA REG */
+#define PPE_RFBI_CFG			PPE_REG_ADDR(0x0400)
+#define PPE_RBA_CFG0			PPE_REG_ADDR(0x0404)
+#define PPE_RBA_CFG1			PPE_REG_ADDR(0x0405)
+#define PPE_RCA_CFG0			PPE_REG_ADDR(0x0408)
+#define PPE_RCA_CFG1			PPE_REG_ADDR(0x0409)
+#define PPE_RDES_CFG0			PPE_REG_ADDR(0x040C)
+#define PPE_RDES_CFG1			PPE_REG_ADDR(0x040D)
+#define PPE_SFSM_STATE0			PPE_REG_ADDR(0x0410)
+#define PPE_SFSM_STATE1			PPE_REG_ADDR(0x0411)
+#define PPE_SFSM_DBA0			PPE_REG_ADDR(0x0412)
+#define PPE_SFSM_DBA1			PPE_REG_ADDR(0x0413)
+#define PPE_SFSM_CBA0			PPE_REG_ADDR(0x0414)
+#define PPE_SFSM_CBA1			PPE_REG_ADDR(0x0415)
+#define PPE_SFSM_CFG0			PPE_REG_ADDR(0x0416)
+#define PPE_SFSM_CFG1			PPE_REG_ADDR(0x0417)
+#define PPE_SFSM_PGCNT0			PPE_REG_ADDR(0x041C)
+#define PPE_SFSM_PGCNT1			PPE_REG_ADDR(0x041D)
+#define PPE_FFSM_DBA0			PPE_REG_ADDR(0x0508)
+#define PPE_FFSM_DBA1			PPE_REG_ADDR(0x0509)
+#define PPE_FFSM_CFG0			PPE_REG_ADDR(0x050A)
+#define PPE_FFSM_CFG1			PPE_REG_ADDR(0x050B)
+#define PPE_FFSM_IDLE_HEAD_BC0		PPE_REG_ADDR(0x050E)
+#define PPE_FFSM_IDLE_HEAD_BC1		PPE_REG_ADDR(0x050F)
+#define PPE_FFSM_PGCNT0			PPE_REG_ADDR(0x0514)
+#define PPE_FFSM_PGCNT1			PPE_REG_ADDR(0x0515)
+
+/* SAR REG */
+#define PPE_SAR_MODE_CFG		PPE_REG_ADDR(0x080A)
+#define PPE_SAR_RX_CMDCNT		PPE_REG_ADDR(0x080B)
+#define PPE_SAR_TX_CMDCNT		PPE_REG_ADDR(0x080C)
+#define PPE_SAR_RX_CTX_CFG		PPE_REG_ADDR(0x080D)
+#define PPE_SAR_TX_CTX_CFG		PPE_REG_ADDR(0x080E)
+#define PPE_SAR_POLY_CFG_SET0		PPE_REG_ADDR(0x0812)
+#define PPE_SAR_POLY_CFG_SET1		PPE_REG_ADDR(0x0813)
+#define PPE_SAR_POLY_CFG_SET2		PPE_REG_ADDR(0x0814)
+#define PPE_SAR_POLY_CFG_SET3		PPE_REG_ADDR(0x0815)
+#define PPE_SAR_CRC_SIZE_CFG		PPE_REG_ADDR(0x0816)
+
+/* PDMA/EMA REG */
+#define PPE_PDMA_CFG			PPE_REG_ADDR(0x0A00)
+#define PPE_PDMA_RX_CMDCNT		PPE_REG_ADDR(0x0A01)
+#define PPE_PDMA_TX_CMDCNT		PPE_REG_ADDR(0x0A02)
+#define PPE_PDMA_RX_FWDATACNT		PPE_REG_ADDR(0x0A03)
+#define PPE_PDMA_TX_FWDATACNT		PPE_REG_ADDR(0x0A04)
+#define PPE_PDMA_RX_CTX_CFG		PPE_REG_ADDR(0x0A05)
+#define PPE_PDMA_TX_CTX_CFG		PPE_REG_ADDR(0x0A06)
+#define PPE_PDMA_RX_MAX_LEN_REG		PPE_REG_ADDR(0x0A07)
+#define PPE_PDMA_RX_DELAY_CFG		PPE_REG_ADDR(0x0A08)
+#define PPE_PDMA_INT_FIFO_RD		PPE_REG_ADDR(0x0A09)
+#define PPE_PDMA_ISR			PPE_REG_ADDR(0x0A0A)
+#define PPE_PDMA_IER			PPE_REG_ADDR(0x0A0B)
+#define PPE_PDMA_SUBID			PPE_REG_ADDR(0x0A0C)
+#define PPE_PDMA_BAR0			PPE_REG_ADDR(0x0A0D)
+#define PPE_PDMA_BAR1			PPE_REG_ADDR(0x0A0E)
+
+/* PPE TC Logic REG (partial) */
+#define PPE_DREG_A_VERSION		PPE_REG_ADDR(0x0D00)
+#define PPE_DREG_A_CFG			PPE_REG_ADDR(0x0D01)
+#define PPE_DREG_AT_CTRL		PPE_REG_ADDR(0x0D02)
+#define PPE_DREG_AT_CB_CFG0		PPE_REG_ADDR(0x0D03)
+#define PPE_DREG_AT_CB_CFG1		PPE_REG_ADDR(0x0D04)
+#define PPE_DREG_AR_CTRL		PPE_REG_ADDR(0x0D08)
+#define PPE_DREG_AR_CB_CFG0		PPE_REG_ADDR(0x0D09)
+#define PPE_DREG_AR_CB_CFG1		PPE_REG_ADDR(0x0D0A)
+#define PPE_DREG_A_UTPCFG		PPE_REG_ADDR(0x0D0E)
+#define PPE_DREG_A_STATUS		PPE_REG_ADDR(0x0D0F)
+#define PPE_DREG_AT_CFG0		PPE_REG_ADDR(0x0D20)
+#define PPE_DREG_AT_CFG1		PPE_REG_ADDR(0x0D21)
+#define PPE_DREG_AT_FB_SIZE0		PPE_REG_ADDR(0x0D22)
+#define PPE_DREG_AT_FB_SIZE1		PPE_REG_ADDR(0x0D23)
+#define PPE_DREG_AT_CELL0		PPE_REG_ADDR(0x0D24)
+#define PPE_DREG_AT_CELL1		PPE_REG_ADDR(0x0D25)
+#define PPE_DREG_AT_IDLE_CNT0		PPE_REG_ADDR(0x0D26)
+#define PPE_DREG_AT_IDLE_CNT1		PPE_REG_ADDR(0x0D27)
+#define PPE_DREG_AT_IDLE0		PPE_REG_ADDR(0x0D28)
+#define PPE_DREG_AT_IDLE1		PPE_REG_ADDR(0x0D29)
+#define PPE_DREG_AR_CFG0		PPE_REG_ADDR(0x0D60)
+#define PPE_DREG_AR_CFG1		PPE_REG_ADDR(0x0D61)
+#define PPE_DREG_AR_CELL0		PPE_REG_ADDR(0x0D68)
+#define PPE_DREG_AR_CELL1		PPE_REG_ADDR(0x0D69)
+#define PPE_DREG_AR_IDLE_CNT0		PPE_REG_ADDR(0x0D6A)
+#define PPE_DREG_AR_IDLE_CNT1		PPE_REG_ADDR(0x0D6B)
+#define PPE_DREG_AR_AIIDLE_CNT0		PPE_REG_ADDR(0x0D6C)
+#define PPE_DREG_AR_AIIDLE_CNT1		PPE_REG_ADDR(0x0D6D)
+#define PPE_DREG_AR_BE_CNT0		PPE_REG_ADDR(0x0D6E)
+#define PPE_DREG_AR_BE_CNT1		PPE_REG_ADDR(0x0D6F)
+#define PPE_DREG_AR_HEC_CNT0		PPE_REG_ADDR(0x0D70)
+#define PPE_DREG_AR_HEC_CNT1		PPE_REG_ADDR(0x0D71)
+#define PPE_DREG_AR_IDLE0		PPE_REG_ADDR(0x0D74)
+#define PPE_DREG_AR_IDLE1		PPE_REG_ADDR(0x0D75)
+#define PPE_DREG_AR_OVDROP_CNT0		PPE_REG_ADDR(0x0D98)
+#define PPE_DREG_AR_OVDROP_CNT1		PPE_REG_ADDR(0x0D99)
+#define PPE_DREG_AR_CERRN_CNT0		PPE_REG_ADDR(0x0DA0)
+#define PPE_DREG_AR_CERRN_CNT1		PPE_REG_ADDR(0x0DA1)
+#define PPE_DREG_AR_CERRNP_CNT0		PPE_REG_ADDR(0x0DA2)
+#define PPE_DREG_AR_CERRNP_CNT1		PPE_REG_ADDR(0x0DA3)
+#define PPE_DREG_AR_CVN_CNT0		PPE_REG_ADDR(0x0DA4)
+#define PPE_DREG_AR_CVN_CNT1		PPE_REG_ADDR(0x0DA5)
+#define PPE_DREG_AR_CVNP_CNT0		PPE_REG_ADDR(0x0DA6)
+#define PPE_DREG_AR_CVNP_CNT1		PPE_REG_ADDR(0x0DA7)
+#define PPE_DREG_B0_LADR		PPE_REG_ADDR(0x0DA8)
+#define PPE_DREG_B1_LADR		PPE_REG_ADDR(0x0DA9)
+
+#define BC0_LINK_STATUS			PPE_REG_ADDR(0x0DC0)
+#define DSL_TC_INDICATE			PPE_REG_ADDR(0x0DC4)
+#define PPE_TC_SWITCH			PPE_REG_ADDR(0x0DC5)
+
+/* SAR/PDMA REG*/
+#define PPE_SAR_PDMA_RX_CMDBUF_CFG	PPE_REG_ADDR(0x0F00)
+#define PPE_SAR_PDMA_TX_CMDBUF_CFG	PPE_REG_ADDR(0x0F01)
+#define PPE_SAR_PDMA_RX_FW_CMDBUF_CFG	PPE_REG_ADDR(0x0F02)
+#define PPE_SAR_PDMA_TX_FW_CMDBUF_CFG	PPE_REG_ADDR(0x0F03)
+#define PPE_SAR_PDMA_RX_CMDBUF_STATUS	PPE_REG_ADDR(0x0F04)
+#define PPE_SAR_PDMA_TX_CMDBUF_STATUS	PPE_REG_ADDR(0x0F05)
+
+
+#define GIF0_RX_CRC_ERR_CNT		PPE_DREG_AR_CERRN_CNT0
+#define GIF1_RX_CRC_ERR_CNT		PPE_DREG_AR_CERRNP_CNT0
+#define GIF2_RX_CRC_ERR_CNT		PPE_DREG_AR_CERRN_CNT1
+#define GIF3_RX_CRC_ERR_CNT		PPE_DREG_AR_CERRNP_CNT1
+#define GIF0_RX_CV_CNT			PPE_DREG_AR_CVN_CNT0
+#define GIF1_RX_CV_CNT			PPE_DREG_AR_CVNP_CNT0
+#define GIF2_RX_CV_CNT			PPE_DREG_AR_CVN_CNT1
+#define GIF3_RX_CV_CNT			PPE_DREG_AR_CVNP_CNT1
+#define DREG_B0_OVERDROP_CNT		PPE_DREG_AR_OVDROP_CNT0
+#define DREG_B1_OVERDROP_CNT		PPE_DREG_AR_OVDROP_CNT1
+
+/* Mailbox IGU0 Registers */
+#define MBOX_IGU0_ISRS			PPE_REG_ADDR(0x0200)
+#define MBOX_IGU0_ISRC			PPE_REG_ADDR(0x0201)
+#define MBOX_IGU0_ISR			PPE_REG_ADDR(0x0202)
+#define MBOX_IGU0_IER			PPE_REG_ADDR(0x0203)
+
+/* Mailbox IGU1 Registers */
+#define MBOX_IGU1_ISRS			PPE_REG_ADDR(0x0204)
+#define MBOX_IGU1_ISRC			PPE_REG_ADDR(0x0205)
+#define MBOX_IGU1_ISR			PPE_REG_ADDR(0x0206)
+#define MBOX_IGU1_IER			PPE_REG_ADDR(0x0207)
+
+/* PPE SB address */
+#define DS_FLOW_CTRL_CFG		SB_BUFFER(0x2026)
+#define TX_CTRL_K_TABLE(i)		SB_BUFFER(__CTRL_K_TBL_BASE + (i))
+#define DS_FRAGQ_DES_LIST_BASE(off, i)	SB_BUFFER(__DS_FRAGQ_DES_LIST_BASE + (off) + ((i) << 1))
+#define DS_BOND_GIF_LL_DES_BA(i)	SB_BUFFER(__DS_BOND_GIF_LL_DES_BA + ((i) << 1))
+#define DES_SYNC_CFG_CTXT(idx)		SB_BUFFER(__DES_SYNC_CFG_CTXT + ((idx) * 32))
+#define BOND_US_DES_SYNC_CFG_CTXT(i)	SB_BUFFER(__BOND_US_DES_SYNC_CFG_CTXT + ((i) * 8))
+#define INQ_QOS_CFG_BASE(off)		SB_BUFFER(__INQ_QOS_CFG_BASE + (off))
+
+/* PP32 debug register and macro */
+#define PP32_DBG_CTRL(n)				PP32_DEBUG_REG_ADDR(n, 0x0000)
+
+#define DBG_CTRL_RESTART                                0
+#define DBG_CTRL_STOP                                   1
+
+#define PP32_CTRL_CMD(n)				PP32_DEBUG_REG_ADDR(n, 0x0B00)
+#define PP32_CTRL_CMD_RESTART				(1 << 0)
+#define PP32_CTRL_CMD_STOP				(1 << 1)
+#define PP32_CTRL_CMD_STEP				(1 << 2)
+#define PP32_CTRL_CMD_BREAKOUT				(1 << 3)
+
+#define PP32_CTRL_OPT(n)				PP32_DEBUG_REG_ADDR(n, 0x0C00)
+#define PP32_CTRL_OPT_BREAKOUT_ON_STOP_ON		(3 << 0)
+#define PP32_CTRL_OPT_BREAKOUT_ON_STOP_OFF		(2 << 0)
+#define PP32_CTRL_OPT_BREAKOUT_ON_BREAKIN_ON		(3 << 2)
+#define PP32_CTRL_OPT_BREAKOUT_ON_BREAKIN_OFF		(2 << 2)
+#define PP32_CTRL_OPT_STOP_ON_BREAKIN_ON		(3 << 4)
+#define PP32_CTRL_OPT_STOP_ON_BREAKIN_OFF		(2 << 4)
+#define PP32_CTRL_OPT_STOP_ON_BREAKPOINT_ON		(3 << 6)
+#define PP32_CTRL_OPT_STOP_ON_BREAKPOINT_OFF		(2 << 6)
+#define PP32_CTRL_OPT_BREAKOUT_ON_STOP(base, n)        	((vrx318_r32(PP32_CTRL_OPT(n), base)) & (1 << 0))
+#define PP32_CTRL_OPT_BREAKOUT_ON_BREAKIN(base, n)	((vrx318_r32(PP32_CTRL_OPT(n), base)) & (1 << 2))
+#define PP32_CTRL_OPT_STOP_ON_BREAKIN(base, n)		((vrx318_r32(PP32_CTRL_OPT(n), base)) & (1 << 4))
+#define PP32_CTRL_OPT_STOP_ON_BREAKPOINT(base, n)	((vrx318_r32(PP32_CTRL_OPT(n), base)) & (1 << 6))
+
+#define PP32_BRK_PC(n, i)				(PP32_DEBUG_REG_ADDR(n, 0x0900 + (i) * 2))
+#define PP32_BRK_PC_MASK(n, i)				(PP32_DEBUG_REG_ADDR(n, 0x0901 + (i) * 2))
+#define PP32_BRK_DATA_ADDR(n, i)			(PP32_DEBUG_REG_ADDR(n, 0x0904 + (i) * 2))
+#define PP32_BRK_DATA_ADDR_MASK(n, i)			(PP32_DEBUG_REG_ADDR(n, 0x0905 + (i) * 2))
+#define PP32_BRK_DATA_VALUE_RD(n, i)			(PP32_DEBUG_REG_ADDR(n, 0x0908 + (i) * 2))
+#define PP32_BRK_DATA_VALUE_RD_MASK(n, i)		(PP32_DEBUG_REG_ADDR(n, 0x0909 + (i) * 2))
+#define PP32_BRK_DATA_VALUE_WR(n, i)			(PP32_DEBUG_REG_ADDR(n, 0x090C + (i) * 2))
+#define PP32_BRK_DATA_VALUE_WR_MASK(n, i)		(PP32_DEBUG_REG_ADDR(n, 0x090D + (i) * 2))
+#define PP32_BRK_CONTEXT_MASK(i)			(1 << (i))
+#define PP32_BRK_CONTEXT_MASK_EN			(1 << 4)
+#define PP32_BRK_COMPARE_GREATER_EQUAL			(1 << 5)    /* valid for break data value rd/wr only */
+#define PP32_BRK_COMPARE_LOWER_EQUAL			(1 << 6)
+#define PP32_BRK_COMPARE_EN				(1 << 7)
+
+#define PP32_BRK_TRIG(n)				PP32_DEBUG_REG_ADDR(n, 0x0F00)
+#define PP32_BRK_GRPi_PCn_ON(i, n)			((3 << ((n) * 2)) << ((i) * 16))
+#define PP32_BRK_GRPi_PCn_OFF(i, n)			((2 << ((n) * 2)) << ((i) * 16))
+#define PP32_BRK_GRPi_DATA_ADDRn_ON(i, n)		((3 << ((n) * 2 + 4)) << ((i) * 16))
+#define PP32_BRK_GRPi_DATA_ADDRn_OFF(i, n)		((2 << ((n) * 2 + 4)) << ((i) * 16))
+#define PP32_BRK_GRPi_DATA_VALUE_RDn_ON(i, n)		((3 << ((n) * 2 + 8)) << ((i) * 16))
+#define PP32_BRK_GRPi_DATA_VALUE_RDn_OFF(i, n)		((2 << ((n) * 2 + 8)) << ((i) * 16))
+#define PP32_BRK_GRPi_DATA_VALUE_WRn_ON(i, n)		((3 << ((n) * 2 + 12)) << ((i) * 16))
+#define PP32_BRK_GRPi_DATA_VALUE_WRn_OFF(i, n)		((2 << ((n) * 2 + 12)) << ((i) * 16))
+#define PP32_BRK_GRPi_PCn(base, k, i, n)		((vrx318_r32(PP32_BRK_TRIG(k), base)) & ((1 << ((n))) << ((i) * 8)))
+#define PP32_BRK_GRPi_DATA_ADDRn(base, k, i, n)		((vrx318_r32(PP32_BRK_TRIG(k), base)) & ((1 << ((n) + 2)) << ((i) * 8)))
+#define PP32_BRK_GRPi_DATA_VALUE_RDn(base, k, i, n)	((vrx318_r32(PP32_BRK_TRIG(k), base)) & ((1 << ((n) + 4)) << ((i) * 8)))
+#define PP32_BRK_GRPi_DATA_VALUE_WRn(base, k, i, n)	((vrx318_r32(PP32_BRK_TRIG(k), base)) & ((1 << ((n) + 6)) << ((i) * 8)))
+
+#define PP32_CPU_STATUS(n)				PP32_DEBUG_REG_ADDR(n, 0x0D00)
+#define PP32_HALT_STAT(n)				PP32_CPU_STATUS(n)
+#define PP32_DBG_CUR_PC(n)				PP32_CPU_STATUS(n)
+#define PP32_CPU_USER_STOPPED(base, n)			((vrx318_r32(PP32_CPU_STATUS(n), base)) & (1 << 0))
+#define PP32_CPU_USER_BREAKIN_RCV(base, n)		((vrx318_r32(PP32_CPU_STATUS(n), base)) & (1 << 1))
+#define PP32_CPU_USER_BREAKPOINT_MET(base, n)		((vrx318_r32(PP32_CPU_STATUS(n), base)) & (1 << 2))
+#define PP32_CPU_CUR_PC(base, n)			((vrx318_r32(PP32_CPU_STATUS(n), base)) >> 16)
+
+#define PP32_BREAKPOINT_REASONS(n)			PP32_DEBUG_REG_ADDR(n, 0x0A00)
+#define PP32_BRK_PC_MET(base, n, i)			((vrx318_r32(PP32_BREAKPOINT_REASONS(n), base)) & (1 << (i)))
+#define PP32_BRK_DATA_ADDR_MET(base, n, i)		((vrx318_r32(PP32_BREAKPOINT_REASONS(n), base)) & (1 << ((i) + 2)))
+#define PP32_BRK_DATA_VALUE_RD_MET(base, n, i)		((vrx318_r32(PP32_BREAKPOINT_REASONS(n), base)) & (1 << ((i) + 4)))
+#define PP32_BRK_DATA_VALUE_WR_MET(base, n, i)		((vrx318_r32(PP32_BREAKPOINT_REASONS(n), base)) & (1 << ((i) + 6)))
+#define PP32_BRK_DATA_VALUE_RD_LO_EQ(base, n, i)	((vrx318_r32(PP32_BREAKPOINT_REASONS(n), base)) & (1 << ((i) * 2 + 8)))
+#define PP32_BRK_DATA_VALUE_RD_GT_EQ(base, n, i)	((vrx318_r32(PP32_BREAKPOINT_REASONS(n), base)) & (1 << ((i) * 2 + 9)))
+#define PP32_BRK_DATA_VALUE_WR_LO_EQ(base, n, i)	((vrx318_r32(PP32_BREAKPOINT_REASONS(n), base)) & (1 << ((i) * 2 + 12)))
+#define PP32_BRK_DATA_VALUE_WR_GT_EQ(base, n, i)	((vrx318_r32(PP32_BREAKPOINT_REASONS(n), base)) & (1 << ((i) * 2 + 13)))
+#define PP32_BRK_CUR_CONTEXT(base, n)			(((vrx318_r32(PP32_BREAKPOINT_REASONS(n), base)) >> 8) & 0x03)
+
+#define PP32_GP_REG_BASE(base, n)			vrx318_r32(PP32_DEBUG_REG_ADDR(n, 0x0E00), base)
+#define PP32_GP_CONTEXTi_REGn(base, n, i, j)		vrx318_r32(PP32_DEBUG_REG_ADDR(n, 0x0E00 + (i) * 16 + (j)), base)
+
+enum {
+	MBOX_IGU0 = 0,
+	MBOX_IGU1
+};
+
+enum {
+	PPE_PROC_READ = 1,
+	PPE_PROC_WRITE
+};
+
+/* VRX318 RST REG */
+#define RST_PPE_DSL_IF	(1 << 3)
+#define RST_PPE_DFE	(1 << 7)
+#define RST_DMA_CORE	(1 << 9)
+#define RST_PPE_ATM_TC	(1 << 23)
+#define RCU_BASE	0x1E002000
+#define RST_STAT	(RCU_BASE + 0x0)
+#define RST_REQ		(RCU_BASE + 0x10)
+
+
+/* VRX318 CGU REG */
+#define CGU_BASE	0x1E003000
+#define PMU_PWDCR	(CGU_BASE + 0x011C)
+#define PMU_SR		(CGU_BASE + 0x0120)
+#define PMU_PPE_EMA	(1 << 22)
+#define CGU_CLKFSR	(CGU_BASE + 0x10)
+#define SET_PPE_CLK(val, x)	((val & (~(0x7 << 16))) | (x & 0x7) << 16)
+#define VRX318_SYS_CLK	288000000
+
+
+/* VRX318 DMA REG */
+#define DMA_BASE	0x1E104100
+#define DMA_CTRL	(DMA_BASE + 0x10)
+#define DMA_CPOLL	(DMA_BASE + 0x14)
+#define DMA_CS		(DMA_BASE + 0x18)
+#define DMA_CCTRL	(DMA_BASE + 0x1C)
+#define DMA_CBA		(DMA_BASE + 0x20)
+#define DMA_CDLEN	(DMA_BASE + 0x24)
+#define DMA_CIS		(DMA_BASE + 0x28)
+#define DMA_CIE		(DMA_BASE + 0x2C)
+#define DMA_CDPTNRD	(DMA_BASE + 0x34)
+#define DMA_PS		(DMA_BASE + 0x40)
+#define DMA_PCTRL	(DMA_BASE + 0x44)
+
+/* VRX318 xDSL DFE(MEI) REG */
+#define MEI_DFE_BASE	0x1E116000
+#define MEI_RST_CTRL	(MEI_DFE_BASE + 0x18)
+
+/* VRX318 DSL DFE REG */
+#define DSL_DFE_BASE	0x1E400000
+#define DSL_CRI_RST	(DSL_DFE_BASE + 0x20C404)
+
+/* PDBRAM */
+#define PDBRAM_TX_PKT_BUF_BASE	0x1E098000
+#define PDBRAM_TX_PKT_BUF_END	0x1E09DDBF
+#define PDBRAM_RX_PKT_BUF_BASE	0x1E09DDC0
+#define PDBRAM_RX_PKT_BUF_END	0x1E0A3B7F
+
+
+struct fw_ver_id { /*@2000*/
+	/* DWORD 0 */
+	unsigned int family:4;
+	unsigned int package:4;
+	unsigned int major:8;
+	unsigned int middle:8;
+	unsigned int minor:8;
+
+	/* DWORD 1 */
+	unsigned int features;
+};
+
+struct psave_cfg { /*@2014*/
+	unsigned int res1:15;
+	unsigned int start_state:1;  /*1: start from partial PPE reset, 0: start from full PPE reset */
+	unsigned int res2:15;
+	unsigned int sleep_en:1;  /*1: enable sleep mode, 0: disable sleep mode */
+};
+
+struct vrx318_soc_cfg {
+	u32 soc_cpu_us_phybase;
+	int soc_cpu_us_dnum;
+	u32 soc_fp_us_phybase;
+	int soc_fp_us_dnum;
+	u32 soc_ds_phybase;
+	u32 soc_ds_dbase;
+	int soc_ds_dnum;
+	int soc_us_desc_own; /* des belong to VRX318 */
+	int soc_ds_desc_own;
+	int pmac_en;
+};
+
+#define MAX_VRX318_NUM (IFX_PCIE_EP_MAX_PEER + 1)
+#define PP32_NUM	2
+#define MAX_MTU			1600
+#define CRC_SIZE		4
+#define PMAC_SIZE		8
+#define DMA_ALIGNMENT		32
+#define MAX_PKT_SIZE		(MAX_MTU + CRC_SIZE + PMAC_SIZE)
+#define DMA_PACKET_SIZE		ALIGN(MAX_PKT_SIZE, DMA_ALIGNMENT)
+#define QOSQ_NUM		16 /* MAX 16 */
+#define TOTAL_QOS_DES_NUM	512
+#define FW_STOP_TIMEOUT		200
+#define PPE_PDMA_RX_MAX_LEN_REG_CONF (0x02040000 | MAX_MTU)
+/* Interrupt bit definition */
+/**
+*  Bit 0 - Receive Pkt in Ds_pkt_des_list queue
+*  Bit 1 - Reserved for ATM: Receive Pkt in DS OAM  queue
+*  Bit 2 - Swap Queue pkt (obsolete)
+*  Bit 3 - EDMA Hang
+*  Bit 4 - Peer-to-peer-link-state [single link no support]
+*  Bit 5 - PPE FW ready to be unloaded
+*/
+#define PKT_RX_INTR		BIT(0)
+#define OAM_RX_INTR		BIT(1)
+#define EDMA_HANG_INTR		BIT(3)
+#define P2P_STAT_INTR		BIT(4)
+#define FW_UNLOAD_INTR		BIT(5)
+
+#define VRX318_ASSERT(cond, fmt, arg...)	do { if (!(cond)) pr_err_ratelimited("%d:%s: " fmt "\n", __LINE__, __func__, ##arg); } while (0)
+
+void init_dsl_callback(void);
+void *ppa_callback_get(int type);
+int ppa_callback_set(int type, void *func);
+int get_num_from_str(char **p, int *len, int is_hex);
+void ignore_space(char **p, int *len);
+int get_number_f_buf(const char __user __force **buf, int *len, int base, u32 *ret_val);
+int soc_vrx318_cfg_init(struct vrx318_soc_cfg *);
+void soc_vrx318_cfg_reset(void);
+
+#endif /*__VRX218_COMMON_H__*/
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_dfe.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_dfe.h
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_dfe.h
@@ -0,0 +1,24 @@
+/******************************************************************************
+ *
+ *                        Copyright (c) 2012, 2014, 2015
+ *                           Lantiq Deutschland GmbH
+ *
+ *  For licensing information, see the file 'LICENSE' in the root folder of
+ *  this software module.
+ *
+ ******************************************************************************/
+#ifndef __VRX218_DFE_H
+#define __VRX218_DFE_H
+
+#include "vrx318_dsl_address_define.h"
+
+struct me_cfg_def {
+	u32 addr;
+	u32 data;
+	u32 type;
+};
+
+/* Header file to set the Loopback rate to programmable! */
+#include "prograte.h"
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_dsl_address_define.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_dsl_address_define.h
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_dsl_address_define.h
@@ -0,0 +1,4942 @@
+/******************************************************************************
+ *
+ *                        Copyright (c) 2012, 2014, 2015
+ *                           Lantiq Deutschland GmbH
+ *
+ *  For licensing information, see the file 'LICENSE' in the root folder of
+ *  this software module.
+ *
+ ******************************************************************************/
+
+/**********************************************
+ * Memory Space Description for ADSL DFE
+ **********************************************/
+#ifndef __VRX218_DSL_DFE_ADDRESS_DEFINE__
+#define __VRX218_DSL_DFE_ADDRESS_DEFINE__
+
+#ifdef CACHE
+#define DFE_BASE_ADDR         0x9C116000
+#else
+#define DFE_BASE_ADDR         0xBC116000   // This is for the MEI Interface
+#endif
+
+#define MEI_OFFSET		0x116000
+#define DSL_OFFSET		0x400000
+//#define MEI_OFFSET (pcie_port ? 0xB8116000 : 0xBC116000) // This is for the MEI Interface
+//#define DSL_OFFSET (pcie_port ? 0xB8400000 : 0xBC400000) // This is for the FPI SLAVE to AWARE DFE
+#define MEIAD(a) ((a)+MEI_OFFSET)
+#define FPIAD(a) ((((a)&0x300000)>>1)+((a)&0xFFFFF)+DSL_OFFSET)
+
+#define mei_dataxfr_c         (DFE_BASE_ADDR + 0x00000040)
+#define mei_version_c         (DFE_BASE_ADDR + 0x00000000)
+#define mei_arc_gp_c          (DFE_BASE_ADDR + 0x00000048)
+#define mei_dataxfr_stat_c    (DFE_BASE_ADDR + 0x00000044)
+#define mei_xfraddr_c         (DFE_BASE_ADDR + 0x0000003C)
+#define mei_max_wait_c        (DFE_BASE_ADDR + 0x00000014)
+#define mei_2_arcint_c        (DFE_BASE_ADDR + 0x0000000C)
+#define mei_fr_arcint_c       (DFE_BASE_ADDR + 0x00000004)
+#define mei_fr_arcimsk_c      (DFE_BASE_ADDR + 0x00000008)
+#define mei_dbg_waddr_c       (DFE_BASE_ADDR + 0x00000030)
+#define mei_dbg_raddr_c       (DFE_BASE_ADDR + 0x0000002C)
+#define mei_dbg_data_c        (DFE_BASE_ADDR + 0x00000034)
+#define mei_dbg_deco_c        (DFE_BASE_ADDR + 0x00000024)
+#define mei_config_c          (DFE_BASE_ADDR + 0x0000001C)
+#define mei_rst_ctrl_c        (DFE_BASE_ADDR + 0x00000018)
+#define mei_dbg_master_c      (DFE_BASE_ADDR + 0x00000020)
+#define mei_clk_ctrl_c        (DFE_BASE_ADDR + 0x00000014)
+#define mei_bist_ctrl_c       (DFE_BASE_ADDR + 0x00000044)
+#define mei_bist_stat_c       (DFE_BASE_ADDR + 0x00000048)
+#define mei_xdata_base_sh_c   (DFE_BASE_ADDR + 0x00000050)
+#define mei_xdata_base_c      (DFE_BASE_ADDR + 0x00000054)
+#define mei_xmem_bar0_c       (DFE_BASE_ADDR + 0x00000058)
+#define mei_xmem_bar1_c       (DFE_BASE_ADDR + 0x0000005C)
+#define mei_xmem_bar2_c       (DFE_BASE_ADDR + 0x00000060)
+#define mei_xmem_bar3_c       (DFE_BASE_ADDR + 0x00000064)
+#define mei_xmem_bar4_c       (DFE_BASE_ADDR + 0x00000068)
+#define mei_xmem_bar5_c       (DFE_BASE_ADDR + 0x0000006C)
+#define mei_xmem_bar6_c       (DFE_BASE_ADDR + 0x00000070)
+#define mei_xmem_bar7_c       (DFE_BASE_ADDR + 0x00000074)
+#define mei_xmem_bar8_c       (DFE_BASE_ADDR + 0x00000078)
+#define mei_xmem_bar9_c       (DFE_BASE_ADDR + 0x0000007C)
+#define mei_xmem_bar10_c      (DFE_BASE_ADDR + 0x00000080)
+#define mei_xmem_bar11_c      (DFE_BASE_ADDR + 0x00000084)
+#define mei_xmem_bar12_c      (DFE_BASE_ADDR + 0x00000088)
+#define mei_xmem_bar13_c      (DFE_BASE_ADDR + 0x0000008C)
+#define mei_xmem_bar14_c      (DFE_BASE_ADDR + 0x00000090)
+#define mei_xmem_bar15_c      (DFE_BASE_ADDR + 0x00000094)
+#define mei_xmem_bar16_c      (DFE_BASE_ADDR + 0x00000098)
+
+#define mei_dataxfr_r         0xffffffff
+#define mei_version_r         0x00000003
+#define mei_arc_gp_r          0xffffffff
+#define mei_dataxfr_stat_r    0x00000003
+#define mei_xfraddr_r         0x3ffffffc
+#define mei_max_wait_r        0x00000000
+#define mei_2_arcint_r        0x00000000
+#define mei_fr_arcint_r       0x00000000
+#define mei_fr_arcimsk_r      0x00000000
+#define mei_dbg_waddr_r       0x3fffffff
+#define mei_dbg_raddr_r       0x3fffffff
+#define mei_dbg_data_r        0xffffffff
+#define mei_dbg_deco_r        0x00000003
+#define mei_config_r          0x00000001
+#define mei_rst_ctrl_r        0x00000007
+#define mei_dbg_master_r      0x00000001
+#define mei_clk_ctrl_r        0x00000001
+#define mei_bist_ctrl_r       0x00000000
+#define mei_bist_stat_r       0x1FFFFFFC
+#define mei_xdata_base_sh_r   0x1FFFFFE0
+#define mei_xdata_base_r      0x1FFFFFE0
+#define mei_xmem_bar0_r       0x1FFFFFE0
+#define mei_xmem_bar1_r       0x1FFFFFE0
+#define mei_xmem_bar2_r       0x1FFFFFE0
+#define mei_xmem_bar3_r       0x1FFFFFE0
+#define mei_xmem_bar4_r       0x1FFFFFE0
+#define mei_xmem_bar5_r       0x1FFFFFE0
+#define mei_xmem_bar6_r       0x1FFFFFE0
+#define mei_xmem_bar7_r       0x1FFFFFE0
+#define mei_xmem_bar8_r       0x1FFFFFE0
+#define mei_xmem_bar9_r       0x1FFFFFE0
+#define mei_xmem_bar10_r      0x1FFFFFE0
+#define mei_xmem_bar11_r      0x1FFFFFE0
+#define mei_xmem_bar12_r      0x1FFFFFE0
+#define mei_xmem_bar13_r      0x1FFFFFE0
+#define mei_xmem_bar14_r      0x1FFFFFE0
+#define mei_xmem_bar15_r      0x1FFFFFE0
+#define mei_xmem_bar16_r      0x1FFFFFE0
+
+#define mei_dataxfr_m         0xffffffff
+#define mei_version_m         0x0000000f
+#define mei_arc_gp_m          0x00000000
+#define mei_dataxfr_stat_m    0x00000003
+#define mei_xfraddr_m         0x3ffffffc
+#define mei_max_wait_m        0x0000000f
+#define mei_2_arcint_m        0x000001ff
+#define mei_fr_arcint_m       0x000001ff
+#define mei_fr_arcimsk_m      0xffffffff
+#define mei_dbg_waddr_m       0x3fffffff
+#define mei_dbg_raddr_m       0x3fffffff
+#define mei_dbg_data_m        0xffffffff
+#define mei_dbg_deco_m        0x00000003
+#define mei_config_m          0x00000001
+#define mei_rst_ctrl_m        0x00000007
+#define mei_dbg_master_m      0x00000001
+#define mei_clk_ctrl_m        0x00000001
+#define	mei_bist_ctrl_m       0xffffffff
+#define	mei_bist_stat_m       0x1FFFFFFC
+#define	mei_xdata_base_sh_m   0x1FFFFFE0
+#define	mei_xdata_base_m      0x1FFFFFE0
+#define mei_xmem_bar0_m       0x1FFFFFE0
+#define mei_xmem_bar1_m       0x1FFFFFE0
+#define mei_xmem_bar2_m       0x1FFFFFE0
+#define mei_xmem_bar3_m       0x1FFFFFE0
+#define mei_xmem_bar4_m       0x1FFFFFE0
+#define mei_xmem_bar5_m       0x1FFFFFE0
+#define mei_xmem_bar6_m       0x1FFFFFE0
+#define mei_xmem_bar7_m       0x1FFFFFE0
+#define mei_xmem_bar8_m       0x1FFFFFE0
+#define mei_xmem_bar9_m       0x1FFFFFE0
+#define mei_xmem_bar10_m      0x1FFFFFE0
+#define mei_xmem_bar11_m      0x1FFFFFE0
+#define mei_xmem_bar12_m      0x1FFFFFE0
+#define mei_xmem_bar13_m      0x1FFFFFE0
+#define mei_xmem_bar14_m      0x1FFFFFE0
+#define mei_xmem_bar15_m      0x1FFFFFE0
+#define mei_xmem_bar16_m      0x1FFFFFE0
+
+//************************** Constants *************************/
+//* ARC address spaces, visible to the MEI using the debug port.  */
+//* ARC load/store space definitions */
+#define IRAM0_BASE 0x00000
+#define IRAM0_SIZE (16*1024)
+#define IRAM1_BASE 0x04000
+#define IRAM1_SIZE (22*1024)
+#define IRAM2_BASE 0x08000    // to be removed
+#define IRAM2_SIZE (8*1024)   // to be removed
+#define BRAM_BASE 0x40000
+#define BRAM_SIZE (152*1024)
+#define IIBRAM2_BASE 0x66000
+#define IIBRAM2_SIZE (16*1024)
+#define XRAM_BASE 0x30000
+#define XRAM_SIZE (4*1024)
+#define YRAM_BASE 0x34000
+#define YRAM_SIZE (4*1024)
+#define LDST_BASE 0x20000
+#define LDST_SIZE (512)
+#define ADSL_BASE 0x40000      // to be removed
+#define ADSL_SIZE (168*1024)   // to be removed
+#define SDRAM_BASE 0x80000
+#define SDRAM_SIZE (2048*1024)
+#define EXT_SDRAM_BASE 0x200000      // mapped to XMEM_BARx Register at 0x80000
+#define EXT_SDRAM_SIZE (2048*1024)
+
+/* Dsp Memory Address Constants */
+#define dsp_iram_base          (0x0000)
+#define dsp_iram_mask          (0xFFFFFFFF)
+#define dsp_iram_size          (0x9000)
+#define dsp_iram_default       (0x0000)
+#define dsp_dccm_base          (0x10000)
+#define dsp_dccm_mask          (0xFFFFFFFF)
+#define dsp_dccm_size          (0x4000)
+#define dsp_dccm_default       (0x0000)
+#define dsp_ldstreg_base       (0x20000)
+#define dsp_ldstreg_mask       (0xFFFFFFFF)
+#define dsp_ldstreg_size       (0x0200)
+#define dsp_ldstreg_default    (0x0000)
+#define dsp_xram_base          (0x30000)
+#define dsp_xram_mask          (0xFFFFFFFF)
+#define dsp_xram_size          (0x1000)
+#define dsp_xram_default       (0x0000)
+#define dsp_yram_base          (0x34000)
+#define dsp_yram_mask          (0xFFFFFFFF)
+#define dsp_yram_size          (0x1000)
+#define dsp_yram_default       (0x0000)
+#define dsp_iibram_base        (0x40000)
+#define dsp_iibram_mask        (0xFFFFFFFF)
+#define dsp_iibram_size        (0x28000)
+#define dsp_iibram_default     (0x0000)
+#define dsp_sdram_base         (0x80000)
+#define dsp_sdram_mask         (0xFFFFFFFF)
+#define dsp_sdram_size         (0x200000)
+#define dsp_sdram_default      (0x0000)
+
+#define ME_DBG_RD 0
+#define ME_DBG_WR 1
+
+//----------------------------------------
+// mei_dbg_access
+//----------------------------------------
+#define me_dx_rd(a,d,n) {REG32(MEIAD(ME_DX_AD))=a;for (k=0;k<n;k++) { *((d)+k)=REG32(MEIAD(ME_DX_DATA));};}
+#define me_dx_wr(a,d,n) {REG32(MEIAD(ME_DX_AD))=a;for (k=0;k<n;k++) { REG32(MEIAD(ME_DX_DATA))=*((d)+k);};}
+#define me_dbg_wr(a,d) {REG32(MEIAD(ME_DBG_WR_AD))=a; REG32(MEIAD(ME_DBG_DATA))=d; while(!(REG32(MEIAD(ME_ARC2ME_STAT))&0x10));REG32(MEIAD(ME_ARC2ME_STAT))=0x10; }
+#define me_dbg_rd(a,d) {REG32(MEIAD(ME_DBG_RD_AD))=a; while(!(REG32(MEIAD(ME_ARC2ME_STAT))&0x10));REG32(MEIAD(ME_ARC2ME_STAT))=0x10; d=REG32(MEIAD(ME_DBG_DATA));}
+#define me_dbg_master_on {REG32(MEIAD(ME_DBG_MASTER))=1;}
+#define me_dbg_master_off {REG32(MEIAD(ME_DBG_MASTER))=0;}
+#define me_dbg_port(p) {REG32(MEIAD(ME_DBG_PORT_SEL))=p;}
+#define me_dbg_decode(acc) {REG32(MEIAD(ME_DBG_DECODE))=acc;}
+#define ARC_CORE_REG_ADDR_SPACE 3
+#define ARC_AUX_REG_ADDR_SPACE  0
+#define ARC_LDST_ADDR_SPACE     1
+#define S_JTAG 0
+#define S_MEI 0x1
+
+#define ARC_STATUS32        0x000A
+
+#define dsl_dbg_check1(a,d,m,idx) {me_dbg_rd(a,read_data);if ((read_data&(m))!=((d)&(m))) {asc_puts("Error Detected at Address : "); print_u32((a)|0xF0000000|((idx)<<24)); asc_puts(", expect : "); print_u32((d)&(m)); asc_puts(", get : "); print_u32(read_data&(m)); asc_puts("\n"); err++;};}
+#define dsl_dbg_check2(a,d,m,idx) {me_dbg_wr(a,d);dsl_dbg_check1(a,d,m,idx);}
+
+/* Dsp Mgmt Address Constants */
+#define dsp_mgmt_reg_base      (0x0000)
+#define DSP_MGMT_REG(r)        (int)(dsp_mgmt_reg_base + (r))
+#define dsp_mgmt_reg_size      (0x0080)
+
+#define ME_VERSION             DSP_MGMT_REG(0x0000)
+#define ME_VERSION_WMASK       (0x0000)
+#define ME_VERSION_MASK        (0x0FFF)
+#define ME_VERSION_DEFAULT     (0x0240)
+#define ME_VERSION_FMASK       (0x0FFF)
+#define ME_ARC2ME_STAT         DSP_MGMT_REG(0x0004)
+#define ME_ARC2ME_STAT_WMASK   (0x0037)
+#define ME_ARC2ME_STAT_MASK    (0x0037)
+#define ME_ARC2ME_STAT_DEFAULT (0x0000)
+#define ME_ARC2ME_STAT_FMASK   (0x0037)
+#define ME_ARC2ME_MASK         DSP_MGMT_REG(0x0008)
+#define ME_ARC2ME_MASK_WMASK   (0x0037)
+#define ME_ARC2ME_MASK_MASK    (0x0037)
+#define ME_ARC2ME_MASK_DEFAULT (0x0000)
+#define ME_ARC2ME_MASK_FMASK   (0x0037)
+#define ME_ME2ARC_INT          DSP_MGMT_REG(0x000C)
+#define ME_ME2ARC_INT_WMASK    (0x0007)
+#define ME_ME2ARC_INT_MASK     (0x0000)
+#define ME_ME2ARC_INT_DEFAULT  (0x0000)
+#define ME_ME2ARC_INT_FMASK    (0x0007)
+#define ME_ME2ARC_STAT         DSP_MGMT_REG(0x0010)
+#define ME_ME2ARC_STAT_WMASK   (0x0000)
+#define ME_ME2ARC_STAT_MASK    (0x0007)
+#define ME_ME2ARC_STAT_DEFAULT (0x0000)
+#define ME_ME2ARC_STAT_FMASK   (0x0007)
+#define ME_CLK_CTRL            DSP_MGMT_REG(0x0014)
+#define ME_CLK_CTRL_WMASK      (0x0001)
+#define ME_CLK_CTRL_MASK       (0x0001)
+#define ME_CLK_CTRL_DEFAULT    (0x0001)
+#define ME_CLK_CTRL_FMASK      (0x0001)
+#define ME_RST_CTRL            DSP_MGMT_REG(0x0018)
+#define ME_RST_CTRL_WMASK      (0x0007)
+#define ME_RST_CTRL_MASK       (0x0007)
+#define ME_RST_CTRL_DEFAULT    (0x0000)
+#define ME_RST_CTRL_FMASK      (0x0007)
+#define ME_CHIP_CONFIG         DSP_MGMT_REG(0x001C)
+#define ME_CHIP_CONFIG_WMASK   (0x0001)
+#define ME_CHIP_CONFIG_MASK    (0x0001)
+#define ME_CHIP_CONFIG_DEFAULT (0x0000)
+#define ME_CHIP_CONFIG_FMASK   (0x0001)
+#define ME_DBG_MASTER          DSP_MGMT_REG(0x0020)
+#define ME_DBG_MASTER_WMASK    (0x0001)
+#define ME_DBG_MASTER_MASK     (0x0001)
+#define ME_DBG_MASTER_DEFAULT  (0x0000)
+#define ME_DBG_MASTER_FMASK    (0x0001)
+#define ME_DBG_DECODE          DSP_MGMT_REG(0x0024)
+#define ME_DBG_DECODE_WMASK    (0x0003)
+#define ME_DBG_DECODE_MASK     (0x0003)
+#define ME_DBG_DECODE_DEFAULT  (0x0000)
+#define ME_DBG_DECODE_FMASK    (0x0003)
+#define ME_DBG_PORT_SEL        DSP_MGMT_REG(0x0028)
+#define ME_DBG_PORT_SEL_WMASK  (0x0001)
+#define ME_DBG_PORT_SEL_MASK   (0x0001)
+#define ME_DBG_PORT_SEL_DEFAULT (0x0000)
+#define ME_DBG_PORT_SEL_FMASK  (0x0001)
+#define ME_DBG_RD_AD           DSP_MGMT_REG(0x002C)
+#define ME_DBG_RD_AD_WMASK     (0x3FFFFF)
+#define ME_DBG_RD_AD_MASK      (0x3FFFFF)
+#define ME_DBG_RD_AD_DEFAULT   (0x0000)
+#define ME_DBG_RD_AD_FMASK     (0x3FFFFF)
+#define ME_DBG_WR_AD           DSP_MGMT_REG(0x0030)
+#define ME_DBG_WR_AD_WMASK     (0x3FFFFF)
+#define ME_DBG_WR_AD_MASK      (0x3FFFFF)
+#define ME_DBG_WR_AD_DEFAULT   (0x0000)
+#define ME_DBG_WR_AD_FMASK     (0x3FFFFF)
+#define ME_DBG_DATA            DSP_MGMT_REG(0x0034)
+#define ME_DBG_DATA_WMASK      (0xFFFFFFFF)
+#define ME_DBG_DATA_MASK       (0xFFFFFFFF)
+#define ME_DBG_DATA_DEFAULT    (0x0000)
+#define ME_DBG_DATA_FMASK      (0xFFFFFFFF)
+#define ME_DX_PORT_SEL         DSP_MGMT_REG(0x0038)
+#define ME_DX_PORT_SEL_WMASK   (0x0001)
+#define ME_DX_PORT_SEL_MASK    (0x0001)
+#define ME_DX_PORT_SEL_DEFAULT (0x0000)
+#define ME_DX_PORT_SEL_FMASK   (0x0001)
+#define ME_DX_AD               DSP_MGMT_REG(0x003C)
+#define ME_DX_AD_WMASK         (0x3FFFFC)
+#define ME_DX_AD_MASK          (0x3FFFFF)
+#define ME_DX_AD_DEFAULT       (0x0000)
+#define ME_DX_AD_FMASK         (0x3FFFFF)
+#define ME_DX_DATA             DSP_MGMT_REG(0x0040)
+#define ME_DX_DATA_WMASK       (0xFFFFFFFF)
+#define ME_DX_DATA_MASK        (0xFFFFFFFF)
+#define ME_DX_DATA_DEFAULT     (0x0000)
+#define ME_DX_DATA_FMASK       (0xFFFFFFFF)
+#define ME_DX_STAT             DSP_MGMT_REG(0x0044)
+#define ME_DX_STAT_WMASK       (0x0003)
+#define ME_DX_STAT_MASK        (0x0003)
+#define ME_DX_STAT_DEFAULT     (0x0000)
+#define ME_DX_STAT_FMASK       (0x0003)
+#define ME_DX_MWS              DSP_MGMT_REG(0x0048)
+#define ME_DX_MWS_WMASK        (0x000F)
+#define ME_DX_MWS_MASK         (0x000F)
+#define ME_DX_MWS_DEFAULT      (0x0003)
+#define ME_DX_MWS_FMASK        (0x000F)
+#define ME_ARC_GP_STAT         DSP_MGMT_REG(0x004C)
+#define ME_ARC_GP_STAT_WMASK   (0x0000)
+#define ME_ARC_GP_STAT_MASK    (0xFFFFFFFF)
+#define ME_ARC_GP_STAT_DEFAULT (0x0000)
+#define ME_ARC_GP_STAT_FMASK   (0xFFFFFFFF)
+#define ME_XDATA_BASE_SH       DSP_MGMT_REG(0x0050)
+#define ME_XDATA_BASE_SH_WMASK (0xFFFFFFE0)
+#define ME_XDATA_BASE_SH_MASK  (0xFFFFFFE0)
+#define ME_XDATA_BASE_SH_DEFAULT (0xFFFFFFE0)
+#define ME_XDATA_BASE_SH_FMASK (0xFFFFFFE0)
+#define ME_XDATA_BASE          DSP_MGMT_REG(0x0054)
+#define ME_XDATA_BASE_WMASK    (0x0000)
+#define ME_XDATA_BASE_MASK     (0xFFFFFFE0)
+#define ME_XDATA_BASE_DEFAULT  (0xFFFFFFE0)
+#define ME_XDATA_BASE_FMASK    (0xFFFFFFE0)
+#define ME_XMEM_BAR0           DSP_MGMT_REG(0x0058)
+#define ME_XMEM_BAR0_WMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR0_MASK      (0xFFFFFFE0)
+#define ME_XMEM_BAR0_DEFAULT   (0xFFFFFFE0)
+#define ME_XMEM_BAR0_FMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR1           DSP_MGMT_REG(0x005C)
+#define ME_XMEM_BAR1_WMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR1_MASK      (0xFFFFFFE0)
+#define ME_XMEM_BAR1_DEFAULT   (0xFFFFFFE0)
+#define ME_XMEM_BAR1_FMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR2           DSP_MGMT_REG(0x0060)
+#define ME_XMEM_BAR2_WMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR2_MASK      (0xFFFFFFE0)
+#define ME_XMEM_BAR2_DEFAULT   (0xFFFFFFE0)
+#define ME_XMEM_BAR2_FMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR3           DSP_MGMT_REG(0x0064)
+#define ME_XMEM_BAR3_WMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR3_MASK      (0xFFFFFFE0)
+#define ME_XMEM_BAR3_DEFAULT   (0xFFFFFFE0)
+#define ME_XMEM_BAR3_FMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR4           DSP_MGMT_REG(0x0068)
+#define ME_XMEM_BAR4_WMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR4_MASK      (0xFFFFFFE0)
+#define ME_XMEM_BAR4_DEFAULT   (0xFFFFFFE0)
+#define ME_XMEM_BAR4_FMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR5           DSP_MGMT_REG(0x006C)
+#define ME_XMEM_BAR5_WMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR5_MASK      (0xFFFFFFE0)
+#define ME_XMEM_BAR5_DEFAULT   (0xFFFFFFE0)
+#define ME_XMEM_BAR5_FMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR6           DSP_MGMT_REG(0x0070)
+#define ME_XMEM_BAR6_WMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR6_MASK      (0xFFFFFFE0)
+#define ME_XMEM_BAR6_DEFAULT   (0xFFFFFFE0)
+#define ME_XMEM_BAR6_FMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR7           DSP_MGMT_REG(0x0074)
+#define ME_XMEM_BAR7_WMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR7_MASK      (0xFFFFFFE0)
+#define ME_XMEM_BAR7_DEFAULT   (0xFFFFFFE0)
+#define ME_XMEM_BAR7_FMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR8           DSP_MGMT_REG(0x0078)
+#define ME_XMEM_BAR8_WMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR8_MASK      (0xFFFFFFE0)
+#define ME_XMEM_BAR8_DEFAULT   (0xFFFFFFE0)
+#define ME_XMEM_BAR8_FMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR9           DSP_MGMT_REG(0x007C)
+#define ME_XMEM_BAR9_WMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR9_MASK      (0xFFFFFFE0)
+#define ME_XMEM_BAR9_DEFAULT   (0xFFFFFFE0)
+#define ME_XMEM_BAR9_FMASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR10          DSP_MGMT_REG(0x0080)
+#define ME_XMEM_BAR10_WMASK    (0xFFFFFFE0)
+#define ME_XMEM_BAR10_MASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR10_DEFAULT  (0xFFFFFFE0)
+#define ME_XMEM_BAR10_FMASK    (0xFFFFFFE0)
+#define ME_XMEM_BAR11          DSP_MGMT_REG(0x0084)
+#define ME_XMEM_BAR11_WMASK    (0xFFFFFFE0)
+#define ME_XMEM_BAR11_MASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR11_DEFAULT  (0xFFFFFFE0)
+#define ME_XMEM_BAR11_FMASK    (0xFFFFFFE0)
+#define ME_XMEM_BAR12          DSP_MGMT_REG(0x0088)
+#define ME_XMEM_BAR12_WMASK    (0xFFFFFFE0)
+#define ME_XMEM_BAR12_MASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR12_DEFAULT  (0xFFFFFFE0)
+#define ME_XMEM_BAR12_FMASK    (0xFFFFFFE0)
+#define ME_XMEM_BAR13          DSP_MGMT_REG(0x008C)
+#define ME_XMEM_BAR13_WMASK    (0xFFFFFFE0)
+#define ME_XMEM_BAR13_MASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR13_DEFAULT  (0xFFFFFFE0)
+#define ME_XMEM_BAR13_FMASK    (0xFFFFFFE0)
+#define ME_XMEM_BAR14          DSP_MGMT_REG(0x0090)
+#define ME_XMEM_BAR14_WMASK    (0xFFFFFFE0)
+#define ME_XMEM_BAR14_MASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR14_DEFAULT  (0xFFFFFFE0)
+#define ME_XMEM_BAR14_FMASK    (0xFFFFFFE0)
+#define ME_XMEM_BAR15          DSP_MGMT_REG(0x0094)
+#define ME_XMEM_BAR15_WMASK    (0xFFFFFFE0)
+#define ME_XMEM_BAR15_MASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR15_DEFAULT  (0xFFFFFFE0)
+#define ME_XMEM_BAR15_FMASK    (0xFFFFFFE0)
+#define ME_XMEM_BAR16          DSP_MGMT_REG(0x0098)
+#define ME_XMEM_BAR16_WMASK    (0xFFFFFFE0)
+#define ME_XMEM_BAR16_MASK     (0xFFFFFFE0)
+#define ME_XMEM_BAR16_DEFAULT  (0x1E200000)
+#define ME_XMEM_BAR16_FMASK    (0xFFFFFFE0)
+#define ME_XMEM_ARB_MISC       DSP_MGMT_REG(0x009C)
+#define ME_XMEM_ARB_MISC_WMASK (0x0000)
+#define ME_XMEM_ARB_MISC_MASK  (0x000F)
+#define ME_XMEM_ARB_MISC_DEFAULT (0x0000)
+#define ME_XMEM_ARB_MISC_FMASK (0x000F)
+
+/* Dsp Ldstreg Address Constants */
+#define dsp_ldstreg_reg_base   (0x20000)
+#define DSP_LDSTREG_REG(r)     (int)(dsp_ldstreg_reg_base + (r))
+#define dsp_ldstreg_reg_size   (0x0080)
+
+#define D_VERSION              DSP_LDSTREG_REG(0x0000)
+#define D_VERSION_WMASK        (0x0000)
+#define D_VERSION_MASK         (0x0FFF)
+#define D_VERSION_DEFAULT      (0x0230)
+#define D_VERSION_FMASK        (0x0FFF)
+#define D_PORT_SEL             DSP_LDSTREG_REG(0x0004)
+#define D_PORT_SEL_WMASK       (0x1113311)
+#define D_PORT_SEL_MASK        (0x1113311)
+#define D_PORT_SEL_DEFAULT     (0x0000)
+#define D_PORT_SEL_FMASK       (0x1113311)
+#define D_INT_STAT             DSP_LDSTREG_REG(0x0008)
+#define D_INT_STAT_WMASK       (0x3003371)
+#define D_INT_STAT_MASK        (0x3333371)
+#define D_INT_STAT_DEFAULT     (0x0000)
+#define D_INT_STAT_FMASK       (0x3333371)
+#define D_INT_MASK             DSP_LDSTREG_REG(0x000C)
+#define D_INT_MASK_WMASK       (0x3333371)
+#define D_INT_MASK_MASK        (0x3333371)
+#define D_INT_MASK_DEFAULT     (0x0000)
+#define D_INT_MASK_FMASK       (0x3333371)
+#define D_MEMEX_SRC            DSP_LDSTREG_REG(0x0010)
+#define D_MEMEX_SRC_WMASK      (0x000F)
+#define D_MEMEX_SRC_MASK       (0x000F)
+#define D_MEMEX_SRC_DEFAULT    (0x0000)
+#define D_MEMEX_SRC_FMASK      (0x000F)
+#define D_ARC2ME_INT           DSP_LDSTREG_REG(0x0014)
+#define D_ARC2ME_INT_WMASK     (0x0007)
+#define D_ARC2ME_INT_MASK      (0x0007)
+#define D_ARC2ME_INT_DEFAULT   (0x0000)
+#define D_ARC2ME_INT_FMASK     (0x0007)
+#define D_ARC2ME_STAT          DSP_LDSTREG_REG(0x0018)
+#define D_ARC2ME_STAT_WMASK    (0x0000)
+#define D_ARC2ME_STAT_MASK     (0x0007)
+#define D_ARC2ME_STAT_DEFAULT  (0x0000)
+#define D_ARC2ME_STAT_FMASK    (0x0007)
+#define D_GP_STAT              DSP_LDSTREG_REG(0x001C)
+#define D_GP_STAT_WMASK        (0xFFFFFFFF)
+#define D_GP_STAT_MASK         (0xFFFFFFFF)
+#define D_GP_STAT_DEFAULT      (0x0000)
+#define D_GP_STAT_FMASK        (0xFFFFFFFF)
+#define D_ME_CONFIG            DSP_LDSTREG_REG(0x0020)
+#define D_ME_CONFIG_WMASK      (0x0000)
+#define D_ME_CONFIG_MASK       (0x0001)
+#define D_ME_CONFIG_DEFAULT    (0x0000)
+#define D_ME_CONFIG_FMASK      (0x0001)
+#define D_MEMEXT_SEL           DSP_LDSTREG_REG(0x0024)
+#define D_MEMEXT_SEL_WMASK     (0x0000)
+#define D_MEMEXT_SEL_MASK      (0x0007)
+#define D_MEMEXT_SEL_DEFAULT   (0x0000)
+#define D_MEMEXT_SEL_FMASK     (0x0007)
+#define D_ADMA0_CTRL           DSP_LDSTREG_REG(0x0028)
+#define D_ADMA0_CTRL_WMASK     (0x0003)
+#define D_ADMA0_CTRL_MASK      (0x0003)
+#define D_ADMA0_CTRL_DEFAULT   (0x0000)
+#define D_ADMA0_CTRL_FMASK     (0x0003)
+#define D_ADMA0_STAT           DSP_LDSTREG_REG(0x002C)
+#define D_ADMA0_STAT_WMASK     (0x0000)
+#define D_ADMA0_STAT_MASK      (0x0007)
+#define D_ADMA0_STAT_DEFAULT   (0x0000)
+#define D_ADMA0_STAT_FMASK     (0x0007)
+#define D_ADMA0_SA_S           DSP_LDSTREG_REG(0x0030)
+#define D_ADMA0_SA_S_WMASK     (0x3FFFFE)
+#define D_ADMA0_SA_S_MASK      (0x3FFFFF)
+#define D_ADMA0_SA_S_DEFAULT   (0x0000)
+#define D_ADMA0_SA_S_FMASK     (0x3FFFFF)
+#define D_ADMA0_SA_E           DSP_LDSTREG_REG(0x0034)
+#define D_ADMA0_SA_E_WMASK     (0x3FFFFE)
+#define D_ADMA0_SA_E_MASK      (0x3FFFFF)
+#define D_ADMA0_SA_E_DEFAULT   (0x0000)
+#define D_ADMA0_SA_E_FMASK     (0x3FFFFF)
+#define D_ADMA0_DA_S           DSP_LDSTREG_REG(0x0038)
+#define D_ADMA0_DA_S_WMASK     (0x3FFFFE)
+#define D_ADMA0_DA_S_MASK      (0x3FFFFF)
+#define D_ADMA0_DA_S_DEFAULT   (0x0000)
+#define D_ADMA0_DA_S_FMASK     (0x3FFFFF)
+#define D_ADMA0_FILL_VAL       DSP_LDSTREG_REG(0x003C)
+#define D_ADMA0_FILL_VAL_WMASK (0xFFFFFFFF)
+#define D_ADMA0_FILL_VAL_MASK  (0xFFFFFFFF)
+#define D_ADMA0_FILL_VAL_DEFAULT (0x0000)
+#define D_ADMA0_FILL_VAL_FMASK (0xFFFFFFFF)
+#define D_ADMA1_CTRL           DSP_LDSTREG_REG(0x0040)
+#define D_ADMA1_CTRL_WMASK     (0x0003)
+#define D_ADMA1_CTRL_MASK      (0x0003)
+#define D_ADMA1_CTRL_DEFAULT   (0x0000)
+#define D_ADMA1_CTRL_FMASK     (0x0003)
+#define D_ADMA1_STAT           DSP_LDSTREG_REG(0x0044)
+#define D_ADMA1_STAT_WMASK     (0x0000)
+#define D_ADMA1_STAT_MASK      (0x0007)
+#define D_ADMA1_STAT_DEFAULT   (0x0000)
+#define D_ADMA1_STAT_FMASK     (0x0007)
+#define D_ADMA1_SA_S           DSP_LDSTREG_REG(0x0048)
+#define D_ADMA1_SA_S_WMASK     (0x3FFFFE)
+#define D_ADMA1_SA_S_MASK      (0x3FFFFF)
+#define D_ADMA1_SA_S_DEFAULT   (0x0000)
+#define D_ADMA1_SA_S_FMASK     (0x3FFFFF)
+#define D_ADMA1_SA_E           DSP_LDSTREG_REG(0x004C)
+#define D_ADMA1_SA_E_WMASK     (0x3FFFFE)
+#define D_ADMA1_SA_E_MASK      (0x3FFFFF)
+#define D_ADMA1_SA_E_DEFAULT   (0x0000)
+#define D_ADMA1_SA_E_FMASK     (0x3FFFFF)
+#define D_ADMA1_DA_S           DSP_LDSTREG_REG(0x0050)
+#define D_ADMA1_DA_S_WMASK     (0x3FFFFE)
+#define D_ADMA1_DA_S_MASK      (0x3FFFFF)
+#define D_ADMA1_DA_S_DEFAULT   (0x0000)
+#define D_ADMA1_DA_S_FMASK     (0x3FFFFF)
+#define D_ADMA1_FILL_VAL       DSP_LDSTREG_REG(0x0054)
+#define D_ADMA1_FILL_VAL_WMASK (0xFFFFFFFF)
+#define D_ADMA1_FILL_VAL_MASK  (0xFFFFFFFF)
+#define D_ADMA1_FILL_VAL_DEFAULT (0x0000)
+#define D_ADMA1_FILL_VAL_FMASK (0xFFFFFFFF)
+#define D_XDMA0_CTRL           DSP_LDSTREG_REG(0x0058)
+#define D_XDMA0_CTRL_WMASK     (0x0007)
+#define D_XDMA0_CTRL_MASK      (0x0007)
+#define D_XDMA0_CTRL_DEFAULT   (0x0000)
+#define D_XDMA0_CTRL_FMASK     (0x0007)
+#define D_XDMA0_STAT           DSP_LDSTREG_REG(0x005C)
+#define D_XDMA0_STAT_WMASK     (0x0000)
+#define D_XDMA0_STAT_MASK      (0x000F)
+#define D_XDMA0_STAT_DEFAULT   (0x0000)
+#define D_XDMA0_STAT_FMASK     (0x000F)
+#define D_XDMA0_SA_S           DSP_LDSTREG_REG(0x0060)
+#define D_XDMA0_SA_S_WMASK     (0x3FFFFFFE)
+#define D_XDMA0_SA_S_MASK      (0x3FFFFFFF)
+#define D_XDMA0_SA_S_DEFAULT   (0x0000)
+#define D_XDMA0_SA_S_FMASK     (0x3FFFFFFF)
+#define D_XDMA0_SA_E           DSP_LDSTREG_REG(0x0064)
+#define D_XDMA0_SA_E_WMASK     (0x203FFFFE)
+#define D_XDMA0_SA_E_MASK      (0x203FFFFF)
+#define D_XDMA0_SA_E_DEFAULT   (0x0000)
+#define D_XDMA0_SA_E_FMASK     (0x203FFFFF)
+#define D_XDMA0_DA_S           DSP_LDSTREG_REG(0x0068)
+#define D_XDMA0_DA_S_WMASK     (0x3FFFFFFE)
+#define D_XDMA0_DA_S_MASK      (0x3FFFFFFF)
+#define D_XDMA0_DA_S_DEFAULT   (0x0000)
+#define D_XDMA0_DA_S_FMASK     (0x3FFFFFFF)
+#define D_XDMA1_CTRL           DSP_LDSTREG_REG(0x006C)
+#define D_XDMA1_CTRL_WMASK     (0x0007)
+#define D_XDMA1_CTRL_MASK      (0x0007)
+#define D_XDMA1_CTRL_DEFAULT   (0x0000)
+#define D_XDMA1_CTRL_FMASK     (0x0007)
+#define D_XDMA1_STAT           DSP_LDSTREG_REG(0x0070)
+#define D_XDMA1_STAT_WMASK     (0x0000)
+#define D_XDMA1_STAT_MASK      (0x000F)
+#define D_XDMA1_STAT_DEFAULT   (0x0000)
+#define D_XDMA1_STAT_FMASK     (0x000F)
+#define D_XDMA1_SA_S           DSP_LDSTREG_REG(0x0074)
+#define D_XDMA1_SA_S_WMASK     (0x3FFFFFFE)
+#define D_XDMA1_SA_S_MASK      (0x3FFFFFFF)
+#define D_XDMA1_SA_S_DEFAULT   (0x0000)
+#define D_XDMA1_SA_S_FMASK     (0x3FFFFFFF)
+#define D_XDMA1_SA_E           DSP_LDSTREG_REG(0x0078)
+#define D_XDMA1_SA_E_WMASK     (0x203FFFFE)
+#define D_XDMA1_SA_E_MASK      (0x203FFFFF)
+#define D_XDMA1_SA_E_DEFAULT   (0x0000)
+#define D_XDMA1_SA_E_FMASK     (0x203FFFFF)
+#define D_XDMA1_DA_S           DSP_LDSTREG_REG(0x007C)
+#define D_XDMA1_DA_S_WMASK     (0x3FFFFFFE)
+#define D_XDMA1_DA_S_MASK      (0x3FFFFFFF)
+#define D_XDMA1_DA_S_DEFAULT   (0x0000)
+#define D_XDMA1_DA_S_FMASK     (0x3FFFFFFF)
+#define D_XDMA_GAP             DSP_LDSTREG_REG(0x0080)
+#define D_XDMA_GAP_WMASK       (0xFFFF)
+#define D_XDMA_GAP_MASK        (0xFFFF)
+#define D_XDMA_GAP_DEFAULT     (0x0000)
+#define D_XDMA_GAP_FMASK       (0xFFFF)
+#define D_XDATA_BASE_SH        DSP_LDSTREG_REG(0x0084)
+#define D_XDATA_BASE_SH_WMASK  (0x0000)
+#define D_XDATA_BASE_SH_MASK   (0x1FFFFFE0)
+#define D_XDATA_BASE_SH_DEFAULT (0x1FFFFFE0)
+#define D_XDATA_BASE_SH_FMASK  (0x1FFFFFE0)
+#define D_XDATA_BASE           DSP_LDSTREG_REG(0x0088)
+#define D_XDATA_BASE_WMASK     (0x0000)
+#define D_XDATA_BASE_MASK      (0x1FFFFFE0)
+#define D_XDATA_BASE_DEFAULT   (0x1FFFFFE0)
+#define D_XDATA_BASE_FMASK     (0x1FFFFFE0)
+#define D_XMEM_BAR0            DSP_LDSTREG_REG(0x008C)
+#define D_XMEM_BAR0_WMASK      (0x0000)
+#define D_XMEM_BAR0_MASK       (0x1FFFFFE0)
+#define D_XMEM_BAR0_DEFAULT    (0x1FFFFFE0)
+#define D_XMEM_BAR0_FMASK      (0x1FFFFFE0)
+#define D_XMEM_BAR1            DSP_LDSTREG_REG(0x0090)
+#define D_XMEM_BAR1_WMASK      (0x0000)
+#define D_XMEM_BAR1_MASK       (0x1FFFFFE0)
+#define D_XMEM_BAR1_DEFAULT    (0x1FFFFFE0)
+#define D_XMEM_BAR1_FMASK      (0x1FFFFFE0)
+#define D_XMEM_BAR2            DSP_LDSTREG_REG(0x0094)
+#define D_XMEM_BAR2_WMASK      (0x0000)
+#define D_XMEM_BAR2_MASK       (0x1FFFFFE0)
+#define D_XMEM_BAR2_DEFAULT    (0x1FFFFFE0)
+#define D_XMEM_BAR2_FMASK      (0x1FFFFFE0)
+#define D_XMEM_BAR3            DSP_LDSTREG_REG(0x0098)
+#define D_XMEM_BAR3_WMASK      (0x0000)
+#define D_XMEM_BAR3_MASK       (0x1FFFFFE0)
+#define D_XMEM_BAR3_DEFAULT    (0x1FFFFFE0)
+#define D_XMEM_BAR3_FMASK      (0x1FFFFFE0)
+#define D_XMEM_BAR4            DSP_LDSTREG_REG(0x009C)
+#define D_XMEM_BAR4_WMASK      (0x0000)
+#define D_XMEM_BAR4_MASK       (0x1FFFFFE0)
+#define D_XMEM_BAR4_DEFAULT    (0x1FFFFFE0)
+#define D_XMEM_BAR4_FMASK      (0x1FFFFFE0)
+#define D_XMEM_BAR5            DSP_LDSTREG_REG(0x00A0)
+#define D_XMEM_BAR5_WMASK      (0x0000)
+#define D_XMEM_BAR5_MASK       (0x1FFFFFE0)
+#define D_XMEM_BAR5_DEFAULT    (0x1FFFFFE0)
+#define D_XMEM_BAR5_FMASK      (0x1FFFFFE0)
+#define D_XMEM_BAR6            DSP_LDSTREG_REG(0x00A4)
+#define D_XMEM_BAR6_WMASK      (0x0000)
+#define D_XMEM_BAR6_MASK       (0x1FFFFFE0)
+#define D_XMEM_BAR6_DEFAULT    (0x1FFFFFE0)
+#define D_XMEM_BAR6_FMASK      (0x1FFFFFE0)
+#define D_XMEM_BAR7            DSP_LDSTREG_REG(0x00A8)
+#define D_XMEM_BAR7_WMASK      (0x0000)
+#define D_XMEM_BAR7_MASK       (0x1FFFFFE0)
+#define D_XMEM_BAR7_DEFAULT    (0x1FFFFFE0)
+#define D_XMEM_BAR7_FMASK      (0x1FFFFFE0)
+#define D_XMEM_BAR8            DSP_LDSTREG_REG(0x00AC)
+#define D_XMEM_BAR8_WMASK      (0x0000)
+#define D_XMEM_BAR8_MASK       (0x1FFFFFE0)
+#define D_XMEM_BAR8_DEFAULT    (0x1FFFFFE0)
+#define D_XMEM_BAR8_FMASK      (0x1FFFFFE0)
+#define D_XMEM_BAR9            DSP_LDSTREG_REG(0x00B0)
+#define D_XMEM_BAR9_WMASK      (0x0000)
+#define D_XMEM_BAR9_MASK       (0x1FFFFFE0)
+#define D_XMEM_BAR9_DEFAULT    (0x1FFFFFE0)
+#define D_XMEM_BAR9_FMASK      (0x1FFFFFE0)
+#define D_XMEM_BAR10           DSP_LDSTREG_REG(0x00B4)
+#define D_XMEM_BAR10_WMASK     (0x0000)
+#define D_XMEM_BAR10_MASK      (0x1FFFFFE0)
+#define D_XMEM_BAR10_DEFAULT   (0x1FFFFFE0)
+#define D_XMEM_BAR10_FMASK     (0x1FFFFFE0)
+#define D_XMEM_BAR11           DSP_LDSTREG_REG(0x00B8)
+#define D_XMEM_BAR11_WMASK     (0x0000)
+#define D_XMEM_BAR11_MASK      (0x1FFFFFE0)
+#define D_XMEM_BAR11_DEFAULT   (0x1FFFFFE0)
+#define D_XMEM_BAR11_FMASK     (0x1FFFFFE0)
+#define D_XMEM_BAR12           DSP_LDSTREG_REG(0x00BC)
+#define D_XMEM_BAR12_WMASK     (0x0000)
+#define D_XMEM_BAR12_MASK      (0x1FFFFFE0)
+#define D_XMEM_BAR12_DEFAULT   (0x1FFFFFE0)
+#define D_XMEM_BAR12_FMASK     (0x1FFFFFE0)
+#define D_XMEM_BAR13           DSP_LDSTREG_REG(0x00C0)
+#define D_XMEM_BAR13_WMASK     (0x0000)
+#define D_XMEM_BAR13_MASK      (0x1FFFFFE0)
+#define D_XMEM_BAR13_DEFAULT   (0x1FFFFFE0)
+#define D_XMEM_BAR13_FMASK     (0x1FFFFFE0)
+#define D_XMEM_BAR14           DSP_LDSTREG_REG(0x00C4)
+#define D_XMEM_BAR14_WMASK     (0x0000)
+#define D_XMEM_BAR14_MASK      (0x1FFFFFE0)
+#define D_XMEM_BAR14_DEFAULT   (0x1FFFFFE0)
+#define D_XMEM_BAR14_FMASK     (0x1FFFFFE0)
+#define D_XMEM_BAR15           DSP_LDSTREG_REG(0x00C8)
+#define D_XMEM_BAR15_WMASK     (0x0000)
+#define D_XMEM_BAR15_MASK      (0x1FFFFFE0)
+#define D_XMEM_BAR15_DEFAULT   (0x1FFFFFE0)
+#define D_XMEM_BAR15_FMASK     (0x1FFFFFE0)
+#define D_XMEM_BAR16           DSP_LDSTREG_REG(0x00CC)
+#define D_XMEM_BAR16_WMASK     (0x0000)
+#define D_XMEM_BAR16_MASK      (0x1FFFFFE0)
+#define D_XMEM_BAR16_DEFAULT   (0x1FFFFFE0)
+#define D_XMEM_BAR16_FMASK     (0x1FFFFFE0)
+#define D_GPIO_CTRL            DSP_LDSTREG_REG(0x00D0)
+#define D_GPIO_CTRL_WMASK      (0x3FFFF)
+#define D_GPIO_CTRL_MASK       (0x3FFFF)
+#define D_GPIO_CTRL_DEFAULT    (0x0000)
+#define D_GPIO_CTRL_FMASK      (0x3FFFF)
+#define D_GPIO_PW_CTRL         DSP_LDSTREG_REG(0x00D4)
+#define D_GPIO_PW_CTRL_WMASK   (0x000F)
+#define D_GPIO_PW_CTRL_MASK    (0x000F)
+#define D_GPIO_PW_CTRL_DEFAULT (0x0000)
+#define D_GPIO_PW_CTRL_FMASK   (0x000F)
+#define D_GPIO_DATA            DSP_LDSTREG_REG(0x00D8)
+#define D_GPIO_DATA_WMASK      (0xFFFF)
+#define D_GPIO_DATA_MASK       (0xFFFF)
+#define D_GPIO_DATA_DEFAULT    (0x0000)
+#define D_GPIO_DATA_FMASK      (0xFFFF)
+#define D_XMEM_LAT             DSP_LDSTREG_REG(0x00DC)
+#define D_XMEM_LAT_WMASK       (0x0FF1)
+#define D_XMEM_LAT_MASK        (0x0FF1)
+#define D_XMEM_LAT_DEFAULT     (0x0000)
+#define D_XMEM_LAT_FMASK       (0x0FF1)
+#define D_IC_MISSES            DSP_LDSTREG_REG(0x00E0)
+#define D_IC_MISSES_WMASK      (0x7FFFFFF)
+#define D_IC_MISSES_MASK       (0x7FFFFFF)
+#define D_IC_MISSES_DEFAULT    (0x0000)
+#define D_IC_MISSES_FMASK      (0x7FFFFFF)
+#define D_IC_MISS_LAT          DSP_LDSTREG_REG(0x00E4)
+#define D_IC_MISS_LAT_WMASK    (0xFFFFFFFF)
+#define D_IC_MISS_LAT_MASK     (0xFFFFFFFF)
+#define D_IC_MISS_LAT_DEFAULT  (0x0000)
+#define D_IC_MISS_LAT_FMASK    (0xFFFFFFFF)
+#define D_PER_IC_MISS_LAT      DSP_LDSTREG_REG(0x00E8)
+#define D_PER_IC_MISS_LAT_WMASK (0xFFFF)
+#define D_PER_IC_MISS_LAT_MASK (0xFFFF)
+#define D_PER_IC_MISS_LAT_DEFAULT (0x0000)
+#define D_PER_IC_MISS_LAT_FMASK (0xFFFF)
+#define D_XMEM_DATA_ACCS       DSP_LDSTREG_REG(0x00EC)
+#define D_XMEM_DATA_ACCS_WMASK (0xFFFFFFFF)
+#define D_XMEM_DATA_ACCS_MASK  (0xFFFFFFFF)
+#define D_XMEM_DATA_ACCS_DEFAULT (0xC0000000)
+#define D_XMEM_DATA_ACCS_FMASK (0xFFFFFFFF)
+#define D_XMEM_DATA_CLKS       DSP_LDSTREG_REG(0x00F0)
+#define D_XMEM_DATA_CLKS_WMASK (0xFFFFFFFF)
+#define D_XMEM_DATA_CLKS_MASK  (0xFFFFFFFF)
+#define D_XMEM_DATA_CLKS_DEFAULT (0x0000)
+#define D_XMEM_DATA_CLKS_FMASK (0xFFFFFFFF)
+
+/* Fc Memory Address Constants */
+#define fc_cwram_base          (0x20C000)
+#define fc_cwram_mask          (0xFFFF)
+#define fc_cwram_size          (0x0400)
+#define fc_cwram_default       (0x0000)
+
+/* Fci Memory Address Constants */
+#define fci_glbtx_base         (0x20D800)
+#define fci_glbtx_mask         (0xFFFFFFFF)
+#define fci_glbtx_size         (0x0400)
+#define fci_glbtx_default      (0x0000)
+#define fci_glbrx_base         (0x20DC00)
+#define fci_glbrx_mask         (0xFFFFFFFF)
+#define fci_glbrx_size         (0x0400)
+#define fci_glbrx_default      (0x0000)
+
+/* Fci Glbtx Address Constants */
+#define fci_glbtx_reg_base     (0x20D800)
+#define FCI_GLBTX_REG(r)       (int)(fci_glbtx_reg_base + (r))
+#define fci_glbtx_reg_size     (0x0001)
+
+#define ZT_R0                  FCI_GLBTX_REG(0x0000)
+#define ZT_R0_WMASK            (0xFFFFFFFF)
+#define ZT_R0_MASK             (0xFFFFFFFF)
+#define ZT_R0_DEFAULT          (0x0000)
+#define ZT_R0_FMASK            (0xFFFFFFFF)
+#define ZT_R4                  FCI_GLBTX_REG(0x0004)
+#define ZT_R4_WMASK            (0xFFFFFFFF)
+#define ZT_R4_MASK             (0xFFFFFFFF)
+#define ZT_R4_DEFAULT          (0x0000)
+#define ZT_R4_FMASK            (0xFFFFFFFF)
+#define ZT_R8                  FCI_GLBTX_REG(0x0008)
+#define ZT_R8_WMASK            (0xFFFFFFFF)
+#define ZT_R8_MASK             (0xFFFFFFFF)
+#define ZT_R8_DEFAULT          (0x0000)
+#define ZT_R8_FMASK            (0xFFFFFFFF)
+#define ZT_R12                 FCI_GLBTX_REG(0x000C)
+#define ZT_R12_WMASK           (0xFFFFFFFF)
+#define ZT_R12_MASK            (0xFFFFFFFF)
+#define ZT_R12_DEFAULT         (0x0000)
+#define ZT_R12_FMASK           (0xFFFFFFFF)
+#define ZT_CODEWORD            FCI_GLBTX_REG(0x0010)
+#define ZT_CODEWORD_WMASK      (0xFFFFFFFF)
+#define ZT_CODEWORD_MASK       (0xFFFFFFFF)
+#define ZT_CODEWORD_DEFAULT    (0x0000)
+#define ZT_CODEWORD_FMASK      (0xFFFFFFFF)
+#define ZT_VBC_SIZE            FCI_GLBTX_REG(0x0014)
+#define ZT_VBC_SIZE_WMASK      (0xFFFFFFFF)
+#define ZT_VBC_SIZE_MASK       (0xFFFFFFFF)
+#define ZT_VBC_SIZE_DEFAULT    (0x0000)
+#define ZT_VBC_SIZE_FMASK      (0xFFFFFFFF)
+#define ZT_FRAMING             FCI_GLBTX_REG(0x0018)
+#define ZT_FRAMING_WMASK       (0xFFFFFFFF)
+#define ZT_FRAMING_MASK        (0xFFFFFFFF)
+#define ZT_FRAMING_DEFAULT     (0x0000)
+#define ZT_FRAMING_FMASK       (0xFFFFFFFF)
+#define ZT_OHRATE              FCI_GLBTX_REG(0x001C)
+#define ZT_OHRATE_WMASK        (0xFFFFFFFF)
+#define ZT_OHRATE_MASK         (0xFFFFFFFF)
+#define ZT_OHRATE_DEFAULT      (0x0000)
+#define ZT_OHRATE_FMASK        (0xFFFFFFFF)
+#define ZT_FLAG_CTRL0          FCI_GLBTX_REG(0x0020)
+#define ZT_FLAG_CTRL0_WMASK    (0x77777777)
+#define ZT_FLAG_CTRL0_MASK     (0x77777777)
+#define ZT_FLAG_CTRL0_DEFAULT  (0x0000)
+#define ZT_FLAG_CTRL0_FMASK    (0x77777777)
+#define ZT_FLAG_CTRL1          FCI_GLBTX_REG(0x0024)
+#define ZT_FLAG_CTRL1_WMASK    (0x7777077)
+#define ZT_FLAG_CTRL1_MASK     (0x7777077)
+#define ZT_FLAG_CTRL1_DEFAULT  (0x0000)
+#define ZT_FLAG_CTRL1_FMASK    (0x7777077)
+#define ZT_CRC0                FCI_GLBTX_REG(0x0028)
+#define ZT_CRC0_WMASK          (0xFFFFFFFF)
+#define ZT_CRC0_MASK           (0xFFFFFFFF)
+#define ZT_CRC0_DEFAULT        (0x0000)
+#define ZT_CRC0_FMASK          (0xFFFFFFFF)
+#define ZT_CRC_POLY0           FCI_GLBTX_REG(0x002C)
+#define ZT_CRC_POLY0_WMASK     (0xFFFFFFFF)
+#define ZT_CRC_POLY0_MASK      (0xFFFFFFFF)
+#define ZT_CRC_POLY0_DEFAULT   (0x0000)
+#define ZT_CRC_POLY0_FMASK     (0xFFFFFFFF)
+#define ZT_CRC_CTRL0           FCI_GLBTX_REG(0x0030)
+#define ZT_CRC_CTRL0_WMASK     (0xFFFF0003)
+#define ZT_CRC_CTRL0_MASK      (0xFFFF0003)
+#define ZT_CRC_CTRL0_DEFAULT   (0x0000)
+#define ZT_CRC_CTRL0_FMASK     (0xFFFF0003)
+#define ZT_CRC1                FCI_GLBTX_REG(0x0034)
+#define ZT_CRC1_WMASK          (0xFFFFFFFF)
+#define ZT_CRC1_MASK           (0xFFFFFFFF)
+#define ZT_CRC1_DEFAULT        (0x0000)
+#define ZT_CRC1_FMASK          (0xFFFFFFFF)
+#define ZT_CRC_POLY1           FCI_GLBTX_REG(0x0038)
+#define ZT_CRC_POLY1_WMASK     (0xFFFFFFFF)
+#define ZT_CRC_POLY1_MASK      (0xFFFFFFFF)
+#define ZT_CRC_POLY1_DEFAULT   (0x0000)
+#define ZT_CRC_POLY1_FMASK     (0xFFFFFFFF)
+#define ZT_CRC_CTRL1           FCI_GLBTX_REG(0x003C)
+#define ZT_CRC_CTRL1_WMASK     (0xFFFF0003)
+#define ZT_CRC_CTRL1_MASK      (0xFFFF0003)
+#define ZT_CRC_CTRL1_DEFAULT   (0x0000)
+#define ZT_CRC_CTRL1_FMASK     (0xFFFF0003)
+#define ZT_SCR                 FCI_GLBTX_REG(0x0040)
+#define ZT_SCR_WMASK           (0xFFFFFFFF)
+#define ZT_SCR_MASK            (0xFFFFFFFF)
+#define ZT_SCR_DEFAULT         (0x0000)
+#define ZT_SCR_FMASK           (0xFFFFFFFF)
+#define ZT_SCR_POLY            FCI_GLBTX_REG(0x0044)
+#define ZT_SCR_POLY_WMASK      (0xFFFFFFFF)
+#define ZT_SCR_POLY_MASK       (0xFFFFFFFF)
+#define ZT_SCR_POLY_DEFAULT    (0x0000)
+#define ZT_SCR_POLY_FMASK      (0xFFFFFFFF)
+#define ZT_SCR_CTRL            FCI_GLBTX_REG(0x0048)
+#define ZT_SCR_CTRL_WMASK      (0x001F)
+#define ZT_SCR_CTRL_MASK       (0x001F)
+#define ZT_SCR_CTRL_DEFAULT    (0x0000)
+#define ZT_SCR_CTRL_FMASK      (0x001F)
+#define ZT_SCR_STATE           FCI_GLBTX_REG(0x004C)
+#define ZT_SCR_STATE_WMASK     (0x3FFFFFF)
+#define ZT_SCR_STATE_MASK      (0x3FFFFFF)
+#define ZT_SCR_STATE_DEFAULT   (0x0000)
+#define ZT_SCR_STATE_FMASK     (0x3FFFFFF)
+#define ZT_DTB_CTRL            FCI_GLBTX_REG(0x0050)
+#define ZT_DTB_CTRL_WMASK      (0x1FFF0FFF)
+#define ZT_DTB_CTRL_MASK       (0x1FFF0FFF)
+#define ZT_DTB_CTRL_DEFAULT    (0x0000)
+#define ZT_DTB_CTRL_FMASK      (0x1FFF0FFF)
+#define ZT_DTB_PTRS            FCI_GLBTX_REG(0x0054)
+#define ZT_DTB_PTRS_WMASK      (0xFFFFFFFF)
+#define ZT_DTB_PTRS_MASK       (0xFFFFFFFF)
+#define ZT_DTB_PTRS_DEFAULT    (0x0000)
+#define ZT_DTB_PTRS_FMASK      (0xFFFFFFFF)
+#define ZT_ILVB_WRAD           FCI_GLBTX_REG(0x0058)
+#define ZT_ILVB_WRAD_WMASK     (0xFFFFFFFF)
+#define ZT_ILVB_WRAD_MASK      (0xFFFFFFFF)
+#define ZT_ILVB_WRAD_DEFAULT   (0x0000)
+#define ZT_ILVB_WRAD_FMASK     (0xFFFFFFFF)
+#define ZT_ILVB_RDAD           FCI_GLBTX_REG(0x005C)
+#define ZT_ILVB_RDAD_WMASK     (0xFFFFFFFF)
+#define ZT_ILVB_RDAD_MASK      (0xFFFFFFFF)
+#define ZT_ILVB_RDAD_DEFAULT   (0x0000)
+#define ZT_ILVB_RDAD_FMASK     (0xFFFFFFFF)
+#define ZT_ILVB_WRPTR          FCI_GLBTX_REG(0x0060)
+#define ZT_ILVB_WRPTR_WMASK    (0xFFFFFFFF)
+#define ZT_ILVB_WRPTR_MASK     (0xFFFFFFFF)
+#define ZT_ILVB_WRPTR_DEFAULT  (0x0000)
+#define ZT_ILVB_WRPTR_FMASK    (0xFFFFFFFF)
+#define ZT_ILVB_RDPTR          FCI_GLBTX_REG(0x0064)
+#define ZT_ILVB_RDPTR_WMASK    (0xFFFFFFFF)
+#define ZT_ILVB_RDPTR_MASK     (0xFFFFFFFF)
+#define ZT_ILVB_RDPTR_DEFAULT  (0x0000)
+#define ZT_ILVB_RDPTR_FMASK    (0xFFFFFFFF)
+#define ZT_FIFO_BASE0          FCI_GLBTX_REG(0x0068)
+#define ZT_FIFO_BASE0_WMASK    (0x3FFFFFF)
+#define ZT_FIFO_BASE0_MASK     (0x3FFFFFF)
+#define ZT_FIFO_BASE0_DEFAULT  (0x0000)
+#define ZT_FIFO_BASE0_FMASK    (0x3FFFFFF)
+#define ZT_FIFO_PTRS0          FCI_GLBTX_REG(0x006C)
+#define ZT_FIFO_PTRS0_WMASK    (0xC0FF00FF)
+#define ZT_FIFO_PTRS0_MASK     (0xC0FF00FF)
+#define ZT_FIFO_PTRS0_DEFAULT  (0x0000)
+#define ZT_FIFO_PTRS0_FMASK    (0xC0FF00FF)
+#define ZT_FIFO_CNST0          FCI_GLBTX_REG(0x0070)
+#define ZT_FIFO_CNST0_WMASK    (0xFFFFFF)
+#define ZT_FIFO_CNST0_MASK     (0xFFFFFF)
+#define ZT_FIFO_CNST0_DEFAULT  (0x0000)
+#define ZT_FIFO_CNST0_FMASK    (0xFFFFFF)
+#define ZT_FIFO_BASE1          FCI_GLBTX_REG(0x0074)
+#define ZT_FIFO_BASE1_WMASK    (0x3FFFFFF)
+#define ZT_FIFO_BASE1_MASK     (0x3FFFFFF)
+#define ZT_FIFO_BASE1_DEFAULT  (0x0000)
+#define ZT_FIFO_BASE1_FMASK    (0x3FFFFFF)
+#define ZT_FIFO_PTRS1          FCI_GLBTX_REG(0x0078)
+#define ZT_FIFO_PTRS1_WMASK    (0xC0FF00FF)
+#define ZT_FIFO_PTRS1_MASK     (0xC0FF00FF)
+#define ZT_FIFO_PTRS1_DEFAULT  (0x0000)
+#define ZT_FIFO_PTRS1_FMASK    (0xC0FF00FF)
+#define ZT_FIFO_CNST1          FCI_GLBTX_REG(0x007C)
+#define ZT_FIFO_CNST1_WMASK    (0xFFFFFF)
+#define ZT_FIFO_CNST1_MASK     (0xFFFFFF)
+#define ZT_FIFO_CNST1_DEFAULT  (0x0000)
+#define ZT_FIFO_CNST1_FMASK    (0xFFFFFF)
+#define ZT_FIFO_BASE2          FCI_GLBTX_REG(0x0080)
+#define ZT_FIFO_BASE2_WMASK    (0x3FFFFFF)
+#define ZT_FIFO_BASE2_MASK     (0x3FFFFFF)
+#define ZT_FIFO_BASE2_DEFAULT  (0x0000)
+#define ZT_FIFO_BASE2_FMASK    (0x3FFFFFF)
+#define ZT_FIFO_PTRS2          FCI_GLBTX_REG(0x0084)
+#define ZT_FIFO_PTRS2_WMASK    (0xC0FF00FF)
+#define ZT_FIFO_PTRS2_MASK     (0xC0FF00FF)
+#define ZT_FIFO_PTRS2_DEFAULT  (0x0000)
+#define ZT_FIFO_PTRS2_FMASK    (0xC0FF00FF)
+#define ZT_FIFO_CNST2          FCI_GLBTX_REG(0x0088)
+#define ZT_FIFO_CNST2_WMASK    (0xFFFFFF)
+#define ZT_FIFO_CNST2_MASK     (0xFFFFFF)
+#define ZT_FIFO_CNST2_DEFAULT  (0x0000)
+#define ZT_FIFO_CNST2_FMASK    (0xFFFFFF)
+#define ZT_FIFO_BASE3          FCI_GLBTX_REG(0x008C)
+#define ZT_FIFO_BASE3_WMASK    (0x3FFFFFFF)
+#define ZT_FIFO_BASE3_MASK     (0x3FFFFFFF)
+#define ZT_FIFO_BASE3_DEFAULT  (0x0000)
+#define ZT_FIFO_BASE3_FMASK    (0x3FFFFFFF)
+#define ZT_FIFO_PTRS3          FCI_GLBTX_REG(0x0090)
+#define ZT_FIFO_PTRS3_WMASK    (0xCFFF0FFF)
+#define ZT_FIFO_PTRS3_MASK     (0xCFFF0FFF)
+#define ZT_FIFO_PTRS3_DEFAULT  (0x0000)
+#define ZT_FIFO_PTRS3_FMASK    (0xCFFF0FFF)
+#define ZT_FIFO_CNST3          FCI_GLBTX_REG(0x0094)
+#define ZT_FIFO_CNST3_WMASK    (0x1FFFFFF)
+#define ZT_FIFO_CNST3_MASK     (0x1FFFFFF)
+#define ZT_FIFO_CNST3_DEFAULT  (0x0000)
+#define ZT_FIFO_CNST3_FMASK    (0x1FFFFFF)
+#define ZT_DEPTH               FCI_GLBTX_REG(0x0098)
+#define ZT_DEPTH_WMASK         (0xFFFFFFFF)
+#define ZT_DEPTH_MASK          (0xFFFFFFFF)
+#define ZT_DEPTH_DEFAULT       (0x0000)
+#define ZT_DEPTH_FMASK         (0xFFFFFFFF)
+#define ZT_ILV_PARAMS0         FCI_GLBTX_REG(0x009C)
+#define ZT_ILV_PARAMS0_WMASK   (0xFFFFFF07)
+#define ZT_ILV_PARAMS0_MASK    (0xFFFFFF07)
+#define ZT_ILV_PARAMS0_DEFAULT (0x0000)
+#define ZT_ILV_PARAMS0_FMASK   (0xFFFFFF07)
+#define ZT_ILV_BASE0           FCI_GLBTX_REG(0x00A0)
+#define ZT_ILV_BASE0_WMASK     (0x3FFFF)
+#define ZT_ILV_BASE0_MASK      (0x3FFFF)
+#define ZT_ILV_BASE0_DEFAULT   (0x0000)
+#define ZT_ILV_BASE0_FMASK     (0x3FFFF)
+#define ZT_ILV_SIZE0           FCI_GLBTX_REG(0x00A4)
+#define ZT_ILV_SIZE0_WMASK     (0xFFFFFF)
+#define ZT_ILV_SIZE0_MASK      (0xFFFFFF)
+#define ZT_ILV_SIZE0_DEFAULT   (0x0000)
+#define ZT_ILV_SIZE0_FMASK     (0xFFFFFF)
+#define ZT_ILV_FULLNESS0       FCI_GLBTX_REG(0x00A8)
+#define ZT_ILV_FULLNESS0_WMASK (0xFFFFFFFF)
+#define ZT_ILV_FULLNESS0_MASK  (0xFFFFFFFF)
+#define ZT_ILV_FULLNESS0_DEFAULT (0x0000)
+#define ZT_ILV_FULLNESS0_FMASK (0xFFFFFFFF)
+#define ZT_ILV_CNTRS0          FCI_GLBTX_REG(0x00AC)
+#define ZT_ILV_CNTRS0_WMASK    (0xFFFFFFFF)
+#define ZT_ILV_CNTRS0_MASK     (0xFFFFFFFF)
+#define ZT_ILV_CNTRS0_DEFAULT  (0x0000)
+#define ZT_ILV_CNTRS0_FMASK    (0xFFFFFFFF)
+#define ZT_ILV_PMS_CNTRS0      FCI_GLBTX_REG(0x00B0)
+#define ZT_ILV_PMS_CNTRS0_WMASK (0xFFFFFFFF)
+#define ZT_ILV_PMS_CNTRS0_MASK (0xFFFFFFFF)
+#define ZT_ILV_PMS_CNTRS0_DEFAULT (0x0000)
+#define ZT_ILV_PMS_CNTRS0_FMASK (0xFFFFFFFF)
+#define ZT_ILV_PMD_CNTRS0      FCI_GLBTX_REG(0x00B4)
+#define ZT_ILV_PMD_CNTRS0_WMASK (0xFFFFFFFF)
+#define ZT_ILV_PMD_CNTRS0_MASK (0xFFFFFFFF)
+#define ZT_ILV_PMD_CNTRS0_DEFAULT (0x0000)
+#define ZT_ILV_PMD_CNTRS0_FMASK (0xFFFFFFFF)
+#define ZT_ILV_PARAMS1         FCI_GLBTX_REG(0x00B8)
+#define ZT_ILV_PARAMS1_WMASK   (0xFFFFFF07)
+#define ZT_ILV_PARAMS1_MASK    (0xFFFFFF07)
+#define ZT_ILV_PARAMS1_DEFAULT (0x0000)
+#define ZT_ILV_PARAMS1_FMASK   (0xFFFFFF07)
+#define ZT_ILV_BASE1           FCI_GLBTX_REG(0x00BC)
+#define ZT_ILV_BASE1_WMASK     (0x3FFFF)
+#define ZT_ILV_BASE1_MASK      (0x3FFFF)
+#define ZT_ILV_BASE1_DEFAULT   (0x0000)
+#define ZT_ILV_BASE1_FMASK     (0x3FFFF)
+#define ZT_ILV_SIZE1           FCI_GLBTX_REG(0x00C0)
+#define ZT_ILV_SIZE1_WMASK     (0xFFFFFF)
+#define ZT_ILV_SIZE1_MASK      (0xFFFFFF)
+#define ZT_ILV_SIZE1_DEFAULT   (0x0000)
+#define ZT_ILV_SIZE1_FMASK     (0xFFFFFF)
+#define ZT_ILV_FULLNESS1       FCI_GLBTX_REG(0x00C4)
+#define ZT_ILV_FULLNESS1_WMASK (0xFFFFFFFF)
+#define ZT_ILV_FULLNESS1_MASK  (0xFFFFFFFF)
+#define ZT_ILV_FULLNESS1_DEFAULT (0x0000)
+#define ZT_ILV_FULLNESS1_FMASK (0xFFFFFFFF)
+#define ZT_ILV_CNTRS1          FCI_GLBTX_REG(0x00C8)
+#define ZT_ILV_CNTRS1_WMASK    (0xFFFFFFFF)
+#define ZT_ILV_CNTRS1_MASK     (0xFFFFFFFF)
+#define ZT_ILV_CNTRS1_DEFAULT  (0x0000)
+#define ZT_ILV_CNTRS1_FMASK    (0xFFFFFFFF)
+#define ZT_ILV_PMS_CNTRS1      FCI_GLBTX_REG(0x00CC)
+#define ZT_ILV_PMS_CNTRS1_WMASK (0xFFFFFFFF)
+#define ZT_ILV_PMS_CNTRS1_MASK (0xFFFFFFFF)
+#define ZT_ILV_PMS_CNTRS1_DEFAULT (0x0000)
+#define ZT_ILV_PMS_CNTRS1_FMASK (0xFFFFFFFF)
+#define ZT_ILV_PMD_CNTRS1      FCI_GLBTX_REG(0x00D0)
+#define ZT_ILV_PMD_CNTRS1_WMASK (0xFFFFFFFF)
+#define ZT_ILV_PMD_CNTRS1_MASK (0xFFFFFFFF)
+#define ZT_ILV_PMD_CNTRS1_DEFAULT (0x0000)
+#define ZT_ILV_PMD_CNTRS1_FMASK (0xFFFFFFFF)
+#define ZT_CHECKBYTE0          FCI_GLBTX_REG(0x00D4)
+#define ZT_CHECKBYTE0_WMASK    (0xFFFFFFFF)
+#define ZT_CHECKBYTE0_MASK     (0xFFFFFFFF)
+#define ZT_CHECKBYTE0_DEFAULT  (0x0000)
+#define ZT_CHECKBYTE0_FMASK    (0xFFFFFFFF)
+#define ZT_CHECKBYTE1          FCI_GLBTX_REG(0x00D8)
+#define ZT_CHECKBYTE1_WMASK    (0xFFFFFFFF)
+#define ZT_CHECKBYTE1_MASK     (0xFFFFFFFF)
+#define ZT_CHECKBYTE1_DEFAULT  (0x0000)
+#define ZT_CHECKBYTE1_FMASK    (0xFFFFFFFF)
+#define ZT_CHECKBYTE2          FCI_GLBTX_REG(0x00DC)
+#define ZT_CHECKBYTE2_WMASK    (0xFFFFFFFF)
+#define ZT_CHECKBYTE2_MASK     (0xFFFFFFFF)
+#define ZT_CHECKBYTE2_DEFAULT  (0x0000)
+#define ZT_CHECKBYTE2_FMASK    (0xFFFFFFFF)
+#define ZT_CHECKBYTE3          FCI_GLBTX_REG(0x00E0)
+#define ZT_CHECKBYTE3_WMASK    (0xFFFFFFFF)
+#define ZT_CHECKBYTE3_MASK     (0xFFFFFFFF)
+#define ZT_CHECKBYTE3_DEFAULT  (0x0000)
+#define ZT_CHECKBYTE3_FMASK    (0xFFFFFFFF)
+#define ZT_TCSRC_STATE         FCI_GLBTX_REG(0x00E4)
+#define ZT_TCSRC_STATE_WMASK   (0xFFFFFF)
+#define ZT_TCSRC_STATE_MASK    (0xFFFFFF)
+#define ZT_TCSRC_STATE_DEFAULT (0x0000)
+#define ZT_TCSRC_STATE_FMASK   (0xFFFFFF)
+#define ZT_UPROC_ENA           FCI_GLBTX_REG(0x00E8)
+#define ZT_UPROC_ENA_WMASK     (0x03FF)
+#define ZT_UPROC_ENA_MASK      (0x03FF)
+#define ZT_UPROC_ENA_DEFAULT   (0x0000)
+#define ZT_UPROC_ENA_FMASK     (0x03FF)
+#define ZT_UPROC01_BASE        FCI_GLBTX_REG(0x00EC)
+#define ZT_UPROC01_BASE_WMASK  (0xFFFFFFFF)
+#define ZT_UPROC01_BASE_MASK   (0xFFFFFFFF)
+#define ZT_UPROC01_BASE_DEFAULT (0x0000)
+#define ZT_UPROC01_BASE_FMASK  (0xFFFFFFFF)
+#define ZT_UPROC23_BASE        FCI_GLBTX_REG(0x00F0)
+#define ZT_UPROC23_BASE_WMASK  (0xFFFFFFFF)
+#define ZT_UPROC23_BASE_MASK   (0xFFFFFFFF)
+#define ZT_UPROC23_BASE_DEFAULT (0x0000)
+#define ZT_UPROC23_BASE_FMASK  (0xFFFFFFFF)
+#define ZT_UPROC45_BASE        FCI_GLBTX_REG(0x00F4)
+#define ZT_UPROC45_BASE_WMASK  (0xFFFFFFFF)
+#define ZT_UPROC45_BASE_MASK   (0xFFFFFFFF)
+#define ZT_UPROC45_BASE_DEFAULT (0x0000)
+#define ZT_UPROC45_BASE_FMASK  (0xFFFFFFFF)
+#define ZT_UPROC67_BASE        FCI_GLBTX_REG(0x00F8)
+#define ZT_UPROC67_BASE_WMASK  (0xFFFFFFFF)
+#define ZT_UPROC67_BASE_MASK   (0xFFFFFFFF)
+#define ZT_UPROC67_BASE_DEFAULT (0x0000)
+#define ZT_UPROC67_BASE_FMASK  (0xFFFFFFFF)
+#define ZT_UPROC89_BASE        FCI_GLBTX_REG(0x00FC)
+#define ZT_UPROC89_BASE_WMASK  (0xFFFFFFFF)
+#define ZT_UPROC89_BASE_MASK   (0xFFFFFFFF)
+#define ZT_UPROC89_BASE_DEFAULT (0x0000)
+#define ZT_UPROC89_BASE_FMASK  (0xFFFFFFFF)
+#define ZT_UPROC_INT           FCI_GLBTX_REG(0x0100)
+#define ZT_UPROC_INT_WMASK     (0x03FF)
+#define ZT_UPROC_INT_MASK      (0x03FF)
+#define ZT_UPROC_INT_DEFAULT   (0x0000)
+#define ZT_UPROC_INT_FMASK     (0x03FF)
+#define ZT_UPROC0_STATE0       FCI_GLBTX_REG(0x0104)
+#define ZT_UPROC0_STATE0_WMASK (0xFFF1F00)
+#define ZT_UPROC0_STATE0_MASK  (0xFFF1FFF)
+#define ZT_UPROC0_STATE0_DEFAULT (0x0000)
+#define ZT_UPROC0_STATE0_FMASK (0xFFF1FFF)
+#define ZT_UPROC0_STATE1       FCI_GLBTX_REG(0x0108)
+#define ZT_UPROC0_STATE1_WMASK (0xFFFFFFFF)
+#define ZT_UPROC0_STATE1_MASK  (0xFFFFFFFF)
+#define ZT_UPROC0_STATE1_DEFAULT (0x0000)
+#define ZT_UPROC0_STATE1_FMASK (0xFFFFFFFF)
+#define ZT_UPROC0_STATE2       FCI_GLBTX_REG(0x010C)
+#define ZT_UPROC0_STATE2_WMASK (0x7FFFFFFF)
+#define ZT_UPROC0_STATE2_MASK  (0x7FFFFFFF)
+#define ZT_UPROC0_STATE2_DEFAULT (0x0000)
+#define ZT_UPROC0_STATE2_FMASK (0x7FFFFFFF)
+#define ZT_UPROC0_STATE3       FCI_GLBTX_REG(0x0110)
+#define ZT_UPROC0_STATE3_WMASK (0xFFFFFFFF)
+#define ZT_UPROC0_STATE3_MASK  (0xFFFFFFFF)
+#define ZT_UPROC0_STATE3_DEFAULT (0x0000)
+#define ZT_UPROC0_STATE3_FMASK (0xFFFFFFFF)
+#define ZT_UPROC0_STATE4       FCI_GLBTX_REG(0x0114)
+#define ZT_UPROC0_STATE4_WMASK (0xFFFFFFFF)
+#define ZT_UPROC0_STATE4_MASK  (0xFFFFFFFF)
+#define ZT_UPROC0_STATE4_DEFAULT (0x0000)
+#define ZT_UPROC0_STATE4_FMASK (0xFFFFFFFF)
+#define ZT_UPROC1_STATE0       FCI_GLBTX_REG(0x0118)
+#define ZT_UPROC1_STATE0_WMASK (0xFFF1F00)
+#define ZT_UPROC1_STATE0_MASK  (0xFFF1FFF)
+#define ZT_UPROC1_STATE0_DEFAULT (0x0000)
+#define ZT_UPROC1_STATE0_FMASK (0xFFF1FFF)
+#define ZT_UPROC1_STATE1       FCI_GLBTX_REG(0x011C)
+#define ZT_UPROC1_STATE1_WMASK (0xFFFFFFFF)
+#define ZT_UPROC1_STATE1_MASK  (0xFFFFFFFF)
+#define ZT_UPROC1_STATE1_DEFAULT (0x0000)
+#define ZT_UPROC1_STATE1_FMASK (0xFFFFFFFF)
+#define ZT_UPROC1_STATE2       FCI_GLBTX_REG(0x0120)
+#define ZT_UPROC1_STATE2_WMASK (0x7FFFFFFF)
+#define ZT_UPROC1_STATE2_MASK  (0x7FFFFFFF)
+#define ZT_UPROC1_STATE2_DEFAULT (0x0000)
+#define ZT_UPROC1_STATE2_FMASK (0x7FFFFFFF)
+#define ZT_UPROC1_STATE3       FCI_GLBTX_REG(0x0124)
+#define ZT_UPROC1_STATE3_WMASK (0xFFFFFFFF)
+#define ZT_UPROC1_STATE3_MASK  (0xFFFFFFFF)
+#define ZT_UPROC1_STATE3_DEFAULT (0x0000)
+#define ZT_UPROC1_STATE3_FMASK (0xFFFFFFFF)
+#define ZT_UPROC1_STATE4       FCI_GLBTX_REG(0x0128)
+#define ZT_UPROC1_STATE4_WMASK (0xFFFFFFFF)
+#define ZT_UPROC1_STATE4_MASK  (0xFFFFFFFF)
+#define ZT_UPROC1_STATE4_DEFAULT (0x0000)
+#define ZT_UPROC1_STATE4_FMASK (0xFFFFFFFF)
+#define ZT_UPROC2_STATE0       FCI_GLBTX_REG(0x012C)
+#define ZT_UPROC2_STATE0_WMASK (0xFFF1F00)
+#define ZT_UPROC2_STATE0_MASK  (0xFFF1FFF)
+#define ZT_UPROC2_STATE0_DEFAULT (0x0000)
+#define ZT_UPROC2_STATE0_FMASK (0xFFF1FFF)
+#define ZT_UPROC2_STATE1       FCI_GLBTX_REG(0x0130)
+#define ZT_UPROC2_STATE1_WMASK (0xFFFFFFFF)
+#define ZT_UPROC2_STATE1_MASK  (0xFFFFFFFF)
+#define ZT_UPROC2_STATE1_DEFAULT (0x0000)
+#define ZT_UPROC2_STATE1_FMASK (0xFFFFFFFF)
+#define ZT_UPROC2_STATE2       FCI_GLBTX_REG(0x0134)
+#define ZT_UPROC2_STATE2_WMASK (0x7FFFFFFF)
+#define ZT_UPROC2_STATE2_MASK  (0x7FFFFFFF)
+#define ZT_UPROC2_STATE2_DEFAULT (0x0000)
+#define ZT_UPROC2_STATE2_FMASK (0x7FFFFFFF)
+#define ZT_UPROC2_STATE3       FCI_GLBTX_REG(0x0138)
+#define ZT_UPROC2_STATE3_WMASK (0xFFFFFFFF)
+#define ZT_UPROC2_STATE3_MASK  (0xFFFFFFFF)
+#define ZT_UPROC2_STATE3_DEFAULT (0x0000)
+#define ZT_UPROC2_STATE3_FMASK (0xFFFFFFFF)
+#define ZT_UPROC2_STATE4       FCI_GLBTX_REG(0x013C)
+#define ZT_UPROC2_STATE4_WMASK (0xFFFFFFFF)
+#define ZT_UPROC2_STATE4_MASK  (0xFFFFFFFF)
+#define ZT_UPROC2_STATE4_DEFAULT (0x0000)
+#define ZT_UPROC2_STATE4_FMASK (0xFFFFFFFF)
+#define ZT_UPROC3_STATE0       FCI_GLBTX_REG(0x0140)
+#define ZT_UPROC3_STATE0_WMASK (0xFFF1F00)
+#define ZT_UPROC3_STATE0_MASK  (0xFFF1FFF)
+#define ZT_UPROC3_STATE0_DEFAULT (0x0000)
+#define ZT_UPROC3_STATE0_FMASK (0xFFF1FFF)
+#define ZT_UPROC3_STATE1       FCI_GLBTX_REG(0x0144)
+#define ZT_UPROC3_STATE1_WMASK (0xFFFFFFFF)
+#define ZT_UPROC3_STATE1_MASK  (0xFFFFFFFF)
+#define ZT_UPROC3_STATE1_DEFAULT (0x0000)
+#define ZT_UPROC3_STATE1_FMASK (0xFFFFFFFF)
+#define ZT_UPROC3_STATE2       FCI_GLBTX_REG(0x0148)
+#define ZT_UPROC3_STATE2_WMASK (0x7FFFFFFF)
+#define ZT_UPROC3_STATE2_MASK  (0x7FFFFFFF)
+#define ZT_UPROC3_STATE2_DEFAULT (0x0000)
+#define ZT_UPROC3_STATE2_FMASK (0x7FFFFFFF)
+#define ZT_UPROC3_STATE3       FCI_GLBTX_REG(0x014C)
+#define ZT_UPROC3_STATE3_WMASK (0xFFFFFFFF)
+#define ZT_UPROC3_STATE3_MASK  (0xFFFFFFFF)
+#define ZT_UPROC3_STATE3_DEFAULT (0x0000)
+#define ZT_UPROC3_STATE3_FMASK (0xFFFFFFFF)
+#define ZT_UPROC3_STATE4       FCI_GLBTX_REG(0x0150)
+#define ZT_UPROC3_STATE4_WMASK (0xFFFFFFFF)
+#define ZT_UPROC3_STATE4_MASK  (0xFFFFFFFF)
+#define ZT_UPROC3_STATE4_DEFAULT (0x0000)
+#define ZT_UPROC3_STATE4_FMASK (0xFFFFFFFF)
+#define ZT_UPROC4_STATE0       FCI_GLBTX_REG(0x0154)
+#define ZT_UPROC4_STATE0_WMASK (0xFFF1F00)
+#define ZT_UPROC4_STATE0_MASK  (0xFFF1FFF)
+#define ZT_UPROC4_STATE0_DEFAULT (0x0000)
+#define ZT_UPROC4_STATE0_FMASK (0xFFF1FFF)
+#define ZT_UPROC4_STATE1       FCI_GLBTX_REG(0x0158)
+#define ZT_UPROC4_STATE1_WMASK (0xFFFFFFFF)
+#define ZT_UPROC4_STATE1_MASK  (0xFFFFFFFF)
+#define ZT_UPROC4_STATE1_DEFAULT (0x0000)
+#define ZT_UPROC4_STATE1_FMASK (0xFFFFFFFF)
+#define ZT_UPROC4_STATE2       FCI_GLBTX_REG(0x015C)
+#define ZT_UPROC4_STATE2_WMASK (0x7FFFFFFF)
+#define ZT_UPROC4_STATE2_MASK  (0x7FFFFFFF)
+#define ZT_UPROC4_STATE2_DEFAULT (0x0000)
+#define ZT_UPROC4_STATE2_FMASK (0x7FFFFFFF)
+#define ZT_UPROC4_STATE3       FCI_GLBTX_REG(0x0160)
+#define ZT_UPROC4_STATE3_WMASK (0xFFFFFFFF)
+#define ZT_UPROC4_STATE3_MASK  (0xFFFFFFFF)
+#define ZT_UPROC4_STATE3_DEFAULT (0x0000)
+#define ZT_UPROC4_STATE3_FMASK (0xFFFFFFFF)
+#define ZT_UPROC4_STATE4       FCI_GLBTX_REG(0x0164)
+#define ZT_UPROC4_STATE4_WMASK (0xFFFFFFFF)
+#define ZT_UPROC4_STATE4_MASK  (0xFFFFFFFF)
+#define ZT_UPROC4_STATE4_DEFAULT (0x0000)
+#define ZT_UPROC4_STATE4_FMASK (0xFFFFFFFF)
+#define ZT_UPROC5_STATE0       FCI_GLBTX_REG(0x0168)
+#define ZT_UPROC5_STATE0_WMASK (0xFFF1F00)
+#define ZT_UPROC5_STATE0_MASK  (0xFFF1FFF)
+#define ZT_UPROC5_STATE0_DEFAULT (0x0000)
+#define ZT_UPROC5_STATE0_FMASK (0xFFF1FFF)
+#define ZT_UPROC5_STATE1       FCI_GLBTX_REG(0x016C)
+#define ZT_UPROC5_STATE1_WMASK (0xFFFFFFFF)
+#define ZT_UPROC5_STATE1_MASK  (0xFFFFFFFF)
+#define ZT_UPROC5_STATE1_DEFAULT (0x0000)
+#define ZT_UPROC5_STATE1_FMASK (0xFFFFFFFF)
+#define ZT_UPROC5_STATE2       FCI_GLBTX_REG(0x0170)
+#define ZT_UPROC5_STATE2_WMASK (0x7FFFFFFF)
+#define ZT_UPROC5_STATE2_MASK  (0x7FFFFFFF)
+#define ZT_UPROC5_STATE2_DEFAULT (0x0000)
+#define ZT_UPROC5_STATE2_FMASK (0x7FFFFFFF)
+#define ZT_UPROC5_STATE3       FCI_GLBTX_REG(0x0174)
+#define ZT_UPROC5_STATE3_WMASK (0xFFFFFFFF)
+#define ZT_UPROC5_STATE3_MASK  (0xFFFFFFFF)
+#define ZT_UPROC5_STATE3_DEFAULT (0x0000)
+#define ZT_UPROC5_STATE3_FMASK (0xFFFFFFFF)
+#define ZT_UPROC5_STATE4       FCI_GLBTX_REG(0x0178)
+#define ZT_UPROC5_STATE4_WMASK (0xFFFFFFFF)
+#define ZT_UPROC5_STATE4_MASK  (0xFFFFFFFF)
+#define ZT_UPROC5_STATE4_DEFAULT (0x0000)
+#define ZT_UPROC5_STATE4_FMASK (0xFFFFFFFF)
+#define ZT_UPROC6_STATE0       FCI_GLBTX_REG(0x017C)
+#define ZT_UPROC6_STATE0_WMASK (0xFFF1F00)
+#define ZT_UPROC6_STATE0_MASK  (0xFFF1FFF)
+#define ZT_UPROC6_STATE0_DEFAULT (0x0000)
+#define ZT_UPROC6_STATE0_FMASK (0xFFF1FFF)
+#define ZT_UPROC6_STATE1       FCI_GLBTX_REG(0x0180)
+#define ZT_UPROC6_STATE1_WMASK (0xFFFFFFFF)
+#define ZT_UPROC6_STATE1_MASK  (0xFFFFFFFF)
+#define ZT_UPROC6_STATE1_DEFAULT (0x0000)
+#define ZT_UPROC6_STATE1_FMASK (0xFFFFFFFF)
+#define ZT_UPROC6_STATE2       FCI_GLBTX_REG(0x0184)
+#define ZT_UPROC6_STATE2_WMASK (0x7FFFFFFF)
+#define ZT_UPROC6_STATE2_MASK  (0x7FFFFFFF)
+#define ZT_UPROC6_STATE2_DEFAULT (0x0000)
+#define ZT_UPROC6_STATE2_FMASK (0x7FFFFFFF)
+#define ZT_UPROC6_STATE3       FCI_GLBTX_REG(0x0188)
+#define ZT_UPROC6_STATE3_WMASK (0xFFFFFFFF)
+#define ZT_UPROC6_STATE3_MASK  (0xFFFFFFFF)
+#define ZT_UPROC6_STATE3_DEFAULT (0x0000)
+#define ZT_UPROC6_STATE3_FMASK (0xFFFFFFFF)
+#define ZT_UPROC6_STATE4       FCI_GLBTX_REG(0x018C)
+#define ZT_UPROC6_STATE4_WMASK (0xFFFFFFFF)
+#define ZT_UPROC6_STATE4_MASK  (0xFFFFFFFF)
+#define ZT_UPROC6_STATE4_DEFAULT (0x0000)
+#define ZT_UPROC6_STATE4_FMASK (0xFFFFFFFF)
+#define ZT_UPROC7_STATE0       FCI_GLBTX_REG(0x0190)
+#define ZT_UPROC7_STATE0_WMASK (0xFFF1F00)
+#define ZT_UPROC7_STATE0_MASK  (0xFFF1FFF)
+#define ZT_UPROC7_STATE0_DEFAULT (0x0000)
+#define ZT_UPROC7_STATE0_FMASK (0xFFF1FFF)
+#define ZT_UPROC7_STATE1       FCI_GLBTX_REG(0x0194)
+#define ZT_UPROC7_STATE1_WMASK (0xFFFFFFFF)
+#define ZT_UPROC7_STATE1_MASK  (0xFFFFFFFF)
+#define ZT_UPROC7_STATE1_DEFAULT (0x0000)
+#define ZT_UPROC7_STATE1_FMASK (0xFFFFFFFF)
+#define ZT_UPROC7_STATE2       FCI_GLBTX_REG(0x0198)
+#define ZT_UPROC7_STATE2_WMASK (0x7FFFFFFF)
+#define ZT_UPROC7_STATE2_MASK  (0x7FFFFFFF)
+#define ZT_UPROC7_STATE2_DEFAULT (0x0000)
+#define ZT_UPROC7_STATE2_FMASK (0x7FFFFFFF)
+#define ZT_UPROC7_STATE3       FCI_GLBTX_REG(0x019C)
+#define ZT_UPROC7_STATE3_WMASK (0xFFFFFFFF)
+#define ZT_UPROC7_STATE3_MASK  (0xFFFFFFFF)
+#define ZT_UPROC7_STATE3_DEFAULT (0x0000)
+#define ZT_UPROC7_STATE3_FMASK (0xFFFFFFFF)
+#define ZT_UPROC7_STATE4       FCI_GLBTX_REG(0x01A0)
+#define ZT_UPROC7_STATE4_WMASK (0xFFFFFFFF)
+#define ZT_UPROC7_STATE4_MASK  (0xFFFFFFFF)
+#define ZT_UPROC7_STATE4_DEFAULT (0x0000)
+#define ZT_UPROC7_STATE4_FMASK (0xFFFFFFFF)
+#define ZT_UPROC8_STATE0       FCI_GLBTX_REG(0x01A4)
+#define ZT_UPROC8_STATE0_WMASK (0xFFF1F00)
+#define ZT_UPROC8_STATE0_MASK  (0xFFF1FFF)
+#define ZT_UPROC8_STATE0_DEFAULT (0x0000)
+#define ZT_UPROC8_STATE0_FMASK (0xFFF1FFF)
+#define ZT_UPROC8_STATE1       FCI_GLBTX_REG(0x01A8)
+#define ZT_UPROC8_STATE1_WMASK (0xFFFFFFFF)
+#define ZT_UPROC8_STATE1_MASK  (0xFFFFFFFF)
+#define ZT_UPROC8_STATE1_DEFAULT (0x0000)
+#define ZT_UPROC8_STATE1_FMASK (0xFFFFFFFF)
+#define ZT_UPROC8_STATE2       FCI_GLBTX_REG(0x01AC)
+#define ZT_UPROC8_STATE2_WMASK (0x7FFFFFFF)
+#define ZT_UPROC8_STATE2_MASK  (0x7FFFFFFF)
+#define ZT_UPROC8_STATE2_DEFAULT (0x0000)
+#define ZT_UPROC8_STATE2_FMASK (0x7FFFFFFF)
+#define ZT_UPROC8_STATE3       FCI_GLBTX_REG(0x01B0)
+#define ZT_UPROC8_STATE3_WMASK (0xFFFFFFFF)
+#define ZT_UPROC8_STATE3_MASK  (0xFFFFFFFF)
+#define ZT_UPROC8_STATE3_DEFAULT (0x0000)
+#define ZT_UPROC8_STATE3_FMASK (0xFFFFFFFF)
+#define ZT_UPROC8_STATE4       FCI_GLBTX_REG(0x01B4)
+#define ZT_UPROC8_STATE4_WMASK (0xFFFFFFFF)
+#define ZT_UPROC8_STATE4_MASK  (0xFFFFFFFF)
+#define ZT_UPROC8_STATE4_DEFAULT (0x0000)
+#define ZT_UPROC8_STATE4_FMASK (0xFFFFFFFF)
+#define ZT_UPROC9_STATE0       FCI_GLBTX_REG(0x01B8)
+#define ZT_UPROC9_STATE0_WMASK (0xFFF1F00)
+#define ZT_UPROC9_STATE0_MASK  (0xFFF1FFF)
+#define ZT_UPROC9_STATE0_DEFAULT (0x0000)
+#define ZT_UPROC9_STATE0_FMASK (0xFFF1FFF)
+#define ZT_UPROC9_STATE1       FCI_GLBTX_REG(0x01BC)
+#define ZT_UPROC9_STATE1_WMASK (0xFFFFFFFF)
+#define ZT_UPROC9_STATE1_MASK  (0xFFFFFFFF)
+#define ZT_UPROC9_STATE1_DEFAULT (0x0000)
+#define ZT_UPROC9_STATE1_FMASK (0xFFFFFFFF)
+#define ZT_UPROC9_STATE2       FCI_GLBTX_REG(0x01C0)
+#define ZT_UPROC9_STATE2_WMASK (0x7FFFFFFF)
+#define ZT_UPROC9_STATE2_MASK  (0x7FFFFFFF)
+#define ZT_UPROC9_STATE2_DEFAULT (0x0000)
+#define ZT_UPROC9_STATE2_FMASK (0x7FFFFFFF)
+#define ZT_UPROC9_STATE3       FCI_GLBTX_REG(0x01C4)
+#define ZT_UPROC9_STATE3_WMASK (0xFFFFFFFF)
+#define ZT_UPROC9_STATE3_MASK  (0xFFFFFFFF)
+#define ZT_UPROC9_STATE3_DEFAULT (0x0000)
+#define ZT_UPROC9_STATE3_FMASK (0xFFFFFFFF)
+#define ZT_UPROC9_STATE4       FCI_GLBTX_REG(0x01C8)
+#define ZT_UPROC9_STATE4_WMASK (0xFFFFFFFF)
+#define ZT_UPROC9_STATE4_MASK  (0xFFFFFFFF)
+#define ZT_UPROC9_STATE4_DEFAULT (0x0000)
+#define ZT_UPROC9_STATE4_FMASK (0xFFFFFFFF)
+#define Z_VERSION              FCI_GLBTX_REG(0x01CC)
+#define Z_VERSION_WMASK        (0x0000)
+#define Z_VERSION_MASK         (0x00FF)
+#define Z_VERSION_DEFAULT      (0x0050)
+#define Z_VERSION_FMASK        (0x00FF)
+#define Z_MBOX_ACCESS          FCI_GLBTX_REG(0x01D0)
+#define Z_MBOX_ACCESS_WMASK    (0x0001)
+#define Z_MBOX_ACCESS_MASK     (0x0001)
+#define Z_MBOX_ACCESS_DEFAULT  (0x0000)
+#define Z_MBOX_ACCESS_FMASK    (0x0001)
+#define ZT_FIFO_ACCESS         FCI_GLBTX_REG(0x01D4)
+#define ZT_FIFO_ACCESS_WMASK   (0xBFFFF7FF)
+#define ZT_FIFO_ACCESS_MASK    (0xBFFFFFFF)
+#define ZT_FIFO_ACCESS_DEFAULT (0x0800)
+#define ZT_FIFO_ACCESS_FMASK   (0xBFFFFFFF)
+#define ZT_CONFIG              FCI_GLBTX_REG(0x01D8)
+#define ZT_CONFIG_WMASK        (0xFFFF)
+#define ZT_CONFIG_MASK         (0xFFFF)
+#define ZT_CONFIG_DEFAULT      (0x0000)
+#define ZT_CONFIG_FMASK        (0xFFFF)
+#define ZT_PMS_SIZE            FCI_GLBTX_REG(0x01DC)
+#define ZT_PMS_SIZE_WMASK      (0xFFFFFFFF)
+#define ZT_PMS_SIZE_MASK       (0xFFFFFFFF)
+#define ZT_PMS_SIZE_DEFAULT    (0x0000)
+#define ZT_PMS_SIZE_FMASK      (0xFFFFFFFF)
+#define ZT_DT_SIZE             FCI_GLBTX_REG(0x01E0)
+#define ZT_DT_SIZE_WMASK       (0xFFFFFFFF)
+#define ZT_DT_SIZE_MASK        (0xFFFFFFFF)
+#define ZT_DT_SIZE_DEFAULT     (0x0000)
+#define ZT_DT_SIZE_FMASK       (0xFFFFFFFF)
+#define ZT_QTDTB_CONFIG_LP0    FCI_GLBTX_REG(0x01E4)
+#define ZT_QTDTB_CONFIG_LP0_WMASK (0xCFFF0FFF)
+#define ZT_QTDTB_CONFIG_LP0_MASK (0xCFFF0FFF)
+#define ZT_QTDTB_CONFIG_LP0_DEFAULT (0x0000)
+#define ZT_QTDTB_CONFIG_LP0_FMASK (0xCFFF0FFF)
+#define ZT_QTDTB_CONFIG_LP1    FCI_GLBTX_REG(0x01E8)
+#define ZT_QTDTB_CONFIG_LP1_WMASK (0xCFFF0FFF)
+#define ZT_QTDTB_CONFIG_LP1_MASK (0xCFFF0FFF)
+#define ZT_QTDTB_CONFIG_LP1_DEFAULT (0x0000)
+#define ZT_QTDTB_CONFIG_LP1_FMASK (0xCFFF0FFF)
+#define ZT_QTDTB_CONFIG_LP2    FCI_GLBTX_REG(0x01EC)
+#define ZT_QTDTB_CONFIG_LP2_WMASK (0xFFF0FFF)
+#define ZT_QTDTB_CONFIG_LP2_MASK (0xFFF0FFF)
+#define ZT_QTDTB_CONFIG_LP2_DEFAULT (0x0000)
+#define ZT_QTDTB_CONFIG_LP2_FMASK (0xFFF0FFF)
+#define ZT_QTDTB_ADDR_LP01     FCI_GLBTX_REG(0x01F0)
+#define ZT_QTDTB_ADDR_LP01_WMASK (0xFFF0FFF)
+#define ZT_QTDTB_ADDR_LP01_MASK (0xFFF0FFF)
+#define ZT_QTDTB_ADDR_LP01_DEFAULT (0x0000)
+#define ZT_QTDTB_ADDR_LP01_FMASK (0xFFF0FFF)
+#define ZT_QTDTB_ADDR_LP2      FCI_GLBTX_REG(0x01F4)
+#define ZT_QTDTB_ADDR_LP2_WMASK (0x0FFF)
+#define ZT_QTDTB_ADDR_LP2_MASK (0x0FFF)
+#define ZT_QTDTB_ADDR_LP2_DEFAULT (0x0000)
+#define ZT_QTDTB_ADDR_LP2_FMASK (0x0FFF)
+#define ZT_DTB_OFFSET          FCI_GLBTX_REG(0x01F8)
+#define ZT_DTB_OFFSET_WMASK    (0x0FFF)
+#define ZT_DTB_OFFSET_MASK     (0x0FFF)
+#define ZT_DTB_OFFSET_DEFAULT  (0x0000)
+#define ZT_DTB_OFFSET_FMASK    (0x0FFF)
+#define ZT_STAT_CTRL           FCI_GLBTX_REG(0x01FC)
+#define ZT_STAT_CTRL_WMASK     (0x0101)
+#define ZT_STAT_CTRL_MASK      (0x0101)
+#define ZT_STAT_CTRL_DEFAULT   (0x0000)
+#define ZT_STAT_CTRL_FMASK     (0x0100)
+
+/* Fci Glbrx Address Constants */
+#define fci_glbrx_reg_base     (0x20DC00)
+#define FCI_GLBRX_REG(r)       (int)(fci_glbrx_reg_base + (r))
+#define fci_glbrx_reg_size     (0x0001)
+
+#define ZR_R0                  FCI_GLBRX_REG(0x0000)
+#define ZR_R0_WMASK            (0xFFFFFFFF)
+#define ZR_R0_MASK             (0xFFFFFFFF)
+#define ZR_R0_DEFAULT          (0x0000)
+#define ZR_R0_FMASK            (0xFFFFFFFF)
+#define ZR_R4                  FCI_GLBRX_REG(0x0004)
+#define ZR_R4_WMASK            (0xFFFFFFFF)
+#define ZR_R4_MASK             (0xFFFFFFFF)
+#define ZR_R4_DEFAULT          (0x0000)
+#define ZR_R4_FMASK            (0xFFFFFFFF)
+#define ZR_R8                  FCI_GLBRX_REG(0x0008)
+#define ZR_R8_WMASK            (0xFFFFFFFF)
+#define ZR_R8_MASK             (0xFFFFFFFF)
+#define ZR_R8_DEFAULT          (0x0000)
+#define ZR_R8_FMASK            (0xFFFFFFFF)
+#define ZR_R12                 FCI_GLBRX_REG(0x000C)
+#define ZR_R12_WMASK           (0xFFFFFFFF)
+#define ZR_R12_MASK            (0xFFFFFFFF)
+#define ZR_R12_DEFAULT         (0x0000)
+#define ZR_R12_FMASK           (0xFFFFFFFF)
+#define ZR_CODEWORD            FCI_GLBRX_REG(0x0010)
+#define ZR_CODEWORD_WMASK      (0xFFFFFFFF)
+#define ZR_CODEWORD_MASK       (0xFFFFFFFF)
+#define ZR_CODEWORD_DEFAULT    (0x0000)
+#define ZR_CODEWORD_FMASK      (0xFFFFFFFF)
+#define ZR_VBC_SIZE            FCI_GLBRX_REG(0x0014)
+#define ZR_VBC_SIZE_WMASK      (0xFFFFFFFF)
+#define ZR_VBC_SIZE_MASK       (0xFFFFFFFF)
+#define ZR_VBC_SIZE_DEFAULT    (0x0000)
+#define ZR_VBC_SIZE_FMASK      (0xFFFFFFFF)
+#define ZR_FRAMING             FCI_GLBRX_REG(0x0018)
+#define ZR_FRAMING_WMASK       (0xFFFFFFFF)
+#define ZR_FRAMING_MASK        (0xFFFFFFFF)
+#define ZR_FRAMING_DEFAULT     (0x0000)
+#define ZR_FRAMING_FMASK       (0xFFFFFFFF)
+#define ZR_OHRATE              FCI_GLBRX_REG(0x001C)
+#define ZR_OHRATE_WMASK        (0xFFFFFFFF)
+#define ZR_OHRATE_MASK         (0xFFFFFFFF)
+#define ZR_OHRATE_DEFAULT      (0x0000)
+#define ZR_OHRATE_FMASK        (0xFFFFFFFF)
+#define ZR_FLAG_CTRL0          FCI_GLBRX_REG(0x0020)
+#define ZR_FLAG_CTRL0_WMASK    (0x77777777)
+#define ZR_FLAG_CTRL0_MASK     (0x77777777)
+#define ZR_FLAG_CTRL0_DEFAULT  (0x0000)
+#define ZR_FLAG_CTRL0_FMASK    (0x77777777)
+#define ZR_FLAG_CTRL1          FCI_GLBRX_REG(0x0024)
+#define ZR_FLAG_CTRL1_WMASK    (0x7777777)
+#define ZR_FLAG_CTRL1_MASK     (0x7777777)
+#define ZR_FLAG_CTRL1_DEFAULT  (0x0000)
+#define ZR_FLAG_CTRL1_FMASK    (0x7777777)
+#define ZR_CRC0                FCI_GLBRX_REG(0x0028)
+#define ZR_CRC0_WMASK          (0xFFFFFFFF)
+#define ZR_CRC0_MASK           (0xFFFFFFFF)
+#define ZR_CRC0_DEFAULT        (0x0000)
+#define ZR_CRC0_FMASK          (0xFFFFFFFF)
+#define ZR_CRC_POLY0           FCI_GLBRX_REG(0x002C)
+#define ZR_CRC_POLY0_WMASK     (0xFFFFFFFF)
+#define ZR_CRC_POLY0_MASK      (0xFFFFFFFF)
+#define ZR_CRC_POLY0_DEFAULT   (0x0000)
+#define ZR_CRC_POLY0_FMASK     (0xFFFFFFFF)
+#define ZR_CRC_CTRL0           FCI_GLBRX_REG(0x0030)
+#define ZR_CRC_CTRL0_WMASK     (0xFFFF0003)
+#define ZR_CRC_CTRL0_MASK      (0xFFFF0003)
+#define ZR_CRC_CTRL0_DEFAULT   (0x0000)
+#define ZR_CRC_CTRL0_FMASK     (0xFFFF0003)
+#define ZR_CRC1                FCI_GLBRX_REG(0x0034)
+#define ZR_CRC1_WMASK          (0xFFFFFFFF)
+#define ZR_CRC1_MASK           (0xFFFFFFFF)
+#define ZR_CRC1_DEFAULT        (0x0000)
+#define ZR_CRC1_FMASK          (0xFFFFFFFF)
+#define ZR_CRC_POLY1           FCI_GLBRX_REG(0x0038)
+#define ZR_CRC_POLY1_WMASK     (0xFFFFFFFF)
+#define ZR_CRC_POLY1_MASK      (0xFFFFFFFF)
+#define ZR_CRC_POLY1_DEFAULT   (0x0000)
+#define ZR_CRC_POLY1_FMASK     (0xFFFFFFFF)
+#define ZR_CRC_CTRL1           FCI_GLBRX_REG(0x003C)
+#define ZR_CRC_CTRL1_WMASK     (0xFFFF0003)
+#define ZR_CRC_CTRL1_MASK      (0xFFFF0003)
+#define ZR_CRC_CTRL1_DEFAULT   (0x0000)
+#define ZR_CRC_CTRL1_FMASK     (0xFFFF0003)
+#define ZR_SCR                 FCI_GLBRX_REG(0x0040)
+#define ZR_SCR_WMASK           (0xFFFFFFFF)
+#define ZR_SCR_MASK            (0xFFFFFFFF)
+#define ZR_SCR_DEFAULT         (0x0000)
+#define ZR_SCR_FMASK           (0xFFFFFFFF)
+#define ZR_SCR_POLY            FCI_GLBRX_REG(0x0044)
+#define ZR_SCR_POLY_WMASK      (0xFFFFFFFF)
+#define ZR_SCR_POLY_MASK       (0xFFFFFFFF)
+#define ZR_SCR_POLY_DEFAULT    (0x0000)
+#define ZR_SCR_POLY_FMASK      (0xFFFFFFFF)
+#define ZR_SCR_CTRL            FCI_GLBRX_REG(0x0048)
+#define ZR_SCR_CTRL_WMASK      (0x001F)
+#define ZR_SCR_CTRL_MASK       (0x001F)
+#define ZR_SCR_CTRL_DEFAULT    (0x0000)
+#define ZR_SCR_CTRL_FMASK      (0x001F)
+#define ZR_SCR_STATE           FCI_GLBRX_REG(0x004C)
+#define ZR_SCR_STATE_WMASK     (0x3FFFFFF)
+#define ZR_SCR_STATE_MASK      (0x3FFFFFF)
+#define ZR_SCR_STATE_DEFAULT   (0x0000)
+#define ZR_SCR_STATE_FMASK     (0x3FFFFFF)
+#define ZR_DTB_CTRL            FCI_GLBRX_REG(0x0050)
+#define ZR_DTB_CTRL_WMASK      (0x1FFF0FFF)
+#define ZR_DTB_CTRL_MASK       (0x1FFF0FFF)
+#define ZR_DTB_CTRL_DEFAULT    (0x0000)
+#define ZR_DTB_CTRL_FMASK      (0x1FFF0FFF)
+#define ZR_DTB_PTRS            FCI_GLBRX_REG(0x0054)
+#define ZR_DTB_PTRS_WMASK      (0xFFFFFFFF)
+#define ZR_DTB_PTRS_MASK       (0xFFFFFFFF)
+#define ZR_DTB_PTRS_DEFAULT    (0x0000)
+#define ZR_DTB_PTRS_FMASK      (0xFFFFFFFF)
+#define ZR_ILVB_WRAD           FCI_GLBRX_REG(0x0058)
+#define ZR_ILVB_WRAD_WMASK     (0xFFFFFFFF)
+#define ZR_ILVB_WRAD_MASK      (0xFFFFFFFF)
+#define ZR_ILVB_WRAD_DEFAULT   (0x0000)
+#define ZR_ILVB_WRAD_FMASK     (0xFFFFFFFF)
+#define ZR_ILVB_RDAD           FCI_GLBRX_REG(0x005C)
+#define ZR_ILVB_RDAD_WMASK     (0xFFFFFFFF)
+#define ZR_ILVB_RDAD_MASK      (0xFFFFFFFF)
+#define ZR_ILVB_RDAD_DEFAULT   (0x0000)
+#define ZR_ILVB_RDAD_FMASK     (0xFFFFFFFF)
+#define ZR_ILVB_WRPTR          FCI_GLBRX_REG(0x0060)
+#define ZR_ILVB_WRPTR_WMASK    (0xFFFFFFFF)
+#define ZR_ILVB_WRPTR_MASK     (0xFFFFFFFF)
+#define ZR_ILVB_WRPTR_DEFAULT  (0x0000)
+#define ZR_ILVB_WRPTR_FMASK    (0xFFFFFFFF)
+#define ZR_ILVB_RDPTR          FCI_GLBRX_REG(0x0064)
+#define ZR_ILVB_RDPTR_WMASK    (0xFFFFFFFF)
+#define ZR_ILVB_RDPTR_MASK     (0xFFFFFFFF)
+#define ZR_ILVB_RDPTR_DEFAULT  (0x0000)
+#define ZR_ILVB_RDPTR_FMASK    (0xFFFFFFFF)
+#define ZR_FIFO_BASE0          FCI_GLBRX_REG(0x0068)
+#define ZR_FIFO_BASE0_WMASK    (0x3FFFFFF)
+#define ZR_FIFO_BASE0_MASK     (0x3FFFFFF)
+#define ZR_FIFO_BASE0_DEFAULT  (0x0000)
+#define ZR_FIFO_BASE0_FMASK    (0x3FFFFFF)
+#define ZR_FIFO_PTRS0          FCI_GLBRX_REG(0x006C)
+#define ZR_FIFO_PTRS0_WMASK    (0xC0FF00FF)
+#define ZR_FIFO_PTRS0_MASK     (0xC0FF00FF)
+#define ZR_FIFO_PTRS0_DEFAULT  (0x0000)
+#define ZR_FIFO_PTRS0_FMASK    (0xC0FF00FF)
+#define ZR_FIFO_CNST0          FCI_GLBRX_REG(0x0070)
+#define ZR_FIFO_CNST0_WMASK    (0xFFFFFF)
+#define ZR_FIFO_CNST0_MASK     (0xFFFFFF)
+#define ZR_FIFO_CNST0_DEFAULT  (0x0000)
+#define ZR_FIFO_CNST0_FMASK    (0xFFFFFF)
+#define ZR_FIFO_BASE1          FCI_GLBRX_REG(0x0074)
+#define ZR_FIFO_BASE1_WMASK    (0x3FFFFFF)
+#define ZR_FIFO_BASE1_MASK     (0x3FFFFFF)
+#define ZR_FIFO_BASE1_DEFAULT  (0x0000)
+#define ZR_FIFO_BASE1_FMASK    (0x3FFFFFF)
+#define ZR_FIFO_PTRS1          FCI_GLBRX_REG(0x0078)
+#define ZR_FIFO_PTRS1_WMASK    (0xC0FF00FF)
+#define ZR_FIFO_PTRS1_MASK     (0xC0FF00FF)
+#define ZR_FIFO_PTRS1_DEFAULT  (0x0000)
+#define ZR_FIFO_PTRS1_FMASK    (0xC0FF00FF)
+#define ZR_FIFO_CNST1          FCI_GLBRX_REG(0x007C)
+#define ZR_FIFO_CNST1_WMASK    (0xFFFFFF)
+#define ZR_FIFO_CNST1_MASK     (0xFFFFFF)
+#define ZR_FIFO_CNST1_DEFAULT  (0x0000)
+#define ZR_FIFO_CNST1_FMASK    (0xFFFFFF)
+#define ZR_FIFO_BASE2          FCI_GLBRX_REG(0x0080)
+#define ZR_FIFO_BASE2_WMASK    (0x3FFFFFF)
+#define ZR_FIFO_BASE2_MASK     (0x3FFFFFF)
+#define ZR_FIFO_BASE2_DEFAULT  (0x0000)
+#define ZR_FIFO_BASE2_FMASK    (0x3FFFFFF)
+#define ZR_FIFO_PTRS2          FCI_GLBRX_REG(0x0084)
+#define ZR_FIFO_PTRS2_WMASK    (0xC0FF00FF)
+#define ZR_FIFO_PTRS2_MASK     (0xC0FF00FF)
+#define ZR_FIFO_PTRS2_DEFAULT  (0x0000)
+#define ZR_FIFO_PTRS2_FMASK    (0xC0FF00FF)
+#define ZR_FIFO_CNST2          FCI_GLBRX_REG(0x0088)
+#define ZR_FIFO_CNST2_WMASK    (0xFFFFFF)
+#define ZR_FIFO_CNST2_MASK     (0xFFFFFF)
+#define ZR_FIFO_CNST2_DEFAULT  (0x0000)
+#define ZR_FIFO_CNST2_FMASK    (0xFFFFFF)
+#define ZR_FIFO_BASE3          FCI_GLBRX_REG(0x008C)
+#define ZR_FIFO_BASE3_WMASK    (0x3FFFFFFF)
+#define ZR_FIFO_BASE3_MASK     (0x3FFFFFFF)
+#define ZR_FIFO_BASE3_DEFAULT  (0x0000)
+#define ZR_FIFO_BASE3_FMASK    (0x3FFFFFFF)
+#define ZR_FIFO_PTRS3          FCI_GLBRX_REG(0x0090)
+#define ZR_FIFO_PTRS3_WMASK    (0xCFFF0FFF)
+#define ZR_FIFO_PTRS3_MASK     (0xCFFF0FFF)
+#define ZR_FIFO_PTRS3_DEFAULT  (0x0000)
+#define ZR_FIFO_PTRS3_FMASK    (0xCFFF0FFF)
+#define ZR_FIFO_CNST3          FCI_GLBRX_REG(0x0094)
+#define ZR_FIFO_CNST3_WMASK    (0x1FFFFFF)
+#define ZR_FIFO_CNST3_MASK     (0x1FFFFFF)
+#define ZR_FIFO_CNST3_DEFAULT  (0x0000)
+#define ZR_FIFO_CNST3_FMASK    (0x1FFFFFF)
+#define ZR_DEPTH               FCI_GLBRX_REG(0x0098)
+#define ZR_DEPTH_WMASK         (0xFFFFFFFF)
+#define ZR_DEPTH_MASK          (0xFFFFFFFF)
+#define ZR_DEPTH_DEFAULT       (0x0000)
+#define ZR_DEPTH_FMASK         (0xFFFFFFFF)
+#define ZR_ILV_PARAMS0         FCI_GLBRX_REG(0x009C)
+#define ZR_ILV_PARAMS0_WMASK   (0xFFFFFF07)
+#define ZR_ILV_PARAMS0_MASK    (0xFFFFFF07)
+#define ZR_ILV_PARAMS0_DEFAULT (0x0000)
+#define ZR_ILV_PARAMS0_FMASK   (0xFFFFFF07)
+#define ZR_ILV_BASE0           FCI_GLBRX_REG(0x00A0)
+#define ZR_ILV_BASE0_WMASK     (0x3FFFF)
+#define ZR_ILV_BASE0_MASK      (0x3FFFF)
+#define ZR_ILV_BASE0_DEFAULT   (0x0000)
+#define ZR_ILV_BASE0_FMASK     (0x3FFFF)
+#define ZR_ILV_SIZE0           FCI_GLBRX_REG(0x00A4)
+#define ZR_ILV_SIZE0_WMASK     (0xFFFFFF)
+#define ZR_ILV_SIZE0_MASK      (0xFFFFFF)
+#define ZR_ILV_SIZE0_DEFAULT   (0x0000)
+#define ZR_ILV_SIZE0_FMASK     (0xFFFFFF)
+#define ZR_ILV_FULLNESS0       FCI_GLBRX_REG(0x00A8)
+#define ZR_ILV_FULLNESS0_WMASK (0xFFFFFFFF)
+#define ZR_ILV_FULLNESS0_MASK  (0xFFFFFFFF)
+#define ZR_ILV_FULLNESS0_DEFAULT (0x0000)
+#define ZR_ILV_FULLNESS0_FMASK (0xFFFFFFFF)
+#define ZR_ILV_CNTRS0          FCI_GLBRX_REG(0x00AC)
+#define ZR_ILV_CNTRS0_WMASK    (0xFFFFFFFF)
+#define ZR_ILV_CNTRS0_MASK     (0xFFFFFFFF)
+#define ZR_ILV_CNTRS0_DEFAULT  (0x0000)
+#define ZR_ILV_CNTRS0_FMASK    (0xFFFFFFFF)
+#define ZR_ILV_PMS_CNTRS0      FCI_GLBRX_REG(0x00B0)
+#define ZR_ILV_PMS_CNTRS0_WMASK (0xFFFFFFFF)
+#define ZR_ILV_PMS_CNTRS0_MASK (0xFFFFFFFF)
+#define ZR_ILV_PMS_CNTRS0_DEFAULT (0x0000)
+#define ZR_ILV_PMS_CNTRS0_FMASK (0xFFFFFFFF)
+#define ZR_ILV_PMD_CNTRS0      FCI_GLBRX_REG(0x00B4)
+#define ZR_ILV_PMD_CNTRS0_WMASK (0xFFFFFFFF)
+#define ZR_ILV_PMD_CNTRS0_MASK (0xFFFFFFFF)
+#define ZR_ILV_PMD_CNTRS0_DEFAULT (0x0000)
+#define ZR_ILV_PMD_CNTRS0_FMASK (0xFFFFFFFF)
+#define ZR_ILV_PARAMS1         FCI_GLBRX_REG(0x00B8)
+#define ZR_ILV_PARAMS1_WMASK   (0xFFFFFF07)
+#define ZR_ILV_PARAMS1_MASK    (0xFFFFFF07)
+#define ZR_ILV_PARAMS1_DEFAULT (0x0000)
+#define ZR_ILV_PARAMS1_FMASK   (0xFFFFFF07)
+#define ZR_ILV_BASE1           FCI_GLBRX_REG(0x00BC)
+#define ZR_ILV_BASE1_WMASK     (0x3FFFF)
+#define ZR_ILV_BASE1_MASK      (0x3FFFF)
+#define ZR_ILV_BASE1_DEFAULT   (0x0000)
+#define ZR_ILV_BASE1_FMASK     (0x3FFFF)
+#define ZR_ILV_SIZE1           FCI_GLBRX_REG(0x00C0)
+#define ZR_ILV_SIZE1_WMASK     (0xFFFFFF)
+#define ZR_ILV_SIZE1_MASK      (0xFFFFFF)
+#define ZR_ILV_SIZE1_DEFAULT   (0x0000)
+#define ZR_ILV_SIZE1_FMASK     (0xFFFFFF)
+#define ZR_ILV_FULLNESS1       FCI_GLBRX_REG(0x00C4)
+#define ZR_ILV_FULLNESS1_WMASK (0xFFFFFFFF)
+#define ZR_ILV_FULLNESS1_MASK  (0xFFFFFFFF)
+#define ZR_ILV_FULLNESS1_DEFAULT (0x0000)
+#define ZR_ILV_FULLNESS1_FMASK (0xFFFFFFFF)
+#define ZR_ILV_CNTRS1          FCI_GLBRX_REG(0x00C8)
+#define ZR_ILV_CNTRS1_WMASK    (0xFFFFFFFF)
+#define ZR_ILV_CNTRS1_MASK     (0xFFFFFFFF)
+#define ZR_ILV_CNTRS1_DEFAULT  (0x0000)
+#define ZR_ILV_CNTRS1_FMASK    (0xFFFFFFFF)
+#define ZR_ILV_PMS_CNTRS1      FCI_GLBRX_REG(0x00CC)
+#define ZR_ILV_PMS_CNTRS1_WMASK (0xFFFFFFFF)
+#define ZR_ILV_PMS_CNTRS1_MASK (0xFFFFFFFF)
+#define ZR_ILV_PMS_CNTRS1_DEFAULT (0x0000)
+#define ZR_ILV_PMS_CNTRS1_FMASK (0xFFFFFFFF)
+#define ZR_ILV_PMD_CNTRS1      FCI_GLBRX_REG(0x00D0)
+#define ZR_ILV_PMD_CNTRS1_WMASK (0xFFFFFFFF)
+#define ZR_ILV_PMD_CNTRS1_MASK (0xFFFFFFFF)
+#define ZR_ILV_PMD_CNTRS1_DEFAULT (0x0000)
+#define ZR_ILV_PMD_CNTRS1_FMASK (0xFFFFFFFF)
+#define ZIR_DL_REL0            FCI_GLBRX_REG(0x00D4)
+#define ZIR_DL_REL0_WMASK      (0x3FFFFFF)
+#define ZIR_DL_REL0_MASK       (0x3FFFFFF)
+#define ZIR_DL_REL0_DEFAULT    (0x0000)
+#define ZIR_DL_REL0_FMASK      (0x3FFFFFF)
+#define ZIR_NL_REL0            FCI_GLBRX_REG(0x00D8)
+#define ZIR_NL_REL0_WMASK      (0x3FF07FF)
+#define ZIR_NL_REL0_MASK       (0x3FF07FF)
+#define ZIR_NL_REL0_DEFAULT    (0x0000)
+#define ZIR_NL_REL0_FMASK      (0x3FF07FF)
+#define ZIR_DMETRIC0           FCI_GLBRX_REG(0x00DC)
+#define ZIR_DMETRIC0_WMASK     (0x3FFFFFF)
+#define ZIR_DMETRIC0_MASK      (0x3FFFFFF)
+#define ZIR_DMETRIC0_DEFAULT   (0x0000)
+#define ZIR_DMETRIC0_FMASK     (0x3FFFFFF)
+#define ZIR_DMETRIC_CTRL       FCI_GLBRX_REG(0x00E0)
+#define ZIR_DMETRIC_CTRL_WMASK (0xFF1300FF)
+#define ZIR_DMETRIC_CTRL_MASK  (0xFF1300FF)
+#define ZIR_DMETRIC_CTRL_DEFAULT (0x0000)
+#define ZIR_DMETRIC_CTRL_FMASK (0xFF1300FF)
+#define ZIR_LPBITS             FCI_GLBRX_REG(0x00E4)
+#define ZIR_LPBITS_WMASK       (0xFFFF)
+#define ZIR_LPBITS_MASK        (0xFFFF)
+#define ZIR_LPBITS_DEFAULT     (0x0000)
+#define ZIR_LPBITS_FMASK       (0xFFFF)
+#define ZR_CW_COUNT            FCI_GLBRX_REG(0x00E8)
+#define ZR_CW_COUNT_WMASK      (0xFFFF)
+#define ZR_CW_COUNT_MASK       (0xFFFF)
+#define ZR_CW_COUNT_DEFAULT    (0x0000)
+#define ZR_CW_COUNT_FMASK      (0xFFFF)
+#define ZR_FEC_CNT             FCI_GLBRX_REG(0x00EC)
+#define ZR_FEC_CNT_WMASK       (0xFFFFFFFF)
+#define ZR_FEC_CNT_MASK        (0xFFFFFFFF)
+#define ZR_FEC_CNT_DEFAULT     (0x0000)
+#define ZR_FEC_CNT_FMASK       (0xFFFFFFFF)
+#define ZR_UNCORR_CW0          FCI_GLBRX_REG(0x00F0)
+#define ZR_UNCORR_CW0_WMASK    (0xFFFFFFFF)
+#define ZR_UNCORR_CW0_MASK     (0xFFFFFFFF)
+#define ZR_UNCORR_CW0_DEFAULT  (0x0000)
+#define ZR_UNCORR_CW0_FMASK    (0xFFFFFFFF)
+#define ZR_UNCORR_CW1          FCI_GLBRX_REG(0x00F4)
+#define ZR_UNCORR_CW1_WMASK    (0xFFFFFFFF)
+#define ZR_UNCORR_CW1_MASK     (0xFFFFFFFF)
+#define ZR_UNCORR_CW1_DEFAULT  (0x0000)
+#define ZR_UNCORR_CW1_FMASK    (0xFFFFFFFF)
+#define ZR_WB_SCORE_CTL        FCI_GLBRX_REG(0x00F8)
+#define ZR_WB_SCORE_CTL_WMASK  (0xBF3F5FFF)
+#define ZR_WB_SCORE_CTL_MASK   (0xBF3F5FFF)
+#define ZR_WB_SCORE_CTL_DEFAULT (0x0000)
+#define ZR_WB_SCORE_CTL_FMASK  (0xBF3F5FFF)
+#define ZR_WB_SCORE2           FCI_GLBRX_REG(0x00FC)
+#define ZR_WB_SCORE2_WMASK     (0xFFFF)
+#define ZR_WB_SCORE2_MASK      (0xFFFF)
+#define ZR_WB_SCORE2_DEFAULT   (0x0000)
+#define ZR_WB_SCORE2_FMASK     (0xFFFF)
+#define ZR_UPROC_ENA           FCI_GLBRX_REG(0x0100)
+#define ZR_UPROC_ENA_WMASK     (0x03FF)
+#define ZR_UPROC_ENA_MASK      (0x03FF)
+#define ZR_UPROC_ENA_DEFAULT   (0x0000)
+#define ZR_UPROC_ENA_FMASK     (0x03FF)
+#define ZR_UPROC01_BASE        FCI_GLBRX_REG(0x0104)
+#define ZR_UPROC01_BASE_WMASK  (0xFFFFFFFF)
+#define ZR_UPROC01_BASE_MASK   (0xFFFFFFFF)
+#define ZR_UPROC01_BASE_DEFAULT (0x0000)
+#define ZR_UPROC01_BASE_FMASK  (0xFFFFFFFF)
+#define ZR_UPROC23_BASE        FCI_GLBRX_REG(0x0108)
+#define ZR_UPROC23_BASE_WMASK  (0xFFFFFFFF)
+#define ZR_UPROC23_BASE_MASK   (0xFFFFFFFF)
+#define ZR_UPROC23_BASE_DEFAULT (0x0000)
+#define ZR_UPROC23_BASE_FMASK  (0xFFFFFFFF)
+#define ZR_UPROC45_BASE        FCI_GLBRX_REG(0x010C)
+#define ZR_UPROC45_BASE_WMASK  (0xFFFFFFFF)
+#define ZR_UPROC45_BASE_MASK   (0xFFFFFFFF)
+#define ZR_UPROC45_BASE_DEFAULT (0x0000)
+#define ZR_UPROC45_BASE_FMASK  (0xFFFFFFFF)
+#define ZR_UPROC67_BASE        FCI_GLBRX_REG(0x0110)
+#define ZR_UPROC67_BASE_WMASK  (0xFFFFFFFF)
+#define ZR_UPROC67_BASE_MASK   (0xFFFFFFFF)
+#define ZR_UPROC67_BASE_DEFAULT (0x0000)
+#define ZR_UPROC67_BASE_FMASK  (0xFFFFFFFF)
+#define ZR_UPROC89_BASE        FCI_GLBRX_REG(0x0114)
+#define ZR_UPROC89_BASE_WMASK  (0xFFFFFFFF)
+#define ZR_UPROC89_BASE_MASK   (0xFFFFFFFF)
+#define ZR_UPROC89_BASE_DEFAULT (0x0000)
+#define ZR_UPROC89_BASE_FMASK  (0xFFFFFFFF)
+#define ZR_UPROC_INT           FCI_GLBRX_REG(0x0118)
+#define ZR_UPROC_INT_WMASK     (0x03FF)
+#define ZR_UPROC_INT_MASK      (0x03FF)
+#define ZR_UPROC_INT_DEFAULT   (0x0000)
+#define ZR_UPROC_INT_FMASK     (0x03FF)
+#define ZR_UPROC0_STATE0       FCI_GLBRX_REG(0x011C)
+#define ZR_UPROC0_STATE0_WMASK (0xFFF1F00)
+#define ZR_UPROC0_STATE0_MASK  (0xFFF1FFF)
+#define ZR_UPROC0_STATE0_DEFAULT (0x0000)
+#define ZR_UPROC0_STATE0_FMASK (0xFFF1FFF)
+#define ZR_UPROC0_STATE1       FCI_GLBRX_REG(0x0120)
+#define ZR_UPROC0_STATE1_WMASK (0xFFFFFFFF)
+#define ZR_UPROC0_STATE1_MASK  (0xFFFFFFFF)
+#define ZR_UPROC0_STATE1_DEFAULT (0x0000)
+#define ZR_UPROC0_STATE1_FMASK (0xFFFFFFFF)
+#define ZR_UPROC0_STATE2       FCI_GLBRX_REG(0x0124)
+#define ZR_UPROC0_STATE2_WMASK (0x7FFFFFFF)
+#define ZR_UPROC0_STATE2_MASK  (0x7FFFFFFF)
+#define ZR_UPROC0_STATE2_DEFAULT (0x0000)
+#define ZR_UPROC0_STATE2_FMASK (0x7FFFFFFF)
+#define ZR_UPROC0_STATE3       FCI_GLBRX_REG(0x0128)
+#define ZR_UPROC0_STATE3_WMASK (0xFFFFFFFF)
+#define ZR_UPROC0_STATE3_MASK  (0xFFFFFFFF)
+#define ZR_UPROC0_STATE3_DEFAULT (0x0000)
+#define ZR_UPROC0_STATE3_FMASK (0xFFFFFFFF)
+#define ZR_UPROC0_STATE4       FCI_GLBRX_REG(0x012C)
+#define ZR_UPROC0_STATE4_WMASK (0xFFFFFFFF)
+#define ZR_UPROC0_STATE4_MASK  (0xFFFFFFFF)
+#define ZR_UPROC0_STATE4_DEFAULT (0x0000)
+#define ZR_UPROC0_STATE4_FMASK (0xFFFFFFFF)
+#define ZR_UPROC1_STATE0       FCI_GLBRX_REG(0x0130)
+#define ZR_UPROC1_STATE0_WMASK (0xFFF1F00)
+#define ZR_UPROC1_STATE0_MASK  (0xFFF1FFF)
+#define ZR_UPROC1_STATE0_DEFAULT (0x0000)
+#define ZR_UPROC1_STATE0_FMASK (0xFFF1FFF)
+#define ZR_UPROC1_STATE1       FCI_GLBRX_REG(0x0134)
+#define ZR_UPROC1_STATE1_WMASK (0xFFFFFFFF)
+#define ZR_UPROC1_STATE1_MASK  (0xFFFFFFFF)
+#define ZR_UPROC1_STATE1_DEFAULT (0x0000)
+#define ZR_UPROC1_STATE1_FMASK (0xFFFFFFFF)
+#define ZR_UPROC1_STATE2       FCI_GLBRX_REG(0x0138)
+#define ZR_UPROC1_STATE2_WMASK (0x7FFFFFFF)
+#define ZR_UPROC1_STATE2_MASK  (0x7FFFFFFF)
+#define ZR_UPROC1_STATE2_DEFAULT (0x0000)
+#define ZR_UPROC1_STATE2_FMASK (0x7FFFFFFF)
+#define ZR_UPROC1_STATE3       FCI_GLBRX_REG(0x013C)
+#define ZR_UPROC1_STATE3_WMASK (0xFFFFFFFF)
+#define ZR_UPROC1_STATE3_MASK  (0xFFFFFFFF)
+#define ZR_UPROC1_STATE3_DEFAULT (0x0000)
+#define ZR_UPROC1_STATE3_FMASK (0xFFFFFFFF)
+#define ZR_UPROC1_STATE4       FCI_GLBRX_REG(0x0140)
+#define ZR_UPROC1_STATE4_WMASK (0xFFFFFFFF)
+#define ZR_UPROC1_STATE4_MASK  (0xFFFFFFFF)
+#define ZR_UPROC1_STATE4_DEFAULT (0x0000)
+#define ZR_UPROC1_STATE4_FMASK (0xFFFFFFFF)
+#define ZR_UPROC2_STATE0       FCI_GLBRX_REG(0x0144)
+#define ZR_UPROC2_STATE0_WMASK (0xFFF1F00)
+#define ZR_UPROC2_STATE0_MASK  (0xFFF1FFF)
+#define ZR_UPROC2_STATE0_DEFAULT (0x0000)
+#define ZR_UPROC2_STATE0_FMASK (0xFFF1FFF)
+#define ZR_UPROC2_STATE1       FCI_GLBRX_REG(0x0148)
+#define ZR_UPROC2_STATE1_WMASK (0xFFFFFFFF)
+#define ZR_UPROC2_STATE1_MASK  (0xFFFFFFFF)
+#define ZR_UPROC2_STATE1_DEFAULT (0x0000)
+#define ZR_UPROC2_STATE1_FMASK (0xFFFFFFFF)
+#define ZR_UPROC2_STATE2       FCI_GLBRX_REG(0x014C)
+#define ZR_UPROC2_STATE2_WMASK (0x7FFFFFFF)
+#define ZR_UPROC2_STATE2_MASK  (0x7FFFFFFF)
+#define ZR_UPROC2_STATE2_DEFAULT (0x0000)
+#define ZR_UPROC2_STATE2_FMASK (0x7FFFFFFF)
+#define ZR_UPROC2_STATE3       FCI_GLBRX_REG(0x0150)
+#define ZR_UPROC2_STATE3_WMASK (0xFFFFFFFF)
+#define ZR_UPROC2_STATE3_MASK  (0xFFFFFFFF)
+#define ZR_UPROC2_STATE3_DEFAULT (0x0000)
+#define ZR_UPROC2_STATE3_FMASK (0xFFFFFFFF)
+#define ZR_UPROC2_STATE4       FCI_GLBRX_REG(0x0154)
+#define ZR_UPROC2_STATE4_WMASK (0xFFFFFFFF)
+#define ZR_UPROC2_STATE4_MASK  (0xFFFFFFFF)
+#define ZR_UPROC2_STATE4_DEFAULT (0x0000)
+#define ZR_UPROC2_STATE4_FMASK (0xFFFFFFFF)
+#define ZR_UPROC3_STATE0       FCI_GLBRX_REG(0x0158)
+#define ZR_UPROC3_STATE0_WMASK (0xFFF1F00)
+#define ZR_UPROC3_STATE0_MASK  (0xFFF1FFF)
+#define ZR_UPROC3_STATE0_DEFAULT (0x0000)
+#define ZR_UPROC3_STATE0_FMASK (0xFFF1FFF)
+#define ZR_UPROC3_STATE1       FCI_GLBRX_REG(0x015C)
+#define ZR_UPROC3_STATE1_WMASK (0xFFFFFFFF)
+#define ZR_UPROC3_STATE1_MASK  (0xFFFFFFFF)
+#define ZR_UPROC3_STATE1_DEFAULT (0x0000)
+#define ZR_UPROC3_STATE1_FMASK (0xFFFFFFFF)
+#define ZR_UPROC3_STATE2       FCI_GLBRX_REG(0x0160)
+#define ZR_UPROC3_STATE2_WMASK (0x7FFFFFFF)
+#define ZR_UPROC3_STATE2_MASK  (0x7FFFFFFF)
+#define ZR_UPROC3_STATE2_DEFAULT (0x0000)
+#define ZR_UPROC3_STATE2_FMASK (0x7FFFFFFF)
+#define ZR_UPROC3_STATE3       FCI_GLBRX_REG(0x0164)
+#define ZR_UPROC3_STATE3_WMASK (0xFFFFFFFF)
+#define ZR_UPROC3_STATE3_MASK  (0xFFFFFFFF)
+#define ZR_UPROC3_STATE3_DEFAULT (0x0000)
+#define ZR_UPROC3_STATE3_FMASK (0xFFFFFFFF)
+#define ZR_UPROC3_STATE4       FCI_GLBRX_REG(0x0168)
+#define ZR_UPROC3_STATE4_WMASK (0xFFFFFFFF)
+#define ZR_UPROC3_STATE4_MASK  (0xFFFFFFFF)
+#define ZR_UPROC3_STATE4_DEFAULT (0x0000)
+#define ZR_UPROC3_STATE4_FMASK (0xFFFFFFFF)
+#define ZR_UPROC4_STATE0       FCI_GLBRX_REG(0x016C)
+#define ZR_UPROC4_STATE0_WMASK (0xFFF1F00)
+#define ZR_UPROC4_STATE0_MASK  (0xFFF1FFF)
+#define ZR_UPROC4_STATE0_DEFAULT (0x0000)
+#define ZR_UPROC4_STATE0_FMASK (0xFFF1FFF)
+#define ZR_UPROC4_STATE1       FCI_GLBRX_REG(0x0170)
+#define ZR_UPROC4_STATE1_WMASK (0xFFFFFFFF)
+#define ZR_UPROC4_STATE1_MASK  (0xFFFFFFFF)
+#define ZR_UPROC4_STATE1_DEFAULT (0x0000)
+#define ZR_UPROC4_STATE1_FMASK (0xFFFFFFFF)
+#define ZR_UPROC4_STATE2       FCI_GLBRX_REG(0x0174)
+#define ZR_UPROC4_STATE2_WMASK (0x7FFFFFFF)
+#define ZR_UPROC4_STATE2_MASK  (0x7FFFFFFF)
+#define ZR_UPROC4_STATE2_DEFAULT (0x0000)
+#define ZR_UPROC4_STATE2_FMASK (0x7FFFFFFF)
+#define ZR_UPROC4_STATE3       FCI_GLBRX_REG(0x0178)
+#define ZR_UPROC4_STATE3_WMASK (0xFFFFFFFF)
+#define ZR_UPROC4_STATE3_MASK  (0xFFFFFFFF)
+#define ZR_UPROC4_STATE3_DEFAULT (0x0000)
+#define ZR_UPROC4_STATE3_FMASK (0xFFFFFFFF)
+#define ZR_UPROC4_STATE4       FCI_GLBRX_REG(0x017C)
+#define ZR_UPROC4_STATE4_WMASK (0xFFFFFFFF)
+#define ZR_UPROC4_STATE4_MASK  (0xFFFFFFFF)
+#define ZR_UPROC4_STATE4_DEFAULT (0x0000)
+#define ZR_UPROC4_STATE4_FMASK (0xFFFFFFFF)
+#define ZR_UPROC5_STATE0       FCI_GLBRX_REG(0x0180)
+#define ZR_UPROC5_STATE0_WMASK (0xFFF1F00)
+#define ZR_UPROC5_STATE0_MASK  (0xFFF1FFF)
+#define ZR_UPROC5_STATE0_DEFAULT (0x0000)
+#define ZR_UPROC5_STATE0_FMASK (0xFFF1FFF)
+#define ZR_UPROC5_STATE1       FCI_GLBRX_REG(0x0184)
+#define ZR_UPROC5_STATE1_WMASK (0xFFFFFFFF)
+#define ZR_UPROC5_STATE1_MASK  (0xFFFFFFFF)
+#define ZR_UPROC5_STATE1_DEFAULT (0x0000)
+#define ZR_UPROC5_STATE1_FMASK (0xFFFFFFFF)
+#define ZR_UPROC5_STATE2       FCI_GLBRX_REG(0x0188)
+#define ZR_UPROC5_STATE2_WMASK (0x7FFFFFFF)
+#define ZR_UPROC5_STATE2_MASK  (0x7FFFFFFF)
+#define ZR_UPROC5_STATE2_DEFAULT (0x0000)
+#define ZR_UPROC5_STATE2_FMASK (0x7FFFFFFF)
+#define ZR_UPROC5_STATE3       FCI_GLBRX_REG(0x018C)
+#define ZR_UPROC5_STATE3_WMASK (0xFFFFFFFF)
+#define ZR_UPROC5_STATE3_MASK  (0xFFFFFFFF)
+#define ZR_UPROC5_STATE3_DEFAULT (0x0000)
+#define ZR_UPROC5_STATE3_FMASK (0xFFFFFFFF)
+#define ZR_UPROC5_STATE4       FCI_GLBRX_REG(0x0190)
+#define ZR_UPROC5_STATE4_WMASK (0xFFFFFFFF)
+#define ZR_UPROC5_STATE4_MASK  (0xFFFFFFFF)
+#define ZR_UPROC5_STATE4_DEFAULT (0x0000)
+#define ZR_UPROC5_STATE4_FMASK (0xFFFFFFFF)
+#define ZR_UPROC6_STATE0       FCI_GLBRX_REG(0x0194)
+#define ZR_UPROC6_STATE0_WMASK (0xFFF1F00)
+#define ZR_UPROC6_STATE0_MASK  (0xFFF1FFF)
+#define ZR_UPROC6_STATE0_DEFAULT (0x0000)
+#define ZR_UPROC6_STATE0_FMASK (0xFFF1FFF)
+#define ZR_UPROC6_STATE1       FCI_GLBRX_REG(0x0198)
+#define ZR_UPROC6_STATE1_WMASK (0xFFFFFFFF)
+#define ZR_UPROC6_STATE1_MASK  (0xFFFFFFFF)
+#define ZR_UPROC6_STATE1_DEFAULT (0x0000)
+#define ZR_UPROC6_STATE1_FMASK (0xFFFFFFFF)
+#define ZR_UPROC6_STATE2       FCI_GLBRX_REG(0x019C)
+#define ZR_UPROC6_STATE2_WMASK (0x7FFFFFFF)
+#define ZR_UPROC6_STATE2_MASK  (0x7FFFFFFF)
+#define ZR_UPROC6_STATE2_DEFAULT (0x0000)
+#define ZR_UPROC6_STATE2_FMASK (0x7FFFFFFF)
+#define ZR_UPROC6_STATE3       FCI_GLBRX_REG(0x01A0)
+#define ZR_UPROC6_STATE3_WMASK (0xFFFFFFFF)
+#define ZR_UPROC6_STATE3_MASK  (0xFFFFFFFF)
+#define ZR_UPROC6_STATE3_DEFAULT (0x0000)
+#define ZR_UPROC6_STATE3_FMASK (0xFFFFFFFF)
+#define ZR_UPROC6_STATE4       FCI_GLBRX_REG(0x01A4)
+#define ZR_UPROC6_STATE4_WMASK (0xFFFFFFFF)
+#define ZR_UPROC6_STATE4_MASK  (0xFFFFFFFF)
+#define ZR_UPROC6_STATE4_DEFAULT (0x0000)
+#define ZR_UPROC6_STATE4_FMASK (0xFFFFFFFF)
+#define ZR_UPROC7_STATE0       FCI_GLBRX_REG(0x01A8)
+#define ZR_UPROC7_STATE0_WMASK (0xFFF1F00)
+#define ZR_UPROC7_STATE0_MASK  (0xFFF1FFF)
+#define ZR_UPROC7_STATE0_DEFAULT (0x0000)
+#define ZR_UPROC7_STATE0_FMASK (0xFFF1FFF)
+#define ZR_UPROC7_STATE1       FCI_GLBRX_REG(0x01AC)
+#define ZR_UPROC7_STATE1_WMASK (0xFFFFFFFF)
+#define ZR_UPROC7_STATE1_MASK  (0xFFFFFFFF)
+#define ZR_UPROC7_STATE1_DEFAULT (0x0000)
+#define ZR_UPROC7_STATE1_FMASK (0xFFFFFFFF)
+#define ZR_UPROC7_STATE2       FCI_GLBRX_REG(0x01B0)
+#define ZR_UPROC7_STATE2_WMASK (0x7FFFFFFF)
+#define ZR_UPROC7_STATE2_MASK  (0x7FFFFFFF)
+#define ZR_UPROC7_STATE2_DEFAULT (0x0000)
+#define ZR_UPROC7_STATE2_FMASK (0x7FFFFFFF)
+#define ZR_UPROC7_STATE3       FCI_GLBRX_REG(0x01B4)
+#define ZR_UPROC7_STATE3_WMASK (0xFFFFFFFF)
+#define ZR_UPROC7_STATE3_MASK  (0xFFFFFFFF)
+#define ZR_UPROC7_STATE3_DEFAULT (0x0000)
+#define ZR_UPROC7_STATE3_FMASK (0xFFFFFFFF)
+#define ZR_UPROC7_STATE4       FCI_GLBRX_REG(0x01B8)
+#define ZR_UPROC7_STATE4_WMASK (0xFFFFFFFF)
+#define ZR_UPROC7_STATE4_MASK  (0xFFFFFFFF)
+#define ZR_UPROC7_STATE4_DEFAULT (0x0000)
+#define ZR_UPROC7_STATE4_FMASK (0xFFFFFFFF)
+#define ZR_UPROC8_STATE0       FCI_GLBRX_REG(0x01BC)
+#define ZR_UPROC8_STATE0_WMASK (0xFFF1F00)
+#define ZR_UPROC8_STATE0_MASK  (0xFFF1FFF)
+#define ZR_UPROC8_STATE0_DEFAULT (0x0000)
+#define ZR_UPROC8_STATE0_FMASK (0xFFF1FFF)
+#define ZR_UPROC8_STATE1       FCI_GLBRX_REG(0x01C0)
+#define ZR_UPROC8_STATE1_WMASK (0xFFFFFFFF)
+#define ZR_UPROC8_STATE1_MASK  (0xFFFFFFFF)
+#define ZR_UPROC8_STATE1_DEFAULT (0x0000)
+#define ZR_UPROC8_STATE1_FMASK (0xFFFFFFFF)
+#define ZR_UPROC8_STATE2       FCI_GLBRX_REG(0x01C4)
+#define ZR_UPROC8_STATE2_WMASK (0x7FFFFFFF)
+#define ZR_UPROC8_STATE2_MASK  (0x7FFFFFFF)
+#define ZR_UPROC8_STATE2_DEFAULT (0x0000)
+#define ZR_UPROC8_STATE2_FMASK (0x7FFFFFFF)
+#define ZR_UPROC8_STATE3       FCI_GLBRX_REG(0x01C8)
+#define ZR_UPROC8_STATE3_WMASK (0xFFFFFFFF)
+#define ZR_UPROC8_STATE3_MASK  (0xFFFFFFFF)
+#define ZR_UPROC8_STATE3_DEFAULT (0x0000)
+#define ZR_UPROC8_STATE3_FMASK (0xFFFFFFFF)
+#define ZR_UPROC8_STATE4       FCI_GLBRX_REG(0x01CC)
+#define ZR_UPROC8_STATE4_WMASK (0xFFFFFFFF)
+#define ZR_UPROC8_STATE4_MASK  (0xFFFFFFFF)
+#define ZR_UPROC8_STATE4_DEFAULT (0x0000)
+#define ZR_UPROC8_STATE4_FMASK (0xFFFFFFFF)
+#define ZR_UPROC9_STATE0       FCI_GLBRX_REG(0x01D0)
+#define ZR_UPROC9_STATE0_WMASK (0xFFF1F00)
+#define ZR_UPROC9_STATE0_MASK  (0xFFF1FFF)
+#define ZR_UPROC9_STATE0_DEFAULT (0x0000)
+#define ZR_UPROC9_STATE0_FMASK (0xFFF1FFF)
+#define ZR_UPROC9_STATE1       FCI_GLBRX_REG(0x01D4)
+#define ZR_UPROC9_STATE1_WMASK (0xFFFFFFFF)
+#define ZR_UPROC9_STATE1_MASK  (0xFFFFFFFF)
+#define ZR_UPROC9_STATE1_DEFAULT (0x0000)
+#define ZR_UPROC9_STATE1_FMASK (0xFFFFFFFF)
+#define ZR_UPROC9_STATE2       FCI_GLBRX_REG(0x01D8)
+#define ZR_UPROC9_STATE2_WMASK (0x7FFFFFFF)
+#define ZR_UPROC9_STATE2_MASK  (0x7FFFFFFF)
+#define ZR_UPROC9_STATE2_DEFAULT (0x0000)
+#define ZR_UPROC9_STATE2_FMASK (0x7FFFFFFF)
+#define ZR_UPROC9_STATE3       FCI_GLBRX_REG(0x01DC)
+#define ZR_UPROC9_STATE3_WMASK (0xFFFFFFFF)
+#define ZR_UPROC9_STATE3_MASK  (0xFFFFFFFF)
+#define ZR_UPROC9_STATE3_DEFAULT (0x0000)
+#define ZR_UPROC9_STATE3_FMASK (0xFFFFFFFF)
+#define ZR_UPROC9_STATE4       FCI_GLBRX_REG(0x01E0)
+#define ZR_UPROC9_STATE4_WMASK (0xFFFFFFFF)
+#define ZR_UPROC9_STATE4_MASK  (0xFFFFFFFF)
+#define ZR_UPROC9_STATE4_DEFAULT (0x0000)
+#define ZR_UPROC9_STATE4_FMASK (0xFFFFFFFF)
+#define ZR_WB_DBG              FCI_GLBRX_REG(0x01E4)
+#define ZR_WB_DBG_WMASK        (0x0000)
+#define ZR_WB_DBG_MASK         (0x01FF)
+#define ZR_WB_DBG_DEFAULT      (0x0000)
+#define ZR_WB_DBG_FMASK        (0x01FF)
+#define ZR_WB_RCHK0            FCI_GLBRX_REG(0x01E8)
+#define ZR_WB_RCHK0_WMASK      (0x0000)
+#define ZR_WB_RCHK0_MASK       (0xFFFFFFFF)
+#define ZR_WB_RCHK0_DEFAULT    (0x0000)
+#define ZR_WB_RCHK0_FMASK      (0xFFFFFFFF)
+#define ZR_WB_RCHK1            FCI_GLBRX_REG(0x01EC)
+#define ZR_WB_RCHK1_WMASK      (0x0000)
+#define ZR_WB_RCHK1_MASK       (0xFFFFFFFF)
+#define ZR_WB_RCHK1_DEFAULT    (0x0000)
+#define ZR_WB_RCHK1_FMASK      (0xFFFFFFFF)
+#define ZR_WB_RCHK2            FCI_GLBRX_REG(0x01F0)
+#define ZR_WB_RCHK2_WMASK      (0x0000)
+#define ZR_WB_RCHK2_MASK       (0xFFFFFFFF)
+#define ZR_WB_RCHK2_DEFAULT    (0x0000)
+#define ZR_WB_RCHK2_FMASK      (0xFFFFFFFF)
+#define ZR_WB_RCHK3            FCI_GLBRX_REG(0x01F4)
+#define ZR_WB_RCHK3_WMASK      (0x0000)
+#define ZR_WB_RCHK3_MASK       (0xFFFFFFFF)
+#define ZR_WB_RCHK3_DEFAULT    (0x0000)
+#define ZR_WB_RCHK3_FMASK      (0xFFFFFFFF)
+#define ZR_WB_RSYND0           FCI_GLBRX_REG(0x01F8)
+#define ZR_WB_RSYND0_WMASK     (0x0000)
+#define ZR_WB_RSYND0_MASK      (0xFFFFFFFF)
+#define ZR_WB_RSYND0_DEFAULT   (0x0000)
+#define ZR_WB_RSYND0_FMASK     (0xFFFFFFFF)
+#define ZR_WB_RSYND1           FCI_GLBRX_REG(0x01FC)
+#define ZR_WB_RSYND1_WMASK     (0x0000)
+#define ZR_WB_RSYND1_MASK      (0xFFFFFFFF)
+#define ZR_WB_RSYND1_DEFAULT   (0x0000)
+#define ZR_WB_RSYND1_FMASK     (0xFFFFFFFF)
+#define ZR_WB_RSYND2           FCI_GLBRX_REG(0x0200)
+#define ZR_WB_RSYND2_WMASK     (0x0000)
+#define ZR_WB_RSYND2_MASK      (0xFFFFFFFF)
+#define ZR_WB_RSYND2_DEFAULT   (0x0000)
+#define ZR_WB_RSYND2_FMASK     (0xFFFFFFFF)
+#define ZR_WB_RSYND3           FCI_GLBRX_REG(0x0204)
+#define ZR_WB_RSYND3_WMASK     (0x0000)
+#define ZR_WB_RSYND3_MASK      (0xFFFFFFFF)
+#define ZR_WB_RSYND3_DEFAULT   (0x0000)
+#define ZR_WB_RSYND3_FMASK     (0xFFFFFFFF)
+#define ZR_WB_AJ0              FCI_GLBRX_REG(0x0208)
+#define ZR_WB_AJ0_WMASK        (0x0000)
+#define ZR_WB_AJ0_MASK         (0xFFFFFFFF)
+#define ZR_WB_AJ0_DEFAULT      (0x0000)
+#define ZR_WB_AJ0_FMASK        (0xFFFFFFFF)
+#define ZR_WB_AJ1              FCI_GLBRX_REG(0x020C)
+#define ZR_WB_AJ1_WMASK        (0x0000)
+#define ZR_WB_AJ1_MASK         (0xFFFFFFFF)
+#define ZR_WB_AJ1_DEFAULT      (0x0000)
+#define ZR_WB_AJ1_FMASK        (0xFFFFFFFF)
+#define ZR_WB_AJ2              FCI_GLBRX_REG(0x0210)
+#define ZR_WB_AJ2_WMASK        (0x0000)
+#define ZR_WB_AJ2_MASK         (0xFFFFFFFF)
+#define ZR_WB_AJ2_DEFAULT      (0x0000)
+#define ZR_WB_AJ2_FMASK        (0xFFFFFFFF)
+#define ZR_WB_AJ3              FCI_GLBRX_REG(0x0214)
+#define ZR_WB_AJ3_WMASK        (0x0000)
+#define ZR_WB_AJ3_MASK         (0xFFFFFFFF)
+#define ZR_WB_AJ3_DEFAULT      (0x0000)
+#define ZR_WB_AJ3_FMASK        (0xFFFFFFFF)
+#define ZR_FIFO_ACCESS         FCI_GLBRX_REG(0x0218)
+#define ZR_FIFO_ACCESS_WMASK   (0xBFFFF7FF)
+#define ZR_FIFO_ACCESS_MASK    (0xBFFFFFFF)
+#define ZR_FIFO_ACCESS_DEFAULT (0x0800)
+#define ZR_FIFO_ACCESS_FMASK   (0xBFFFFFFF)
+#define ZR_CONFIG              FCI_GLBRX_REG(0x021C)
+#define ZR_CONFIG_WMASK        (0xFFFF)
+#define ZR_CONFIG_MASK         (0xFFFF)
+#define ZR_CONFIG_DEFAULT      (0x0000)
+#define ZR_CONFIG_FMASK        (0xFFFF)
+#define ZR_PMS_SIZE            FCI_GLBRX_REG(0x0220)
+#define ZR_PMS_SIZE_WMASK      (0xFFFFFFFF)
+#define ZR_PMS_SIZE_MASK       (0xFFFFFFFF)
+#define ZR_PMS_SIZE_DEFAULT    (0x0000)
+#define ZR_PMS_SIZE_FMASK      (0xFFFFFFFF)
+#define ZR_DT_SIZE             FCI_GLBRX_REG(0x0224)
+#define ZR_DT_SIZE_WMASK       (0xFFFFFFFF)
+#define ZR_DT_SIZE_MASK        (0xFFFFFFFF)
+#define ZR_DT_SIZE_DEFAULT     (0x0000)
+#define ZR_DT_SIZE_FMASK       (0xFFFFFFFF)
+#define ZR_QTDTB_CONFIG_LP0    FCI_GLBRX_REG(0x0228)
+#define ZR_QTDTB_CONFIG_LP0_WMASK (0xCFFF0FFF)
+#define ZR_QTDTB_CONFIG_LP0_MASK (0xCFFF0FFF)
+#define ZR_QTDTB_CONFIG_LP0_DEFAULT (0x0000)
+#define ZR_QTDTB_CONFIG_LP0_FMASK (0xCFFF0FFF)
+#define ZR_QTDTB_CONFIG_LP1    FCI_GLBRX_REG(0x022C)
+#define ZR_QTDTB_CONFIG_LP1_WMASK (0xCFFF0FFF)
+#define ZR_QTDTB_CONFIG_LP1_MASK (0xCFFF0FFF)
+#define ZR_QTDTB_CONFIG_LP1_DEFAULT (0x0000)
+#define ZR_QTDTB_CONFIG_LP1_FMASK (0xCFFF0FFF)
+#define ZR_QTDTB_CONFIG_LP2    FCI_GLBRX_REG(0x0230)
+#define ZR_QTDTB_CONFIG_LP2_WMASK (0xFFF0FFF)
+#define ZR_QTDTB_CONFIG_LP2_MASK (0xFFF0FFF)
+#define ZR_QTDTB_CONFIG_LP2_DEFAULT (0x0000)
+#define ZR_QTDTB_CONFIG_LP2_FMASK (0xFFF0FFF)
+#define ZR_QTDTB_ADDR_LP01     FCI_GLBRX_REG(0x0234)
+#define ZR_QTDTB_ADDR_LP01_WMASK (0xFFF0FFF)
+#define ZR_QTDTB_ADDR_LP01_MASK (0xFFF0FFF)
+#define ZR_QTDTB_ADDR_LP01_DEFAULT (0x0000)
+#define ZR_QTDTB_ADDR_LP01_FMASK (0xFFF0FFF)
+#define ZR_QTDTB_ADDR_LP2      FCI_GLBRX_REG(0x0238)
+#define ZR_QTDTB_ADDR_LP2_WMASK (0x0FFF)
+#define ZR_QTDTB_ADDR_LP2_MASK (0x0FFF)
+#define ZR_QTDTB_ADDR_LP2_DEFAULT (0x0000)
+#define ZR_QTDTB_ADDR_LP2_FMASK (0x0FFF)
+#define ZR_DTB_OFFSET          FCI_GLBRX_REG(0x023C)
+#define ZR_DTB_OFFSET_WMASK    (0x0FFF)
+#define ZR_DTB_OFFSET_MASK     (0x0FFF)
+#define ZR_DTB_OFFSET_DEFAULT  (0x0000)
+#define ZR_DTB_OFFSET_FMASK    (0x0FFF)
+#define ZR_QTSCORE             FCI_GLBRX_REG(0x0240)
+#define ZR_QTSCORE_WMASK       (0x3FF00FF)
+#define ZR_QTSCORE_MASK        (0x3FF00FF)
+#define ZR_QTSCORE_DEFAULT     (0x0000)
+#define ZR_QTSCORE_FMASK       (0x3FF00FF)
+#define ZR_STAT_CTRL           FCI_GLBRX_REG(0x0244)
+#define ZR_STAT_CTRL_WMASK     (0x0101)
+#define ZR_STAT_CTRL_MASK      (0x0101)
+#define ZR_STAT_CTRL_DEFAULT   (0x0000)
+#define ZR_STAT_CTRL_FMASK     (0x0100)
+
+/* Ft Memory Address Constants */
+
+/* Ft Global Address Constants */
+#define ft_global_base         (0x20C800)
+#define FT_GLOBAL(r)           (int)(ft_global_base + (r))
+#define ft_global_size         (0x0200)
+
+#define FT_RX_CTRL             FT_GLOBAL(0x0000)
+#define FT_RX_CTRL_WMASK       (0x0003)
+#define FT_RX_CTRL_MASK        (0x0003)
+#define FT_RX_CTRL_DEFAULT     (0x0000)
+#define FT_RX_CTRL_FMASK       (0x0003)
+#define FT_RX_CTRL_A           FT_GLOBAL(0x0004)
+#define FT_RX_CTRL_A_WMASK     (0x0003)
+#define FT_RX_CTRL_A_MASK      (0x001F)
+#define FT_RX_CTRL_A_DEFAULT   (0x0000)
+#define FT_RX_CTRL_A_FMASK     (0x0003)
+#define FT_TX_CTRL             FT_GLOBAL(0x0008)
+#define FT_TX_CTRL_WMASK       (0x0003)
+#define FT_TX_CTRL_MASK        (0x003B)
+#define FT_TX_CTRL_DEFAULT     (0x0010)
+#define FT_TX_CTRL_FMASK       (0x0003)
+#define FT_TX_CTRL_A           FT_GLOBAL(0x000C)
+#define FT_TX_CTRL_A_WMASK     (0x0003)
+#define FT_TX_CTRL_A_MASK      (0x003B)
+#define FT_TX_CTRL_A_DEFAULT   (0x0010)
+#define FT_TX_CTRL_A_FMASK     (0x0003)
+#define FT_STATUS              FT_GLOBAL(0x0010)
+#define FT_STATUS_WMASK        (0x000A)
+#define FT_STATUS_MASK         (0x000F)
+#define FT_STATUS_DEFAULT      (0x0000)
+#define FT_STATUS_FMASK        (0x0005)
+#define FT_RX_SCALE            FT_GLOBAL(0x0014)
+#define FT_RX_SCALE_WMASK      (0x3FFF)
+#define FT_RX_SCALE_MASK       (0x3FFF)
+#define FT_RX_SCALE_DEFAULT    (0x0000)
+#define FT_RX_SCALE_FMASK      (0x3FFF)
+#define FT_TX_SCALE            FT_GLOBAL(0x0018)
+#define FT_TX_SCALE_WMASK      (0x3FFF)
+#define FT_TX_SCALE_MASK       (0x3FFF)
+#define FT_TX_SCALE_DEFAULT    (0x0000)
+#define FT_TX_SCALE_FMASK      (0x3FFF)
+
+/* Ftb Memory Address Constants */
+#define ftb_iffta_base         (0x210000)
+#define ftb_iffta_mask         (0xFFFFFFFF)
+#define ftb_iffta_size         (0x4000)
+#define ftb_iffta_default      (0x0000)
+#define ftb_ifftb_base         (0x214000)
+#define ftb_ifftb_mask         (0xFFFFFFFF)
+#define ftb_ifftb_size         (0x4000)
+#define ftb_ifftb_default      (0x0000)
+#define ftb_ifftc_base         (0x218000)
+#define ftb_ifftc_mask         (0xFFFFFFFF)
+#define ftb_ifftc_size         (0x4000)
+#define ftb_ifftc_default      (0x0000)
+#define ftb_ffta_base          (0x21C000)
+#define ftb_ffta_mask          (0xFFFFFFFF)
+#define ftb_ffta_size          (0x4000)
+#define ftb_ffta_default       (0x0000)
+#define ftb_fftb_base          (0x220000)
+#define ftb_fftb_mask          (0xFFFFFFFF)
+#define ftb_fftb_size          (0x4000)
+#define ftb_fftb_default       (0x0000)
+#define ftb_fftc_base          (0x224000)
+#define ftb_fftc_mask          (0xFFFFFFFF)
+#define ftb_fftc_size          (0x4000)
+#define ftb_fftc_default       (0x0000)
+
+/* Ftb Global Address Constants */
+#define ftb_global_base        (0x20D200)
+#define FTB_GLOBAL(r)          (int)(ftb_global_base + (r))
+#define ftb_global_size        (0x0200)
+
+#define FTB_CTRL               FTB_GLOBAL(0x0000)
+#define FTB_CTRL_WMASK         (0x18FFF)
+#define FTB_CTRL_MASK          (0x18FFF)
+#define FTB_CTRL_DEFAULT       (0x0000)
+#define FTB_CTRL_FMASK         (0x18FFF)
+#define FTB_IFFT_TSIZE         FTB_GLOBAL(0x0004)
+#define FTB_IFFT_TSIZE_WMASK   (0x7777)
+#define FTB_IFFT_TSIZE_MASK    (0x7777)
+#define FTB_IFFT_TSIZE_DEFAULT (0x2222)
+#define FTB_IFFT_TSIZE_FMASK   (0x7777)
+#define FTB_RX_STATUS          FTB_GLOBAL(0x0008)
+#define FTB_RX_STATUS_WMASK    (0x0000)
+#define FTB_RX_STATUS_MASK     (0x01FF)
+#define FTB_RX_STATUS_DEFAULT  (0x0080)
+#define FTB_RX_STATUS_FMASK    (0x0000)
+#define FTB_TX_STATUS          FTB_GLOBAL(0x000C)
+#define FTB_TX_STATUS_WMASK    (0x0000)
+#define FTB_TX_STATUS_MASK     (0x01FF)
+#define FTB_TX_STATUS_DEFAULT  (0x0081)
+#define FTB_TX_STATUS_FMASK    (0x0000)
+
+/* Ilv Memory Address Constants */
+#define ilv_dtb_base           (0x254000)
+#define ilv_dtb_mask           (0xFFFFFFFF)
+#define ilv_dtb_size           (0x2C00)
+#define ilv_dtb_default        (0x0000)
+#define ilv_dmetric_base       (0x257000)
+#define ilv_dmetric_mask       (0xFFFFFFFF)
+#define ilv_dmetric_size       (0x0800)
+#define ilv_dmetric_default    (0x0000)
+
+
+/* Qt Memory Address Constants */
+#define qt_abgtn_base          (0x230000)
+#define qt_abgtn_mask          (0xFFFFFFFF)
+#define qt_abgtn_size          (0x4400)
+#define qt_abgtn_default       (0x0000)
+#define qt_txaegt_base         (0x238000)
+#define qt_txaegt_mask         (0x70007)
+#define qt_txaegt_size         (0x2200)
+#define qt_txaegt_default      (0x0000)
+#define qt_rxfdqm_base         (0x23C000)
+#define qt_rxfdqm_mask         (0xFFFFFFFF)
+#define qt_rxfdqm_size         (0x4000)
+#define qt_rxfdqm_default      (0x0000)
+#define qt_rxfdqe_base         (0x240000)
+#define qt_rxfdqe_mask         (0x000F)
+#define qt_rxfdqe_size         (0x4000)
+#define qt_rxfdqe_default      (0x0000)
+#define qt_mco_ma_base         (0x24E000)
+#define qt_mco_ma_mask         (0xFFFFFFFF)
+#define qt_mco_ma_size         (0x0100)
+#define qt_mco_ma_default      (0x0000)
+#define qt_mco_ff_base         (0x24E100)
+#define qt_mco_ff_mask         (0xFFFFFFFF)
+#define qt_mco_ff_size         (0x0100)
+#define qt_mco_ff_default      (0x0000)
+#define qt_mco_ex_base         (0x24E200)
+#define qt_mco_ex_mask         (0x000F)
+#define qt_mco_ex_size         (0x0100)
+#define qt_mco_ex_default      (0x0000)
+#define qt_xyt_base            (0x24E800)
+#define qt_xyt_mask            (0xFFFFFFFF)
+#define qt_xyt_size            (0x0500)
+#define qt_xyt_default         (0x0000)
+#define qt_spm_base            (0x24F000)
+#define qt_spm_mask            (0x0000)
+#define qt_spm_size            (0x0180)
+#define qt_spm_default         (0x0000)
+#define qt_npsp_base           (0x24F200)
+#define qt_npsp_mask           (0x3FFFF)
+#define qt_npsp_size           (0x0180)
+#define qt_npsp_default        (0x0000)
+#define qt_vdt_base            (0x24F400)
+#define qt_vdt_mask            (0xFFFF)
+#define qt_vdt_size            (0x00C0)
+#define qt_vdt_default         (0x0000)
+#define qt_noiseaccl_base      (0x250000)
+#define qt_noiseaccl_mask      (0xFFFFFFFF)
+#define qt_noiseaccl_size      (0x1000)
+#define qt_noiseaccl_default   (0x0000)
+#define qt_noiseacch_base      (0x251000)
+#define qt_noiseacch_mask      (0x03FF)
+#define qt_noiseacch_size      (0x1000)
+#define qt_noiseacch_default   (0x0000)
+#define qt_qtxpram_base        (0x252000)
+#define qt_qtxpram_mask        (0xFFFFFFFF)
+#define qt_qtxpram_size        (0x0100)
+#define qt_qtxpram_default     (0x0000)
+#define qt_qrxpram_base        (0x252400)
+#define qt_qrxpram_mask        (0xFFFFFFFF)
+#define qt_qrxpram_size        (0x0100)
+#define qt_qrxpram_default     (0x0000)
+#define qt_rxfbt_base          (0x252500)
+#define qt_rxfbt_mask          (0xFFFFFFFF)
+#define qt_rxfbt_size          (0x0100)
+#define qt_rxfbt_default       (0x0000)
+#define qt_rxfdt_base          (0x252600)
+#define qt_rxfdt_mask          (0xFF00FF00)
+#define qt_rxfdt_size          (0x0200)
+#define qt_rxfdt_default       (0x0000)
+
+/* Qt Global Address Constants */
+#define qt_global_base         (0x20CA00)
+#define QT_GLOBAL(r)           (int)(qt_global_base + (r))
+#define qt_global_size         (0x0100)
+
+#define IT_ENABLE              QT_GLOBAL(0x0000)
+#define IT_ENABLE_WMASK        (0x0001)
+#define IT_ENABLE_MASK         (0x0001)
+#define IT_ENABLE_DEFAULT      (0x0000)
+#define IT_ENABLE_FMASK        (0x0001)
+#define IR_ENABLE              QT_GLOBAL(0x0004)
+#define IR_ENABLE_WMASK        (0x0001)
+#define IR_ENABLE_MASK         (0x0001)
+#define IR_ENABLE_DEFAULT      (0x0000)
+#define IR_ENABLE_FMASK        (0x0001)
+#define IR_NSC                 QT_GLOBAL(0x0008)
+#define IR_NSC_WMASK           (0x0007)
+#define IR_NSC_MASK            (0x0007)
+#define IR_NSC_DEFAULT         (0x0000)
+#define IR_NSC_FMASK           (0x0007)
+#define IR_PRBS_CTRL           QT_GLOBAL(0x000C)
+#define IR_PRBS_CTRL_WMASK     (0x0003)
+#define IR_PRBS_CTRL_MASK      (0x0003)
+#define IR_PRBS_CTRL_DEFAULT   (0x0000)
+#define IR_PRBS_CTRL_FMASK     (0x0003)
+#define IR_PRBS0               QT_GLOBAL(0x0010)
+#define IR_PRBS0_WMASK         (0xFFFFFFFF)
+#define IR_PRBS0_MASK          (0xFFFFFFFF)
+#define IR_PRBS0_DEFAULT       (0x0000)
+#define IR_PRBS0_FMASK         (0xFFFFFFFF)
+#define IR_PRBS1               QT_GLOBAL(0x0014)
+#define IR_PRBS1_WMASK         (0xFFFFFFFF)
+#define IR_PRBS1_MASK          (0xFFFFFFFF)
+#define IR_PRBS1_DEFAULT       (0x0000)
+#define IR_PRBS1_FMASK         (0xFFFFFFFF)
+#define I_ABGT_OFFSET          QT_GLOBAL(0x0018)
+#define I_ABGT_OFFSET_WMASK    (0x1FFF1FFF)
+#define I_ABGT_OFFSET_MASK     (0x1FFF1FFF)
+#define I_ABGT_OFFSET_DEFAULT  (0x0000)
+#define I_ABGT_OFFSET_FMASK    (0x1FFF1FFF)
+
+/* Qt Qtxpram Address Constants */
+#define qt_qtxpram_reg_base    (0x252000)
+#define QT_QTXPRAM_REG(r)      (int)(qt_qtxpram_reg_base + (r))
+#define qt_qtxpram_reg_size    (0x0100)
+
+#define IT_CONFIG              QT_QTXPRAM_REG(0x0000)
+#define IT_CONFIG_WMASK        (0x0077)
+#define IT_CONFIG_MASK         (0x0077)
+#define IT_CONFIG_DEFAULT      (0x0000)
+#define IT_CONFIG_FMASK        (0x0077)
+#define IT_TCM_CTRL            QT_QTXPRAM_REG(0x0004)
+#define IT_TCM_CTRL_WMASK      (0x17FFFFF)
+#define IT_TCM_CTRL_MASK       (0x17FFFFF)
+#define IT_TCM_CTRL_DEFAULT    (0x0000)
+#define IT_TCM_CTRL_FMASK      (0x17FFFFF)
+#define IT_MISC                QT_QTXPRAM_REG(0x0008)
+#define IT_MISC_WMASK          (0xFFFFF0)
+#define IT_MISC_MASK           (0xFFFFF0)
+#define IT_MISC_DEFAULT        (0x0000)
+#define IT_MISC_FMASK          (0xFFFFF0)
+#define IT_ACT_ADDR            QT_QTXPRAM_REG(0x000C)
+#define IT_ACT_ADDR_WMASK      (0xFFF0FFF)
+#define IT_ACT_ADDR_MASK       (0xFFF0FFF)
+#define IT_ACT_ADDR_DEFAULT    (0x0000)
+#define IT_ACT_ADDR_FMASK      (0xFFF0FFF)
+#define IT_LP0_BITS            QT_QTXPRAM_REG(0x0010)
+#define IT_LP0_BITS_WMASK      (0xFFFF)
+#define IT_LP0_BITS_MASK       (0xFFFF)
+#define IT_LP0_BITS_DEFAULT    (0x0000)
+#define IT_LP0_BITS_FMASK      (0xFFFF)
+#define IT_LP1_BITS            QT_QTXPRAM_REG(0x0014)
+#define IT_LP1_BITS_WMASK      (0xFFFF)
+#define IT_LP1_BITS_MASK       (0xFFFF)
+#define IT_LP1_BITS_DEFAULT    (0x0000)
+#define IT_LP1_BITS_FMASK      (0xFFFF)
+#define IT_LP2_BITS            QT_QTXPRAM_REG(0x0018)
+#define IT_LP2_BITS_WMASK      (0xFFFF)
+#define IT_LP2_BITS_MASK       (0xFFFF)
+#define IT_LP2_BITS_DEFAULT    (0x0000)
+#define IT_LP2_BITS_FMASK      (0xFFFF)
+#define IT_DUMMY               QT_QTXPRAM_REG(0x001C)
+#define IT_DUMMY_WMASK         (0xFFFF)
+#define IT_DUMMY_MASK          (0xFFFF)
+#define IT_DUMMY_DEFAULT       (0x0000)
+#define IT_DUMMY_FMASK         (0xFFFF)
+#define IT_LP0_BIT_FIFO        QT_QTXPRAM_REG(0x0020)
+#define IT_LP0_BIT_FIFO_WMASK  (0x07FF)
+#define IT_LP0_BIT_FIFO_MASK   (0x07FF)
+#define IT_LP0_BIT_FIFO_DEFAULT (0x0000)
+#define IT_LP0_BIT_FIFO_FMASK  (0x07FF)
+#define IT_LP1_BIT_FIFO        QT_QTXPRAM_REG(0x0024)
+#define IT_LP1_BIT_FIFO_WMASK  (0x07FF)
+#define IT_LP1_BIT_FIFO_MASK   (0x07FF)
+#define IT_LP1_BIT_FIFO_DEFAULT (0x0000)
+#define IT_LP1_BIT_FIFO_FMASK  (0x07FF)
+#define IT_LP2_BIT_FIFO        QT_QTXPRAM_REG(0x0028)
+#define IT_LP2_BIT_FIFO_WMASK  (0x07FF)
+#define IT_LP2_BIT_FIFO_MASK   (0x07FF)
+#define IT_LP2_BIT_FIFO_DEFAULT (0x0000)
+#define IT_LP2_BIT_FIFO_FMASK  (0x07FF)
+#define IT_PILOT               QT_QTXPRAM_REG(0x002C)
+#define IT_PILOT_WMASK         (0xFFFFFFFF)
+#define IT_PILOT_MASK          (0xFFFFFFFF)
+#define IT_PILOT_DEFAULT       (0x0000)
+#define IT_PILOT_FMASK         (0xFFFFFFFF)
+#define IT_PTINDEX             QT_QTXPRAM_REG(0x0030)
+#define IT_PTINDEX_WMASK       (0x7FFF)
+#define IT_PTINDEX_MASK        (0x7FFF)
+#define IT_PTINDEX_DEFAULT     (0x0000)
+#define IT_PTINDEX_FMASK       (0x7FFF)
+#define IT_PRBS                QT_QTXPRAM_REG(0x0034)
+#define IT_PRBS_WMASK          (0xFFFFFFFF)
+#define IT_PRBS_MASK           (0xFFFFFFFF)
+#define IT_PRBS_DEFAULT        (0x0000)
+#define IT_PRBS_FMASK          (0xFFFFFFFF)
+#define IT_PRBS_MISC           QT_QTXPRAM_REG(0x0038)
+#define IT_PRBS_MISC_WMASK     (0xFFFFFFF8)
+#define IT_PRBS_MISC_MASK      (0xFFFFFFF8)
+#define IT_PRBS_MISC_DEFAULT   (0x0000)
+#define IT_PRBS_MISC_FMASK     (0xFFFFFFF8)
+#define IT_PRBS_POLY           QT_QTXPRAM_REG(0x003C)
+#define IT_PRBS_POLY_WMASK     (0xFFFFFFFF)
+#define IT_PRBS_POLY_MASK      (0xFFFFFFFF)
+#define IT_PRBS_POLY_DEFAULT   (0x0000)
+#define IT_PRBS_POLY_FMASK     (0xFFFFFFFF)
+#define IT_PRBS_DATA0          QT_QTXPRAM_REG(0x0040)
+#define IT_PRBS_DATA0_WMASK    (0xFFFFFFFF)
+#define IT_PRBS_DATA0_MASK     (0xFFFFFFFF)
+#define IT_PRBS_DATA0_DEFAULT  (0x0000)
+#define IT_PRBS_DATA0_FMASK    (0xFFFFFFFF)
+#define IT_PRBS_DATA1          QT_QTXPRAM_REG(0x0044)
+#define IT_PRBS_DATA1_WMASK    (0xFFFFFFFF)
+#define IT_PRBS_DATA1_MASK     (0xFFFFFFFF)
+#define IT_PRBS_DATA1_DEFAULT  (0x0000)
+#define IT_PRBS_DATA1_FMASK    (0xFFFFFFFF)
+#define IT_PRBS_DATA2          QT_QTXPRAM_REG(0x0048)
+#define IT_PRBS_DATA2_WMASK    (0xFFFFFFFF)
+#define IT_PRBS_DATA2_MASK     (0xFFFFFFFF)
+#define IT_PRBS_DATA2_DEFAULT  (0x0000)
+#define IT_PRBS_DATA2_FMASK    (0xFFFFFFFF)
+#define IT_PRBS_DATA3          QT_QTXPRAM_REG(0x004C)
+#define IT_PRBS_DATA3_WMASK    (0xFFFFFFFF)
+#define IT_PRBS_DATA3_MASK     (0xFFFFFFFF)
+#define IT_PRBS_DATA3_DEFAULT  (0x0000)
+#define IT_PRBS_DATA3_FMASK    (0xFFFFFFFF)
+#define IT_PRBS_DATA4          QT_QTXPRAM_REG(0x0050)
+#define IT_PRBS_DATA4_WMASK    (0xFFFFFFFF)
+#define IT_PRBS_DATA4_MASK     (0xFFFFFFFF)
+#define IT_PRBS_DATA4_DEFAULT  (0x0000)
+#define IT_PRBS_DATA4_FMASK    (0xFFFFFFFF)
+#define IT_PRBS_DATA5          QT_QTXPRAM_REG(0x0054)
+#define IT_PRBS_DATA5_WMASK    (0xFFFFFFFF)
+#define IT_PRBS_DATA5_MASK     (0xFFFFFFFF)
+#define IT_PRBS_DATA5_DEFAULT  (0x0000)
+#define IT_PRBS_DATA5_FMASK    (0xFFFFFFFF)
+#define IT_PRBS_DATA6          QT_QTXPRAM_REG(0x0058)
+#define IT_PRBS_DATA6_WMASK    (0xFFFFFFFF)
+#define IT_PRBS_DATA6_MASK     (0xFFFFFFFF)
+#define IT_PRBS_DATA6_DEFAULT  (0x0000)
+#define IT_PRBS_DATA6_FMASK    (0xFFFFFFFF)
+#define IT_PRBS_DATA7          QT_QTXPRAM_REG(0x005C)
+#define IT_PRBS_DATA7_WMASK    (0xFFFFFFFF)
+#define IT_PRBS_DATA7_MASK     (0xFFFFFFFF)
+#define IT_PRBS_DATA7_DEFAULT  (0x0000)
+#define IT_PRBS_DATA7_FMASK    (0xFFFFFFFF)
+#define IT_REF_GAIN            QT_QTXPRAM_REG(0x0060)
+#define IT_REF_GAIN_WMASK      (0x7FFF)
+#define IT_REF_GAIN_MASK       (0x7FFF)
+#define IT_REF_GAIN_DEFAULT    (0x0000)
+#define IT_REF_GAIN_FMASK      (0x7FFF)
+#define IT_NYQ_TONE_DATA       QT_QTXPRAM_REG(0x0064)
+#define IT_NYQ_TONE_DATA_WMASK (0xFFFFFFFF)
+#define IT_NYQ_TONE_DATA_MASK  (0xFFFFFFFF)
+#define IT_NYQ_TONE_DATA_DEFAULT (0x0000)
+#define IT_NYQ_TONE_DATA_FMASK (0xFFFFFFFF)
+#define IT_TXCG_0              QT_QTXPRAM_REG(0x0068)
+#define IT_TXCG_0_WMASK        (0x7FFFF)
+#define IT_TXCG_0_MASK         (0x7FFFF)
+#define IT_TXCG_0_DEFAULT      (0x0000)
+#define IT_TXCG_0_FMASK        (0x7FFFF)
+#define IT_TXCG_1              QT_QTXPRAM_REG(0x006C)
+#define IT_TXCG_1_WMASK        (0x7FFFF)
+#define IT_TXCG_1_MASK         (0x7FFFF)
+#define IT_TXCG_1_DEFAULT      (0x0000)
+#define IT_TXCG_1_FMASK        (0x7FFFF)
+#define IT_TXCG_2              QT_QTXPRAM_REG(0x0070)
+#define IT_TXCG_2_WMASK        (0x7FFFF)
+#define IT_TXCG_2_MASK         (0x7FFFF)
+#define IT_TXCG_2_DEFAULT      (0x0000)
+#define IT_TXCG_2_FMASK        (0x7FFFF)
+#define IT_TXCG_3              QT_QTXPRAM_REG(0x0074)
+#define IT_TXCG_3_WMASK        (0x7FFFF)
+#define IT_TXCG_3_MASK         (0x7FFFF)
+#define IT_TXCG_3_DEFAULT      (0x0000)
+#define IT_TXCG_3_FMASK        (0x7FFFF)
+#define IT_TXCG_4              QT_QTXPRAM_REG(0x0078)
+#define IT_TXCG_4_WMASK        (0x7FFFF)
+#define IT_TXCG_4_MASK         (0x7FFFF)
+#define IT_TXCG_4_DEFAULT      (0x0000)
+#define IT_TXCG_4_FMASK        (0x7FFFF)
+#define IT_TXCG_5              QT_QTXPRAM_REG(0x007C)
+#define IT_TXCG_5_WMASK        (0x7FFFF)
+#define IT_TXCG_5_MASK         (0x7FFFF)
+#define IT_TXCG_5_DEFAULT      (0x0000)
+#define IT_TXCG_5_FMASK        (0x7FFFF)
+#define IT_TXCG_6              QT_QTXPRAM_REG(0x0080)
+#define IT_TXCG_6_WMASK        (0x7FFFF)
+#define IT_TXCG_6_MASK         (0x7FFFF)
+#define IT_TXCG_6_DEFAULT      (0x0000)
+#define IT_TXCG_6_FMASK        (0x7FFFF)
+#define IT_TXCG_7              QT_QTXPRAM_REG(0x0084)
+#define IT_TXCG_7_WMASK        (0x7FFFF)
+#define IT_TXCG_7_MASK         (0x7FFFF)
+#define IT_TXCG_7_DEFAULT      (0x0000)
+#define IT_TXCG_7_FMASK        (0x7FFFF)
+#define IT_TXCG_8              QT_QTXPRAM_REG(0x0088)
+#define IT_TXCG_8_WMASK        (0x7FFFF)
+#define IT_TXCG_8_MASK         (0x7FFFF)
+#define IT_TXCG_8_DEFAULT      (0x0000)
+#define IT_TXCG_8_FMASK        (0x7FFFF)
+#define IT_TXCG_9              QT_QTXPRAM_REG(0x008C)
+#define IT_TXCG_9_WMASK        (0x7FFFF)
+#define IT_TXCG_9_MASK         (0x7FFFF)
+#define IT_TXCG_9_DEFAULT      (0x0000)
+#define IT_TXCG_9_FMASK        (0x7FFFF)
+#define IT_TXCG_10             QT_QTXPRAM_REG(0x0090)
+#define IT_TXCG_10_WMASK       (0x7FFFF)
+#define IT_TXCG_10_MASK        (0x7FFFF)
+#define IT_TXCG_10_DEFAULT     (0x0000)
+#define IT_TXCG_10_FMASK       (0x7FFFF)
+#define IT_TXCG_11             QT_QTXPRAM_REG(0x0094)
+#define IT_TXCG_11_WMASK       (0x7FFFF)
+#define IT_TXCG_11_MASK        (0x7FFFF)
+#define IT_TXCG_11_DEFAULT     (0x0000)
+#define IT_TXCG_11_FMASK       (0x7FFFF)
+#define IT_TXCG_12             QT_QTXPRAM_REG(0x0098)
+#define IT_TXCG_12_WMASK       (0x7FFFF)
+#define IT_TXCG_12_MASK        (0x7FFFF)
+#define IT_TXCG_12_DEFAULT     (0x0000)
+#define IT_TXCG_12_FMASK       (0x7FFFF)
+#define IT_TXCG_13             QT_QTXPRAM_REG(0x009C)
+#define IT_TXCG_13_WMASK       (0x7FFFF)
+#define IT_TXCG_13_MASK        (0x7FFFF)
+#define IT_TXCG_13_DEFAULT     (0x0000)
+#define IT_TXCG_13_FMASK       (0x7FFFF)
+#define IT_TXCG_14             QT_QTXPRAM_REG(0x00A0)
+#define IT_TXCG_14_WMASK       (0x7FFFF)
+#define IT_TXCG_14_MASK        (0x7FFFF)
+#define IT_TXCG_14_DEFAULT     (0x0000)
+#define IT_TXCG_14_FMASK       (0x7FFFF)
+#define IT_TXCG_15             QT_QTXPRAM_REG(0x00A4)
+#define IT_TXCG_15_WMASK       (0x7FFFF)
+#define IT_TXCG_15_MASK        (0x7FFFF)
+#define IT_TXCG_15_DEFAULT     (0x0000)
+#define IT_TXCG_15_FMASK       (0x7FFFF)
+#define IT_IFFTZ_RNG0          QT_QTXPRAM_REG(0x00A8)
+#define IT_IFFTZ_RNG0_WMASK    (0x1FFFFFF)
+#define IT_IFFTZ_RNG0_MASK     (0x1FFFFFF)
+#define IT_IFFTZ_RNG0_DEFAULT  (0x0000)
+#define IT_IFFTZ_RNG0_FMASK    (0x1FFFFFF)
+#define IT_IFFTZ_RNG1          QT_QTXPRAM_REG(0x00AC)
+#define IT_IFFTZ_RNG1_WMASK    (0x1FFFFFF)
+#define IT_IFFTZ_RNG1_MASK     (0x1FFFFFF)
+#define IT_IFFTZ_RNG1_DEFAULT  (0x0000)
+#define IT_IFFTZ_RNG1_FMASK    (0x1FFFFFF)
+#define IT_IFFTZ_RNG2          QT_QTXPRAM_REG(0x00B0)
+#define IT_IFFTZ_RNG2_WMASK    (0x1FFFFFF)
+#define IT_IFFTZ_RNG2_MASK     (0x1FFFFFF)
+#define IT_IFFTZ_RNG2_DEFAULT  (0x0000)
+#define IT_IFFTZ_RNG2_FMASK    (0x1FFFFFF)
+#define IT_IFFTZ_RNG3          QT_QTXPRAM_REG(0x00B4)
+#define IT_IFFTZ_RNG3_WMASK    (0x1FFFFFF)
+#define IT_IFFTZ_RNG3_MASK     (0x1FFFFFF)
+#define IT_IFFTZ_RNG3_DEFAULT  (0x0000)
+#define IT_IFFTZ_RNG3_FMASK    (0x1FFFFFF)
+#define IT_IFFTZ_RNG4          QT_QTXPRAM_REG(0x00B8)
+#define IT_IFFTZ_RNG4_WMASK    (0x1FFFFFF)
+#define IT_IFFTZ_RNG4_MASK     (0x1FFFFFF)
+#define IT_IFFTZ_RNG4_DEFAULT  (0x0000)
+#define IT_IFFTZ_RNG4_FMASK    (0x1FFFFFF)
+#define IT_IFFTZ_RNG5          QT_QTXPRAM_REG(0x00BC)
+#define IT_IFFTZ_RNG5_WMASK    (0x1FFFFFF)
+#define IT_IFFTZ_RNG5_MASK     (0x1FFFFFF)
+#define IT_IFFTZ_RNG5_DEFAULT  (0x0000)
+#define IT_IFFTZ_RNG5_FMASK    (0x1FFFFFF)
+#define IT_TONE0_DATA          QT_QTXPRAM_REG(0x00C0)
+#define IT_TONE0_DATA_WMASK    (0xFFFFFFFF)
+#define IT_TONE0_DATA_MASK     (0xFFFFFFFF)
+#define IT_TONE0_DATA_DEFAULT  (0x0000)
+#define IT_TONE0_DATA_FMASK    (0xFFFFFFFF)
+#define IT_DCI_CTRL            QT_QTXPRAM_REG(0x00C4)
+#define IT_DCI_CTRL_WMASK      (0x1FFFFFF)
+#define IT_DCI_CTRL_MASK       (0x1FFFFFF)
+#define IT_DCI_CTRL_DEFAULT    (0x0000)
+#define IT_DCI_CTRL_FMASK      (0x1FFFFFF)
+
+/* Qt Qrxpram Address Constants */
+#define qt_qrxpram_reg_base    (0x252400)
+#define QT_QRXPRAM_REG(r)      (int)(qt_qrxpram_reg_base + (r))
+#define qt_qrxpram_reg_size    (0x0100)
+
+#define IR_CONFIG              QT_QRXPRAM_REG(0x0000)
+#define IR_CONFIG_WMASK        (0x0FFF)
+#define IR_CONFIG_MASK         (0x0FFF)
+#define IR_CONFIG_DEFAULT      (0x0000)
+#define IR_CONFIG_FMASK        (0x0FFF)
+#define IR_TCM_CTRL            QT_QRXPRAM_REG(0x0004)
+#define IR_TCM_CTRL_WMASK      (0x17FFFFF)
+#define IR_TCM_CTRL_MASK       (0x17FFFFF)
+#define IR_TCM_CTRL_DEFAULT    (0x0000)
+#define IR_TCM_CTRL_FMASK      (0x17FFFFF)
+#define IR_MISC                QT_QRXPRAM_REG(0x0008)
+#define IR_MISC_WMASK          (0x7FEFFFE0)
+#define IR_MISC_MASK           (0x7FEFFFE0)
+#define IR_MISC_DEFAULT        (0x0000)
+#define IR_MISC_FMASK          (0x7FEFFFE0)
+#define IR_ACT_ADDR            QT_QRXPRAM_REG(0x000C)
+#define IR_ACT_ADDR_WMASK      (0xFFF0FFF)
+#define IR_ACT_ADDR_MASK       (0xFFF0FFF)
+#define IR_ACT_ADDR_DEFAULT    (0x0000)
+#define IR_ACT_ADDR_FMASK      (0xFFF0FFF)
+#define IR_LP0_BITS            QT_QRXPRAM_REG(0x0010)
+#define IR_LP0_BITS_WMASK      (0xFFFF)
+#define IR_LP0_BITS_MASK       (0xFFFF)
+#define IR_LP0_BITS_DEFAULT    (0x0000)
+#define IR_LP0_BITS_FMASK      (0xFFFF)
+#define IR_LP1_BITS            QT_QRXPRAM_REG(0x0014)
+#define IR_LP1_BITS_WMASK      (0xFFFF)
+#define IR_LP1_BITS_MASK       (0xFFFF)
+#define IR_LP1_BITS_DEFAULT    (0x0000)
+#define IR_LP1_BITS_FMASK      (0xFFFF)
+#define IR_LP2_BITS            QT_QRXPRAM_REG(0x0018)
+#define IR_LP2_BITS_WMASK      (0xFFFF)
+#define IR_LP2_BITS_MASK       (0xFFFF)
+#define IR_LP2_BITS_DEFAULT    (0x0000)
+#define IR_LP2_BITS_FMASK      (0xFFFF)
+#define IR_DUMMY               QT_QRXPRAM_REG(0x001C)
+#define IR_DUMMY_WMASK         (0xFFFF)
+#define IR_DUMMY_MASK          (0xFFFF)
+#define IR_DUMMY_DEFAULT       (0x0000)
+#define IR_DUMMY_FMASK         (0xFFFF)
+#define IR_LP0_BIT_FIFO        QT_QRXPRAM_REG(0x0020)
+#define IR_LP0_BIT_FIFO_WMASK  (0x07FF)
+#define IR_LP0_BIT_FIFO_MASK   (0x07FF)
+#define IR_LP0_BIT_FIFO_DEFAULT (0x0000)
+#define IR_LP0_BIT_FIFO_FMASK  (0x07FF)
+#define IR_LP1_BIT_FIFO        QT_QRXPRAM_REG(0x0024)
+#define IR_LP1_BIT_FIFO_WMASK  (0x07FF)
+#define IR_LP1_BIT_FIFO_MASK   (0x07FF)
+#define IR_LP1_BIT_FIFO_DEFAULT (0x0000)
+#define IR_LP1_BIT_FIFO_FMASK  (0x07FF)
+#define IR_LP2_BIT_FIFO        QT_QRXPRAM_REG(0x0028)
+#define IR_LP2_BIT_FIFO_WMASK  (0x07FF)
+#define IR_LP2_BIT_FIFO_MASK   (0x07FF)
+#define IR_LP2_BIT_FIFO_DEFAULT (0x0000)
+#define IR_LP2_BIT_FIFO_FMASK  (0x07FF)
+#define IR_DEROT_MISC          QT_QRXPRAM_REG(0x002C)
+#define IR_DEROT_MISC_WMASK    (0x7FFF)
+#define IR_DEROT_MISC_MASK     (0x7FFF)
+#define IR_DEROT_MISC_DEFAULT  (0x0000)
+#define IR_DEROT_MISC_FMASK    (0x7FFF)
+#define IR_DEROT_POLY          QT_QRXPRAM_REG(0x0030)
+#define IR_DEROT_POLY_WMASK    (0xFFFFFFFF)
+#define IR_DEROT_POLY_MASK     (0xFFFFFFFF)
+#define IR_DEROT_POLY_DEFAULT  (0x0000)
+#define IR_DEROT_POLY_FMASK    (0xFFFFFFFF)
+#define IR_FD_RNG0             QT_QRXPRAM_REG(0x0034)
+#define IR_FD_RNG0_WMASK       (0xBFFFFFFF)
+#define IR_FD_RNG0_MASK        (0xBFFFFFFF)
+#define IR_FD_RNG0_DEFAULT     (0x0000)
+#define IR_FD_RNG0_FMASK       (0xBFFFFFFF)
+#define IR_FD_RNG1             QT_QRXPRAM_REG(0x0038)
+#define IR_FD_RNG1_WMASK       (0xBFFFFFFF)
+#define IR_FD_RNG1_MASK        (0xBFFFFFFF)
+#define IR_FD_RNG1_DEFAULT     (0x0000)
+#define IR_FD_RNG1_FMASK       (0xBFFFFFFF)
+#define IR_FD_RNG1_BASE        QT_QRXPRAM_REG(0x003C)
+#define IR_FD_RNG1_BASE_WMASK  (0x0FFF)
+#define IR_FD_RNG1_BASE_MASK   (0x0FFF)
+#define IR_FD_RNG1_BASE_DEFAULT (0x0000)
+#define IR_FD_RNG1_BASE_FMASK  (0x0FFF)
+#define IR_NPR_IIBRAM          QT_QRXPRAM_REG(0x0040)
+#define IR_NPR_IIBRAM_WMASK    (0x8000FFFF)
+#define IR_NPR_IIBRAM_MASK     (0x8000FFFF)
+#define IR_NPR_IIBRAM_DEFAULT  (0x0000)
+#define IR_NPR_IIBRAM_FMASK    (0x8000FFFF)
+#define IR_QUAD0               QT_QRXPRAM_REG(0x0044)
+#define IR_QUAD0_WMASK         (0xFFFFFFFF)
+#define IR_QUAD0_MASK          (0xFFFFFFFF)
+#define IR_QUAD0_DEFAULT       (0x0000)
+#define IR_QUAD0_FMASK         (0xFFFFFFFF)
+#define IR_QUAD1               QT_QRXPRAM_REG(0x0048)
+#define IR_QUAD1_WMASK         (0xFFFFFFFF)
+#define IR_QUAD1_MASK          (0xFFFFFFFF)
+#define IR_QUAD1_DEFAULT       (0x0000)
+#define IR_QUAD1_FMASK         (0xFFFFFFFF)
+#define IR_SLOWDOWN            QT_QRXPRAM_REG(0x004C)
+#define IR_SLOWDOWN_WMASK      (0x00FF)
+#define IR_SLOWDOWN_MASK       (0x00FF)
+#define IR_SLOWDOWN_DEFAULT    (0x0000)
+#define IR_SLOWDOWN_FMASK      (0x00FF)
+#define IR_PTINDEX             QT_QRXPRAM_REG(0x0050)
+#define IR_PTINDEX_WMASK       (0x1FFF)
+#define IR_PTINDEX_MASK        (0x1FFF)
+#define IR_PTINDEX_DEFAULT     (0x0000)
+#define IR_PTINDEX_FMASK       (0x1FFF)
+#define IR_PILOT               QT_QRXPRAM_REG(0x0054)
+#define IR_PILOT_WMASK         (0xFFFFFFFF)
+#define IR_PILOT_MASK          (0xFFFFFFFF)
+#define IR_PILOT_DEFAULT       (0x0000)
+#define IR_PILOT_FMASK         (0xFFFFFFFF)
+#define IR_FDQADAPT            QT_QRXPRAM_REG(0x0058)
+#define IR_FDQADAPT_WMASK      (0x73FF)
+#define IR_FDQADAPT_MASK       (0x73FF)
+#define IR_FDQADAPT_DEFAULT    (0x0000)
+#define IR_FDQADAPT_FMASK      (0x73FF)
+#define IR_VECPOW_L            QT_QRXPRAM_REG(0x005C)
+#define IR_VECPOW_L_WMASK      (0xFFFFFFFF)
+#define IR_VECPOW_L_MASK       (0xFFFFFFFF)
+#define IR_VECPOW_L_DEFAULT    (0x0000)
+#define IR_VECPOW_L_FMASK      (0xFFFFFFFF)
+#define IR_VECPOW_H            QT_QRXPRAM_REG(0x0060)
+#define IR_VECPOW_H_WMASK      (0x03FF)
+#define IR_VECPOW_H_MASK       (0x03FF)
+#define IR_VECPOW_H_DEFAULT    (0x0000)
+#define IR_VECPOW_H_FMASK      (0x03FF)
+#define IR_RMETRIC_CTL         QT_QRXPRAM_REG(0x0064)
+#define IR_RMETRIC_CTL_WMASK   (0x001F)
+#define IR_RMETRIC_CTL_MASK    (0x001F)
+#define IR_RMETRIC_CTL_DEFAULT (0x0000)
+#define IR_RMETRIC_CTL_FMASK   (0x001F)
+#define IR_RMETRIC_VAL         QT_QRXPRAM_REG(0x0068)
+#define IR_RMETRIC_VAL_WMASK   (0x00FF)
+#define IR_RMETRIC_VAL_MASK    (0x00FF)
+#define IR_RMETRIC_VAL_DEFAULT (0x0000)
+#define IR_RMETRIC_VAL_FMASK   (0x00FF)
+#define IR_RXCG_0              QT_QRXPRAM_REG(0x006C)
+#define IR_RXCG_0_WMASK        (0x7FFFF)
+#define IR_RXCG_0_MASK         (0x7FFFF)
+#define IR_RXCG_0_DEFAULT      (0x0000)
+#define IR_RXCG_0_FMASK        (0x7FFFF)
+#define IR_RXCG_1              QT_QRXPRAM_REG(0x0070)
+#define IR_RXCG_1_WMASK        (0x7FFFF)
+#define IR_RXCG_1_MASK         (0x7FFFF)
+#define IR_RXCG_1_DEFAULT      (0x0000)
+#define IR_RXCG_1_FMASK        (0x7FFFF)
+#define IR_RXCG_2              QT_QRXPRAM_REG(0x0074)
+#define IR_RXCG_2_WMASK        (0x7FFFF)
+#define IR_RXCG_2_MASK         (0x7FFFF)
+#define IR_RXCG_2_DEFAULT      (0x0000)
+#define IR_RXCG_2_FMASK        (0x7FFFF)
+#define IR_RXCG_3              QT_QRXPRAM_REG(0x0078)
+#define IR_RXCG_3_WMASK        (0x7FFFF)
+#define IR_RXCG_3_MASK         (0x7FFFF)
+#define IR_RXCG_3_DEFAULT      (0x0000)
+#define IR_RXCG_3_FMASK        (0x7FFFF)
+#define IR_RXCG_4              QT_QRXPRAM_REG(0x007C)
+#define IR_RXCG_4_WMASK        (0x7FFFF)
+#define IR_RXCG_4_MASK         (0x7FFFF)
+#define IR_RXCG_4_DEFAULT      (0x0000)
+#define IR_RXCG_4_FMASK        (0x7FFFF)
+#define IR_RXCG_5              QT_QRXPRAM_REG(0x0080)
+#define IR_RXCG_5_WMASK        (0x7FFFF)
+#define IR_RXCG_5_MASK         (0x7FFFF)
+#define IR_RXCG_5_DEFAULT      (0x0000)
+#define IR_RXCG_5_FMASK        (0x7FFFF)
+#define IR_RXCG_6              QT_QRXPRAM_REG(0x0084)
+#define IR_RXCG_6_WMASK        (0x7FFFF)
+#define IR_RXCG_6_MASK         (0x7FFFF)
+#define IR_RXCG_6_DEFAULT      (0x0000)
+#define IR_RXCG_6_FMASK        (0x7FFFF)
+#define IR_RXCG_7              QT_QRXPRAM_REG(0x0088)
+#define IR_RXCG_7_WMASK        (0x7FFFF)
+#define IR_RXCG_7_MASK         (0x7FFFF)
+#define IR_RXCG_7_DEFAULT      (0x0000)
+#define IR_RXCG_7_FMASK        (0x7FFFF)
+#define IR_RXCG_8              QT_QRXPRAM_REG(0x008C)
+#define IR_RXCG_8_WMASK        (0x7FFFF)
+#define IR_RXCG_8_MASK         (0x7FFFF)
+#define IR_RXCG_8_DEFAULT      (0x0000)
+#define IR_RXCG_8_FMASK        (0x7FFFF)
+#define IR_RXCG_9              QT_QRXPRAM_REG(0x0090)
+#define IR_RXCG_9_WMASK        (0x7FFFF)
+#define IR_RXCG_9_MASK         (0x7FFFF)
+#define IR_RXCG_9_DEFAULT      (0x0000)
+#define IR_RXCG_9_FMASK        (0x7FFFF)
+#define IR_RXCG_10             QT_QRXPRAM_REG(0x0094)
+#define IR_RXCG_10_WMASK       (0x7FFFF)
+#define IR_RXCG_10_MASK        (0x7FFFF)
+#define IR_RXCG_10_DEFAULT     (0x0000)
+#define IR_RXCG_10_FMASK       (0x7FFFF)
+#define IR_RXCG_11             QT_QRXPRAM_REG(0x0098)
+#define IR_RXCG_11_WMASK       (0x7FFFF)
+#define IR_RXCG_11_MASK        (0x7FFFF)
+#define IR_RXCG_11_DEFAULT     (0x0000)
+#define IR_RXCG_11_FMASK       (0x7FFFF)
+#define IR_RXCG_12             QT_QRXPRAM_REG(0x009C)
+#define IR_RXCG_12_WMASK       (0x7FFFF)
+#define IR_RXCG_12_MASK        (0x7FFFF)
+#define IR_RXCG_12_DEFAULT     (0x0000)
+#define IR_RXCG_12_FMASK       (0x7FFFF)
+#define IR_RXCG_13             QT_QRXPRAM_REG(0x00A0)
+#define IR_RXCG_13_WMASK       (0x7FFFF)
+#define IR_RXCG_13_MASK        (0x7FFFF)
+#define IR_RXCG_13_DEFAULT     (0x0000)
+#define IR_RXCG_13_FMASK       (0x7FFFF)
+#define IR_RXCG_14             QT_QRXPRAM_REG(0x00A4)
+#define IR_RXCG_14_WMASK       (0x7FFFF)
+#define IR_RXCG_14_MASK        (0x7FFFF)
+#define IR_RXCG_14_DEFAULT     (0x0000)
+#define IR_RXCG_14_FMASK       (0x7FFFF)
+#define IR_RXCG_15             QT_QRXPRAM_REG(0x00A8)
+#define IR_RXCG_15_WMASK       (0x7FFFF)
+#define IR_RXCG_15_MASK        (0x7FFFF)
+#define IR_RXCG_15_DEFAULT     (0x0000)
+#define IR_RXCG_15_FMASK       (0x7FFFF)
+
+/* Qtp Memory Address Constants */
+#define qtp_ibat_base          (0x244000)
+#define qtp_ibat_mask          (0xF0F0F0F)
+#define qtp_ibat_size          (0x1000)
+#define qtp_ibat_default       (0x0000)
+#define qtp_igst_base          (0x246000)
+#define qtp_igst_mask          (0xFFFFFFFF)
+#define qtp_igst_size          (0x2000)
+#define qtp_igst_default       (0x0000)
+#define qtp_iegt_base          (0x248000)
+#define qtp_iegt_mask          (0xF0F0F0F)
+#define qtp_iegt_size          (0x1000)
+#define qtp_iegt_default       (0x0000)
+#define qtp_itot_base          (0x24A000)
+#define qtp_itot_mask          (0xFFF0FFF)
+#define qtp_itot_size          (0x2000)
+#define qtp_itot_default       (0x0000)
+#define qtp_ifbt_base          (0x24C000)
+#define qtp_ifbt_mask          (0xFFF0FFF)
+#define qtp_ifbt_size          (0x0080)
+#define qtp_ifbt_default       (0x0000)
+#define qtp_txpram_base        (0x252800)
+#define qtp_txpram_mask        (0xFFFFFFFF)
+#define qtp_txpram_size        (0x0040)
+#define qtp_txpram_default     (0x0000)
+#define qtp_rxpram_base        (0x252840)
+#define qtp_rxpram_mask        (0xFFFFFFFF)
+#define qtp_rxpram_size        (0x0040)
+#define qtp_rxpram_default     (0x0000)
+
+/* Qtp Global Address Constants */
+#define qtp_global_base        (0x20CB00)
+#define QTP_GLOBAL(r)          (int)(qtp_global_base + (r))
+#define qtp_global_size        (0x0100)
+
+#define QTP_CONFIG             QTP_GLOBAL(0x0000)
+#define QTP_CONFIG_WMASK       (0x0007)
+#define QTP_CONFIG_MASK        (0x0007)
+#define QTP_CONFIG_DEFAULT     (0x0000)
+#define QTP_CONFIG_FMASK       (0x0007)
+#define QTP_STATUS             QTP_GLOBAL(0x0004)
+#define QTP_STATUS_WMASK       (0x0003)
+#define QTP_STATUS_MASK        (0x0003)
+#define QTP_STATUS_DEFAULT     (0x0000)
+#define QTP_STATUS_FMASK       (0x0000)
+#define QTP_TX_PRBS_DATA0      QTP_GLOBAL(0x0008)
+#define QTP_TX_PRBS_DATA0_WMASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA0_MASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA0_DEFAULT (0x0000)
+#define QTP_TX_PRBS_DATA0_FMASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA1      QTP_GLOBAL(0x000C)
+#define QTP_TX_PRBS_DATA1_WMASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA1_MASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA1_DEFAULT (0x0000)
+#define QTP_TX_PRBS_DATA1_FMASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA2      QTP_GLOBAL(0x0010)
+#define QTP_TX_PRBS_DATA2_WMASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA2_MASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA2_DEFAULT (0x0000)
+#define QTP_TX_PRBS_DATA2_FMASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA3      QTP_GLOBAL(0x0014)
+#define QTP_TX_PRBS_DATA3_WMASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA3_MASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA3_DEFAULT (0x0000)
+#define QTP_TX_PRBS_DATA3_FMASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA4      QTP_GLOBAL(0x0018)
+#define QTP_TX_PRBS_DATA4_WMASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA4_MASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA4_DEFAULT (0x0000)
+#define QTP_TX_PRBS_DATA4_FMASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA5      QTP_GLOBAL(0x001C)
+#define QTP_TX_PRBS_DATA5_WMASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA5_MASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA5_DEFAULT (0x0000)
+#define QTP_TX_PRBS_DATA5_FMASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA6      QTP_GLOBAL(0x0020)
+#define QTP_TX_PRBS_DATA6_WMASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA6_MASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA6_DEFAULT (0x0000)
+#define QTP_TX_PRBS_DATA6_FMASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA7      QTP_GLOBAL(0x0024)
+#define QTP_TX_PRBS_DATA7_WMASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA7_MASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_DATA7_DEFAULT (0x0000)
+#define QTP_TX_PRBS_DATA7_FMASK (0xFFFFFFFF)
+
+/* Qtp Txpram Address Constants */
+#define qtp_txpram_reg_base    (0x252800)
+#define QTP_TXPRAM_REG(r)      (int)(qtp_txpram_reg_base + (r))
+#define qtp_txpram_reg_size    (0x0100)
+
+#define QTP_TX_CTRL            QTP_TXPRAM_REG(0x0000)
+#define QTP_TX_CTRL_WMASK      (0x3FFF)
+#define QTP_TX_CTRL_MASK       (0x3FFF)
+#define QTP_TX_CTRL_DEFAULT    (0x0000)
+#define QTP_TX_CTRL_FMASK      (0x3FFF)
+#define QTP_TXTC_CTRL          QTP_TXPRAM_REG(0x0004)
+#define QTP_TXTC_CTRL_WMASK    (0x3FFFFFFF)
+#define QTP_TXTC_CTRL_MASK     (0x3FFFFFFF)
+#define QTP_TXTC_CTRL_DEFAULT  (0x0000)
+#define QTP_TXTC_CTRL_FMASK    (0x3FFFFFFF)
+#define QTP_TXTC_TOT_AD        QTP_TXPRAM_REG(0x0008)
+#define QTP_TXTC_TOT_AD_WMASK  (0xFFFFFF)
+#define QTP_TXTC_TOT_AD_MASK   (0xFFFFFF)
+#define QTP_TXTC_TOT_AD_DEFAULT (0x0000)
+#define QTP_TXTC_TOT_AD_FMASK  (0xFFFFFF)
+#define QTP_TXTC_ACT_AD        QTP_TXPRAM_REG(0x000C)
+#define QTP_TXTC_ACT_AD_WMASK  (0xFFFFFF)
+#define QTP_TXTC_ACT_AD_MASK   (0xFFFFFF)
+#define QTP_TXTC_ACT_AD_DEFAULT (0x0000)
+#define QTP_TXTC_ACT_AD_FMASK  (0xFFFFFF)
+#define QTP_TX_PRBS            QTP_TXPRAM_REG(0x0010)
+#define QTP_TX_PRBS_WMASK      (0xFFFFFFFF)
+#define QTP_TX_PRBS_MASK       (0xFFFFFFFF)
+#define QTP_TX_PRBS_DEFAULT    (0x0000)
+#define QTP_TX_PRBS_FMASK      (0xFFFFFFFF)
+#define QTP_TX_PRBS_MISC       QTP_TXPRAM_REG(0x0014)
+#define QTP_TX_PRBS_MISC_WMASK (0xFFF9FDF0)
+#define QTP_TX_PRBS_MISC_MASK  (0xFFF9FDF0)
+#define QTP_TX_PRBS_MISC_DEFAULT (0x0000)
+#define QTP_TX_PRBS_MISC_FMASK (0xFFF9FDF0)
+#define QTP_TX_PRBS_POLY       QTP_TXPRAM_REG(0x0018)
+#define QTP_TX_PRBS_POLY_WMASK (0xFFFFFFFF)
+#define QTP_TX_PRBS_POLY_MASK  (0xFFFFFFFF)
+#define QTP_TX_PRBS_POLY_DEFAULT (0x0000)
+#define QTP_TX_PRBS_POLY_FMASK (0xFFFFFFFF)
+
+/* Qtp Rxpram Address Constants */
+#define qtp_rxpram_reg_base    (0x252840)
+#define QTP_RXPRAM_REG(r)      (int)(qtp_rxpram_reg_base + (r))
+#define qtp_rxpram_reg_size    (0x0100)
+
+#define QTP_RX_CTRL            QTP_RXPRAM_REG(0x0000)
+#define QTP_RX_CTRL_WMASK      (0x3FFF)
+#define QTP_RX_CTRL_MASK       (0x3FFF)
+#define QTP_RX_CTRL_DEFAULT    (0x0000)
+#define QTP_RX_CTRL_FMASK      (0x3FFF)
+#define QTP_RXTC_CTRL          QTP_RXPRAM_REG(0x0004)
+#define QTP_RXTC_CTRL_WMASK    (0x3FFFFFFF)
+#define QTP_RXTC_CTRL_MASK     (0x3FFFFFFF)
+#define QTP_RXTC_CTRL_DEFAULT  (0x0000)
+#define QTP_RXTC_CTRL_FMASK    (0x3FFFFFFF)
+#define QTP_RXTC_TOT_AD        QTP_RXPRAM_REG(0x0008)
+#define QTP_RXTC_TOT_AD_WMASK  (0xFFFFFF)
+#define QTP_RXTC_TOT_AD_MASK   (0xFFFFFF)
+#define QTP_RXTC_TOT_AD_DEFAULT (0x0000)
+#define QTP_RXTC_TOT_AD_FMASK  (0xFFFFFF)
+#define QTP_RXTC_ACT_AD        QTP_RXPRAM_REG(0x000C)
+#define QTP_RXTC_ACT_AD_WMASK  (0xFFFFFF)
+#define QTP_RXTC_ACT_AD_MASK   (0xFFFFFF)
+#define QTP_RXTC_ACT_AD_DEFAULT (0x0000)
+#define QTP_RXTC_ACT_AD_FMASK  (0xFFFFFF)
+#define QTP_RX_PRBS            QTP_RXPRAM_REG(0x0010)
+#define QTP_RX_PRBS_WMASK      (0xFFFFFFFF)
+#define QTP_RX_PRBS_MASK       (0xFFFFFFFF)
+#define QTP_RX_PRBS_DEFAULT    (0x0000)
+#define QTP_RX_PRBS_FMASK      (0xFFFFFFFF)
+#define QTP_RX_PRBS_MISC       QTP_RXPRAM_REG(0x0014)
+#define QTP_RX_PRBS_MISC_WMASK (0x7DF0)
+#define QTP_RX_PRBS_MISC_MASK  (0x7DF0)
+#define QTP_RX_PRBS_MISC_DEFAULT (0x0000)
+#define QTP_RX_PRBS_MISC_FMASK (0x7DF0)
+#define QTP_RX_PRBS_POLY       QTP_RXPRAM_REG(0x0018)
+#define QTP_RX_PRBS_POLY_WMASK (0xFFFFFFFF)
+#define QTP_RX_PRBS_POLY_MASK  (0xFFFFFFFF)
+#define QTP_RX_PRBS_POLY_DEFAULT (0x0000)
+#define QTP_RX_PRBS_POLY_FMASK (0xFFFFFFFF)
+#define QTP_RX_PRBS_OFFSET     QTP_RXPRAM_REG(0x001C)
+#define QTP_RX_PRBS_OFFSET_WMASK (0xFFF0FFF)
+#define QTP_RX_PRBS_OFFSET_MASK (0xFFF0FFF)
+#define QTP_RX_PRBS_OFFSET_DEFAULT (0x0000)
+#define QTP_RX_PRBS_OFFSET_FMASK (0xFFF0FFF)
+
+/* Vfdf Memory Address Constants */
+#define vfdf_decimco_base      (0x200000)
+#define vfdf_decimco_mask      (0xFFFFFFFF)
+#define vfdf_decimco_size      (0x0120)
+#define vfdf_decimco_default   (0x0000)
+#define vfdf_decimps_base      (0x200800)
+#define vfdf_decimps_mask      (0xFFFFFFFF)
+#define vfdf_decimps_size      (0x0220)
+#define vfdf_decimps_default   (0x0000)
+#define vfdf_rxwincops_base    (0x201000)
+#define vfdf_rxwincops_mask    (0xFFFFFFFF)
+#define vfdf_rxwincops_size    (0x0300)
+#define vfdf_rxwincops_default (0x0000)
+#define vfdf_txwincops_base    (0x201800)
+#define vfdf_txwincops_mask    (0xFFFFFFFF)
+#define vfdf_txwincops_size    (0x0480)
+#define vfdf_txwincops_default (0x0000)
+#define vfdf_dectdqps_base     (0x202000)
+#define vfdf_dectdqps_mask     (0xFFFFFFFF)
+#define vfdf_dectdqps_size     (0x0800)
+#define vfdf_dectdqps_default  (0x0000)
+#define vfdf_dectdqco_base     (0x202800)
+#define vfdf_dectdqco_mask     (0xFFFFFFFF)
+#define vfdf_dectdqco_size     (0x0600)
+#define vfdf_dectdqco_default  (0x0000)
+#define vfdf_txiir_co_base     (0x204000)
+#define vfdf_txiir_co_mask     (0x3FFFFF)
+#define vfdf_txiir_co_size     (0x007C)
+#define vfdf_txiir_co_default  (0x0000)
+#define vfdf_rxiir_co_base     (0x204100)
+#define vfdf_rxiir_co_mask     (0x3FFFF)
+#define vfdf_rxiir_co_size     (0x007C)
+#define vfdf_rxiir_co_default  (0x0000)
+#define vfdf_interpco_base     (0x204400)
+#define vfdf_interpco_mask     (0xFFFFFFFF)
+#define vfdf_interpco_size     (0x0200)
+#define vfdf_interpco_default  (0x0000)
+#define vfdf_decadapt_base     (0x204800)
+#define vfdf_decadapt_mask     (0xFFFFFFFF)
+#define vfdf_decadapt_size     (0x0800)
+#define vfdf_decadapt_default  (0x0000)
+#define vfdf_srcco_b00_rx_base (0x205000)
+#define vfdf_srcco_b00_rx_mask (0x1FFF0FF)
+#define vfdf_srcco_b00_rx_size (0x0800)
+#define vfdf_srcco_b00_rx_default (0x0000)
+#define vfdf_srcco_b01_rx_base (0x205800)
+#define vfdf_srcco_b01_rx_mask (0x3FFF1FF)
+#define vfdf_srcco_b01_rx_size (0x0800)
+#define vfdf_srcco_b01_rx_default (0x0000)
+#define vfdf_srcco_b02_rx_base (0x206000)
+#define vfdf_srcco_b02_rx_mask (0x1FFFF7FF)
+#define vfdf_srcco_b02_rx_size (0x0800)
+#define vfdf_srcco_b02_rx_default (0x0000)
+#define vfdf_srcco_b12_rx_base (0x206800)
+#define vfdf_srcco_b12_rx_mask (0x1FFFF7FF)
+#define vfdf_srcco_b12_rx_size (0x0800)
+#define vfdf_srcco_b12_rx_default (0x0000)
+#define vfdf_srcco_b11_rx_base (0x207000)
+#define vfdf_srcco_b11_rx_mask (0x3FFF1FF)
+#define vfdf_srcco_b11_rx_size (0x0800)
+#define vfdf_srcco_b11_rx_default (0x0000)
+#define vfdf_srcco_b10_rx_base (0x207800)
+#define vfdf_srcco_b10_rx_mask (0x1FFF0FF)
+#define vfdf_srcco_b10_rx_size (0x0800)
+#define vfdf_srcco_b10_rx_default (0x0000)
+#define vfdf_srcco_b00_tx_base (0x208000)
+#define vfdf_srcco_b00_tx_mask (0x1FFF0FF)
+#define vfdf_srcco_b00_tx_size (0x0800)
+#define vfdf_srcco_b00_tx_default (0x0000)
+#define vfdf_srcco_b01_tx_base (0x208800)
+#define vfdf_srcco_b01_tx_mask (0x3FFF1FF)
+#define vfdf_srcco_b01_tx_size (0x0800)
+#define vfdf_srcco_b01_tx_default (0x0000)
+#define vfdf_srcco_b02_tx_base (0x209000)
+#define vfdf_srcco_b02_tx_mask (0x1FFFF7FF)
+#define vfdf_srcco_b02_tx_size (0x0800)
+#define vfdf_srcco_b02_tx_default (0x0000)
+#define vfdf_srcco_b12_tx_base (0x209800)
+#define vfdf_srcco_b12_tx_mask (0x1FFFF7FF)
+#define vfdf_srcco_b12_tx_size (0x0800)
+#define vfdf_srcco_b12_tx_default (0x0000)
+#define vfdf_srcco_b11_tx_base (0x20A000)
+#define vfdf_srcco_b11_tx_mask (0x3FFF1FF)
+#define vfdf_srcco_b11_tx_size (0x0800)
+#define vfdf_srcco_b11_tx_default (0x0000)
+#define vfdf_srcco_b10_tx_base (0x20A800)
+#define vfdf_srcco_b10_tx_mask (0x1FFF0FF)
+#define vfdf_srcco_b10_tx_size (0x0800)
+#define vfdf_srcco_b10_tx_default (0x0000)
+
+/* Vfdf Global Address Constants */
+#define vfdf_global_base       (0x20C600)
+#define VFDF_GLOBAL(r)         (int)(vfdf_global_base + (r))
+#define vfdf_global_size       (0x0200)
+
+#define V_CONTROL              VFDF_GLOBAL(0x0000)
+#define V_CONTROL_WMASK        (0xDFFFC803)
+#define V_CONTROL_MASK         (0xDFFFCA03)
+#define V_CONTROL_DEFAULT      (0x50000000)
+#define V_CONTROL_FMASK        (0xDFFFC803)
+#define V_BLOCK_RSTN           VFDF_GLOBAL(0x0004)
+#define V_BLOCK_RSTN_WMASK     (0x0077)
+#define V_BLOCK_RSTN_MASK      (0x0077)
+#define V_BLOCK_RSTN_DEFAULT   (0x0077)
+#define V_BLOCK_RSTN_FMASK     (0x0077)
+#define V_OVERFLOW             VFDF_GLOBAL(0x0008)
+#define V_OVERFLOW_WMASK       (0x1FEBF)
+#define V_OVERFLOW_MASK        (0x1FEBF)
+#define V_OVERFLOW_DEFAULT     (0x0000)
+#define V_OVERFLOW_FMASK       (0x0000)
+#define V_TXIIR1_CFG           VFDF_GLOBAL(0x000C)
+#define V_TXIIR1_CFG_WMASK     (0x1F7FFFF)
+#define V_TXIIR1_CFG_MASK      (0x1F7FFFF)
+#define V_TXIIR1_CFG_DEFAULT   (0x0000)
+#define V_TXIIR1_CFG_FMASK     (0x1F7FFFF)
+#define V_TXIIR2_CFG           VFDF_GLOBAL(0x0010)
+#define V_TXIIR2_CFG_WMASK     (0xF00FF)
+#define V_TXIIR2_CFG_MASK      (0xF00FF)
+#define V_TXIIR2_CFG_DEFAULT   (0x0000)
+#define V_TXIIR2_CFG_FMASK     (0xF00FF)
+#define V_RXIIR1_CFG           VFDF_GLOBAL(0x0014)
+#define V_RXIIR1_CFG_WMASK     (0x1F7FFFF)
+#define V_RXIIR1_CFG_MASK      (0x1F7FFFF)
+#define V_RXIIR1_CFG_DEFAULT   (0x0000)
+#define V_RXIIR1_CFG_FMASK     (0x1F7FFFF)
+#define V_RXIIR2_CFG           VFDF_GLOBAL(0x0018)
+#define V_RXIIR2_CFG_WMASK     (0xF00FF)
+#define V_RXIIR2_CFG_MASK      (0xF00FF)
+#define V_RXIIR2_CFG_DEFAULT   (0x0000)
+#define V_RXIIR2_CFG_FMASK     (0xF00FF)
+#define V_INTERP_CFG           VFDF_GLOBAL(0x001C)
+#define V_INTERP_CFG_WMASK     (0xF0F21F07)
+#define V_INTERP_CFG_MASK      (0xF0F21F07)
+#define V_INTERP_CFG_DEFAULT   (0x80020000)
+#define V_INTERP_CFG_FMASK     (0xF0F21F07)
+#define V_DECIM_CFG            VFDF_GLOBAL(0x0020)
+#define V_DECIM_CFG_WMASK      (0xFFF13F1F)
+#define V_DECIM_CFG_MASK       (0xFFF13F1F)
+#define V_DECIM_CFG_DEFAULT    (0x80000000)
+#define V_DECIM_CFG_FMASK      (0xFFF13F1F)
+#define V_DEC_CFG              VFDF_GLOBAL(0x0024)
+#define V_DEC_CFG_WMASK        (0xFF3F7F7F)
+#define V_DEC_CFG_MASK         (0xFF3F7F7F)
+#define V_DEC_CFG_DEFAULT      (0x0000)
+#define V_DEC_CFG_FMASK        (0xFF3F7F7F)
+#define V_TDQ_CFG              VFDF_GLOBAL(0x0028)
+#define V_TDQ_CFG_WMASK        (0x2FE001E0)
+#define V_TDQ_CFG_MASK         (0x2FE001E0)
+#define V_TDQ_CFG_DEFAULT      (0x0000)
+#define V_TDQ_CFG_FMASK        (0x2FE001E0)
+#define V_DEC_CAPTURE          VFDF_GLOBAL(0x002C)
+#define V_DEC_CAPTURE_WMASK    (0x700007FE)
+#define V_DEC_CAPTURE_MASK     (0x7FFFFFFE)
+#define V_DEC_CAPTURE_DEFAULT  (0x1800)
+#define V_DEC_CAPTURE_FMASK    (0x7FFFFFFE)
+#define V_ADAPT_CTRL           VFDF_GLOBAL(0x0030)
+#define V_ADAPT_CTRL_WMASK     (0x0EE6)
+#define V_ADAPT_CTRL_MASK      (0x0EEF)
+#define V_ADAPT_CTRL_DEFAULT   (0x0000)
+#define V_ADAPT_CTRL_FMASK     (0x0EEE)
+#define V_TX_VARGAIN           VFDF_GLOBAL(0x0034)
+#define V_TX_VARGAIN_WMASK     (0xFFFFF)
+#define V_TX_VARGAIN_MASK      (0xFFFFF)
+#define V_TX_VARGAIN_DEFAULT   (0x0000)
+#define V_TX_VARGAIN_FMASK     (0xFFFFF)
+#define V_TX_AVARGAIN          VFDF_GLOBAL(0x0038)
+#define V_TX_AVARGAIN_WMASK    (0xFFFFF)
+#define V_TX_AVARGAIN_MASK     (0xFFFFF)
+#define V_TX_AVARGAIN_DEFAULT  (0x0000)
+#define V_TX_AVARGAIN_FMASK    (0xFFFFF)
+#define V_RX_VARGAIN           VFDF_GLOBAL(0x003C)
+#define V_RX_VARGAIN_WMASK     (0x7FFFF)
+#define V_RX_VARGAIN_MASK      (0x7FFFF)
+#define V_RX_VARGAIN_DEFAULT   (0x0000)
+#define V_RX_VARGAIN_FMASK     (0x7FFFF)
+#define V_RX_AVARGAIN          VFDF_GLOBAL(0x0040)
+#define V_RX_AVARGAIN_WMASK    (0x7FFFF)
+#define V_RX_AVARGAIN_MASK     (0x7FFFF)
+#define V_RX_AVARGAIN_DEFAULT  (0x0000)
+#define V_RX_AVARGAIN_FMASK    (0x7FFFF)
+#define V_ADC_ADJUST           VFDF_GLOBAL(0x0044)
+#define V_ADC_ADJUST_WMASK     (0xFFFFF)
+#define V_ADC_ADJUST_MASK      (0xFFFFF)
+#define V_ADC_ADJUST_DEFAULT   (0x0000)
+#define V_ADC_ADJUST_FMASK     (0xFFFFF)
+#define V_FRAME_SKEW           VFDF_GLOBAL(0x0048)
+#define V_FRAME_SKEW_WMASK     (0x1000000)
+#define V_FRAME_SKEW_MASK      (0x100FFFF)
+#define V_FRAME_SKEW_DEFAULT   (0x0000)
+#define V_FRAME_SKEW_FMASK     (0xFFFF)
+#define V_TX_EXTEN             VFDF_GLOBAL(0x004C)
+#define V_TX_EXTEN_WMASK       (0x17FFFFFF)
+#define V_TX_EXTEN_MASK        (0x17FFFFFF)
+#define V_TX_EXTEN_DEFAULT     (0x0000)
+#define V_TX_EXTEN_FMASK       (0x17FFFFFF)
+#define V_TX_EXTEN_A           VFDF_GLOBAL(0x0050)
+#define V_TX_EXTEN_A_WMASK     (0x17FFFFFF)
+#define V_TX_EXTEN_A_MASK      (0x17FFFFFF)
+#define V_TX_EXTEN_A_DEFAULT   (0x0000)
+#define V_TX_EXTEN_A_FMASK     (0x17FFFFFF)
+#define V_TX_BETA              VFDF_GLOBAL(0x0054)
+#define V_TX_BETA_WMASK        (0x01FF)
+#define V_TX_BETA_MASK         (0x01FF)
+#define V_TX_BETA_DEFAULT      (0x0000)
+#define V_TX_BETA_FMASK        (0x01FF)
+#define V_TX_BETA_A            VFDF_GLOBAL(0x0058)
+#define V_TX_BETA_A_WMASK      (0x01FF)
+#define V_TX_BETA_A_MASK       (0x01FF)
+#define V_TX_BETA_A_DEFAULT    (0x0000)
+#define V_TX_BETA_A_FMASK      (0x01FF)
+#define V_TX_FSIZE             VFDF_GLOBAL(0x005C)
+#define V_TX_FSIZE_WMASK       (0xF3FFF)
+#define V_TX_FSIZE_MASK        (0xF3FFF)
+#define V_TX_FSIZE_DEFAULT     (0x0000)
+#define V_TX_FSIZE_FMASK       (0xF3FFF)
+#define V_TX_FSIZE_A           VFDF_GLOBAL(0x0060)
+#define V_TX_FSIZE_A_WMASK     (0xF3FFF)
+#define V_TX_FSIZE_A_MASK      (0xF3FFF)
+#define V_TX_FSIZE_A_DEFAULT   (0x0000)
+#define V_TX_FSIZE_A_FMASK     (0xF3FFF)
+#define V_FSOFFSET_IN          VFDF_GLOBAL(0x0064)
+#define V_FSOFFSET_IN_WMASK    (0x3FFF)
+#define V_FSOFFSET_IN_MASK     (0x3FFF)
+#define V_FSOFFSET_IN_DEFAULT  (0x0000)
+#define V_FSOFFSET_IN_FMASK    (0x3FFF)
+#define V_FSOFFSET_ER          VFDF_GLOBAL(0x0068)
+#define V_FSOFFSET_ER_WMASK    (0x3FFF)
+#define V_FSOFFSET_ER_MASK     (0x3FFF)
+#define V_FSOFFSET_ER_DEFAULT  (0x0000)
+#define V_FSOFFSET_ER_FMASK    (0x3FFF)
+#define V_RX_EXTEN             VFDF_GLOBAL(0x006C)
+#define V_RX_EXTEN_WMASK       (0xFFFFFFF)
+#define V_RX_EXTEN_MASK        (0xFFFFFFF)
+#define V_RX_EXTEN_DEFAULT     (0x0000)
+#define V_RX_EXTEN_FMASK       (0xFFFFFFF)
+#define V_RX_EXTEN_A           VFDF_GLOBAL(0x0070)
+#define V_RX_EXTEN_A_WMASK     (0xFFFFFFF)
+#define V_RX_EXTEN_A_MASK      (0xFFFFFFF)
+#define V_RX_EXTEN_A_DEFAULT   (0x0000)
+#define V_RX_EXTEN_A_FMASK     (0xFFFFFFF)
+#define V_RX_WSIZE             VFDF_GLOBAL(0x0074)
+#define V_RX_WSIZE_WMASK       (0x01FF)
+#define V_RX_WSIZE_MASK        (0x01FF)
+#define V_RX_WSIZE_DEFAULT     (0x0000)
+#define V_RX_WSIZE_FMASK       (0x01FF)
+#define V_RX_WSIZE_A           VFDF_GLOBAL(0x0078)
+#define V_RX_WSIZE_A_WMASK     (0x01FF)
+#define V_RX_WSIZE_A_MASK      (0x01FF)
+#define V_RX_WSIZE_A_DEFAULT   (0x0000)
+#define V_RX_WSIZE_A_FMASK     (0x01FF)
+#define V_RX_FSIZE             VFDF_GLOBAL(0x007C)
+#define V_RX_FSIZE_WMASK       (0xF3FFF)
+#define V_RX_FSIZE_MASK        (0xF3FFF)
+#define V_RX_FSIZE_DEFAULT     (0x0000)
+#define V_RX_FSIZE_FMASK       (0xF3FFF)
+#define V_RX_FSIZE_A           VFDF_GLOBAL(0x0080)
+#define V_RX_FSIZE_A_WMASK     (0xF3FFF)
+#define V_RX_FSIZE_A_MASK      (0xF3FFF)
+#define V_RX_FSIZE_A_DEFAULT   (0x0000)
+#define V_RX_FSIZE_A_FMASK     (0xF3FFF)
+#define V_SERDES_XBAR          VFDF_GLOBAL(0x0084)
+#define V_SERDES_XBAR_WMASK    (0x0301)
+#define V_SERDES_XBAR_MASK     (0x0301)
+#define V_SERDES_XBAR_DEFAULT  (0x0000)
+#define V_SERDES_XBAR_FMASK    (0x0301)
+#define V_SRCFR                VFDF_GLOBAL(0x0088)
+#define V_SRCFR_WMASK          (0xFFFFF)
+#define V_SRCFR_MASK           (0xFFFFF)
+#define V_SRCFR_DEFAULT        (0x0000)
+#define V_SRCFR_FMASK          (0xFFFFF)
+#define V_SRCCTL               VFDF_GLOBAL(0x008C)
+#define V_SRCCTL_WMASK         (0xFFFFFF)
+#define V_SRCCTL_MASK          (0xFFFFFF)
+#define V_SRCCTL_DEFAULT       (0x0000)
+#define V_SRCCTL_FMASK         (0xFFFFFF)
+#define V_SRC_CFG              VFDF_GLOBAL(0x0090)
+#define V_SRC_CFG_WMASK        (0xC0F3007F)
+#define V_SRC_CFG_MASK         (0xC0F3007F)
+#define V_SRC_CFG_DEFAULT      (0x0000)
+#define V_SRC_CFG_FMASK        (0xC0F3007F)
+#define V_HBFILT_CFG           VFDF_GLOBAL(0x0094)
+#define V_HBFILT_CFG_WMASK     (0xF0F10000)
+#define V_HBFILT_CFG_MASK      (0xF0F10000)
+#define V_HBFILT_CFG_DEFAULT   (0x0000)
+#define V_HBFILT_CFG_FMASK     (0xF0F10000)
+#define V_AFE_SERIAL_CFG       VFDF_GLOBAL(0x0098)
+#define V_AFE_SERIAL_CFG_WMASK (0x800FFFFF)
+#define V_AFE_SERIAL_CFG_MASK  (0xC00FFFFF)
+#define V_AFE_SERIAL_CFG_DEFAULT (0x0010)
+#define V_AFE_SERIAL_CFG_FMASK (0x400FFFFF)
+#define V_AFE_SERIAL_ADDR      VFDF_GLOBAL(0x009C)
+#define V_AFE_SERIAL_ADDR_WMASK (0x3FFF)
+#define V_AFE_SERIAL_ADDR_MASK (0x3FFF)
+#define V_AFE_SERIAL_ADDR_DEFAULT (0x0000)
+#define V_AFE_SERIAL_ADDR_FMASK (0x3FFF)
+#define V_AFE_SERIAL_WDATA     VFDF_GLOBAL(0x00A0)
+#define V_AFE_SERIAL_WDATA_WMASK (0xFFFF)
+#define V_AFE_SERIAL_WDATA_MASK (0xFFFF)
+#define V_AFE_SERIAL_WDATA_DEFAULT (0x0000)
+#define V_AFE_SERIAL_WDATA_FMASK (0xFFFF)
+#define V_AFE_SERIAL_RDATA     VFDF_GLOBAL(0x00A4)
+#define V_AFE_SERIAL_RDATA_WMASK (0x0000)
+#define V_AFE_SERIAL_RDATA_MASK (0xFFFF)
+#define V_AFE_SERIAL_RDATA_DEFAULT (0x0000)
+#define V_AFE_SERIAL_RDATA_FMASK (0xFFFF)
+
+// Framer/Coder/Interleaver
+#define ADSL_ILV_BASE (ADSL_BASE+0x0C000)
+#define ADSL_ILV_SIZE 1248*4
+#define ADSL_RX_FB_BASE (ADSL_BASE+0x0E000)
+#define ADSL_RX_FB_SIZE 512
+#define ADSL_TX_FB_BASE (ADSL_BASE+0x0E800)
+#define ADSL_TX_FB_SIZE 256
+#define ADSL_RX_CW_BASE (ADSL_BASE+0x0EC00)
+#define ADSL_RX_CW_SIZE 256*2
+#define ADSL_RS_RM_BASE (ADSL_BASE+0x10000)
+#define ADSL_RS_RM_SIZE 512
+
+#define ADSL_DILV_BASE (ADSL_BASE+0x20000)
+#define ADSL_DILV_SIZE 5120*4
+
+// Iridia Registers
+#define ADSL_IFFTA_BASE (ADSL_BASE+0x12400)
+#define ADSL_IFFTA_SIZE 64*4
+#define ADSL_IFFTB_BASE (ADSL_BASE+0x12600)
+#define ADSL_IFFTB_SIZE 64*4
+#define ADSL_FFTA_BASE (ADSL_BASE+0x12800)
+#define ADSL_FFTA_SIZE 512*4
+#define ADSL_FFTB_BASE (ADSL_BASE+0x13000)
+#define ADSL_FFTB_SIZE 512*4
+#define ADSL_FFTC_BASE (ADSL_BASE+0x13800)
+#define ADSL_FFTC_SIZE 512*4
+
+#define ADSL_FDQ_M_BASE   (ADSL_BASE+0x14000)
+#define ADSL_FDQ_M_SIZE   512*4
+#define ADSL_FDQ_E_BASE   (ADSL_BASE+0x15000)
+#define ADSL_FDQ_E_SIZE   128*4
+#define ADSL_REV_S_BASE   (ADSL_BASE+0x15200)
+#define ADSL_REV_S_SIZE   128*4
+#define ADSL_XY_FIFO_BASE (ADSL_BASE+0x15C00)
+#define ADSL_XY_FIFO_SIZE 400                 // 160 * 20 bytes
+
+#define ADSL_RX_GAIN_BASE (ADSL_BASE+0x16000)
+#define ADSL_RX_GAIN_SIZE 1024*2
+
+// Filter Address Space
+#define ADSL_DEC_SUM_BASE (ADSL_BASE+0x1D000)
+#define ADSL_DEC_SUM_SIZE 128*2
+#define ADSL_DEC_PS_BASE  (ADSL_BASE+0x1D200)
+#define ADSL_DEC_PS_SIZE  128*2
+#define ADSL_DECCO_BASE   (ADSL_BASE+0x1D800)
+#define ADSL_DECCO_SIZE   128*2
+
+/* AEC Global Address Constants */
+#define aec_global_base       (0x20D000)
+#define AEC_GLOBAL(r)         (int)(aec_global_base+(r))
+#define aec_global_size       (0x0100)
+
+#define AEC_PROG_DLY_CTRL                        AEC_GLOBAL(0x00)
+#define AEC_PROG_DLY_CTRL_WMASK                  (0x000000f3)
+#define AEC_PROG_DLY_CTRL_MASK                   (0x000000f3)
+#define AEC_PROG_DLY_CTRL_DEFAULT                (0x00000001)
+#define AEC_PROG_DLY_CTRL_FMASK                  (0x000000f3)
+#define AEC_PROG_FIR_CTRL                        AEC_GLOBAL(0x04)
+#define AEC_PROG_FIR_CTRL_WMASK                  (0x00003f13)
+#define AEC_PROG_FIR_CTRL_MASK                   (0x00003f13)
+#define AEC_PROG_FIR_CTRL_DEFAULT                (0x00000001)
+#define AEC_PROG_FIR_CTRL_FMASK                  (0x00003f13)
+#define AEC_HP_CTRL                              AEC_GLOBAL(0x08)
+#define AEC_HP_CTRL_WMASK                        (0x00000f13)
+#define AEC_HP_CTRL_MASK                         (0x00000f13)
+#define AEC_HP_CTRL_DEFAULT                      (0x00000601)
+#define AEC_HP_CTRL_FMASK                        (0x00000f13)
+#define AEC_STATUS                               AEC_GLOBAL(0x0C)
+#define AEC_STATUS_WMASK                         (0x00010101)
+#define AEC_STATUS_MASK                          (0x00010101)
+#define AEC_STATUS_DEFAULT                       (0x00000000)
+#define AEC_STATUS_FMASK                         (0x00010101)
+#define AEC_PROG_FIR_COEFF_3_0                   AEC_GLOBAL(0x10)
+#define AEC_PROG_FIR_COEFF_3_0_WMASK             (0xffffffff)
+#define AEC_PROG_FIR_COEFF_3_0_MASK              (0xffffffff)
+#define AEC_PROG_FIR_COEFF_3_0_DEFAULT           (0x00000000)
+#define AEC_PROG_FIR_COEFF_3_0_FMASK             (0xffffffff)
+#define AEC_PROG_FIR_COEFF_7_4                   AEC_GLOBAL(0x14)
+#define AEC_PROG_FIR_COEFF_7_4_WMASK             (0xffffffff)
+#define AEC_PROG_FIR_COEFF_7_4_MASK              (0xffffffff)
+#define AEC_PROG_FIR_COEFF_7_4_DEFAULT           (0x00000000)
+#define AEC_PROG_FIR_COEFF_7_4_FMASK             (0xffffffff)
+#define AEC_PROG_FIR_COEFF_B_8                   AEC_GLOBAL(0x18)
+#define AEC_PROG_FIR_COEFF_B_8_WMASK             (0xffffffff)
+#define AEC_PROG_FIR_COEFF_B_8_MASK              (0xffffffff)
+#define AEC_PROG_FIR_COEFF_B_8_DEFAULT           (0x00000000)
+#define AEC_PROG_FIR_COEFF_B_8_FMASK             (0xffffffff)
+#define AEC_PROG_FIR_COEFF_F_C                   AEC_GLOBAL(0x1C)
+#define AEC_PROG_FIR_COEFF_F_C_WMASK             (0xffffffff)
+#define AEC_PROG_FIR_COEFF_F_C_MASK              (0xffffffff)
+#define AEC_PROG_FIR_COEFF_F_C_DEFAULT           (0x00000000)
+#define AEC_PROG_FIR_COEFF_F_C_FMASK             (0xffffffff)
+#define AEC_AFIR_CTRL                            AEC_GLOBAL(0x000024)
+#define AEC_AFIR_CTRL_WMASK                      (0x000000ff)
+#define AEC_AFIR_CTRL_MASK                       (0x000000ff)
+#define AEC_AFIR_CTRL_DEFAULT                    (0x00000000)
+#define AEC_AFIR_CTRL_FMASK                      (0x000000ff)
+#define AEC_AFIR_CFG                             AEC_GLOBAL(0x000028)
+#define AEC_AFIR_CFG_WMASK                       (0x000001ff)
+#define AEC_AFIR_CFG_MASK                        (0x000001ff)
+#define AEC_AFIR_CFG_DEFAULT                     (0x00000080)
+#define AEC_AFIR_CFG_FMASK                       (0x000001ff)
+#define AEC_AFIR_CFRD                            AEC_GLOBAL(0x00002C)
+#define AEC_AFIR_CFRD_WMASK                      (0x0000ffff)
+#define AEC_AFIR_CFRD_MASK                       (0x0000ffff)
+#define AEC_AFIR_CFRD_DEFAULT                    (0x00000000)
+#define AEC_AFIR_CFRD_FMASK                      (0x0000ffff)
+#define AEC_AFIR_CFWR                            AEC_GLOBAL(0x000030)
+#define AEC_AFIR_CFWR_WMASK                      (0x0000ffff)
+#define AEC_AFIR_CFWR_MASK                       (0x0000ffff)
+#define AEC_AFIR_CFWR_DEFAULT                    (0x00000000)
+#define AEC_AFIR_CFWR_FMASK                      (0x0000ffff)
+#define AEC_AFIR_CFADDR                          AEC_GLOBAL(0x000034)
+#define AEC_AFIR_CFADDR_WMASK                    (0x000000ff)
+#define AEC_AFIR_CFADDR_MASK                     (0x000000ff)
+#define AEC_AFIR_CFADDR_DEFAULT                  (0x00000000)
+#define AEC_AFIR_CFADDR_FMASK                    (0x000000ff)
+#define AEC_AFIR_MDLLCTL                         AEC_GLOBAL(0x000038)
+#define AEC_AFIR_MDLLCTL_WMASK                   (0x0000000f)
+#define AEC_AFIR_MDLLCTL_MASK                    (0x0000000f)
+#define AEC_AFIR_MDLLCTL_DEFAULT                 (0x00000007)
+#define AEC_AFIR_MDLLCTL_FMASK                   (0x0000000f)
+#define AEC_AFIR_MDLLSTAT                        AEC_GLOBAL(0x00003C)
+#define AEC_AFIR_MDLLSTAT_WMASK                  (0x00000001)
+#define AEC_AFIR_MDLLSTAT_MASK                   (0x00000001)
+#define AEC_AFIR_MDLLSTAT_DEFAULT                (0x00000000)
+#define AEC_AFIR_MDLLSTAT_FMASK                  (0x00000001)
+#define AEC_AFIR_CTRL2                           AEC_GLOBAL(0x000040)
+#define AEC_AFIR_CTRL2_WMASK                     (0x00000003)
+#define AEC_AFIR_CTRL2_MASK                      (0x00000003)
+#define AEC_AFIR_CTRL2_DEFAULT                   (0x00000000)
+#define AEC_AFIR_CTRL2_FMASK                     (0x00000003)
+#define AEC_AFIR_CNT_UPDATE                      AEC_GLOBAL(0x000044)
+#define AEC_AFIR_CNT_UPDATE_WMASK                (0x000000ff)
+#define AEC_AFIR_CNT_UPDATE_MASK                 (0x000000ff)
+#define AEC_AFIR_CNT_UPDATE_DEFAULT              (0x00000000)
+#define AEC_AFIR_CNT_UPDATE_FMASK                (0x000000ff)
+#define AEC_AFIR_CNT_LEAKY                       AEC_GLOBAL(0x000048)
+#define AEC_AFIR_CNT_LEAKY_WMASK                 (0x0000ffff)
+#define AEC_AFIR_CNT_LEAKY_MASK                  (0x0000ffff)
+#define AEC_AFIR_CNT_LEAKY_DEFAULT               (0x00000000)
+#define AEC_AFIR_CNT_LEAKY_FMASK                 (0x0000ffff)
+#define AEC_AFIR_CNT_STOP                        AEC_GLOBAL(0x00004C)
+#define AEC_AFIR_CNT_STOP_WMASK                  (0x0000ffff)
+#define AEC_AFIR_CNT_STOP_MASK                   (0x0000ffff)
+#define AEC_AFIR_CNT_STOP_DEFAULT                (0x00000000)
+#define AEC_AFIR_CNT_STOP_FMASK                  (0x0000ffff)
+
+
+/* DREG Global Address Constants */
+#define dreg_global_base       (0x20D400)
+#define DREG_GLOBAL(r)         (int)(dreg_global_base+(r))
+#define dreg_global_size       (0x0400)
+
+#define DREG_AT_CFG0_WMASK                       (0x0007ffff)
+#define DREG_AT_CFG0_MASK                        (0x0007ffff)
+#define DREG_AT_CFG0_DEFAULT                     (0x00000000)
+#define DREG_AT_CFG0_FMASK                       (0x0007ffff)
+#define DREG_AT_CFG1                             DREG_GLOBAL(0x0084)
+#define DREG_AT_CFG1_WMASK                       (0x0007ffff)
+#define DREG_AT_CFG1_MASK                        (0x0007ffff)
+#define DREG_AT_CFG1_DEFAULT                     (0x00000000)
+#define DREG_AT_CFG1_FMASK                       (0x0007ffff)
+#define DREG_AT_CELL0                            DREG_GLOBAL(0x0090)
+#define DREG_AT_CELL0_WMASK                      (0xffffffff)
+#define DREG_AT_CELL0_MASK                       (0xffffffff)
+#define DREG_AT_CELL0_DEFAULT                    (0x00000000)
+#define DREG_AT_CELL0_FMASK                      (0xffffffff)
+#define DREG_AT_CELL1                            DREG_GLOBAL(0x0094)
+#define DREG_AT_CELL1_WMASK                      (0xffffffff)
+#define DREG_AT_CELL1_MASK                       (0xffffffff)
+#define DREG_AT_CELL1_DEFAULT                    (0x00000000)
+#define DREG_AT_CELL1_FMASK                      (0xffffffff)
+#define DREG_AT_IDLE_CNT0                        DREG_GLOBAL(0x0098)
+#define DREG_AT_IDLE_CNT0_WMASK                  (0xffffffff)
+#define DREG_AT_IDLE_CNT0_MASK                   (0xffffffff)
+#define DREG_AT_IDLE_CNT0_DEFAULT                (0x00000000)
+#define DREG_AT_IDLE_CNT0_FMASK                  (0xffffffff)
+#define DREG_AT_IDLE_CNT1                        DREG_GLOBAL(0x009c)
+#define DREG_AT_IDLE_CNT1_WMASK                  (0xffffffff)
+#define DREG_AT_IDLE_CNT1_MASK                   (0xffffffff)
+#define DREG_AT_IDLE_CNT1_DEFAULT                (0x00000000)
+#define DREG_AT_IDLE_CNT1_FMASK                  (0xffffffff)
+#define DREG_AT_IDLE0                            DREG_GLOBAL(0x00a0)
+#define DREG_AT_IDLE0_WMASK                      (0x000000ff)
+#define DREG_AT_IDLE0_MASK                       (0x000000ff)
+#define DREG_AT_IDLE0_DEFAULT                    (0x0000006A)
+#define DREG_AT_IDLE0_FMASK                      (0x000000ff)
+#define DREG_AT_IDLE1                            DREG_GLOBAL(0x00a4)
+#define DREG_AT_IDLE1_WMASK                      (0x000000ff)
+#define DREG_AT_IDLE1_MASK                       (0x000000ff)
+#define DREG_AT_IDLE1_DEFAULT                    (0x0000006A)
+#define DREG_AT_IDLE1_FMASK                      (0x000000ff)
+#define DREG_AR_CFG0                             DREG_GLOBAL(0x0180)
+#define DREG_AR_CFG0_WMASK                       (0x0007ffff)
+#define DREG_AR_CFG0_MASK                        (0x0007ffff)
+#define DREG_AR_CFG0_DEFAULT                     (0x00000000)
+#define DREG_AR_CFG0_FMASK                       (0x0007ffff)
+#define DREG_AR_CFG1                             DREG_GLOBAL(0x0184)
+#define DREG_AR_CFG1_WMASK                       (0x0007ffff)
+#define DREG_AR_CFG1_MASK                        (0x0007ffff)
+#define DREG_AR_CFG1_DEFAULT                     (0x00000000)
+#define DREG_AR_CFG1_FMASK                       (0x0007ffff)
+#define DREG_AR_STAT0                            DREG_GLOBAL(0x0198)
+#define DREG_AR_STAT0_WMASK                      (0x0000003f)
+#define DREG_AR_STAT0_MASK                       (0x0000003f)
+#define DREG_AR_STAT0_DEFAULT                    (0x00000000)
+#define DREG_AR_STAT0_FMASK                      (0x0000003f)
+#define DREG_AR_STAT1                            DREG_GLOBAL(0x019c)
+#define DREG_AR_STAT1_WMASK                      (0x0000003f)
+#define DREG_AR_STAT1_MASK                       (0x0000003f)
+#define DREG_AR_STAT1_DEFAULT                    (0x00000000)
+#define DREG_AR_STAT1_FMASK                      (0x0000003f)
+#define DREG_AR_CELL0                            DREG_GLOBAL(0x01a0)
+#define DREG_AR_CELL0_WMASK                      (0xffffffff)
+#define DREG_AR_CELL0_MASK                       (0xffffffff)
+#define DREG_AR_CELL0_DEFAULT                    (0x00000000)
+#define DREG_AR_CELL0_FMASK                      (0xffffffff)
+#define DREG_AR_CELL1                            DREG_GLOBAL(0x01a4)
+#define DREG_AR_CELL1_WMASK                      (0xffffffff)
+#define DREG_AR_CELL1_MASK                       (0xffffffff)
+#define DREG_AR_CELL1_DEFAULT                    (0x00000000)
+#define DREG_AR_CELL1_FMASK                      (0xffffffff)
+#define DREG_AR_IDLE_CNT0                        DREG_GLOBAL(0x01a8)
+#define DREG_AR_IDLE_CNT0_WMASK                  (0xffffffff)
+#define DREG_AR_IDLE_CNT0_MASK                   (0xffffffff)
+#define DREG_AR_IDLE_CNT0_DEFAULT                (0x00000000)
+#define DREG_AR_IDLE_CNT0_FMASK                  (0xffffffff)
+#define DREG_AR_IDLE_CNT1                        DREG_GLOBAL(0x01ac)
+#define DREG_AR_IDLE_CNT1_WMASK                  (0xffffffff)
+#define DREG_AR_IDLE_CNT1_MASK                   (0xffffffff)
+#define DREG_AR_IDLE_CNT1_DEFAULT                (0x00000000)
+#define DREG_AR_IDLE_CNT1_FMASK                  (0xffffffff)
+#define DREG_AR_AIIDLE_CNT0                      DREG_GLOBAL(0x01b0)
+#define DREG_AR_AIIDLE_CNT0_WMASK                (0xffffffff)
+#define DREG_AR_AIIDLE_CNT0_MASK                 (0xffffffff)
+#define DREG_AR_AIIDLE_CNT0_DEFAULT              (0x00000000)
+#define DREG_AR_AIIDLE_CNT0_FMASK                (0xffffffff)
+#define DREG_AR_AIIDLE_CNT1                      DREG_GLOBAL(0x01b4)
+#define DREG_AR_AIIDLE_CNT1_WMASK                (0xffffffff)
+#define DREG_AR_AIIDLE_CNT1_MASK                 (0xffffffff)
+#define DREG_AR_AIIDLE_CNT1_DEFAULT              (0x00000000)
+#define DREG_AR_AIIDLE_CNT1_FMASK                (0xffffffff)
+#define DREG_AR_BE_CNT0                          DREG_GLOBAL(0x01b8)
+#define DREG_AR_BE_CNT0_WMASK                    (0xffffffff)
+#define DREG_AR_BE_CNT0_MASK                     (0xffffffff)
+#define DREG_AR_BE_CNT0_DEFAULT                  (0x00000000)
+#define DREG_AR_BE_CNT0_FMASK                    (0xffffffff)
+#define DREG_AR_BE_CNT1                          DREG_GLOBAL(0x01bc)
+#define DREG_AR_BE_CNT1_WMASK                    (0xffffffff)
+#define DREG_AR_BE_CNT1_MASK                     (0xffffffff)
+#define DREG_AR_BE_CNT1_DEFAULT                  (0x00000000)
+#define DREG_AR_BE_CNT1_FMASK                    (0xffffffff)
+#define DREG_AR_HEC_CNT0                         DREG_GLOBAL(0x01c0)
+#define DREG_AR_HEC_CNT0_WMASK                   (0xffffffff)
+#define DREG_AR_HEC_CNT0_MASK                    (0xffffffff)
+#define DREG_AR_HEC_CNT0_DEFAULT                 (0x00000000)
+#define DREG_AR_HEC_CNT0_FMASK                   (0xffffffff)
+#define DREG_AR_HEC_CNT1                         DREG_GLOBAL(0x01c4)
+#define DREG_AR_HEC_CNT1_WMASK                   (0xffffffff)
+#define DREG_AR_HEC_CNT1_MASK                    (0xffffffff)
+#define DREG_AR_HEC_CNT1_DEFAULT                 (0x00000000)
+#define DREG_AR_HEC_CNT1_FMASK                   (0xffffffff)
+#define DREG_AR_CD_CNT0                          DREG_GLOBAL(0x01c8)
+#define DREG_AR_CD_CNT0_WMASK                    (0xffffffff)
+#define DREG_AR_CD_CNT0_MASK                     (0xffffffff)
+#define DREG_AR_CD_CNT0_DEFAULT                  (0x00000000)
+#define DREG_AR_CD_CNT0_FMASK                    (0xffffffff)
+#define DREG_AR_CD_CNT1                          DREG_GLOBAL(0x01cc)
+#define DREG_AR_CD_CNT1_WMASK                    (0xffffffff)
+#define DREG_AR_CD_CNT1_MASK                     (0xffffffff)
+#define DREG_AR_CD_CNT1_DEFAULT                  (0x00000000)
+#define DREG_AR_CD_CNT1_FMASK                    (0xffffffff)
+#define DREG_AR_IDLE0                            DREG_GLOBAL(0x01d0)
+#define DREG_AR_IDLE0_WMASK                      (0x000000ff)
+#define DREG_AR_IDLE0_MASK                       (0x000000ff)
+#define DREG_AR_IDLE0_DEFAULT                    (0x0000006A)
+#define DREG_AR_IDLE0_FMASK                      (0x000000ff)
+#define DREG_AR_IDLE1                            DREG_GLOBAL(0x01d4)
+#define DREG_AR_IDLE1_WMASK                      (0x000000ff)
+#define DREG_AR_IDLE1_MASK                       (0x000000ff)
+#define DREG_AR_IDLE1_DEFAULT                    (0x0000006A)
+#define DREG_AR_IDLE1_FMASK                      (0x000000ff)
+#define DREG_AR_DELIN0                           DREG_GLOBAL(0x01d8)
+#define DREG_AR_DELIN0_WMASK                     (0x000000ff)
+#define DREG_AR_DELIN0_MASK                      (0x000000ff)
+#define DREG_AR_DELIN0_DEFAULT                   (0x00000011)
+#define DREG_AR_DELIN0_FMASK                     (0x000000ff)
+#define DREG_AR_DELIN1                           DREG_GLOBAL(0x01dc)
+#define DREG_AR_DELIN1_WMASK                     (0x000000ff)
+#define DREG_AR_DELIN1_MASK                      (0x000000ff)
+#define DREG_AR_DELIN1_DEFAULT                   (0x00000011)
+#define DREG_AR_DELIN1_FMASK                     (0x000000ff)
+#define DREG_AR_OVDROP_CNT0                      DREG_GLOBAL(0x0260)
+#define DREG_AR_OVDROP_CNT0_WMASK                (0xffffffff)
+#define DREG_AR_OVDROP_CNT0_MASK                 (0xffffffff)
+#define DREG_AR_OVDROP_CNT0_DEFAULT              (0x00000000)
+#define DREG_AR_OVDROP_CNT0_FMASK                (0xffffffff)
+#define DREG_AR_OVDROP_CNT1                      DREG_GLOBAL(0x0264)
+#define DREG_AR_OVDROP_CNT1_WMASK                (0xffffffff)
+#define DREG_AR_OVDROP_CNT1_MASK                 (0xffffffff)
+#define DREG_AR_OVDROP_CNT1_DEFAULT              (0x00000000)
+#define DREG_AR_OVDROP_CNT1_FMASK                (0xffffffff)
+#define DREG_AR_CERRN_CNT0                       DREG_GLOBAL(0x0280)
+#define DREG_AR_CERRN_CNT0_WMASK                 (0xffffffff)
+#define DREG_AR_CERRN_CNT0_MASK                  (0xffffffff)
+#define DREG_AR_CERRN_CNT0_DEFAULT               (0x00000000)
+#define DREG_AR_CERRN_CNT0_FMASK                 (0xffffffff)
+#define DREG_AR_CERRN_CNT1                       DREG_GLOBAL(0x0284)
+#define DREG_AR_CERRN_CNT1_WMASK                 (0xffffffff)
+#define DREG_AR_CERRN_CNT1_MASK                  (0xffffffff)
+#define DREG_AR_CERRN_CNT1_DEFAULT               (0x00000000)
+#define DREG_AR_CERRN_CNT1_FMASK                 (0xffffffff)
+#define DREG_AR_CERRNP_CNT0                      DREG_GLOBAL(0x0288)
+#define DREG_AR_CERRNP_CNT0_WMASK                (0xffffffff)
+#define DREG_AR_CERRNP_CNT0_MASK                 (0xffffffff)
+#define DREG_AR_CERRNP_CNT0_DEFAULT              (0x00000000)
+#define DREG_AR_CERRNP_CNT0_FMASK                (0xffffffff)
+#define DREG_AR_CERRNP_CNT1                      DREG_GLOBAL(0x028c)
+#define DREG_AR_CERRNP_CNT1_WMASK                (0xffffffff)
+#define DREG_AR_CERRNP_CNT1_MASK                 (0xffffffff)
+#define DREG_AR_CERRNP_CNT1_DEFAULT              (0x00000000)
+#define DREG_AR_CERRNP_CNT1_FMASK                (0xffffffff)
+#define DREG_AR_CVN_CNT0                         DREG_GLOBAL(0x0290)
+#define DREG_AR_CVN_CNT0_WMASK                   (0xffffffff)
+#define DREG_AR_CVN_CNT0_MASK                    (0xffffffff)
+#define DREG_AR_CVN_CNT0_DEFAULT                 (0x00000000)
+#define DREG_AR_CVN_CNT0_FMASK                   (0xffffffff)
+#define DREG_AR_CVN_CNT1                         DREG_GLOBAL(0x0294)
+#define DREG_AR_CVN_CNT1_WMASK                   (0xffffffff)
+#define DREG_AR_CVN_CNT1_MASK                    (0xffffffff)
+#define DREG_AR_CVN_CNT1_DEFAULT                 (0x00000000)
+#define DREG_AR_CVN_CNT1_FMASK                   (0xffffffff)
+#define DREG_AR_CVNP_CNT0                        DREG_GLOBAL(0x0298)
+#define DREG_AR_CVNP_CNT0_WMASK                  (0xffffffff)
+#define DREG_AR_CVNP_CNT0_MASK                   (0xffffffff)
+#define DREG_AR_CVNP_CNT0_DEFAULT                (0x00000000)
+#define DREG_AR_CVNP_CNT0_FMASK                  (0xffffffff)
+#define DREG_AR_CVNP_CNT1                        DREG_GLOBAL(0x029c)
+#define DREG_AR_CVNP_CNT1_WMASK                  (0xffffffff)
+#define DREG_AR_CVNP_CNT1_MASK                   (0xffffffff)
+#define DREG_AR_CVNP_CNT1_DEFAULT                (0x00000000)
+#define DREG_AR_CVNP_CNT1_FMASK                  (0xffffffff)
+#define DREG_B0_LADR                             DREG_GLOBAL(0x02a0)
+#define DREG_B0_LADR_WMASK                       (0x00001fff)
+#define DREG_B0_LADR_MASK                        (0x00001fff)
+#define DREG_B0_LADR_DEFAULT                     (0x00000000)
+#define DREG_B0_LADR_FMASK                       (0x00001fff)
+#define DREG_B1_LADR                             DREG_GLOBAL(0x02a4)
+#define DREG_B1_LADR_WMASK                       (0x00001fff)
+#define DREG_B1_LADR_MASK                        (0x00001fff)
+#define DREG_B1_LADR_DEFAULT                     (0x00000000)
+#define DREG_B1_LADR_FMASK                       (0x00001fff)
+#define DREG_MISC_RAM0                           DREG_GLOBAL(0x0300)
+#define DREG_MISC_RAM0_WMASK                     (0xffffffff)
+#define DREG_MISC_RAM0_MASK                      (0xffffffff)
+#define DREG_MISC_RAM0_DEFAULT                   (0x00000000)
+#define DREG_MISC_RAM0_FMASK                     (0xffffffff)
+#define DREG_MISCRAM1                            DREG_GLOBAL(0x0304)
+#define DREG_MISCRAM1_WMASK                      (0xffffffff)
+#define DREG_MISCRAM1_MASK                       (0xffffffff)
+#define DREG_MISCRAM1_DEFAULT                    (0x00000000)
+#define DREG_MISCRAM1_FMASK                      (0xffffffff)
+#define DREG_MISCRAM2                            DREG_GLOBAL(0x0308)
+#define DREG_MISCRAM2_WMASK                      (0xffffffff)
+#define DREG_MISCRAM2_MASK                       (0xffffffff)
+#define DREG_MISCRAM2_DEFAULT                    (0x00000000)
+#define DREG_MISCRAM2_FMASK                      (0xffffffff)
+#define DREG_MISCRAM3                            DREG_GLOBAL(0x030c)
+#define DREG_MISCRAM3_WMASK                      (0xffffffff)
+#define DREG_MISCRAM3_MASK                       (0xffffffff)
+#define DREG_MISCRAM3_DEFAULT                    (0x00000000)
+#define DREG_MISCRAM3_FMASK                      (0xffffffff)
+#define DREG_MISCRAM4                            DREG_GLOBAL(0x0310)
+#define DREG_MISCRAM4_WMASK                      (0xffffffff)
+#define DREG_MISCRAM4_MASK                       (0xffffffff)
+#define DREG_MISCRAM4_DEFAULT                    (0x00000000)
+#define DREG_MISCRAM4_FMASK                      (0xffffffff)
+#define DREG_MISCRAM5                            DREG_GLOBAL(0x0314)
+#define DREG_MISCRAM5_WMASK                      (0xffffffff)
+#define DREG_MISCRAM5_MASK                       (0xffffffff)
+#define DREG_MISCRAM5_DEFAULT                    (0x00000000)
+#define DREG_MISCRAM5_FMASK                      (0xffffffff)
+#define DREG_MISCRAM6                            DREG_GLOBAL(0x0318)
+#define DREG_MISCRAM6_WMASK                      (0xffffffff)
+#define DREG_MISCRAM6_MASK                       (0xffffffff)
+#define DREG_MISCRAM6_DEFAULT                    (0x00000000)
+#define DREG_MISCRAM6_FMASK                      (0xffffffff)
+#define DREG_MISCRAM7                            DREG_GLOBAL(0x031c)
+#define DREG_MISCRAM7_WMASK                      (0xffffffff)
+#define DREG_MISCRAM7_MASK                       (0xffffffff)
+#define DREG_MISCRAM7_DEFAULT                    (0x00000000)
+#define DREG_MISCRAM7_FMASK                      (0xffffffff)
+#define DREG_MISCRAM8                            DREG_GLOBAL(0x0320)
+#define DREG_MISCRAM8_WMASK                      (0xffffffff)
+#define DREG_MISCRAM8_MASK                       (0xffffffff)
+#define DREG_MISCRAM8_DEFAULT                    (0x00000000)
+#define DREG_MISCRAM8_FMASK                      (0xffffffff)
+#define DREG_MISCRAM9                            DREG_GLOBAL(0x0324)
+#define DREG_MISCRAM9_WMASK                      (0xffffffff)
+#define DREG_MISCRAM9_MASK                       (0xffffffff)
+#define DREG_MISCRAM9_DEFAULT                    (0x00000000)
+#define DREG_MISCRAM9_FMASK                      (0xffffffff)
+#define DREG_MISCRAM10                           DREG_GLOBAL(0x0328)
+#define DREG_MISCRAM10_WMASK                     (0xffffffff)
+#define DREG_MISCRAM10_MASK                      (0xffffffff)
+#define DREG_MISCRAM10_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM10_FMASK                     (0xffffffff)
+#define DREG_MISCRAM11                           DREG_GLOBAL(0x032c)
+#define DREG_MISCRAM11_WMASK                     (0xffffffff)
+#define DREG_MISCRAM11_MASK                      (0xffffffff)
+#define DREG_MISCRAM11_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM11_FMASK                     (0xffffffff)
+#define DREG_MISCRAM12                           DREG_GLOBAL(0x0330)
+#define DREG_MISCRAM12_WMASK                     (0xffffffff)
+#define DREG_MISCRAM12_MASK                      (0xffffffff)
+#define DREG_MISCRAM12_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM12_FMASK                     (0xffffffff)
+#define DREG_MISCRAM13                           DREG_GLOBAL(0x0334)
+#define DREG_MISCRAM13_WMASK                     (0xffffffff)
+#define DREG_MISCRAM13_MASK                      (0xffffffff)
+#define DREG_MISCRAM13_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM13_FMASK                     (0xffffffff)
+#define DREG_MISCRAM14                           DREG_GLOBAL(0x0338)
+#define DREG_MISCRAM14_WMASK                     (0xffffffff)
+#define DREG_MISCRAM14_MASK                      (0xffffffff)
+#define DREG_MISCRAM14_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM14_FMASK                     (0xffffffff)
+#define DREG_MISCRAM15                           DREG_GLOBAL(0x033c)
+#define DREG_MISCRAM15_WMASK                     (0xffffffff)
+#define DREG_MISCRAM15_MASK                      (0xffffffff)
+#define DREG_MISCRAM15_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM15_FMASK                     (0xffffffff)
+#define DREG_MISC_RAM16                          DREG_GLOBAL(0x0340)
+#define DREG_MISC_RAM16_WMASK                    (0xffffffff)
+#define DREG_MISC_RAM16_MASK                     (0xffffffff)
+#define DREG_MISC_RAM16_DEFAULT                  (0x00000000)
+#define DREG_MISC_RAM16_FMASK                    (0xffffffff)
+#define DREG_MISCRAM17                           DREG_GLOBAL(0x0344)
+#define DREG_MISCRAM17_WMASK                     (0xffffffff)
+#define DREG_MISCRAM17_MASK                      (0xffffffff)
+#define DREG_MISCRAM17_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM17_FMASK                     (0xffffffff)
+#define DREG_MISCRAM18                           DREG_GLOBAL(0x0348)
+#define DREG_MISCRAM18_WMASK                     (0xffffffff)
+#define DREG_MISCRAM18_MASK                      (0xffffffff)
+#define DREG_MISCRAM18_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM18_FMASK                     (0xffffffff)
+#define DREG_MISCRAM19                           DREG_GLOBAL(0x034c)
+#define DREG_MISCRAM19_WMASK                     (0xffffffff)
+#define DREG_MISCRAM19_MASK                      (0xffffffff)
+#define DREG_MISCRAM19_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM19_FMASK                     (0xffffffff)
+#define DREG_MISCRAM20                           DREG_GLOBAL(0x0350)
+#define DREG_MISCRAM20_WMASK                     (0xffffffff)
+#define DREG_MISCRAM20_MASK                      (0xffffffff)
+#define DREG_MISCRAM20_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM20_FMASK                     (0xffffffff)
+#define DREG_MISCRAM21                           DREG_GLOBAL(0x0354)
+#define DREG_MISCRAM21_WMASK                     (0xffffffff)
+#define DREG_MISCRAM21_MASK                      (0xffffffff)
+#define DREG_MISCRAM21_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM21_FMASK                     (0xffffffff)
+#define DREG_MISCRAM22                           DREG_GLOBAL(0x0358)
+#define DREG_MISCRAM22_WMASK                     (0xffffffff)
+#define DREG_MISCRAM22_MASK                      (0xffffffff)
+#define DREG_MISCRAM22_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM22_FMASK                     (0xffffffff)
+#define DREG_MISCRAM23                           DREG_GLOBAL(0x035c)
+#define DREG_MISCRAM23_WMASK                     (0xffffffff)
+#define DREG_MISCRAM23_MASK                      (0xffffffff)
+#define DREG_MISCRAM23_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM23_FMASK                     (0xffffffff)
+#define DREG_MISCRAM24                           DREG_GLOBAL(0x0360)
+#define DREG_MISCRAM24_WMASK                     (0xffffffff)
+#define DREG_MISCRAM24_MASK                      (0xffffffff)
+#define DREG_MISCRAM24_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM24_FMASK                     (0xffffffff)
+#define DREG_MISCRAM25                           DREG_GLOBAL(0x0364)
+#define DREG_MISCRAM25_WMASK                     (0xffffffff)
+#define DREG_MISCRAM25_MASK                      (0xffffffff)
+#define DREG_MISCRAM25_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM25_FMASK                     (0xffffffff)
+#define DREG_MISCRAM26                           DREG_GLOBAL(0x0368)
+#define DREG_MISCRAM26_WMASK                     (0xffffffff)
+#define DREG_MISCRAM26_MASK                      (0xffffffff)
+#define DREG_MISCRAM26_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM26_FMASK                     (0xffffffff)
+#define DREG_MISCRAM27                           DREG_GLOBAL(0x036c)
+#define DREG_MISCRAM27_WMASK                     (0xffffffff)
+#define DREG_MISCRAM27_MASK                      (0xffffffff)
+#define DREG_MISCRAM27_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM27_FMASK                     (0xffffffff)
+#define DREG_MISCRAM28                           DREG_GLOBAL(0x0370)
+#define DREG_MISCRAM28_WMASK                     (0xffffffff)
+#define DREG_MISCRAM28_MASK                      (0xffffffff)
+#define DREG_MISCRAM28_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM28_FMASK                     (0xffffffff)
+#define DREG_MISCRAM29                           DREG_GLOBAL(0x0374)
+#define DREG_MISCRAM29_WMASK                     (0xffffffff)
+#define DREG_MISCRAM29_MASK                      (0xffffffff)
+#define DREG_MISCRAM29_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM29_FMASK                     (0xffffffff)
+#define DREG_MISCRAM30                           DREG_GLOBAL(0x0378)
+#define DREG_MISCRAM30_WMASK                     (0xffffffff)
+#define DREG_MISCRAM30_MASK                      (0xffffffff)
+#define DREG_MISCRAM30_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM30_FMASK                     (0xffffffff)
+#define DREG_MISCRAM31                           DREG_GLOBAL(0x037c)
+#define DREG_MISCRAM31_WMASK                     (0xffffffff)
+#define DREG_MISCRAM31_MASK                      (0xffffffff)
+#define DREG_MISCRAM31_DEFAULT                   (0x00000000)
+#define DREG_MISCRAM31_FMASK                     (0xffffffff)
+#define DREG_MB0_P2D_ISRS                        DREG_GLOBAL(0x0380)
+#define DREG_MB0_P2D_ISRS_WMASK                  (0x000000ff)
+#define DREG_MB0_P2D_ISRS_MASK                   (0x000000ff)
+#define DREG_MB0_P2D_ISRS_DEFAULT                (0x00000000)
+#define DREG_MB0_P2D_ISRS_FMASK                  (0x000000ff)
+#define DREG_MB0_P2D_ISRC                        DREG_GLOBAL(0x0384)
+#define DREG_MB0_P2D_ISRC_WMASK                  (0x000000ff)
+#define DREG_MB0_P2D_ISRC_MASK                   (0x000000ff)
+#define DREG_MB0_P2D_ISRC_DEFAULT                (0x00000000)
+#define DREG_MB0_P2D_ISRC_FMASK                  (0x000000ff)
+#define DREG_MB0_P2D_ISR                         DREG_GLOBAL(0x0388)
+#define DREG_MB0_P2D_ISR_WMASK                   (0x000000ff)
+#define DREG_MB0_P2D_ISR_MASK                    (0x000000ff)
+#define DREG_MB0_P2D_ISR_DEFAULT                 (0x00000000)
+#define DREG_MB0_P2D_ISR_FMASK                   (0x000000ff)
+#define DREG_MB0_P2D_IER                         DREG_GLOBAL(0x038c)
+#define DREG_MB0_P2D_IER_WMASK                   (0x000000ff)
+#define DREG_MB0_P2D_IER_MASK                    (0x000000ff)
+#define DREG_MB0_P2D_IER_DEFAULT                 (0x00000000)
+#define DREG_MB0_P2D_IER_FMASK                   (0x000000ff)
+#define DREG_MB1_P2D_ISRS                        DREG_GLOBAL(0x03c0)
+#define DREG_MB1_P2D_ISRS_WMASK                  (0x000000ff)
+#define DREG_MB1_P2D_ISRS_MASK                   (0x000000ff)
+#define DREG_MB1_P2D_ISRS_DEFAULT                (0x00000000)
+#define DREG_MB1_P2D_ISRS_FMASK                  (0x000000ff)
+#define DREG_MB1_P2D_ISRC                        DREG_GLOBAL(0x03c4)
+#define DREG_MB1_P2D_ISRC_WMASK                  (0x000000ff)
+#define DREG_MB1_P2D_ISRC_MASK                   (0x000000ff)
+#define DREG_MB1_P2D_ISRC_DEFAULT                (0x00000000)
+#define DREG_MB1_P2D_ISRC_FMASK                  (0x000000ff)
+#define DREG_MB1_P2D_ISR                         DREG_GLOBAL(0x03c8)
+#define DREG_MB1_P2D_ISR_WMASK                   (0x000000ff)
+#define DREG_MB1_P2D_ISR_MASK                    (0x000000ff)
+#define DREG_MB1_P2D_ISR_DEFAULT                 (0x00000000)
+#define DREG_MB1_P2D_ISR_FMASK                   (0x000000ff)
+#define DREG_MB1_P2D_IER                         DREG_GLOBAL(0x03cc)
+#define DREG_MB1_P2D_IER_WMASK                   (0x000000ff)
+#define DREG_MB1_P2D_IER_MASK                    (0x000000ff)
+#define DREG_MB1_P2D_IER_DEFAULT                 (0x00000000)
+#define DREG_MB1_P2D_IER_FMASK                   (0x000000ff)
+#define DREG_MB2_D2P_ISRS                        DREG_GLOBAL(0x0390)
+#define DREG_MB2_D2P_ISRS_WMASK                  (0x000000ff)
+#define DREG_MB2_D2P_ISRS_MASK                   (0x000000ff)
+#define DREG_MB2_D2P_ISRS_DEFAULT                (0x00000000)
+#define DREG_MB2_D2P_ISRS_FMASK                  (0x000000ff)
+#define DREG_MB2_D2P_ISRC                        DREG_GLOBAL(0x0394)
+#define DREG_MB2_D2P_ISRC_WMASK                  (0x000000ff)
+#define DREG_MB2_D2P_ISRC_MASK                   (0x000000ff)
+#define DREG_MB2_D2P_ISRC_DEFAULT                (0x00000000)
+#define DREG_MB2_D2P_ISRC_FMASK                  (0x000000ff)
+#define DREG_MB2_D2P_ISR                         DREG_GLOBAL(0x0398)
+#define DREG_MB2_D2P_ISR_WMASK                   (0x000000ff)
+#define DREG_MB2_D2P_ISR_MASK                    (0x000000ff)
+#define DREG_MB2_D2P_ISR_DEFAULT                 (0x00000000)
+#define DREG_MB2_D2P_ISR_FMASK                   (0x000000ff)
+#define DREG_MB2_D2P_IER                         DREG_GLOBAL(0x039c)
+#define DREG_MB2_D2P_IER_WMASK                   (0x000000ff)
+#define DREG_MB2_D2P_IER_MASK                    (0x000000ff)
+#define DREG_MB2_D2P_IER_DEFAULT                 (0x00000000)
+#define DREG_MB2_D2P_IER_FMASK                   (0x000000ff)
+#define DREG_MB3_D2P_ISRS                        DREG_GLOBAL(0x03d0)
+#define DREG_MB3_D2P_ISRS_WMASK                  (0x000000ff)
+#define DREG_MB3_D2P_ISRS_MASK                   (0x000000ff)
+#define DREG_MB3_D2P_ISRS_DEFAULT                (0x00000000)
+#define DREG_MB3_D2P_ISRS_FMASK                  (0x000000ff)
+#define DREG_MB3_D2P_ISRC                        DREG_GLOBAL(0x03d4)
+#define DREG_MB3_D2P_ISRC_WMASK                  (0x000000ff)
+#define DREG_MB3_D2P_ISRC_MASK                   (0x000000ff)
+#define DREG_MB3_D2P_ISRC_DEFAULT                (0x00000000)
+#define DREG_MB3_D2P_ISRC_FMASK                  (0x000000ff)
+#define DREG_MB3_D2P_ISR                         DREG_GLOBAL(0x03d8)
+#define DREG_MB3_D2P_ISR_WMASK                   (0x000000ff)
+#define DREG_MB3_D2P_ISR_MASK                    (0x000000ff)
+#define DREG_MB3_D2P_ISR_DEFAULT                 (0x00000000)
+#define DREG_MB3_D2P_ISR_FMASK                   (0x000000ff)
+#define DREG_MB3_D2P_IER                         DREG_GLOBAL(0x03dc)
+#define DREG_MB3_D2P_IER_WMASK                   (0x000000ff)
+#define DREG_MB3_D2P_IER_MASK                    (0x000000ff)
+#define DREG_MB3_D2P_IER_DEFAULT                 (0x00000000)
+#define DREG_MB3_D2P_IER_FMASK                   (0x000000ff)
+#define DREG_BIN_SEM0                            DREG_GLOBAL(0x03a0)
+#define DREG_BIN_SEM0_WMASK                      (0x00000001)
+#define DREG_BIN_SEM0_MASK                       (0x00000001)
+#define DREG_BIN_SEM0_DEFAULT                    (0x00000000)
+#define DREG_BIN_SEM0_FMASK                      (0x00000001)
+#define DREG_BIN_SEM1                            DREG_GLOBAL(0x03e0)
+#define DREG_BIN_SEM1_WMASK                      (0x00000001)
+#define DREG_BIN_SEM1_MASK                       (0x00000001)
+#define DREG_BIN_SEM1_DEFAULT                    (0x00000000)
+#define DREG_BIN_SEM1_FMASK                      (0x00000001)
+
+/* GLPTOP Global Address Constants */
+#define glptop_global_base       (0x20CE00)
+#define GLPTOP_GLOBAL(r)         (int)(glptop_global_base+(r))
+#define glptop_global_size       (0x0040)
+
+#define GLP_TOP_CFG                              GLPTOP_GLOBAL(0x00)
+#define GLP_TOP_CFG_WMASK                        (0x88331111)
+#define GLP_TOP_CFG_MASK                         (0x88331111)
+#define GLP_TOP_CFG_DEFAULT                      (0x00330000)
+#define GLP_TOP_CFG_FMASK                        (0x88331111)
+#define GLP_TOP_STATUS                           GLPTOP_GLOBAL(0x04)
+#define GLP_TOP_STATUS_WMASK                     (0x00001111)
+#define GLP_TOP_STATUS_MASK                      (0x00001111)
+#define GLP_TOP_STATUS_DEFAULT                   (0x00001010)
+#define GLP_TOP_STATUS_FMASK                     (0x00001111)
+#define GLP_TX0FIFO_CFG                          GLPTOP_GLOBAL(0x10)
+#define GLP_TX0FIFO_CFG_WMASK                    (0x901f000f)
+#define GLP_TX0FIFO_CFG_MASK                     (0x901f000f)
+#define GLP_TX0FIFO_CFG_DEFAULT                  (0x00080000)
+#define GLP_TX0FIFO_CFG_FMASK                    (0x901f000f)
+#define GLP_RX0FIFO_CFG                          GLPTOP_GLOBAL(0x18)
+#define GLP_RX0FIFO_CFG_WMASK                    (0x901f000f)
+#define GLP_RX0FIFO_CFG_MASK                     (0x901f000f)
+#define GLP_RX0FIFO_CFG_DEFAULT                  (0x00080000)
+#define GLP_RX0FIFO_CFG_FMASK                    (0x901f000f)
+#define GLP_TX1FIFO_CFG                          GLPTOP_GLOBAL(0x20)
+#define GLP_TX1FIFO_CFG_WMASK                    (0x901f000f)
+#define GLP_TX1FIFO_CFG_MASK                     (0x901f000f)
+#define GLP_TX1FIFO_CFG_DEFAULT                  (0x00080000)
+#define GLP_TX1FIFO_CFG_FMASK                    (0x901f000f)
+#define GLP_RX1FIFO_CFG                          GLPTOP_GLOBAL(0x28)
+#define GLP_RX1FIFO_CFG_WMASK                    (0x901f000f)
+#define GLP_RX1FIFO_CFG_MASK                     (0x901f000f)
+#define GLP_RX1FIFO_CFG_DEFAULT                  (0x00080000)
+#define GLP_RX1FIFO_CFG_FMASK                    (0x901f000f)
+#define GLP_MISC                                 GLPTOP_GLOBAL(0x3C)
+#define GLP_MISC_WMASK                           (0x000000ff)
+#define GLP_MISC_MASK                            (0x000000ff)
+#define GLP_MISC_DEFAULT                         (0x00000000)
+#define GLP_MISC_FMASK                           (0x000000ff)
+
+/* ERRC Global Address Constants */
+#define errc_global_base       (0x20CE40)
+#define ERRC_GLOBAL(r)         (int)(errc_global_base+(r))
+#define errc_global_size       (0x0080)
+
+#define ERRC_RX1_CTRL                            ERRC_GLOBAL(0x000000)
+#define ERRC_RX1_CTRL_WMASK                      (0x00000013)
+#define ERRC_RX1_CTRL_MASK                       (0x00000013)
+#define ERRC_RX1_CTRL_DEFAULT                    (0x0002)
+#define ERRC_RX1_CTRL_FMASK                      (0x00000013)
+#define ERRC_RX1_ERRD_CTRL                       ERRC_GLOBAL(0x000004)
+#define ERRC_RX1_ERRD_CTRL_WMASK                 (0x00000311)
+#define ERRC_RX1_ERRD_CTRL_MASK                  (0x00000311)
+#define ERRC_RX1_ERRD_CTRL_DEFAULT               (0x0001)
+#define ERRC_RX1_ERRD_CTRL_FMASK                 (0x00000311)
+#define ERRC_RX1_STAT                            ERRC_GLOBAL(0x000008)
+#define ERRC_RX1_STAT_WMASK                      (0x00000001)
+#define ERRC_RX1_STAT_MASK                       (0x00000001)
+#define ERRC_RX1_STAT_DEFAULT                    (0x0000)
+#define ERRC_RX1_STAT_FMASK                      (0x00000001)
+#define ERRC_RX1_SAT_CNT                         ERRC_GLOBAL(0x00000C)
+#define ERRC_RX1_SAT_CNT_WMASK                   (0x0000ffff)
+#define ERRC_RX1_SAT_CNT_MASK                    (0x0000ffff)
+#define ERRC_RX1_SAT_CNT_DEFAULT                 (0x0000)
+#define ERRC_RX1_SAT_CNT_FMASK                   (0x0000ffff)
+#define ERRC_RX1_ERR_CNT                         ERRC_GLOBAL(0x000010)
+#define ERRC_RX1_ERR_CNT_WMASK                   (0x0000ffff)
+#define ERRC_RX1_ERR_CNT_MASK                    (0x0000ffff)
+#define ERRC_RX1_ERR_CNT_DEFAULT                 (0x0000)
+#define ERRC_RX1_ERR_CNT_FMASK                   (0x0000ffff)
+#define ERRC_RX2_CTRL                            ERRC_GLOBAL(0x000040)
+#define ERRC_RX2_CTRL_WMASK                      (0x00000013)
+#define ERRC_RX2_CTRL_MASK                       (0x00000013)
+#define ERRC_RX2_CTRL_DEFAULT                    (0x0002)
+#define ERRC_RX2_CTRL_FMASK                      (0x00000013)
+#define ERRC_RX2_ERRD_CTRL                       ERRC_GLOBAL(0x000044)
+#define ERRC_RX2_ERRD_CTRL_WMASK                 (0x00000311)
+#define ERRC_RX2_ERRD_CTRL_MASK                  (0x00000311)
+#define ERRC_RX2_ERRD_CTRL_DEFAULT               (0x0001)
+#define ERRC_RX2_ERRD_CTRL_FMASK                 (0x00000311)
+#define ERRC_RX2_STAT                            ERRC_GLOBAL(0x000048)
+#define ERRC_RX2_STAT_WMASK                      (0x00000001)
+#define ERRC_RX2_STAT_MASK                       (0x00000001)
+#define ERRC_RX2_STAT_DEFAULT                    (0x0000)
+#define ERRC_RX2_STAT_FMASK                      (0x00000001)
+#define ERRC_RX2_SAT_CNT                         ERRC_GLOBAL(0x00004C)
+#define ERRC_RX2_SAT_CNT_WMASK                   (0x0000ffff)
+#define ERRC_RX2_SAT_CNT_MASK                    (0x0000ffff)
+#define ERRC_RX2_SAT_CNT_DEFAULT                 (0x0000)
+#define ERRC_RX2_SAT_CNT_FMASK                   (0x0000ffff)
+#define ERRC_RX2_ERR_CNT                         ERRC_GLOBAL(0x000050)
+#define ERRC_RX2_ERR_CNT_WMASK                   (0x0000ffff)
+#define ERRC_RX2_ERR_CNT_MASK                    (0x0000ffff)
+#define ERRC_RX2_ERR_CNT_DEFAULT                 (0x0000)
+#define ERRC_RX2_ERR_CNT_FMASK                   (0x0000ffff)
+
+/* GLPM Global Address Constants */
+#define glpm_global_base       (0x20CC00)
+#define GLPM_GLOBAL(r)         (int)(glpm_global_base+(r))
+#define glpm_global_size       (0x0200)
+
+#define GLPM_GLP_FR_CTRL_0                       GLPM_GLOBAL(0x000000)
+#define GLPM_GLP_FR_CTRL_0_WMASK                 (0x00007f7f)
+#define GLPM_GLP_FR_CTRL_0_MASK                  (0x00007f7f)
+#define GLPM_GLP_FR_CTRL_0_DEFAULT               (0x0000)
+#define GLPM_GLP_FR_CTRL_0_FMASK                 (0x00007f7f)
+#define GLPM_GLP_FR_CTRL_1                       GLPM_GLOBAL(0x000004)
+#define GLPM_GLP_FR_CTRL_1_WMASK                 (0x00007f7f)
+#define GLPM_GLP_FR_CTRL_1_MASK                  (0x00007f7f)
+#define GLPM_GLP_FR_CTRL_1_DEFAULT               (0x0000)
+#define GLPM_GLP_FR_CTRL_1_FMASK                 (0x00007f7f)
+#define GLPM_GLP_FR_STATUS_0                     GLPM_GLOBAL(0x000008)
+#define GLPM_GLP_FR_STATUS_0_WMASK               (0x00007fff)
+#define GLPM_GLP_FR_STATUS_0_MASK                (0x00007fff)
+#define GLPM_GLP_FR_STATUS_0_DEFAULT             (0x0000)
+#define GLPM_GLP_FR_STATUS_0_FMASK               (0x00007fff)
+#define GLPM_GLP_FR_STATUS_1                     GLPM_GLOBAL(0x00000C)
+#define GLPM_GLP_FR_STATUS_1_WMASK               (0x00007fff)
+#define GLPM_GLP_FR_STATUS_1_MASK                (0x00007fff)
+#define GLPM_GLP_FR_STATUS_1_DEFAULT             (0x0000)
+#define GLPM_GLP_FR_STATUS_1_FMASK               (0x00007fff)
+#define GLPM_GLP_FR_WD_AL_0                      GLPM_GLOBAL(0x000010)
+#define GLPM_GLP_FR_WD_AL_0_WMASK                (0x0000007f)
+#define GLPM_GLP_FR_WD_AL_0_MASK                 (0x0000007f)
+#define GLPM_GLP_FR_WD_AL_0_DEFAULT              (0x0025)
+#define GLPM_GLP_FR_WD_AL_0_FMASK                (0x0000007f)
+#define GLPM_GLP_FR_WD_AL_1                      GLPM_GLOBAL(0x000014)
+#define GLPM_GLP_FR_WD_AL_1_WMASK                (0x0000007f)
+#define GLPM_GLP_FR_WD_AL_1_MASK                 (0x0000007f)
+#define GLPM_GLP_FR_WD_AL_1_DEFAULT              (0x0025)
+#define GLPM_GLP_FR_WD_AL_1_FMASK                (0x0000007f)
+#define GLPM_GLP_FR_MISC_0                       GLPM_GLOBAL(0x000018)
+#define GLPM_GLP_FR_MISC_0_WMASK                 (0x00003fff)
+#define GLPM_GLP_FR_MISC_0_MASK                  (0x00003fff)
+#define GLPM_GLP_FR_MISC_0_DEFAULT               (0x0407)
+#define GLPM_GLP_FR_MISC_0_FMASK                 (0x00003fff)
+#define GLPM_GLP_FR_MISC_1                       GLPM_GLOBAL(0x00001C)
+#define GLPM_GLP_FR_MISC_1_WMASK                 (0x00003fff)
+#define GLPM_GLP_FR_MISC_1_MASK                  (0x00003fff)
+#define GLPM_GLP_FR_MISC_1_DEFAULT               (0x0407)
+#define GLPM_GLP_FR_MISC_1_FMASK                 (0x00003fff)
+#define GLPM_GLP_FR_BITLOCK_0                    GLPM_GLOBAL(0x000020)
+#define GLPM_GLP_FR_BITLOCK_0_WMASK              (0x000000ff)
+#define GLPM_GLP_FR_BITLOCK_0_MASK               (0x000000ff)
+#define GLPM_GLP_FR_BITLOCK_0_DEFAULT            (0x000A)
+#define GLPM_GLP_FR_BITLOCK_0_FMASK              (0x000000ff)
+#define GLPM_GLP_FR_BITLOCK_1                    GLPM_GLOBAL(0x000024)
+#define GLPM_GLP_FR_BITLOCK_1_WMASK              (0x000000ff)
+#define GLPM_GLP_FR_BITLOCK_1_MASK               (0x000000ff)
+#define GLPM_GLP_FR_BITLOCK_1_DEFAULT            (0x000A)
+#define GLPM_GLP_FR_BITLOCK_1_FMASK              (0x000000ff)
+#define GLPM_GLP_FR_WDG_CFG_0                    GLPM_GLOBAL(0x000028)
+#define GLPM_GLP_FR_WDG_CFG_0_WMASK              (0x0000ffff)
+#define GLPM_GLP_FR_WDG_CFG_0_MASK               (0x0000ffff)
+#define GLPM_GLP_FR_WDG_CFG_0_DEFAULT            (0xFFFF)
+#define GLPM_GLP_FR_WDG_CFG_0_FMASK              (0x0000ffff)
+#define GLPM_GLP_FR_WDG_CFG_1                    GLPM_GLOBAL(0x00002C)
+#define GLPM_GLP_FR_WDG_CFG_1_WMASK              (0x0000ffff)
+#define GLPM_GLP_FR_WDG_CFG_1_MASK               (0x0000ffff)
+#define GLPM_GLP_FR_WDG_CFG_1_DEFAULT            (0xFFFF)
+#define GLPM_GLP_FR_WDG_CFG_1_FMASK              (0x0000ffff)
+#define GLPM_GLP_FR_ERR_LIM_0                    GLPM_GLOBAL(0x000030)
+#define GLPM_GLP_FR_ERR_LIM_0_WMASK              (0x0000ffff)
+#define GLPM_GLP_FR_ERR_LIM_0_MASK               (0x0000ffff)
+#define GLPM_GLP_FR_ERR_LIM_0_DEFAULT            (0x0A64)
+#define GLPM_GLP_FR_ERR_LIM_0_FMASK              (0x0000ffff)
+#define GLPM_GLP_FR_ERR_LIM_1                    GLPM_GLOBAL(0x000034)
+#define GLPM_GLP_FR_ERR_LIM_1_WMASK              (0x0000ffff)
+#define GLPM_GLP_FR_ERR_LIM_1_MASK               (0x0000ffff)
+#define GLPM_GLP_FR_ERR_LIM_1_DEFAULT            (0x0A64)
+#define GLPM_GLP_FR_ERR_LIM_1_FMASK              (0x0000ffff)
+#define GLPM_GLP_FR_UNIQ_WD_0                    GLPM_GLOBAL(0x000038)
+#define GLPM_GLP_FR_UNIQ_WD_0_WMASK              (0x0000ffff)
+#define GLPM_GLP_FR_UNIQ_WD_0_MASK               (0x0000ffff)
+#define GLPM_GLP_FR_UNIQ_WD_0_DEFAULT            (0x6E78)
+#define GLPM_GLP_FR_UNIQ_WD_0_FMASK              (0x0000ffff)
+#define GLPM_GLP_FR_UNIQ_WD_1                    GLPM_GLOBAL(0x00003C)
+#define GLPM_GLP_FR_UNIQ_WD_1_WMASK              (0x0000ffff)
+#define GLPM_GLP_FR_UNIQ_WD_1_MASK               (0x0000ffff)
+#define GLPM_GLP_FR_UNIQ_WD_1_DEFAULT            (0x6E78)
+#define GLPM_GLP_FR_UNIQ_WD_1_FMASK              (0x0000ffff)
+#define GLPM_GLP_FR_RX_UNIQ_WD_0                 GLPM_GLOBAL(0x000040)
+#define GLPM_GLP_FR_RX_UNIQ_WD_0_WMASK           (0x0000ffff)
+#define GLPM_GLP_FR_RX_UNIQ_WD_0_MASK            (0x0000ffff)
+#define GLPM_GLP_FR_RX_UNIQ_WD_0_DEFAULT         (0x0000)
+#define GLPM_GLP_FR_RX_UNIQ_WD_0_FMASK           (0x0000ffff)
+#define GLPM_GLP_FR_RX_UNIQ_WD_1                 GLPM_GLOBAL(0x000044)
+#define GLPM_GLP_FR_RX_UNIQ_WD_1_WMASK           (0x0000ffff)
+#define GLPM_GLP_FR_RX_UNIQ_WD_1_MASK            (0x0000ffff)
+#define GLPM_GLP_FR_RX_UNIQ_WD_1_DEFAULT         (0x0000)
+#define GLPM_GLP_FR_RX_UNIQ_WD_1_FMASK           (0x0000ffff)
+#define GLPM_GLP_FR_ERR_0                        GLPM_GLOBAL(0x000048)
+#define GLPM_GLP_FR_ERR_0_WMASK                  (0x0000ffff)
+#define GLPM_GLP_FR_ERR_0_MASK                   (0x0000ffff)
+#define GLPM_GLP_FR_ERR_0_DEFAULT                (0x0000)
+#define GLPM_GLP_FR_ERR_0_FMASK                  (0x0000ffff)
+#define GLPM_GLP_FR_ERR_1                        GLPM_GLOBAL(0x00004C)
+#define GLPM_GLP_FR_ERR_1_WMASK                  (0x0000ffff)
+#define GLPM_GLP_FR_ERR_1_MASK                   (0x0000ffff)
+#define GLPM_GLP_FR_ERR_1_DEFAULT                (0x0000)
+#define GLPM_GLP_FR_ERR_1_FMASK                  (0x0000ffff)
+#define GLPM_GLP_BIST_CTRL                       GLPM_GLOBAL(0x000050)
+#define GLPM_GLP_BIST_CTRL_WMASK                 (0x0000007f)
+#define GLPM_GLP_BIST_CTRL_MASK                  (0x0000007f)
+#define GLPM_GLP_BIST_CTRL_DEFAULT               (0x0000)
+#define GLPM_GLP_BIST_CTRL_FMASK                 (0x0000007f)
+#define GLPM_GLP_BIST_PHLOCK                     GLPM_GLOBAL(0x000054)
+#define GLPM_GLP_BIST_PHLOCK_WMASK               (0x000003ff)
+#define GLPM_GLP_BIST_PHLOCK_MASK                (0x000003ff)
+#define GLPM_GLP_BIST_PHLOCK_DEFAULT             (0x03E8)
+#define GLPM_GLP_BIST_PHLOCK_FMASK               (0x000003ff)
+#define GLPM_GLP_BIST_END                        GLPM_GLOBAL(0x000058)
+#define GLPM_GLP_BIST_END_WMASK                  (0x000003ff)
+#define GLPM_GLP_BIST_END_MASK                   (0x000003ff)
+#define GLPM_GLP_BIST_END_DEFAULT                (0x03E8)
+#define GLPM_GLP_BIST_END_FMASK                  (0x000003ff)
+#define GLPM_GLP_BERT_TERM                       GLPM_GLOBAL(0x00005C)
+#define GLPM_GLP_BERT_TERM_WMASK                 (0x000003ff)
+#define GLPM_GLP_BERT_TERM_MASK                  (0x000003ff)
+#define GLPM_GLP_BERT_TERM_DEFAULT               (0x0000)
+#define GLPM_GLP_BERT_TERM_FMASK                 (0x000003ff)
+#define GLPM_GLP_BERT_ERR                        GLPM_GLOBAL(0x000060)
+#define GLPM_GLP_BERT_ERR_WMASK                  (0x000003ff)
+#define GLPM_GLP_BERT_ERR_MASK                   (0x000003ff)
+#define GLPM_GLP_BERT_ERR_DEFAULT                (0x0000)
+#define GLPM_GLP_BERT_ERR_FMASK                  (0x000003ff)
+#define GLPM_GLP_BERT_CTRL                       GLPM_GLOBAL(0x000064)
+#define GLPM_GLP_BERT_CTRL_WMASK                 (0x000007ff)
+#define GLPM_GLP_BERT_CTRL_MASK                  (0x000007ff)
+#define GLPM_GLP_BERT_CTRL_DEFAULT               (0x0180)
+#define GLPM_GLP_BERT_CTRL_FMASK                 (0x000007ff)
+#define GLPM_GLP_GLP_CTRL                        GLPM_GLOBAL(0x000068)
+#define GLPM_GLP_GLP_CTRL_WMASK                  (0x0000007f)
+#define GLPM_GLP_GLP_CTRL_MASK                   (0x0000007f)
+#define GLPM_GLP_GLP_CTRL_DEFAULT                (0x0008)
+#define GLPM_GLP_GLP_CTRL_FMASK                  (0x0000007f)
+#define GLPM_GLP_GLP_MISC                        GLPM_GLOBAL(0x00006C)
+#define GLPM_GLP_GLP_MISC_WMASK                  (0x0000ffff)
+#define GLPM_GLP_GLP_MISC_MASK                   (0x0000ffff)
+#define GLPM_GLP_GLP_MISC_DEFAULT                (0xC0C0)
+#define GLPM_GLP_GLP_MISC_FMASK                  (0x0000ffff)
+#define GLPM_PMA_STARTUP_CTRL                    GLPM_GLOBAL(0x000080)
+#define GLPM_PMA_STARTUP_CTRL_WMASK              (0x000007ff)
+#define GLPM_PMA_STARTUP_CTRL_MASK               (0x000007ff)
+#define GLPM_PMA_STARTUP_CTRL_DEFAULT            (0x0400)
+#define GLPM_PMA_STARTUP_CTRL_FMASK              (0x000007ff)
+#define GLPM_PMA_STATE                           GLPM_GLOBAL(0x000084)
+#define GLPM_PMA_STATE_WMASK                     (0x00000007)
+#define GLPM_PMA_STATE_MASK                      (0x00000007)
+#define GLPM_PMA_STATE_DEFAULT                   (0x0000)
+#define GLPM_PMA_STATE_FMASK                     (0x00000007)
+#define GLPM_PLL_CTRL1                           GLPM_GLOBAL(0x000088)
+#define GLPM_PLL_CTRL1_WMASK                     (0x0000ffff)
+#define GLPM_PLL_CTRL1_MASK                      (0x0000ffff)
+#define GLPM_PLL_CTRL1_DEFAULT                   (0x8E39)
+#define GLPM_PLL_CTRL1_FMASK                     (0x0000ffff)
+#define GLPM_PLL_CTRL2                           GLPM_GLOBAL(0x00008C)
+#define GLPM_PLL_CTRL2_WMASK                     (0x0000ffff)
+#define GLPM_PLL_CTRL2_MASK                      (0x0000ffff)
+#define GLPM_PLL_CTRL2_DEFAULT                   (0x0383)
+#define GLPM_PLL_CTRL2_FMASK                     (0x0000ffff)
+#define GLPM_PLL_CTRL3                           GLPM_GLOBAL(0x000090)
+#define GLPM_PLL_CTRL3_WMASK                     (0x00003fff)
+#define GLPM_PLL_CTRL3_MASK                      (0x00003fff)
+#define GLPM_PLL_CTRL3_DEFAULT                   (0x0000)
+#define GLPM_PLL_CTRL3_FMASK                     (0x00003fff)
+#define GLPM_PLL_CTRL4                           GLPM_GLOBAL(0x000094)
+#define GLPM_PLL_CTRL4_WMASK                     (0x0000ffff)
+#define GLPM_PLL_CTRL4_MASK                      (0x0000ffff)
+#define GLPM_PLL_CTRL4_DEFAULT                   (0x0000)
+#define GLPM_PLL_CTRL4_FMASK                     (0x0000ffff)
+#define GLPM_PLL_CTRL5                           GLPM_GLOBAL(0x000098)
+#define GLPM_PLL_CTRL5_WMASK                     (0x0000ffff)
+#define GLPM_PLL_CTRL5_MASK                      (0x0000ffff)
+#define GLPM_PLL_CTRL5_DEFAULT                   (0x0000)
+#define GLPM_PLL_CTRL5_FMASK                     (0x0000ffff)
+#define GLPM_PLL_CTRL6                           GLPM_GLOBAL(0x00009C)
+#define GLPM_PLL_CTRL6_WMASK                     (0x0000ffff)
+#define GLPM_PLL_CTRL6_MASK                      (0x0000ffff)
+#define GLPM_PLL_CTRL6_DEFAULT                   (0x0000)
+#define GLPM_PLL_CTRL6_FMASK                     (0x0000ffff)
+#define GLPM_PLL_CTRL7                           GLPM_GLOBAL(0x0000A0)
+#define GLPM_PLL_CTRL7_WMASK                     (0x0000ffff)
+#define GLPM_PLL_CTRL7_MASK                      (0x0000ffff)
+#define GLPM_PLL_CTRL7_DEFAULT                   (0x0000)
+#define GLPM_PLL_CTRL7_FMASK                     (0x0000ffff)
+#define GLPM_PLL_A_CTRL1                         GLPM_GLOBAL(0x0000A4)
+#define GLPM_PLL_A_CTRL1_WMASK                   (0x0000ffff)
+#define GLPM_PLL_A_CTRL1_MASK                    (0x0000ffff)
+#define GLPM_PLL_A_CTRL1_DEFAULT                 (0x1000)
+#define GLPM_PLL_A_CTRL1_FMASK                   (0x0000ffff)
+#define GLPM_PLL_A_CTRL2                         GLPM_GLOBAL(0x0000A8)
+#define GLPM_PLL_A_CTRL2_WMASK                   (0x00007fff)
+#define GLPM_PLL_A_CTRL2_MASK                    (0x00007fff)
+#define GLPM_PLL_A_CTRL2_DEFAULT                 (0x1800)
+#define GLPM_PLL_A_CTRL2_FMASK                   (0x00007fff)
+#define GLPM_PLL_A_CTRL3                         GLPM_GLOBAL(0x0000AC)
+#define GLPM_PLL_A_CTRL3_WMASK                   (0x0000ffff)
+#define GLPM_PLL_A_CTRL3_MASK                    (0x0000ffff)
+#define GLPM_PLL_A_CTRL3_DEFAULT                 (0x0100)
+#define GLPM_PLL_A_CTRL3_FMASK                   (0x0000ffff)
+#define GLPM_PLL_STATUS                          GLPM_GLOBAL(0x0000B0)
+#define GLPM_PLL_STATUS_WMASK                    (0x00000073)
+#define GLPM_PLL_STATUS_MASK                     (0x00000073)
+#define GLPM_PLL_STATUS_DEFAULT                  (0x0000)
+#define GLPM_PLL_STATUS_FMASK                    (0x00000073)
+#define GLPM_TX1_CTRL1                           GLPM_GLOBAL(0x0000C0)
+#define GLPM_TX1_CTRL1_WMASK                     (0x00003f1f)
+#define GLPM_TX1_CTRL1_MASK                      (0x00003f1f)
+#define GLPM_TX1_CTRL1_DEFAULT                   (0x0009)
+#define GLPM_TX1_CTRL1_FMASK                     (0x00003f1f)
+#define GLPM_TX1_CTRL2                           GLPM_GLOBAL(0x0000C4)
+#define GLPM_TX1_CTRL2_WMASK                     (0x00003fff)
+#define GLPM_TX1_CTRL2_MASK                      (0x00003fff)
+#define GLPM_TX1_CTRL2_DEFAULT                   (0x2096)
+#define GLPM_TX1_CTRL2_FMASK                     (0x00003fff)
+#define GLPM_TX1_CTRL3                           GLPM_GLOBAL(0x0000C8)
+#define GLPM_TX1_CTRL3_WMASK                     (0x0000ffff)
+#define GLPM_TX1_CTRL3_MASK                      (0x0000ffff)
+#define GLPM_TX1_CTRL3_DEFAULT                   (0xFFFF)
+#define GLPM_TX1_CTRL3_FMASK                     (0x0000ffff)
+#define GLPM_TX1_A_CTRL1                         GLPM_GLOBAL(0x0000CC)
+#define GLPM_TX1_A_CTRL1_WMASK                   (0x0000ff1f)
+#define GLPM_TX1_A_CTRL1_MASK                    (0x0000ff1f)
+#define GLPM_TX1_A_CTRL1_DEFAULT                 (0x0010)
+#define GLPM_TX1_A_CTRL1_FMASK                   (0x0000ff1f)
+#define GLPM_TX1_A_CTRL2                         GLPM_GLOBAL(0x0000D0)
+#define GLPM_TX1_A_CTRL2_WMASK                   (0x0000ffff)
+#define GLPM_TX1_A_CTRL2_MASK                    (0x0000ffff)
+#define GLPM_TX1_A_CTRL2_DEFAULT                 (0x408F)
+#define GLPM_TX1_A_CTRL2_FMASK                   (0x0000ffff)
+#define GLPM_TX1_MOD1                            GLPM_GLOBAL(0x0000D4)
+#define GLPM_TX1_MOD1_WMASK                      (0x00003fff)
+#define GLPM_TX1_MOD1_MASK                       (0x00003fff)
+#define GLPM_TX1_MOD1_DEFAULT                    (0x0000)
+#define GLPM_TX1_MOD1_FMASK                      (0x00003fff)
+#define GLPM_TX1_MOD2                            GLPM_GLOBAL(0x0000D8)
+#define GLPM_TX1_MOD2_WMASK                      (0x0000ffff)
+#define GLPM_TX1_MOD2_MASK                       (0x0000ffff)
+#define GLPM_TX1_MOD2_DEFAULT                    (0x0000)
+#define GLPM_TX1_MOD2_FMASK                      (0x0000ffff)
+#define GLPM_TX1_MOD3                            GLPM_GLOBAL(0x0000DC)
+#define GLPM_TX1_MOD3_WMASK                      (0x000007ff)
+#define GLPM_TX1_MOD3_MASK                       (0x000007ff)
+#define GLPM_TX1_MOD3_DEFAULT                    (0x0180)
+#define GLPM_TX1_MOD3_FMASK                      (0x000007ff)
+#define GLPM_TX2_CTRL1                           GLPM_GLOBAL(0x0000E0)
+#define GLPM_TX2_CTRL1_WMASK                     (0x00003f1f)
+#define GLPM_TX2_CTRL1_MASK                      (0x00003f1f)
+#define GLPM_TX2_CTRL1_DEFAULT                   (0x0009)
+#define GLPM_TX2_CTRL1_FMASK                     (0x00003f1f)
+#define GLPM_TX2_CTRL2                           GLPM_GLOBAL(0x0000E4)
+#define GLPM_TX2_CTRL2_WMASK                     (0x00003fff)
+#define GLPM_TX2_CTRL2_MASK                      (0x00003fff)
+#define GLPM_TX2_CTRL2_DEFAULT                   (0x2096)
+#define GLPM_TX2_CTRL2_FMASK                     (0x00003fff)
+#define GLPM_TX2_CTRL3                           GLPM_GLOBAL(0x0000E8)
+#define GLPM_TX2_CTRL3_WMASK                     (0x0000ffff)
+#define GLPM_TX2_CTRL3_MASK                      (0x0000ffff)
+#define GLPM_TX2_CTRL3_DEFAULT                   (0xFFFF)
+#define GLPM_TX2_CTRL3_FMASK                     (0x0000ffff)
+#define GLPM_TX2_A_CTRL1                         GLPM_GLOBAL(0x0000EC)
+#define GLPM_TX2_A_CTRL1_WMASK                   (0x0000ff1f)
+#define GLPM_TX2_A_CTRL1_MASK                    (0x0000ff1f)
+#define GLPM_TX2_A_CTRL1_DEFAULT                 (0x0010)
+#define GLPM_TX2_A_CTRL1_FMASK                   (0x0000ff1f)
+#define GLPM_TX2_A_CTRL2                         GLPM_GLOBAL(0x0000F0)
+#define GLPM_TX2_A_CTRL2_WMASK                   (0x0000ffff)
+#define GLPM_TX2_A_CTRL2_MASK                    (0x0000ffff)
+#define GLPM_TX2_A_CTRL2_DEFAULT                 (0x408F)
+#define GLPM_TX2_A_CTRL2_FMASK                   (0x0000ffff)
+#define GLPM_TX2_MOD1                            GLPM_GLOBAL(0x0000F4)
+#define GLPM_TX2_MOD1_WMASK                      (0x00003fff)
+#define GLPM_TX2_MOD1_MASK                       (0x00003fff)
+#define GLPM_TX2_MOD1_DEFAULT                    (0x0000)
+#define GLPM_TX2_MOD1_FMASK                      (0x00003fff)
+#define GLPM_TX2_MOD2                            GLPM_GLOBAL(0x0000F8)
+#define GLPM_TX2_MOD2_WMASK                      (0x0000ffff)
+#define GLPM_TX2_MOD2_MASK                       (0x0000ffff)
+#define GLPM_TX2_MOD2_DEFAULT                    (0x0000)
+#define GLPM_TX2_MOD2_FMASK                      (0x0000ffff)
+#define GLPM_TX2_MOD3                            GLPM_GLOBAL(0x0000FC)
+#define GLPM_TX2_MOD3_WMASK                      (0x000007ff)
+#define GLPM_TX2_MOD3_MASK                       (0x000007ff)
+#define GLPM_TX2_MOD3_DEFAULT                    (0x0180)
+#define GLPM_TX2_MOD3_FMASK                      (0x000007ff)
+#define GLPM_TX3_CTRL1                           GLPM_GLOBAL(0x000100)
+#define GLPM_TX3_CTRL1_WMASK                     (0x00003f1f)
+#define GLPM_TX3_CTRL1_MASK                      (0x00003f1f)
+#define GLPM_TX3_CTRL1_DEFAULT                   (0x0009)
+#define GLPM_TX3_CTRL1_FMASK                     (0x00003f1f)
+#define GLPM_TX3_CTRL2                           GLPM_GLOBAL(0x000104)
+#define GLPM_TX3_CTRL2_WMASK                     (0x00003fff)
+#define GLPM_TX3_CTRL2_MASK                      (0x00003fff)
+#define GLPM_TX3_CTRL2_DEFAULT                   (0x2096)
+#define GLPM_TX3_CTRL2_FMASK                     (0x00003fff)
+#define GLPM_TX3_CTRL3                           GLPM_GLOBAL(0x000108)
+#define GLPM_TX3_CTRL3_WMASK                     (0x0000ffff)
+#define GLPM_TX3_CTRL3_MASK                      (0x0000ffff)
+#define GLPM_TX3_CTRL3_DEFAULT                   (0xFFFF)
+#define GLPM_TX3_CTRL3_FMASK                     (0x0000ffff)
+#define GLPM_TX3_A_CTRL1                         GLPM_GLOBAL(0x00010C)
+#define GLPM_TX3_A_CTRL1_WMASK                   (0x0000ff1f)
+#define GLPM_TX3_A_CTRL1_MASK                    (0x0000ff1f)
+#define GLPM_TX3_A_CTRL1_DEFAULT                 (0x0010)
+#define GLPM_TX3_A_CTRL1_FMASK                   (0x0000ff1f)
+#define GLPM_TX3_A_CTRL2                         GLPM_GLOBAL(0x000110)
+#define GLPM_TX3_A_CTRL2_WMASK                   (0x0000ffff)
+#define GLPM_TX3_A_CTRL2_MASK                    (0x0000ffff)
+#define GLPM_TX3_A_CTRL2_DEFAULT                 (0x408F)
+#define GLPM_TX3_A_CTRL2_FMASK                   (0x0000ffff)
+#define GLPM_TX3_MOD1                            GLPM_GLOBAL(0x000114)
+#define GLPM_TX3_MOD1_WMASK                      (0x00003fff)
+#define GLPM_TX3_MOD1_MASK                       (0x00003fff)
+#define GLPM_TX3_MOD1_DEFAULT                    (0x0000)
+#define GLPM_TX3_MOD1_FMASK                      (0x00003fff)
+#define GLPM_TX3_MOD2                            GLPM_GLOBAL(0x000118)
+#define GLPM_TX3_MOD2_WMASK                      (0x0000ffff)
+#define GLPM_TX3_MOD2_MASK                       (0x0000ffff)
+#define GLPM_TX3_MOD2_DEFAULT                    (0x0000)
+#define GLPM_TX3_MOD2_FMASK                      (0x0000ffff)
+#define GLPM_TX3_MOD3                            GLPM_GLOBAL(0x00011C)
+#define GLPM_TX3_MOD3_WMASK                      (0x000007ff)
+#define GLPM_TX3_MOD3_MASK                       (0x000007ff)
+#define GLPM_TX3_MOD3_DEFAULT                    (0x0180)
+#define GLPM_TX3_MOD3_FMASK                      (0x000007ff)
+#define GLPM_TX4_CTRL1                           GLPM_GLOBAL(0x000120)
+#define GLPM_TX4_CTRL1_WMASK                     (0x00003f1f)
+#define GLPM_TX4_CTRL1_MASK                      (0x00003f1f)
+#define GLPM_TX4_CTRL1_DEFAULT                   (0x0009)
+#define GLPM_TX4_CTRL1_FMASK                     (0x00003f1f)
+#define GLPM_TX4_CTRL2                           GLPM_GLOBAL(0x000124)
+#define GLPM_TX4_CTRL2_WMASK                     (0x00003fff)
+#define GLPM_TX4_CTRL2_MASK                      (0x00003fff)
+#define GLPM_TX4_CTRL2_DEFAULT                   (0x2096)
+#define GLPM_TX4_CTRL2_FMASK                     (0x00003fff)
+#define GLPM_TX4_CTRL3                           GLPM_GLOBAL(0x000128)
+#define GLPM_TX4_CTRL3_WMASK                     (0x0000ffff)
+#define GLPM_TX4_CTRL3_MASK                      (0x0000ffff)
+#define GLPM_TX4_CTRL3_DEFAULT                   (0xFFFF)
+#define GLPM_TX4_CTRL3_FMASK                     (0x0000ffff)
+#define GLPM_TX4_A_CTRL1                         GLPM_GLOBAL(0x00012C)
+#define GLPM_TX4_A_CTRL1_WMASK                   (0x0000ff1f)
+#define GLPM_TX4_A_CTRL1_MASK                    (0x0000ff1f)
+#define GLPM_TX4_A_CTRL1_DEFAULT                 (0x0010)
+#define GLPM_TX4_A_CTRL1_FMASK                   (0x0000ff1f)
+#define GLPM_TX4_A_CTRL2                         GLPM_GLOBAL(0x000130)
+#define GLPM_TX4_A_CTRL2_WMASK                   (0x0000ffff)
+#define GLPM_TX4_A_CTRL2_MASK                    (0x0000ffff)
+#define GLPM_TX4_A_CTRL2_DEFAULT                 (0x408F)
+#define GLPM_TX4_A_CTRL2_FMASK                   (0x0000ffff)
+#define GLPM_TX4_MOD1                            GLPM_GLOBAL(0x000134)
+#define GLPM_TX4_MOD1_WMASK                      (0x00003fff)
+#define GLPM_TX4_MOD1_MASK                       (0x00003fff)
+#define GLPM_TX4_MOD1_DEFAULT                    (0x0000)
+#define GLPM_TX4_MOD1_FMASK                      (0x00003fff)
+#define GLPM_TX4_MOD2                            GLPM_GLOBAL(0x000138)
+#define GLPM_TX4_MOD2_WMASK                      (0x0000ffff)
+#define GLPM_TX4_MOD2_MASK                       (0x0000ffff)
+#define GLPM_TX4_MOD2_DEFAULT                    (0x0000)
+#define GLPM_TX4_MOD2_FMASK                      (0x0000ffff)
+#define GLPM_TX4_MOD3                            GLPM_GLOBAL(0x00013C)
+#define GLPM_TX4_MOD3_WMASK                      (0x000007ff)
+#define GLPM_TX4_MOD3_MASK                       (0x000007ff)
+#define GLPM_TX4_MOD3_DEFAULT                    (0x0180)
+#define GLPM_TX4_MOD3_FMASK                      (0x000007ff)
+#define GLPM_RX1_CTRL1                           GLPM_GLOBAL(0x000140)
+#define GLPM_RX1_CTRL1_WMASK                     (0x00003fff)
+#define GLPM_RX1_CTRL1_MASK                      (0x00003fff)
+#define GLPM_RX1_CTRL1_DEFAULT                   (0x0005)
+#define GLPM_RX1_CTRL1_FMASK                     (0x00003fff)
+#define GLPM_RX1_CTRL2                           GLPM_GLOBAL(0x000144)
+#define GLPM_RX1_CTRL2_WMASK                     (0x00003fff)
+#define GLPM_RX1_CTRL2_MASK                      (0x00003fff)
+#define GLPM_RX1_CTRL2_DEFAULT                   (0x2000)
+#define GLPM_RX1_CTRL2_FMASK                     (0x00003fff)
+#define GLPM_RX1_CDR                             GLPM_GLOBAL(0x000148)
+#define GLPM_RX1_CDR_WMASK                       (0x00000377)
+#define GLPM_RX1_CDR_MASK                        (0x00000377)
+#define GLPM_RX1_CDR_DEFAULT                     (0x0144)
+#define GLPM_RX1_CDR_FMASK                       (0x00000377)
+#define GLPM_RX1_EI                              GLPM_GLOBAL(0x00014C)
+#define GLPM_RX1_EI_WMASK                        (0x0000ffff)
+#define GLPM_RX1_EI_MASK                         (0x0000ffff)
+#define GLPM_RX1_EI_DEFAULT                      (0xFFFF)
+#define GLPM_RX1_EI_FMASK                        (0x0000ffff)
+#define GLPM_RX1_CAL                             GLPM_GLOBAL(0x000150)
+#define GLPM_RX1_CAL_WMASK                       (0x000003ff)
+#define GLPM_RX1_CAL_MASK                        (0x000003ff)
+#define GLPM_RX1_CAL_DEFAULT                     (0x00FF)
+#define GLPM_RX1_CAL_FMASK                       (0x000003ff)
+#define GLPM_RX1_A_CTRL                          GLPM_GLOBAL(0x000154)
+#define GLPM_RX1_A_CTRL_WMASK                    (0x00007fff)
+#define GLPM_RX1_A_CTRL_MASK                     (0x00007fff)
+#define GLPM_RX1_A_CTRL_DEFAULT                  (0x6800)
+#define GLPM_RX1_A_CTRL_FMASK                    (0x00007fff)
+#define GLPM_RX1_TEST_CTRL                       GLPM_GLOBAL(0x000158)
+#define GLPM_RX1_TEST_CTRL_WMASK                 (0x00000003)
+#define GLPM_RX1_TEST_CTRL_MASK                  (0x00000003)
+#define GLPM_RX1_TEST_CTRL_DEFAULT               (0x0002)
+#define GLPM_RX1_TEST_CTRL_FMASK                 (0x00000003)
+#define GLPM_RX2_CTRL1                           GLPM_GLOBAL(0x000160)
+#define GLPM_RX2_CTRL1_WMASK                     (0x00003fff)
+#define GLPM_RX2_CTRL1_MASK                      (0x00003fff)
+#define GLPM_RX2_CTRL1_DEFAULT                   (0x0005)
+#define GLPM_RX2_CTRL1_FMASK                     (0x00003fff)
+#define GLPM_RX2_CTRL2                           GLPM_GLOBAL(0x000164)
+#define GLPM_RX2_CTRL2_WMASK                     (0x00003fff)
+#define GLPM_RX2_CTRL2_MASK                      (0x00003fff)
+#define GLPM_RX2_CTRL2_DEFAULT                   (0x2000)
+#define GLPM_RX2_CTRL2_FMASK                     (0x00003fff)
+#define GLPM_RX2_CDR                             GLPM_GLOBAL(0x000168)
+#define GLPM_RX2_CDR_WMASK                       (0x00000377)
+#define GLPM_RX2_CDR_MASK                        (0x00000377)
+#define GLPM_RX2_CDR_DEFAULT                     (0x0144)
+#define GLPM_RX2_CDR_FMASK                       (0x00000377)
+#define GLPM_RX2_EI                              GLPM_GLOBAL(0x00016C)
+#define GLPM_RX2_EI_WMASK                        (0x0000ffff)
+#define GLPM_RX2_EI_MASK                         (0x0000ffff)
+#define GLPM_RX2_EI_DEFAULT                      (0xFFFF)
+#define GLPM_RX2_EI_FMASK                        (0x0000ffff)
+#define GLPM_RX2_CAL                             GLPM_GLOBAL(0x000170)
+#define GLPM_RX2_CAL_WMASK                       (0x000003ff)
+#define GLPM_RX2_CAL_MASK                        (0x000003ff)
+#define GLPM_RX2_CAL_DEFAULT                     (0x00FF)
+#define GLPM_RX2_CAL_FMASK                       (0x000003ff)
+#define GLPM_RX2_A_CTRL                          GLPM_GLOBAL(0x000174)
+#define GLPM_RX2_A_CTRL_WMASK                    (0x00007fff)
+#define GLPM_RX2_A_CTRL_MASK                     (0x00007fff)
+#define GLPM_RX2_A_CTRL_DEFAULT                  (0x6800)
+#define GLPM_RX2_A_CTRL_FMASK                    (0x00007fff)
+#define GLPM_RX2_TEST_CTRL                       GLPM_GLOBAL(0x000178)
+#define GLPM_RX2_TEST_CTRL_WMASK                 (0x00000003)
+#define GLPM_RX2_TEST_CTRL_MASK                  (0x00000003)
+#define GLPM_RX2_TEST_CTRL_DEFAULT               (0x0002)
+#define GLPM_RX2_TEST_CTRL_FMASK                 (0x00000003)
+
+/* Cri Memory Address Constants */
+
+/* Cri Global Address Constants */
+#define cri_global_base        (0x20C400)
+#define CRI_GLOBAL(r)          (int)(cri_global_base + (r))
+#define cri_global_size        (0x0200)
+
+#define CRI_CCR                CRI_GLOBAL(0x0000)
+#define CRI_CCR_WMASK          (0x001F)
+#define CRI_CCR_MASK           (0x001F)
+#define CRI_CCR_DEFAULT        (0x0000)
+#define CRI_CCR_FMASK          (0x001F)
+#define CRI_RST                CRI_GLOBAL(0x0004)
+#define CRI_RST_WMASK          (0x007F)
+#define CRI_RST_MASK           (0x007F)
+#define CRI_RST_DEFAULT        (0x0000)
+#define CRI_RST_FMASK          (0x007F)
+#define CRI_PORT_MODE          CRI_GLOBAL(0x0008)
+#define CRI_PORT_MODE_WMASK    (0x1555)
+#define CRI_PORT_MODE_MASK     (0x1555)
+#define CRI_PORT_MODE_DEFAULT  (0x0000)
+#define CRI_PORT_MODE_FMASK    (0x1555)
+#define CRI_TSC_CTRL           CRI_GLOBAL(0x000C)
+#define CRI_TSC_CTRL_WMASK     (0xFFFFFFF)
+#define CRI_TSC_CTRL_MASK      (0x8FFFFFFF)
+#define CRI_TSC_CTRL_DEFAULT   (0x1FFFE0)
+#define CRI_TSC_CTRL_FMASK     (0xFFFFFFF)
+#define CRI_TSC_STATUS         CRI_GLOBAL(0x0010)
+#define CRI_TSC_STATUS_WMASK   (0x0000)
+#define CRI_TSC_STATUS_MASK    (0x3FFFFF)
+#define CRI_TSC_STATUS_DEFAULT (0x0000)
+#define CRI_TSC_STATUS_FMASK   (0x3FFFFF)
+#define CRI_TX_TSLOTC_A        CRI_GLOBAL(0x0014)
+#define CRI_TX_TSLOTC_A_WMASK  (0x0000)
+#define CRI_TX_TSLOTC_A_MASK   (0x3E0FFFFF)
+#define CRI_TX_TSLOTC_A_DEFAULT (0x3E0FFFFF)
+#define CRI_TX_TSLOTC_A_FMASK  (0x0000)
+#define CRI_TX_TSLOTC_B        CRI_GLOBAL(0x0018)
+#define CRI_TX_TSLOTC_B_WMASK  (0x0000)
+#define CRI_TX_TSLOTC_B_MASK   (0x3E0FFFFF)
+#define CRI_TX_TSLOTC_B_DEFAULT (0x3E0FFFFF)
+#define CRI_TX_TSLOTC_B_FMASK  (0x0000)
+#define CRI_TX_TSLOT0          CRI_GLOBAL(0x001C)
+#define CRI_TX_TSLOT0_WMASK    (0x3E0FFFFF)
+#define CRI_TX_TSLOT0_MASK     (0x3E0FFFFF)
+#define CRI_TX_TSLOT0_DEFAULT  (0x3E0FFFFF)
+#define CRI_TX_TSLOT0_FMASK    (0x3E0FFFFF)
+#define CRI_TX_TSLOT1          CRI_GLOBAL(0x0020)
+#define CRI_TX_TSLOT1_WMASK    (0x3E0FFFFF)
+#define CRI_TX_TSLOT1_MASK     (0x3E0FFFFF)
+#define CRI_TX_TSLOT1_DEFAULT  (0x3E0FFFFF)
+#define CRI_TX_TSLOT1_FMASK    (0x3E0FFFFF)
+#define CRI_RX_TSLOTC_A        CRI_GLOBAL(0x0024)
+#define CRI_RX_TSLOTC_A_WMASK  (0x0000)
+#define CRI_RX_TSLOTC_A_MASK   (0x3E0FFFFF)
+#define CRI_RX_TSLOTC_A_DEFAULT (0x3E0FFFFF)
+#define CRI_RX_TSLOTC_A_FMASK  (0x0000)
+#define CRI_RX_TSLOTC_B        CRI_GLOBAL(0x0028)
+#define CRI_RX_TSLOTC_B_WMASK  (0x0000)
+#define CRI_RX_TSLOTC_B_MASK   (0x3E0FFFFF)
+#define CRI_RX_TSLOTC_B_DEFAULT (0x3E0FFFFF)
+#define CRI_RX_TSLOTC_B_FMASK  (0x0000)
+#define CRI_RX_TSLOT0          CRI_GLOBAL(0x002C)
+#define CRI_RX_TSLOT0_WMASK    (0x3E0FFFFF)
+#define CRI_RX_TSLOT0_MASK     (0x3E0FFFFF)
+#define CRI_RX_TSLOT0_DEFAULT  (0x3E0FFFFF)
+#define CRI_RX_TSLOT0_FMASK    (0x3E0FFFFF)
+#define CRI_RX_TSLOT1          CRI_GLOBAL(0x0030)
+#define CRI_RX_TSLOT1_WMASK    (0x3E0FFFFF)
+#define CRI_RX_TSLOT1_MASK     (0x3E0FFFFF)
+#define CRI_RX_TSLOT1_DEFAULT  (0x3E0FFFFF)
+#define CRI_RX_TSLOT1_FMASK    (0x3E0FFFFF)
+#define CRI_TX_ATSLOTC_A       CRI_GLOBAL(0x0034)
+#define CRI_TX_ATSLOTC_A_WMASK (0x0000)
+#define CRI_TX_ATSLOTC_A_MASK  (0x3E000000)
+#define CRI_TX_ATSLOTC_A_DEFAULT (0x3E000000)
+#define CRI_TX_ATSLOTC_A_FMASK (0x0000)
+#define CRI_TX_ATSLOTC_B       CRI_GLOBAL(0x0038)
+#define CRI_TX_ATSLOTC_B_WMASK (0x0000)
+#define CRI_TX_ATSLOTC_B_MASK  (0x3E000000)
+#define CRI_TX_ATSLOTC_B_DEFAULT (0x3E000000)
+#define CRI_TX_ATSLOTC_B_FMASK (0x0000)
+#define CRI_TX_ATSLOT0         CRI_GLOBAL(0x003C)
+#define CRI_TX_ATSLOT0_WMASK   (0x3E000000)
+#define CRI_TX_ATSLOT0_MASK    (0x3E000000)
+#define CRI_TX_ATSLOT0_DEFAULT (0x3E000000)
+#define CRI_TX_ATSLOT0_FMASK   (0x3E000000)
+#define CRI_TX_ATSLOT1         CRI_GLOBAL(0x0040)
+#define CRI_TX_ATSLOT1_WMASK   (0x3E000000)
+#define CRI_TX_ATSLOT1_MASK    (0x3E000000)
+#define CRI_TX_ATSLOT1_DEFAULT (0x3E000000)
+#define CRI_TX_ATSLOT1_FMASK   (0x3E000000)
+#define CRI_RX_ATSLOTC_A       CRI_GLOBAL(0x0044)
+#define CRI_RX_ATSLOTC_A_WMASK (0x0000)
+#define CRI_RX_ATSLOTC_A_MASK  (0x3E000000)
+#define CRI_RX_ATSLOTC_A_DEFAULT (0x3E000000)
+#define CRI_RX_ATSLOTC_A_FMASK (0x0000)
+#define CRI_RX_ATSLOTC_B       CRI_GLOBAL(0x0048)
+#define CRI_RX_ATSLOTC_B_WMASK (0x0000)
+#define CRI_RX_ATSLOTC_B_MASK  (0x3E000000)
+#define CRI_RX_ATSLOTC_B_DEFAULT (0x3E000000)
+#define CRI_RX_ATSLOTC_B_FMASK (0x0000)
+#define CRI_RX_ATSLOT0         CRI_GLOBAL(0x004C)
+#define CRI_RX_ATSLOT0_WMASK   (0x3E000000)
+#define CRI_RX_ATSLOT0_MASK    (0x3E000000)
+#define CRI_RX_ATSLOT0_DEFAULT (0x3E000000)
+#define CRI_RX_ATSLOT0_FMASK   (0x3E000000)
+#define CRI_RX_ATSLOT1         CRI_GLOBAL(0x0050)
+#define CRI_RX_ATSLOT1_WMASK   (0x3E000000)
+#define CRI_RX_ATSLOT1_MASK    (0x3E000000)
+#define CRI_RX_ATSLOT1_DEFAULT (0x3E000000)
+#define CRI_RX_ATSLOT1_FMASK   (0x3E000000)
+#define CRI_RXGP0_CTL          CRI_GLOBAL(0x0054)
+#define CRI_RXGP0_CTL_WMASK    (0x000F)
+#define CRI_RXGP0_CTL_MASK     (0x000F)
+#define CRI_RXGP0_CTL_DEFAULT  (0x0000)
+#define CRI_RXGP0_CTL_FMASK    (0x000F)
+#define CRI_RXGP1_CTL          CRI_GLOBAL(0x0058)
+#define CRI_RXGP1_CTL_WMASK    (0x000F)
+#define CRI_RXGP1_CTL_MASK     (0x000F)
+#define CRI_RXGP1_CTL_DEFAULT  (0x0000)
+#define CRI_RXGP1_CTL_FMASK    (0x000F)
+#define CRI_TXGP0_CTL          CRI_GLOBAL(0x005C)
+#define CRI_TXGP0_CTL_WMASK    (0x000F)
+#define CRI_TXGP0_CTL_MASK     (0x000F)
+#define CRI_TXGP0_CTL_DEFAULT  (0x0000)
+#define CRI_TXGP0_CTL_FMASK    (0x000F)
+#define CRI_TXGP1_CTL          CRI_GLOBAL(0x0060)
+#define CRI_TXGP1_CTL_WMASK    (0x000F)
+#define CRI_TXGP1_CTL_MASK     (0x000F)
+#define CRI_TXGP1_CTL_DEFAULT  (0x0000)
+#define CRI_TXGP1_CTL_FMASK    (0x000F)
+#define CRI_RXGP0_VAL          CRI_GLOBAL(0x0064)
+#define CRI_RXGP0_VAL_WMASK    (0xFFFFF)
+#define CRI_RXGP0_VAL_MASK     (0xFFFFF)
+#define CRI_RXGP0_VAL_DEFAULT  (0x0000)
+#define CRI_RXGP0_VAL_FMASK    (0xFFFFF)
+#define CRI_RXGP1_VAL          CRI_GLOBAL(0x0068)
+#define CRI_RXGP1_VAL_WMASK    (0xFFFFF)
+#define CRI_RXGP1_VAL_MASK     (0xFFFFF)
+#define CRI_RXGP1_VAL_DEFAULT  (0x0000)
+#define CRI_RXGP1_VAL_FMASK    (0xFFFFF)
+#define CRI_TXGP0_MCNT         CRI_GLOBAL(0x006C)
+#define CRI_TXGP0_MCNT_WMASK   (0xFFFFF)
+#define CRI_TXGP0_MCNT_MASK    (0xFFFFF)
+#define CRI_TXGP0_MCNT_DEFAULT (0x0000)
+#define CRI_TXGP0_MCNT_FMASK   (0xFFFFF)
+#define CRI_TXGP1_MCNT         CRI_GLOBAL(0x0070)
+#define CRI_TXGP1_MCNT_WMASK   (0xFFFFF)
+#define CRI_TXGP1_MCNT_MASK    (0xFFFFF)
+#define CRI_TXGP1_MCNT_DEFAULT (0x0000)
+#define CRI_TXGP1_MCNT_FMASK   (0xFFFFF)
+#define CRI_MASK0_TX           CRI_GLOBAL(0x0074)
+#define CRI_MASK0_TX_WMASK     (0x37B80050)
+#define CRI_MASK0_TX_MASK      (0x37B80050)
+#define CRI_MASK0_TX_DEFAULT   (0x0000)
+#define CRI_MASK0_TX_FMASK     (0x37B80050)
+#define CRI_MASK0_RX           CRI_GLOBAL(0x0078)
+#define CRI_MASK0_RX_WMASK     (0xC807FFAF)
+#define CRI_MASK0_RX_MASK      (0xC807FFAF)
+#define CRI_MASK0_RX_DEFAULT   (0x0000)
+#define CRI_MASK0_RX_FMASK     (0xC807FFAF)
+#define CRI_MASK1_TX           CRI_GLOBAL(0x007C)
+#define CRI_MASK1_TX_WMASK     (0x37B80050)
+#define CRI_MASK1_TX_MASK      (0x37B80050)
+#define CRI_MASK1_TX_DEFAULT   (0x0000)
+#define CRI_MASK1_TX_FMASK     (0x37B80050)
+#define CRI_MASK1_RX           CRI_GLOBAL(0x0080)
+#define CRI_MASK1_RX_WMASK     (0xC807FFAF)
+#define CRI_MASK1_RX_MASK      (0xC807FFAF)
+#define CRI_MASK1_RX_DEFAULT   (0x0000)
+#define CRI_MASK1_RX_FMASK     (0xC807FFAF)
+#define CRI_STATUS0            CRI_GLOBAL(0x0084)
+#define CRI_STATUS0_WMASK      (0xFFBFFFFF)
+#define CRI_STATUS0_MASK       (0xFFBFFFFF)
+#define CRI_STATUS0_DEFAULT    (0x0000)
+#define CRI_STATUS0_FMASK      (0x0000)
+#define CRI_STATUS1            CRI_GLOBAL(0x0088)
+#define CRI_STATUS1_WMASK      (0xFFBFFFFF)
+#define CRI_STATUS1_MASK       (0xFFBFFFFF)
+#define CRI_STATUS1_DEFAULT    (0x0000)
+#define CRI_STATUS1_FMASK      (0x0000)
+#define CRI_AMASK0_TX          CRI_GLOBAL(0x008C)
+#define CRI_AMASK0_TX_WMASK    (0x0000)
+#define CRI_AMASK0_TX_MASK     (0x0000)
+#define CRI_AMASK0_TX_DEFAULT  (0x0000)
+#define CRI_AMASK0_TX_FMASK    (0x0000)
+#define CRI_AMASK0_RX          CRI_GLOBAL(0x0090)
+#define CRI_AMASK0_RX_WMASK    (0x0000)
+#define CRI_AMASK0_RX_MASK     (0x0000)
+#define CRI_AMASK0_RX_DEFAULT  (0x0000)
+#define CRI_AMASK0_RX_FMASK    (0x0000)
+#define CRI_AMASK1_TX          CRI_GLOBAL(0x0094)
+#define CRI_AMASK1_TX_WMASK    (0x0000)
+#define CRI_AMASK1_TX_MASK     (0x0000)
+#define CRI_AMASK1_TX_DEFAULT  (0x0000)
+#define CRI_AMASK1_TX_FMASK    (0x0000)
+#define CRI_AMASK1_RX          CRI_GLOBAL(0x0098)
+#define CRI_AMASK1_RX_WMASK    (0x0000)
+#define CRI_AMASK1_RX_MASK     (0x0000)
+#define CRI_AMASK1_RX_DEFAULT  (0x0000)
+#define CRI_AMASK1_RX_FMASK    (0x0000)
+#define CRI_UPDCTL             CRI_GLOBAL(0x009C)
+#define CRI_UPDCTL_WMASK       (0xA000)
+#define CRI_UPDCTL_MASK        (0xF1FE)
+#define CRI_UPDCTL_DEFAULT     (0x0000)
+#define CRI_UPDCTL_FMASK       (0xA000)
+#define CRI_EVENT              CRI_GLOBAL(0x00A0)
+#define CRI_EVENT_WMASK        (0xFFBFFFFF)
+#define CRI_EVENT_MASK         (0xFFBFFFFF)
+#define CRI_EVENT_DEFAULT      (0x0000)
+#define CRI_EVENT_FMASK        (0x0000)
+#define CRI_TX_TIMER           CRI_GLOBAL(0x00A4)
+#define CRI_TX_TIMER_WMASK     (0xFFFFF)
+#define CRI_TX_TIMER_MASK      (0xFFFFF)
+#define CRI_TX_TIMER_DEFAULT   (0x0000)
+#define CRI_TX_TIMER_FMASK     (0xFFFFF)
+#define CRI_TX_TIMER_CTL       CRI_GLOBAL(0x00A8)
+#define CRI_TX_TIMER_CTL_WMASK (0x6FFFFF)
+#define CRI_TX_TIMER_CTL_MASK  (0x7FFFFF)
+#define CRI_TX_TIMER_CTL_DEFAULT (0x0000)
+#define CRI_TX_TIMER_CTL_FMASK (0x6FFFFF)
+#define CRI_RX_TIMER           CRI_GLOBAL(0x00AC)
+#define CRI_RX_TIMER_WMASK     (0xFFFFF)
+#define CRI_RX_TIMER_MASK      (0xFFFFF)
+#define CRI_RX_TIMER_DEFAULT   (0x0000)
+#define CRI_RX_TIMER_FMASK     (0xFFFFF)
+#define CRI_RX_TIMER_CTL       CRI_GLOBAL(0x00B0)
+#define CRI_RX_TIMER_CTL_WMASK (0x6FFFFF)
+#define CRI_RX_TIMER_CTL_MASK  (0x7FFFFF)
+#define CRI_RX_TIMER_CTL_DEFAULT (0x0000)
+#define CRI_RX_TIMER_CTL_FMASK (0x6FFFFF)
+#define CRI_TX_PMS_CTL         CRI_GLOBAL(0x00B4)
+#define CRI_TX_PMS_CTL_WMASK   (0x7FFFFF)
+#define CRI_TX_PMS_CTL_MASK    (0xFFFFFF)
+#define CRI_TX_PMS_CTL_DEFAULT (0x0000)
+#define CRI_TX_PMS_CTL_FMASK   (0x7FFFFF)
+#define CRI_TX_QTP_CTL         CRI_GLOBAL(0x00B8)
+#define CRI_TX_QTP_CTL_WMASK   (0x7FFFFF)
+#define CRI_TX_QTP_CTL_MASK    (0xFFFFFF)
+#define CRI_TX_QTP_CTL_DEFAULT (0x0000)
+#define CRI_TX_QTP_CTL_FMASK   (0x7FFFFF)
+#define CRI_TX_QT_CTL          CRI_GLOBAL(0x00BC)
+#define CRI_TX_QT_CTL_WMASK    (0x7FFFFF)
+#define CRI_TX_QT_CTL_MASK     (0xFFFFFF)
+#define CRI_TX_QT_CTL_DEFAULT  (0x0000)
+#define CRI_TX_QT_CTL_FMASK    (0x7FFFFF)
+#define CRI_TX_IFFT_CTL        CRI_GLOBAL(0x00C0)
+#define CRI_TX_IFFT_CTL_WMASK  (0x7FFFFF)
+#define CRI_TX_IFFT_CTL_MASK   (0xFFFFFF)
+#define CRI_TX_IFFT_CTL_DEFAULT (0x0000)
+#define CRI_TX_IFFT_CTL_FMASK  (0x7FFFFF)
+#define CRI_RX_FFT_CTL         CRI_GLOBAL(0x00C4)
+#define CRI_RX_FFT_CTL_WMASK   (0x7FFFFF)
+#define CRI_RX_FFT_CTL_MASK    (0xFFFFFF)
+#define CRI_RX_FFT_CTL_DEFAULT (0x0000)
+#define CRI_RX_FFT_CTL_FMASK   (0x7FFFFF)
+#define CRI_RX_QT_CTL          CRI_GLOBAL(0x00C8)
+#define CRI_RX_QT_CTL_WMASK    (0x7FFFFF)
+#define CRI_RX_QT_CTL_MASK     (0xFFFFFF)
+#define CRI_RX_QT_CTL_DEFAULT  (0x0000)
+#define CRI_RX_QT_CTL_FMASK    (0x7FFFFF)
+#define CRI_RX_QTP_CTL         CRI_GLOBAL(0x00CC)
+#define CRI_RX_QTP_CTL_WMASK   (0x7FFFFF)
+#define CRI_RX_QTP_CTL_MASK    (0xFFFFFF)
+#define CRI_RX_QTP_CTL_DEFAULT (0x0000)
+#define CRI_RX_QTP_CTL_FMASK   (0x7FFFFF)
+#define CRI_RX_PMS_CTL         CRI_GLOBAL(0x00D0)
+#define CRI_RX_PMS_CTL_WMASK   (0x7FFFFF)
+#define CRI_RX_PMS_CTL_MASK    (0xFFFFFF)
+#define CRI_RX_PMS_CTL_DEFAULT (0x0000)
+#define CRI_RX_PMS_CTL_FMASK   (0x7FFFFF)
+#define CRI_TX_QT_STALL        CRI_GLOBAL(0x00D4)
+#define CRI_TX_QT_STALL_WMASK  (0x3FFFF)
+#define CRI_TX_QT_STALL_MASK   (0xFFFFF)
+#define CRI_TX_QT_STALL_DEFAULT (0x40000)
+#define CRI_TX_QT_STALL_FMASK  (0x1FFFF)
+#define CRI_RX_QT_STALL        CRI_GLOBAL(0x00D8)
+#define CRI_RX_QT_STALL_WMASK  (0x3FFFF)
+#define CRI_RX_QT_STALL_MASK   (0xFFFFF)
+#define CRI_RX_QT_STALL_DEFAULT (0x40000)
+#define CRI_RX_QT_STALL_FMASK  (0x1FFFF)
+#define CRI_RX_FFT_STALL_CTL   CRI_GLOBAL(0x00DC)
+#define CRI_RX_FFT_STALL_CTL_WMASK (0x3FFFFF)
+#define CRI_RX_FFT_STALL_CTL_MASK (0xBFFFFF)
+#define CRI_RX_FFT_STALL_CTL_DEFAULT (0x0000)
+#define CRI_RX_FFT_STALL_CTL_FMASK (0x3FFFFF)
+#define CRI_NTR_CPE_CTRL       CRI_GLOBAL(0x00E0)
+#define CRI_NTR_CPE_CTRL_WMASK (0x7FFFF)
+#define CRI_NTR_CPE_CTRL_MASK  (0x8007FFFF)
+#define CRI_NTR_CPE_CTRL_DEFAULT (0x8A00)
+#define CRI_NTR_CPE_CTRL_FMASK (0x7FFFF)
+#define CRI_NTRSRCFR           CRI_GLOBAL(0x00E4)
+#define CRI_NTRSRCFR_WMASK     (0xFFFFF)
+#define CRI_NTRSRCFR_MASK      (0xFFFFF)
+#define CRI_NTRSRCFR_DEFAULT   (0xECE2A)
+#define CRI_NTRSRCFR_FMASK     (0xFFFFF)
+#define CRI_NTRPHASE           CRI_GLOBAL(0x00E8)
+#define CRI_NTRPHASE_WMASK     (0x0000)
+#define CRI_NTRPHASE_MASK      (0x1FFFF)
+#define CRI_NTRPHASE_DEFAULT   (0x0000)
+#define CRI_NTRPHASE_FMASK     (0x1FFFF)
+#define CRI_NTR_CO_CTRL        CRI_GLOBAL(0x00EC)
+#define CRI_NTR_CO_CTRL_WMASK  (0x3FFFC000)
+#define CRI_NTR_CO_CTRL_MASK   (0xBFFFC3FF)
+#define CRI_NTR_CO_CTRL_DEFAULT (0x0000)
+#define CRI_NTR_CO_CTRL_FMASK  (0x3FFFC2FF)
+#define CRI_NTR_CO_PERP_NUM    CRI_GLOBAL(0x00F0)
+#define CRI_NTR_CO_PERP_NUM_WMASK (0xFFFFFFFF)
+#define CRI_NTR_CO_PERP_NUM_MASK (0xFFFFFFFF)
+#define CRI_NTR_CO_PERP_NUM_DEFAULT (0x0000)
+#define CRI_NTR_CO_PERP_NUM_FMASK (0xFFFFFFFF)
+#define CRI_NTR_CO_PERP_DENOM  CRI_GLOBAL(0x00F4)
+#define CRI_NTR_CO_PERP_DENOM_WMASK (0xFFFFFFFF)
+#define CRI_NTR_CO_PERP_DENOM_MASK (0xFFFFFFFF)
+#define CRI_NTR_CO_PERP_DENOM_DEFAULT (0x0000)
+#define CRI_NTR_CO_PERP_DENOM_FMASK (0xFFFFFFFF)
+#define CRI_FCIMASK2_TX        CRI_GLOBAL(0x00F8)
+#define CRI_FCIMASK2_TX_WMASK  (0x37B80050)
+#define CRI_FCIMASK2_TX_MASK   (0x37B80050)
+#define CRI_FCIMASK2_TX_DEFAULT (0x0000)
+#define CRI_FCIMASK2_TX_FMASK  (0x37B80050)
+#define CRI_FCIMASK2_RX        CRI_GLOBAL(0x00FC)
+#define CRI_FCIMASK2_RX_WMASK  (0xC807FFAF)
+#define CRI_FCIMASK2_RX_MASK   (0xC807FFAF)
+#define CRI_FCIMASK2_RX_DEFAULT (0x0000)
+#define CRI_FCIMASK2_RX_FMASK  (0xC807FFAF)
+#define CRI_FCIMASK3_TX        CRI_GLOBAL(0x0100)
+#define CRI_FCIMASK3_TX_WMASK  (0x37B80050)
+#define CRI_FCIMASK3_TX_MASK   (0x37B80050)
+#define CRI_FCIMASK3_TX_DEFAULT (0x0000)
+#define CRI_FCIMASK3_TX_FMASK  (0x37B80050)
+#define CRI_FCIMASK3_RX        CRI_GLOBAL(0x0104)
+#define CRI_FCIMASK3_RX_WMASK  (0xC807FFAF)
+#define CRI_FCIMASK3_RX_MASK   (0xC807FFAF)
+#define CRI_FCIMASK3_RX_DEFAULT (0x0000)
+#define CRI_FCIMASK3_RX_FMASK  (0xC807FFAF)
+#define CRI_FCISTATUS2         CRI_GLOBAL(0x0108)
+#define CRI_FCISTATUS2_WMASK   (0xFFBFFFFF)
+#define CRI_FCISTATUS2_MASK    (0xFFBFFFFF)
+#define CRI_FCISTATUS2_DEFAULT (0x0000)
+#define CRI_FCISTATUS2_FMASK   (0x0000)
+#define CRI_FCISTATUS3         CRI_GLOBAL(0x010C)
+#define CRI_FCISTATUS3_WMASK   (0xFFBFFFFF)
+#define CRI_FCISTATUS3_MASK    (0xFFBFFFFF)
+#define CRI_FCISTATUS3_DEFAULT (0x0000)
+#define CRI_FCISTATUS3_FMASK   (0x0000)
+
+// Register Definitions
+#define aux_access 0x0
+#define dmp_access 0x1 // or 0x2
+#define core_access 0x3
+
+//* Registers in the ARC address space */
+//* ARC auxiliary space definitions */
+#define AUX_STATUS 0x0000
+#define AUX_SEMAPHORE 0x0001
+#define AUX_LP_START 0x0002
+#define AUX_LP_END 0x0003
+#define AUX_IDENTITY 0x0004
+#define AUX_DEBUG 0x0005
+#define AUX_LOCAL_RAM 0x20
+#define AUX_HINT 0x0023
+#define AUX_PCPORT 0x0024
+#define AUX_AX0 0x0030
+#define AUX_AX1 0x0031
+#define AUX_AY0 0x0032
+#define AUX_AY1 0x0033
+#define AUX_MX0 0x0034
+#define AUX_MX1 0x0035
+#define AUX_MY0 0x0036
+#define AUX_MY1 0x0037
+
+#define AUX_XRAM_BASE 0x2000
+#define AUX_YRAM_BASE 0x4000
+
+#define AUX_ADMA_CTRL_AC 0x100
+#define AUX_ADMA_STAT_AC 0x101
+#define AUX_ADMA_SAD_S_AC 0x102
+#define AUX_ADMA_DAD_S_AC 0x103
+#define AUX_ADMA_SAD_E_AC 0x104
+#define AUX_ADMA_FILL_AC  0x105
+#define AUX_MEI_TO_ARC_INT 0x106
+#define AUX_ARC_TO_MEI_INT 0x107
+#define AUX_ME_CONFIG 0x108
+#define AUX_ADSL_MEMTEST 0x109
+#define AUX_ARC_INT_MASK 0x10A
+#define AUX_ARC_INT_EVENT 0x10B
+#define AUX_GPIO_CTRL 0x10C
+#define AUX_GPIO_DATA 0x10D
+#define AUX_ARC_GP_STAT 0x10E
+#define AUX_XDMA_CTRL 0x10F
+#define AUX_XDMA_STAT 0x110
+#define AUX_XDMA_SA_S 0x111
+#define AUX_XDMA_DA_S 0x112
+#define AUX_XDMA_SA_E 0x113
+#define AUX_XDMA_GAP  0x114
+#define AUX_XDATA_BASE_SH 0x115
+#define AUX_XDATA_BASE 0x116
+#define AUX_XMEM_BAR0 0x117
+#define AUX_XMEM_BAR1 0x118
+#define AUX_XMEM_BAR2 0x119
+#define AUX_XMEM_BAR3 0x11A
+#define AUX_XMEM_BAR4 0x11B
+#define AUX_XMEM_BAR5 0x11C
+#define AUX_XMEM_BAR6 0x11D
+#define AUX_XMEM_BAR7 0x11E
+#define AUX_XMEM_BAR8 0x11F
+#define AUX_XMEM_BAR9 0x120
+#define AUX_XMEM_BAR10 0x121
+#define AUX_XMEM_BAR11 0x122
+#define AUX_XMEM_BAR12 0x123
+#define AUX_XMEM_BAR13 0x124
+#define AUX_XMEM_BAR14 0x125
+#define AUX_XMEM_BAR15 0x126
+#define AUX_XMEM_BAR16 0x127
+#define AUX_XMEM_LTEST 0x128
+#define AUX_CLK_CTL    0x129
+
+
+//* ARC core register space definitions */
+//* MEI COMMAND CODES */
+//* Sent commands */
+#define MEI_ACK 0x00000000
+#define MEI_PING 0x00000001
+#define MEI_WRITE       0x00000002
+#define MEI_READ 0x00000003
+#define MEI_DMASTART 0x00000004
+#define MEI_ESTART 0x00000005
+#define AUX_READ 0x6
+#define AUX_WRITE 0x7
+
+//* Received commands */
+#define ARC_ACK 0x00000000
+#define ARC_PING 0x00000001
+#define ARC_DMADONE 0x00000002
+#define ARC_EDONE 0x00000003
+#define ARC_ERROR 0x00000004
+
+/*-----------------------------------------------------------
+ * Mailbox locations (mapped to the base of port 0's bram)
+ -----------------------------------------------------------*/
+
+/* Start and end addresses of INBOX and OUTBOX */
+#define IMBOX_BASE (dsp_iibram_base)
+#define IMBOX_END  (IMBOX_BASE + 0x3F)
+#define OMBOX_BASE (IMBOX_END  + 1)
+#define OMBOX_END  (OMBOX_BASE + 0x3F)
+
+/* Outbox locations */
+#define OMBOX0  OMBOX_BASE
+#define OMBOX1  OMBOX_BASE + 0x04
+#define OMBOX2  OMBOX_BASE + 0x08
+#define OMBOX3  OMBOX_BASE + 0x0C
+#define OMBOX4  OMBOX_BASE + 0x10
+#define OMBOX5  OMBOX_BASE + 0x14
+#define OMBOX6  OMBOX_BASE + 0x18
+#define OMBOX7  OMBOX_BASE + 0x1C
+#define OMBOX8  OMBOX_BASE + 0x20
+#define OMBOX9  OMBOX_BASE + 0x24
+#define OMBOX10 OMBOX_BASE + 0x28
+#define OMBOX11 OMBOX_BASE + 0x2C
+
+/* Inbox locations */
+#define IMBOX0  IMBOX_BASE + 0x00
+#define IMBOX1  IMBOX_BASE + 0x04
+#define IMBOX2  IMBOX_BASE + 0x08
+#define IMBOX3  IMBOX_BASE + 0x0C
+#define IMBOX4  IMBOX_BASE + 0x10
+#define IMBOX5  IMBOX_BASE + 0x14
+#define IMBOX6  IMBOX_BASE + 0x18
+#define IMBOX7  IMBOX_BASE + 0x1C
+#define IMBOX8  IMBOX_BASE + 0x20
+#define IMBOX9  IMBOX_BASE + 0x24
+#define IMBOX10 IMBOX_BASE + 0x28
+#define IMBOX11 IMBOX_BASE + 0x2C
+
+/* Mailbox sizes */
+#define IMBOX_SIZE_B  (IMBOX_END - IMBOX_BASE + 1)
+#define OMBOX_SIZE_B  (OMBOX_END - OMBOX_BASE + 1)
+#define IMBOX_SIZE_LW (IMBOX_SIZE_B >> 2)
+#define OMBOX_SIZE_LW (OMBOX_SIZE_B >> 2)
+
+#endif
+
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_e1_addr_def.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_e1_addr_def.h
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_e1_addr_def.h
@@ -0,0 +1,1115 @@
+/******************************************************************************
+ *
+ *                        Copyright (c) 2012, 2014, 2015
+ *                           Lantiq Deutschland GmbH
+ *
+ *  For licensing information, see the file 'LICENSE' in the root folder of
+ *  this software module.
+ *
+ ******************************************************************************/
+
+#ifndef __SMARTPHY_ADDR_DEF_INC
+#define __SMARTPHY_ADDR_DEF_INC
+
+//=============================================================================
+// Defines for "PPE DSL Notifications" Module
+//=============================================================================
+#define __DREG_BC0_LINK_STATUS              0x7DC0
+#define __DREG_BC1_LINK_STATUS              0x7DD0
+#define __DREG_MEI_STATE                    0x7DC1
+#define __DREG_PDBRAM_S_44K_OWN             0x7DC2
+#define __DREG_SIGNATURE                    0x7DC3
+#define __SFSM_PGCNT0                       0x741C
+#define __SFSM_PGCNT1                       0x741D
+
+//=============================================================================
+// General Configuraton:  0x2000 - 0x202F
+// Need to be refined further
+//=============================================================================
+//
+#define __FW_VER_ID                         0x2000
+#define __FW_FEATURE                        0x2001
+#define xLDI_FW_FEATURE(__rd)			                    ldi __rd 0 __FW_FEATURE
+
+#define __PP32_0_TIME                   0x2002  /* New */
+#define __PP32_1_TIME                   0x2003  /* New */
+
+#define __DSL_LINK_DOWN                 0x2004  /* New */
+
+// #define __TFA_MAILBOX_PDMA_ADDR0     0x2004  /* Deleted */
+// #define __TFA_MAILBOX_PDMA_ADDR1     0x2005  /* Deleted */
+// #define __LINK_UP_NOTIFY_ADDR        0x2006  /* Deleted */
+// #define __LINK_DOWN_NOTIFY_ADDR      0x2007  /* Deleted */
+#define __BOND_CONF                     0x2008
+#define __US_BG_QMAP                    0x2009
+#define __US_BG_GMAP                    0x200A
+#define __DS_BG_GMAP                    0x200B
+
+#define __PEER_GIF_LINK_STATE_TMP         0x200C
+#define __ISR_CHECK_CNT_NORMAL_LINK_DOWN  0x200D
+#define __ISRS_SET_CNT_NORMAL_LINK_DOWN   0x200E
+#define __ISR_CHECK_CNT_FORCE_LINK_DOWN   0x2018
+#define __ISRS_SET_CNT_FORCE_LINK_DOWN    0x2019
+#define __LINK_STATE_INTERMEDIATE         0x201C
+#define __LINK_STABLE_CNT                 0x201D
+
+//#define __CURR_TIME_STAMP             0x200C  /* Deleted, Reused */
+//#define __E1_DES_PDMA_BAR             0x200D  /* Deleted, Reused */
+//#define __B1_DES_PDMA_BAR             0x200E  /* Deleted, Reused */
+//#define __DATA_PTR_PDMA_PREFIX_CFG    0x200F  /* Deleted, Reused */
+//                                      0x2010  /* Reused */
+
+//Only for DEBUG!!
+#define _PDMA_RX_CMD_ERR_FLAG           0x200F
+#define _PDMA_TX_CMD_ERR_FLAG           0x2010
+
+#define __STD_DES_CFG                   0x2011
+#define __QOS_CFG                       0x2012
+#define __QOSQ_FLOW_CTRL_CFG            0x2013
+
+#define __CFG_STD_DATA_LEN              __STD_DES_CFG
+#define __TX_QOS_CFG                    __QOS_CFG
+#define __CFG_TX_QOSQ_BANDWIDTH_CTRL    __QOSQ_FLOW_CTRL_CFG
+
+#define __PSAVE_CFG                     0x2014
+
+//                                      0x2018
+// #define __GPIO_ADDR                  0x2019  /* Deleted */
+
+
+//Added by Naveen (31/01/2012) -- START
+#define __SHAPING_CFG                   0x201A  /* New */
+#define __WFQ_CFG                       0x201B  /* New */
+//Added by Naveen (31/01/2012) -- END
+
+// #define __GPIO_MODE                  0x201C  /* Deleted, Reused */
+// #define __GPIO_WM_CFG                0x201D  /* Deleted, Reused */
+
+#define __QOS_SHADOW_TTICK              0x201E
+#define __TX_QOS_CFG_SHADOW             __QOS_SHADOW_TTICK
+
+#define __TEST_MODE                     0x201F
+//#define __US_CDMA_RX_DES_PDMA_BAR     0x2020  /* Deleted */
+//#define __US_CDMA_RX_DES_BASE         0x2021  /* Deleted */
+//#define __US_FRAG_READY_NOTICE_ADDR   0x2022  /* Deleted */
+//                                      0x2023
+//                                      0x2024
+//                                      0x2025
+//                                      0x2026
+//                                      0x2027
+//                                      0x2028
+//                                      0x2029
+//#define __US_E1_FRAG_DESBA_CFG        0x202A  /* Deleted */
+//#define __DS_E1_FRAG_DESBA_CFG        0x202B  /* Deleted */
+//                                      0x202C
+//                                      0x202D
+//                                      0x202E
+//                                      0x202F
+
+#define __PP32_0_TASK_CFG               0x2020  /* new */
+#define __PP32_1_TASK_CFG               0x2021  /* new */
+#define __PP32_0_MODULE_ACTIVITY        0x2022
+#define __PP32_1_MODULE_ACTIVITY        0x2023
+
+// valid below for PP32 address range:
+//   sb_addr range:     0x2000-0x5FFF
+//   hw_reg range :     0x7000-0x7FFF
+// a vrx218 can access any <pp32_addr> in above range in its peer vrx218
+// with an effective external address of  *__BOND_PEER_SB_BASE + (pp32_addr << 4)
+#define __BOND_PEER_SB_BASE               0x2024  /* New */
+
+#define PCIE_EP_MSI_SR_ADDR_HIGH          0x1E10
+#define PCIE_EP_MSI_SR_ADDR_LOW           0x2484
+
+//                                      0x2019
+
+#define __DS_PKT_PMAC_HEADER            0x2025  /* new */
+#define __VRX218_FLOW_CTRL_CFG           0x2026  /* new */
+#define xLDI_VRX218_FLOW_CTRL_CFG(__rd)                     ldi __rd 0 __VRX218_FLOW_CTRL_CFG
+
+//=============================================================================
+// Unified QoS Part
+//=============================================================================
+#define __INQ_QOS_CFG_BASE              0x2508  /* 0x2508-0x2509  2   x 1 = 2       */
+#define __US_FAST_PATH_DES_LIST_BASE    0x2580  /* 0x2580-0x25FF  64  x 2 = 128     */
+#define __US_CPU_PATH_DEST_LIST_BASE    0x3D00  /* 0x3D00-0x3D7F  64  x 2 = 128     */
+#define __QOSQ_OVERFLOW_STATE_BMAP      0x250c  /* 0x250c-0x250c  1   x 1 = 1       */
+
+#define __QOSQ_CFG_CTXT_BASE            0x2FE0  /* 0x2FE0-0x2FFF  16  x 2 = 32      */
+#define __US_QOSQ_DES_LIST_BASE         0x2800  /* 0x2800-0x2BFF  512 x 2 = 1024    */
+#define __QOSQ_MIB_BASE                 0x2030  /* 0x2030-0x20AF  16  x 8 = 128     */
+#define __QOSQ_EVENT_MBOX_INT_CFG       0x3F10  /* 0x3F10-0x3F13  1   x 4 = 4       */
+//#define __QOSQ_PKT_CNT                  0x2680  /* 0x2680-0x268F  16  X 1 = 16      */
+
+#define __SHAPING_WFQ_CFG_BASE          0x3420  /* 0x3420-0x3473  21  x 4 = 84      */
+
+#define __SWAPQ_CFG_CTXT_BASE           0x2500  /* 0x2500-0x2501  1   * 2 = 2       */
+#define __SWAPQ_DES_LIST_BASE           0x3F60  /* 0x3F60-0x3F9F  32  * 2 = 64      */
+
+#define __OUTQ_QOS_CFG_CTXT_BASE        0x2550  /* 0x2550-0x255F  4   x 4 = 16      */
+#define __US_OUTQ_DES_LIST_BASE         0x2100  /* 0x2100-0x217F  64  x 2 = 128     */
+
+#define __DESQ_MBOX_INT_CFG             0x3F14  /* 0x3F14-0x3F1F  6    x 2 = 12     */
+
+#define __US_FP_INQ_DES_CFG_CTXT        0x20B0  /* 0x20B0-0x20B7  1  x 8 = 8      */
+#define __US_CPU_INQ_DES_CFG_CTXT       0x20B8  /* 0x20B8-0x20BF  1  x 8 = 8      */
+#define __US_QOS_OUTQ_DES_CFG_CTXT_BASE 0x20C0  /* 0x20C0-0x20DF  4  x 8 = 32      */
+
+//=============================================================================
+// Des Queues, eDMA  copy channel mgm, des_sync (SmartPhy Part)
+//=============================================================================
+#define __US_FRAGQ_CFG_CTXT_BASE        0x2180  /* 0x2180-0x21BF  8  x 8 = 64  */
+#define __US_FRAGQ_DES_LIST_BASE        0x21C0  /* 0x21C0-0x233F  8  x 48= 384 */
+#define __US_TC_LOCAL_Q_CFG_CTXT_BASE   0x2E00  /* 0x2E00-0x2E7F  16 x 8 = 128 */
+#define __US_BP_TC_LOCAL_Q_CFG_CTXT_BASE    0x2390  /* 0x2390-0x23A2  1 * 19 = 19 */
+#define __US_TC_LOCAL_Q_DES_LIST_BASE   0x2360  /* 0x2360-0x2385  1  x 48= 48  */
+#define __US_EDMA_COPY_CH_CFG           0x2340  /* 0x2340-0x234F  16 x 1 = 16   */
+#define __US_EDMA_READ_CH_CFG_CTXT      0x2798  /* 0x2798-0x279F  1  x 8 = 8   */
+#if (LLE_IN_PDBRAM == 1)
+    // To optimize EDMA read/write performance, EDMA_LLE is moved to PDBRAM, EDMA_LLE_EXT
+    // size is also increased to 6 to ease FW process (Apr 24, 2012)
+    #define __US_EDMA_LLE_BASE          0x6600  /* 0x6600-0x66C5  33 x 6 = 198*/
+#else
+    #define __US_EDMA_LLE_BASE          0x2390  /* 0x2390-0x2455  33 x 6 = 198 Reused 0x2390-23A2 */
+#endif
+#define __US_EDMA_LLE_FPI_BASE          0x1E0A3800  /* 0x1E0A3800-0x1E0A3B17  33 x 24 = 792 bytes*/
+#define __US_EDMA_LLE_EXT_BASE          0x3796  /* 0x3796-0x385B  33 x 6 = 198  */
+#define __DS_TC_LOCAL_Q_CFG_CTXT        0x20E0  /* 0x20E0-0x20EF  2  x 8 = 16   */
+#define __DS_TC_LOCAL_Q_DES_LIST_BASE   0x24D0  /* 0x24D0-0x24E3  10 x 2 = 20  */
+#define __DS_TC_LOCAL_Q_DES_LIST_BP_BASE   0x24F0  /* 0x24F0-0x24F9  10 x 1 = 10  */
+#define __DS_FRAGQ_CFG_CTXT_BASE        0x20F0  /* 0x20F0-0x20FF  2  x 8 = 16  */
+#define __DS_FRAGQ_DES_LIST_BASE        0x26D0  /* 0x26D0-0x278F  2  x 96= 192 */
+#define __DS_PKT_DESQ_CFG_CTXT          0x24C0  /* 0x24C0-0x24CF  2  x 8 = 16   */
+#define __DS_PKT_DES_LIST_BASE          0x2600  /* 0x2600-0x267F  64 x 2 = 128*/
+#define __DS_EDMA_COPY_CH_CFG           0x250A  /* 0x250A-0x250B  2  x 1 = 2  */
+#define __DS_EDMA_WRITE_CH_CFG_CTXT     0x2790  /* 0x2790-0x2798  1  x 8 = 8  */
+#if (LLE_IN_PDBRAM == 1)
+    // To optimize EDMA read/write performance, EDMA_LLE is moved to PDBRAM, EDMA_LLE_EXT
+    // size is also increased to 6 to ease FW process (Apr 24, 2012)
+    #define __DS_EDMA_LLE_BASE          0x6700  /* 0x6700-0x67C5  33 x 6 = 198*/
+#else
+    #define __DS_EDMA_LLE_BASE          0x3600  /* 0x3600-0x36C5  33 x 6 = 198*/
+#endif
+#define __DS_EDMA_LLE_FPI_BASE          0x1E0A3C00  /* 0x1E0A3C00-0x1E0A3F17  33 x 24 = 792 bytes*/
+#define __DS_EDMA_LLE_EXT_BASE          0x36D0  /* 0x36D0-0x3795  33 x 6 = 198 */
+
+#define __DES_SYNC_CFG_CTXT             0x2F00  /* 0x2F00-0x2FBF  6  x 32= 192*/
+//In Bonding, Upstream Bonding Master only synchronizes 2 Upstream Queues (FP & CPU)
+//            Downstream Bonding Master only synchronizes 1 Downstream Queue
+//Since Peer-to-Peer writes are not allowed, we need to synchronize Bonding Descriptors!
+//  Re-using the space reserved for "Descriptor Sync"
+//  __DES_SYNC_CFG_CTXT ==> 0x2F00 - 0x2F3F (Upstream Bonding Master)
+//  __DES_SYNC_CFG_CTXT ==> 0x2F00 - 0x2F1F (Downstream Bonding Master)
+#define __BOND_US_DES_SYNC_CFG_CTXT             0x2F48  /* 0x2F48 - 0x2F67; 4 * 8 = 32 */
+
+#define __BOND_US_DES_SYNC_QUEUE_ID             0x2F68  /* 0x2F68 - 0x2F68; 1 * 1 = 1  */
+
+#define __US_BOND_SOC_SYNC_ADDR_GIF4            0x2F6C  /* 0x2F6C - 0x2F6C; 1 * 1 = 1  */
+#define __US_BOND_SOC_SYNC_ADDR_GIF5            0x2F6D  /* 0x2F6D - 0x2F6D; 1 * 1 = 1  */
+#define __US_BOND_SOC_SYNC_ADDR_GIF6            0x2F6E  /* 0x2F6E - 0x2F6E; 1 * 1 = 1  */
+#define __US_BOND_SOC_SYNC_ADDR_GIF7            0x2F6F  /* 0x2F6F - 0x2F6F; 1 * 1 = 1  */
+
+#define __BOND_US_DES_SYNC_TX_DES_DW0           0x2F78  /* 0x2F78 - 0x2F78; 1 * 1 = 1  */
+#define __BOND_US_DES_SYNC_TX_DES_DW1           0x2F79  /* 0x2F79 - 0x2F79; 1 * 1 = 1  */
+#define __BOND_US_DES_SYNC_RX_DES_DW0           0x2F7A  /* 0x2F7A - 0x2F7A; 1 * 1 = 1  */
+#define __BOND_US_DES_SYNC_RX_DES_DW1           0x2F7B  /* 0x2F7B - 0x2F7B; 1 * 1 = 1  */
+
+#define __BOND_US_DES_SYNC_BUF_BASE             0x2F80  /* 0x2F80 - 0x2FBF; 64 DWORDS  */
+#define __BOND_US_DES_SYNC_ENQ_PKT_CNT          0x2F80  /* 0x2F80 - 0x2F80; 1 * 1 = 1  */
+#define __BOND_US_DES_SYNC_DEQ_PKT_CNT          0x2F81  /* 0x2F81 - 0x2F81; 1 * 1 = 1  */
+#define __BOND_US_DES_SYNC_DES_BASE             0x2F88  /* 0x2F88 - 0x2FA7; 32 DWORDs  */
+#define __BOND_US_DES_SYNC_DES_BP_BASE          0x2FA8  /* 0x2FA8 - 0x2FB7; 16 DWORDs  */
+
+#define __BOND_DS_DES_SYNC_CFG_CTXT             0x2FC0  /* 0x2FC0 - 0x2FC7; 1 * 8 = 8  */
+#define __BOND_DS_DES_SYNC_QUEUE_ID             0x2FC8  /* 0x2FC8 - 0x2FC8; 1 * 1 = 1  */
+#define __DS_BOND_SOC_SYNC_ADDR                 0x2FC9  /* 0x2FC9 - 0x2FC9; 1 * 1 = 1  */
+#define __DS_BOND_SOC_SYNC_ENQ_CNT_ADDR         0x2FCA  /* 0x2FCA - 0x2FCA; 1 * 1 = 1  */
+#define __DS_BOND_SOC_SYNC_DEQ_CNT_ADDR         0x2FCB  /* 0x2FCB - 0x2FCB; 1 * 1 = 1  */
+
+#define __BOND_DS_DES_SYNC_BUF_BASE             0x2458  /* 0x2458 - 0x24BF; 104 DWORDS */
+#define __BOND_DS_DES_SYNC_ENQ_PKT_CNT          0x2458  /* 0x2458 - 0x2458; 1 * 1 = 1  */
+#define __BOND_DS_DES_SYNC_DEQ_PKT_CNT          0x2459  /* 0x2459 - 0x2459; 1 * 1 = 1  */
+#define __BOND_DS_DES_SYNC_DES_BASE             0x2460  /* 0x2460 - 0x249F;  64 DWORDs */
+#define __BOND_DS_DES_SYNC_DES_BP_BASE          0x24A0  /* 0x24A0 - 0x24BF;  32 DWORDs */
+
+#define __BOND_DES_SYNC_CFG_CTXT_SIZE           8
+#define __BOND_DES_SYNC_ENQ_PKT_CNT_OFFSET      0
+#define __BOND_DES_SYNC_DEQ_PKT_CNT_OFFSET      1
+#define __BOND_DES_SYNC_DES_BASE_OFFSET         2
+
+#define __CDMA_DES_SYNC_DEST_LIST_BASE  0x27A0  /* 0x27A0-0x27FF  6  x 4 x 2 x 2 = 96 */
+#define __EDMA_RD_CNT_SM                0x2560  /* 0x2560-0x256F  1  x 16= 16 */
+
+// To optimize EDMA read/write performance, EDMA_LLE is moved to PDBRAM.
+// 0x1E0A2000-0x1E0A3FFF, (second half of PDBRAM8 0x1E0A0000-0x1E0A3FFF)
+// the last 2k bytes are used for EDMA_LLE
+// __US_EDMA_LLE_BASE: 0x6600-0x66FF (FPI: 0x1E0A3800-0x1E0A3BFF)
+// __US_EDMA_LLE_BASE: 0x6700-0x67FF (FPI: 0x1E0A3C00-0x1E0A3FFF)
+#define __EDMA_LLE_BLOCK_FPI_ADDR       0x1E0A2000
+#define __EDMA_LLE_BLOCK_FPI_ADDR_Hi    0x1E0A
+#define __EDMA_LLE_BLOCK_FPI_ADDR_Lo    0x2000
+#define xLDI_edma_lle_block_fpi_addr(__rd) \
+    xLDI_dword(__rd, __EDMA_LLE_BLOCK_FPI_ADDR_Hi, __EDMA_LLE_BLOCK_FPI_ADDR_Lo)
+
+#if (LLE_IN_PDBRAM == 1)
+    #define __US_EDMA_LLE_LINK_ELEM         0x66C0  /* 0x6600-0x66C5  33 x 6 = 198*/
+    #define __DS_EDMA_LLE_LINK_ELEM         0x67C0  /* 0x6700-0x67C5  33 x 6 = 198*/
+#else
+    #define __US_EDMA_LLE_LINK_ELEM         0x2450  /* 0x2390-0x2455  33 x 6 = 198*/
+    #define __DS_EDMA_LLE_LINK_ELEM         0x36C0  /* 0x3600-0x36C5  33 x 6 = 198*/
+#endif
+
+//edma hang detection
+//
+ #define __EDMA_HANG_BENCH_RD_IDX      0x2510  /*0x2510-0x2511 0:write channel  1: read channel*/
+ #define __EDMA_HANG_DETECT_CNT        0x2512  /*0x2512-0x2513 0:write channel  1: read channel*/
+ #define __EDMA_HANG_DETECT_TH         0x2514  /* 1Dword*/
+ #define __EDMA_HANG_DETECT_MIB        0x2516  /* 1Dword*/
+//----------------------------------------------------------
+// Detailed Memory Allocation
+//----------------------------------------------------------
+
+//**********************************************
+//"Unified QoS" Module Memory Allocation - START
+//**********************************************
+
+//2 INQs; CPU Path & Fast Path
+#define __INQ_QOS_CFG_BASE              0x2508
+#define __INQ_QOS_CFG_END               0x2509
+#define __INQ_QOS_CFG_SIZE              1
+
+//16 QoSQs
+#define __QOSQ_CFG_CTXT_BASE            0x2FE0
+#define __QOSQ_CFG_CTXT_END             0x2FFF
+#define __QOSQ_CFG_CTXT_SIZE            2
+
+//16 QoSQs; 4 L2 Shapers; 1 L3 Shaper
+#define __SHAPING_WFQ_CFG_BASE          0x3420
+#define __SHAPING_WFQ_CFG_END           0x3473
+#define __SHAPING_WFQ_CFG_SIZE          4
+
+//16 QoSQs
+#define __QOSQ_MIB_BASE                 0x2030
+#define __QOSQ_MIB_END                  0x20AF
+#define __QOSQ_MIB_SIZE                 8
+
+#define __QOSQ_PKT_CNT                  0x2680
+
+//#define __SWAPQ_CFG_CTXT_BASE           0x2500
+#define __SWAPQ_CFG_CTXT_DW1_ADDR       0x2501
+#define __SWAPQ_CFG_CTXT_END            0x2501
+#define __SWAPQ_CFG_CTXT_SIZE           2
+
+#define __OUTQ_QOS_CFG_CTXT_BASE        0x2550
+#define __OUTQ_QOS_CFG_CTXT_END         0x255F
+#define __OUTQ_QOS_CFG_CTXT_SIZE        4
+
+//**********************************************
+//"Unified QoS" Module Memory Allocation - END
+//**********************************************
+
+#define __DES_SYNC_CFG_CTXT_BASE        __DES_SYNC_CFG_CTXT
+#define __DES_SYNC_CFG_CTXT_BASE_END    0x2FBF
+
+#define __DES_READ_SYNC_CFG_CTXT_BASE  __DES_SYNC_CFG_CTXT_BASE
+#define __DES_READ_SYNC_CFG_CTXT_END   __DES_SYNC_CFG_CTXT_BASE_END
+
+#define __DES_WRITE_SYNC_CFG_CTXT_BASE  __DES_SYNC_CFG_CTXT_BASE
+#define __DES_WRITE_SYNC_CFG_CTXT_END   __DES_SYNC_CFG_CTXT_BASE_END
+
+
+#define __EDMA_CH_CTXT_BASE             __DS_EDMA_WRITE_CH_CFG_CTXT
+#define __EDMA_WRITE_CH_CTXT            __DS_EDMA_WRITE_CH_CFG_CTXT
+#define __EDMA_READ_CH_CTXT             __US_EDMA_READ_CH_CFG_CTXT
+#define __EDMA_CH_CTXT_BASE_END         0x27A0
+
+
+#define __EDMA_WRITE_COPY_CH_CFG_BASE   __DS_EDMA_COPY_CH_CFG
+#define __EDMA_WRITE_COPY_CH_CFG_END    0x250C
+
+#define __EDMA_READ_COPY_CH_CFG_BASE    __US_EDMA_COPY_CH_CFG
+#define __EDMA_READ_COPY_CH_CFG_END     0x2350
+
+//PPA2.16 PI
+#define __DS_CDMA_COPY_CH_CFG           0x2350  /* 0x2350-0x2350  1 x 1 = 1   */
+
+#define __REG_STACK_PI                  0x2351  /* 0x2351-0x2352  2 x 1 = 2   */
+
+#define __DES_SIDEBAND_WR_PTR           0x2353
+
+#define __DES_SIDEBAND_LIST_BASE        0x3FA0  /* 0x3FA0-0x3FBF  32 x 1 = 32 */
+
+#define __DES_SIDEBAND_LIST_SIZE        32
+
+#define __SOC_FAMILY                    0x2507
+
+// SB = 0x7000
+#define __WRITE_CH_DOORBELL_EXT_ADDR    0x1E700980
+#define __WRITE_CH_DOORBELL_EXT_ADDR_hi 0x1E70
+#define __WRITE_CH_DOORBELL_EXT_ADDR_lo 0x0980
+
+// SB = 0x7001
+#define __READ_CH_DOORBELL_EXT_ADDR     0x1E709A0
+#define __READ_CH_DOORBELL_EXT_ADDR_hi  0x1E70
+#define __READ_CH_DOORBELL_EXT_ADDR_lo  0x09A0
+
+
+//=============================================================================
+// TC Part (E1 part)
+//=============================================================================
+#define __RX_BC_CFG_STATS_CFG_BASE      0x3E80  /* 0x3E80-0x3EBF  2  x 32= 64  */
+#define __TX_BC_CFG_STATS_CFG_BASE      0x3EC0  /* 0x3EC0-0x3EFF  2  x 32= 64  */
+#define __RX_GIF_CFG_STATS_CFG_BASE     0x3D80  /* 0x3D80-0x3DFF  4  x 32= 128 */
+#define __TX_GIF_CFG_STATS_CFG_BASE     0x3E00  /* 0x3E00-0x3E7F  4  x 32= 128 */
+#define __RX_GIF_MIB_BASE               0x3400  /* 0x3400-0x341F  4  x 8 = 32  */
+
+//---------------------------------------------------
+// detailed SB allocation
+//---------------------------------------------------
+
+//---------------------------------------------------
+// WAN RX BC Config/Status/Context Table
+// 32 * 2 = 64
+//---------------------------------------------------
+#define __RX_BC0_CFG_STATS_CFG              __RX_BC_CFG_STATS_CFG_BASE
+// #define __RX_BC1_CFG_STATS_CFG              0x3EA0
+
+//---------------------------------------------------
+// WAN TX BC Config/Status/Context Table
+// 32 * 2 = 64
+//---------------------------------------------------
+#define __TX_BC0_CFG_STATS_CFG              __TX_BC_CFG_STATS_CFG_BASE
+//#define __TX_BC1_CFG_STATS_CFG              0x3EE0
+
+//---------------------------------------------------
+// WAN RX Path Config/Status/Context Table
+// i.e. Gamma Interface Config/Status/Context
+// 32 * 4 = 128
+//---------------------------------------------------
+#define __RX_GIF0_CFG_STATS_CFG             __RX_GIF_CFG_STATS_CFG_BASE
+// #define __RX_GIF1_CFG_STATS_CFG             0x3DA0
+// #define __RX_GIF2_CFG_STATS_CFG             0x3DC0
+// #define __RX_GIF3_CFG_STATS_CFG             0x3DE0
+
+//---------------------------------------------------
+// WAN TX Path Config/Status/Context Table
+// i.e. Gamma Interface Config/Status/Context
+// 32 * 4 = 128
+//---------------------------------------------------
+#define __TX_GIF0_CFG_STATS_CFG             __TX_GIF_CFG_STATS_CFG_BASE
+// #define __TX_GIF1_CFG_STATS_CFG             0x3E20
+// #define __TX_GIF2_CFG_STATS_CFG             0x3E40
+// #define __TX_GIF3_CFG_STATS_CFG             0x3E60
+
+//---------------------------------------------------
+// WAN RX Gamma Interface MIB Table
+// 4 * 8 = 32
+//---------------------------------------------------
+#define __RX_GIF0_MIB_BASE                  __RX_GIF_MIB_BASE
+#define __RX_GIF1_MIB_BASE                  0x3408
+#define __RX_GIF2_MIB_BASE                  0x3410
+#define __RX_GIF3_MIB_BASE                  0x3418
+
+
+//=============================================================================
+// Bonding Part (B1 part)
+//=============================================================================
+#define __DS_BOND_GIF_LL_DES_BA         0x2C00  /* 0x2C00-0x2DFF  256x 2 = 512 */
+#define __US_BG_CTXT_BASE               0x3F00  /* 0x3F00-0x3F0F  4  x 4 = 16  */
+#define __DS_BOND_LL_CTXT_BASE          0x26A4  /* 0x26A4-0x26C7  9  x 4 = 36  */
+#define __DS_BOND_GIF_MIB_BASE          0x2E80  /* 0x2E80-0x2EFF  8  x 16= 128 */
+#define __DS_BG_MIB_BASE                0x3F20  /* 0x3F20-0x3F5F  4  x 16= 64  */
+#define __DS_BG_CTXT_BASE               0x3FE0  /* 0x3FE0-0x3FFF  4  x 8 = 32  */
+#define __DS_BOND_GIF_LL_DESBP_BA       0x4AB0  /* 0x4AB0-0x4BAF  256x 1 = 256 */
+
+//-------------------------------------
+// SB allocation in detail
+//-------------------------------------
+//US Bonding Group Context
+//Section 5.7 in Spec
+#define __US_BG_CTXT                        __US_BG_CTXT_BASE
+#define __US_BG_CTXT_SIZE                   16
+#define __US_BG_CTXT_SIZE_PER_BG            4
+
+//DS Bonding Gamma Interface Linked-List Context
+//Section 5.8 in Spec
+#define __DS_BOND_FREE_LL_CTXT              __DS_BOND_LL_CTXT_BASE
+#define __DS_BOND_FREE_LL_CTXT_SIZE         4
+
+#define __DS_BOND_GIF_LL_CTXT               0x26A8
+#define __DS_BOND_GIF_LL_CTXT_SIZE          32
+#define __DS_BOND_GIF_LL_CTXT_SIZE_PER_GIF  4
+
+//DS Bonding Gamma Interface MIB
+//Section 5.9 in Spec
+#define __DS_BOND_GIF_MIB                   __DS_BOND_GIF_MIB_BASE
+#define __DS_BOND_GIF_MIB_SIZE              128
+#define __DS_BOND_GIF_MIB_SIZE_PER_BG       16
+
+//DS Bonding Group MIB
+//Section 5.10 in Spec
+#define __DS_BG_MIB                         __DS_BG_MIB_BASE
+#define __DS_BG_MIB_SIZE                    64
+#define __DS_BG_MIB_SIZE_PER_BG             16
+
+//DS Bonding Group Context
+//Section 5.11 in Spec
+#define __DS_BG_CTXT                        __DS_BG_CTXT_BASE
+#define __DS_BG_CTXT_SIZE                   32
+#define __DS_BG_CTXT_SIZE_PER_BG            8
+
+#define __MAX_PKT_SIZE_CFG          0x2502
+
+
+// Link UP/DOWN info
+// E1 forwards link up/down info generated by DSL firmware
+// to B1 with  __MBOX_IGU4_ISRS and __MBOX_IGU4_ISRC
+// to indicate link UP and DOWN
+#define __LINK_UP_DOWN_STATUS               __MBOX_IGU4_ISR
+
+
+//=============================================================================
+// General Context
+//=============================================================================
+#define __GENERAL_CONTEXT_BASE              0x3000  /* 0x3000-0x31FF  512x 1 = 512 */
+
+//------------------------------------------------
+// detailed SB allocation
+//------------------------------------------------
+//US Internal Variables
+#define __US_E1_FRAG_Q_FRAG_MIB             0x3100
+#define __US_E1_FRAG_Q_NON_EMPTY_FLAG       0x3108
+
+#define __US_E1_FRAG_Q_DES_WRIDX            0x3110
+#define __US_E1_FRAG_Q_DES_RDIDX            0x3118
+
+// free des per gif 0x3120-0x3127
+#define __US_E1_FRAG_Q_FREE_FRAG_CNT        0x3120
+// number of fragment released by release proc per gif
+// 0x3128-0x312F
+#define __US_E1_FRAG_Q_REL_FAG_MIB          0x3128
+
+//===========================================================
+// Debug Variable
+//===========================================================
+#define __MAX_XPCI_WDES_NUM                 0x3130
+#define __FLUSH_NO_DES_NUM                  0x3131
+
+//===========================================================
+// XPCI desc read data buffer: 0x3140-0x314F
+//===========================================================
+#define __XPCI_RDES_DES_BASE                0x3140
+#define __XPCI_RDES_DES_BASE_HW             0x1140
+#define __XPCI_RDES_DES_SIZE                16
+
+
+// 0x3150 - 0x31F0
+#define __XPCI_DES_READ_OWN_CHECK_CNT       0x3150
+
+
+//DS Internal Variables
+#define __DS_SM_E1_FRAG_DES_RDIDX           0x3180
+#define __DS_BM_E1_FRAG_DES_RDIDX           0x3181
+#define __RX_FRAG_DISP_RDIDX                __DS_SM_E1_FRAG_DES_RDIDX
+
+#define __DS_BOND_GIF_LL_NONEMPTY_FLAG      0x3182
+
+#define __IS_PKT_FLUSHING                   0x3183
+#define __DMA_PKT_FLUSHING_CURR_BG          0x3184
+#define __DMA_TX_CH1_DES_WRPTR              0x3185
+
+// task activity
+#define __PP32_0_TASK_ACTV_FLAG             0x3188
+#define __PP32_1_TASK_ACTV_FLAG             0x3189
+
+//=====================================================================
+// debug counter, to counter cycles needed to read/write cross pci
+//=====================================================================
+#define __READ_NUM                          0x3190
+#define __READ_MAX_CYCLES                   0x3191
+#define __READ_MIN_CYCLES                   0x3192
+#define __TOTAL_READ_CYCLES_HI              0x3194
+#define __TOTAL_READ_CYCLES_LO              0x3195
+
+#define __WRITE_NUM                         0x3198
+#define __WRITE_MAX_CYCLES                  0x3199
+#define __WRITE_MIN_CYCLES                  0x319A
+#define __TOTAL_WRITE_CYCLES_HI             0x319C
+#define __TOTAL_WRITE_CYCLES_LO             0x319D
+
+//=====================================================================
+// cross PCI optimization variables
+//=====================================================================
+#define __IS_XPCI_DES_READ_STATUS           0x31A0
+#define __XPCI_DES_READ_SPTR                0x31A1
+#define __XPCI_DES_READ_EPTR                0x31A2
+#define __XPCI_DES_READ_PDMA_CMD0           0x31A3
+#define __XPCI_DES_READ_PDMA_CMD1           0x31A4
+
+#define __IS_XPCI_DES_WRITE_STATUS          0x31A5
+#define __XPCI_DES_WRITE_SPTR               0x31A6
+#define __XPCI_DES_WRITE_EPTR               0x31A7
+#define __XPCI_DES_WRITE_PDMA_CMD0          0x31A8
+#define __XPCI_DES_WRITE_PDMA_CMD1          0x31A9
+
+
+#define __TOTAL_SUCC_CNT                    0x31AA
+#define __TOTAL_FAIL_CNT                    0x31AB
+
+#define __FAILD_DATA_PTR0                   0x31AC
+#define __FAILD_DATA_PTR1                   0x31AD
+#define __FAILD_DATA_PTR2                   0x31AE
+#define __FAILD_DATA_PTR3                   0x31AF
+
+// 0x31B0-0x31BF for 4 consecutive des own bit combinnation
+#define __XPCI_DES_READ_OWN_FAIL_CNT        0x31B0
+
+// 0x31C0-0x31CF for 4 data_ptr violation combinaton count
+#define __XPCI_DES_READ_DPTR_FAIL_CNT       0x31C0
+
+
+
+//=============================================================================
+// TC Part (E1 Part)
+//=============================================================================
+#define __TC_GENERAL_CONTEXT_BASE       0x3480  /* 0x3480-0x35FF  1  x 384= 384  */
+#define __SFSM0_DATA_BUF_BASE           0x5000  /* 0x5000-0x576F  112x 17 = 1904 */
+#define __SFSM0_CTRL_BUF_BASE           0x5EE0  /* 0x5EE0-0x5F4F  112x 1  = 112  */
+#define __FFSM0_DATA_BUF_BASE           0x4000  /* 0x4000-0x454F  80 x 17 = 1360 */
+#define __SFSM1_DATA_BUF_BASE           0x5770  /* 0x5770-0x5EDF  112x 17 = 1904 */
+#define __SFSM1_CTRL_BUF_BASE           0x5F50  /* 0x5F50-0x5FBF  112x 1  = 112  */
+#define __FFSM1_DATA_BUF_BASE           0x4550  /* 0x4550-0x4A9F  80 x 17 = 1360 */
+#define __CTRL_K_TBL_BASE               0x4AA0  /* 0x4AA0-0x4AAF  1  x 16 = 16   */
+#define __RX_SARPDMA_CMD_BUF_BASE       0x3900  /* 0x3900-0x39FF  128x 2  = 256  */
+#define __TX_SARPDMA_CMD_BUF_BASE       0x3A00  /* 0x3A00-0x3AFF  128x 2  = 256  */
+#define __RX_SAR_CTXT_BUF_BASE          0x3200  /* 0x3200-0x33FF  64 x 8  = 512  */
+#define __RX_PDMA_CTXT_BUF_BASE         0x4C00  /* 0x4C00-0x4DFF  64 x 8  = 512  */
+#define __TX_SAR_CTXT_BUF_BASE          0x4E00  /* 0x4E00-0x4FFF  64 x 8  = 512  */
+#define __TX_PDMA_CTXT_BUF_BASE         0x3B00  /* 0x3B00-0x3CFF  64 x 8  = 512  */
+#define __PDMA_RX_DATA_BUFFER           0x5FC0  /* 0x5FC0-0x5FDF  32 x 1  = 32   */
+#define __PDMA_TX_DATA_BUFFER           0x5FE0  /* 0x5FE0-0x5FFF  64 x 1  = 32   */
+
+//---------------------------------------------------
+// detailed SB allocation
+//---------------------------------------------------
+
+// EDMA_RD_CNT_SM related
+#define EDMA_SM_UPDATE_THRESHOLD        1
+#define __EDMA_WRITE_IDX_0              0x5FC0
+#define __EDMA_WRITE_IDX_1              0x5FC1
+
+#define __EDMA_READ_CH_STATUS_PTR_0     0x5FE0
+#define __EDMA_READ_CH_STATUS_PTR_1     0x5FE8
+
+#define __EDMA_CH_CTXT_IDX_FPI_ADDR     0x1E700A6C
+#define __EDMA_CH_CTXT_IDX_FPI_hi       0x1E70
+#define __EDMA_CH_CTXT_IDX_FPI_low      0x0A6C
+#define xLDI_edma_ch_ctxt_idx_fpi_addr(__rd) \
+    xLDI_dword(__rd, __EDMA_CH_CTXT_IDX_FPI_hi, __EDMA_CH_CTXT_IDX_FPI_low)
+
+#define __EDMA_LL_PTR_LOW_FPI_ADDR      0x1E700A8C
+#define __EDMA_LL_PTR_LOW_FPI_hi        0x1E70
+#define __EDMA_LL_PTR_LOW_FPI_lo        0x0A8C
+#define xLDI_edma_ll_ptr_fpi_addr(__rd) \
+    xLDI_dword(__rd, __EDMA_LL_PTR_LOW_FPI_hi, __EDMA_LL_PTR_LOW_FPI_lo)
+
+#define __EDMA_CH_STATUS_LOW_FPI_ADDR       0x1E700A70
+#define __EDMA_CH_STATUS_LOW_FPI_hi         0x1E70
+#define __EDMA_CH_STATUS_LOW_FPI_lo         0x0A70
+#define xLDI_edma_ch_status_fpi_addr(__rd) \
+    xLDI_dword(__rd, __EDMA_CH_STATUS_LOW_FPI_hi, __EDMA_CH_STATUS_LOW_FPI_lo)
+
+//---------------------------------------------------
+// VR9 EFM-TC general context [0x3480..0x35FF]
+//---------------------------------------------------
+#define __BC_ID                             0x3480
+
+//---------------------------------------------------
+// RX & TX SAR PDMA CMD Write Pointers
+//---------------------------------------------------
+#define __TX_SARPDMA_CMD_RDPTR              0x3481
+#define __RX_SARPDMA_CMD_WRPTR              0x3482
+#define __TX_SARPDMA_CMD_WRPTR              0x3483
+
+//---------------------------------------------------
+// RX DMA Descriptor - Read & Write Pointers
+//---------------------------------------------------
+#define __RX_DMA_DESC_RDPTR                 0x3484
+#define __RX_DMA_DESC_WRPTR                 0x3485
+
+//---------------------------------------------------
+// RX Context Use Flag
+//---------------------------------------------------
+#define __RX_CTX_USE_FLAG_0                 0x3486
+#define __RX_CTX_USE_FLAG_1                 0x3487
+
+//---------------------------------------------------
+// TX Context Use Flag
+//---------------------------------------------------
+#define __TX_CTX_USE_FLAG_0                 0x3488
+#define __TX_CTX_USE_FLAG_1                 0x3489
+
+//---------------------------------------------------
+// TX QoS SWAP read pointer
+//---------------------------------------------------
+#define __FP_IN_DESC_RDPTR                  0x348A
+#define __CPU_IN_DESC_RDPTR                 0x348B
+#define __SWAP_DESC_RDPTR                   0x348C
+
+//---------------------------------------------------
+// Upstream backpressure GPIO control value
+//---------------------------------------------------
+#define __GPIO_BP_CURR_VAL                  0x348D
+
+//---------------------------------------------------
+// Task pending flag for power save
+//---------------------------------------------------
+#define __TASK_PENDING_FLAG                 0x348E
+
+//---------------------------------------------------
+// Downstream Pending Receive packet counter
+// to avoid read pointer and write pointer overlap issue
+//---------------------------------------------------
+#define __DS_PENDING_RECV_PKT_CNT           0x348F
+#define DS_RW_PTR_GUARD                     2
+
+//---------------------------------------------------
+// Task pending flag for power save in PP32 1
+//---------------------------------------------------
+#define __TASK_PENDING_FLAG_VRX318_PPA            0x3490
+
+#define __WAKEUP_MIB_VRX318												0x3491
+//---------------------------------------------------
+// Receive Non Idle Cell Count
+//---------------------------------------------------
+#define __RECEIVE_NON_IDLE_CELL_CNT_0       0x34A0
+#define __RECEIVE_NON_IDLE_CELL_CNT_1       0x34A1
+
+//---------------------------------------------------
+// Receive Idle Cell Count
+//---------------------------------------------------
+#define __RECEIVE_IDLE_CELL_CNT_0           0x34A2
+#define __RECEIVE_IDLE_CELL_CNT_1           0x34A3
+
+//---------------------------------------------------
+// Transmit Cell Count
+//---------------------------------------------------
+#define __TRANSMIT_CELL_CNT_0               0x34A4
+#define __TRANSMIT_CELL_CNT_1               0x34A5
+
+//---------------------------------------------------
+// Receive Packet Count - From Switch
+//---------------------------------------------------
+#define __FP_RECEIVE_PKT_CNT                0x34A6
+#define __CPU_PATH_RECEIVE_PKT_CNT          0x34A7
+
+//---------------------------------------------------
+// Receive Packet Count - From Switch
+//---------------------------------------------------
+#define __TIMER_INT_COUNT                   0x34A8
+
+//---------------------------------------------------
+// address of pkt_cnt that is used to control GPIO
+// for VR9, it is initialized to 0x7E08 in tc_init.asm
+// for debug/test purpose, it should be changed to 0x3490
+// sicne 0x7e08 is not writable, note that the address
+// should be 8 dword aligned
+//---------------------------------------------------
+#define __GPIO_CTRL_PKT_CNT_ADDR_CFG        0x34A9
+
+//---------------------------------------------------
+// bonding variables
+//---------------------------------------------------
+
+// polling control
+// MBOX_IGU6_ISR is used to as signal of new fragment ready
+#define __GIF_TX_POLLING_CTRL               0x34AA
+#define __GIF_TX_FRAG_AVAILABLE             0x34AB
+
+
+#define xGET_TX_NEW_FRAG_AVAIL(__r_new_frag_ready)      \
+    xLDRi(__r_new_frag_ready, __MBOX_IGU6_ISR, WB_NOINC)
+
+#define xCLR_TX_NEW_FRAG_AVAIL(__r_val)                 \
+    xSTIr(__MBOX_IGU6_ISRC, __r_val, WB_NOINC)
+
+
+// read index for TX descritpor 0x34AC-0X34AF
+#define __GIF_TX_DES_RDIDX                  0x34AC
+#define __GIF_TX_DES_SIZE                   32
+#define __GIF_TX_DES_SIZE_BIT_SHIFT         5
+
+#define __GIF_TX_DES_BP_SIZE                16
+#define __GIF_TX_DES_BP_SIZE_BIT_SHIFT      4
+
+// bit0-3 indicate if GIF0-GIF3 is up or down
+// 0: link is down, means local_state != SYNC or SYNC_TRUE or remote_state = 0
+// 1: link is on, means locase_state = SYNC or SYNC_TRUE and remote_state = 1
+#define __PREV_GIF_LINK_STATE               0x34B0
+#define __PEER_GIF_LINK_STATE               0x34B1
+
+#define __PREV_LINK_UP_DOWN_STATUS          0x34B2
+
+// busy polling couter for each GIF when link is down
+#define __GIF_BUSY_POLLING_CNT              0x34B3
+
+// waiting for RX descriptor
+#define __RX_WAIT_FOR_DES                   0x34B4
+#define __CONTEXT_DESC_INIT_RET_ADDR        0x34B5
+#define __RX_NO_DES_CNT                     0x34B6
+
+//Number of times DREG_PDBRAM_S_44K_OWN changes from S_44K_OWN_PPE to S_44K_OWN_DSL
+#define __PDBRAM_OWN_CHG_CNT                0x34B7
+
+
+//---------------------------------------------------
+// SFSM0 (Pages) - Data
+// 112 * 17 = 1904
+//---------------------------------------------------
+//#define __SFSM0_DATA_BUF_BASE
+#define __SFSM0_DATA_BUF_SIZE               1904
+#define __SFSM0_DATA_PAGE_NUM               112
+
+//---------------------------------------------------
+// SFSM0 (Pages) - Ctrl
+// 112 * 1 = 64
+//---------------------------------------------------
+//#define __SFSM0_CTRL_BUF_BASE
+#define __SFSM0_CTRL_BUF_SIZE               __SFSM0_DATA_PAGE_NUM
+#define __SFSM0_CTRL_PAGE_NUM               __SFSM0_DATA_PAGE_NUM
+
+//---------------------------------------------------
+// FFSM0 (Pages) - Data
+// 80 * 17 = 1360
+//---------------------------------------------------
+//#define __FFSM0_DATA_BUF_BASE
+#define __FFSM0_DATA_BUF_SIZE               1360
+#define __FFSM0_DATA_PAGE_NUM               80
+
+//---------------------------------------------------
+// SFSM1 (Pages) - Data
+// 112 * 17 = 1904
+//---------------------------------------------------
+//#define __SFSM1_DATA_BUF_BASE
+#define __SFSM1_DATA_BUF_SIZE               1088
+#define __SFSM1_DATA_PAGE_NUM               64
+
+//---------------------------------------------------
+// SFSM1 (Pages) - Ctrl
+// 112 * 1 = 112
+//---------------------------------------------------
+//#define __SFSM1_CTRL_BUF_BASE
+#define __SFSM1_CTRL_BUF_SIZE               __SFSM1_DATA_PAGE_NUM
+#define __SFSM1_CTRL_PAGE_NUM               __SFSM1_DATA_PAGE_NUM
+
+//---------------------------------------------------
+// FFSM1 (Pages) - Data
+// 89 * 17 = 1360
+//---------------------------------------------------
+//#define __FFSM1_DATA_BUF_BASE
+#define __FFSM1_DATA_BUF_SIZE               1360
+#define __FFSM1_DATA_PAGE_NUM               80
+
+//---------------------------------------------------
+// Control K Table
+// 1 * 16 = 16
+//---------------------------------------------------
+//#define __CTRL_K_TBL_BASE
+#define __CTRL_K_TBL_SIZE                   16
+#define __CTRL_K_TBL_NUM                    1
+
+//---------------------------------------------------
+// RX SARPDMA Command Buffer
+// 128 * 2 = 256
+//---------------------------------------------------
+//#define __RX_SARPDMA_CMD_BUF_BASE
+#define __RX_SARPDMA_CMD_BUF_SIZE           256
+#define __RX_SARPDMA_CMD_NUM                128
+
+//---------------------------------------------------
+// TX SARPDMA Command Buffer
+// 128 * 2 = 256
+//---------------------------------------------------
+//#define __TX_SARPDMA_CMD_BUF_BASE
+#define __TX_SARPDMA_CMD_BUF_SIZE           256
+#define __TX_SARPDMA_CMD_NUM                128
+
+//---------------------------------------------------
+// RX SAR Context Buffer
+// 64 * 8 = 512
+//---------------------------------------------------
+//#define __RX_SAR_CTXT_BUF_BASE
+#define __RX_SAR_CTXT_BUF_SIZE              512
+#define __RX_SAR_CTXT_NUM                   64
+
+//---------------------------------------------------
+// RX PDMA Context Buffer
+// 64 * 8 = 512
+//---------------------------------------------------
+//#define __RX_PDMA_CTXT_BUF_BASE
+#define __RX_PDMA_CTXT_BUF_SIZE             512
+#define __RX_PDMA_CTXT_NUM                  64
+
+//---------------------------------------------------
+// TX SAR Context Buffer
+// 64 * 8 = 512
+//---------------------------------------------------
+//#define __TX_SAR_CTXT_BUF_BASE
+#define __TX_SAR_CTXT_BUF_SIZE              512
+#define __TX_SAR_CTXT_NUM                   64
+
+//---------------------------------------------------
+// TX PDMA Context Buffer
+// 64 * 8 = 512
+//---------------------------------------------------
+//#define __TX_PDMA_CTXT_BUF_BASE
+#define __TX_PDMA_CTXT_BUF_SIZE             512
+#define __TX_PDMA_CTXT_NUM                  64
+
+
+//=============================================================================
+// Performance Monitor And Event Trace
+//=============================================================================
+#define __PP32_0_INIT_CNT               0x385C
+#define __PP32_1_INIT_CNT               0x385D
+#define __PP32_0_MAIN_LOOP_CNT          0x385E
+#define __PP32_1_MAIN_LOOP_CNT          0x385F
+#define __EVENT_TRACE_INDEX_BASE        0x2570  /* 0x2570-0x257F size = 1x16 = 16 */
+
+// use SFSM RX buffer to store more event, start_cmd_process will
+// disable store for BC1
+#define __EVENT_TRACE_USE_BC1_SFSM_BASE 0x5800  /* 0x5800-0x5BFF size = 16x64 = 1024 */
+
+#define __MODULE_PERF_STATISTICS        0x3860	/* 0x3860-0x38FF size = 20x8 = 160 */
+#define __PROFILING_START_TIME_hi	    0x3474
+#define __PROFILING_START_TIME_lo	    0x3475
+#define __PROFILING_END_TIME_hi	        0x3476
+#define __PROFILING_END_TIME_lo	        0x3477
+#define __RROF_EVENT_CMD	            0x3478
+#define __TIMER_SYNC_STATE              0x3479
+#define __TC_RX_FIFO_PKT_CNT            0x347A  /* number of correct packet received in RX_FIFO_INT_POLLING */
+
+#define PROF_EVENT_CMD_start            0x1
+#define PROF_EVENT_STATUS_started       0x8001
+#define PROF_EVENT_CMD_stop             0x2
+#define PROF_EVENT_STATUS_stopped       0x8002
+#define TIMER_SYNC_END_STATE            2
+#define EM_TICK_WIDTH                   19
+#define EM_CLK_WIDTH                    13
+
+
+// frag_header tracing
+#define __FRAG_HEADER_TRACE_IDX         0x26C8
+
+#define FH_TRACE_NUM                    128
+#define FH_TRACE_NUM_bit_width          7
+
+#define __EP0_US_SEG_IDX                0x26C8
+#define __EP1_US_SEG_IDX                0x26C9
+#define __EP0_DS_TC_RECV_IDX            0x26CA
+#define __EP1_DS_TC_RECV_IDX            0x26CB
+#define __EP0_DS_EDMA_PP_IDX            0x26CC
+#define __EP1_DS_EDMA_PP_IDX            0x26CD
+#define __EP0_DS_BONDING_DISP_IDX       0x26CE
+#define __EP1_DS_BONDING_DISP_IDX       0x26CF
+
+#define __EP0_US_SEG_FH_BASE            0x5800
+#define __EP1_US_SEG_FH_BASE            0x5880
+#define __EP0_DS_TC_RECV_FH_BASE        0x5900
+#define __EP1_DS_TC_RECV_FH_BASE        0x5980
+#define __EP0_DS_EDMA_PP_FH_BASE        0x5A00
+#define __EP1_DS_EDMA_PP_FH_BASE        0x5A80
+#define __EP0_DS_BONDING_DISP_FH_BASE   0x5B00
+#define __EP1_DS_BONDING_DISP_FH_BASE   0x5B80
+
+
+//=============================================================================
+// Free Spaces
+//=============================================================================
+/*----------------------------------------------------------------------------
+    From    To       Size
+----------------------------------------------------------------------------*/
+
+
+//==============================================================================
+// FROM vr9 bonding
+//--------------
+//PDMA Registers
+//--------------
+#define __DMAL_BAR0_FIFO_STATUS             0x7600
+#define __DMAL_BAR1_FIFO_STATUS             0x7601
+#define __PDMA_BAR0                         0x7602
+#define __PDMA_BAR1                         0x7603
+
+#define __BAR0_WINDOW_SB_ADDR               0x6000
+#define __BAR0_WINDOW_SB_ADDR_PLUS_1        0x6001
+#define __BAR1_WINDOW_SB_ADDR               0x6800
+#define __BAR1_WINDOW_SB_ADDR_PLUS_1        0x6801
+
+
+// hardware registers
+#define __SAR_PDMA_RX_FW_DATABUF_CFG        0x7F02
+#define __SAR_PDMA_TX_FW_DATABUF_CFG        0x7F03
+#define __PDMA_IER                          0x7A0B
+
+//--------------------
+//Constant Definitions
+//--------------------
+
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//---------------------
+//Descriptors Addresses
+//---------------------
+//E1 TX Fragment Descriptor Base Address (Non-Bonding Part)
+//Section 5.2.4 (Non-Bonding Part)
+#define __US_E1_FRAG_DESBA                      0x3800
+#define __US_E1_FRAG_DES_NUM                    128
+#define __US_E1_FRAG_DES_SIZE                   2
+#define __US_E1_FRAG_DES_TOTAL_SIZE             256
+//__US_E1_FRAG_DES_NUM_PER_GIF = __US_E1_FRAG_DES_NUM/__NUM_US_GIFS
+#define __US_E1_FRAG_DES_NUM_PER_GIF            16
+//__US_E1_FRAG_DES_TOTAL_SIZE_PER_GIF = __US_E1_FRAG_DES_TOTAL_SIZE/__NUM_US_GIFS
+#define __US_E1_FRAG_DES_TOTAL_SIZE_PER_GIF     32
+
+//E1 TX Fragment Descriptor Base Address (Bonding Part)
+//Section 5.2.4 (Bonding Part)
+#define __US_E1_FRAG_BP_DESBA                   0x3F60
+#define __US_E1_FRAG_BP_DES_NUM                 128
+#define __US_E1_FRAG_BP_DES_SIZE                1
+#define __US_E1_FRAG_BP_DES_TOTAL_SIZE          128
+//__US_E1_FRAG_BP_DES_NUM_PER_GIF = __US_E1_FRAG_BP_DES_NUM/__NUM_US_GIFS
+#define __US_E1_FRAG_BP_DES_NUM_PER_GIF         16
+//__US_E1_FRAG_BP_DES_TOTAL_SIZE_PER_GIF = __US_E1_FRAG_BP_DES_TOTAL_SIZE/__NUM_US_GIFS
+#define __US_E1_FRAG_BP_DES_TOTAL_SIZE_PER_GIF  16
+
+//System Master E1 RX Fragment Descriptor Base Address
+#define __DS_SM_E1_FRAG_DESBA                   0x3D00
+#define __DS_SM_E1_FRAG_DES_NUM                 32
+#define __DS_SM_E1_FRAG_DES_SIZE                2
+#define __DS_SM_E1_FRAG_DES_TOTAL_SIZE          64
+
+//Bonding Master E1 RX Fragment Descriptor Base Address
+#define __DS_BM_E1_FRAG_DESBA                   0x3D40
+#define __DS_BM_E1_FRAG_DES_NUM                 32
+#define __DS_SM_E1_FRAG_DES_SIZE                2
+#define __DS_SM_E1_FRAG_DES_TOTAL_SIZE          64
+
+//DS Bonding GIF Link List Descriptor Base Address
+#define __DS_BOND_GIF_LL_DESBA                  0x2C00
+#define __DS_BOND_GIF_LL_DES_NUM                256
+
+//DMA TX Channel 1 Descriptor List
+#define __DMA_TX_CH1_DESBA                      0x2600
+#define __DMA_TX_CH1_DESBA_HW                   0x600
+#define __DMA_TX_CH1_DES_NUM                    64
+#define __DMA_TX_CH1_DES_TOTAL_SIZE             128
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
+
+//----------------
+//FW Context & MIB
+//----------------
+
+//US Bonding Priority Queue Descriptor Configuraton Table
+//Section 5.4 in Spec - Already defined in E1
+
+//US Bonding Priority Queue Shaping & Scheduling Configuration Table
+//Section 5.5 in Spec - Already defined in E1
+
+//US Bonding Priority Queue MIB Counters
+//Section 5.6 in Spec - Already defined in E1
+
+
+
+
+
+
+//---------------------
+//FW Internal Variables
+
+//==============================================================================
+// FROM e1
+
+
+//=============================================================================
+// EFM-TC Address definition
+//=============================================================================
+
+/*
+//---------------------------------------------------
+// WAN CPU TX channel Descriptor List
+// 64 * 2 = 128
+//---------------------------------------------------
+#define __CPU_TX_DESC_LIST                  0x3D00
+#define __CPU_TX_DESC_LIST_SIZE             128
+#define __CPU_TX_DESC_NUM                   64
+
+//---------------------------------------------------
+// WAN SWAP TX channel Descriptor List Length
+// 64 * 2 = 128
+//---------------------------------------------------
+#define __SWAP_TX_DESC_LIST                 0x2E80
+#define __SWAP_TX_DESC_LIST_SIZE            64
+#define __SWAP_TX_DESC_NUM                  32
+
+//---------------------------------------------------
+// DSL Fastpath TX Channel Descriptor
+// 64 * 2 = 128
+//---------------------------------------------------
+#define __DSL_FASTPATH_TX_DESC_LIST         0x2580
+#define __DSL_FASTPATH_TX_DESC_LIST_SIZE    128
+#define __DSL_FASTPATH_TX_DESC_NUM          64
+
+
+
+//---------------------------------------------------
+// DMA RX Channel 1 Descriptor
+// 64 * 2 = 128
+//---------------------------------------------------
+#define __DMA_RX_CH1_DESC_LIST              __DSL_FASTPATH_TX_DESC_LIST
+#define __DMA_RX_CH1_DESC_LIST_SIZE         __DSL_FASTPATH_TX_DESC_LIST_SIZE
+#define __DMA_RX_CH1_DESC_NUM               __DSL_FASTPATH_TX_DESC_NUM
+
+//---------------------------------------------------
+// DSL RX Channel Descriptor
+// 64 * 2 = 128
+//---------------------------------------------------
+#define __DSL_RX_DESC_LIST                  0x2600
+#define __DSL_RX_DESC_LIST_SIZE             128
+#define __DSL_RX_DESC_NUM                   64
+
+//---------------------------------------------------
+// DMA TX Channel 1 Descriptor List
+// 64 * 2 = 128
+//---------------------------------------------------
+#define __DMA_TX_CH1_DESC_LIST              __DSL_RX_DESC_LIST
+#define __DMA_TX_CH1_DESC_LIST_SIZE         __DSL_RX_DESC_LIST_SIZE
+#define __DMA_TX_CH1_DESC_NUM               __DSL_RX_DESC_NUM
+
+//---------------------------------------------------
+// DSL Shaping and Scheduling Configure
+// 8 * 4 = 32
+//---------------------------------------------------
+#define __DSL_SHAPING_SCHEDULING_CFG        0x2680
+#define __DSL_SHAPING_SCHEDULING_CFG_SIZE   32
+#define __DSL_SHAPING_SCHEDULING_CFG_NUM    8
+
+//---------------------------------------------------
+// ETH0 RX (Pages) - Data
+// 20 * 32 = 640
+//---------------------------------------------------
+#define __ETH0_RX_DATA_BUF_BASE             0x4550
+#define __ETH0_RX_DATA_BUF_SIZE             640
+#define __ETH0_RX_DATA_PAGE_NUM             20
+
+//---------------------------------------------------
+// ETH0 RX (Pages) - Ctrl
+// 20 * 1 = 20
+//---------------------------------------------------
+#define __ETH0_RX_CTRL_BUF_BASE             0x47D0
+#define __ETH0_RX_CTRL_BUF_SIZE             __ETH0_RX_DATA_PAGE_NUM
+#define __ETH0_RX_CTRL_PAGE_NUM             __ETH0_RX_DATA_PAGE_NUM
+
+*/
+
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_edma.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_edma.h
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_edma.h
@@ -0,0 +1,191 @@
+/******************************************************************************
+ *
+ *                        Copyright (c) 2012, 2014, 2015
+ *                           Lantiq Deutschland GmbH
+ *
+ *  For licensing information, see the file 'LICENSE' in the root folder of
+ *  this software module.
+ *
+ ******************************************************************************/
+#ifndef __VRX218_EDMA_H
+#define __VRX218_EDMA_H
+
+#define EDMA_WRITE_CH           0
+#define EDMA_READ_CH            1
+
+/* EDMA reg */
+#define PCIE_AP_BASE		0x1E102000
+#define PCIE_AP_OFFSET		0x00102000
+#define PCIE_DM_BASE		0x1E700000
+#define PCIE_DM_OFFSET		0x00700000
+#define EDMA_OFFSET		(PCIE_DM_OFFSET + 0x700)
+
+#define EDMA_WCH_DATA_LLE_NUM   32
+#define EDMA_RCH_DATA_LLE_NUM   32
+
+/* EDMA Global Register */
+#define EDMA_WCH_EN			(0x27C + EDMA_OFFSET)
+#define EDMA_WCH_DOORBELL		(0x280 + EDMA_OFFSET)
+#define EDMA_RCH_EN			(0x29C + EDMA_OFFSET)
+#define EDMA_RCH_DOORBELL		(0x2A0 + EDMA_OFFSET)
+
+/* EDMA Interrupt Registers */
+#define EDMA_WCH_INT_STATUS		(0x2BC + EDMA_OFFSET)
+#define EDMA_WCH_INT_MASK		(0x2C4 + EDMA_OFFSET)
+#define EDMA_WCH_INT_CLEAR		(0x2C8 + EDMA_OFFSET)
+#define EDMA_WCH_ERR_STATUS		(0x2CC + EDMA_OFFSET)
+#define EDMA_WCH_DONE_IMWR_ADDR_LOW	(0x2D0 + EDMA_OFFSET)
+#define EDMA_WCH_DONE_IMWR_ADDR_HIGH	(0x2D4 + EDMA_OFFSET)
+#define EDMA_WCH_ABORT_IMWR_ADDR_LOW	(0x2D8 + EDMA_OFFSET)
+#define EDMA_WCH_ABORT_IMWR_ADDR_HIGH	(0x2DC + EDMA_OFFSET)
+#define EDMA_WCH_0_IMWR_DATA		(0x2E0 + EDMA_OFFSET)
+#define EDMA_WCH_LL_ERR_EN		(0x300 + EDMA_OFFSET)
+
+#define EDMA_RCH_INT_STATUS		(0x310 + EDMA_OFFSET)
+#define EDMA_RCH_INT_MASK		(0x318 + EDMA_OFFSET)
+#define EDMA_RCH_INT_CLEAR		(0x31C + EDMA_OFFSET)
+#define EDMA_RCH_ERR_STATUS_LOW		(0x324 + EDMA_OFFSET)
+#define EDMA_RCH_ERR_STATUS_HIGH	(0x328 + EDMA_OFFSET)
+#define EDMA_RCH_LL_ERR_EN		(0x334 + EDMA_OFFSET)
+#define EDMA_RCH_DONE_IMWR_ADDR_LOW	(0x33C + EDMA_OFFSET)
+#define EDMA_RCH_DONE_IMWR_ADDR_HIGH	(0x340 + EDMA_OFFSET)
+#define EDMA_RCH_ABORT_IMWR_ADDR_LOW	(0x344 + EDMA_OFFSET)
+#define EDMA_RCH_ABORT_IMWR_ADDR_HIGH	(0x348 + EDMA_OFFSET)
+#define EDMA_RCH_0_IMWR_DATA		(0x34C + EDMA_OFFSET)
+
+/* EDMA Channel Context Index Registers */
+#define EDMA_CH_IDX			(0x36C + EDMA_OFFSET)
+#define EDMA_CH_CTRL			(0x370 + EDMA_OFFSET)
+#define EDMA_TRANSFER_SIZE		(0x378 + EDMA_OFFSET)
+#define EDMA_SAR_LOW			(0x37C + EDMA_OFFSET)
+#define EDMA_SAR_HIGH			(0x380 + EDMA_OFFSET)
+#define EDMA_DAR_LOW			(0x384 + EDMA_OFFSET)
+#define EDMA_DAR_HIGH			(0x388 + EDMA_OFFSET)
+#define EDMA_LL_PTR_LOW			(0x38C + EDMA_OFFSET)
+#define EDMA_LL_PTR_HIGH		(0x390 + EDMA_OFFSET)
+
+
+typedef struct {
+    // The following TLP header fields are used by the eDMA when generating
+    // MRd/Mwr (not IMWr) TLPs
+    unsigned int at : 2;    // Address Translation (AT)
+
+    unsigned int tc : 3;    // Traffic Class (TC)
+
+    unsigned int td : 1;    // Traffic Digest, the PCIe core adds the ECRC
+                            // field and sets the TD bit in TLP header
+    unsigned int ro : 1;    // Releaxed Ording
+
+    unsigned int ns : 1;    // No Snoop
+
+    // -----------------------
+    unsigned int res0 : 7;
+
+    unsigned int fn   : 5;  // Function Number (FN) for generated MRd/MWr DMA TLPs
+                            // The core uses this when generating the RID for the
+                            // MRd/MWr DMA TLP
+    unsigned int res1 : 2;
+
+    unsigned int ll_en: 1;  // link list enable
+
+    unsigned int ccs  : 1;  // Consumer Cycles State (CCS).
+                            // Used in Link List mode only. It is used to synchronize
+                            // the Producer (Software) and the Consumer (DMA).
+                            // *You must initialize this bit.* The DMA updates
+                            // this bit during linked list operation
+    unsigned int res2 : 1;
+
+    unsigned int cs   : 2;  // Channel Status (CS)
+                            // The Channel Status bits identify the current operational
+                            // state of the DMA write or read channel.
+                            //  00: Reserved
+                            //  01: Running, this channel is active and transferring data
+                            //  10: Halted. An error condition has been detected.
+                            //      and the DMA has stopped this channel
+                            //  11: Stopped. The DMA has transferred all data for
+                            //      this channel or you have prematurely stopped
+                            //      this channel by writing to the Stop field of
+                            //      of the DMA R/W doorbell register
+
+    unsigned int rie  : 1;  // remote interrupt enable
+
+    unsigned int lie  : 1;  // local interrupt enable
+
+    unsigned int llp  : 1;  // load link pointer (LLP)
+                            // Used in link list mode only. Indicates that
+                            // this linked list element is a link element, and
+                            // it's LL element pointer DWORDs are pointint to the next
+                            // (non-contiguous) element
+                            // the DMA loads this field with the LLP of the
+                            // linked list element
+
+    unsigned int tcb  : 1;  // Toggle Cycle Bit (TCB)
+                            // Indicates to the DMA to toglle its intepreation of
+                            // the CB. Used in linked list mode only. It is used
+                            // to synchorize the Producer (Software) and the
+                            // Consumer (DMA).
+                            // The DMA loads this field with the TCB of the linked
+                            // list element.
+                            // Note: this field is not defined in a ata LL element
+
+    unsigned int cb  : 1;   // Cycle Bit (CB)
+                            // Unsed in Linked list mode only.  It is used
+                            // to synchorize the Producer (Software) and the
+                            // Consumer (DMA).
+                            // The DMA loads this field with the CB of the linked
+                            // list elment
+
+} edma_ch_ctrl_t;
+
+typedef struct {
+    //-----------------------------------------------
+    // {{PPE_FW fields
+    // for transfer_type DES_xxx, ctxt_ptr --> DES_SYNC_CFG_CTXT
+    // for transfer_type PKT_xxx, ctxt_ptr --> EDMA_LLE_EXT
+    unsigned int ctxt_ptr       : 16;
+
+    // PKT_WRITE       : 0
+    // PKT_READ        : 1
+    //
+    // DES_WRITE_DW0    : 3
+    // DES_WRITE_DW1    : 4
+    // DES_READ         : 5
+    unsigned int transfer_type  : 4;
+
+    // PPE_FW fields }}
+    //-----------------------------------------------
+
+    unsigned int res0 : 7;
+
+    unsigned int rie  : 1;  // = 0, load link pointer (LLP)
+    unsigned int lie  : 1;  // = 0, load link pointer (LLP)
+    unsigned int llp  : 1;  // = 0, load link pointer (LLP)
+    unsigned int res1 : 1;  //
+    unsigned int cb   : 1;  // Cycle Bit (CB)
+
+    unsigned int transfer_size;
+    unsigned int sar_low;
+    unsigned int sar_high;
+    unsigned int dar_low;
+    unsigned int dar_high;
+
+} edma_lle_data_t;
+
+typedef struct {
+    unsigned int res0 : 29;
+    unsigned int llp  : 1;  // = 1, load link pointer (LLP)
+    unsigned int tcb  : 1;  // Toggle Cycle Bit (TCB)
+    unsigned int cb   : 1;  // Cycle Bit (CB)
+
+    unsigned int res1;
+
+    unsigned int lle_ptr_low;
+    unsigned int lle_ptr_high;
+
+    unsigned int res2;
+    unsigned int res3;
+} edma_lle_link_t;
+
+
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_framework.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_framework.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_framework.h
@@ -0,0 +1,142 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2015 Zhu YiXin<yixin.zhu@lantiq.com>
+ */
+
+#ifndef __VRX318_FRAMEWORK_H__
+#define __VRX318_FRAMEWORK_H__
+#include <linux/klogging.h>
+
+
+enum ep_hw_type { /* Used for Future Product */
+	HW_TYPE_VRX318,
+	HW_TYPE_MAX,
+};
+
+enum vrx318_status {
+	VRX318_RUNNING = 0, /* TC loaded succesfully */
+	VRX318_INIT, /* in Initialization */
+	VRX318_NO_TC, /* Init done, but NO TC loaded */
+	VRX318_SWITCHING, /* TC is swiching */
+	VRX318_EXIT, /* module is going to be removed */
+};
+
+enum dsl_tc_mode {
+	TC_ATM_SL_MODE = 0,
+	TC_PTM_SL_MODE = 1, /*PTM Single line mode */
+	TC_PTM_BND_MODE = 2, /* PTM Bonding mode */
+	TC_NONE_MODE,
+};
+
+struct vrx318_param {
+	unsigned int p2p_en:1;
+	unsigned int cdma_wr_en:1;
+	unsigned int lle_in_sb:1;
+	unsigned int pmac_en:1;
+	unsigned int dfe_loopback:1;
+	unsigned int atm_qos:1;
+	unsigned int res0:26;
+
+	int q_gamma_map[4];
+	int qsb_tau;
+	int qsb_srvm;
+	int qsb_tstep;
+	int aal5r_max_pktsz;
+	int aal5r_min_pktsz;
+	int aal5s_max_pktsz;
+	int oam_prio;
+};
+
+/* Please note, any HW specific/related paramter must be accessed via MACRO.
+to make it easy to add new product in future.
+*/
+struct vrx318_priv {
+	struct pcie_ep_dev ep_dev[MAX_VRX318_NUM]; /* EP dev */
+	int ep_num;
+	int show_time_stat[MAX_VRX318_NUM];
+	enum vrx318_status tc_stat;
+	enum dsl_tc_mode tc_mode[MAX_VRX318_NUM];
+	enum ep_hw_type hw_type;
+	/* u32 msg_enable; */
+	struct device *pdev;
+	struct module *owner;
+	struct proc_dir_entry *proc_dir;
+	struct vrx318_soc_cfg soc_cfg;
+	int port_id; /* PMAC port ID */
+	dp_cb_t	cb; /* Datapath library callback function set */
+	void *tc_priv;
+	struct vrx318_param param;
+	spinlock_t fw_lock; /* Framework lock */
+};
+
+/* VRX318 back_pointer structure from ATM TC or PTM TC*/
+struct vrx318_tc {
+	struct vrx318_priv *frwk;
+	int ep_id;
+};
+
+/* Debug Level */
+#define DBG_ERR		BIT(0)
+#define DBG_PKT_RX	BIT(1)
+#define DBG_PKT_TX	BIT(2)
+#define DBG_EVENT	BIT(3)
+#define DBG_PKT_RX_DUMP	BIT(4)
+#define DBG_PKT_TX_DUMP	BIT(5)
+#define DBG_INIT	BIT(6)
+#define DBG_INFO	BIT(7)
+#define DBG_OAM_RX	BIT(8)
+#define DBG_OAM_TX	BIT(9)
+#define DBG_OAM_RX_DUMP	BIT(10)
+#define DBG_OAM_TX_DUMP	BIT(11)
+#define DBG_QOS		BIT(12)
+#define DBG_TC_SWITCH	BIT(13)
+#define DBG_LOOPBACK	BIT(14)
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+#define DBG_COC		BIT(15)
+#endif
+
+extern u32 g_vrx318_dbg;
+
+#define vrx318_dbg(dbg_level, fmt, arg...) \
+	do { \
+		if ((g_vrx318_dbg & dbg_level)) { \
+			if (dbg_level & DBG_ERR) { \
+				LOGF_KLOG_ERR_RATELIMITED(fmt, ##arg); \
+			} else if ((dbg_level & DBG_INFO) || \
+					(dbg_level & DBG_INIT)) { \
+				LOGF_KLOG_INFO_RATELIMITED(fmt, ##arg); \
+			} else { \
+				LOGF_KLOG_DEBUG_RATELIMITED(fmt, ##arg); \
+			} \
+		} \
+	} \
+	while (0)
+
+#define VRX318_DEF_MSG_EN	(DBG_ERR | DBG_INIT | DBG_INFO \
+				| DBG_EVENT | DBG_TC_SWITCH)
+
+
+extern void vrx318_cb_setup(void *, void *, void *, void *
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+	, void *
+#endif
+);
+extern int vrx318_unload_atm_tc(struct vrx318_priv *, int);
+extern int max_pvc_num(u32);
+extern void vrx318_atm_param_setup(struct vrx318_priv *, int, int,
+		int, int, int, int);
+extern int vrx318_atm_tc_init(struct vrx318_priv *, int, enum dsl_tc_mode);
+extern int vrx318_unload_ptm_tc(struct vrx318_priv *, int, enum dsl_tc_mode);
+extern int vrx318_ptm_tc_init(struct vrx318_priv *, int, enum dsl_tc_mode);
+extern int vrx318_unload_tc(struct vrx318_priv *, int);
+extern int vrx318_load_tc(struct vrx318_priv *, int, enum dsl_tc_mode);
+extern void vrx318_ptm_param_setup(struct vrx318_priv *, int *);
+extern void get_vrx318_drv_ver(char **, char **);
+extern void vrx318_atm_exit(void);
+extern void vrx318_ptm_exit(void);
+
+#endif /* __VRX318_FRAMEWORK_H__ */
+
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_fw_prereq.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_fw_prereq.h
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_fw_prereq.h
@@ -0,0 +1,21 @@
+/******************************************************************************
+ *
+ *                        Copyright (c) 2012, 2014, 2015
+ *                           Lantiq Deutschland GmbH
+ *
+ *  For licensing information, see the file 'LICENSE' in the root folder of
+ *  this software module.
+ *
+ ******************************************************************************/
+#ifndef __VRX218_FW_PREREQ_H__
+#define __VRX218_FW_PREREQ_H__
+
+/* By Default use PDBRAM for LLE */
+#define LLE_IN_PDBRAM                   1
+
+#define __DS_TC_LOCAL_Q_DES_LIST_NUM    10  //  VRX218 E1 only
+#define __US_TC_LOCAL_Q_DES_LIST_NUM    18
+
+
+#endif  //  __VRX218_FW_PREREQ_H__
+
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ppe_atm_ds.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ppe_atm_ds.h
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ppe_atm_ds.h
@@ -0,0 +1,60 @@
+/******************************************************************************
+ *
+ *                        Copyright (c) 2012, 2014, 2015
+ *                           Lantiq Deutschland GmbH
+ *
+ *  For licensing information, see the file 'LICENSE' in the root folder of
+ *  this software module.
+ *
+ ******************************************************************************/
+#ifndef __VRX218_PPE_ATM_DS_H__
+#define __VRX218_PPE_ATM_DS_H__
+
+/* ATM FW Data-Structure Definitions -- START */
+typedef struct {
+	/*  0h  */
+	unsigned int    new_vlan            :16;
+	unsigned int    res1                :3;
+	unsigned int    vlan_ins            :1;
+	unsigned int    mpoa_type           :2; //  0: EoA without FCS, 1: EoA with FCS, 2: PPPoA, 3:IPoA
+	unsigned int    ip_ver              :1; //  0: IPv4, 1: IPv6
+	unsigned int    mpoa_mode           :1; //  0: VCmux, 1: LLC
+	unsigned int    res2                :8;
+	/*  1h  */
+	unsigned int    oversize            :16;
+	unsigned int    undersize           :16;
+	/*  2h  */
+	unsigned int    res3                :16;
+	unsigned int    mfs                 :16;
+	/*  3h  */
+	unsigned int    uumask              :8;
+	unsigned int    cpimask             :8;
+	unsigned int    uuexp               :8;
+	unsigned int    cpiexp              :8;
+} wrx_queue_config_t;
+
+typedef struct {
+	unsigned int    res1                :27;
+	unsigned int    qid                 :4;
+	unsigned int    qsben               :1;
+} wtx_port_config_t;
+
+typedef struct {
+	/*  0h  */
+	unsigned int    res0                :16;
+	unsigned int    same_vc_qmap        :16; //  e.g., TX Q0, Q2, Q4 is VCID1, config TX Q0, value is binary 0000000000010100. Set all queue in this VC with 1 except this queue.
+	/*  1h  */
+	unsigned int    uu                  :8;
+	unsigned int    cpi                 :8;
+	unsigned int    res1                :9;
+	unsigned int    sbid                :1;
+	unsigned int    qsb_vcid            :4; //  Which QSB queue (VCID) does this TX queue map to.
+	unsigned int    mpoa_mode           :1; //  0: VCmux, 1: LLC
+	unsigned int    qsben               :1; //  reserved in A5
+	/*  2h  */
+	unsigned int    atm_header          :32;
+} wtx_queue_config_t;
+/* ATM FW Data-Structure Definitions -- END */
+
+#endif	/* __VRX218_PPE_ATM_DS_H__ */
+
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ppe_bonding_ds.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ppe_bonding_ds.h
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ppe_bonding_ds.h
@@ -0,0 +1,331 @@
+/******************************************************************************
+ *
+ *                        Copyright (c) 2012, 2014, 2015
+ *                           Lantiq Deutschland GmbH
+ *
+ *  For licensing information, see the file 'LICENSE' in the root folder of
+ *  this software module.
+ *
+ ******************************************************************************/
+
+#ifndef __VR9_BONDING_FW_DATA_STRUCTURE_BE_H_
+#define __VR9_BONDING_FW_DATA_STRUCTURE_BE_H_
+
+    typedef struct {
+
+        unsigned int own:1;
+        unsigned int c:1;
+        unsigned int sop:1;
+        unsigned int eop:1;
+        unsigned int res0:3;
+        unsigned int byte_off:2;
+        unsigned int qos:4;
+        unsigned int res1:3;
+        unsigned int data_len:16;
+
+        unsigned int data_ptr:32;
+
+    } cdma_rx_des_t;
+
+    typedef struct {
+
+        unsigned int own:1;
+        unsigned int c:1;
+        unsigned int sop:1;
+        unsigned int eop:1;
+        unsigned int byte_off:5;
+        unsigned int res0:7;
+        unsigned int data_len:16;
+
+        unsigned int data_ptr:32;
+
+    } cdma_tx_des_t;
+
+    typedef struct {
+
+        unsigned int own:1;
+        unsigned int c:1;
+        unsigned int sop:1;
+        unsigned int eop:1;
+        unsigned int byte_off:5;
+        unsigned int last_frag:1;
+        unsigned int frag_num:6;
+        unsigned int data_len:16;
+
+        unsigned int data_ptr:32;
+
+    } us_bond_pkt_des_t;
+
+    typedef struct {
+
+        unsigned int own:1;
+        unsigned int c:1;
+        unsigned int sop:1;
+        unsigned int eop:1;
+        unsigned int byte_off:5;
+        unsigned int qid:4;
+        unsigned int res0:3;
+        unsigned int data_len:16;
+
+        unsigned int data_ptr:32;
+
+    } us_e1_frag_des_t;
+
+    typedef struct {
+
+        unsigned int frag_header:16;
+        unsigned int status:1;
+        unsigned int pkt_des_ptr:15;
+
+    } us_e1_frag_des_bp_t;
+
+    typedef struct {
+
+        unsigned int own:1;
+        unsigned int c:1;
+        unsigned int sop:1;
+        unsigned int eop:1;
+        unsigned int byte_off:5;
+        unsigned int gid:2;
+        unsigned int res0:5;
+        unsigned int data_len:16;
+
+        unsigned int data_ptr:32;
+
+    } ds_e1_frag_des_t;
+
+    typedef struct {
+
+        unsigned int next_des_ptr:16;
+        unsigned int data_len:16;
+
+        unsigned int data_ptr:32;
+
+    } ds_bond_gif_ll_des_t;
+
+    typedef struct {
+
+        unsigned int family:4;
+        unsigned int fw_type:4;
+        unsigned int interface:4;
+        unsigned int fw_mode:4;
+        unsigned int major:8;
+        unsigned int minor:8;
+
+    } fw_ver_id_t;
+
+    typedef struct {
+
+        unsigned int max_frag_size:16;
+        unsigned int polling_ctrl_cnt:8;
+        unsigned int dplus_fp_fcs_en:1;
+        unsigned int bg_num:3;
+        unsigned int bond_mode:1;
+        unsigned int e1_bond_en:1;
+        unsigned int d5_acc_dis:1;
+        unsigned int d5_b1_en:1;
+
+    } bond_conf_t;
+
+    typedef struct {
+
+        unsigned int queue_map3:8;
+        unsigned int queue_map2:8;
+        unsigned int queue_map1:8;
+        unsigned int queue_map0:8;
+
+    } us_bg_qmap_t;
+
+    typedef struct {
+
+        unsigned int gif_map3:8;
+        unsigned int gif_map2:8;
+        unsigned int gif_map1:8;
+        unsigned int gif_map0:8;
+
+    } us_bg_gmap_t;
+
+    typedef struct {
+
+        unsigned int gif_map3:8;
+        unsigned int gif_map2:8;
+        unsigned int gif_map1:8;
+        unsigned int gif_map0:8;
+
+    } ds_bg_gmap_t;
+
+    typedef struct {
+
+        unsigned int time;
+
+    } curr_time_stamp_t;
+
+    typedef struct {
+
+        unsigned int bp_desba:16;
+        unsigned int desba:16;
+
+    } us_e1_frag_desba_t;
+
+    typedef struct {
+
+        unsigned int dma_des_ba:16;
+        unsigned int desba:16;
+
+    } ds_e1_frag_desba_t;
+
+    typedef struct {
+
+        unsigned int prefix:16;
+        unsigned int mask:16;
+
+    } data_ptr_pdma_prefix_cfg_t;
+
+    typedef struct {
+
+        unsigned int sid:14;
+        unsigned int sop:1;
+        unsigned int eop:1;
+        unsigned int pkt_status:1;
+        unsigned int des_addr:15;
+
+        unsigned int data_ptr:32;
+
+        unsigned int res1:9;
+        unsigned int qid:4;
+        unsigned int gif_id:3;
+        unsigned int rem_len:16;
+
+        unsigned int _res0:16;
+        unsigned int desq_cfg_ctxt_ptr:16;
+
+    } us_bg_ctxt_t;
+
+    typedef struct {
+
+        unsigned int tail_ptr:16;
+        unsigned int head_ptr:16;
+
+        unsigned int sid:14;
+        unsigned int sop:1;
+        unsigned int eop:1;
+        unsigned int fh_valid:1;
+        unsigned int des_num:15;
+
+        unsigned int max_des_num:8;
+        unsigned int to_buff_thres:8;
+        unsigned int max_delay:16;
+
+        unsigned int timeout;
+
+    } ds_bond_gif_ll_ctxt_t;
+
+    typedef struct {
+
+        unsigned int total_rx_frag_cnt;
+
+        unsigned int total_rx_byte_cnt;
+
+        unsigned int overflow_frag_cnt;
+
+        unsigned int overflow_byte_cnt;
+
+        unsigned int out_of_range_frag_cnt;
+
+        unsigned int missing_frag_cnt;
+
+        unsigned int timeout_frag_cnt;
+
+        unsigned int _dw_res0[9];
+
+    } ds_bond_gif_mib_t;
+
+    typedef struct {
+
+        unsigned int conform_pkt_cnt;
+
+        unsigned int conform_frag_cnt;
+
+        unsigned int conform_byte_cnt;
+
+        unsigned int no_sop_pkt_cnt;
+
+        unsigned int no_sop_frag_cnt;
+
+        unsigned int no_sop_byte_cnt;
+
+        unsigned int no_eop_pkt_cnt;
+
+        unsigned int no_eop_frag_cnt;
+
+        unsigned int no_eop_byte_cnt;
+
+        unsigned int oversize_pkt_cnt;
+
+        unsigned int oversize_frag_cnt;
+
+        unsigned int oversize_byte_cnt;
+
+        unsigned int noncosec_pkt_cnt;
+
+        unsigned int noncosec_frag_cnt;
+
+        unsigned int noncosec_byte_cnt;
+
+        unsigned int _dw_res0;
+
+    } ds_bg_mib_t;
+
+    typedef struct {
+
+        unsigned int link_state_chg:1;
+        unsigned int res0:15;
+        unsigned int expected_sid:14;
+        unsigned int last_sop:1;
+        unsigned int last_eop:1;
+
+        unsigned int res1:22;
+        unsigned int bg_pkt_state:2;
+        unsigned int res2:3;
+        unsigned int noncosec_flag:1;
+        unsigned int oversize_flag:1;
+        unsigned int no_eop_flag:1;
+        unsigned int no_sop_flag:1;
+        unsigned int no_err_flag:1;
+
+        unsigned int curr_pkt_frag_cnt;
+
+        unsigned int curr_pkt_byte_cnt;
+
+        unsigned int tail_ptr:16;
+        unsigned int head_ptr:16;
+
+        unsigned int sid:14;
+        unsigned int sop:1;
+        unsigned int eop:1;
+        unsigned int fh_valid:1;
+        unsigned int des_num:15;
+
+        unsigned int _dw_res0[2];
+
+    } ds_bg_ctxt_t;
+
+    typedef struct {
+
+        unsigned int byte_cnt:10;
+        unsigned int int_mem_addr_off:11;
+        unsigned int res0:6;
+        unsigned int eop:1;
+        unsigned int pdma:1;
+        unsigned int sar:1;
+        unsigned int bc:2;
+
+        unsigned int res1:1;
+        unsigned int ext_mem_addr:29;
+        unsigned int release:1;
+        unsigned int pdma_cmd_type:1;
+
+    } pdma_dira_cmd_t;
+
+#endif
+
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ppe_fw_const.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ppe_fw_const.h
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ppe_fw_const.h
@@ -0,0 +1,171 @@
+/******************************************************************************
+ *
+ *                        Copyright (c) 2012, 2014, 2015
+ *                           Lantiq Deutschland GmbH
+ *
+ *  For licensing information, see the file 'LICENSE' in the root folder of
+ *  this software module.
+ *
+ ******************************************************************************/
+
+#ifndef VRX218_Bonding_const_h__
+#define VRX218_Bonding_const_h__
+
+//----------------------------------------------------------------------
+// DES_SYNC_READ number of descriptor per read command config
+//
+//      set DES_SYNC_READ_DES_NUM to 4 or 8
+//
+//
+// for us stream, we will not issue more des_read unless
+//      to_read_num >= US_DES_SYNC_READ_GUARD
+// where
+//      to_read_num            = desc_num - (sync_rd_cnt - sync_wr_cnt)
+//      US_DES_SYNC_READ_GUARD = DES_SYNC_READ_DES_NUM + 4
+#if defined(DES_SYNC_READ_DES_NUM) && (DES_SYNC_READ_DES_NUM == 8)
+
+    #define DES_SYNC_READ_DW_NUM    16
+    #define US_DES_SYNC_READ_GUARD  12
+
+#else
+
+    #define DES_SYNC_READ_DES_NUM   4
+    #define DES_SYNC_READ_DW_NUM    8
+    #define US_DES_SYNC_READ_GUARD  8
+
+#endif
+
+//----------------------------------------------------------------------
+
+// typedef EDMA_LLE.transfer_type
+#define PKT_WRITE               0
+#define PKT_READ                1
+#define DES_WRITE_DW0           2
+#define DES_WRITE_DW1           3
+#define DES_READ                4
+
+// typedef DES_SYNC_CFG_CTXT.sync_type
+#define US_READ_WRITE_SYNC      0
+#define DS_WRITE_READ_SYNC      1
+
+// typedef DES_SYNC_CFG_CTXT.sync_rd_status
+#define SYNC_RD_IDLE            0
+#define SYNC_RD_CMD_READY       1
+#define SYNC_RD_CMD_ISSUED      2
+#define SYNC_RD_CMD_DONE        3
+
+// typedef DES_SYNC_CFG_CTXT.sync_wr_status
+#define SYNC_WR_IDLE            0
+#define SYNC_WR_CMD_READY       1
+#define SYNC_WR_CMD_DW1_ISSUED  2
+#define SYNC_WR_CMD_DW0_ISSUED  3
+#define SYNC_WR_CMD_DONE        4
+
+// typedef EDMA_RD_CNT_SM.state
+#define ERCS_IDLE               0
+#define ERCS_WRITING_IDX        1
+#define ERCS_READING_LL_PTR     2
+
+// typedef EDMA_CH_CTXT.edma_ch_type
+// typedef EDMA_RD_CNT_SM.ch_id
+#define EDMA_WRITE_CH           0
+#define EDMA_READ_CH            1
+
+#define SIZE_OF_EDMA_LLE            6
+#define SIZE_OF_EDMA_LLE_EXT        SIZE_OF_EDMA_LLE
+#define SIZE_OF_DES_SYNC_CFG_CTXT   32
+#define SIZE_OF_EDMA_CH_CTXT        8
+#define SIZE_OF_EDMA_COPY_CH_CFG    1
+
+#define MIN_FREE_LLE_NUM            2
+#define MIN_FREE_DMAL_FIFO_SLOT     6
+
+#define FPI_FOR_SB0x2000            0x1E220000
+#define FPI_FOR_SB0x2000_HI         0x1E22
+#define FPI_FOR_SB0x2000_LO         0x0
+
+#define PKT_REASSEMBLING                    0
+#define PKT_ASSEMBLY_DONE                   1
+#define PKT_FLUSHING                        2
+
+// CDMA copy channel des own bit definition
+#define CDMA_DES_MIPS_OWN                0
+#define CDMA_DES_DMA_OWN                 1
+
+#define EDMA_STOPPED                        3
+#define EDMA_RUNNING                        1
+
+//Number of Bonding Groups in Upstream
+#define __NUM_US_BG                         4
+//Number of Gamma Interfaces in Upstream
+#define __NUM_US_GIFS                       8
+//Number of Bonding Groups in Downstream
+#define __NUM_DS_BG                         4
+//Number of Gamma Interfaces in Downstream
+#define __NUM_DS_GIFS                       8
+
+#define __MAX_PKT_SIZE                      1604
+#define __MAX_FRAG_NUM_PER_PKT              30
+
+//US Macros definitions
+
+//for US_E1_FRAG_Q descriptor fields
+#define FRAG_TX_DESC_OWNER_E1_DMA_TX        1
+#define FRAG_TX_DESC_OWNER_B1               0
+
+#define FRAG_TX_DESC_STATUS_RELEASED        0
+#define FRAG_TX_DESC_STATUS_NOT_RELEASED    1
+
+#define FRAG_TX_DESC_RELEASED               0
+#define FRAG_TX_DESC_NOT_RELEASED           1
+
+//For BG_CTXT fields
+#define PKT_STATUS_IN_PROCESS               1
+#define PKT_STATUS_NOT_IN_PROCESS           0
+
+#define __US_E1_FRAG_DES_NUM_PER_GIF            16
+
+// constant
+// PDMA maximum burst is 8 dwords
+// set maximum read number to be 4
+#define XPCI_DES_READ_NUM                   4
+#define XPCI_DES_WRITE_MAX_NUM              8
+
+// to keep des_read_ptr and des_write_ptr from reach
+// each other too close
+#define XPCI_DES_RW_WINDOW_SIZE             52
+#define XPCI_DES_WRITE_GUARD_DIST           4
+
+// when segment a fragment, there should be at least
+// US_SEG_GUARD_DIST free descriptor to avoid read/write clash
+#define US_SEG_GUARD_DIST                   2
+
+#define XPCI_DES_RW_NONE                    0
+#define XPCI_DES_RW_CMD_READY               1
+#define XPCI_DES_RW_CMD_INCMDBUF            2
+#define XPCI_DES_RW_CMD_DONE                3
+
+#define DMA_OWN                             0
+#define PPE_OWN                             1
+
+//Constants used by "Unified QoS" Module
+#define __QOS_DISPATCH_OWN      0
+#define __SHAPING_WFQ_SCHED_OWN 1
+
+//Constants used by "PPE DSL Notifications" Module (ppe_dsl_notifications.asm)
+#define S_44K_OWN_DSL   0
+#define S_44K_OWN_PPE   1
+
+#define __DREG_SIGNATURE_VAL_HWORD  0xA5A5
+
+//Constants used by "Bonding - Descriptor Synchronization" Module
+#define __BOND_DES_SYNC_IDLE_STATE      0
+#define __BOND_DES_SYNC_CDMA_READ_STATE 1
+
+#define READ_WRITE_SYNC     0
+#define WRITE_READ_SYNC     1
+
+#define UPSTREAM            0
+#define DOWNSTREAM          1
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ppe_fw_ds.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ppe_fw_ds.h
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ppe_fw_ds.h
@@ -0,0 +1,295 @@
+/******************************************************************************
+ *
+ *                        Copyright (c) 2012, 2014, 2015
+ *                           Lantiq Deutschland GmbH
+ *
+ *  For licensing information, see the file 'LICENSE' in the root folder of
+ *  this software module.
+ *
+ ******************************************************************************/
+
+#ifndef __SMARTPHY_DS_BE_H_
+#define __SMARTPHY_DS_BE_H_
+
+    typedef struct {
+
+        unsigned int ctxt_ptr:16;
+        unsigned int transfer_type:4;
+        unsigned int _res0:7;
+        unsigned int rie:1;
+        unsigned int lie:1;
+        unsigned int llp:1;
+        unsigned int tcb:1;
+        unsigned int cb:1;
+
+        unsigned int transfer_size;
+
+        unsigned int sar_low;
+
+        unsigned int sar_high;
+
+        unsigned int dar_low;
+
+        unsigned int dar_high;
+
+    } edma_lle_t;
+
+    typedef struct {
+
+        unsigned int srcq_ctxt_ptr:16;
+        unsigned int src_des_ptr:16;
+
+        unsigned int dstq_ctxt_ptr:16;
+        unsigned int dst_des_ptr:16;
+
+        unsigned int src_des_bp_ptr:16;
+        unsigned int dst_des_bp_ptr:16;
+
+        unsigned int ctxt_ptr:16;
+        unsigned int transfer_type:4;
+        unsigned int _res0:4;
+        unsigned int des_sync_size:8;
+
+        unsigned int _dw_res0[2];
+
+    } edma_lle_ext_t;
+
+    typedef struct {
+
+        unsigned int sync_type:1;
+        unsigned int us_des_polling_needed:1;
+        unsigned int running_cnt:4;
+        unsigned int polling_intv:4;
+        unsigned int max_polling_intv:4;
+        unsigned int _res0:1;
+        unsigned int soc_des_own_val:1;
+        unsigned int desq_cfg_ctxt:16;
+
+        unsigned int sync_rd_status:3;
+        unsigned int sync_rd_size:13;
+        unsigned int sync_rd_idx:16;
+
+        unsigned int rd_cmd_sar;
+
+        unsigned int rd_cmd_dar;
+
+        unsigned int sync_wr_status:3;
+        unsigned int sync_wr_size:13;
+        unsigned int sync_wr_idx:16;
+
+        unsigned int wr_cmd_sar;
+
+        unsigned int wr_cmd_dar;
+
+        unsigned int ext_desc_base_addr;
+
+        unsigned int ext_bp_des_base_addr;
+
+        unsigned int _dw_res0;
+
+        unsigned int cdma_dst_des_dw0;
+
+        unsigned int cdma_dst_des_dw1;
+
+        unsigned int sync_rd_cmd_cnt;
+
+        unsigned int sync_wr_cmd_cnt;
+
+        unsigned int sync_rd_cnt;
+
+        unsigned int sync_wr_cnt;
+
+        unsigned int rd_des_buf[16];
+
+    } des_sync_cfg_ctxt_t;
+
+    typedef struct {
+
+        unsigned int des_idx:8;
+        unsigned int _res0:3;
+        unsigned int dir:1;
+        unsigned int _res1:2;
+        unsigned int state:1;
+        unsigned int sync_type:1;
+        unsigned int desq_cfg_ctxt:16;
+
+        unsigned int soc_sync_addr;
+
+        unsigned int enq_pkt_cnt;
+
+        unsigned int deq_pkt_cnt;
+
+        unsigned int cdma_tx_des_dw0;
+
+        unsigned int cdma_tx_des_dw1;
+
+        unsigned int cdma_rx_des_dw0;
+
+        unsigned int cdma_rx_des_dw1;
+
+    } bond_des_sync_cfg_ctxt_t;
+
+    typedef struct {
+
+        unsigned int edma_ch_type:1;
+        unsigned int edma_pcs:1;
+        unsigned int edma_lle_num:6;
+        unsigned int edma_lle_sb_size:8;
+        unsigned int edma_lle_sb_base:16;
+
+        unsigned int edma_lle_ext_sb_base:16;
+        unsigned int fw_pp_idx:8;
+        unsigned int fw_wr_idx:8;
+
+        unsigned int edma_lle_fpi_base;
+
+        unsigned int edma_rd_idx:8;
+        unsigned int fw_pp_cnt:8;
+        unsigned int edma_rd_cnt:8;
+        unsigned int fw_wr_cnt:8;
+
+        unsigned int edma_extra_db_cnt:24;
+        unsigned int edma_zero_complete_cnt:4;
+        unsigned int _res0:2;
+        unsigned int edma_ch_status:2;
+
+        unsigned int edma_lle_pending_cnt;
+
+        unsigned int edma_lle_pending_wr_ptr;
+
+        unsigned int edma_lle_pending_wr_dw0;
+
+    } edma_ch_ctxt_t;
+
+    typedef struct {
+
+        unsigned int srcq_ctxt_ptr:16;
+        unsigned int dstq_ctxt_ptr:16;
+
+    } edma_copy_ch_cfg_t;
+
+    typedef struct {
+
+        unsigned int _res0:29;
+        unsigned int ch_id:1;
+        unsigned int state:2;
+
+        unsigned int _dw_res0;
+
+        unsigned int wch_idx_write_pdma_cmd0;
+
+        unsigned int wch_idx_write_pdma_cmd1;
+
+        unsigned int wch_ll_ptr_read_pdma_cmd0;
+
+        unsigned int wch_ll_ptr_read_pdma_cmd1;
+
+        unsigned int rch_idx_write_pdma_cmd0;
+
+        unsigned int rch_idx_write_pdma_cmd1;
+
+        unsigned int rch_ll_ptr_read_pdma_cmd0;
+
+        unsigned int rch_ll_ptr_read_pdma_cmd1;
+
+        unsigned int pdma_bc3_rd_cmd_issue_cnt;
+
+        unsigned int pdma_bc3_rd_cmd_finish_cnt;
+
+        unsigned int _dw_res1[4];
+
+    } edma_rd_cnt_sm_t;
+
+    typedef struct {
+
+        unsigned int pp32_core_id:1;
+        unsigned int us_bonding_master:1;
+        unsigned int us_segment_en:1;
+        unsigned int us_buf_release_en:1;
+        unsigned int profiling_en:1;
+        unsigned int event_monitor_en:1;
+        unsigned int _res0:2;
+        unsigned int ds_bonding_master:1;
+        unsigned int ds_pkt_dispatch_en:1;
+        unsigned int ds_pkt_reconstruct_en:1;
+        unsigned int ds_pkt_flush_en:1;
+        unsigned int _res1:2;
+        unsigned int us_bonding_des_sync:1;
+        unsigned int ds_bonding_des_sync:1;
+        unsigned int tc_us_en:1;
+        unsigned int tc_ds_en:1;
+        unsigned int _res2:5;
+        unsigned int des_sync_en:1;
+        unsigned int edma_write_cnt_update_en:1;
+        unsigned int edma_read_cnt_update_en:1;
+        unsigned int edma_write_lle_gen_en:1;
+        unsigned int edma_read_lle_gen_en:1;
+        unsigned int edma_post_proc_en:1;
+        unsigned int qos_wfq_shaping_en:1;
+        unsigned int qos_dispatch_en:1;
+        unsigned int qos_replenish_en:1;
+
+    } task_cfg_t;
+
+    typedef struct {
+
+        unsigned int enter_time;
+
+        unsigned int total_call_num;
+
+        unsigned int idle_call_num;
+
+        unsigned int working_call_num;
+
+        unsigned int idle_call_time_hi;
+
+        unsigned int idle_call_time_lo;
+
+        unsigned int working_call_time_hi;
+
+        unsigned int working_call_time_lo;
+
+    } module_perf_statistics_t;
+
+    typedef struct {
+
+        unsigned int _res0:12;
+        unsigned int pp32_1_main_loop:1;
+        unsigned int pp32_0_main_loop:1;
+        unsigned int _res1:1;
+        unsigned int ds_bonding_flush:1;
+        unsigned int ds_bonding_pkt_reconst:1;
+        unsigned int ds_bonding_pkt_dispatch:1;
+        unsigned int ds_bonding_link_state_check:1;
+        unsigned int us_bonding_buf_release:1;
+        unsigned int us_bonding_segment:1;
+        unsigned int tc_update_link_state:1;
+        unsigned int tc_rx_fifo_proc:1;
+        unsigned int tc_rx_main:1;
+        unsigned int tc_tx_main:1;
+        unsigned int edma_rd_cnt_update:1;
+        unsigned int edma_rwch_pp:1;
+        unsigned int edma_wch_lle_prod:1;
+        unsigned int edma_rch_lle_prod:1;
+        unsigned int us_wfq_shaping:1;
+        unsigned int us_qos_dispatch:1;
+        unsigned int des_sync:1;
+
+    } module_index_t;
+
+    typedef struct {
+
+        unsigned int srcq_ctxt_ptr:16;
+        unsigned int dstq_ctxt_ptr:16;
+
+    } cdma_copy_ch_cfg_t;
+
+    typedef struct {
+
+        unsigned int _res0:31;
+        unsigned int grx500:1;
+
+    } soc_family_t;
+
+#endif
+
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ppe_ptm_tc_ds.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ppe_ptm_tc_ds.h
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ppe_ptm_tc_ds.h
@@ -0,0 +1,257 @@
+/******************************************************************************
+ *
+ *                        Copyright (c) 2012, 2014, 2015
+ *                           Lantiq Deutschland GmbH
+ *
+ *  For licensing information, see the file 'LICENSE' in the root folder of
+ *  this software module.
+ *
+ ******************************************************************************/
+
+#ifndef __TC_DS__H__
+#define __TC_DS__H__
+
+#define US_BONDING_MASTER    0
+#define DS_BONDING_MASTER    1
+
+
+struct cfg_std_data_len {
+    unsigned int res1                   :14;
+    unsigned int byte_off               :2;     //  byte offset in RX DMA channel
+    unsigned int data_len               :16;    //  data length for standard size packet buffer
+};
+
+struct tx_qos_cfg {
+    unsigned int time_tick              :16;    //  number of PP32 cycles per basic time tick
+    unsigned int overhd_bytes           :8;     //  number of overhead bytes per packet in rate shaping
+    unsigned int eth1_eg_qnum           :4;     //  number of egress QoS queues (< 8);
+    unsigned int eth1_burst_chk         :1;     //  always 1, more accurate WFQ
+    unsigned int eth1_qss               :1;     //  1: FW QoS, 0: HW QoS
+    unsigned int shape_en               :1;     //  1: enable rate shaping, 0: disable
+    unsigned int wfq_en                 :1;     //  1: WFQ enabled, 0: strict priority enabled
+};
+
+struct eg_bwctrl_cfg {
+    unsigned int fdesc_wm               :16;    //  if free descriptors in QoS/Swap channel is less than this watermark, large size packets are discarded
+    unsigned int class_len              :16;    //  if packet length is not less than this value, the packet is recognized as large packet
+};
+
+struct test_mode {
+    unsigned int res1           :30;
+    unsigned int mib_clear_mode :1;     //  1: MIB counter is cleared with TPS-TC software reset, 0: MIB counter not cleared
+    unsigned int test_mode      :1;     //  1: test mode, 0: normal mode
+};
+
+struct rx_bc_cfg {
+    unsigned int res1           :14;
+    unsigned int local_state    :2;     //  0: local receiver is "Looking", 1: local receiver is "Freewheel Sync False", 2: local receiver is "Synced", 3: local receiver is "Freewheel Sync Truee"
+    unsigned int res2           :15;
+    unsigned int remote_state   :1;     //  0: remote receiver is "Out-of-Sync", 1: remote receiver is "Synced"
+
+    unsigned int to_false_th    :16;    //  the number of consecutive "Miss Sync" for leaving "Freewheel Sync False" to "Looking" (default 3)
+    unsigned int to_looking_th  :16;    //  the number of consecutive "Miss Sync" for leaving "Freewheel Sync True" to "Freewheel Sync False" (default 7)
+    /*
+     *  firmware use only (total 30 dwords)
+     */
+    unsigned int rx_cw_rdptr;
+    unsigned int cw_cnt;
+    unsigned int missed_sync_cnt;
+    unsigned int bitmap_last_cw[3];         //  Bitmap of the Last Codeword
+    unsigned int bitmap_second_last_cw[3];  //  Bitmap of the Second Last Codeword
+    unsigned int bitmap_third_last_cw[3];   //  Bitmap of the Third Last Codeword
+    unsigned int looking_cw_cnt;
+    unsigned int looking_cw_th;
+    unsigned int byte_shift_cnt;
+    unsigned int byte_shift_val;
+    unsigned int res_word1[14];
+};
+
+struct rx_gamma_itf_cfg {
+    unsigned int res1           :31;
+    unsigned int receive_state  :1;     //  0: "Out-of-Fragment", 1: "In-Fragment"
+    unsigned int res2           :16;
+    unsigned int rx_min_len     :8;     //  min length of packet, padding if packet length is smaller than this value
+    unsigned int rx_pad_en      :1;     //  0:  padding disabled, 1: padding enabled
+    unsigned int res3           :2;
+    unsigned int rx_eth_fcs_ver_dis :1; //  0: ETH FCS verification is enabled, 1: disabled
+    unsigned int rx_rm_eth_fcs      :1; //  0: ETH FCS field is not removed, 1: ETH FCS field is removed
+    unsigned int rx_tc_crc_ver_dis  :1; //  0: TC CRC verification enabled, 1: disabled
+    unsigned int rx_tc_crc_size     :2; //  0: 0-bit, 1: 16-bit, 2: 32-bit
+    unsigned int rx_eth_fcs_result;     //  if the ETH FCS result matches this magic number, then the packet is valid packet
+    unsigned int rx_tc_crc_result;      //  if the TC CRC result matches this magic number, then the packet is valid packet
+    unsigned int rx_crc_cfg     :16;    //  TC CRC config, please check the description of SAR context data structure in the hardware spec
+    unsigned int res4           :16;
+    unsigned int rx_eth_fcs_init_value; //  ETH FCS initialization value
+    unsigned int rx_tc_crc_init_value;  //  TC CRC initialization value
+    unsigned int res_word1;
+    unsigned int rx_max_len_sel :1;     //  0: normal, the max length is given by MAX_LEN_NORMAL, 1: fragment, the max length is given by MAX_LEN_FRAG
+    unsigned int res5           :2;
+    unsigned int rx_edit_num2   :4;     //  number of bytes to be inserted/removed
+    unsigned int rx_edit_pos2   :7;     //  first byte position to be edited
+    unsigned int rx_edit_type2  :1;     //  0: remove, 1: insert
+    unsigned int rx_edit_en2    :1;     //  0: disable insertion or removal of data, 1: enable
+    unsigned int res6           :3;
+    unsigned int rx_edit_num1   :4;     //  number of bytes to be inserted/removed
+    unsigned int rx_edit_pos1   :7;     //  first byte position to be edited
+    unsigned int rx_edit_type1  :1;     //  0: remove, 1: insert
+    unsigned int rx_edit_en1    :1;     //  0: disable insertion or removal of data, 1: enable
+    unsigned int res_word2[2];
+    unsigned int rx_inserted_bytes_1l;
+    unsigned int rx_inserted_bytes_1h;
+    unsigned int rx_inserted_bytes_2l;
+    unsigned int rx_inserted_bytes_2h;
+    int rx_len_adj;                     //  the packet length adjustment, it is sign integer
+    unsigned int res_word3[16];
+};
+
+struct tx_bc_cfg {
+    unsigned int fill_wm        :16;    //  default 2
+    unsigned int uflw_wm        :16;    //  default 2
+    /*
+     *  firmware use only (total 31 dwords)
+     */
+    //  Reserved
+    unsigned int res0;
+    //  FW Internal Use
+    unsigned int holding_pages;
+    unsigned int ready_pages;
+    unsigned int pending_pages;
+    unsigned int cw_wrptr;              // TX codeword write pointer for e
+    unsigned int res_word[26];
+};
+
+struct tx_gamma_itf_cfg {
+    unsigned int res_word1;
+    unsigned int res1           :8;
+    unsigned int tx_len_adj     :4;     //  4 * (not TX_ETH_FCS_GEN_DIS) + TX_TC_CRC_SIZE
+    unsigned int tx_crc_off_adj :4;     //  4 + TX_TC_CRC_SIZE
+    unsigned int tx_min_len     :8;     //  min length of packet, if length is less than this value, packet is padded
+    unsigned int res2           :3;
+    unsigned int tx_eth_fcs_gen_dis :1; //  0: ETH FCS generation enabled, 1: disabled
+    unsigned int res3           :2;
+    unsigned int tx_tc_crc_size :2;     //  0: 0-bit, 1: 16-bit, 2: 32-bit
+    unsigned int res4           :24;
+    unsigned int queue_mapping  :8;     //  TX queue attached to this Gamma interface
+    unsigned int res_word2;
+    unsigned int tx_crc_cfg     :16;    //  TC CRC config, please check the description of SAR context data structure in the hardware spec
+    unsigned int res5           :16;
+    unsigned int tx_eth_fcs_init_value; //  ETH FCS initialization value
+    unsigned int tx_tc_crc_init_value;  //  TC CRC initialization value
+    unsigned int res_word3[9];
+    /*
+     *  firmware use only (total 25 dwords)
+     */
+    //  FW Internal Use
+    unsigned int curr_qid;
+    unsigned int fill_pkt_state;
+    unsigned int post_pkt_state;
+    unsigned int curr_pdma_context_ptr;
+    unsigned int curr_sar_context_ptr;
+    unsigned int des_addr;
+    unsigned int des_qid;
+    unsigned int rem_data;
+    unsigned int rem_crc;
+    //  bonding fields
+    unsigned int rem_fh_len;
+    unsigned int des_dw0;
+    unsigned int des_dw1;
+    unsigned int des_bp_dw;
+
+    //MIB field
+    unsigned int tx_pkt_cnt;
+    unsigned int tx_byte_cnt;
+    //  Reserved
+    unsigned int res_word4;
+};
+
+struct gpio_mode {
+    unsigned int res1           :3;
+    unsigned int gpio_bit_bc1   :5;
+    unsigned int res2           :3;
+    unsigned int gpio_bit_bc0   :5;
+
+    unsigned int res3           :7;
+    unsigned int gpio_bc1_en    :1;
+
+    unsigned int res4           :7;
+    unsigned int gpio_bc0_en    :1;
+};
+
+struct gpio_wm_cfg {
+    unsigned int stop_wm_bc1    :8;
+    unsigned int start_wm_bc1   :8;
+    unsigned int stop_wm_bc0    :8;
+    unsigned int start_wm_bc0   :8;
+};
+
+struct wtx_qos_q_desc_cfg {
+    unsigned int    threshold           :8;
+    unsigned int    length              :8;
+    unsigned int    addr                :16;
+    unsigned int    rd_ptr              :16;
+    unsigned int    wr_ptr              :16;
+};
+
+struct wan_rx_mib_table {
+    unsigned int    res1[2];
+    unsigned int    wrx_dropdes_pdu;
+    unsigned int    wrx_total_bytes;
+    unsigned int    res2[4];
+    //  wrx_total_pdu is implemented with hardware counter (not used by PTM TC)
+    //  check register "TC_RX_MIB_CMD"
+    //  "HEC_INC" used to increase preemption Gamma interface (wrx_total_pdu)
+    //  "AIIDLE_INC" used to increase normal Gamma interface (wrx_total_pdu)
+};
+
+struct SFSM_cfg {
+    unsigned int    res                 :14;
+    unsigned int    rlsync              :1;
+    unsigned int    endian              :1;
+    unsigned int    idlekeep            :1;
+    unsigned int    sen                 :1;
+    unsigned int    res1                :6;
+    unsigned int    pnum                :8;
+};
+
+struct PTM_CW_CTRL {
+    unsigned int    state               :1;
+    unsigned int    bad                 :1;
+    unsigned int    ber                 :9;
+    unsigned int    spos                :7;
+    unsigned int    ffbn                :7;
+    unsigned int    shrt                :1;
+    unsigned int    preempt             :1;
+    unsigned int    cwer                :2;
+    unsigned int    cwid                :3;
+};
+
+struct SFSM_dba {
+    unsigned int    res                 :17;
+    unsigned int    dbase               :15;
+};
+
+struct SFSM_cba {
+    unsigned int    res                 :15;
+    unsigned int    cbase               :17;
+};
+
+struct FFSM_dba {
+    unsigned int    res                 :17;
+    unsigned int    dbase               :15;
+};
+
+struct FFSM_cfg  {
+    unsigned int    res                 :12;
+    unsigned int    rstptr              :1;
+    unsigned int    clvpage             :1;
+    unsigned int    fidle               :1;
+    unsigned int    endian              :1;
+    unsigned int    res1                :8;
+    unsigned int    pnum                :8;
+};
+
+
+
+
+
+#endif  //  __TC_DS__H__
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_proc.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_proc.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_proc.h
@@ -0,0 +1,21 @@
+
+extern int vrx318_atm_proc_init(void *);
+extern int vrx318_ptm_proc_init(void *);
+extern void vrx318_atm_proc_exit(void *);
+extern void vrx318_ptm_proc_exit(void *);
+extern int vrx318_proc_init(struct vrx318_priv *);
+extern void vrx318_proc_exit(struct vrx318_priv *);
+extern int proc_read_ptm_wanmib(struct seq_file *, void *);
+extern ssize_t proc_write_ptm_wanmib(struct file *, const char __user *,
+		size_t , loff_t *);
+extern int proc_read_atm_wanmib(struct seq_file *, void *);
+extern ssize_t proc_write_atm_wanmib(struct file *, const char __user *,
+		size_t, loff_t *);
+
+#define set_vrx_dbg_flag(v, e, f) do {	\
+	if (e > 0)			\
+		v |= (uint32_t)(f);	\
+	else				\
+		v &= (uint32_t) (~f); }	\
+	while (0)
+
diff --git a/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ptm_tc.h b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ptm_tc.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/include/vrx318_ptm_tc.h
@@ -0,0 +1,75 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * Copyright (C) 2015 Zhu YiXin<yixin.zhu@lantiq.com>
+ */
+
+#ifndef __VRX318_PTM_TC_H__
+#define __VRX318_PTM_TC_H__
+
+#define DS_FRAG_DES_LIST1_LEN		32
+#define DS_FRAG_DES_LIST1_LEN_MAX	48
+#define DS_FRAG_DES_LIST2_LEN		32
+#define DS_FRAG_DES_LIST2_LEN_MAX	48
+#define DS_BOND_GIF_LL_DES_LEN		256
+#define BOND_SOC_SYNC_US_BUF_SIZE	(512 * 4) /* 512 DWORDS */
+#define BOND_SOC_SYNC_DS_BUF_SIZE	(256 * 4) /* 256 DWORDS */
+
+#define OUTQ_NUM		64
+#define MAX_FRAGQ_NUM		8
+
+#define QOSQ_ID_MASK		((QOSQ_NUM - 1) | ((QOSQ_NUM - 1) >> 1) | \
+				((QOSQ_NUM - 1) >> 2) | ((QOSQ_NUM - 1) >> 3))
+#define QOSQ_PORT_SSID		16 /* PORT SHAPER STARD ID */
+#define QOSQ_L3_SHAPER_ID	20 /* All the outqss share one L3 shaper */
+
+#define US_FASTPATH_DES_OWN	0
+#define US_CPUPATH_DES_OWN	1
+#define US_OUTQ_DES_OWN		0
+#define US_FRAGQ_DES_OWN	1
+#define US_LOCALQ_DES_OWN	1
+#define DS_FRAGQ_DES_OWN	0
+#define DS_PKT_DES_OWN		0
+
+#define PTM_PRIO_Q_NUM		8
+#define PTM_DESC_QID(qid) (((qid) & 0xF) << 3)
+
+struct vrx318_priv;
+struct vrx318_ptm_bnd {
+	dma_addr_t soc_peer_phybase; /* required if p2p disable */
+	unsigned long soc_peer_membase;
+};
+
+struct vrx318_ptm_hw_mib {
+	unsigned int rx_total_pdu[4];
+	unsigned int rx_crc_err_pdu[4];
+	unsigned int rx_cv_cw_cnt[4];
+	unsigned int rx_bc_overdrop_cnt[2];
+	unsigned int tx_total_pdu[4];
+	unsigned int tx_total_bytes[4];
+};
+
+struct vrx318_ptm_tc {
+	struct vrx318_priv *frwk;
+	int ep_id;
+	enum dsl_tc_mode tc_mode;
+	struct vrx318_ptm_bnd ptm_bnd_cfg;
+	struct fw_ver_id fw_ver[MAX_VRX318_NUM][2];
+	struct proc_dir_entry *proc_dir;
+	struct net_device *dev;
+	dp_cb_t	ptm_cb;
+	spinlock_t ptm_lock;
+	struct net_device_stats stats;
+	struct vrx318_ptm_hw_mib ptm_mib[MAX_VRX318_NUM];
+	int subif_id;
+	int ptm_prio_queue_map[PTM_PRIO_Q_NUM];
+	struct completion comp;
+};
+
+extern int ptm_in_showtime(void);
+extern int ptm_power_saving(struct vrx318_ptm_tc *, int, int);
+
+#endif /* __VRX318_PTM_TC_H__ */
+
diff --git a/drivers/net/ethernet/lantiq/vrx318/vrx318.c b/drivers/net/ethernet/lantiq/vrx318/vrx318.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/vrx318.c
@@ -0,0 +1,636 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * Copyright (C) 2015 Zhu YiXin<yixin.zhu@lantiq.com>
+ * HISTORY
+ * $Date		$Author		$Version	$Comment
+ * 01/02/2015	Zhu YiXin		1.0.0	Basic PTM datapath & TC driver
+ * 13/02/2015	Zhu YiXin		1.0.1
+ *		1. FW(Ver: 03.02.01)  add supporting unaligned data address
+ *		2. Driver support built as module
+ * 06/03/2015	Zhu YiXin		1.0.2
+ *		1. Driver fix smp_proccess_id()
+ *		called in Preemption enabled state.
+ *		2. FW(Ver: 03.02.02) Fixed isse: data corruption in ARP packet
+ * 06/03/2015	Zhu YiXin		1.0.3
+ *		1. Fix PTM driver enabled unnecessary per-packet interrupt.
+ * 29/04/2015      Zhu YiXin		2.0.0
+ *		1. Unified ATM/PTM driver. Support switch ATM/PTM/Bonding
+ *		TC layer without unload/load the driver module.
+ * 29/04/2015      Eswaran Rekha	2.0.1
+ *		1. Add Dedicated proc file to manage all the proc function for
+ *		framework/ATM/PTM/Bonding
+ *		2. Improve proc write function by using standard parse function
+ *		from Datapath libarary.
+ * 25/05/2015      Eswaran Rekha	2.0.2
+ *		1. Add TC Status Genetlink Notification feature
+ * 26/10/2015      Ho Nghia Duc		2.0.4
+ *		1. CoC Support
+ */
+
+#define DEBUG
+#include <linux/ctype.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/seq_file.h>
+#include <linux/printk.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <net/datapath_api.h>
+#include <net/lantiq_cbm.h>
+#include <net/lantiq_cbm_api.h>
+#include <net/ppa_stack_al.h>
+
+#include <lantiq.h>
+#include <lantiq_soc.h>
+#include <lantiq_irq.h>
+#include <lantiq_pcie.h>
+#include <lantiq_ptm.h>
+
+#include "include/vrx318_fw_prereq.h"
+#include "include/vrx318_common.h"
+#include "include/vrx318_framework.h"
+#include "include/vrx318_proc.h"
+#include "include/vrx318_api.h"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Yixin.zhu@lantiq.com");
+MODULE_DESCRIPTION("LTQ CPE SmartPHY PCIe EP ATM/PTM driver");
+MODULE_SUPPORTED_DEVICE("LTQ CPE SmartPHY PCIe EP for Devices GRX35X, GRX5XX");
+
+#define DRV_MODULE_NAME	"VRX318_DRIVER"
+#define DRV_MODULE_VERSION "2.0.4"
+static int queue_gamma_map[4] = {0x00FF, 0x0000, 0x0000, 0x0000};
+static int p2p_en;
+static int loopback_en;
+static int atm_qos;
+static int oam_prio;
+static int qsb_tau = 1;	/*  QSB cell delay variation due to concurrency */
+static int qsb_srvm = 0x0F; /*  QSB scheduler burst length */
+static int qsb_tstep = 4; /*  QSB time step, all legal values are 1, 2, 4 */
+static int aal5r_max_pktsz = 0x0686; /*  Max frame size for RX */
+static int aal5r_min_pktsz = 0x0000; /*  Min frame size for RX */
+static int aal5s_max_pktsz = 0x0686; /*  Max frame size for TX */
+
+module_param_array(queue_gamma_map, int, NULL, 0444);
+MODULE_PARM_DESC(queue_gamma_map, "TX QoS queues mapping to 4 TX Gamma interfaces.");
+module_param(oam_prio, int, 0444);
+MODULE_PARM_DESC(oam_prio, "OAM Priority (0 to max queue number id (7/15)).");
+module_param(atm_qos, int, 0444);
+MODULE_PARM_DESC(atm_qos, "ATM QoS Enable/Disable. if Enable, only support up to 8 PVCs.");
+module_param(p2p_en, int, 0444);
+MODULE_PARM_DESC(p2p_en, "PTM Bonding directly access Peer Enable flag.");
+module_param(loopback_en, int, 0444);
+MODULE_PARM_DESC(loopback_en, "Enable-1/Disable-0 the DFE loopback mode.");
+module_param(qsb_tau, int, 0444);
+MODULE_PARM_DESC(qsb_tau, "Cell delay variation. Value must be > 0");
+module_param(qsb_srvm, int, 0444);
+MODULE_PARM_DESC(qsb_srvm, "Maximum burst size.");
+module_param(qsb_tstep, int, 0444);
+MODULE_PARM_DESC(qsb_tstep, "n*32 cycles per sbs cycles n=1,2,4");
+module_param(aal5r_max_pktsz, int, 0444);
+MODULE_PARM_DESC(aal5r_max_pktsz, "Max packet size in byte for downstream AAL5 frames");
+module_param(aal5r_min_pktsz, int, 0444);
+MODULE_PARM_DESC(aal5r_min_pktsz, "Min packet size in byte for downstream AAL5 frames");
+module_param(aal5s_max_pktsz, int, 0444);
+MODULE_PARM_DESC(aal5s_max_pktsz, "Max packet size in byte for upstream AAL5 frames");
+
+static struct vrx318_priv *g_vrx318_priv;
+u32 g_vrx318_dbg = VRX318_DEF_MSG_EN;
+
+static dp_rx_fn_t vrx318_rx_fn;
+static dp_stop_tx_fn_t vrx318_stop_fn;
+static dp_restart_tx_fn_t vrx318_restart_fn;
+static dp_get_netif_subifid_fn_t vrx318_get_subifid_fn;
+static dp_coc_confirm_stat vrx318_coc_confirm_stat_fn;
+#ifndef MODULE
+
+#define MAX_OPT_NUM 1
+static int __init vrx318_opt_setup(char *line)
+{
+	int ints[MAX_OPT_NUM];
+
+	line = get_options(line, MAX_OPT_NUM, ints);
+
+	if (ints[0] >= 1)
+		loopback_en = ints[0];
+
+	return 0;
+}
+
+__setup("vrx318_opt=", vrx318_opt_setup);
+#endif
+
+void get_vrx318_drv_ver(char **name, char **ver)
+{
+	*name = DRV_MODULE_NAME;
+	*ver = DRV_MODULE_VERSION;
+}
+
+void vrx318_cb_setup(void *rx_fn, void *stop_fn,
+	void *restart_fn, void *get_subifid_fn
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+	, void *coc_confirm_stat_fn
+#endif
+	)
+{
+	vrx318_rx_fn = rx_fn;
+	vrx318_stop_fn = stop_fn;
+	vrx318_restart_fn = restart_fn;
+	vrx318_get_subifid_fn = get_subifid_fn;
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+	vrx318_coc_confirm_stat_fn = coc_confirm_stat_fn;
+#endif
+}
+
+static int pcie_ep_probe(struct vrx318_priv *pcie_ep)
+{
+	int dev_num;
+	int i;
+
+	if (ifx_pcie_ep_dev_num_get(&dev_num)) {
+		vrx318_dbg(DBG_ERR, "Failed to get total PCIe device number\n");
+		return -EIO;
+	}
+
+	for (i = 0; i < dev_num && i < MAX_VRX318_NUM; i++) {
+		if (ifx_pcie_ep_dev_info_req(i,
+			IFX_PCIE_EP_INT_PPE, &pcie_ep->ep_dev[i])) {
+			vrx318_dbg(DBG_ERR, "%s failed to get pcie ep %d information\n",
+				__func__, i);
+			continue;
+		}
+	}
+	vrx318_dbg(DBG_INIT, "Probe VRX318 total num: %d\n", i);
+	pcie_ep->ep_num = i;
+
+	if (!pcie_ep->ep_num)
+		return -EIO;
+
+	return 0;
+}
+
+static void pcie_ep_release(struct vrx318_priv *pcie_ep)
+{
+	int i;
+
+	for (i = 0; i < pcie_ep->ep_num; i++)
+		ifx_pcie_ep_dev_info_release(i);
+}
+
+static int init_local_variables(struct vrx318_priv *priv)
+{
+	struct vrx318_param *cfg;
+	int i;
+
+	priv->owner = THIS_MODULE;
+	if (!priv->owner) {
+		priv->owner = kmalloc(sizeof(*priv->owner), GFP_KERNEL);
+		if (!priv->owner) {
+			vrx318_dbg(DBG_ERR, "Failed to alloc buffer for module structure\n");
+			return -ENOMEM;
+		}
+		sprintf(priv->owner->name, DRV_MODULE_NAME);
+	}
+
+	cfg = &priv->param;
+	cfg->dfe_loopback = loopback_en;
+	cfg->lle_in_sb = LLE_IN_PDBRAM ? 0 : 1;
+	cfg->p2p_en = p2p_en;
+	cfg->atm_qos = atm_qos;
+	if (oam_prio < 0 || oam_prio >= max_pvc_num(atm_qos))
+		cfg->oam_prio = 0;
+	else
+		cfg->oam_prio = oam_prio;
+
+	priv->pdev = priv->ep_dev[0].dev;
+	vrx318_cb_setup(NULL, NULL, NULL, NULL
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+	, NULL
+#endif
+	);
+
+	if (IS_ENABLED(CONFIG_USE_EMULATOR))
+		priv->param.dfe_loopback = 1;
+
+	if (cfg->dfe_loopback)
+		vrx318_dbg(DBG_INIT, "DFE LOOPBACK Enabled\n");
+
+	priv->tc_stat = VRX318_INIT;
+	priv->hw_type = HW_TYPE_VRX318;
+
+	for (i = 0; i < MAX_VRX318_NUM; i++)
+		priv->tc_mode[i] = TC_NONE_MODE;
+
+	vrx318_atm_param_setup(priv, qsb_tau, qsb_srvm, qsb_tstep,
+		aal5r_max_pktsz, aal5r_min_pktsz, aal5s_max_pktsz);
+
+	vrx318_ptm_param_setup(priv, queue_gamma_map);
+
+	init_dsl_callback();
+
+	spin_lock_init(&priv->fw_lock);
+
+	return 0;
+}
+
+static int32_t vrx318_stop(struct net_device *dev)
+{
+	struct vrx318_priv *priv = g_vrx318_priv;
+	int ret = -ENODEV;
+
+	spin_lock_bh(&priv->fw_lock);
+	if (priv->tc_stat != VRX318_RUNNING) {
+		spin_unlock_bh(&priv->fw_lock);
+		return ret;
+	}
+
+	if (vrx318_stop_fn != NULL)
+		ret = vrx318_stop_fn(dev);
+
+	spin_unlock_bh(&priv->fw_lock);
+
+	return ret;
+}
+
+static int32_t vrx318_restart(struct net_device *dev)
+{
+	struct vrx318_priv *priv = g_vrx318_priv;
+	int ret = -ENODEV;
+
+	spin_lock_bh(&priv->fw_lock);
+	if (priv->tc_stat != VRX318_RUNNING) {
+		spin_unlock_bh(&priv->fw_lock);
+		return ret;
+	}
+
+	if (vrx318_restart_fn != NULL)
+		ret = vrx318_restart_fn(dev);
+
+	spin_unlock_bh(&priv->fw_lock);
+
+	return ret;
+}
+
+static int32_t vrx318_rx(struct net_device *rxif, struct net_device *txif,
+		struct sk_buff *skb, int32_t len)
+{
+	struct vrx318_priv *priv = g_vrx318_priv;
+	int ret = -ENODEV;
+
+	spin_lock_bh(&priv->fw_lock);
+	if (priv->tc_stat != VRX318_RUNNING) {
+		spin_unlock_bh(&priv->fw_lock);
+		dev_kfree_skb_any(skb);
+		return ret;
+	}
+
+	if (vrx318_rx_fn != NULL) {
+		ret = vrx318_rx_fn(rxif, txif, skb, len);
+	} else {
+		vrx318_dbg(DBG_ERR, "TC Status Running but no rx function\n");
+		dev_kfree_skb_any(skb);
+	}
+	spin_unlock_bh(&priv->fw_lock);
+
+	return ret;
+}
+
+static int32_t vrx318_get_subifid(struct net_device *netif, struct sk_buff *skb,
+			void *vcc, uint8_t dst_mac[MAX_ETH_ALEN],
+			dp_subif_t *subif, uint32_t flags)
+{
+	struct vrx318_priv *priv = g_vrx318_priv;
+	int ret = -ENODEV;
+
+	spin_lock_bh(&priv->fw_lock);
+	if (priv->tc_stat != VRX318_RUNNING) {
+		spin_unlock_bh(&priv->fw_lock);
+		dev_kfree_skb_any(skb);
+		return ret;
+	}
+
+	if (vrx318_get_subifid_fn != NULL)
+		ret = vrx318_get_subifid_fn(netif, skb, vcc,
+				dst_mac, subif, flags);
+
+	spin_unlock_bh(&priv->fw_lock);
+
+	return ret;
+}
+
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+static int32_t vrx318_coc_confirm_stat(enum ltq_cpufreq_state new_state,
+	enum ltq_cpufreq_state old_state,
+	uint32_t flags)
+{
+	struct vrx318_priv *priv = g_vrx318_priv;
+	int ret = -ENODEV;
+	vrx318_dbg(DBG_COC, "%s: Start\n", __func__);
+	vrx318_dbg(DBG_COC, "Change from old [%u] to [%u]\n", (u32)old_state, (u32)new_state);
+	spin_lock_bh(&priv->fw_lock);
+	if (priv->tc_stat != VRX318_RUNNING) {
+		spin_unlock_bh(&priv->fw_lock);
+		vrx318_dbg(DBG_COC, "VRX 318 is not RUNNING[%d]\n", priv->tc_stat);
+		return ret;
+	}
+
+	if (vrx318_coc_confirm_stat_fn != NULL)
+		ret = vrx318_coc_confirm_stat_fn(new_state, old_state, flags);
+	else
+		vrx318_dbg(DBG_COC, "There is no callback for COC\n");
+
+	spin_unlock_bh(&priv->fw_lock);
+	vrx318_dbg(DBG_COC, "%s: Finish\n", __func__);
+	return ret;
+}
+
+#endif
+int vrx318_unload_tc(struct vrx318_priv *priv, int ep_id)
+{
+	int err = 0;
+
+	/* Unload Callback function in Framework */
+	vrx318_cb_setup(NULL, NULL, NULL, NULL
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+	, NULL
+#endif
+	);
+
+	if (priv->tc_mode[ep_id] == TC_ATM_SL_MODE)
+		err = vrx318_unload_atm_tc(priv, ep_id);
+	else if (priv->tc_mode[ep_id] == TC_PTM_SL_MODE ||
+			priv->tc_mode[ep_id] == TC_PTM_BND_MODE)
+		err = vrx318_unload_ptm_tc(priv, ep_id, priv->tc_mode[ep_id]);
+
+	if (err)
+		return err;
+	priv->tc_priv = NULL;
+	vrx318_dbg(DBG_TC_SWITCH, "vrx318 tc unload successfully\n");
+
+	return err;
+}
+
+int vrx318_load_tc(struct vrx318_priv *priv, int ep_id,
+			enum dsl_tc_mode tc_mode)
+{
+	if (ep_id >= priv->ep_num)
+		return -EINVAL;
+
+	switch (tc_mode) {
+	case TC_ATM_SL_MODE:
+		return vrx318_atm_tc_init(priv, ep_id, tc_mode);
+	case TC_PTM_SL_MODE:
+	case TC_PTM_BND_MODE:
+		return vrx318_ptm_tc_init(priv, ep_id, tc_mode);
+	case TC_NONE_MODE:
+		return 0;
+	default:
+		return -ENOPROTOOPT;
+	}
+}
+
+/**
+ * TC swtich condition
+ * 1. Current TC is not same as request TC
+ * 2. Peer TC is not UP unless Peer TC and request TC both is PTM bonding.
+ */
+static int vrx318_tc_switch(struct vrx318_priv *priv, u32 ep_id,
+				enum dsl_tc_mode tc_mode)
+{
+	u32 peer_id;
+	int err = 0;
+
+	peer_id = ((MAX_VRX318_NUM - 1) - ep_id);
+
+	spin_lock_bh(&priv->fw_lock);
+
+	if (priv->tc_stat != VRX318_RUNNING
+			&& priv->tc_stat != VRX318_NO_TC) {
+		err = -EAGAIN;
+		vrx318_dbg(DBG_TC_SWITCH, "tc stat: %d\n", (u32)priv->tc_stat);
+		goto TCSW_CHECK_FAIL;
+	}
+
+	if (tc_mode == TC_PTM_BND_MODE && priv->ep_num < 2) {
+		err = -EINVAL;
+		vrx318_dbg(DBG_TC_SWITCH, "request bonding but only %d dev detected\n",
+			priv->ep_num);
+		goto TCSW_CHECK_FAIL;
+	}
+
+	if (priv->tc_mode[ep_id] == tc_mode) {
+		vrx318_dbg(DBG_TC_SWITCH, "TC switch request on same TC\n");
+		err = 0;
+		goto TCSW_CHECK_FAIL;
+	}
+
+	priv->tc_stat = VRX318_SWITCHING;
+	spin_unlock_bh(&priv->fw_lock);
+
+	/* Unload TC */
+	if (priv->tc_mode[ep_id] != TC_NONE_MODE) {
+		err = vrx318_unload_tc(priv, ep_id);
+		if (err)
+			return err;
+		if (priv->tc_mode[ep_id] == TC_PTM_BND_MODE)
+			priv->tc_mode[peer_id] = TC_NONE_MODE;
+		priv->tc_mode[ep_id] = TC_NONE_MODE;
+	}
+
+	/* Load requested TC */
+	err = vrx318_load_tc(priv, ep_id, tc_mode);
+	if (err)
+		return err;
+	if (priv->tc_mode[ep_id] == TC_PTM_BND_MODE)
+		priv->tc_mode[peer_id] = tc_mode;
+	priv->tc_mode[ep_id] = tc_mode;
+
+	spin_lock_bh(&priv->fw_lock);
+	priv->tc_stat = VRX318_RUNNING;
+	spin_unlock_bh(&priv->fw_lock);
+
+	return err;
+
+TCSW_CHECK_FAIL:
+	spin_unlock_bh(&priv->fw_lock);
+	return err;
+
+}
+
+/**
+ * API defintion for the DSL MEI driver to call to do TC switch
+ * line_no: the DSL line number
+ * tc_type: TC mode to be loaded. ATM TC/PTM TC
+ * is_bondng:  Bonding mode: 0- No, 1-Yes.
+ */
+static int dsl_req_tc_switch(const unsigned char line_no,
+		mei_tc_request_type tc_type,
+		int is_bonding)
+{
+	struct vrx318_priv *priv = g_vrx318_priv;
+	enum dsl_tc_mode tc_mode;
+
+	vrx318_dbg(DBG_TC_SWITCH, "%s, line_no: %d, tc_type: %d, is_bonding: %d\n",
+		__func__, line_no, tc_type, is_bonding);
+
+	if (!priv || line_no >= priv->ep_num || tc_type >= MEI_TC_REQUEST_LAST)
+		return -EINVAL;
+
+	switch (tc_type) {
+	case MEI_TC_REQUEST_OFF:
+		tc_mode = TC_NONE_MODE;
+		break;
+	case MEI_TC_REQUEST_ATM:
+		tc_mode = TC_ATM_SL_MODE;
+		break;
+	case MEI_TC_REQUEST_PTM:
+		if (is_bonding)
+			tc_mode = TC_PTM_BND_MODE;
+		else
+			tc_mode = TC_PTM_SL_MODE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return vrx318_tc_switch(priv, line_no, tc_mode);
+}
+
+static void print_ver(const char *name, const char *ver)
+{
+	vrx318_dbg(DBG_INFO, "%s version: %s\n", name, ver);
+}
+
+static int __init vrx318_drv_init(void)
+{
+	struct vrx318_priv *priv;
+	int err;
+	int dp_id;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		vrx318_dbg(DBG_ERR, "Failed to alloc priv buffer\n");
+		err = -ENOMEM;
+		goto err1;
+	}
+
+	err = pcie_ep_probe(priv);
+	if (err)
+		goto err1;
+
+	err = vrx318_soc_cfg_get(priv);
+	if (err)
+		goto err2;
+
+	err = init_local_variables(priv);
+	if (err)
+		goto err2;
+
+	dp_id  = dp_alloc_port(priv->owner, NULL, 0, 0, NULL, DP_F_FAST_DSL);
+	if (dp_id == DP_FAILURE) {
+		vrx318_dbg(DBG_ERR, "%s: dp_alloc_port fail!\n", __func__);
+		err = -ENODEV;
+		goto err2;
+	}
+	priv->port_id		= dp_id;
+	priv->cb.stop_fn	= vrx318_stop;
+	priv->cb.restart_fn	= vrx318_restart;
+	priv->cb.rx_fn		= vrx318_rx;
+	priv->cb.get_subifid_fn = vrx318_get_subifid;
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+	priv->cb.dp_coc_confirm_stat_fn = vrx318_coc_confirm_stat;
+#endif
+	if (dp_register_dev(priv->owner, dp_id, &priv->cb, 0) != DP_SUCCESS) {
+		vrx318_dbg(DBG_ERR, "%s:dp_register_dev failed for port id %d",
+			__func__, dp_id);
+		err = -ENODEV;
+		goto err3;
+	}
+	vrx318_dbg(DBG_INFO, "DP register VRX318 successfully, dp_id: %d\n",
+		dp_id);
+
+	print_ver(DRV_MODULE_NAME, DRV_MODULE_VERSION);
+	vrx318_dbg(DBG_INFO, "Total %d device are detected\n", priv->ep_num);
+
+	priv->tc_stat = VRX318_NO_TC;
+	g_vrx318_priv = priv;
+	vrx318_proc_init(priv);
+	vrx318_genetlink_init();
+
+	ppa_callback_set(LTQ_MEI_TC_REQUEST, dsl_req_tc_switch);
+
+	return 0;
+
+err3:
+	dp_alloc_port(priv->owner, NULL, 0, dp_id, NULL, DP_F_DEREGISTER);
+err2:
+	pcie_ep_release(priv);
+err1:
+	kfree(priv);
+	return err;
+}
+
+/* Warn: module unload should not happen during TC_switch */
+static void __exit vrx318_drv_exit(void)
+{
+	struct vrx318_priv *priv = g_vrx318_priv;
+	int i, ret;
+
+	spin_lock_bh(&priv->fw_lock);
+	if (priv->tc_stat == VRX318_INIT ||
+		priv->tc_stat == VRX318_SWITCHING)
+		goto err;
+	priv->tc_stat = VRX318_EXIT;
+	g_vrx318_priv = NULL;
+	spin_unlock_bh(&priv->fw_lock);
+
+	for (i = 0; i < priv->ep_num; i++) {
+		if (priv->tc_mode[i] != TC_NONE_MODE) {
+			vrx318_unload_tc(priv, i);
+			break;
+		}
+	}
+
+	vrx318_atm_exit();
+	vrx318_ptm_exit();
+
+	ret = dp_register_dev(priv->owner, priv->port_id,
+			NULL, DP_F_DEREGISTER);
+	if (ret)
+		vrx318_dbg(DBG_ERR,
+			"Unregister VRX318 dp dev error: %d\n", ret);
+	ret = dp_alloc_port(priv->owner, NULL, 0,
+			priv->port_id, NULL, DP_F_DEREGISTER);
+	if (ret)
+		vrx318_dbg(DBG_ERR, "Free VRX318 dp port err: %d\n", ret);
+
+	vrx318_proc_exit(priv);
+	kfree(priv);
+	vrx318_genetlink_exit();
+	vrx318_dbg(DBG_INFO, "VRX318 MODULE Unloaded!\n");
+
+	return;
+err:
+	spin_unlock_bh(&priv->fw_lock);
+	vrx318_dbg(DBG_ERR, "Exiting while tc mode: %d\n", (u32)priv->tc_mode);
+	return;
+}
+
+module_init(vrx318_drv_init);
+module_exit(vrx318_drv_exit);
+
diff --git a/drivers/net/ethernet/lantiq/vrx318/vrx318_api.c b/drivers/net/ethernet/lantiq/vrx318/vrx318_api.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/vrx318_api.c
@@ -0,0 +1,619 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * Copyright (C) 2015 Zhu YiXin<yixin.zhu@lantiq.com>
+ */
+
+#define DEBUG
+#include <linux/ctype.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/seq_file.h>
+#include <linux/printk.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <net/datapath_api.h>
+#include <net/lantiq_cbm.h>
+#include <net/lantiq_cbm_api.h>
+#include <net/vrx318_dsl_api.h>
+
+#include <lantiq.h>
+#include <lantiq_soc.h>
+#include <lantiq_irq.h>
+#include <lantiq_pcie.h>
+
+#include "include/vrx318_dfe.h"
+#include "include/vrx318_ppe_fw_ds.h"
+
+#include "include/vrx318_common.h"
+#include "include/vrx318_framework.h"
+#include "include/vrx318_api.h"
+
+void reset_ppe(u32 base)
+{
+	int max_loop = 10000;
+	u32 reset_mask
+		= RST_PPE_ATM_TC | RST_DMA_CORE | RST_PPE_DSL_IF | RST_PPE_DFE;
+	u32 ppe_rst;
+
+	vrx318_w32(reset_mask, RST_REQ, base);
+	udelay(1000);
+
+	while (max_loop-- > 0 && vrx318_r32(RST_REQ, base) & reset_mask)
+		;
+
+	if ((vrx318_r32(RST_REQ, base) & reset_mask)) {
+		vrx318_dbg(DBG_ERR, "failed in reset PPE\n");
+		BUG();
+	}
+
+	/* Software Reset PPM1/PPM0/QSB/PDMA/SSL1/SAR/SSL0/DREG/RTHA/TTHA */
+	ppe_rst = vrx318_r32(PP32_SRST, base);
+	ppe_rst &= ~0x303CF;
+	vrx318_w32(ppe_rst, PP32_SRST, base);
+	udelay(1000);
+
+	/* Set back to working status */
+	ppe_rst = vrx318_r32(PP32_SRST, base);
+	ppe_rst |= 0x303CF;
+	vrx318_w32(ppe_rst, PP32_SRST, base);
+	udelay(1000);
+}
+
+int pp32_download_code(u32 base, int pp32, const u32 *code_src,
+			unsigned int code_dword_len, const u32 *data_src,
+			unsigned int data_dword_len)
+{
+	unsigned int clr, set, cdm_cfg;
+
+	if (code_src == 0 || ((unsigned long)code_src & 0x03) != 0
+		|| data_src == 0 || ((unsigned long)data_src & 0x03) != 0) {
+		vrx318_dbg(DBG_ERR, "FW code src or data src check fail\n");
+		return -ENOEXEC;
+	}
+
+	vrx318_dbg(DBG_INIT, "pp32: %d, code_src: 0x%x, code dw len: 0x%x\n",
+		pp32, (unsigned int)code_src, code_dword_len);
+
+	clr = pp32 ? 0xF0 : 0x0F;
+	if (code_dword_len <= CDM_CODE_MEMORYN_DWLEN(0))
+		set = pp32 ? (3 << 6) : (2 << 2);
+	else
+		set = 0x00;
+	cdm_cfg = vrx318_r32(CDM_CFG, base);
+	cdm_cfg = (cdm_cfg & ~clr) | set;
+	vrx318_w32(cdm_cfg, CDM_CFG, base);
+	vrx318_dbg(DBG_INIT, "addr(CDM_CFG) = 0x%08x\n", cdm_cfg);
+
+	/*  clear code memory   */
+	dword_ep_clear(CDM_CODE_MEMORY(pp32, 0),
+		CDM_CODE_MEMORYN_DWLEN(0) << 2, base);
+
+	if (code_dword_len > CDM_CODE_MEMORYN_DWLEN(0))
+		dword_ep_clear((CDM_CODE_MEMORY(pp32, 0) +
+			(CDM_CODE_MEMORYN_DWLEN(0) << 2)),
+			CDM_CODE_MEMORYN_DWLEN(1) << 2, base);
+
+	/*  copy code   */
+	dword_mem_write(CDM_CODE_MEMORY(pp32, 0), code_src,
+			code_dword_len << 2, base);
+
+	/*  copy data   */
+	dword_mem_write(CDM_DATA_MEMORY(pp32, 0), data_src,
+			data_dword_len << 2, base);
+
+	return 0;
+}
+
+void enable_ppe_ema(u32 base)
+{
+	u32 val;
+	int cnt;
+
+	/* some version of chip by default power on */
+	if ((vrx318_r32(PMU_SR, base) & PMU_PPE_EMA) == 0)
+		return;
+
+	val = vrx318_r32(PMU_PWDCR, base);
+	val &= ~PMU_PPE_EMA; /* set 0 to power on */
+	vrx318_w32(val, PMU_PWDCR, base);
+
+	for (cnt = 0; cnt < 1000; cnt++) {
+		if ((vrx318_r32(PMU_SR, base) & PMU_PPE_EMA) == 0)
+			return;
+	}
+	vrx318_dbg(DBG_INIT, "Power on PPE EMA failed\n");
+	BUG();
+}
+
+void set_ppe_clk(u32 clk, u32 base)
+{
+	u32 clk_val;
+
+	clk_val = vrx318_r32(CGU_CLKFSR, base);
+
+	switch (clk) {
+	case 288:
+		vrx318_w32(SET_PPE_CLK(clk_val, 2), CGU_CLKFSR, base);
+		break;
+	case 432:
+		vrx318_w32(SET_PPE_CLK(clk_val, 1), CGU_CLKFSR, base);
+		break;
+	default:
+		vrx318_dbg(DBG_ERR, "Set PPE CLK err:%d\n", clk);
+		break;
+	}
+}
+
+u32 get_ppe_clk(u32 base)
+{
+	u32 clk_val;
+
+	clk_val = (vrx318_r32(CGU_CLKFSR, base) >> 16) & 0x7;
+	switch (clk_val) {
+	case 1:
+		return 432000000;
+	case 2:
+		return 288000000;
+	default:
+		vrx318_dbg(DBG_ERR, "PPE CLK error: %d\n", clk_val);
+	}
+	/* Default */
+	return 288000000;
+}
+
+void print_fw_version(char *dstbuf, struct fw_ver_id *ver)
+{
+	char buf[128];
+	int len;
+
+	static char *fw_ver_package_str[] = {
+		"Reserved - 0",
+		"A1",
+		"B1 - (PTM_BONDING)",
+		"E1",
+		"A5",
+		"D5",
+		"D5v2",
+		"E5",
+	};
+
+	len = 0;
+
+	if (ver->family == 9)
+		len += sprintf(buf + len, "FW Family:\t VRX318\n");
+	else
+		len += sprintf(buf + len, "FW Family:\t Unknown: %d\n",
+			ver->family);
+
+	if (ver->package < ARRAY_SIZE(fw_ver_package_str))
+		len += sprintf(buf + len,
+			"FW Package:\t %s Package\n",
+			fw_ver_package_str[ver->package]);
+	else
+		len += sprintf(buf + len,
+			"FW Package:\t Unknow Package: %d\n", ver->package);
+
+	len += sprintf(buf + len, "FW Version:\t %d.%d.%d\n",
+			ver->major, ver->middle, ver->minor);
+	buf[len] = 0;
+
+	if (dstbuf)
+		strcpy(dstbuf, buf);
+	else
+		vrx318_dbg(DBG_INIT, "%s", buf);
+}
+
+void dword_clear(void *addr, int byte_len)
+{
+	int i;
+	u32 *dst = (u32 *)addr;
+	int dw_len;
+
+	dw_len = byte_len / 4;
+
+	if (dw_len <= 0)
+		return;
+
+	if ((u32)dst & 0x3) {
+		vrx318_dbg(DBG_ERR, "%s: address is not aligned: 0x%x\n",
+			__func__, (u32)addr);
+	}
+
+	for (i = 0; i < dw_len; i++)
+		dst[i] = 0;
+}
+
+void dword_ep_clear(u32 addr, int byte_len, u32 base)
+{
+	int i;
+	int dw_len;
+
+	dw_len = byte_len / 4;
+
+	if (dw_len <= 0)
+		return;
+
+	for (i = 0; i < dw_len; i++)
+		vrx318_w32(0, addr + (i << 2), base);
+
+	return;
+}
+
+void dword_mem_write(u32 dst_addr, const void *src_addr, int byte_len, u32 base)
+{
+	int i;
+	const u32 *src = (const u32 *)src_addr;
+	int dw_len;
+
+	dw_len = byte_len / 4;
+
+	if (dw_len <= 0)
+		return;
+
+	if ((dst_addr & 0x3) || ((u32)src & 0x3)) {
+		vrx318_dbg(DBG_ERR, "%s: address is not dw aligned: dst: 0x%x, src: 0x%x\n",
+			__func__, dst_addr, (u32)src);
+	}
+
+	for (i = 0; i < dw_len; i++)
+		vrx318_w32(src[i], dst_addr + (i << 2), base);
+}
+
+void dword_mem_read(void *dst_addr, u32 src_addr, int byte_len, u32 base)
+{
+	int i;
+	u32 *dst = (u32 *)dst_addr;
+	int dw_len;
+
+	dw_len = byte_len / 4;
+
+	if (dw_len <= 0)
+		return;
+
+	if (((u32)dst & 0x3) || (src_addr & 0x3)) {
+		vrx318_dbg(DBG_ERR, "%s: address is not dw aligned: dst: 0x%x, src: 0x%x\n",
+			__func__, (u32)dst, src_addr);
+	}
+
+	for (i = 0; i < dw_len; i++)
+		dst[i] = vrx318_r32(src_addr + (i << 2), base);
+}
+
+void vrx318_sb_clear(u32 base)
+{
+	dword_ep_clear(SB_BUFFER(0x2000), 0x5000 * 4, base);
+	dword_ep_clear(SB_BUFFER(0x8000), 0x8000 * 4, base);
+}
+
+int alloc_data_buffer(struct vrx318_priv *priv,
+				unsigned int size, dma_addr_t *dma_addr,
+				unsigned int *v_addr)
+{
+	dma_addr_t phy_addr;
+	unsigned int *buf;
+
+	buf = (unsigned int *)cbm_buffer_alloc(0, CBM_PORT_F_STANDARD_BUF);
+	if (!buf)
+		return -ENOMEM;
+
+	phy_addr = dma_map_single(priv->pdev, buf, size, DMA_FROM_DEVICE);
+	if (dma_mapping_error(priv->pdev, phy_addr)) {
+		vrx318_dbg(DBG_ERR, "DMA address mapping error: buf: 0x%x, size: %d, dir: %d\n",
+			(u32)buf, size, DMA_FROM_DEVICE);
+		BUG();
+	}
+	dma_unmap_single(priv->pdev, phy_addr, size, DMA_FROM_DEVICE);
+	*dma_addr = phy_addr;
+	if (v_addr)
+		*v_addr = (unsigned int)buf;
+
+	return 0;
+}
+
+int free_data_buffer(dma_addr_t phy_addr)
+{
+	return cbm_buffer_free(0, phy_addr, 1);
+}
+
+static u32 mei_rd(u32 addr, u32 base)
+{
+	vrx318_w32(addr, MEIAD(ME_DBG_RD_AD), base);
+	while (!(vrx318_r32(MEIAD(ME_ARC2ME_STAT), base) & 0x10))
+		;
+	vrx318_w32(0x10, MEIAD(ME_ARC2ME_STAT), base);
+
+	return vrx318_r32(MEIAD(ME_DBG_DATA), base);
+}
+
+static void mei_wr(u32 addr, u32 val, u32 base)
+{
+	vrx318_w32(addr, MEIAD(ME_DBG_WR_AD), base);
+	vrx318_w32(val, MEIAD(ME_DBG_DATA), base);
+	while (!(vrx318_r32(MEIAD(ME_ARC2ME_STAT), base) & 0x10))
+		;
+	vrx318_w32(0x10, MEIAD(ME_ARC2ME_STAT), base);
+}
+
+static void setup_zephyr(u32 base)
+{
+
+	u32 i, read_data;
+
+	for (i = 0; i < NUM_ME_VAR; i++) {
+		switch (my_cfg_seq[i].type) {
+		case ME_DBG_RD:
+			read_data = vrx318_r32(my_cfg_seq[i].addr +
+					0x1e116000, base);
+			break;
+		case ME_DBG_WR:
+			vrx318_w32(my_cfg_seq[i].data, my_cfg_seq[i].addr +
+					0x1e116000, base);
+			break;
+		}
+	}
+
+	/* Read back to make sure Zephry started */
+	read_data = mei_rd(0x00020c40c, base);
+	vrx318_dbg(DBG_LOOPBACK, "CRI_TSC_CTRL: 0x%08x\n", read_data);
+
+	read_data = mei_rd(0x00020c4dc, base);
+	vrx318_dbg(DBG_LOOPBACK, "CRI_RXFFT_STALL_CTRL: 0x%08x\n", read_data);
+
+	read_data = mei_rd(0x00020c4d8, base);
+	vrx318_dbg(DBG_LOOPBACK, "CRI_RXQT_STALL_CTRL: 0x%08x\n", read_data);
+
+	read_data = mei_rd(0x00020c4d0, base);
+	vrx318_dbg(DBG_LOOPBACK, "CRI_RXPMS_CTRL: 0x%08x\n", read_data);
+
+	read_data = mei_rd(0x00020c4b4, base);
+	vrx318_dbg(DBG_LOOPBACK, "CRI_TXPMS_CTRL: 0x%08x\n", read_data);
+
+	return;
+}
+
+
+static inline void vrx218_dfe_reset(u32 base)
+{
+	vrx318_w32(((0x1 << 7) | (0x1 << 3)), RST_STAT, base);
+	mdelay(1);
+}
+
+static void dfe_zephyr_lb_init(u32 base, u32 arc_mode)
+{
+	vrx218_dfe_reset(base);
+
+	if (arc_mode)
+		/* start_arc(base); */
+		vrx318_dbg(DBG_ERR, "ARC loopback mode is not supported\n");
+	else
+		setup_zephyr(base);
+
+	return;
+}
+
+static void set_dfe_data_rate(u32 base, u32 nbc_switches, u32 nbc0bytes,
+				u32 nbc1bytes, u32 numtimeslots)
+{
+
+	/* Num of BC switches for Tx to load into register ZT_R0 */
+	mei_wr(0x000542F4, nbc_switches, base);
+
+	/* Num of BC switches for Rx to load into register ZR_R0 */
+	mei_wr(0x0005B94C, nbc_switches, base);
+
+	/* Num of BC0 and BC1 bytes for Tx to load into register ZT_VBC_SIZE */
+	mei_wr(0x00054308, (nbc1bytes << 16) + nbc0bytes, base);
+
+	/* Num of BC0 and BC1 bytes for Rx to load into register ZR_VBC_SIZE */
+	mei_wr(0x0005B960, (nbc1bytes << 16) + nbc0bytes, base);
+
+	/* Num of BC0 and BC1 error bytes for Tx to load into register ZT_R12 */
+	/* me_dbg_wr(0x00054300, (nBC1ErrBytes << 16) + nBC0ErrBytes); */
+	mei_wr(0x00054300, 0, base);
+
+	/* Num of BC0 and BC1 error bytes for Rx to load into REG ZR_R12 */
+	/* me_dbg_wr(0x0005B958, (nBC1ErrBytes << 16) + nBC0ErrBytes); */
+	mei_wr(0x0005B958, 0, base);
+
+	/* kick of by writing to CRI registers */
+	/* me_dbg_wr(0x0020c40c, 0x8007ffe1); */
+	mei_wr(0x0020c40c, 0x8007ffe0 | numtimeslots, base);
+	mei_wr(0x0020c49c, 0x00000078, base);
+
+	return;
+}
+
+void setup_dfe_loopback(struct vrx318_priv *priv, u32 base)
+{
+	if (!priv->param.dfe_loopback)
+		return;
+
+	vrx318_dbg(DBG_INIT, "enable DFE loopback ...\n");
+
+	/* Set DFE to Zephyr loopback mode */
+	/* 0 - ARC core disable ; 1 - ARC core enable */
+	dfe_zephyr_lb_init(base, 0);
+
+	/* Function to change DFE data rate
+	 * Bit_rate (MBps) = num_bc_switch *
+	 *	(bc0_payld + bc1_payld)  / ((num_time_slot + 1) * 28 us);
+	 * Bit_rate (Mbps) = 8 * num_bc_switch *
+	 *	(bc0_payld + bc1_payld)  / ((num_time_slot + 1) * 28 us);
+	 * set_dfe_data_rate(u8 pcie_port, UINT32 num_bc_switch,
+	 *	UINT32 bc0_payld, UINT32 bc1_payld, UINT32 num_time_slot)
+	 */
+	set_dfe_data_rate(base, 4, 427, 427, 1);
+}
+
+static inline int in_sync(u32 base, u32 bc)
+{
+	int state = 0;
+
+	if (bc == 0)
+		state = vrx318_r32(PPE_SFSM_STATE0, base) & 0x1;
+	else if (bc == 1)
+		state = vrx318_r32(PPE_SFSM_STATE1, base) & 0x1;
+
+	return state;
+}
+
+void dfe_loopback_linkup(struct vrx318_priv *priv, u32 base)
+{
+	u32 val;
+	int i = 0;
+	if (!priv->param.dfe_loopback)
+		return;
+
+	vrx318_dbg(DBG_LOOPBACK, "wait dfe_loopback_linkup\n");
+	vrx318_w32(0x07, BC0_LINK_STATUS, base);
+	udelay(15);
+
+	while (!in_sync(base, 0) && !in_sync(base, 1) && (i++) < 10000)
+		;
+
+	vrx318_dbg(DBG_INIT, "%s\n", in_sync(base, 0) ?
+		"BC0 is in sync\n" : "BC0 is not in sync\n");
+	vrx318_dbg(DBG_INIT, "%s\n", in_sync(base, 1) ?
+		"BC1 is in sync\n" : "BC1 is not in sync\n");
+
+	/* Don't keep idle for emulation, but must keep idle for real case. */
+	val = vrx318_r32(PPE_SFSM_CFG0, base) & (~(1 << 15));
+	vrx318_w32(val, PPE_SFSM_CFG0, base);
+	val = vrx318_r32(PPE_SFSM_CFG1, base) & (~(1 << 15));
+	vrx318_w32(val, PPE_SFSM_CFG1, base);
+
+	udelay(5);
+}
+
+int vrx318_soc_cfg_get(struct vrx318_priv *priv)
+{
+	int ret;
+	struct vrx318_soc_cfg *cfg = &priv->soc_cfg;
+
+	ret = soc_vrx318_cfg_init(cfg);
+
+	vrx318_dbg(DBG_INIT, "cpu (phybase: 0x%x, dnum: %d), fp (phybase: 0x%x, fp dnum: %d), ds (phybase: 0x%x, dnum: %d), pmac_en: %d, us desown: %d, ds desown: %d\n",
+		cfg->soc_cpu_us_phybase, cfg->soc_cpu_us_dnum,
+		cfg->soc_fp_us_phybase, cfg->soc_fp_us_dnum,
+		cfg->soc_ds_phybase, cfg->soc_ds_dnum,
+		cfg->pmac_en,
+		cfg->soc_us_desc_own, cfg->soc_ds_desc_own);
+	priv->param.pmac_en = cfg->pmac_en;
+
+	return ret;
+}
+
+/* VRX318 TC message genelink family */
+struct genl_family vrx_tc_gnl_family = {
+	.id = GENL_ID_GENERATE, /* To generate an id for the family*/
+	.hdrsize = 0,
+	.name = VRX_FAMILY_NAME, /*family name, used by userspace application*/
+	.version = VERSION_NR, /*version number  */
+	.maxattr = VRX_TC_A_MAX,
+};
+
+/* VRX318 TC message multicast group */
+struct genl_multicast_group vrx_grp = {
+	.name = VRX_MCAST_GRP_NAME,
+};
+
+/**
+ * API defintion for the driver to send TC notify messages to user application
+ * using genetlink method.
+ * pid: process id
+ * tc_mode: ATM_TC/PTM_TC
+ * tc_action: TC_LOADED/TC_UNLOADED
+ * bnd_mode: BONDING_MODE/NON_BONDING_MODE
+ * ln_no: VRX318 ep id
+ */
+int vrx_tc_msg_send(int pid, int tc_mode, int tc_action,
+			int bnd_mode, int ln_no)
+{
+	struct sk_buff *skb;
+	int ret;
+	void *msg_head;
+
+	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	/* create the message headers */
+	msg_head = genlmsg_put(skb, 0, 0,
+			&vrx_tc_gnl_family, 0, VRX_TC_C_NOTIFY);
+	if (msg_head == NULL) {
+		ret = -ENOMEM;
+		vrx318_dbg(DBG_EVENT, "Create message header fail!\n");
+		goto out;
+	}
+
+	nla_put_u32(skb, VRX_TC_A_TC_MODE, tc_mode);
+	nla_put_u32(skb, VRX_TC_A_TC_ACTION, tc_action);
+	nla_put_u32(skb, VRX_TC_A_BOND, bnd_mode);
+	nla_put_u32(skb, VRX_TC_A_LINENO, ln_no);
+
+	genlmsg_end(skb, msg_head);
+	ret = genlmsg_multicast(skb, pid, vrx_grp.id, GFP_KERNEL);
+	if (ret != 0) {
+		vrx318_dbg(DBG_EVENT, "Failed to send out the multicast message\n");
+		goto out;
+	}
+	return 0;
+out:
+	return ret;
+}
+
+int vrx318_genetlink_init(void)
+{
+	int ret;
+
+	/*register new family*/
+	ret = genl_register_family(&vrx_tc_gnl_family);
+	if (ret != 0) {
+		vrx318_dbg(DBG_ERR, "Family registeration fail:%s\n",
+			vrx_tc_gnl_family.name);
+		goto failure;
+	}
+
+	ret = genl_register_mc_group(&vrx_tc_gnl_family, &vrx_grp);
+	if (ret != 0) {
+		vrx318_dbg(DBG_ERR, "register mc group fail: %i, grp name: %s\n",
+			ret, vrx_grp.name);
+		genl_unregister_family(&vrx_tc_gnl_family);
+		goto failure;
+	}
+
+	return 0;
+
+failure:
+	return ret;
+}
+
+void vrx318_genetlink_exit(void)
+{
+	int ret;
+
+	/* unregister mc groups */
+	genl_unregister_mc_group(&vrx_tc_gnl_family, &vrx_grp);
+
+	/*unregister the family*/
+	ret = genl_unregister_family(&vrx_tc_gnl_family);
+	if (ret != 0)
+		vrx318_dbg(DBG_ERR, "unregister Genetlink family %i\n", ret);
+
+	return;
+}
diff --git a/drivers/net/ethernet/lantiq/vrx318/vrx318_atm_tc.c b/drivers/net/ethernet/lantiq/vrx318/vrx318_atm_tc.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/vrx318_atm_tc.c
@@ -0,0 +1,3527 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * Copyright (C) 2015 Zhu YiXin<yixin.zhu@lantiq.com>
+ */
+#define DEBUG
+#include <linux/ctype.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/jiffies.h>
+#include <linux/seq_file.h>
+#include <linux/printk.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/completion.h>
+#include <net/datapath_api.h>
+#include <net/lantiq_cbm.h>
+#include <net/lantiq_cbm_api.h>
+#include <net/datapath_proc_api.h>
+#include <net/vrx318_dsl_api.h>
+#include <net/ppa_stack_al.h>
+
+#include <lantiq.h>
+#include <lantiq_soc.h>
+#include <lantiq_irq.h>
+#include <lantiq_pcie.h>
+#include <lantiq_atm.h>
+
+#if defined(CONFIG_LTQ_PPA_API) || defined(CONFIG_LTQ_PPA_API_MODULE)
+#include <net/ppa_api.h>
+#endif
+
+#include "include/vrx318_ppe_fw_ds.h"
+#include "include/vrx318_ppe_atm_ds.h"
+#include "include/vrx318_fw_prereq.h"
+#include "include/vrx318_a1plus_addr_def.h"
+#include "include/vrx318_ppe_fw_const.h"
+#include "include/unified_qos_ds_be.h"
+#include "include/vrx318_edma.h"
+#include "include/vrx318_common.h"
+#include "include/vrx318_framework.h"
+#include "include/vrx318_atm_tc.h"
+#include "include/vrx318_api.h"
+#include "include/vrx318_proc.h"
+
+#include "fw/vrx318_a1plus.h"
+
+static struct vrx318_atm_tc *g_atm_tc;
+static const char *g_atm_dev_name = "vrx318_atm";
+
+static void do_oam_tasklet(unsigned long);
+static DECLARE_TASKLET(g_oam_tasklet, do_oam_tasklet, 0);
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+static void do_coc_tasklet(unsigned long);
+static DECLARE_TASKLET(g_coc_tasklet, do_coc_tasklet, 0);
+#endif
+static int ppe_open(struct atm_vcc *);
+static void ppe_close(struct atm_vcc *);
+static int ppe_ioctl(struct atm_dev *, unsigned int, void *);
+static int ppe_send(struct atm_vcc *, struct sk_buff *);
+static int ppe_send_oam(struct atm_vcc *, void *, int);
+static int ppe_change_qos(struct atm_vcc *, struct atm_qos *, int);
+static int find_vpi(unsigned int);
+static int find_vcc(struct atm_vcc *);
+static void qsb_global_set(struct vrx318_atm_tc *, u32);
+static u32 get_qsb_clk(u32);
+
+
+
+static struct atmdev_ops g_ppe_atm_ops = {
+	.owner =	THIS_MODULE,
+	.open =		ppe_open,
+	.close =	ppe_close,
+	.ioctl =	ppe_ioctl,
+	.send =		ppe_send,
+	.send_oam =	ppe_send_oam,
+	.change_qos =	ppe_change_qos,
+};
+
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+enum ltq_cpufreq_state atm_coc_state = LTQ_CPUFREQ_PS_D0;
+#endif
+
+static inline void dump_oam_cell(void *cell, int rx)
+{
+	if (rx) {
+		if (g_vrx318_dbg & DBG_OAM_RX_DUMP)
+			dp_dump_raw_data(cell, CELL_SIZE, "OAM RX Cell");
+	} else {
+		if (g_vrx318_dbg & DBG_OAM_TX_DUMP)
+			dp_dump_raw_data(cell, CELL_SIZE, "OAM TX Cell");
+	}
+}
+
+int max_pvc_num(u32 qos_en)
+{
+	return ATM_TXQ_NUM(qos_en);
+}
+
+/*Note: FW RXQ number is 16, TXQ number is 15 */
+static inline int txq_num(void)
+{
+	return ATM_TXQ_NUM(g_atm_tc->frwk->param.atm_qos);
+}
+
+static inline int pvc_num(void)
+{
+	return ATM_PVC_NUM(g_atm_tc->frwk->param.atm_qos);
+}
+
+void vrx318_atm_param_setup(struct vrx318_priv *priv, int qsb_tau, int qsb_srvm,
+			int qsb_tstep, int aal5r_max_pktsz,
+			int aal5r_min_pktsz, int aal5s_max_pktsz)
+{
+	struct vrx318_param *cfg = &priv->param;
+
+	cfg->qsb_tau = qsb_tau & 0x3F;
+	cfg->qsb_srvm = qsb_srvm & 0x0F;
+	cfg->qsb_tstep = qsb_tstep;
+	cfg->aal5r_max_pktsz = aal5r_max_pktsz < DMA_PACKET_SIZE
+		? aal5r_max_pktsz : DMA_PACKET_SIZE;
+	cfg->aal5r_min_pktsz = aal5r_min_pktsz < 0 ? 0 : aal5r_min_pktsz;
+	cfg->aal5s_max_pktsz = aal5s_max_pktsz < DMA_PACKET_SIZE
+		? aal5s_max_pktsz : DMA_PACKET_SIZE;
+}
+
+/**
+ *  Description:
+ *    Loop up for connection ID with virtual path ID and virtual channel ID.
+ *  Input:
+ *    vpi --- unsigned int, virtual path ID
+ *    vci --- unsigned int, virtual channel ID
+ *  Output:
+ *    int --- negative value: failed
+ *            else          : connection ID
+ */
+int find_vpivci(unsigned int vpi, unsigned int vci)
+{
+	int i;
+	struct atm_pvc *conn = g_atm_tc->conn;
+	int max_pvc = pvc_num();
+
+	for (i = 0; i < max_pvc; i++)
+		if ((g_atm_tc->pvc_tbl & BIT(i))
+			&& conn[i].vcc != NULL
+			&& vpi == conn[i].vcc->vpi
+			&& vci == conn[i].vcc->vci)
+			return i;
+
+	return -ENODEV;
+}
+
+/**
+ * Description:
+ *   Loop up for connection ID with virtual path ID.
+ * Input:
+ *   vpi --- unsigned int, virtual path ID
+ * Output:
+ *   int --- negative value: failed
+ *   else          : connection ID
+ */
+static int find_vpi(unsigned int vpi)
+{
+	int i;
+	struct atm_pvc *conn = g_atm_tc->conn;
+	int max_pvc = pvc_num();
+
+	for (i = 0; i < max_pvc; i++)
+		if ((g_atm_tc->pvc_tbl & (1 << i)) != 0
+			&& conn[i].vcc != NULL
+			&& vpi == conn[i].vcc->vpi)
+			return i;
+
+	return -ENODEV;
+}
+
+/**
+ *  ps_en:  1 - Enable powersaving, 0 -Disable Powersaving
+ *  flag:   0 - Get the powersaving cfg, 1 - Set the powersaving
+ */
+int atm_power_saving(struct vrx318_atm_tc *priv, int ps_en, int flag)
+{
+	struct psave_cfg ps_cfg;
+	u32 base;
+
+	base = (u32)priv->frwk->ep_dev[priv->ep_id].membase;
+	dword_clear(&ps_cfg, sizeof(ps_cfg));
+	dword_mem_read(&ps_cfg, SB_BUFFER(__PSAVE_CFG),
+			sizeof(ps_cfg), base);
+	if (!flag)
+		return ps_cfg.sleep_en;
+	else {
+		ps_cfg.sleep_en = !!(ps_en);
+		dword_mem_write(SB_BUFFER(__PSAVE_CFG), &ps_cfg,
+			sizeof(ps_cfg), base);
+	}
+
+	return 0;
+}
+
+int atm_in_showtime(void)
+{
+	if (g_atm_tc->frwk->param.dfe_loopback)
+		return 1;
+
+	return g_atm_tc->frwk->show_time_stat[g_atm_tc->ep_id];
+}
+
+static inline void get_fw_version(struct fw_ver_id *ver, u32 base)
+{
+	u32 version;
+
+	version = vrx318_r32_sb(__FW_VER_ID, base);
+	*ver = *(struct fw_ver_id *)&version;
+}
+
+void vrx318_atm_pmac_cfg_init(int pid)
+{
+	struct dp_pmac_cfg pmac_cfg;
+
+	memset(&pmac_cfg, 0, sizeof(pmac_cfg));
+
+	pmac_cfg.eg_pmac_flags
+		= EG_PMAC_F_PMAC | EG_PMAC_F_FCS | EG_PMAC_F_TCENA;
+
+	pmac_cfg.eg_pmac.pmac = 0;
+	pmac_cfg.eg_pmac.fcs = 0;
+	pmac_cfg.eg_pmac.tc_enable = 1;
+
+	pmac_cfg.ig_pmac_flags = IG_PMAC_F_PRESENT | IG_PMAC_F_SPID
+				| IG_PMAC_F_PMACHDR3 | IG_PMAC_F_PMACHDR5;
+
+	pmac_cfg.ig_pmac.pmac = 0;
+	pmac_cfg.ig_pmac.def_pmac_src_port = 1;
+	pmac_cfg.ig_pmac.def_pmac_hdr[2] = (pid & 0xF) << 4;
+	pmac_cfg.ig_pmac.def_pmac_hdr[4] = 0; /* Packet has no FCS */
+
+	dp_pmac_set(pid, &pmac_cfg);
+}
+
+/* Initialize eDMA Configuration Registers and PPE FW eDMA Context
+* Single line applcation:   MUST be called
+* Bonding line application: MUST be called for both VRX318
+*/
+static void vrx318_edma_init(u32 base, int lle_in_sb, int cdma_write_data_en)
+{
+	unsigned int dst_addr;
+	edma_ch_ctrl_t edma_ch_ctrl;
+	edma_lle_link_t edma_lle_link;
+	edma_ch_ctxt_t edma_ch_ctxt;
+
+	/* edma hang detection init James */
+	vrx318_w32_sb(10, __EDMA_HANG_DETECT_TH, base);
+
+	/* Initialize eDMA Channel Control Register - Data Structure */
+	dword_clear(&edma_ch_ctrl, sizeof(edma_ch_ctrl));
+
+	edma_ch_ctrl.at = 0; /* ??? Address Translation (AT) */
+	edma_ch_ctrl.tc = 0; /* Traffic Class (TC) */
+	edma_ch_ctrl.td = 0; /* Traffic Digest, the PCIe core adds the ECRC */
+	/* field and sets the TD bit in TLP header */
+	edma_ch_ctrl.ro = 1; /* Releaxed Ording */
+	edma_ch_ctrl.ns = 0; /* No Snoop */
+	/* ??? Function Number (FN) for generated MRd/MWr DMA TLPs */
+	edma_ch_ctrl.fn = 0;
+	/* The core uses this when generating the RID for the MRd/MWr DMA TLP */
+	edma_ch_ctrl.ll_en = 1;	/* link list enable */
+	/* Consumer Cycles State (CCS).
+	* Used in Link List mode only. It is used to synchronize
+	* the Producer (Software) and the Consumer (DMA).
+	* *You must initialize this bit.* The DMA updates
+	* this bit during linked list operation
+	*/
+	edma_ch_ctrl.ccs = 1;
+	/* Channel Status (CS)
+	* The Channel Status bits identify the current operational
+	* state of the DMA write or read channel.
+	* 00: Reserved
+	* 01: Running, this channel is active and transferring data
+	* 10: Halted. An error condition has been detected.
+	* and the DMA has stopped this channel
+	* 11: Stopped. The DMA has transferred all data for
+	* this channel or you have prematurely stopped
+	* this channel by writing to the Stop field of
+	* of the DMA R/W doorbell register
+	*/
+	edma_ch_ctrl.cs	= 3;
+
+	edma_ch_ctrl.rie = 0; /* remote interrupt enable */
+	edma_ch_ctrl.lie = 0; /* local interrupt enable */
+	/* load link pointer (LLP)
+	* Used in link list mode only. Indicates that
+	* this linked list element is a link element, and
+	* it's LL element pointer DWORDs are pointint to the next
+	* (non-contiguous) element
+	* the DMA loads this field with the LLP of the
+	* linked list element
+	*/
+	edma_ch_ctrl.llp = 0;
+	/* Toggle Cycle Bit (TCB)
+	* Indicates to the DMA to toglle its intepreation of
+	* the CB. Used in linked list mode only. It is used
+	* to synchorize the Producer (Software) and the
+	* Consumer (DMA).
+	* The DMA loads this field with the TCB of the linked
+	* list element.
+	* Note: this field is not defined in a ata LL element
+	*/
+	edma_ch_ctrl.tcb = 0;
+	/* Cycle Bit (CB)
+	* Unsed in Linked list mode only.  It is used
+	* to synchorize the Producer (Software) and the
+	* Consumer (DMA).
+	* The DMA loads this field with the CB of the linked
+	* list elment
+	*/
+	edma_ch_ctrl.cb = 0;
+
+	if (cdma_write_data_en == 0) {
+		/* Configure eDMA Write Channel */
+
+		/* Disable eDMA Write Channel */
+		vrx318_w32(0, EDMA_WCH_EN, base);
+
+		/* Select Write Channel */
+		vrx318_w32(EDMA_WRITE_CH, EDMA_CH_IDX, base);
+
+		/* Setup eDMA Channel Control Register */
+		dword_mem_write(EDMA_CH_CTRL, &edma_ch_ctrl,
+				sizeof(edma_ch_ctrl), base);
+
+		vrx318_w32(0, EDMA_TRANSFER_SIZE, base);
+		vrx318_w32(0, EDMA_SAR_LOW, base);
+		vrx318_w32(0, EDMA_SAR_HIGH, base);
+		vrx318_w32(0, EDMA_DAR_LOW, base);
+		vrx318_w32(0, EDMA_DAR_HIGH, base);
+
+		if (lle_in_sb == 1)
+			vrx318_w32(SB_BUFFER(__DS_EDMA_LLE_BASE),
+					EDMA_LL_PTR_LOW, base);
+		else
+			vrx318_w32(__DS_EDMA_LLE_FPI_BASE,
+					EDMA_LL_PTR_LOW, base);
+
+		vrx318_w32(0, EDMA_LL_PTR_HIGH, base);
+
+		/* Setup Write Channel Link List Elements */
+		dword_clear(&edma_lle_link, sizeof(edma_lle_link));
+		edma_lle_link.tcb = 1;
+		edma_lle_link.llp = 1;
+		if (lle_in_sb == 1) {
+			edma_lle_link.lle_ptr_low
+				= SB_BUFFER(__DS_EDMA_LLE_BASE);
+			dst_addr = SB_BUFFER(__DS_EDMA_LLE_BASE);
+		} else {
+			edma_lle_link.lle_ptr_low = __DS_EDMA_LLE_FPI_BASE;
+			dst_addr = __DS_EDMA_LLE_FPI_BASE;
+		}
+
+		dword_ep_clear(dst_addr,
+			(EDMA_WCH_DATA_LLE_NUM * sizeof(edma_lle_data_t)),
+			base);
+		dst_addr += EDMA_WCH_DATA_LLE_NUM * sizeof(edma_lle_data_t);
+		dword_mem_write(dst_addr, &edma_lle_link,
+				sizeof(edma_lle_link), base);
+
+		/* Setup EDMA Write Channel Context */
+		dword_clear(&edma_ch_ctxt, sizeof(edma_ch_ctxt));
+		edma_ch_ctxt.edma_ch_type = EDMA_WRITE_CH;
+		edma_ch_ctxt.edma_pcs = 1;
+		edma_ch_ctxt.edma_lle_num = EDMA_WCH_DATA_LLE_NUM;
+		edma_ch_ctxt.edma_lle_sb_size = EDMA_WCH_DATA_LLE_NUM * 6;
+		edma_ch_ctxt.edma_lle_sb_base = __DS_EDMA_LLE_BASE;
+		edma_ch_ctxt.edma_lle_ext_sb_base = __DS_EDMA_LLE_EXT_BASE;
+		if (lle_in_sb == 1)
+			edma_ch_ctxt.edma_lle_fpi_base
+				= SB_BUFFER(__DS_EDMA_LLE_BASE);
+		else
+			edma_ch_ctxt.edma_lle_fpi_base
+				= __DS_EDMA_LLE_FPI_BASE;
+
+		edma_ch_ctxt.edma_ch_status = EDMA_STOPPED;
+		dword_mem_write(SB_BUFFER(__DS_EDMA_WRITE_CH_CFG_CTXT),
+			&edma_ch_ctxt, sizeof(edma_ch_ctxt), base);
+
+		/* Enable eDMA Write Channel */
+		vrx318_w32(1, EDMA_WCH_EN, base);
+	}
+
+	/* Configure eDMA Read Channel */
+
+	/* Disable eDMA Read Channel */
+	vrx318_w32(0, EDMA_RCH_EN, base);
+
+	/* Select Read Channel */
+	vrx318_w32(EDMA_READ_CH, EDMA_CH_IDX, base);
+
+	/* Setup eDMA Channel Control Register */
+	dword_mem_write(EDMA_CH_CTRL, &edma_ch_ctrl,
+			sizeof(edma_ch_ctrl), base);
+
+	vrx318_w32(0, EDMA_TRANSFER_SIZE, base);
+	vrx318_w32(0, EDMA_SAR_LOW, base);
+	vrx318_w32(0, EDMA_SAR_HIGH, base);
+	vrx318_w32(0, EDMA_DAR_LOW, base);
+	vrx318_w32(0, EDMA_DAR_HIGH, base);
+
+	if (lle_in_sb == 1)
+		vrx318_w32(SB_BUFFER(__US_EDMA_LLE_BASE),
+			EDMA_LL_PTR_LOW, base);
+	else
+		vrx318_w32(__US_EDMA_LLE_FPI_BASE, EDMA_LL_PTR_LOW, base);
+
+	vrx318_w32(0, EDMA_LL_PTR_HIGH, base);
+
+	/* Setup Read Channel Link List Elements */
+	dword_clear(&edma_lle_link, sizeof(edma_lle_link));
+	edma_lle_link.tcb = 1;
+	edma_lle_link.llp = 1;
+	if (lle_in_sb == 1) {
+		edma_lle_link.lle_ptr_low = SB_BUFFER(__US_EDMA_LLE_BASE);
+		dst_addr = SB_BUFFER(__US_EDMA_LLE_BASE);
+	} else {
+		edma_lle_link.lle_ptr_low = __US_EDMA_LLE_FPI_BASE;
+		dst_addr = __US_EDMA_LLE_FPI_BASE;
+	}
+
+	dword_ep_clear(dst_addr,
+		(EDMA_RCH_DATA_LLE_NUM * sizeof(edma_lle_data_t)),
+		base);
+	dst_addr += EDMA_RCH_DATA_LLE_NUM * sizeof(edma_lle_data_t);
+	dword_mem_write(dst_addr, &edma_lle_link, sizeof(edma_lle_link), base);
+
+	/* Setup EDMA Read Channel Context */
+	dword_clear(&edma_ch_ctxt, sizeof(edma_ch_ctxt));
+	edma_ch_ctxt.edma_ch_type = EDMA_READ_CH;
+	edma_ch_ctxt.edma_pcs = 1;
+	edma_ch_ctxt.edma_lle_num = EDMA_RCH_DATA_LLE_NUM;
+	edma_ch_ctxt.edma_lle_sb_size = EDMA_RCH_DATA_LLE_NUM * 6;
+	edma_ch_ctxt.edma_lle_sb_base = __US_EDMA_LLE_BASE;
+	edma_ch_ctxt.edma_lle_ext_sb_base = __US_EDMA_LLE_EXT_BASE;
+	if (lle_in_sb == 1)
+		edma_ch_ctxt.edma_lle_fpi_base
+			= SB_BUFFER(__US_EDMA_LLE_BASE);
+	else
+		edma_ch_ctxt.edma_lle_fpi_base
+			= __US_EDMA_LLE_FPI_BASE;
+
+	edma_ch_ctxt.edma_ch_status = EDMA_STOPPED;
+	dword_mem_write(SB_BUFFER(__US_EDMA_READ_CH_CFG_CTXT), &edma_ch_ctxt,
+			sizeof(edma_ch_ctxt), base);
+
+	/* Enable eDMA Read Channel */
+	vrx318_w32(1, EDMA_RCH_EN, base);
+
+	return;
+}
+
+static void atm_free_tx_skb_vcc(struct sk_buff *skb)
+{
+	struct atm_vcc *vcc;
+
+	vcc = ATM_SKB(skb)->vcc;
+
+	if (vcc != NULL && vcc->pop != NULL) {
+		VRX318_ASSERT(atomic_read(&skb->users) != 0,
+			"atm_free_tx_skb_vcc(vcc->pop): skb->users == 0, skb = %08X",
+			(unsigned int)skb);
+		vcc->pop(vcc, skb);
+	} else {
+		VRX318_ASSERT(atomic_read(&skb->users) != 0,
+			"atm_free_tx_skb_vcc(dev_kfree_skb_any): skb->users == 0, skb = %08X",
+			(unsigned int)skb);
+		dev_kfree_skb_any(skb);
+	}
+}
+
+static void pp32_load(u32 base)
+{
+	int ret;
+
+	/* Download firmware */
+	vrx318_dbg(DBG_INIT, "Download A1 FW\n");
+	ret = pp32_download_code(base, 0,
+		vrx218_a1plus_fw_code, ARRAY_SIZE(vrx218_a1plus_fw_code),
+		vrx218_a1plus_fw_data, ARRAY_SIZE(vrx218_a1plus_fw_data));
+	if (ret) {
+		vrx318_dbg(DBG_ERR, "Download A1 FW code fail\n");
+		BUG();
+	}
+}
+
+static void set_qsb_clk(u32 div, u32 base)
+{
+	u32 clk_val;
+	u32 divisor = 0;
+
+	if (div > 8) {
+		vrx318_dbg(DBG_ERR, "QSB CLK divisor invailid: %d\n", div);
+		return;
+	}
+
+	clk_val = vrx318_r32(CGU_CLKFSR, base);
+	for (; div > 1; div >>= 1)
+		divisor += 1;
+
+	clk_val |= divisor << 28;
+	vrx318_w32(clk_val, CGU_CLKFSR, base);
+}
+
+static int __init vrx318_atm_init(struct vrx318_atm_tc *priv)
+{
+	int i, err;
+	for (i = 0; i < ATM_PORT_NUMBER; i++) {
+		priv->port[i].tx_max_cell_rate = DEFAULT_CELL_RATE;
+		priv->port[i].dev = atm_dev_register(g_atm_dev_name,
+				priv->frwk->pdev, &g_ppe_atm_ops, -1, 0UL);
+		if (!priv->port[i].dev) {
+			err = -EIO;
+			goto ATM_DEV_REGISTER_FAIL;
+		} else {
+			priv->port[i].dev->ci_range.vpi_bits = 8;
+			priv->port[i].dev->ci_range.vci_bits = 16;
+			/* assume 3200 cell rate before get real information*/
+			priv->port[i].dev->link_rate = DEFAULT_CELL_RATE;
+			priv->port[i].dev->dev_data = priv;
+			priv->port[i].dev->phy_data = (void *)(unsigned long)i;
+		}
+	}
+
+	return 0;
+
+ATM_DEV_REGISTER_FAIL:
+	vrx318_dbg(DBG_ERR, "ATM device registration fail\n");
+	for (i = 0; i < ATM_PORT_NUMBER; i++)
+		if (priv->port[i].dev)
+			atm_dev_deregister(priv->port[i].dev);
+
+	return err;
+}
+
+/* Note: Upper interface must be deleted by system before exit */
+void vrx318_atm_exit(void)
+{
+	struct vrx318_atm_tc *priv = g_atm_tc;
+	int i;
+
+	if (!priv)
+		return;
+
+	for (i = 0; i < ATM_PORT_NUMBER; i++) {
+		if (priv->port[i].dev)
+			atm_dev_deregister(priv->port[i].dev);
+	}
+
+	kfree(priv);
+	g_atm_tc = NULL;
+
+	vrx318_dbg(DBG_INFO, "VRX318 ATM exited!\n");
+}
+
+
+static inline void vrx318_atm_pdma_init(u32 base)
+{
+	vrx318_w32(0x00000008, PPE_PDMA_CFG, base);
+	vrx318_w32(0x00203580, PPE_SAR_PDMA_RX_CMDBUF_CFG, base);
+	vrx318_w32(0x004035A0, PPE_SAR_PDMA_RX_FW_CMDBUF_CFG, base);
+
+	return;
+}
+
+static void vrx318_atm_fw_init(u32 base)
+{
+	qos_cfg_t qos_cfg;
+	struct psave_cfg ps_cfg;
+
+	vrx318_w32(0x3C30, DS_FLOW_CTRL_CFG, base);
+
+	dword_clear(&qos_cfg, sizeof(qos_cfg));
+	/* PPE FW use this timer to wake up in the sleep mode.
+	    It's the only way to wake up FW in the ATM mode.
+	*/
+	/* cgu_get_pp32_clock() / 62500 / 3 */
+	qos_cfg.time_tick = get_ppe_clk(base) / (62500 * 3);
+	dword_mem_write(SB_BUFFER(__QOS_CFG), &qos_cfg, sizeof(qos_cfg), base);
+
+	dword_clear(&ps_cfg, sizeof(ps_cfg));
+	ps_cfg.start_state = 0;
+	ps_cfg.sleep_en = 0;  /* Disable sleep mode by default */
+	dword_mem_write(SB_BUFFER(__PSAVE_CFG), &ps_cfg, sizeof(ps_cfg), base);
+
+	vrx318_w32_sb(15 + 3, __CFG_WRX_HTUTS, base);
+	vrx318_w32_sb(0x03, __CFG_WRX_DMACH_ON, base);
+	vrx318_w32_sb(4, __CFG_WRX_HUNT_BITTH, base);
+	vrx318_w32_sb(1, __SOC_FAMILY, base);
+
+	return;
+}
+
+static void vrx318_atm_htu_init(u32 base)
+{
+	/* OAM_F4_SEG_HTU_ENTRY */
+	vrx318_w32_sb(0x00000031, HTU_ENTRY_TBL(OAM_F4_SEG_HTU_ENTRY), base);
+	vrx318_w32_sb(0xfff0000e, HTU_MASK_TBL(OAM_F4_SEG_HTU_ENTRY), base);
+	vrx318_w32_sb(0x00000600, HTU_RESULT_TBL(OAM_F4_SEG_HTU_ENTRY), base);
+
+	/* OAM_F4_TOT_HTU_ENTRY */
+	vrx318_w32_sb(0x00000041, HTU_ENTRY_TBL(OAM_F4_TOT_HTU_ENTRY), base);
+	vrx318_w32_sb(0xfff0000e, HTU_MASK_TBL(OAM_F4_TOT_HTU_ENTRY), base);
+	vrx318_w32_sb(0x00000600, HTU_RESULT_TBL(OAM_F4_TOT_HTU_ENTRY), base);
+
+	/* OAM_F5_HTU_ENTRY */
+	vrx318_w32_sb(0x00000009, HTU_ENTRY_TBL(OAM_F5_HTU_ENTRY), base);
+	vrx318_w32_sb(0xfffffff2, HTU_MASK_TBL(OAM_F5_HTU_ENTRY), base);
+	vrx318_w32_sb(0x00000600, HTU_RESULT_TBL(OAM_F5_HTU_ENTRY), base);
+
+	return;
+}
+
+static void vrx318_atm_wtx_queue_cfg_init(u32 base, int qsb_en)
+{
+	int i;
+	wtx_queue_config_t wtx_queue_config;
+
+	dword_clear(&wtx_queue_config, sizeof(wtx_queue_config));
+	wtx_queue_config.same_vc_qmap = 0;
+	wtx_queue_config.uu           = 0;
+	wtx_queue_config.cpi          = 0;
+	wtx_queue_config.sbid         = 0;
+	/*  Which QSB queue (VCID) does this TX queue map to. */
+	wtx_queue_config.qsb_vcid     = 0;
+	wtx_queue_config.mpoa_mode    = 0; /*  0: VCmux, 1: LLC */
+	wtx_queue_config.qsben        = qsb_en;
+	wtx_queue_config.atm_header   = 0;
+
+	for (i = 0; i < txq_num(); i++) {
+		dword_mem_write(SB_BUFFER(WTX_Q_CFG(i)),
+			&wtx_queue_config, sizeof(wtx_queue_config_t), base);
+	}
+
+	return;
+}
+
+static void vrx318_atm_wtx_port_cfg_init(u32 base, int qsb_en)
+{
+	wtx_port_config_t wtx_port_config;
+
+	dword_clear(&wtx_port_config, sizeof(wtx_port_config));
+	wtx_port_config.qsben = qsb_en;
+	/* BC0: Use TX Queue 0 - if QSB is Disabled */
+	wtx_port_config.qid = 0;
+	dword_mem_write(SB_BUFFER(__WTX_PORT_CONFIG0), &wtx_port_config,
+		sizeof(wtx_port_config), base);
+	/* BC1: Use TX Queue 1 - if QSB is Disabled */
+	wtx_port_config.qid = 1;
+	dword_mem_write(SB_BUFFER(__WTX_PORT_CONFIG1), &wtx_port_config,
+		sizeof(wtx_port_config), base);
+
+	return;
+}
+
+static void vrx318_atm_wrx_queue_cfg_init(u32 base)
+{
+	int i;
+	wrx_queue_config_t wrx_queue_config;
+
+	dword_clear(&wrx_queue_config, sizeof(wrx_queue_config));
+
+	wrx_queue_config.new_vlan  = 0;
+	wrx_queue_config.vlan_ins  = 0;
+	/* 0: EoA without FCS, 1: EoA with FCS, 2: PPPoA, 3:IPoA */
+	wrx_queue_config.mpoa_type = MPOA_IPOA;
+	wrx_queue_config.ip_ver    = ATM_IP_IPV4; /* 0: IPv4, 1: IPv6 */
+	wrx_queue_config.mpoa_mode = MPOA_VCMUX_MODE; /* 0: VCmux, 1: LLC */
+	wrx_queue_config.oversize  = DMA_PACKET_SIZE;
+	wrx_queue_config.undersize = 0;
+	wrx_queue_config.mfs       = DMA_PACKET_SIZE; /* Max fragment size */
+	wrx_queue_config.uumask    = 0xFF;
+	wrx_queue_config.cpimask   = 0xFF;
+	wrx_queue_config.uuexp     = 0;
+	wrx_queue_config.cpiexp    = 0;
+
+	for (i = 0; i < 2; i++)
+		dword_mem_write(SB_BUFFER(WRX_Q_CFG(i)),
+			&wrx_queue_config, sizeof(wrx_queue_config_t), base);
+
+	return;
+}
+
+static int vrx318_ds_aal5_desq_cfg_ctxt_init(struct vrx318_priv *priv,
+							u32 base)
+{
+	int i;
+	rx_descriptor_t rx_descriptor;
+	dma_addr_t phy_addr;
+	desq_cfg_ctxt_t ds_desq_cfg_ctxt;
+	unsigned int *soc_ds_base
+		= (unsigned int *)priv->soc_cfg.soc_ds_dbase;
+
+	dword_clear(&ds_desq_cfg_ctxt, sizeof(ds_desq_cfg_ctxt));
+
+	/* Initialize Downstream Descriptor Queue Config/Context */
+	ds_desq_cfg_ctxt.des_in_own_val		= 0;
+	ds_desq_cfg_ctxt.fast_path		= 0;
+	ds_desq_cfg_ctxt.mbox_int_en		= 0;
+	ds_desq_cfg_ctxt.des_sync_needed	= 1;
+	ds_desq_cfg_ctxt.des_num		= priv->soc_cfg.soc_ds_dnum;
+	ds_desq_cfg_ctxt.des_base_addr		= __DS_PKT_DES_LIST_BASE;
+	dword_mem_write(SB_BUFFER(__DS_PKT_DESQ_CFG_CTXT),
+		&ds_desq_cfg_ctxt, sizeof(desq_cfg_ctxt_t), base);
+
+	dword_clear(&rx_descriptor, sizeof(rx_descriptor));
+	rx_descriptor.own = !ds_desq_cfg_ctxt.des_in_own_val;
+	rx_descriptor.sop = 1;
+	rx_descriptor.eop = 1;
+	rx_descriptor.data_len = DMA_PACKET_SIZE;
+
+	/* Initialize DS Descriptors */
+	for (i = 0; i < ds_desq_cfg_ctxt.des_num; i++) {
+		if (!priv->param.pmac_en)
+			rx_descriptor.data_ptr
+				= soc_ds_base[i * 2 + 1] +  VRX318_OB_BADDR;
+		else {
+			if (alloc_data_buffer(priv, DMA_PACKET_SIZE,
+					&phy_addr, (unsigned int *)NULL)) {
+				vrx318_dbg(DBG_ERR,
+					"Failed to alloc buffer for ds des\n");
+				return -ENOMEM;
+			}
+			rx_descriptor.data_ptr
+				= (unsigned int)phy_addr + VRX318_OB_BADDR;
+		}
+		dword_mem_write(
+			SB_BUFFER(ds_desq_cfg_ctxt.des_base_addr + (i * 2)),
+			&rx_descriptor, sizeof(rx_descriptor), base);
+	}
+
+	return 0;
+}
+
+static int vrx318_ds_oam_desq_cfg_ctxt_init(struct vrx318_atm_tc *priv,
+							u32 base)
+{
+	int i;
+	desq_cfg_ctxt_t oam_desq_cfg_ctxt;
+	rx_descriptor_t rx_descriptor;
+	dma_addr_t phy_addr;
+
+	/* Initialize Downstream OAM Descriptor Queue Config/Context */
+	dword_clear(&oam_desq_cfg_ctxt, sizeof(oam_desq_cfg_ctxt));
+	oam_desq_cfg_ctxt.des_in_own_val	= 1;
+	oam_desq_cfg_ctxt.fast_path		= 0;
+	oam_desq_cfg_ctxt.mbox_int_en		= 0;
+	/* FW does not it copy to SoC, driver launch a tasklet
+	to directly fetch from vrx318 des list
+	*/
+	oam_desq_cfg_ctxt.des_sync_needed	= 0;
+	oam_desq_cfg_ctxt.des_num		= DS_OAM_DES_NUM;
+	oam_desq_cfg_ctxt.des_base_addr		= __DS_OAM_DES_LIST_BASE;
+	dword_mem_write(SB_BUFFER(__DS_OAM_DESQ_CFG_CTXT),
+		&oam_desq_cfg_ctxt, sizeof(oam_desq_cfg_ctxt), base);
+
+	priv->oam_llst.oam_num = oam_desq_cfg_ctxt.des_num;
+	priv->oam_llst.oam_des_list
+		= kmalloc(priv->oam_llst.oam_num * sizeof(unsigned int),
+			GFP_KERNEL);
+	if (!priv->oam_llst.oam_des_list)
+		return -ENOMEM;
+	priv->oam_llst.oam_idx = 0;
+
+	/* Init OWN bit of all the Descriptors in Shadow DS Descriptor List */
+	rx_descriptor.own = !oam_desq_cfg_ctxt.des_in_own_val;
+	rx_descriptor.sop = 1;
+	rx_descriptor.eop = 1;
+	rx_descriptor.data_len = 0; /*EDMA doesn't require the data_len */
+	for (i = 0; i < oam_desq_cfg_ctxt.des_num; i++) {
+		if (alloc_data_buffer(priv->frwk, ATM_OAM_SIZE, &phy_addr,
+			&priv->oam_llst.oam_des_list[i])) {
+			vrx318_dbg(DBG_ERR, "Failed to allocate buffer for DS OAM\n");
+			return -ENOMEM;
+		}
+		rx_descriptor.data_ptr = phy_addr + VRX318_OB_BADDR;
+		dword_mem_write(
+			SB_BUFFER(oam_desq_cfg_ctxt.des_base_addr + (i * 2)),
+			&rx_descriptor, sizeof(rx_descriptor), base);
+	}
+
+	return 0;
+}
+
+static void vrx318_us_fastpath_desq_cfg_ctxt_init(struct vrx318_priv *priv,
+							u32 base)
+{
+	int i, own;
+	desq_cfg_ctxt_t us_fp_desq_cfg_ctxt;
+
+	if (!priv->soc_cfg.soc_fp_us_dnum)
+		return;
+
+	dword_clear(&us_fp_desq_cfg_ctxt, sizeof(us_fp_desq_cfg_ctxt));
+	/* Initialize Up-Stream Fast-Path Descriptor Queue Config/Context */
+	/*1 - owned by SoC CDMA, 0 - owned by VRX318 */
+	us_fp_desq_cfg_ctxt.des_in_own_val	= 0;
+	us_fp_desq_cfg_ctxt.fast_path		= 1;
+	us_fp_desq_cfg_ctxt.mbox_int_en		= 0;
+	us_fp_desq_cfg_ctxt.des_sync_needed	= 1;
+	/* max: soc_fp_us_dnum: 64 */
+	us_fp_desq_cfg_ctxt.des_num		= priv->soc_cfg.soc_fp_us_dnum;
+	us_fp_desq_cfg_ctxt.des_base_addr	= __US_FAST_PATH_DES_LIST_BASE;
+
+	dword_mem_write(SB_BUFFER(__US_FP_INQ_DES_CFG_CTXT),
+		&us_fp_desq_cfg_ctxt, sizeof(desq_cfg_ctxt_t), base);
+
+	/* Init OWN bit of all the Descriptors in Shadow Fast Path Des List */
+	own = !us_fp_desq_cfg_ctxt.des_in_own_val;
+	own = (own & 1) << 31;
+
+	for (i = 0; i < us_fp_desq_cfg_ctxt.des_num; i++) {
+		vrx318_w32_sb(own,
+			us_fp_desq_cfg_ctxt.des_base_addr + (i * 2), base);
+	}
+
+	return;
+}
+
+static void vrx318_us_cpupath_desq_cfg_ctxt_init(struct vrx318_priv *priv,
+							u32 base)
+{
+	int i, own;
+	desq_cfg_ctxt_t us_cpu_desq_cfg_ctxt;
+
+	if (!priv->soc_cfg.soc_cpu_us_dnum)
+		return;
+
+	dword_clear(&us_cpu_desq_cfg_ctxt, sizeof(us_cpu_desq_cfg_ctxt));
+	/* Initialize Up-Stream CPU-Path Descriptor Queue Config/Context */
+	us_cpu_desq_cfg_ctxt.des_in_own_val  = 1;
+	us_cpu_desq_cfg_ctxt.fast_path       = 0;
+	us_cpu_desq_cfg_ctxt.mbox_int_en     = 0;
+	us_cpu_desq_cfg_ctxt.des_sync_needed = 1;
+	/* max: cpu us dnum: 64 */
+	us_cpu_desq_cfg_ctxt.des_num         = priv->soc_cfg.soc_cpu_us_dnum;
+	us_cpu_desq_cfg_ctxt.des_base_addr   = __US_CPU_PATH_DEST_LIST_BASE;
+
+	dword_mem_write(SB_BUFFER(__US_CPU_INQ_DES_CFG_CTXT),
+		&us_cpu_desq_cfg_ctxt, sizeof(desq_cfg_ctxt_t), base);
+
+	/* Init OWN bit of all the Descriptors in Shadow CPU Path Des List */
+	own = !us_cpu_desq_cfg_ctxt.des_in_own_val;
+	own = (own & 1) << 31;
+
+	for (i = 0; i < us_cpu_desq_cfg_ctxt.des_num; i++) {
+		vrx318_w32_sb(own,
+			us_cpu_desq_cfg_ctxt.des_base_addr + (i * 2), base);
+	}
+
+	return;
+}
+
+
+
+/* Initialize QoS related configuration for VRX218
+* Initializes the below PPE FW Data Structures
+* 1. INQ_QoS_CFG
+* 2. QoSQ_CFG_CTXT
+* 4. SHAPING_WFQ_CFG
+* 5. QOSQ_MIB
+* 6. QOSQ_FLOW_CTRL_CFG
+* 7. STD_DES_CFG
+*/
+static void vrx318_atm_us_qos_cfg_init(struct vrx318_priv *priv,
+						u32 base)
+{
+	int i, offset;
+	qosq_flow_ctrl_cfg_t qosq_flow_ctrl_cfg;
+	std_des_cfg_t std_des_cfg;
+	inq_qos_cfg_t fp_qos_cfg, cpu_qos_cfg;
+	qosq_cfg_ctxt_t qosq_cfg_ctxt;
+
+	/* Initialize QOSQ_FLOW_CTRL_CFG */
+	dword_clear(&qosq_flow_ctrl_cfg, sizeof(qosq_flow_ctrl_cfg));
+	qosq_flow_ctrl_cfg.large_frame_size = 1024;
+	qosq_flow_ctrl_cfg.large_frame_drop_th = 28;
+	dword_mem_write(SB_BUFFER(__QOSQ_FLOW_CTRL_CFG),
+		&qosq_flow_ctrl_cfg, sizeof(qosq_flow_ctrl_cfg), base);
+
+	/* Initialize STD_DES_CFG */
+	dword_clear(&std_des_cfg, sizeof(std_des_cfg));
+	std_des_cfg.byte_off = 0;
+	std_des_cfg.data_len = DMA_PACKET_SIZE - 32;
+	dword_mem_write(SB_BUFFER(__STD_DES_CFG),
+		&std_des_cfg, sizeof(std_des_cfg), base);
+
+	/* Setup INQ_QoS_CFG for Fast-Path & CPU-Path */
+	dword_clear(&fp_qos_cfg, sizeof(fp_qos_cfg));
+	dword_clear(&cpu_qos_cfg, sizeof(cpu_qos_cfg));
+
+	/* By default, support 8 queues only */
+	if (priv->soc_cfg.soc_fp_us_dnum) {
+		fp_qos_cfg.qos_en         = 1;
+		fp_qos_cfg.qid_mask       = 0xF;
+		fp_qos_cfg.qosq_base_qid  = 0;
+		fp_qos_cfg.desq_cfg_ctxt  = __US_FP_INQ_DES_CFG_CTXT;
+		dword_mem_write(INQ_QOS_CFG_BASE(0), &fp_qos_cfg,
+				sizeof(fp_qos_cfg), base);
+	}
+
+	if (priv->soc_cfg.soc_cpu_us_dnum) {
+		cpu_qos_cfg.qos_en        = 1;
+		cpu_qos_cfg.qid_mask      = 0xF;
+		cpu_qos_cfg.qosq_base_qid = 0;
+		cpu_qos_cfg.desq_cfg_ctxt = __US_CPU_INQ_DES_CFG_CTXT;
+		dword_mem_write(INQ_QOS_CFG_BASE(1), &cpu_qos_cfg,
+				sizeof(cpu_qos_cfg), base);
+	}
+
+	/* Setup Fast-Path DESQ_CFG_CTXT */
+	vrx318_us_fastpath_desq_cfg_ctxt_init(priv, base);
+
+	/* Setup CPU-Path DESQ_CFG_CTXT */
+	vrx318_us_cpupath_desq_cfg_ctxt_init(priv, base);
+
+	/* Setup QoSQ_CFG_CTXT */
+	dword_clear(&qosq_cfg_ctxt, sizeof(qosq_cfg_ctxt));
+
+	qosq_cfg_ctxt.threshold = 8;
+	qosq_cfg_ctxt.des_num   = TOTAL_QOS_DES_NUM / txq_num();
+
+	offset = 0;
+	for (i = 0; i < txq_num(); i++) {
+		qosq_cfg_ctxt.des_base_addr = __US_QOSQ_DES_LIST_BASE + offset;
+		dword_mem_write(
+			SB_BUFFER((__QOSQ_CFG_CTXT_BASE
+				+ (i * __QOSQ_CFG_CTXT_SIZE))),
+			&qosq_cfg_ctxt, sizeof(qosq_cfg_ctxt), base);
+		offset += qosq_cfg_ctxt.des_num * 2;
+	}
+	return;
+}
+
+static int vrx318_atm_us_qos_des_cfg_ctxt_init(struct vrx318_priv *priv,
+							u32 base)
+{
+	int i, offset;
+	tx_descriptor_t tx_descriptor;
+	desq_cfg_ctxt_t desq_cfg_ctxt;
+	u32 dst_addr;
+	dma_addr_t phy_addr;
+
+	/* Setup QoSQ PSEUDO DES_CFG_CTXT */
+	dword_clear(&desq_cfg_ctxt, sizeof(desq_cfg_ctxt));
+
+	desq_cfg_ctxt.des_in_own_val	= 1;
+	desq_cfg_ctxt.mbox_int_en	= 0;
+	desq_cfg_ctxt.des_sync_needed	= 0;
+	desq_cfg_ctxt.des_num		= TOTAL_QOS_DES_NUM / txq_num();
+	offset				= 0;
+
+	for (i = 0; i < txq_num(); i++) {
+		desq_cfg_ctxt.des_base_addr = __US_QOSQ_DES_LIST_BASE + offset;
+		dst_addr = SB_BUFFER(__QOSQ_PSEUDO_DES_CFG_BASE +
+			(i * sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int)));
+		dword_mem_write(dst_addr, &desq_cfg_ctxt,
+			sizeof(desq_cfg_ctxt), base);
+		offset += desq_cfg_ctxt.des_num * 2;
+	}
+
+	dword_clear(&tx_descriptor, sizeof(tx_descriptor));
+	tx_descriptor.own = !desq_cfg_ctxt.des_in_own_val;
+	tx_descriptor.data_len = DMA_PACKET_SIZE;
+
+	/* Initialize QoSQ Descriptors */
+	for (i = 0; i < TOTAL_QOS_DES_NUM; i++) {
+		if (alloc_data_buffer(priv, tx_descriptor.data_len,
+				&phy_addr, (unsigned int *)NULL)) {
+			vrx318_dbg(DBG_ERR, "Failed alloc buffer for QoSQ\n");
+			return -ENOMEM;
+		}
+		tx_descriptor.data_ptr = phy_addr + VRX318_OB_BADDR;
+		dword_mem_write(SB_BUFFER(__US_QOSQ_DES_LIST_BASE + (i * 2)),
+			&tx_descriptor, sizeof(tx_descriptor), base);
+	}
+
+	return 0;
+}
+
+void vrx318_atm_des_sync_init(struct vrx318_priv *priv, u32 base)
+{
+	des_sync_cfg_ctxt_t des_sync_cfg_ctxt;
+	int idx;
+
+	idx = 0;
+
+	/* Fast-Path Sync Config/Context */
+	dword_clear(&des_sync_cfg_ctxt, sizeof(des_sync_cfg_ctxt));
+	if (priv->soc_cfg.soc_fp_us_dnum) {
+		des_sync_cfg_ctxt.sync_type = US_READ_WRITE_SYNC;
+		/* des_sync_cfg_ctxt.us_des_polling_needed = 0; */
+		des_sync_cfg_ctxt.max_polling_intv = 4;
+		des_sync_cfg_ctxt.desq_cfg_ctxt	= __US_FP_INQ_DES_CFG_CTXT;
+		des_sync_cfg_ctxt.soc_des_own_val
+			= priv->soc_cfg.soc_us_desc_own;
+		des_sync_cfg_ctxt.ext_desc_base_addr
+			= priv->soc_cfg.soc_fp_us_phybase + VRX318_OB_BADDR;
+		dword_mem_write(DES_SYNC_CFG_CTXT(idx), &des_sync_cfg_ctxt,
+				sizeof(des_sync_cfg_ctxt), base);
+		idx++;
+	}
+
+	/* CPU-Path Sync Config/Context */
+	dword_clear(&des_sync_cfg_ctxt, sizeof(des_sync_cfg_ctxt));
+	if (priv->soc_cfg.soc_cpu_us_dnum) {
+		des_sync_cfg_ctxt.sync_type = US_READ_WRITE_SYNC;
+		/* des_sync_cfg_ctxt.us_des_polling_needed = 0; */
+		des_sync_cfg_ctxt.max_polling_intv = 10;
+		des_sync_cfg_ctxt.desq_cfg_ctxt	= __US_CPU_INQ_DES_CFG_CTXT;
+		des_sync_cfg_ctxt.soc_des_own_val
+			= priv->soc_cfg.soc_us_desc_own;
+		des_sync_cfg_ctxt.ext_desc_base_addr
+			= priv->soc_cfg.soc_cpu_us_phybase + VRX318_OB_BADDR;
+		dword_mem_write(DES_SYNC_CFG_CTXT(idx), &des_sync_cfg_ctxt,
+				sizeof(des_sync_cfg_ctxt), base);
+		idx++;
+	}
+
+	/* Downstream AAL5Q Sync Config/Context */
+	dword_clear(&des_sync_cfg_ctxt, sizeof(des_sync_cfg_ctxt));
+	if (priv->soc_cfg.soc_ds_dnum) {
+		des_sync_cfg_ctxt.sync_type = DS_WRITE_READ_SYNC;
+		/* des_sync_cfg_ctxt.us_des_polling_needed = 0; */
+		des_sync_cfg_ctxt.max_polling_intv = 1;
+		des_sync_cfg_ctxt.desq_cfg_ctxt	= __DS_PKT_DESQ_CFG_CTXT;
+		des_sync_cfg_ctxt.ext_desc_base_addr
+			= priv->soc_cfg.soc_ds_phybase + VRX318_OB_BADDR;
+		des_sync_cfg_ctxt.soc_des_own_val
+			= priv->soc_cfg.soc_ds_desc_own;
+		dword_mem_write(DES_SYNC_CFG_CTXT(idx), &des_sync_cfg_ctxt,
+				sizeof(des_sync_cfg_ctxt), base);
+		idx++;
+	}
+
+	/* Downstream OAM Sync Config/Context */
+	/* OAM packet is not synced to SoC in current design */
+
+	return;
+}
+
+/**
+* Initialize VRX218 ATM-TC Local Descriptor List
+* Performs below actions
+* (1) Allocate and Initialize TC UpStream Local Descriptors
+* (2) Allocate and Initialize TC DownStream Local Descriptors
+*/
+void vrx318_atm_local_des_cfg_ctxt_init(u32 base)
+{
+	int i, des_cnt;
+	tx_descriptor_t tx_descriptor;
+	rx_descriptor_t rx_descriptor;
+	desq_cfg_ctxt_t desq_cfg_ctxt;
+	u32 dst_addr;
+
+	unsigned int all5_sb_addr[] = {
+		__DS_SB_PKT_DATA_PTR_0, __DS_SB_PKT_DATA_PTR_1,
+		__DS_SB_PKT_DATA_PTR_2, __DS_SB_PKT_DATA_PTR_3,
+		__DS_SB_PKT_DATA_PTR_4, __DS_SB_PKT_DATA_PTR_5,
+		__DS_SB_PKT_DATA_PTR_6, __DS_SB_PKT_DATA_PTR_7,
+		__DS_SB_PKT_DATA_PTR_8, __DS_SB_PKT_DATA_PTR_9,
+		__DS_SB_PKT_DATA_PTR_10, __DS_SB_PKT_DATA_PTR_11};
+
+	unsigned int oam_sb_addr[] = {
+		__DS_SB_OAM_DATA_PTR_0, __DS_SB_OAM_DATA_PTR_1,
+		__DS_SB_OAM_DATA_PTR_2, __DS_SB_OAM_DATA_PTR_3,
+		__DS_SB_OAM_DATA_PTR_4, __DS_SB_OAM_DATA_PTR_5,
+		__DS_SB_OAM_DATA_PTR_6, __DS_SB_OAM_DATA_PTR_7,
+		__DS_SB_OAM_DATA_PTR_8, __DS_SB_OAM_DATA_PTR_9};
+
+	/* Setup the Local DESQ Configuration/Context for 16 UpStream Queues */
+	dword_clear(&desq_cfg_ctxt, sizeof(desq_cfg_ctxt));
+	desq_cfg_ctxt.des_in_own_val = 1;
+	des_cnt = 0;
+	for (i = 0; i < txq_num(); i++) {
+		desq_cfg_ctxt.des_num
+			= ATM_PDBRAM_US_BUF_LEN / txq_num();
+		desq_cfg_ctxt.des_base_addr
+			= __US_TC_LOCAL_Q_DES_LIST_BASE + (des_cnt * 2);
+		dst_addr = SB_BUFFER(__US_TC_LOCAL_Q_CFG_CTXT_BASE
+			+ i * (sizeof(desq_cfg_ctxt_t)/sizeof(unsigned int)));
+		dword_mem_write(dst_addr, &desq_cfg_ctxt,
+				sizeof(desq_cfg_ctxt), base);
+		des_cnt += desq_cfg_ctxt.des_num;
+	}
+
+	/* Initialize UpStream Descriptors */
+	dword_clear(&tx_descriptor, sizeof(tx_descriptor));
+	tx_descriptor.own = !desq_cfg_ctxt.des_in_own_val;
+	tx_descriptor.data_len = DMA_PACKET_SIZE;
+
+	/* Note: ATM US PDBRAM pointer need convert to DWORD pointer */
+	for (i = 0; i < ATM_PDBRAM_US_BUF_LEN; i++) {
+		tx_descriptor.data_ptr
+			= (PDBRAM_TX_PKT_BUF_BASE
+				+ (i * tx_descriptor.data_len)) / 4;
+		dst_addr = SB_BUFFER(__US_TC_LOCAL_Q_DES_LIST_BASE + (i * 2));
+		dword_mem_write(dst_addr, &tx_descriptor,
+				sizeof(tx_descriptor), base);
+	}
+
+	/* Setup the Local DESQ Configuration/Context for AAL5 DownStream Q*/
+	dword_clear(&desq_cfg_ctxt, sizeof(desq_cfg_ctxt));
+	desq_cfg_ctxt.des_in_own_val = 0;
+	desq_cfg_ctxt.des_num
+		= ARRAY_SIZE(all5_sb_addr) + ATM_PDBRAM_DS_BUF_LEN;
+	desq_cfg_ctxt.des_base_addr = __DS_TC_LOCAL_AAL5Q_DES_LIST_BASE;
+	dword_mem_write(SB_BUFFER(__DS_TC_AAL5_LOCAL_Q_CFG_CTXT),
+			&desq_cfg_ctxt, sizeof(desq_cfg_ctxt), base);
+
+	dword_clear(&rx_descriptor, sizeof(rx_descriptor));
+	rx_descriptor.own = !desq_cfg_ctxt.des_in_own_val;
+	rx_descriptor.data_len = DMA_PACKET_SIZE;
+
+	/* Initialize DownStream AAL5 Descriptors */
+	for (i = 0; i < ATM_PDBRAM_DS_BUF_LEN; i++) {
+		rx_descriptor.data_ptr = (PDBRAM_TX_PKT_BUF_BASE +
+				(ATM_PDBRAM_US_BUF_LEN * DMA_PACKET_SIZE) +
+				(i * DMA_PACKET_SIZE));
+		dst_addr = SB_BUFFER(__DS_TC_LOCAL_AAL5Q_DES_LIST_BASE +
+				(i * 2));
+		dword_mem_write(dst_addr, &rx_descriptor,
+				sizeof(rx_descriptor), base);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(all5_sb_addr); i++) {
+		rx_descriptor.data_ptr = SB_BUFFER(all5_sb_addr[i]);
+		dst_addr = SB_BUFFER(__DS_TC_LOCAL_AAL5Q_DES_LIST_BASE +
+				(ATM_PDBRAM_DS_BUF_LEN * 2) + (i * 2));
+		dword_mem_write(dst_addr, &rx_descriptor,
+				sizeof(rx_descriptor), base);
+	}
+
+	/* Setup the Local DESQ Configuration/Context for OAM DownStream Q */
+	dword_clear(&desq_cfg_ctxt, sizeof(desq_cfg_ctxt));
+	desq_cfg_ctxt.des_in_own_val = 0;
+	desq_cfg_ctxt.des_num = ATM_PDBRAM_DS_OAM_LEN;
+	desq_cfg_ctxt.des_base_addr = __DS_TC_LOCAL_OAMQ_DES_LIST_BASE;
+	dword_mem_write(SB_BUFFER(__DS_TC_OAM_LOCAL_Q_CFG_CTXT),
+			&desq_cfg_ctxt, sizeof(desq_cfg_ctxt), base);
+
+	dword_clear(&rx_descriptor, sizeof(rx_descriptor));
+	rx_descriptor.own = !desq_cfg_ctxt.des_in_own_val;
+	rx_descriptor.data_len = 128;
+
+	/* Initialize DownStream OAM Descriptors */
+	for (i = 0; i < ARRAY_SIZE(oam_sb_addr); i++) {
+		rx_descriptor.data_ptr = SB_BUFFER(oam_sb_addr[i]);
+		dst_addr = SB_BUFFER(__DS_TC_LOCAL_OAMQ_DES_LIST_BASE +
+					(i * 2));
+		dword_mem_write(dst_addr, &rx_descriptor,
+				sizeof(rx_descriptor), base);
+	}
+
+	return;
+}
+
+void vrx318_atm_edma_copy_ch_init(u32 base)
+{
+	edma_copy_ch_cfg_t copy_ch_cfg;
+	int i;
+	u32 dst_addr;
+
+	/* Setup up to 16 UpStream eDMA Copy Channel */
+	for (i = 0; i < txq_num(); i++) {
+		copy_ch_cfg.srcq_ctxt_ptr = __QOSQ_PSEUDO_DES_CFG_BASE +
+			i * sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int);
+		copy_ch_cfg.dstq_ctxt_ptr = __US_TC_LOCAL_Q_CFG_CTXT_BASE +
+			i * sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int);
+		dst_addr = SB_BUFFER(__US_EDMA_COPY_CH_CFG +
+			i * sizeof(edma_copy_ch_cfg_t) / sizeof(unsigned int));
+		dword_mem_write(dst_addr, &copy_ch_cfg,
+				sizeof(copy_ch_cfg), base);
+	}
+
+	/* Setup AAL5 DownStream eDMA Copy Channel */
+	copy_ch_cfg.srcq_ctxt_ptr = __DS_TC_AAL5_LOCAL_Q_CFG_CTXT;
+	copy_ch_cfg.dstq_ctxt_ptr = __DS_PKT_DESQ_CFG_CTXT;
+	dst_addr = __DS_EDMA_COPY_CH_CFG;
+	dword_mem_write(SB_BUFFER(dst_addr), &copy_ch_cfg,
+			sizeof(copy_ch_cfg), base);
+
+	/* Setup OAM DownStream eDMA Copy Channel */
+	copy_ch_cfg.srcq_ctxt_ptr = __DS_TC_OAM_LOCAL_Q_CFG_CTXT;
+	copy_ch_cfg.dstq_ctxt_ptr = __DS_OAM_DESQ_CFG_CTXT;
+	dst_addr += sizeof(copy_ch_cfg) / sizeof(int);
+	dword_mem_write(SB_BUFFER(dst_addr), &copy_ch_cfg,
+			sizeof(copy_ch_cfg), base);
+
+	return;
+}
+
+static inline void vrx318_enable_cdma(int cid, u32 base, int en)
+{
+	u32 reg_val;
+	vrx318_w32(cid, DMA_CS, base);
+
+	if (en)
+		reg_val = vrx318_r32(DMA_CCTRL, base) | 0x00000001;
+	else
+		reg_val = vrx318_r32(DMA_CCTRL, base) & (~0x00000001);
+
+	vrx318_w32(reg_val, DMA_CCTRL, base);
+}
+
+/* Only 1 descriptor is initialized per copy channel */
+static inline void vrx318_cfg_cdma_cpch(int rx_cid, int tx_cid,
+					u32 rx_dbase, u32 tx_dbase,
+					u32 rx_dnum, u32 tx_dnum, u32 base)
+{
+	/* Setup RX DMA Channel */
+	vrx318_w32(rx_cid, DMA_CS, base);
+	vrx318_w32(rx_dbase, DMA_CBA, base);
+	vrx318_w32(rx_dnum, DMA_CDLEN, base);
+
+	/* Setup TX DMA Channel */
+	vrx318_w32(tx_cid, DMA_CS, base);
+	vrx318_w32(tx_dbase, DMA_CBA, base);
+	vrx318_w32(tx_dnum, DMA_CDLEN, base);
+
+	vrx318_enable_cdma(rx_cid, base, 1);
+	vrx318_enable_cdma(tx_cid, base, 1);
+
+	return;
+}
+
+static inline void vrx318_setup_sync_cdma(int rx_cid, int tx_cid,
+						int off, u32 base)
+{
+	u32 rx_dbase, tx_dbase, rx_daddr;
+	/* Calculate all the offset for RX descriptor base address,
+	    RX data pointer, and Tx descriptor base address
+	*/
+	/* offset 11 */
+	const u32 rx_desc_off
+		= offsetof(des_sync_cfg_ctxt_t, cdma_dst_des_dw0) / 4;
+	/* offset 16 */
+	const u32 rx_data_off
+		= offsetof(des_sync_cfg_ctxt_t, rd_des_buf[0]) / 4;
+	/* offset 6 */
+	const u32 tx_desc_off = offsetof(des_sync_cfg_ctxt_t, rd_cmd_sar) / 4;
+
+	off = off * sizeof(des_sync_cfg_ctxt_t) / sizeof(int);
+
+	rx_dbase = __DES_SYNC_CFG_CTXT + off + rx_desc_off;
+	rx_daddr = __DES_SYNC_CFG_CTXT + off + rx_data_off;
+	tx_dbase = __DES_SYNC_CFG_CTXT + off + tx_desc_off;
+
+	/* Setup RX descriptor */
+	vrx318_w32_sb(0xF0000040, rx_dbase, base);
+	vrx318_w32_sb(SB_BUFFER(rx_daddr), rx_dbase + 1, base);
+
+	/* Setup TX descriptor */
+	vrx318_w32_sb(0x0, tx_dbase, base);
+	vrx318_w32_sb(0x0, tx_dbase + 1, base);
+
+	vrx318_cfg_cdma_cpch(rx_cid, tx_cid, SB_BUFFER(rx_dbase),
+				SB_BUFFER(tx_dbase), 1, 1, base);
+}
+
+
+/* Driver initialize and turn on all the required CDMA channel. */
+static void vrx318_atm_cdma_init(u32 base)
+{
+	u32 reg_val;
+	int off;
+
+	/* Enable POWER to CDMA */
+	reg_val = vrx318_r32(PMU_PWDCR, base) & (~0x00000004);
+	vrx318_w32(reg_val, PMU_PWDCR, base);
+
+	vrx318_w32(0x80000040, DMA_CPOLL, base);
+	vrx318_w32(0x00000004, DMA_PS, base);
+	reg_val = (vrx318_r32(DMA_PCTRL, base) & ~(0x0000003C)) | (0x0000003C);
+	vrx318_w32(reg_val, DMA_PCTRL, base);
+
+	/* Setup DMA COPYCH (RXCH0 & TXCH1): 1 Descriptor */
+	off = 0;
+	vrx318_setup_sync_cdma(0, 1, off, base); /*CPU US descriptor SYNC */
+	off++;
+
+	/* Setup DMA COPYCH (RXCH2 & TXCH3): 1 Descriptor */
+	/* FastPath US descriptor SYNC */
+	vrx318_setup_sync_cdma(2, 3, off, base);
+	off++;
+
+	/* Setup DMA COPYCH (RXCH4 & TXCH5): 1 Descriptor */
+	/* DS AAL5 descriptor SYNC */
+	vrx318_setup_sync_cdma(4, 5, off, base);
+
+	return;
+}
+
+/**
+ * ATM TC - Initialization : Entry Point
+ * dev     - PCIe Endpoint Device
+ * qsb_en  - 0: QSB Disabled, 1: QSB Enabled
+ */
+static void vrx318_ppe_atm_init(struct vrx318_atm_tc *priv, int qsb_en)
+{
+	u32 base, qos_en;
+	struct vrx318_priv *frwk = priv->frwk;
+
+	base = (u32)frwk->ep_dev[priv->ep_id].membase;
+	qos_en = frwk->param.atm_qos;
+
+	vrx318_sb_clear(base);
+	vrx318_atm_pdma_init(base);
+
+	/* vrx318_tc_reg_init(base); */ /* Testing only */
+	vrx318_atm_fw_init(base);
+	vrx318_atm_htu_init(base);
+	vrx318_atm_wtx_queue_cfg_init(base, qsb_en);
+	vrx318_atm_wtx_port_cfg_init(base, qsb_en);
+	vrx318_atm_wrx_queue_cfg_init(base);
+
+	/* Initialize Downstream AAL5 Descriptors A1 and desc config context */
+	vrx318_ds_aal5_desq_cfg_ctxt_init(frwk, base);
+
+	/* Initialize Downstream OAM Descriptors and desc config context */
+	vrx318_ds_oam_desq_cfg_ctxt_init(priv, base);
+
+	vrx318_atm_us_qos_cfg_init(frwk, base);
+	vrx318_atm_us_qos_des_cfg_ctxt_init(frwk, base);
+
+	vrx318_atm_des_sync_init(frwk, base);
+	vrx318_atm_local_des_cfg_ctxt_init(base);
+	vrx318_atm_edma_copy_ch_init(base);
+
+	/* eDMA LLE in PDBRAM */
+	vrx318_edma_init(base, frwk->param.lle_in_sb, frwk->param.cdma_wr_en);
+
+	/* Init CDMA for ATM TC-Mode */
+	vrx318_atm_cdma_init(base);
+	return;
+}
+
+static void do_oam_tasklet(unsigned long arg)
+{
+	unsigned long sys_flag;
+	rx_descriptor_t desc;
+	struct uni_cell_header *header;
+	int conn, ep_id;
+	struct atm_vcc *vcc;
+	desq_cfg_ctxt_t ds_oam_cfg_ctxt, local_oam_cfg_ctxt;
+	dma_addr_t phy_addr;
+	struct vrx318_atm_tc *priv;
+	u32 base, ds_oam_dbase, oam_idx, oam_max_num;
+	u32 mbox1_ier, rx_cnt, dq_cnt, *oam_dlist;
+
+	priv = g_atm_tc;
+	ep_id = priv->ep_id;
+	base = (u32)priv->frwk->ep_dev[ep_id].membase;
+	oam_dlist = priv->oam_llst.oam_des_list;
+	oam_idx = priv->oam_llst.oam_idx;
+	oam_max_num = priv->oam_llst.oam_num;
+
+	dword_mem_read(&ds_oam_cfg_ctxt, SB_BUFFER(__DS_OAM_DESQ_CFG_CTXT),
+			sizeof(ds_oam_cfg_ctxt), base);
+	ds_oam_dbase = ds_oam_cfg_ctxt.des_base_addr;
+	rx_cnt = ds_oam_cfg_ctxt.enq_pkt_cnt;
+	dq_cnt = ds_oam_cfg_ctxt.deq_pkt_cnt;
+
+	while (1) {
+		dword_mem_read(&desc, SB_BUFFER(ds_oam_dbase + oam_idx * 2),
+				sizeof(desc), base);
+		if (!desc.own) { /* desc not belong to CPU */
+			/* Update idx as will exit loop */
+			priv->oam_llst.oam_idx = oam_idx;
+			/* probe if there's still availble oam packet */
+			dword_mem_read(&ds_oam_cfg_ctxt,
+				SB_BUFFER(__DS_OAM_DESQ_CFG_CTXT),
+				sizeof(ds_oam_cfg_ctxt), base);
+			dword_mem_write(
+				SB_BUFFER(__DS_OAM_DESQ_CFG_CTXT + offsetof(desq_cfg_ctxt_t, deq_pkt_cnt) / sizeof(u32)),
+				&dq_cnt, sizeof(dq_cnt), base);
+			/* Update deq pkt cnt, may have race condition */
+			/* ds_oam_cfg_ctxt.deq_pkt_cnt += rx_cnt;
+			rx_cnt = ((ds_oam_cfg_ctxt.deq_pkt_cnt & 0xFFFF) << 16)
+				| (ds_oam_cfg_ctxt.enq_pkt_cnt & 0xFFFF);
+			dword_mem_write(SB_BUFFER(__DS_OAM_DESQ_CFG_CTXT + 2),
+					&rx_cnt, 4, base); */
+			dword_mem_read(&local_oam_cfg_ctxt,
+				SB_BUFFER(__DS_TC_OAM_LOCAL_Q_CFG_CTXT),
+				sizeof(local_oam_cfg_ctxt), base);
+			if ((local_oam_cfg_ctxt.enq_pkt_cnt !=
+					ds_oam_cfg_ctxt.enq_pkt_cnt) ||
+				(ds_oam_cfg_ctxt.enq_pkt_cnt !=
+					ds_oam_cfg_ctxt.deq_pkt_cnt))
+				tasklet_schedule(&g_oam_tasklet);
+			else { /* No more oam pkt, should enable irq again */
+				spin_lock_irqsave(&priv->oam_lock, sys_flag);
+				mbox1_ier = vrx318_r32(MBOX_IGU1_IER, base);
+				mbox_set_ier(MBOX_IGU1,
+					mbox1_ier | OAM_RX_INTR, base);
+				spin_unlock_irqrestore(&priv->oam_lock,
+							sys_flag);
+			}
+			break;
+		}
+
+		phy_addr = dma_map_single(priv->frwk->pdev,
+				(void *)oam_dlist[oam_idx],
+				ATM_OAM_SIZE, DMA_FROM_DEVICE);
+
+		dma_unmap_single(priv->frwk->pdev, phy_addr,
+				ATM_OAM_SIZE, DMA_FROM_DEVICE);
+
+		header = (struct uni_cell_header *)oam_dlist[oam_idx];
+
+		if (header->pti == ATM_PTI_SEGF5 ||
+			header->pti == ATM_PTI_E2EF5)
+			conn = find_vpivci(header->vpi, header->vci);
+		else if (header->vci == 0x03 || header->vci == 0x04)
+			conn = find_vpi(header->vpi);
+		else
+			conn = -1;
+
+		if (conn >= 0 && priv->conn[conn].vcc != NULL) {
+			vcc = priv->conn[conn].vcc;
+			priv->conn[conn].access_time = current_kernel_time();
+
+			vrx318_dbg(DBG_OAM_RX, "conn=%d, vpi: %d, vci:%d\n",
+				conn, header->vpi, header->vci);
+			dump_oam_cell(header, 1);
+			if (vcc->push_oam != NULL)
+				vcc->push_oam(vcc, header);
+			else {
+				#if defined(CONFIG_LTQ_OAM) || \
+					defined(CONFIG_LTQ_OAM_MODULE)
+					ifx_push_oam((unsigned char *)header);
+				#else
+					vrx318_dbg(DBG_OAM_RX, "Receive OAM packet\n");
+				#endif
+			}
+			priv->conn[conn].stats.oam_rx_pkts++;
+			priv->conn[conn].stats.oam_rx_bytes
+						+= desc.data_len;
+			priv->stats.oam_rx_pkts++;
+			priv->stats.oam_rx_bytes += desc.data_len;
+		} else {
+			priv->stats.oam_rx_errors++;
+		}
+
+		/* update desc */
+		desc.c = 0;
+		desc.own = 0;
+		desc.data_len = 0;
+		dword_mem_write(SB_BUFFER(ds_oam_dbase + oam_idx * 2), &desc,
+				sizeof(desc), base);
+
+		oam_idx = (oam_idx + 1) % oam_max_num;
+		dq_cnt++;
+	}
+
+}
+
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+extern int dp_coc_new_stat_req(enum ltq_cpufreq_state new_state
+	, uint32_t flag);
+static void do_coc_tasklet(unsigned long arg)
+{
+	/* change state to D0 */
+	atm_coc_state = LTQ_CPUFREQ_PS_D0;
+	/* call datapath to inform about the new state */
+	dp_coc_new_stat_req(atm_coc_state, DP_COC_REQ_VRX318);
+}
+#endif
+
+/* Note, must lock oam lock if change the ier other than OAM_INT bit */
+static irqreturn_t mailbox_irq_handler(int irq, void *dev_id)
+{
+	u32 mbox1_isr, mbox1_ier, mbox1_isrc;
+	u32 base;
+	struct vrx318_atm_tc *priv = dev_id;
+	int ep_id = priv->ep_id;
+
+	base = (u32)priv->frwk->ep_dev[ep_id].membase;
+	mbox1_ier = vrx318_r32(MBOX_IGU1_IER, base);
+	mbox1_isrc = vrx318_r32(MBOX_IGU1_ISR, base);
+
+	mbox1_isr = mbox1_isrc & mbox1_ier;
+
+	/* Any other bit except OAM_INT_BIT, need lock oam_lock */
+	if (mbox1_isr & OAM_RX_INTR) {
+		mbox1_ier &= ~OAM_RX_INTR;
+		mbox_set_ier(MBOX_IGU1, mbox1_ier, base);
+		tasklet_schedule(&g_oam_tasklet);
+	}
+
+	if (mbox1_isr & FW_UNLOAD_INTR) {
+		spin_lock_bh(&priv->oam_lock);
+		mbox1_ier &= ~FW_UNLOAD_INTR;
+		mbox_set_ier(MBOX_IGU1, mbox1_ier, base);
+		spin_unlock_bh(&priv->oam_lock);
+		complete(&priv->comp);
+	}
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+	if (mbox1_isr & PKT_RX_INTR) {
+		spin_lock_bh(&priv->oam_lock);
+		mbox1_ier &= ~PKT_RX_INTR;
+		mbox_set_ier(MBOX_IGU1, mbox1_ier, base);
+		spin_unlock_bh(&priv->oam_lock);
+		tasklet_schedule(&g_coc_tasklet);
+	}
+#endif
+	/**
+	 *Clear TX interrupt at this moment.
+	 * Implement flow control mechansim if there is specific requirement.
+	 */
+	mbox_clr_isr(MBOX_IGU1, mbox1_isrc, base);
+
+	return IRQ_HANDLED;
+}
+
+/* Description:
+ *    Enable/Disable HTU entries to capture OAM cell.
+ *  Input:
+ *    none
+ *  Output:
+ *    none
+ */
+static void validate_oam_htu_entry(u32 base, int en)
+{
+	struct htu_entry entry;
+	int i;
+
+	for (i = OAM_F4_SEG_HTU_ENTRY; i <= OAM_F5_HTU_ENTRY; i++) {
+		dword_mem_read(&entry, SB_BUFFER(HTU_ENTRY_TBL(i)),
+			sizeof(entry), base);
+		entry.vld = en;
+		dword_mem_write(SB_BUFFER(HTU_ENTRY_TBL(i)), &entry,
+			sizeof(entry), base);
+	}
+	/*  idle for a while to finish running HTU search   */
+	udelay(10);
+}
+
+/* Description:
+ *    Add one entry to HTU table.
+ *  Input:
+ *    vpi        --- unsigned int, virtual path ID
+ *    vci        --- unsigned int, virtual channel ID
+ *    connection --- unsigned int, connection ID
+ *    aal5       --- int, 0 means AAL0, else means AAL5
+ *  Output:
+ *    none
+ */
+static void set_htu_entry(struct vrx318_atm_tc *priv, unsigned int vpi,
+			unsigned int vci, unsigned int conn, int aal5)
+{
+	int ep_id = priv->ep_id;
+	u32 base = (u32)priv->frwk->ep_dev[ep_id].membase;
+
+	struct htu_entry htu_entry = {
+		.res1 = 0x00,
+		.pid  = priv->conn[conn].port & 0x01,
+		.vpi  = vpi,
+		.vci  = vci,
+		.pti  = 0x00,
+		.vld  = 0x01};
+
+	struct htu_mask htu_mask = {
+		.set      = 0x03,
+		.pid_mask = 0x02,
+		.vpi_mask = 0x00,
+		.vci_mask = 0x0000,
+		.pti_mask = 0x03, /* 0xx, user data */
+		.clear    = 0x00};
+
+	struct htu_result htu_result = {
+		.res1   = 0x00,
+		.cellid = conn,
+		.res2   = 0x00,
+		.type   = aal5 ? 0x00 : 0x01,
+		.ven    = 0x01,
+		.res3   = 0x00,
+		.qid    = conn};
+
+	dword_mem_write(SB_BUFFER(HTU_RESULT_TBL(conn + OAM_HTU_ENTRY_NUMBER)),
+		&htu_result, sizeof(htu_result), base);
+	dword_mem_write(SB_BUFFER(HTU_MASK_TBL(conn + OAM_HTU_ENTRY_NUMBER)),
+		&htu_mask, sizeof(htu_mask), base);
+	dword_mem_write(SB_BUFFER(HTU_ENTRY_TBL(conn + OAM_HTU_ENTRY_NUMBER)),
+		&htu_entry, sizeof(htu_entry), base);
+}
+
+/* Description:
+ *    Remove one entry from HTU table.
+ *  Input:
+ *    conn --- unsigned int, connection ID
+ *  Output:
+ *    none
+ */
+static void clear_htu_entry(unsigned int conn, u32 base)
+{
+	struct htu_entry entry;
+
+	dword_mem_read(&entry,
+		SB_BUFFER(HTU_ENTRY_TBL(conn + OAM_HTU_ENTRY_NUMBER)),
+		sizeof(entry), base);
+	entry.vld = 0;
+	dword_mem_write(SB_BUFFER(HTU_ENTRY_TBL(conn + OAM_HTU_ENTRY_NUMBER)),
+		&entry,	sizeof(entry), base);
+}
+
+
+/* QSB in VRX318 is fixed CLK 288Mhz (System CLK)*/
+static u32 get_qsb_clk(u32 base)
+{
+	u32 fpi_dvsn;
+	u32 freq;
+
+	fpi_dvsn = (vrx318_r32(CGU_CLKFSR, base) >> 28) & 0x03;
+
+	freq = VRX318_SYS_CLK;
+
+	freq = freq >> fpi_dvsn;
+
+	return freq;
+}
+
+/* Description: Setup QSB. */
+static void qsb_global_set(struct vrx318_atm_tc *priv, u32 base)
+{
+	u32 qsb_clk = get_qsb_clk(base);
+	int i;
+	u32 tmp1, tmp2, tmp3;
+	u32 reg_val;
+	struct vrx318_param *param = &priv->frwk->param;
+
+	vrx318_w32(param->qsb_tau, QSB_ICDV, base);
+	vrx318_w32(param->qsb_srvm, QSB_SBL, base);
+	vrx318_w32(param->qsb_tstep >> 1, QSB_CFG, base);
+
+	/* set SCT and SPT per port */
+	for (i = 0; i < ATM_PORT_NUMBER; i++)
+		if (priv->port[i].tx_max_cell_rate != 0) {
+			tmp1 = ((qsb_clk * priv->frwk->param.qsb_tstep) >> 1) /
+					priv->port[i].tx_max_cell_rate;
+			tmp2 = tmp1 >> 6; /* integer value of Tsb */
+			/* fractional part of Tsb */
+			tmp3 = (tmp1 & ((1 << 6) - 1)) + 1;
+			/*  carry over to integer part (?)  */
+			if (tmp3 == (1 << 6)) {
+				tmp3 = 0;
+				tmp2++;
+			}
+			if (tmp2 == 0)
+				tmp2 = tmp3 = 1;
+			/*  1. set mask  */
+			/*  2. write value to data transfer register */
+			/*  3. start the tranfer */
+			/*  SCT (FracRate)  */
+			vrx318_w32(QSB_SET_SCT_MASK, QSB_RTM, base);
+			vrx318_w32(tmp3, QSB_RTD, base);
+			reg_val = QSB_RAMAC_RW_SET(QSB_RAMAC_RW_WRITE) |
+					QSB_RAMAC_TSEL_SET(QSB_RAMAC_TSEL_SCT) |
+					QSB_RAMAC_LH_SET(QSB_RAMAC_LH_LOW) |
+					QSB_RAMAC_TESEL_SET(i & 0x01);
+			vrx318_w32(reg_val, QSB_RAMAC, base);
+
+			/*  SPT (SBV + PN + IntRage)    */
+			vrx318_w32(QSB_SET_SPT_MASK, QSB_RTM, base);
+			reg_val = QSB_RTD_TTV_SET(QSB_SPT_SBV_VALID) |
+					QSB_SPT_PN_SET(i & 0x01) |
+					QSB_SPT_INTRATE_SET(tmp2);
+			vrx318_w32(reg_val, QSB_RTD, base);
+			reg_val = QSB_RAMAC_RW_SET(QSB_RAMAC_RW_WRITE) |
+					QSB_RAMAC_TSEL_SET(QSB_RAMAC_TSEL_SPT) |
+					QSB_RAMAC_LH_SET(QSB_RAMAC_LH_LOW) |
+					QSB_RAMAC_TESEL_SET(i & 0x01);
+			vrx318_w32(reg_val, QSB_RAMAC, base);
+
+		}
+}
+
+static inline void qsb_qos_dbg(struct atm_qos *qos)
+{
+	static char *str_tc[] = {
+	    "ATM_NONE",
+	    "ATM_UBR",
+	    "ATM_CBR",
+	    "ATM_VBR",
+	    "ATM_ABR",
+	    "ATM_ANYCLASS",
+	    "ATM_VBR_RT",
+	    "ATM_UBR_PLUS",
+	    "ATM_MAX_PCR"
+	};
+
+	unsigned char tc = qos->txtp.traffic_class;
+	int max_pcr = qos->txtp.max_pcr;
+	int pcr = qos->txtp.pcr;
+	int min_pcr = qos->txtp.min_pcr;
+	int scr = qos->txtp.scr;
+	int mbs = qos->txtp.mbs;
+	int cdv = qos->txtp.cdv;
+
+	if (tc == (unsigned char)ATM_MAX_PCR)
+		vrx318_dbg(DBG_QOS, "Traffic Class: %s\n",
+			str_tc[ARRAY_SIZE(str_tc) - 1]);
+	else if (tc > ATM_UBR_PLUS)
+		vrx318_dbg(DBG_QOS, "Traffic Class: Unknown Traffic Class\n");
+	else
+		vrx318_dbg(DBG_QOS, "%s\n", str_tc[tc]);
+
+	vrx318_dbg(DBG_QOS, "max pcr: %d\n", max_pcr);
+	vrx318_dbg(DBG_QOS, "desired pcr: %d\n", pcr);
+	vrx318_dbg(DBG_QOS, "min pcr: %d\n", min_pcr);
+
+	vrx318_dbg(DBG_QOS, "sustained rate: %d\n", scr);
+	vrx318_dbg(DBG_QOS, "max burst size: %d\n", mbs);
+	vrx318_dbg(DBG_QOS, "cell delay var: %d\n", cdv);
+}
+
+static inline void qsb_param_dbg(unsigned int qsb_clk,
+			union qsb_queue_parameter_table *q_parm_tbl,
+			union qsb_queue_vbr_parameter_table *q_vbr_parm_tbl)
+{
+	vrx318_dbg(DBG_QOS, "qsb_clk = %lu\n", (unsigned long)qsb_clk);
+	vrx318_dbg(DBG_QOS, "qsb_queue_parameter_table.bit.tp       = %d\n",
+				(int)q_parm_tbl->bit.tp);
+	vrx318_dbg(DBG_QOS, "qsb_queue_parameter_table.bit.wfqf     = %d (0x%08X)\n",
+				(int)q_parm_tbl->bit.wfqf,
+				(int)q_parm_tbl->bit.wfqf);
+	vrx318_dbg(DBG_QOS, "qsb_queue_parameter_table.bit.vbr      = %d\n",
+				(int)q_parm_tbl->bit.vbr);
+	vrx318_dbg(DBG_QOS, "qsb_queue_parameter_table.dword        = 0x%08X\n",
+				(int)q_parm_tbl->dword);
+	vrx318_dbg(DBG_QOS, "qsb_queue_vbr_parameter_table.bit.ts   = %d\n",
+				(int)q_vbr_parm_tbl->bit.ts);
+	vrx318_dbg(DBG_QOS, "qsb_queue_vbr_parameter_table.bit.taus = %d\n",
+				(int)q_vbr_parm_tbl->bit.taus);
+	vrx318_dbg(DBG_QOS, "qsb_queue_vbr_parameter_table.dword    = 0x%08X\n",
+				(int)q_vbr_parm_tbl->dword);
+}
+/* Description:
+ *    Setup QSB queue.
+ *  Input:
+ *    vcc        --- struct atm_vcc *, structure of an opened connection
+ *    qos        --- struct atm_qos *, QoS parameter of the connection
+ *    connection --- unsigned int, QSB queue ID, which is same as connection ID
+ *  Output:
+ *    none
+ */
+static void set_qsb(struct vrx318_atm_tc *priv, struct atm_vcc *vcc,
+		struct atm_qos *qos, unsigned int conn)
+{
+	union qsb_queue_parameter_table q_parm_tbl = { { 0 } };
+	union qsb_queue_vbr_parameter_table q_vbr_parm_tbl = { { 0 } };
+	unsigned int tmp, reg_val;
+	int ep_id = priv->ep_id;
+	u32 base = (u32)priv->frwk->ep_dev[ep_id].membase;
+	unsigned int qsb_clk = get_qsb_clk(base);
+	struct vrx318_param *param = &priv->frwk->param;
+	int port;
+	unsigned int max_pcr;
+
+	qsb_qos_dbg(qos);
+	conn += QSB_QUEUE_NUMBER_BASE; /* qsb qid = firmware qid + 1 */
+
+	/* Peak Cell Rate (PCR) Limiter */
+	if (qos->txtp.max_pcr == 0)
+		q_parm_tbl.bit.tp = 0; /* disable PCR limiter */
+	else {
+		/*  peak cell rate would be slightly lower than requested
+		 [maximum_rate / pcr = (qsb_clock / 8) * (time_step / 4) / pcr]
+		*/
+		tmp = ((qsb_clk * param->qsb_tstep) >> 5) / qos->txtp.max_pcr
+			+ 1;
+		/*  check if overflow takes place   */
+		q_parm_tbl.bit.tp
+			= tmp > QSB_TP_TS_MAX ? QSB_TP_TS_MAX : tmp;
+	}
+
+	/* A funny issue. Create two PVCs, one UBR and one UBR with max_pcr.
+	* Send packets to these two PVCs at same time,
+	* it triggers strange behavior.
+	* In A1, RAM from 0x80000000 to 0x0x8007FFFF was corrupted
+	* with fixed pattern 0x00000000 0x40000000.
+	* In A4, PPE firmware keep emiting unknown cell
+	* and no more response to driver.
+	* To work around, create UBR always with max_pcr.
+	* If user want to create UBR without max_pcr,
+	* we give a default one larger than line-rate.
+	*/
+	if (qos->txtp.traffic_class == ATM_UBR &&
+		q_parm_tbl.bit.tp == 0) {
+		port = priv->conn[conn - QSB_QUEUE_NUMBER_BASE].port;
+		max_pcr = priv->port[port].tx_max_cell_rate + 1000;
+
+		tmp = ((qsb_clk * param->qsb_tstep) >> 5) / max_pcr + 1;
+		if (tmp > QSB_TP_TS_MAX)
+			tmp = QSB_TP_TS_MAX;
+		else if (tmp < 1)
+			tmp = 1;
+		q_parm_tbl.bit.tp = tmp;
+	}
+
+	/* Weighted Fair Queueing Factor (WFQF) */
+	switch (qos->txtp.traffic_class) {
+	case ATM_CBR:
+	case ATM_VBR_RT:
+		/*  real time queue gets weighted fair queueing bypass  */
+		q_parm_tbl.bit.wfqf = 0;
+		break;
+	case ATM_VBR_NRT:
+	case ATM_UBR_PLUS:
+		/*  WFQF calculation here is based on virtual cell rates,
+		      to reduce granularity for high rates
+		*/
+		/*  WFQF is maximum cell rate / garenteed cell rate */
+		/*  wfqf = qsb_minimum_cell_rate * QSB_WFQ_NONUBR_MAX /
+			requested_minimum_peak_cell_rate
+		*/
+		if (qos->txtp.min_pcr == 0)
+			q_parm_tbl.bit.wfqf = QSB_WFQ_NONUBR_MAX;
+		else {
+			tmp = QSB_GCR_MIN * QSB_WFQ_NONUBR_MAX /
+				qos->txtp.min_pcr;
+			if (tmp == 0)
+				q_parm_tbl.bit.wfqf = 1;
+			else if (tmp > QSB_WFQ_NONUBR_MAX)
+				q_parm_tbl.bit.wfqf
+					= QSB_WFQ_NONUBR_MAX;
+			else
+				q_parm_tbl.bit.wfqf = tmp;
+		}
+		break;
+
+	case ATM_UBR:
+	default:
+		q_parm_tbl.bit.wfqf = QSB_WFQ_UBR_BYPASS;
+		break;
+	}
+
+	/* Sustained Cell Rate (SCR) Leaky Bucket Shaper VBR.0/VBR.1 */
+	if (qos->txtp.traffic_class == ATM_VBR_RT ||
+		qos->txtp.traffic_class == ATM_VBR_NRT) {
+		if (qos->txtp.scr == 0) {
+			/* disable shaper */
+			q_vbr_parm_tbl.bit.taus = 0;
+			q_vbr_parm_tbl.bit.ts = 0;
+		} else {
+			/* Cell Loss Priority  (CLP) */
+			if ((vcc->atm_options & ATM_ATMOPT_CLP))
+				/* CLP1 */
+				q_parm_tbl.bit.vbr = 1;
+			else
+				/* CLP0 */
+				q_parm_tbl.bit.vbr = 0;
+			/* Rate Shaper Parameter (TS) and
+			    Burst Tolerance Parameter for SCR (tauS)
+			*/
+			tmp = ((qsb_clk * param->qsb_tstep) >> 5) /
+					qos->txtp.scr + 1;
+			q_vbr_parm_tbl.bit.ts
+				= tmp > QSB_TP_TS_MAX ? QSB_TP_TS_MAX : tmp;
+			tmp = (qos->txtp.mbs - 1) *
+				(q_vbr_parm_tbl.bit.ts -
+					q_parm_tbl.bit.tp) / 64;
+			if (tmp == 0)
+				q_vbr_parm_tbl.bit.taus = 1;
+			else if (tmp > QSB_TAUS_MAX)
+				q_vbr_parm_tbl.bit.taus
+					= QSB_TAUS_MAX;
+			else
+				q_vbr_parm_tbl.bit.taus = tmp;
+		}
+	} else {
+		q_vbr_parm_tbl.bit.taus = 0;
+		q_vbr_parm_tbl.bit.ts = 0;
+	}
+
+	/* Queue Parameter Table (QPT) */
+	vrx318_w32(QSB_QPT_SET_MASK, QSB_RTM, base);
+	vrx318_w32(q_parm_tbl.dword, QSB_RTD, base);
+	reg_val = QSB_RAMAC_RW_SET(QSB_RAMAC_RW_WRITE) |
+			QSB_RAMAC_TSEL_SET(QSB_RAMAC_TSEL_QPT) |
+			QSB_RAMAC_LH_SET(QSB_RAMAC_LH_LOW) |
+			QSB_RAMAC_TESEL_SET(conn);
+	vrx318_w32(reg_val, QSB_RAMAC, base);
+
+	/* Queue VBR Paramter Table (QVPT) */
+	vrx318_w32(QSB_QVPT_SET_MASK, QSB_RTM, base);
+	vrx318_w32(q_vbr_parm_tbl.dword, QSB_RTD, base);
+	reg_val = QSB_RAMAC_RW_SET(QSB_RAMAC_RW_WRITE) |
+			QSB_RAMAC_TSEL_SET(QSB_RAMAC_TSEL_VBR) |
+			QSB_RAMAC_LH_SET(QSB_RAMAC_LH_LOW) |
+			QSB_RAMAC_TESEL_SET(conn);
+	vrx318_w32(reg_val, QSB_RAMAC, base);
+
+	qsb_param_dbg(qsb_clk, &q_parm_tbl, &q_vbr_parm_tbl);
+	vrx318_dbg(DBG_EVENT, "QSB setting for conn: %d is done\n", conn - 1);
+}
+
+
+/*  Description:
+ *    Loop up for connection ID with atm_vcc structure.
+ *  Input:
+ *    vcc --- struct atm_vcc *, atm_vcc structure of opened connection
+ *  Output:
+ *    int --- negative value: failed
+ *            else          : connection ID
+ */
+static int find_vcc(struct atm_vcc *vcc)
+{
+	int i;
+	struct vrx318_atm_tc *priv;
+	struct atm_pvc *conn;
+	int max_pvc = pvc_num();
+
+	if (!vcc)
+		return -ENODEV;
+
+	priv = g_atm_tc;
+	conn = priv->conn;
+
+	for (i = 0; i < max_pvc; i++)
+		if ((priv->pvc_tbl & (1 << i))
+			&& conn[i].vcc == vcc)
+			return i;
+
+	return -ENODEV;
+}
+
+static void mpoa_setup_sync(struct vrx318_atm_tc *priv, int conn, u32 base)
+{
+	unsigned int sw_txq_tbl;
+	int sw_tx_queue;
+	wrx_queue_config_t rx_qcfg;
+	wtx_queue_config_t tx_qcfg;
+	struct dp_subif dp_id;
+	struct uni_cell_header *cell_header;
+	struct atm_vcc *vcc;
+	struct vrx318_param *param = &priv->frwk->param;
+	struct net_device *dev;
+	char dev_name[32];
+
+	dp_id.port_id = priv->frwk->port_id;
+	dp_id.subif = -1;
+
+	if (conn < 0 || conn >= ATM_PVC_NUMBER) {
+		vrx318_dbg(DBG_EVENT, "%s: conn: %d is illegal\n", __func__, conn);
+		return;
+	}
+
+	dev = priv->conn[conn].dev;
+	vrx318_dbg(DBG_EVENT, "sync: conn: %d, vpi: %d, vci: %d, mpoa_type: %d, mpoa_mode: %d\n",
+		conn, priv->conn[conn].vcc->vpi, priv->conn[conn].vcc->vci,
+		priv->conn[conn].mpoa_type, priv->conn[conn].mpoa_mode);
+
+	if (!dev)
+		sprintf(dev_name, "atm_%d%d",
+			priv->conn[conn].vcc->vpi, priv->conn[conn].vcc->vci);
+
+	if (dp_register_subif(priv->frwk->owner, dev, (!dev) ? dev_name : dev->name,
+			&dp_id, 0) != DP_SUCCESS) {
+		vrx318_dbg(DBG_ERR,
+			"%s: Failed to regsiter sub itf: dev: %s, dp_id: %d, subif: %d\n",
+			__func__, (!dev) ? "" : dev->name,
+			dp_id.port_id, dp_id.subif);
+	}
+	priv->conn[conn].subif_id = dp_id.subif;
+	vcc = priv->conn[conn].vcc;
+
+	/*  set htu entry   */
+	set_htu_entry(priv, vcc->vpi, vcc->vci, conn,
+		vcc->qos.aal == ATM_AAL5 ? 1 : 0);
+
+	dword_clear(&rx_qcfg, sizeof(rx_qcfg));
+	/* setup RX queue cfg and TX queue cfg */
+	rx_qcfg.new_vlan	= 0; /* No Vlan insert for GRX500 */
+	rx_qcfg.vlan_ins	= 0; /* No Vlan insert */
+	rx_qcfg.mpoa_type	= priv->conn[conn].mpoa_type;
+	rx_qcfg.ip_ver		= ATM_IP_IPV4; /* set IPv4 as default */
+	rx_qcfg.mpoa_mode	= priv->conn[conn].mpoa_mode;
+	rx_qcfg.oversize	= param->aal5r_max_pktsz;
+	rx_qcfg.undersize	= param->aal5r_min_pktsz;
+	rx_qcfg.mfs		= param->aal5s_max_pktsz;
+	rx_qcfg.cpimask		= 0xFF;
+	rx_qcfg.uumask		= 0xFF;
+
+	dword_mem_write(SB_BUFFER(WRX_Q_CFG(conn)), &rx_qcfg,
+			sizeof(rx_qcfg), base);
+
+	dword_clear(&tx_qcfg, sizeof(tx_qcfg));
+	/* only one TX queue is assigned now */
+	/* use ioctl/proc to add other TX queues */
+	tx_qcfg.same_vc_qmap   = 0x00;
+	tx_qcfg.sbid           = priv->conn[conn].port;
+	/* qsb qid = firmware qid + 1 */
+	tx_qcfg.qsb_vcid       = conn + QSB_QUEUE_NUMBER_BASE;
+	tx_qcfg.mpoa_mode      = priv->conn[conn].mpoa_mode;
+	/* reserved in A4, however put 1 for backward compatible */
+	tx_qcfg.qsben          = 1;
+
+	cell_header = (struct uni_cell_header *)((unsigned int *)&tx_qcfg + 2);
+	cell_header->clp = (vcc->atm_options & ATM_ATMOPT_CLP) ? 1 : 0;
+	cell_header->pti = ATM_PTI_US0;
+	cell_header->vci = vcc->vci;
+	cell_header->vpi = vcc->vpi;
+	cell_header->gfc = 0;
+
+	for (sw_txq_tbl = priv->conn[conn].sw_txq_tbl, sw_tx_queue = 0;
+		sw_tx_queue < pvc_num();
+		sw_tx_queue++) {
+		if ((sw_txq_tbl & BIT(sw_tx_queue)) != 0) {
+			tx_qcfg.same_vc_qmap
+				= sw_txq_tbl & ~(BIT(sw_tx_queue));
+			dword_mem_write(
+				SB_BUFFER(WTX_Q_CFG(sw_tx_queue)),
+				&tx_qcfg, sizeof(tx_qcfg), base);
+		}
+	}
+
+	/*  set qsb */
+	set_qsb(priv, vcc, &vcc->qos, conn);
+
+}
+
+static void mpoa_setup(struct atm_vcc *vcc, int mpoa_type,
+			int f_llc, struct net_device *dev)
+{
+	int conn;
+	struct vrx318_atm_tc *priv;
+	int ep_id;
+	u32 base;
+
+	vrx318_dbg(DBG_EVENT, "Add VPC/VCI: mpoa_type: %d, f_llc: %d, dev: %s\n",
+		mpoa_type, f_llc, dev->name);
+	priv = (struct vrx318_atm_tc *)vcc->dev->dev_data;
+	ep_id = priv->ep_id;
+	base = (u32)priv->frwk->ep_dev[ep_id].membase;
+
+	spin_lock_bh(&priv->atm_lock);
+	conn = find_vcc(vcc);
+	if (conn < 0)
+		goto err1;
+
+	priv->conn[conn].dev = dev;
+	priv->conn[conn].mpoa_mode = f_llc;
+	priv->conn[conn].mpoa_type = mpoa_type;
+	spin_unlock_bh(&priv->atm_lock);
+
+	mpoa_setup_sync(priv, conn, base);
+
+	return;
+
+err1:
+	spin_unlock_bh(&priv->atm_lock);
+	return;
+}
+
+static void setup_oam_htu_entry(struct vrx318_atm_tc *priv, u32 base)
+{
+	struct htu_entry htu_entry = {0};
+	struct htu_result htu_result = {0};
+	struct htu_mask htu_mask = {0};
+	int ven = 1;
+	int i;
+	int max_pvc = pvc_num();
+
+	if (priv->frwk->param.dfe_loopback)
+		ven = 0;
+	else
+		ven = 1;
+
+	htu_mask.set = 0x03;
+
+	/* Clear HTU Tables */
+	for (i = 0; i < max_pvc; i++) {
+		htu_result.qid = (unsigned int)i;
+		dword_mem_write(
+			SB_BUFFER(HTU_ENTRY_TBL(i + OAM_HTU_ENTRY_NUMBER)),
+			&htu_entry, sizeof(htu_entry), base);
+		dword_mem_write(
+			SB_BUFFER(HTU_MASK_TBL(i + OAM_HTU_ENTRY_NUMBER)),
+			&htu_mask, sizeof(htu_mask), base);
+		dword_mem_write(
+			SB_BUFFER(HTU_RESULT_TBL(i + OAM_HTU_ENTRY_NUMBER)),
+			&htu_result, sizeof(htu_result), base);
+	}
+
+	/*  OAM HTU Entry   */
+	htu_entry.vci		= 0x03;
+	htu_mask.pid_mask	= 0x03;
+	htu_mask.vpi_mask	= 0xFF;
+	htu_mask.vci_mask	= 0x0000;
+	htu_mask.pti_mask	= 0x07;
+	htu_result.cellid	= 0;
+	htu_result.type		= 1;
+	htu_result.ven		= ven;
+	htu_result.qid		= 0;
+	dword_mem_write(SB_BUFFER(HTU_RESULT_TBL(OAM_F4_SEG_HTU_ENTRY)),
+		&htu_result, sizeof(htu_result), base);
+	dword_mem_write(SB_BUFFER(HTU_MASK_TBL(OAM_F4_SEG_HTU_ENTRY)),
+		&htu_mask, sizeof(htu_mask), base);
+	dword_mem_write(SB_BUFFER(HTU_ENTRY_TBL(OAM_F4_SEG_HTU_ENTRY)),
+		&htu_entry, sizeof(htu_entry), base);
+
+	htu_entry.vci		= 0x04;
+	htu_result.cellid	= 0;
+	htu_result.type		= 1;
+	htu_result.ven		= ven;
+	htu_result.qid		= 0;
+	dword_mem_write(SB_BUFFER(HTU_RESULT_TBL(OAM_F4_TOT_HTU_ENTRY)),
+		&htu_result, sizeof(htu_result), base);
+	dword_mem_write(SB_BUFFER(HTU_MASK_TBL(OAM_F4_TOT_HTU_ENTRY)),
+		&htu_mask, sizeof(htu_mask), base);
+	dword_mem_write(SB_BUFFER(HTU_ENTRY_TBL(OAM_F4_TOT_HTU_ENTRY)),
+		&htu_entry, sizeof(htu_entry), base);
+
+	htu_entry.vci		= 0x00;
+	htu_entry.pti		= 0x04;
+	htu_mask.vci_mask	= 0xFFFF;
+	htu_mask.pti_mask	= 0x01;
+	htu_result.cellid	= 0;
+	htu_result.type		= 1;
+	htu_result.ven		= ven;
+	htu_result.qid		= 0;
+	dword_mem_write(SB_BUFFER(HTU_RESULT_TBL(OAM_F5_HTU_ENTRY)),
+		&htu_result, sizeof(htu_result), base);
+	dword_mem_write(SB_BUFFER(HTU_MASK_TBL(OAM_F5_HTU_ENTRY)),
+		&htu_mask, sizeof(htu_mask), base);
+	dword_mem_write(SB_BUFFER(HTU_ENTRY_TBL(OAM_F5_HTU_ENTRY)),
+		&htu_entry, sizeof(htu_entry), base);
+}
+
+static int atm_showtime_enter(const unsigned char line_idx,
+		struct port_cell_info *port_cell, void *xdata_addr)
+{
+	int i, j;
+	struct vrx318_atm_tc *priv = g_atm_tc;
+	u32 base;
+
+	if (!priv)
+		return -ENODEV;
+
+	base = (u32)priv->frwk->ep_dev[priv->ep_id].membase;
+	VRX318_ASSERT(port_cell == NULL, "port_cell is NULL");
+	VRX318_ASSERT(xdata_addr != NULL, "xdata_addr is NOT NULL");
+
+	if (port_cell == NULL)
+		return -EINVAL;
+
+	if (line_idx != priv->ep_id)
+		return 0;
+
+	for (j = 0; j < ATM_PORT_NUMBER && j < port_cell->port_num; j++)
+		if (port_cell->tx_link_rate[j] > 0)
+			break;
+
+	if (j >= ATM_PORT_NUMBER) {
+		vrx318_dbg(DBG_ERR, "Invalid tx link rate: %d, %d\n",
+			port_cell->tx_link_rate[0],
+			port_cell->tx_link_rate[1]);
+		return -EINVAL;
+	}
+	for (i = 0; i < ATM_PORT_NUMBER && i < port_cell->port_num; i++)
+		priv->port[i].tx_max_cell_rate
+			= port_cell->tx_link_rate[i] > 0 ?
+				port_cell->tx_link_rate[i] :
+				port_cell->tx_link_rate[j];
+
+	qsb_global_set(priv, base);
+
+	for (i = 0; i < pvc_num(); i++)
+		if ((priv->pvc_tbl & BIT(i)) && priv->conn[i].vcc != NULL)
+			set_qsb(priv, priv->conn[i].vcc,
+				&priv->conn[i].vcc->qos, i);
+
+	spin_lock_bh(&priv->frwk->fw_lock);
+	if (priv->frwk->tc_stat == VRX318_RUNNING)
+		priv->frwk->show_time_stat[line_idx] = 1;
+	else
+		vrx318_dbg(DBG_ERR, "ATM reach show time while TC status is not running!!!, line: %d, tc stat: %d\n",
+			line_idx, priv->frwk->tc_stat);
+	spin_unlock_bh(&priv->frwk->fw_lock);
+
+	vrx318_dbg(DBG_INFO, "ATM line[%d]:enter showtime, cell rate: 0 - %d, 1 - %d\n",
+		line_idx, priv->port[0].tx_max_cell_rate,
+		priv->port[1].tx_max_cell_rate);
+
+	return 0;
+}
+
+static int atm_showtime_exit(const unsigned char line_idx)
+{
+	if (!g_atm_tc || g_atm_tc->ep_id != line_idx)
+		return 0;
+
+	g_atm_tc->frwk->show_time_stat[line_idx] = 0;
+	/* cbm_dp_enable(g_atm_tc->frwk->owner, g_atm_tc->frwk->port_id,
+		CBM_F_DPATH_DISABLE);
+	*/
+
+	vrx318_dbg(DBG_INFO, "ATM line[%d]:leave showtime\n", line_idx);
+
+	return 0;
+}
+
+static int atm_get_pvc_id(struct sk_buff *skb)
+{
+	struct pmac_rx_hdr *pmac_hdr = (struct pmac_rx_hdr *)skb->data;
+
+	return (pmac_hdr->src_sub_inf_id2 >> 1) & 0xF;
+}
+
+static inline void dump_atm_data(unsigned char *data, int len, int rx)
+{
+	if (rx) {
+		if (g_vrx318_dbg & DBG_PKT_RX_DUMP)
+			dp_dump_raw_data(data, len, "Dump atm rx data");
+	} else {
+		if (g_vrx318_dbg & DBG_PKT_TX_DUMP)
+			dp_dump_raw_data(data, len, "Dump atm tx data");
+	}
+}
+
+static void atm_encapsulate_frame(struct sk_buff *skb, int conn)
+{
+	unsigned int proto_type;
+	int mpoa_type, mpoa_mode;
+
+	mpoa_type = g_atm_tc->conn[conn].mpoa_type;
+	mpoa_mode = g_atm_tc->conn[conn].mpoa_mode;
+
+	/* ETH packet, need recover ATM encapsulation  */
+	if (mpoa_mode) {
+		/*  LLC */
+		switch (mpoa_type) {
+		case 0: /* EoA w/o FCS */
+			VRX318_ASSERT(skb_headroom(skb) >= 10,
+				"not enough skb headroom (LLC EoA w/o FCS)");
+			skb_push(skb, 10);
+			((u32 *)skb->data)[0] = 0xAAAA0300;
+			((u32 *)skb->data)[1] = 0x80C20007;
+			((u16 *)skb->data)[4] = 0x0000;
+			break;
+
+		case 1: /* EoA w FCS */
+			VRX318_ASSERT(skb_headroom(skb) >= 10,
+				"not enough skb headroom (LLC EoA w FCS)");
+			skb_push(skb, 10);
+			((u32 *)skb->data)[0] = 0xAAAA0300;
+			((u32 *)skb->data)[1] = 0x80C20001;
+			((u16 *)skb->data)[4] = 0x0000;
+			break;
+
+		case 2: /* PPPoA */
+			proto_type = ntohs(*(u16 *)(skb->data + 12));
+			switch (proto_type) {
+			case 0x0800:
+				proto_type = 0x0021;
+				break;
+			case 0x86DD:
+				proto_type = 0x0057;
+				break;
+			}
+			skb_pull(skb, ETH_HLEN - 6);
+			((u32 *)skb->data)[0] = 0xFEFE03CF;
+			((u16 *)skb->data)[2] = (u16)proto_type;
+			break;
+
+		case 3: /*  IPoA */
+			skb_pull(skb, ETH_HLEN - 8);
+			((u32 *)skb->data)[0] = 0xAAAA0300;
+			((u16 *)skb->data)[2] = 0x0000;
+			break;
+		}
+	} else {
+		/*  VC-mux  */
+		switch (mpoa_type) {
+		case 0: /* EoA w/o FCS */
+			VRX318_ASSERT(skb_headroom(skb) >= 2,
+				"not enough skb headroom (VC-mux EoA w/o FCS)");
+			skb_push(skb, 2);
+			*(u16 *)skb->data = 0x0000;
+			break;
+
+		case 1: /* EoA w FCS */
+			VRX318_ASSERT(skb_headroom(skb) >= 2,
+				"not enough skb headroom (VC-mux EoA w FCS)");
+			skb_push(skb, 2);
+			*(u16 *)skb->data = 0x0000;
+			break;
+
+		case 2: /* PPPoA */
+			proto_type = ntohs(*(u16 *)(skb->data + 12));
+			switch (proto_type) {
+			case 0x0800:
+				proto_type = 0x0021;
+				break;
+			case 0x86DD:
+				proto_type = 0x0057;
+				break;
+			}
+			skb_pull(skb, ETH_HLEN - 2);
+			*(u16 *)skb->data = (u16)proto_type;
+			break;
+		case 3: /*  IPoA */
+			skb_pull(skb, ETH_HLEN);
+			break;
+		}
+	}
+	dump_atm_data(skb->data, skb->len, 1);
+}
+
+
+static int atm_push(struct net_device *rxif, struct net_device *txif,
+			struct sk_buff *skb, int32_t len)
+{
+	int conn;
+	struct atm_vcc *vcc = NULL;
+	struct vrx318_atm_tc *priv = g_atm_tc;
+	int max_pvc = pvc_num();
+
+	conn = atm_get_pvc_id(skb);
+#if defined(CONFIG_LTQ_PPA_API_SW_FASTPATH)
+    skb->mark &= ~FLG_PPA_PROCESSED;
+#endif
+
+	if (unlikely(conn < 0 || conn >= max_pvc
+		     || (priv->conn[conn].vcc == NULL)
+		     || (priv->pvc_tbl & BIT(conn)) == 0)) {
+		vrx318_dbg(DBG_PKT_RX, "invalid conn: %d or NULL Vcc\n", conn);
+
+	} else {
+		vcc = priv->conn[conn].vcc;
+		if (atm_charge(vcc, skb->truesize)) {
+
+			if (vcc->stats)
+				atomic_inc(&vcc->stats->rx);
+
+			spin_lock_bh(&priv->atm_lock);
+			if (vcc->qos.aal == ATM_AAL5) {
+				priv->stats.aal5_rx_pkts++;
+				priv->stats.aal5_rx_bytes += skb->len;
+				priv->conn[conn].stats.aal5_rx_pkts++;
+				priv->conn[conn].stats.aal5_rx_bytes
+					+= skb->len;
+			} else
+				priv->stats.aal5_rx_errors++;
+			priv->conn[conn].access_time = current_kernel_time();
+			spin_unlock_bh(&priv->atm_lock);
+
+			/* remove PMAC header */
+			skb_pull(skb, 8);
+
+			ATM_SKB(skb)->vcc = vcc;
+			atm_encapsulate_frame(skb, conn);
+
+			vcc->push(vcc, skb);
+
+			return 0;
+		} else {
+			vrx318_dbg(DBG_PKT_RX, "inactive qid %d\n", conn);
+
+			if (vcc->stats)
+				atomic_inc(&vcc->stats->rx_drop);
+
+			spin_lock_bh(&priv->atm_lock);
+			if (vcc->qos.aal == ATM_AAL5)
+				priv->stats.aal5_rx_dropped++;
+			priv->conn[conn].stats.aal5_rx_dropped++;
+			spin_unlock_bh(&priv->atm_lock);
+		}
+	}
+
+	dev_kfree_skb_any(skb);
+	return 0;
+}
+
+static int atm_get_qid_by_vcc(struct net_device *netif, struct sk_buff *skb,
+			struct atm_vcc *vcc, uint8_t dst_mac[MAX_ETH_ALEN],
+			dp_subif_t *subif, uint32_t flags)
+{
+	struct vrx318_atm_tc *priv = g_atm_tc;
+	int qid, mpoa_type, prio;
+	int conn;
+
+	if (!subif || vcc == NULL) {
+		vrx318_dbg(DBG_ERR,
+			"%s: VCC or subif is NULL\n", __func__);
+		return -EINVAL;
+	}
+
+	if (subif->port_id != priv->frwk->port_id) {
+		vrx318_dbg(DBG_ERR,
+			"%s: Port_id not compliance: Input: %d, Local: %d\n",
+			__func__, subif->port_id, priv->frwk->port_id);
+		return -EINVAL;
+	}
+
+	spin_lock_bh(&priv->atm_lock);
+	conn = find_vcc(vcc);
+	if (conn < 0) {
+		vrx318_dbg(DBG_ERR,
+			"%s: given VCC is not attached\n", __func__);
+		spin_unlock_bh(&priv->atm_lock);
+		return -ENODEV;
+
+	} else {
+		if (skb)
+			prio = skb->priority < ATM_PRIO_Q_NUM ?
+				skb->priority : ATM_PRIO_Q_NUM - 1;
+		else
+			prio = 0;
+		qid = priv->conn[conn].prio_queue_map[prio];
+		mpoa_type = priv->conn[conn].mpoa_type;
+		subif->subif = priv->conn[conn].subif_id
+				| ATM_DESC_SUBIF_ID(qid, 0, mpoa_type);
+	}
+
+	spin_unlock_bh(&priv->atm_lock);
+
+	return 0;
+}
+
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+static int32_t atm_coc_confirm_stat(enum ltq_cpufreq_state new_state,
+	enum ltq_cpufreq_state old_state,
+	uint32_t flags)
+{
+	struct vrx318_atm_tc *priv = g_atm_tc;
+	int ret = -ENODEV;
+	u32 base;
+	int ep_id;
+
+	ep_id = priv->ep_id;
+	base = (u32)priv->frwk->ep_dev[ep_id].membase;
+	vrx318_dbg(DBG_COC, "Current state: %u, old [%u] to [%u]\n",
+		atm_coc_state, (u32)old_state, (u32)new_state);
+
+	if (new_state != atm_coc_state) {
+		/* assign new state */
+		vrx318_dbg(DBG_COC, "Change from current state %u to new %u\n",
+			atm_coc_state, new_state);
+		atm_coc_state = new_state;
+		/* check for D3 state */
+		if (atm_coc_state == LTQ_CPUFREQ_PS_D3) {
+			u32 mbox1_ier;
+			vrx318_dbg(DBG_COC, "Change to D3, enable interrupt\n");
+			/* Enable interrupt for DS packet */
+			spin_lock_bh(&priv->oam_lock);
+			mbox1_ier = vrx318_r32(MBOX_IGU1_IER, base);
+			mbox_set_ier(MBOX_IGU1, mbox1_ier | PKT_RX_INTR, base);
+			spin_unlock_bh(&priv->oam_lock);
+		} else {
+			/* Disable interrupt for DS packet */
+			u32 mbox1_ier;
+			vrx318_dbg(DBG_COC, "Change to %u, disable interrupt\n", atm_coc_state);
+			/* Disable interrupt for DS packet */
+			spin_lock_bh(&priv->oam_lock);
+			mbox1_ier = vrx318_r32(MBOX_IGU1_IER, base);
+			mbox1_ier &= ~PKT_RX_INTR;
+			mbox_set_ier(MBOX_IGU1, mbox1_ier, base);
+			spin_unlock_bh(&priv->oam_lock);
+		}
+	}
+	vrx318_dbg(DBG_COC, "Complete\n");
+	return ret;
+}
+#endif
+
+static int vrx318_atm_datapath_init(struct vrx318_atm_tc *priv)
+{
+	int err;
+	struct vrx318_priv *fw_priv = priv->frwk;
+	int ep_id = priv->ep_id;
+	int irq_id = fw_priv->ep_dev[ep_id].irq;
+	u32 base = (u32)fw_priv->ep_dev[ep_id].membase;
+
+	/* request irq (enable by default) */
+	err = devm_request_irq(fw_priv->pdev, irq_id, mailbox_irq_handler, 0,
+				g_atm_dev_name, (void *)priv);
+	if (err) {
+		vrx318_dbg(DBG_ERR, "Failed to request PCIe MSI irq %u\n",
+			irq_id);
+		return err;
+	}
+
+	qsb_global_set(priv, base);
+	setup_oam_htu_entry(priv, base);
+
+	atm_hook_mpoa_setup = mpoa_setup;
+	vrx318_cb_setup(atm_push, NULL, NULL, atm_get_qid_by_vcc
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+		, atm_coc_confirm_stat
+#endif
+	);
+
+	ppa_callback_set(LTQ_MEI_SHOWTIME_ENTER, atm_showtime_enter);
+	ppa_callback_set(LTQ_MEI_SHOWTIME_EXIT, atm_showtime_exit);
+
+	return 0;
+}
+
+/* This API no lock protect, should only be called in initialization part */
+static void vrx318_atm_fw_cfg_init(struct vrx318_atm_tc *priv, u32 base)
+{
+	int conn;
+
+	if (priv->pvc_tbl)
+		validate_oam_htu_entry(base, 1);
+	else
+		return;
+
+	for (conn = 0; (priv->pvc_tbl & BIT(conn)) != 0 && conn < pvc_num(); conn++)
+		mpoa_setup_sync(priv, conn, base);
+
+}
+
+static int vrx318_atm_tc_hw_fw_init(struct vrx318_atm_tc *priv)
+{
+	int ep_id;
+	u32 base;
+
+	ep_id = priv->ep_id;
+	base = (u32)priv->frwk->ep_dev[ep_id].membase;
+
+	vrx318_dbg(DBG_INFO, "port	  = %d\n", ep_id);
+	vrx318_dbg(DBG_INFO, "irq	  = %u\n",
+		priv->frwk->ep_dev[ep_id].irq);
+	vrx318_dbg(DBG_INFO, "membase	  = 0x%08x\n",
+		(unsigned int)priv->frwk->ep_dev[ep_id].membase);
+	vrx318_dbg(DBG_INFO, "phy_membase = 0x%08x\n",
+		(unsigned int)priv->frwk->ep_dev[ep_id].phy_membase);
+
+	/* Reset PPE HW */
+	reset_ppe(base);
+	/* activate VRX318 */
+	enable_ppe_ema(base);
+	/*  Set VRX318 PPE clock 432MHz */
+	set_ppe_clk(432, base);
+	/* Set QSB CLK divisor */
+	set_qsb_clk(0, base);
+	/* clear and disable mailbox	*/
+	mbox_clr_isr(MBOX_IGU0, 0xFFFFFFFF, base);
+	mbox_clr_isr(MBOX_IGU1, 0xFFFFFFFF, base);
+	mbox_set_ier(MBOX_IGU0, 0, base);
+	mbox_set_ier(MBOX_IGU1, 0, base);
+
+	/*  freeze PP32 */
+	pp32_stop(base);
+	vrx318_ppe_atm_init(priv, 1);
+	pp32_load(base);
+
+	/* init datapath */
+	vrx318_atm_datapath_init(priv);
+
+	/* start hardware */
+	setup_dfe_loopback(priv->frwk, base);
+	pp32_start(0, base);
+	dfe_loopback_linkup(priv->frwk, base);
+
+	/* Init FW tx/rx queue /qsb configuration for pre-set PVCs */
+	vrx318_atm_fw_cfg_init(priv, base);
+
+	/* Indicate DSL FW all configuration is ready */
+	/* PPE FW is ready to receive/send packets */
+	vrx318_tc_indicate(TC_ATM_SL_MODE, base, 1);
+
+	/* enable mailbox Interrupts */
+	mbox_set_ier(MBOX_IGU0, 0, base);
+	mbox_set_ier(MBOX_IGU1, OAM_RX_INTR | FW_UNLOAD_INTR, base);/* enable OAM, TC switch */
+
+	get_fw_version(&priv->fw_ver, base);
+	print_fw_version(NULL, &priv->fw_ver);
+
+	return 0;
+}
+
+static void vrx318_atm_cfg_init(struct vrx318_priv *priv)
+{
+	/* Current ATM FW must disable cdma write */
+	priv->param.cdma_wr_en = 0;
+}
+
+int vrx318_atm_tc_init(struct vrx318_priv *frwk_priv,
+			int ep_id, enum dsl_tc_mode tc_mode)
+{
+	int err;
+	struct vrx318_atm_tc *priv;
+
+	if (!g_atm_tc) { /*First time initialization */
+		priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+		if (!priv) {
+			vrx318_dbg(DBG_ERR, "Failed to alloc priv buffer\n");
+			err = -ENOMEM;
+			goto err1;
+		}
+		priv->frwk = frwk_priv;
+		spin_lock_init(&priv->atm_lock);
+		spin_lock_init(&priv->oam_lock);
+		init_completion(&priv->comp);
+		err = vrx318_atm_init(priv);
+		if (err)
+			goto err2;
+
+		g_atm_tc = priv;
+	} else
+		priv = g_atm_tc;
+
+	vrx318_atm_cfg_init(frwk_priv);
+	priv->ep_id = ep_id;
+	err = vrx318_atm_tc_hw_fw_init(priv);
+	if (err)
+		goto err2;
+	frwk_priv->tc_priv = (void *)priv;
+	vrx318_atm_pmac_cfg_init(frwk_priv->port_id);
+	vrx318_atm_proc_init(priv);
+
+	/*netlink message for TC UP */
+	vrx_tc_msg_send(0, ATM_TC, TC_LOADED, NON_BONDING_MODE, ep_id);
+	return 0;
+
+err2:
+	kfree(priv);
+	priv = NULL;
+	g_atm_tc = NULL;
+err1:
+	return err;
+}
+
+void vrx318_atm_free_mem(struct vrx318_atm_tc *priv, u32 base)
+{
+	int i;
+	int phy_addr;
+
+	/* Free oam descriptors */
+	for (i = 0; i < priv->oam_llst.oam_num; i++)
+		cbm_buffer_free(0, priv->oam_llst.oam_des_list[i], 0);
+
+	/* Free QoS queue buffers */
+	for (i = 0; i < TOTAL_QOS_DES_NUM; i++) {
+		phy_addr = vrx318_r32_sb(__US_QOSQ_DES_LIST_BASE + (i * 2) + 1,
+					base) - VRX318_OB_BADDR;
+		cbm_buffer_free(0, phy_addr, 0);
+	}
+
+	/* Free DS AAL5 buffers, not required in GRX350 */
+}
+
+int vrx318_atm_unregister_pvc(struct vrx318_atm_tc *priv)
+{
+	int i;
+	dp_subif_t dp_id;
+	int err = 0;
+	char dev_name[32];
+
+	spin_lock_bh(&priv->atm_lock);
+	for (i = 0; i < pvc_num(); i++) {
+		if ((priv->pvc_tbl & BIT(i)) != 0) {
+			dp_id.port_id = priv->frwk->port_id;
+			dp_id.subif = priv->conn[i].subif_id;
+			if (!priv->conn[i].dev) {
+				sprintf(dev_name, "atm_%d%d",
+					priv->conn[i].vcc->vpi,
+					priv->conn[i].vcc->vci);
+			}
+			err = dp_register_subif(priv->frwk->owner,
+				priv->conn[i].dev,
+				(!priv->conn[i].dev) ?
+					dev_name : priv->conn[i].dev->name,
+				&dp_id,
+				DP_F_DEREGISTER);
+			if (err)
+				goto DP_DEREG_FAIL;
+		}
+	}
+	spin_unlock_bh(&priv->atm_lock);
+
+	return err;
+
+DP_DEREG_FAIL:
+	spin_unlock_bh(&priv->atm_lock);
+
+	return err;
+}
+
+int vrx318_unload_atm_tc(struct vrx318_priv *frwk_priv, int ep_id)
+{
+	struct vrx318_atm_tc *priv = g_atm_tc;
+	u32 base = (u32)frwk_priv->ep_dev[ep_id].membase;
+	int err;
+
+	if (in_interrupt()) {
+		vrx318_dbg(DBG_ERR, "VRX318 cannot be unloaded in interrupt context\n");
+		return -EINVAL;
+	}
+
+	if (priv != frwk_priv->tc_priv) {
+		vrx318_dbg(DBG_ERR, "TC pointer not match as ATM TC pointer\n");
+		return -ENODEV;
+	}
+
+	/* Indicate DSL FW TC Clear */
+	vrx318_tc_indicate(0, base, 0);
+
+	/* Reset xDSL MEI */
+	/* vrx318_reset_xdsl(base); */
+
+	/* Unregister PVC/subif id */
+	err = vrx318_atm_unregister_pvc(priv);
+	if (err) {
+		vrx318_dbg(DBG_TC_SWITCH, "Unregister PVC fail!\n");
+		return err;
+	}
+
+	validate_oam_htu_entry(base, 0);
+
+	/* Indicate PPE FW to stop */
+	priv->comp.done = 0;
+	vrx318_w32(1, PPE_TC_SWITCH, base);
+	err = wait_for_completion_timeout(&priv->comp,
+			msecs_to_jiffies(FW_STOP_TIMEOUT));
+
+	if (err < 0) {
+		vrx318_dbg(DBG_TC_SWITCH, "Wait process got interrupted\n");
+		return err;
+	}
+
+	if (!err)
+		vrx318_dbg(DBG_TC_SWITCH, "Wait process Timeout\n");
+
+	/* Stop PPE FW */
+	pp32_stop(base);
+
+	/* Unregister Interrupt handler */
+	devm_free_irq(frwk_priv->pdev,
+		frwk_priv->ep_dev[ep_id].irq, (void *)priv);
+	/* Kill all tasklets */
+	tasklet_kill(&g_oam_tasklet);
+	/* Disable and Clear all Interrupts */
+	mbox_set_ier(MBOX_IGU0, 0, base);
+	mbox_set_ier(MBOX_IGU1, 0, base);
+	mbox_clr_isr(MBOX_IGU0, 0xFFFFFFFF, base);
+	mbox_clr_isr(MBOX_IGU1, 0xFFFFFFFF, base);
+
+	/* Free CBM resources */
+	vrx318_atm_free_mem(priv, base);
+	/* Reset CBM EQM/DQM idx */
+	soc_vrx318_cfg_reset();
+
+	/* Free Proc */
+	vrx318_atm_proc_exit(priv);
+
+	/* netlink message for TC DOWN */
+	vrx_tc_msg_send(0, ATM_TC, TC_UNLOADED, NON_BONDING_MODE, ep_id);
+	vrx318_dbg(DBG_TC_SWITCH, "Unload ATM TC successfully!!!\n");
+
+	return err;
+}
+
+static int ppe_open(struct atm_vcc *vcc)
+{
+	int vpi = vcc->vpi;
+	int vci = vcc->vci;
+	struct vrx318_atm_tc *priv = g_atm_tc;
+	struct atm_port *port = &priv->port[(int)vcc->dev->phy_data];
+	int sw_txq;
+	int conn, i, ret;
+	u32 base;
+
+	base = (u32)priv->frwk->ep_dev[priv->ep_id].membase;
+
+	if (priv->frwk->tc_stat != VRX318_RUNNING
+		|| priv->frwk->tc_mode[priv->ep_id] != TC_ATM_SL_MODE) {
+		vrx318_dbg(DBG_ERR, "PPE Open fail! TC Status: %d, TC Mode: %d\n",
+			(u32)priv->frwk->tc_stat,
+			(u32)priv->frwk->tc_mode[priv->ep_id]);
+		return -EACCES;
+	}
+
+	if (vcc->qos.aal != ATM_AAL5 && vcc->qos.aal != ATM_AAL0) {
+		vrx318_dbg(DBG_ERR, "aal proto not supported: %d\n",
+			vcc->qos.aal);
+		return -EPROTONOSUPPORT;
+	}
+
+	/* check bandwidth */
+	if ((vcc->qos.txtp.traffic_class == ATM_CBR &&
+		vcc->qos.txtp.max_pcr >
+			(port->tx_max_cell_rate - port->tx_used_cell_rate))
+		|| (vcc->qos.txtp.traffic_class == ATM_VBR_RT &&
+		vcc->qos.txtp.max_pcr >
+			(port->tx_max_cell_rate - port->tx_used_cell_rate))
+		|| (vcc->qos.txtp.traffic_class == ATM_VBR_NRT &&
+		vcc->qos.txtp.scr >
+			(port->tx_max_cell_rate - port->tx_used_cell_rate))
+		|| (vcc->qos.txtp.traffic_class == ATM_UBR_PLUS &&
+		vcc->qos.txtp.min_pcr >
+			(port->tx_max_cell_rate - port->tx_used_cell_rate))) {
+		vrx318_dbg(DBG_ERR, "exceed TX line rate\n");
+		return -EINVAL;
+	}
+
+	/*  check existing vpi,vci  */
+	conn = find_vpivci(vpi, vci);
+	if (conn >= 0) {
+		vrx318_dbg(DBG_ERR, "existing PVC (%d.%d)\n", vpi, vci);
+		return -EADDRINUSE;
+	}
+
+	spin_lock_bh(&priv->atm_lock);
+	/*  allocate software TX queue  */
+	for (sw_txq = 0; sw_txq < txq_num(); sw_txq++)
+		if (!(priv->sw_txq_tbl & BIT(sw_txq)))
+			break;
+
+	if (sw_txq == txq_num()) {
+		ret = -ENOSPC;
+		vrx318_dbg(DBG_ERR, "no free TX queue\n");
+		goto OPEN_ERR;
+	}
+
+	if (!priv->pvc_tbl)
+		validate_oam_htu_entry(base, 1);
+	/* allocate PVC */
+	for (conn = 0; conn < pvc_num(); conn++)
+		if (!(priv->pvc_tbl & BIT(conn))) {
+			priv->sw_txq_tbl |= BIT(sw_txq);
+			priv->conn[conn].vcc = vcc;
+			priv->conn[conn].port
+				= (unsigned int)vcc->dev->phy_data;
+			priv->conn[conn].sw_txq_tbl = BIT(sw_txq);
+			for (i = 0; i < 8; i++)
+				priv->conn[conn].prio_queue_map[i] = sw_txq;
+			priv->pvc_tbl |= BIT(conn);
+			break;
+		}
+
+	if (conn >= pvc_num()) {
+		ret = -ENOSPC;
+		vrx318_dbg(DBG_ERR, "exceed PVC limit\n");
+		goto OPEN_ERR;
+	}
+	spin_unlock_bh(&priv->atm_lock);
+
+	/*  reserve bandwidth */
+	switch (vcc->qos.txtp.traffic_class) {
+	case ATM_CBR:
+	case ATM_VBR_RT:
+		port->tx_used_cell_rate += vcc->qos.txtp.max_pcr;
+		break;
+	case ATM_VBR_NRT:
+		port->tx_used_cell_rate += vcc->qos.txtp.scr;
+		break;
+	case ATM_UBR_PLUS:
+		port->tx_used_cell_rate += vcc->qos.txtp.min_pcr;
+		break;
+	}
+
+	/* update atm_vcc structure */
+	vcc->itf = (int)vcc->dev->phy_data;
+	set_bit(ATM_VF_ADDR, &vcc->flags);
+	set_bit(ATM_VF_READY, &vcc->flags);
+
+	vrx318_dbg(DBG_EVENT, "ppe_open(%d.%d): conn = %d, ep_id: %d\n",
+		vcc->vpi, vcc->vci, conn, priv->ep_id);
+
+	return 0;
+
+OPEN_ERR:
+	spin_unlock_bh(&priv->atm_lock);
+	return ret;
+}
+
+static void ppe_close(struct atm_vcc *vcc)
+{
+	int cid;
+	struct atm_port *port;
+	struct atm_pvc *conn;
+	struct vrx318_atm_tc *priv = vcc->dev->dev_data;
+	u32 base = (u32)priv->frwk->ep_dev[priv->ep_id].membase;
+	struct net_device *dev;
+	dp_subif_t dp_id;
+	char dev_name[32];
+
+	if (!vcc)
+		return;
+
+	if (priv->frwk->tc_stat != VRX318_RUNNING
+		|| priv->frwk->tc_mode[priv->ep_id] != TC_ATM_SL_MODE) {
+		vrx318_dbg(DBG_ERR, "PPE Close fail! TC Status: %d, TC Mode: %d\n",
+			priv->frwk->tc_stat, priv->frwk->tc_mode[priv->ep_id]);
+		return;
+	}
+
+	vrx318_dbg(DBG_EVENT, "ppe close, vpi:%d, vci:%d\n",
+		vcc->vpi, vcc->vci);
+
+	/*  get connection id   */
+	cid = find_vcc(vcc);
+	if (cid < 0) {
+		vrx318_dbg(DBG_ERR, "can't find vcc\n");
+		return;
+	}
+
+	conn = &priv->conn[cid];
+	port = &priv->port[conn->port];
+
+	clear_bit(ATM_VF_READY, &vcc->flags);
+	clear_bit(ATM_VF_ADDR, &vcc->flags);
+
+	/* clear htu */
+	clear_htu_entry(cid, base);
+
+	/*  release connection  */
+	spin_lock_bh(&priv->atm_lock);
+	priv->pvc_tbl &= ~(BIT(cid));
+	priv->sw_txq_tbl &= ~(conn->sw_txq_tbl);
+	dev = conn->dev;
+	if (!dev)
+		sprintf(dev_name, "atm_%d%d",
+			conn->vcc->vpi, conn->vcc->vci);
+	dp_id.port_id = priv->frwk->port_id;
+	dp_id.subif = conn->subif_id;
+	memset(conn, 0, sizeof(*conn));
+	if (priv->pvc_tbl == 0)
+		validate_oam_htu_entry(base, 0);
+	spin_unlock_bh(&priv->atm_lock);
+
+	/* Unregister subif from datapath lib */
+	if (dp_register_subif(priv->frwk->owner, dev, (!dev) ? dev_name : dev->name,
+			&dp_id, DP_F_DEREGISTER) != DP_SUCCESS)
+		vrx318_dbg(DBG_ERR, "%s: Failed to deregsiter sub-itf: %s\n",
+			__func__, dev ? dev->name : "");
+
+	/* release bandwidth */
+	switch (vcc->qos.txtp.traffic_class) {
+	case ATM_CBR:
+	case ATM_VBR_RT:
+		port->tx_used_cell_rate -= vcc->qos.txtp.max_pcr;
+		break;
+	case ATM_VBR_NRT:
+		port->tx_used_cell_rate -= vcc->qos.txtp.scr;
+		break;
+	case ATM_UBR_PLUS:
+		port->tx_used_cell_rate -= vcc->qos.txtp.min_pcr;
+		break;
+	}
+
+	/* idle for a while to let parallel operation finish */
+	udelay(100);
+
+	return;
+}
+
+static int ppe_ioctl(struct atm_dev *dev, unsigned int cmd, void *arg)
+{
+	int ret = 0;
+	/* int conn; */
+
+	if (_IOC_TYPE(cmd) != PPE_ATM_IOC_MAGIC
+		|| _IOC_NR(cmd) >= PPE_ATM_IOC_MAXNR)
+		return -ENOTTY;
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		ret = !access_ok(VERIFY_WRITE, arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		ret = !access_ok(VERIFY_READ, arg, _IOC_SIZE(cmd));
+	if (ret)
+		return -EFAULT;
+
+	switch (cmd) {
+#if 0	/* TODO: to be added */
+	case PPE_ATM_MAP_PKT_PRIO_TO_Q:
+	break;
+	case PPE_ATM_TX_Q_OP:
+	break;
+	case PPE_ATM_GET_MAP_PKT_PRIO_TO_Q:
+	break;
+	default:
+	ret = -ENOIOCTLCMD;
+#endif
+
+	}
+
+	return ret;
+}
+
+static int ppe_send(struct atm_vcc *vcc, struct sk_buff *skb)
+{
+	int ret;
+	int conn, qid, mpoa_pt, mpoa_type, vid;
+	unsigned int prio;
+	dp_subif_t dp_id;
+	struct vrx318_atm_tc *priv = vcc->dev->dev_data;
+
+	if (!skb || !vcc || vcc->qos.aal != ATM_AAL5 ||
+		skb->len > priv->frwk->param.aal5s_max_pktsz)
+		goto PARAM_ERR;
+
+	ATM_SKB(skb)->vcc = vcc;
+
+	if (priv->frwk->tc_stat != VRX318_RUNNING
+		|| priv->frwk->tc_mode[priv->ep_id] != TC_ATM_SL_MODE) {
+		vrx318_dbg(DBG_ERR, "Drop packet due to tc_stat: %d, tc_mode: %d, ep_id: %d\n",
+			(u32)priv->frwk->tc_stat,
+			(u32)priv->frwk->tc_mode[priv->ep_id],
+			priv->ep_id);
+		atm_free_tx_skb_vcc(skb);
+		return -EACCES;
+	}
+
+	skb_get(skb);
+	atm_free_tx_skb_vcc(skb);
+	ATM_SKB(skb)->vcc = NULL;
+
+	conn = find_vcc(vcc);
+	if (conn < 0) {
+		vrx318_dbg(DBG_ERR, "Cannot find vcc: vpi/vci: %d/%d\n",
+			vcc->vpi, vcc->vci);
+		ret = -EINVAL;
+		goto FIND_VCC_FAIL;
+	}
+
+	if (!atm_in_showtime()) {
+		vrx318_dbg(DBG_ERR, "DSL not in showtime\n");
+		ret = -EIO;
+		goto CHECK_SHOWTIME_FAIL;
+	}
+
+	dump_atm_data(skb->data, skb->len, 0);
+
+	prio = skb->priority >= ATM_PRIO_Q_NUM ?
+			ATM_PRIO_Q_NUM - 1 : skb->priority;
+
+	dp_id.port_id = priv->frwk->port_id;
+	mpoa_pt = 1;
+	mpoa_type = 0; /* Ignore by FW if mpoa_pt set */
+	qid = priv->conn[conn].prio_queue_map[prio];
+	vid = priv->conn[conn].subif_id;
+	dp_id.subif = vid | ATM_DESC_SUBIF_ID(qid, mpoa_pt, mpoa_type);
+
+	/* SET EP */
+	skb->DW1 = (skb->DW1 & (~0xF00)) | ((dp_id.port_id & 0xF) << 8);
+	/* SET SUBIFID */
+	skb->DW0 = (skb->DW0 & ~0x7FFF) | dp_id.subif;
+	vrx318_dbg(DBG_PKT_TX, "port_id: 0x%x, subif_id: 0x%x\n",
+		dp_id.port_id, dp_id.subif);
+
+	if (dp_xmit(skb->dev, &dp_id, skb, skb->len, 0) == 0) {
+		priv->stats.aal5_tx_pkts++;
+		priv->stats.aal5_tx_bytes += skb->len;
+		priv->conn[conn].stats.aal5_tx_pkts++;
+		priv->conn[conn].stats.aal5_tx_bytes += skb->len;
+		priv->conn[conn].prio_tx_packets[prio]++;
+	} else {
+		vrx318_dbg(DBG_ERR, "dp xmit fail\n");
+		priv->stats.aal5_tx_dropped++;
+		priv->conn[conn].stats.aal5_tx_dropped++;
+	}
+
+	if (vcc->stats)
+		atomic_inc(&vcc->stats->tx);
+
+	return 0;
+
+PARAM_ERR:
+	if (!skb) {
+		vrx318_dbg(DBG_ERR, "SKB is NULL\n");
+		return -EINVAL;
+	} else if (!vcc) {
+		vrx318_dbg(DBG_ERR, "VCC is NULL\n");
+		return -EINVAL;
+	} else if (vcc->qos.aal != ATM_AAL5) {
+		vrx318_dbg(DBG_ERR, "AAL protocol is not ATM_ALL5\n");
+		return -EPROTONOSUPPORT;
+	} else if (skb->len > priv->frwk->param.aal5s_max_pktsz) {
+		vrx318_dbg(DBG_ERR, "Skb size too big: %d\n", skb->len);
+		return -EOVERFLOW;
+	}
+
+	return -EINVAL;
+
+FIND_VCC_FAIL:
+	if (!vcc) {
+		atm_free_tx_skb_vcc(skb);
+		return ret;
+	} else if (vcc->stats)
+		atomic_inc(&vcc->stats->tx_err);
+
+	if (vcc->qos.aal == ATM_AAL5)
+		priv->stats.aal5_tx_errors++;
+	atm_free_tx_skb_vcc(skb);
+	return ret;
+
+CHECK_SHOWTIME_FAIL:
+	if (vcc->stats)
+		atomic_inc(&vcc->stats->tx_err);
+	if (vcc->qos.aal == ATM_AAL5) {
+		priv->stats.aal5_tx_dropped++;
+		priv->conn[conn].stats.aal5_tx_dropped++;
+	}
+	atm_free_tx_skb_vcc(skb);
+	return ret;
+}
+
+static int ppe_send_oam(struct atm_vcc *vcc, void *cell, int flags)
+{
+	int conn, qid, mpoa_pt, mpoa_type, vid;
+	struct uni_cell_header *cell_header = (struct uni_cell_header *)cell;
+	struct sk_buff *skb;
+	dp_subif_t dp_id;
+	struct vrx318_atm_tc *priv = g_atm_tc;
+
+	if (!vcc)
+		return -EINVAL;
+
+	if (!atm_in_showtime()) {
+		vrx318_dbg(DBG_ERR, "ATM not in showtime\n");
+		return -EIO;
+	}
+
+	dump_oam_cell(cell, 0);
+	if (((cell_header->pti == ATM_PTI_SEGF5 ||
+		cell_header->pti == ATM_PTI_E2EF5)
+		&& find_vpivci(cell_header->vpi, cell_header->vci) < 0)
+		|| ((cell_header->vci == 0x03 || cell_header->vci == 0x04)
+		&& find_vpi(cell_header->vpi) < 0)) {
+
+		vrx318_dbg(DBG_ERR, "Cell pti/vpi/vci not match: %d/%d/%d\n",
+			cell_header->pti, cell_header->vpi, cell_header->vci);
+		return -EINVAL;
+	}
+
+	/*  find queue ID   */
+	conn = find_vcc(vcc);
+	if (conn < 0) {
+		vrx318_dbg(DBG_ERR, "VCC is not configured: VPI/VCI: %d/%d\n",
+			vcc->vpi, vcc->vci);
+		return -EINVAL;
+	}
+
+	dp_id.port_id = priv->frwk->port_id;
+	mpoa_pt = 1;
+	mpoa_type = 0; /* Ignore by FW  */
+	qid = priv->conn[conn].prio_queue_map[priv->frwk->param.oam_prio];
+	vid = priv->conn[conn].subif_id;
+	dp_id.subif = vid | ATM_DESC_SUBIF_ID(qid, mpoa_pt, mpoa_type);
+
+	/*  allocate sk_buff    */
+	skb = cbm_alloc_skb(DMA_PACKET_SIZE, GFP_ATOMIC);
+	if (skb == NULL) {
+		vrx318_dbg(DBG_ERR, "%s: allocate cbm buffer fail\n", __func__);
+		return -ENOMEM;
+	}
+
+	/*  copy data   */
+	skb_put(skb, CELL_SIZE);
+	memcpy(skb->data, cell, CELL_SIZE);
+	/* SET EP */
+	skb->DW1 = (skb->DW1 & (~0xF00)) | ((dp_id.port_id & 0xF) << 8);
+	/* SET SUBIFID */
+	skb->DW0 = (skb->DW0 & ~0x7FFF) | dp_id.subif;
+	skb->dev = priv->conn[conn].dev;
+
+	vrx318_dbg(DBG_OAM_TX, "conn: %d, dev name: %s, dp port: %d, dp subif: 0x%x, len:%d\n",
+		conn, skb->dev->name, dp_id.port_id, dp_id.subif, skb->len);
+
+	if (dp_xmit(skb->dev, &dp_id, skb, skb->len, DP_TX_OAM) == 0) {
+		priv->stats.oam_tx_pkts++;
+		priv->stats.oam_tx_bytes += skb->len;
+		priv->conn[conn].stats.oam_tx_pkts++;
+		priv->conn[conn].stats.oam_tx_bytes += skb->len;
+	} else {
+		priv->stats.oam_tx_dropped++;
+		priv->conn[conn].stats.oam_tx_dropped++;
+	}
+
+	return 0;
+}
+
+static int ppe_change_qos(struct atm_vcc *vcc, struct atm_qos *qos, int flags)
+{
+	int conn;
+
+	if (vcc == NULL || qos == NULL)
+		return -EINVAL;
+
+	conn = find_vcc(vcc);
+	if (conn < 0)
+		return -EINVAL;
+
+	set_qsb((struct vrx318_atm_tc *)vcc->dev->dev_data, vcc, qos, conn);
+
+	return 0;
+}
+
+ssize_t proc_write_atm_wanmib(struct file *file, const char __user *buf,
+				size_t count, loff_t *data)
+{
+	struct vrx318_atm_tc *priv;
+	int ep_id;
+	u32 base;
+	char str[32];
+	int len, rlen, i;
+	int num;
+	char *param_list[20];
+
+	priv = (struct vrx318_atm_tc *)PDE_DATA(file_inode(file));
+	ep_id = priv->ep_id;
+	base = (u32)priv->frwk->ep_dev[ep_id].membase;
+
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+	num = dp_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+	if ((dp_strcmpi(param_list[0], "clear") == 0)
+		|| (dp_strcmpi(param_list[0], "clean") == 0)
+		|| (dp_strcmpi(param_list[0], "c") == 0)) {
+		for (i = 0; i < sizeof(struct dsl_wan_mib_table) / 4; i++)
+			vrx318_w32_sb(0, DSL_WAN_MIB_TBL + i, base);
+
+		for (i = 0; i < QOSQ_NUM; i++) {
+			dword_ep_clear(SB_BUFFER(DSL_Q_RX_MIB_TBL(i)),
+				sizeof(struct dsl_queue_mib), base);
+			dword_ep_clear(SB_BUFFER(DSL_Q_TX_MIB_TBL(i)),
+				sizeof(struct dsl_queue_mib), base);
+		}
+		spin_lock_bh(&priv->atm_lock);
+		for (i = 0; i < pvc_num(); i++) {
+			if (priv->pvc_tbl & BIT(i)) {
+				memset(&priv->conn[i].stats, 0,
+					sizeof(priv->conn[i].stats));
+				memset(&priv->conn[i].prio_tx_packets, 0,
+					sizeof(priv->conn[i].prio_tx_packets));
+			}
+			memset(&priv->stats, 0, sizeof(priv->stats));
+		}
+		spin_unlock_bh(&priv->atm_lock);
+	} else {
+		goto proc_atm_wanmib_help;
+	}
+
+	return count;
+
+proc_atm_wanmib_help:
+	pr_info("echo clear/clean/c > wanmib\n");
+return count;
+
+}
+
+int proc_read_atm_wanmib(struct seq_file *seq, void *v)
+{
+	struct vrx318_atm_tc *priv = (struct vrx318_atm_tc *)seq->private;
+	int i, ep_id;
+	u32 base;
+
+	if (!priv) {
+		pr_err("priv pointer is NULL!!!\n");
+		return -EINVAL;
+	}
+
+	ep_id = priv->ep_id;
+	base = (u32)priv->frwk->ep_dev[ep_id].membase;
+
+	pr_info("ep_id: %d, base: 0x%x\n", ep_id, base);
+
+	seq_puts(seq, "DSL WAN MIB:\n");
+	seq_printf(seq, "  wrx_drophtu_cell: %u\n", vrx318_r32_sb(__WRX_DROPHTU_CELL, base));
+	seq_printf(seq, "  wrx_dropdes_pdu:  %u\n", vrx318_r32_sb(__WRX_DROPDES_PDU, base));
+	seq_printf(seq, "  wrx_correct_pdu:  %u\n", vrx318_r32_sb(__WRX_CORRECT_PDU, base));
+	seq_printf(seq, "  wrx_err_pdu:      %u\n", vrx318_r32_sb(__WRX_ERR_PDU, base));
+	seq_printf(seq, "  wrx_dropdes_cell: %u\n", vrx318_r32_sb(__WRX_DROPDES_CELL, base));
+	seq_printf(seq, "  wrx_correct_cell: %u\n", vrx318_r32_sb(__WRX_CORRECT_CELL, base));
+	seq_printf(seq, "  wrx_err_cell:     %u\n", vrx318_r32_sb(__WRX_ERR_CELL, base));
+	seq_printf(seq, "  wrx_total_byte:   %u\n", vrx318_r32_sb(__WRX_TOTAL_BYTE, base));
+	seq_printf(seq, "  wtx_total_pdu:    %u\n", vrx318_r32_sb(__WTX_TOTAL_PDU, base));
+	seq_printf(seq, "  wtx_total_cell:   %u\n", vrx318_r32_sb(__WTX_TOTAL_CELL, base));
+	seq_printf(seq, "  wtx_total_byte:   %u\n", vrx318_r32_sb(__WTX_TOTAL_BYTE, base));
+	seq_puts(seq, "DSL RX QUEUE MIB:\n");
+	seq_puts(seq, "  idx     pdu       bytes\n");
+	for (i = 0; i < txq_num(); i++)
+		seq_printf(seq, "   %2d %10u %10u\n", i,
+			vrx318_r32_sb(DSL_Q_RX_MIB_TBL(i), base),
+			vrx318_r32_sb(DSL_Q_RX_MIB_TBL(i) + 1, base));
+
+	seq_puts(seq, "DSL TX QUEUE MIB:\n");
+	seq_puts(seq, "  idx     pdu       bytes\n");
+
+	for (i = 0; i < txq_num(); i++)
+		seq_printf(seq, "   %2d %10u %10u\n", i,
+			vrx318_r32_sb(DSL_Q_TX_MIB_TBL(i), base),
+			vrx318_r32_sb(DSL_Q_TX_MIB_TBL(i) + 1, base));
+
+	print_drv_mib(seq, priv);
+
+	return 0;
+}
+static int print_htu(struct seq_file *seq, int i, u32 base)
+{
+	struct htu_entry entry;
+	struct htu_mask mask;
+	struct htu_result result;
+
+	dword_mem_read(&entry, SB_BUFFER(HTU_ENTRY_TBL(i)),
+			sizeof(entry), base);
+	dword_mem_read(&mask, SB_BUFFER(HTU_MASK_TBL(i)),
+			sizeof(mask), base);
+	dword_mem_read(&result, SB_BUFFER(HTU_RESULT_TBL(i)),
+			sizeof(result), base);
+
+	if (entry.vld) {
+		seq_printf(seq, "%2d. valid\n", i);
+		seq_printf(seq,  "    entry  0x%08x - pid %01x, vpi %02x, vci %04x, pti %01x\n",
+			*(u32 *)&entry, entry.pid, entry.vpi,
+			entry.vci, entry.pti);
+		seq_printf(seq,  "    mask   0x%08x - pid %01x, vpi %02x, vci %04x, pti %01x\n",
+			*(u32 *)&mask, mask.pid_mask, mask.vpi_mask,
+			mask.vci_mask, mask.pti_mask);
+		seq_printf(seq,  "    result 0x%08x - type: %s, qid: %d",
+			*(u32 *)&result, result.type ? "cell" : "AAL5",
+			result.qid);
+		if (result.type)
+			seq_printf(seq,  ", cell id: %d, verification: %s",
+				result.cellid, result.ven ? "on" : "off");
+		seq_puts(seq,  "\n");
+	} else
+		seq_printf(seq, "%2d. invalid\n", i);
+
+	return 0;
+}
+
+int proc_read_htu(struct seq_file *seq, void *v)
+{
+	int htuts;
+	int i;
+	u32 base;
+	struct vrx318_atm_tc *priv = (struct vrx318_atm_tc *)seq->private;
+
+	base = (u32)priv->frwk->ep_dev[priv->ep_id].membase;
+
+	htuts = vrx318_r32_sb(__CFG_WRX_HTUTS, base);
+
+	for (i = 0; i < htuts; i++)
+		print_htu(seq, i, base);
+
+	return 0;
+}
+int proc_read_queue(struct seq_file *seq, void *v)
+{
+	static const char const *mpoa_type_str[]
+		= {"EoA w/o FCS", "EoA w FCS", "PPPoA", "IPoA"};
+
+	wrx_queue_config_t rx;
+	wtx_queue_config_t tx;
+	char qmap_str[64];
+	char qmap_flag;
+	int qmap_str_len;
+	int i, k;
+	unsigned int bit;
+
+	u32 base;
+	struct vrx318_atm_tc *priv = (struct vrx318_atm_tc *)seq->private;
+
+	base = (u32)priv->frwk->ep_dev[priv->ep_id].membase;
+
+	seq_printf(seq, "RX Queue Config (0x%08X):\n", WRX_Q_CFG(0));
+
+	for (i = 0; i < txq_num(); i++) {
+		dword_mem_read(&rx, SB_BUFFER(WRX_Q_CFG(i)),
+				sizeof(rx), base);
+		seq_printf(seq, "  %d: MPoA type - %s, MPoA mode - %s, IP version %d\n",
+			i, mpoa_type_str[rx.mpoa_type],
+			rx.mpoa_mode ? "LLC" : "VC mux",
+			rx.ip_ver ? 6 : 4);
+		seq_printf(seq, "     Oversize - %d, Undersize - %d, Max Frame size - %d\n",
+			rx.oversize, rx.undersize, rx.mfs);
+		seq_printf(seq, "     uu mask - 0x%02X, cpi mask - 0x%02X, uu exp - 0x%02X, cpi exp - 0x%02X\n",
+			rx.uumask, rx.cpimask, rx.uuexp, rx.cpiexp);
+		if (rx.vlan_ins)
+			seq_printf(seq, "     new_vlan = 0x%08X\n",
+				rx.new_vlan);
+	}
+
+	seq_printf(seq, "TX Queue Config (0x%08X):\n", WTX_Q_CFG(0));
+
+	for (i = 0; i < txq_num(); i++) {
+		dword_mem_read(&tx, SB_BUFFER(WTX_Q_CFG(i)),
+				sizeof(tx), base);
+		qmap_flag = 0;
+		qmap_str_len = 0;
+		for (k = 0, bit = 1; k < 15; k++, bit <<= 1)
+			if (tx.same_vc_qmap & bit) {
+				if (qmap_flag++)
+					qmap_str_len += sprintf(qmap_str + qmap_str_len, ", ");
+				qmap_str_len += sprintf(qmap_str + qmap_str_len, "%d", k);
+			}
+		seq_printf(seq, "  %d: uu - 0x%02X, cpi - 0x%02X, same VC queue map - %s\n",
+			i, tx.uu, tx.cpi, qmap_flag ? qmap_str : "null");
+		seq_printf(seq, "     bearer channel - %d, QSB ID - %d, MPoA mode - %s\n",
+			tx.sbid, tx.qsb_vcid, tx.mpoa_mode ? "LLC" : "VC mux");
+		seq_printf(seq, "     ATM header - 0x%08X\n", tx.atm_header);
+	}
+
+	return 0;
+}
+int sw_tx_queue_del(struct vrx318_atm_tc *priv, int conn)
+{
+	int i;
+	int qid, txq_id;
+	wtx_queue_config_t wtx_q_cfg;
+	u32 new_q_tbl, q_tbl;
+	struct atm_pvc *connect;
+	u32 base = (u32)priv->frwk->ep_dev[priv->ep_id].membase;
+
+	spin_lock_bh(&priv->atm_lock);
+	connect = &priv->conn[conn];
+	q_tbl = connect->sw_txq_tbl;
+
+	qid = txq_id = -1;
+	for (i = (pvc_num() - 1); i >= 0; i--) {
+		if (q_tbl & BIT(i)) {
+			if (qid == -1)
+				qid = i;
+			else {
+				txq_id = i;
+				break;
+			}
+		}
+	}
+
+	/* Last Queue or something wrong */
+	if (qid < 0 || q_tbl == BIT(qid)
+		|| ((q_tbl & BIT(qid)) == 0) || txq_id < 0) {
+		spin_unlock_bh(&priv->atm_lock);
+		return -EIO;
+	}
+
+	/* Update queue map table */
+	new_q_tbl = connect->sw_txq_tbl & (~(BIT(qid)));
+
+	connect->sw_txq_tbl = new_q_tbl;
+	priv->sw_txq_tbl &= ~(BIT(qid));
+
+	for (i = 0; i < ATM_PRIO_Q_NUM; i++) {
+		if (connect->prio_queue_map[i] == qid)
+			connect->prio_queue_map[i] = txq_id;
+	}
+	spin_unlock_bh(&priv->atm_lock);
+
+	for (i = 0; i < qid; i++) {
+		dword_mem_read(&wtx_q_cfg, SB_BUFFER(WTX_Q_CFG(i)),
+			sizeof(wtx_q_cfg), base);
+		wtx_q_cfg.same_vc_qmap &= ~(BIT(qid));
+		dword_mem_write(SB_BUFFER(WTX_Q_CFG(i)),
+			&wtx_q_cfg, sizeof(wtx_q_cfg), base);
+	}
+	dword_ep_clear(SB_BUFFER(WTX_Q_CFG(qid)), sizeof(wtx_q_cfg), base);
+
+	return 0;
+}
+
+int sw_tx_queue_add(struct vrx318_atm_tc *priv, int conn)
+{
+	int i;
+	int qid;
+	wtx_queue_config_t wtx_q_cfg;
+	u32 new_q_tbl, q_tbl;
+	struct atm_pvc *connect;
+	u32 base = (u32)priv->frwk->ep_dev[priv->ep_id].membase;
+
+	/* Get available Phyiscal Queue ID */
+	spin_lock_bh(&priv->atm_lock);
+	for (qid = 0; qid < pvc_num(); qid++) {
+		if ((priv->sw_txq_tbl & BIT(qid)) == 0)
+			break;
+	}
+
+	if (qid >= pvc_num()) {
+		vrx318_dbg(DBG_ERR, "No available physical queue\n");
+		spin_unlock_bh(&priv->atm_lock);
+		return -ENOSPC;
+	}
+
+	connect = &priv->conn[conn];
+	/* Reconfigure Existing Queue's QMAP */
+	q_tbl = connect->sw_txq_tbl;
+	new_q_tbl = q_tbl | BIT(qid);
+
+	/* Update local and global tx queue table */
+	connect->sw_txq_tbl = new_q_tbl;
+	priv->sw_txq_tbl |= BIT(qid);
+	spin_unlock_bh(&priv->atm_lock);
+
+	for (i = 0; i < pvc_num(); i++) {
+		if (q_tbl & BIT(i)) {
+			dword_mem_read(&wtx_q_cfg, SB_BUFFER(WTX_Q_CFG(i)),
+				sizeof(wtx_q_cfg), base);
+			wtx_q_cfg.same_vc_qmap = new_q_tbl & (~(BIT(i)));
+			dword_mem_write(SB_BUFFER(WTX_Q_CFG(i)),
+				&wtx_q_cfg, sizeof(wtx_q_cfg), base);
+		}
+	}
+	/* Add new Queue Setting */
+	wtx_q_cfg.same_vc_qmap = new_q_tbl & (~(BIT(qid)));
+	dword_mem_write(SB_BUFFER(WTX_Q_CFG(qid)),
+		&wtx_q_cfg, sizeof(wtx_q_cfg), base);
+
+	return 0;
+}
diff --git a/drivers/net/ethernet/lantiq/vrx318/vrx318_common.c b/drivers/net/ethernet/lantiq/vrx318/vrx318_common.c
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/vrx318_common.c
@@ -0,0 +1,184 @@
+/******************************************************************************
+ *
+ *                        Copyright (c) 2012, 2014, 2015
+ *                           Lantiq Deutschland GmbH
+ *
+ *  For licensing information, see the file 'LICENSE' in the root folder of
+ *  this software module.
+ *
+ ******************************************************************************/
+#define DEBUG
+#include <linux/ctype.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/seq_file.h>
+#include <linux/printk.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <net/datapath_api.h>
+#include <net/ppa_stack_al.h>
+
+#include <lantiq_atm.h>
+#include <lantiq_pcie.h>
+
+#include "include/vrx318_common.h"
+
+static struct ltq_mei_atm_showtime_info g_mei_showtime;
+
+void init_dsl_callback(void)
+{
+	memset(&g_mei_showtime, 0, sizeof(g_mei_showtime));
+}
+EXPORT_SYMBOL(init_dsl_callback);
+
+void *ppa_callback_get(int type)
+{
+	switch (type) {
+	case LTQ_MEI_SHOWTIME_CHECK:
+		return g_mei_showtime.check_ptr;
+	case LTQ_MEI_SHOWTIME_ENTER:
+		return g_mei_showtime.enter_ptr;
+	case LTQ_MEI_SHOWTIME_EXIT:
+		return g_mei_showtime.exit_ptr;
+	case LTQ_MEI_TC_REQUEST:
+		return g_mei_showtime.req_tc_ptr;
+	case LTQ_MEI_TC_RESET:
+		return g_mei_showtime.tc_reset_ptr;
+	default:
+		pr_err("mei unknown function type");
+		return NULL;
+	}
+}
+EXPORT_SYMBOL(ppa_callback_get);
+
+int ppa_callback_set(int type, void *func)
+{
+	int ret = 0;
+	switch (type) {
+	/* save func address within global struct */
+	case LTQ_MEI_SHOWTIME_CHECK:
+		g_mei_showtime.check_ptr = func;
+		break;
+	case LTQ_MEI_SHOWTIME_ENTER:
+		g_mei_showtime.enter_ptr = func;
+		break;
+	case LTQ_MEI_SHOWTIME_EXIT:
+		g_mei_showtime.exit_ptr = func;
+		break;
+	case LTQ_MEI_TC_REQUEST:
+		g_mei_showtime.req_tc_ptr = func;
+		break;
+	case LTQ_MEI_TC_RESET:
+		g_mei_showtime.tc_reset_ptr = func;
+		break;
+	default:
+		pr_err("mei unknown function type");
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(ppa_callback_set);
+
+int get_num_from_str(char **p, int *len, int is_hex)
+{
+	int ret = 0;
+	int n = 0;
+
+	if ((*p)[0] == '0' && (*p)[1] == 'x') {
+		is_hex = 1;
+		(*p) += 2;
+		(*len) -= 2;
+	}
+
+	if (is_hex) {
+		while (*len && ((**p >= '0' && **p <= '9')
+			|| (**p >= 'a' && **p <= 'f')
+			|| (**p >= 'A' && **p <= 'F'))) {
+
+			if (**p >= '0' && **p <= '9')
+				n = **p - '0';
+			else if (**p >= 'a' && **p <= 'f')
+				n = **p - 'a' + 10;
+			else if (**p >= 'A' && **p <= 'F')
+				n = **p - 'A' + 10;
+			ret = (ret << 4) | n;
+			(*p)++;
+			(*len)--;
+		}
+	} else {
+		while (*len && **p >= '0' && **p <= '9') {
+			n = **p - '0';
+			ret = ret * 10 + n;
+			(*p)++;
+			(*len)--;
+		}
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(get_num_from_str);
+
+void ignore_space(char **p, int *len)
+{
+	while (*len && (**p <= ' ' || **p == ':' || **p == '.' || **p == ',')) {
+		(*p)++;
+		(*len)--;
+	}
+}
+EXPORT_SYMBOL(ignore_space);
+
+
+/**
+* Note: Soc have to initialize the descriptor and allocate the buffer if needed
+* This API should be moved to SoC part
+*/
+int soc_vrx318_cfg_init(struct vrx318_soc_cfg *cfg)
+{
+	cfg->soc_cpu_us_phybase	= 0;
+	cfg->soc_cpu_us_dnum	= 0;
+	/* TODO: Should get the address from CBM driver */
+	/*CBM_DQM_LDESC0_0_DMA_EGP_23*/
+	cfg->soc_fp_us_phybase	= 0x1E7E7100u;
+	cfg->soc_fp_us_dnum	= 32;
+	/* TODO: Should get the address from CBM driver */
+	/* CBM_EQM_SDESC0_0_IGP_15 */
+	cfg->soc_ds_phybase	= 0x1E79F100u;
+	cfg->soc_ds_dbase	= 0xBE79F100u;
+	cfg->soc_ds_dnum	= 32;
+	cfg->pmac_en		= 0; /* Disable PMAC */
+	cfg->soc_us_desc_own	= 1;
+	cfg->soc_ds_desc_own	= 0;
+
+	return 0;
+}
+EXPORT_SYMBOL(soc_vrx318_cfg_init);
+
+void soc_vrx318_cfg_reset(void)
+{
+	void __iomem *addr;
+	u32 val;
+
+	addr = (void __iomem *)0xBE7E7030;
+	val = ltq_r32(addr) & 0x1F;
+	ltq_w32(val, addr);
+
+	addr = (void __iomem *)0xBE79F030;
+	val = ltq_r32(addr) & 0x71F;
+	ltq_w32(val, addr);
+}
+EXPORT_SYMBOL(soc_vrx318_cfg_reset);
+
diff --git a/drivers/net/ethernet/lantiq/vrx318/vrx318_proc.c b/drivers/net/ethernet/lantiq/vrx318/vrx318_proc.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/vrx318_proc.c
@@ -0,0 +1,1523 @@
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#include <net/datapath_proc_api.h>
+#include <net/datapath_api.h>
+#include <lantiq.h>
+#include <lantiq_soc.h>
+#include <lantiq_irq.h>
+#include <lantiq_pcie.h>
+#include <lantiq_atm.h>
+
+#include "include/vrx318_ppe_fw_ds.h"
+#include "include/vrx318_ppe_atm_ds.h"
+#include "include/vrx318_fw_prereq.h"
+#include "include/vrx318_ppe_fw_const.h"
+#include "include/unified_qos_ds_be.h"
+#include "include/vrx318_edma.h"
+#include "include/vrx318_common.h"
+#include "include/vrx318_framework.h"
+#include "include/vrx318_atm_tc.h"
+#include "include/vrx318_ptm_tc.h"
+#include "include/vrx318_api.h"
+#include "include/vrx318_proc.h"
+#include "include/vrx318_ppe_ptm_tc_ds.h"
+#include "include/vrx318_ppe_bonding_ds.h"
+
+char *vrx_dbg_flag_str[] = {
+	"err",
+	"rx",
+	"tx",
+	"event",
+	"rx_dump",
+	"tx_dump",
+	"init",
+	"info",
+	"oam_rx",
+	"oam_tx",
+	"oam_rx_dump",
+	"oam_tx_dump",
+	"qos",
+	"tc",
+	"loopback",
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+	"coc"
+#endif
+};
+
+static int proc_read_atm_cfg(struct seq_file *seq, void *v)
+{
+	int i;
+	struct vrx318_atm_tc *priv = (struct vrx318_atm_tc *)seq->private;
+	u32 qos_en = priv->frwk->param.atm_qos;
+
+	seq_printf(seq, "VRX318 ATM on line: %d\n", priv->ep_id);
+	seq_printf(seq, "Showtime: %d\n", atm_in_showtime());
+	seq_printf(seq, "Power Saving: %s\n",
+		atm_power_saving(priv, 0, 0) == 1 ? "Enable" : "Disable");
+
+	seq_puts(seq, "PVC list:\n");
+	spin_lock_bh(&priv->atm_lock);
+	seq_printf(seq, "PVC MAP: 0x%x\n", priv->pvc_tbl);
+	seq_printf(seq, "Tx Queue MAP: 0x%x\n", priv->sw_txq_tbl);
+
+	for (i = 0; i < ATM_PVC_NUM(qos_en); i++)
+		if (priv->pvc_tbl & BIT(i))
+			seq_printf(seq, "[%d]: VPI: %d, VCI: %d, dev: %s, MPoA type: %d, MPoA mode: %d, Subif_id: 0x%x, Tx Queue Table: 0x%x\n "
+				, i, priv->conn[i].vcc->vpi,
+				priv->conn[i].vcc->vci,
+				priv->conn[i].dev->name,
+				priv->conn[i].mpoa_type,
+				priv->conn[i].mpoa_mode,
+				priv->conn[i].subif_id,
+				priv->conn[i].sw_txq_tbl);
+	spin_unlock_bh(&priv->atm_lock);
+	return 0;
+}
+
+static int proc_read_atm_cfg_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_atm_cfg, PDE_DATA(inode));
+}
+
+static ssize_t vrx318_atm_cfg_proc_write(struct file *file,
+		const char __user *buf,	size_t count, loff_t *data)
+{
+	struct vrx318_atm_tc *priv;
+	u32 base, ep_id, en;
+	int num, len, rlen;
+	char *param_list[32];
+	char str[128];
+
+	priv = (struct vrx318_atm_tc *)PDE_DATA(file_inode(file));
+	ep_id = priv->ep_id;
+	base = (u32)priv->frwk->ep_dev[ep_id].membase;
+
+	if (!access_ok(VERIFY_READ, buf, count))
+		return -EFAULT;
+
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+	num = dp_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+
+	if (dp_strcmpi(param_list[0], "en") == 0
+		|| dp_strcmpi(param_list[0], "enble") == 0) {
+		en = 1;
+	} else if (dp_strcmpi(param_list[0], "dis") == 0
+		|| dp_strcmpi(param_list[0], "disable") == 0) {
+		en = 0;
+	} else
+		goto proc_atm_cfg_help;
+
+	if (dp_strcmpi(param_list[1], "ps") == 0
+		|| dp_strcmpi(param_list[1], "powersaving") == 0) {
+		atm_power_saving(priv, en, 1);
+	}
+
+	return count;
+
+proc_atm_cfg_help:
+	vrx318_dbg(DBG_INFO, "echo [enable | disable] powersaving > cfg\n");
+	return count;
+}
+
+
+
+static const struct file_operations vrx318_atm_cfg_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_atm_cfg_seq_open,
+	.read		= seq_read,
+	.write		= vrx318_atm_cfg_proc_write,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static ssize_t vrx318_mem_proc_write(struct file *file, const char __user *buf,
+				size_t count, loff_t *data)
+{
+	int c, i;
+	int action = 0;
+	u32 addr, set_val, repeat_cnt;
+	struct vrx318_tc *priv;
+	u32 base, ep_id, soc_flag;
+	int num, len, rlen, idx;
+	char *param_list[32], *p;
+	char str[128];
+
+	priv = (struct vrx318_tc *)PDE_DATA(file_inode(file));
+	ep_id = priv->ep_id;
+	base = (u32)priv->frwk->ep_dev[ep_id].membase;
+	addr = set_val = repeat_cnt = 0;
+	soc_flag = 0;
+
+	if (!access_ok(VERIFY_READ, buf, count))
+		return -EFAULT;
+
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+	num = dp_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+
+	if (dp_strcmpi(param_list[0], "r") == 0) {
+		action = PPE_PROC_READ;
+	} else if (dp_strcmpi(param_list[0], "w") == 0) {
+			action = PPE_PROC_WRITE;
+	} else if ((dp_strcmpi(param_list[0], "s") == 0) &&
+			 (dp_strcmpi(param_list[1], "w") == 0)) {
+		action = PPE_PROC_WRITE;
+		soc_flag = 1;
+	} else if ((dp_strcmpi(param_list[0], "s") == 0)
+			&& (dp_strcmpi(param_list[1], "r") == 0)) {
+		action = PPE_PROC_READ;
+		soc_flag = 1;
+	} else {
+		goto proc_mem_help;
+	}
+
+	idx = soc_flag ? 2 : 1;
+	num -= (soc_flag) ? 2 : 1;
+
+	p = param_list[idx++];
+	addr = get_num_from_str(&p, &len, 1);
+	addr = SB_BUFFER(addr);
+
+	if (action == PPE_PROC_READ) {
+		repeat_cnt = dp_atoi(param_list[idx]);
+		for (i = 0; i < repeat_cnt; i += 4) {
+			if (soc_flag)
+				printk("0x%08x: ", addr + (i << 2));
+			else
+				printk("0x%08x: ", ((addr + i * 4) & VRX318_SMASK) + base);
+			for (c = 0; c < 4 && (i + c) < repeat_cnt; c++)
+				if (soc_flag)
+					printk("%08x  ", ltq_r32((void *)(addr + ((i + c) << 2))));
+				else
+					printk("%08x  ", vrx318_r32(addr + ((i + c) << 2), base));
+				printk("\n");
+		}
+	} else if (action == PPE_PROC_WRITE) {
+		if (dp_strcmpi(param_list[idx + 1], "r") == 0 ||
+			dp_strcmpi(param_list[idx + 1], "rpt") == 0) {
+			repeat_cnt = dp_atoi(param_list[idx + 2]);
+			set_val = dp_atoi(param_list[idx]);
+			for (i = 0; i < repeat_cnt; i++) {
+				if (soc_flag)
+					ltq_w32(set_val, (void *)(addr + (i << 2)));
+				else
+					vrx318_w32(set_val, addr + (i << 2), base);
+			}
+		} else {
+			for (i = 0; i < num; i++) {
+				set_val = dp_atoi(param_list[idx + i]);
+				if (soc_flag)
+					ltq_w32(set_val, (void *)(addr + (i << 2)));
+				else
+					vrx318_w32(set_val, addr + (i << 2), base);
+			}
+		}
+	}
+
+	return count;
+
+proc_mem_help:
+	vrx318_dbg(DBG_INFO, "echo <s> r [soc_addr] [count] > mem\n");
+	vrx318_dbg(DBG_INFO, "echo <s> w [addr] [value] [val0] <val1> ... > mem\n");
+	vrx318_dbg(DBG_INFO, "echo <s> w [addr] <value> r [repeat_count] > mem\n");
+	return count;
+}
+
+static int proc_vrx318_read_mem(struct seq_file *seq, void *v)
+{
+	return 0;
+}
+
+static int proc_read_mem_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_vrx318_read_mem, NULL);
+}
+
+static const struct file_operations vrx318_mem_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_mem_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.write		= vrx318_mem_proc_write,
+};
+
+static ssize_t vrx318_pp32_proc_write(struct file *file, const char __user *buf,
+				size_t count, loff_t *data)
+{
+		struct vrx318_tc *priv;
+		int ep_id;
+		u32 base, reg_val;
+		char str[128];
+		u32 addr;
+		int len, rlen, pc;
+		int pp32 = 0;
+
+		int num;
+		char *param_list[20];
+
+		priv = (struct vrx318_tc *)PDE_DATA(file_inode(file));
+		ep_id = priv->ep_id;
+		base = (u32)priv->frwk->ep_dev[ep_id].membase;
+
+		len = count < sizeof(str) ? count : sizeof(str) - 1;
+		rlen = len - copy_from_user(str, buf, len);
+		str[rlen] = 0;
+		num = dp_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+		pp32 = dp_atoi(param_list[1]);
+		if (dp_strcmpi(param_list[0], "pp32") == 0) {
+			if (dp_strcmpi(param_list[2], "restart") == 0) {
+				reg_val = vrx318_r32(PP32_FREEZE, base) & (~(1 << (pp32 << 4)));
+				vrx318_w32(reg_val, PP32_FREEZE, base);
+			} else if (dp_strcmpi(param_list[2], "freeze") == 0) {
+				reg_val = vrx318_r32(PP32_FREEZE, base) | (1 << (pp32 << 4));
+				vrx318_w32(reg_val, PP32_FREEZE, base);
+			} else if (dp_strcmpi(param_list[2], "start") == 0) {
+				vrx318_w32(PP32_CTRL_CMD_RESTART, PP32_CTRL_CMD(pp32), base);
+			} else if (dp_strcmpi(param_list[2], "stop") == 0) {
+				vrx318_w32(PP32_CTRL_CMD_STOP, PP32_CTRL_CMD(pp32), base);
+			} else if (dp_strcmpi(param_list[2], "step") == 0) {
+				vrx318_w32(PP32_CTRL_CMD_STEP, PP32_CTRL_CMD(pp32), base);
+			} else if ((dp_strcmpi(param_list[2], "pc0") == 0)
+					|| (dp_strcmpi(param_list[0], "pc1") == 0)) {
+				if (dp_strcmpi(param_list[2], "pc0") == 0)
+					pc = 0;
+				else
+					pc = 1;
+
+				if (dp_strcmpi(param_list[3], "off") == 0) {
+					vrx318_w32(PP32_BRK_GRPi_PCn_OFF(pc, pc), PP32_BRK_TRIG(pp32), base);
+					vrx318_w32(PP32_BRK_CONTEXT_MASK_EN,
+						PP32_BRK_PC_MASK(pp32, pc), base);
+					vrx318_w32(0, PP32_BRK_PC(pp32, pc), base);
+				} else {
+					addr = dp_atoi(param_list[3]);
+					vrx318_w32(addr, PP32_BRK_PC(pp32, pc), base);
+					vrx318_w32(PP32_BRK_CONTEXT_MASK_EN | PP32_BRK_CONTEXT_MASK(0) |
+						PP32_BRK_CONTEXT_MASK(1) | PP32_BRK_CONTEXT_MASK(2) | PP32_BRK_CONTEXT_MASK(3),
+						PP32_BRK_PC_MASK(pp32, pc), base);
+					vrx318_w32(PP32_BRK_GRPi_PCn_ON(pc, pc), PP32_BRK_TRIG(pp32), base);
+				}
+			} else if ((dp_strcmpi(param_list[2], "daddr0") == 0)
+						|| (dp_strcmpi(param_list[2], "daddr1") == 0)) {
+				if (dp_strcmpi(param_list[2], "daddr0") == 0)
+						pc = 0;
+				else
+						pc = 1;
+
+				if (dp_strcmpi(param_list[3], "off") == 0) {
+					vrx318_w32(PP32_BRK_GRPi_DATA_ADDRn_OFF(pc, pc), PP32_BRK_TRIG(pp32), base);
+					vrx318_w32(PP32_BRK_CONTEXT_MASK_EN, PP32_BRK_DATA_ADDR_MASK(pp32, pc), base);
+					vrx318_w32(0, PP32_BRK_DATA_ADDR(pp32, pc), base);
+
+				} else {
+					addr = dp_atoi(param_list[3]);
+					vrx318_w32(addr, PP32_BRK_DATA_ADDR(pp32, pc), base);
+					vrx318_w32(PP32_BRK_CONTEXT_MASK_EN | PP32_BRK_CONTEXT_MASK(0) |
+						PP32_BRK_CONTEXT_MASK(1) | PP32_BRK_CONTEXT_MASK(2) | PP32_BRK_CONTEXT_MASK(3),
+						PP32_BRK_DATA_ADDR_MASK(pp32, pc), base);
+					vrx318_w32(PP32_BRK_GRPi_DATA_ADDRn_ON(pc, pc), PP32_BRK_TRIG(pp32), base);
+				}
+			}
+		} else {
+			goto proc_pp32_help;
+		}
+		if (vrx318_r32(PP32_BRK_TRIG(pp32), base))
+			vrx318_w32(PP32_CTRL_OPT_STOP_ON_BREAKPOINT_ON,
+				PP32_CTRL_OPT(pp32), base);
+		else
+			vrx318_w32(PP32_CTRL_OPT_STOP_ON_BREAKPOINT_OFF,
+				PP32_CTRL_OPT(pp32), base);
+		return count;
+
+proc_pp32_help:
+	vrx318_dbg(DBG_INFO, "echo pp32 <id> freeze/start/stop/step/restart > pp32\n");
+	vrx318_dbg(DBG_INFO, "echo pp32 <id> pc0 off/[addr] > pp32\n");
+	vrx318_dbg(DBG_INFO, "echo pp32 <id> daddr0 off/[addr] > pp32\n");
+	return count;
+}
+static int proc_vrx318_read_pp32(struct seq_file *seq, void *v)
+{
+	struct vrx318_atm_tc *priv = (struct vrx318_atm_tc *)seq->private;
+
+	static const char *stron = " on";
+	static const char *stroff = "off";
+
+	int cur_context;
+	int f_stopped;
+	char strlength;
+	int i, j;
+
+	int pp32, ep_id;
+	u32 base;
+
+	if (!priv) {
+		pr_err("priv pointer is NULL!!!\n");
+		return -EINVAL;
+	}
+
+	ep_id = priv->ep_id;
+	base = (u32)priv->frwk->ep_dev[ep_id].membase;
+
+	for (pp32 = 0; pp32 < 2; pp32++) {
+		f_stopped = 0;
+		seq_printf(seq, "===== pp32 core %d =====\n", pp32);
+
+		cur_context = PP32_BRK_CUR_CONTEXT(base, pp32);
+		seq_printf(seq, "Context: %d, PC: 0x%04x ", cur_context, PP32_CPU_CUR_PC(base, pp32));
+		if ((vrx318_r32(PP32_FREEZE, base) & (1 << (pp32 << 4))) != 0) {
+			seq_puts(seq, "freezed");
+			f_stopped = 1;
+		} else if (PP32_CPU_USER_STOPPED(base, pp32) || PP32_CPU_USER_BREAKIN_RCV(base, pp32) || PP32_CPU_USER_BREAKPOINT_MET(base, pp32)) {
+			strlength = 0;
+			f_stopped = 1;
+			if (PP32_CPU_USER_STOPPED(base, pp32)) {
+				seq_puts(seq, "stopped");
+				strlength = 1;
+			}
+			if (PP32_CPU_USER_BREAKPOINT_MET(base, pp32)) {
+				seq_printf(seq, "%s", strlength ? " | breakpoint" : "breakpoint");
+				strlength = 1;
+			}
+			if (PP32_CPU_USER_BREAKIN_RCV(base, pp32))
+				seq_printf(seq, "%s", strlength ? " | breakin" : "breakin");
+
+		} else if (PP32_CPU_CUR_PC(base, pp32) == PP32_CPU_CUR_PC(base, pp32)) {
+			unsigned int pc_value[64] = {0};
+			f_stopped = 1;
+			for (i = 0; f_stopped && i < ARRAY_SIZE(pc_value); i++) {
+				pc_value[i] = PP32_CPU_CUR_PC(base, pp32);
+				for (j = 0; j < i; j++)
+					if (pc_value[j] != pc_value[i]) {
+						f_stopped = 0;
+						break;
+					}
+				}
+				if (f_stopped)
+					seq_puts(seq, "hang");
+		}
+		if (!f_stopped)
+			seq_puts(seq, "running");
+
+		seq_puts(seq, "\n");
+
+		strlength = 0;
+		if (PP32_CPU_USER_BREAKPOINT_MET(base, pp32)) {
+			seq_puts(seq, "break reason: ");
+			if (PP32_BRK_PC_MET(base, pp32, 0)) {
+				seq_puts(seq, "pc0");
+				strlength = 1;
+			}
+			if (PP32_BRK_PC_MET(base, pp32, 1)) {
+				seq_printf(seq, "%s", strlength ? " | pc1" : "pc1");
+				strlength = 1;
+			}
+			if (PP32_BRK_DATA_ADDR_MET(base, pp32, 0)) {
+				seq_printf(seq, "%s", strlength ? " | daddr0" : "daddr0");
+				strlength = 1;
+			}
+			if (PP32_BRK_DATA_ADDR_MET(base, pp32, 1)) {
+				seq_printf(seq, "%s", strlength ? " | daddr1" : "daddr1");
+				strlength = 1;
+			}
+			if (PP32_BRK_DATA_VALUE_RD_MET(base, pp32, 0)) {
+				seq_printf(seq, "%s", strlength ? " | rdval0" : "rdval0");
+				strlength = 1;
+				if (PP32_BRK_DATA_VALUE_RD_LO_EQ(base, pp32, 0)) {
+					if (PP32_BRK_DATA_VALUE_RD_GT_EQ(base, pp32, 0))
+						seq_puts(seq, " ==");
+					else
+						seq_puts(seq, " <=");
+				} else if (PP32_BRK_DATA_VALUE_RD_GT_EQ(base, pp32, 0))
+					seq_puts(seq, " >=");
+			}
+			if (PP32_BRK_DATA_VALUE_RD_MET(base, pp32, 1)) {
+				seq_printf(seq, "%s", strlength ? " | rdval1" : "rdval1");
+				strlength = 1;
+				if (PP32_BRK_DATA_VALUE_RD_LO_EQ(base, pp32, 1)) {
+					if (PP32_BRK_DATA_VALUE_RD_GT_EQ(base, pp32, 1))
+						seq_puts(seq, " ==");
+					else
+						seq_puts(seq, " <=");
+				} else if (PP32_BRK_DATA_VALUE_RD_GT_EQ(base, pp32, 1))
+					seq_puts(seq, " >=");
+			}
+			if (PP32_BRK_DATA_VALUE_WR_MET(base, pp32, 0)) {
+				seq_printf(seq, "%s", strlength ? " | wtval0" : "wtval0");
+				strlength = 1;
+				if (PP32_BRK_DATA_VALUE_WR_LO_EQ(base, pp32, 0)) {
+					if (PP32_BRK_DATA_VALUE_WR_GT_EQ(base, pp32, 0))
+						seq_puts(seq, " ==");
+					else
+						seq_puts(seq, " <=");
+				} else if (PP32_BRK_DATA_VALUE_WR_GT_EQ(base, pp32, 0))
+					seq_puts(seq, " >=");
+			}
+			if (PP32_BRK_DATA_VALUE_WR_MET(base, pp32, 1)) {
+				seq_printf(seq, "%s", strlength ? " | wtval1" : "wtval1");
+				strlength = 1;
+				if (PP32_BRK_DATA_VALUE_WR_LO_EQ(base, pp32, 1)) {
+					if (PP32_BRK_DATA_VALUE_WR_GT_EQ(base, pp32, 1))
+						seq_puts(seq, " ==");
+					else
+						seq_puts(seq, " <=");
+				} else if (PP32_BRK_DATA_VALUE_WR_GT_EQ(base, pp32, 1))
+					seq_puts(seq, " >=");
+			}
+			seq_puts(seq, "\n");
+		}
+
+		if (f_stopped) {
+			seq_printf(seq, "General Purpose Register (Context %d):\n", cur_context);
+			for (i = 0; i < 4; i++) {
+				for (j = 0; j < 4; j++)
+					seq_printf(seq, "   %2d: %08x", i + j * 4, PP32_GP_CONTEXTi_REGn(base, pp32, cur_context, i + j * 4));
+				seq_puts(seq, "\n");
+			}
+		}
+
+		seq_printf(seq, "break out on: break in - %s, stop - %s\n",
+			PP32_CTRL_OPT_BREAKOUT_ON_BREAKIN(base, pp32) ? stron : stroff,
+			PP32_CTRL_OPT_BREAKOUT_ON_STOP(base, pp32) ? stron : stroff);
+		seq_printf(seq, "     stop on: break in - %s, break point - %s\n",
+			PP32_CTRL_OPT_STOP_ON_BREAKIN(base, pp32) ? stron : stroff,
+			PP32_CTRL_OPT_STOP_ON_BREAKPOINT(base, pp32) ? stron : stroff);
+		seq_puts(seq, "breakpoint:\n");
+		seq_printf(seq, "     pc0: 0x%08x, %s\n", vrx318_r32(PP32_BRK_PC(pp32, 0), base), PP32_BRK_GRPi_PCn(base, pp32, 0, 0) ? "group 0" : "off");
+		seq_printf(seq, "     pc1: 0x%08x, %s\n", vrx318_r32(PP32_BRK_PC(pp32, 1), base), PP32_BRK_GRPi_PCn(base, pp32, 1, 1) ? "group 1" : "off");
+		seq_printf(seq, "  daddr0: 0x%08x, %s\n", vrx318_r32(PP32_BRK_DATA_ADDR(pp32, 0), base), PP32_BRK_GRPi_DATA_ADDRn(base, pp32, 0, 0) ? "group 0" : "off");
+		seq_printf(seq, "  daddr1: 0x%08x, %s\n", vrx318_r32(PP32_BRK_DATA_ADDR(pp32, 1), base), PP32_BRK_GRPi_DATA_ADDRn(base, pp32, 1, 1) ? "group 1" : "off");
+		seq_printf(seq, "  rdval0: 0x%08x\n", vrx318_r32(PP32_BRK_DATA_VALUE_RD(pp32, 0), base));
+		seq_printf(seq, "  rdval1: 0x%08x\n", vrx318_r32(PP32_BRK_DATA_VALUE_RD(pp32, 1), base));
+		seq_printf(seq, "  wrval0: 0x%08x\n", vrx318_r32(PP32_BRK_DATA_VALUE_WR(pp32, 0), base));
+		seq_printf(seq, "  wrval1: 0x%08x\n", vrx318_r32(PP32_BRK_DATA_VALUE_WR(pp32, 1), base));
+	}
+
+	return 0;
+}
+
+static int proc_read_pp32_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_vrx318_read_pp32, PDE_DATA(inode));
+}
+
+static const struct file_operations vrx318_pp32_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_pp32_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.write		= vrx318_pp32_proc_write,
+};
+
+void print_stat_mib(struct seq_file *seq, struct atm_stats *stat)
+{
+	seq_printf(seq, "AAL5 RX PKTs:\t\t %u\n", stat->aal5_rx_pkts);
+	seq_printf(seq, "AAL5 RX Bytes:\t\t %u\n", stat->aal5_rx_bytes);
+	seq_printf(seq, "AAL5 RX Err:\t\t %u\n", stat->aal5_rx_errors);
+	seq_printf(seq, "AAL5 RX Drop:\t\t %u\n", stat->aal5_rx_dropped);
+
+	seq_printf(seq, "OAM  RX PKTs:\t\t %u\n", stat->oam_rx_pkts);
+	seq_printf(seq, "OAM  RX Bytes:\t\t %u\n", stat->oam_rx_bytes);
+	seq_printf(seq, "OAM  RX Err:\t\t %u\n", stat->oam_rx_errors);
+	seq_printf(seq, "OAM  RX Drop:\t\t %u\n", stat->oam_rx_dropped);
+
+	seq_printf(seq, "AAL5 TX PKTs:\t\t %u\n", stat->aal5_tx_pkts);
+	seq_printf(seq, "AAL5 TX Bytes:\t\t %u\n", stat->aal5_tx_bytes);
+	seq_printf(seq, "AAL5 TX Err:\t\t %u\n", stat->aal5_tx_errors);
+	seq_printf(seq, "AAL5 TX Drop:\t\t %u\n", stat->aal5_tx_dropped);
+
+	seq_printf(seq, "OAM  TX PKTs:\t\t %u\n", stat->oam_tx_pkts);
+	seq_printf(seq, "OAM  TX Bytes:\t\t %u\n", stat->oam_tx_bytes);
+	seq_printf(seq, "OAM  TX Err:\t\t %u\n", stat->oam_tx_errors);
+	seq_printf(seq, "OAM  TX Drop:\t\t %u\n\n", stat->oam_tx_dropped);
+}
+
+void print_drv_mib(struct seq_file *seq, struct vrx318_atm_tc *priv)
+{
+	seq_puts(seq, "Driver Total MIB:\n");
+	print_stat_mib(seq, &priv->stats);
+}
+static int proc_read_atm_wanmib_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_atm_wanmib, PDE_DATA(inode));
+}
+
+static const struct file_operations vrx318_wanmib_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_atm_wanmib_seq_open,
+	.read		= seq_read,
+	.write		= proc_write_atm_wanmib,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+static int proc_read_htu_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_htu, PDE_DATA(inode));
+}
+
+static const struct file_operations vrx318_htu_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_htu_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+static int proc_read_queue_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_queue, PDE_DATA(inode));
+}
+
+static const struct file_operations vrx318_queue_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_queue_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int proc_atm_read_ver(struct seq_file *seq, void *v)
+{
+	struct vrx318_atm_tc *priv = (struct vrx318_atm_tc *)seq->private;
+	char buf[128];
+
+	print_fw_version(buf, &priv->fw_ver);
+	seq_printf(seq, "%s", buf);
+	return 0;
+}
+
+static int proc_atm_read_ver_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_atm_read_ver, PDE_DATA(inode));
+}
+
+static const struct file_operations vrx318_atm_ver_proc_fops = {
+	.owner      = THIS_MODULE,
+	.open       = proc_atm_read_ver_seq_open,
+	.read       = seq_read,
+	.llseek     = seq_lseek,
+	.release    = single_release,
+};
+
+
+static void set_q_prio(struct vrx318_atm_tc *priv, int conn, int prio, int queue)
+{
+	if (conn < 0 || conn >= ATM_PVC_NUMBER || prio < 0 || prio >= ATM_PRIO_Q_NUM) {
+		vrx318_dbg(DBG_ERR, "%s: invalid parameter: conn: %d, prio: %d\n",
+			__func__, conn, prio);
+		return;
+	}
+
+	vrx318_dbg(DBG_INFO, "conn: %d, prio: %d, queue: %d\n", conn, prio, queue);
+	spin_lock_bh(&priv->atm_lock);
+	if (priv->conn[conn].sw_txq_tbl & BIT(queue))
+		priv->conn[conn].prio_queue_map[prio] = queue;
+	spin_unlock_bh(&priv->atm_lock);
+}
+ssize_t proc_atm_write_prio(struct file *file, const char __user *buf,
+				size_t count, loff_t *data)
+{
+	struct vrx318_atm_tc *priv;
+	char local_buf[256];
+	int len;
+	char *p1;
+	int conn = -1;
+	unsigned int vpi, vci;
+	int prio = -1;
+	int queue = -1;
+	int ret, num;
+	int i;
+	char *param_list[20];
+
+	len = sizeof(local_buf) < count ? sizeof(local_buf) - 1 : count;
+	len = len - copy_from_user(local_buf, buf, len);
+	local_buf[len] = 0;
+	p1 = local_buf;
+
+	num = dp_split_buffer(local_buf, param_list, ARRAY_SIZE(param_list));
+	priv =  (struct vrx318_atm_tc *)PDE_DATA(file_inode(file));
+	if (dp_strcmpi(param_list[0], "help") == 0)
+		goto proc_atm_prio_help;
+	else if (dp_strcmpi(param_list[0], "pvc") == 0) {
+		p1 += 4;
+		len -= 4;
+		ignore_space(&p1, &len);
+		vpi = get_num_from_str(&p1, &len, 0);
+		ignore_space(&p1, &len);
+		vci = get_num_from_str(&p1, &len, 0);
+		conn = find_vpivci(vpi, vci);
+
+		if (conn < 0) {
+			vrx318_dbg(DBG_ERR, "PVC(%d:%d) is invalid\n", vpi, vci);
+			return count;
+		}
+		if (dp_strcmpi(param_list[2], "add") == 0) {
+			ret = sw_tx_queue_add(priv, conn);
+			if (ret < 0)
+				vrx318_dbg(DBG_ERR, "Failed in adding queue for PVC(%d:%d)\n", vpi, vci);
+			else
+				vrx318_dbg(DBG_INFO, "Add queue for PVC(%d:%d) successfully\n", vpi, vci);
+		} else if (dp_strcmpi(param_list[2], "del") == 0 || dp_strcmpi(param_list[2], "rem") == 0) {
+			ret = sw_tx_queue_del(priv, conn);
+			if (ret < 0)
+				vrx318_dbg(DBG_ERR, "Failed in deleting queue for PVC(%d:%d)\n", vpi, vci);
+			else
+				vrx318_dbg(DBG_INFO, "Delete queue for PVC(%d:%d) successfully\n", vpi, vci);
+		} else {
+			prio = queue = -1;
+			for (i = 2; i < num; i += 4) {
+				if ((dp_strcmpi(param_list[i], "prio") == 0)
+					|| (dp_strcmpi(param_list[i], "p") == 0))
+					prio = dp_atoi(param_list[i+1]);
+				else
+					vrx318_dbg(DBG_ERR, "Error: expecting prio\n");
+
+				if ((dp_strcmpi(param_list[i+2], "queue") == 0) ||
+					(dp_strcmpi(param_list[i+2], "q") == 0))
+					queue = dp_atoi(param_list[i+3]);
+				else
+					vrx318_dbg(DBG_ERR, "Error: expecting queue\n");
+
+				if (prio >= 0 && queue >= 0)
+					set_q_prio(priv, conn, prio, queue);
+			}
+		}
+	} else
+		vrx318_dbg(DBG_INFO, "Wrong format!, Please try echo help > prio\n");
+
+	return count;
+
+proc_atm_prio_help:
+	vrx318_dbg(DBG_INFO, "echo pvc vpi.vci prio xx queue xx [prio xx queue xx] > prio\n");
+	vrx318_dbg(DBG_INFO, "echo pvc vpi.vci <add/del> > prio\n");
+	return count;
+}
+static int proc_atm_read_prio(struct seq_file *seq, void *v)
+{
+	int i, j;
+	struct vrx318_atm_tc *priv = (struct vrx318_atm_tc *)seq->private;
+	struct atm_pvc *conn;
+
+	for (i = 0; i < ATM_PVC_NUMBER; i++) {
+		if (priv->pvc_tbl & BIT(i)) {
+			conn = &priv->conn[i];
+			seq_printf(seq, "PVC(%d:%d): Phy_Qid: ",
+				conn->vcc->vpi,
+				conn->vcc->vci);
+			for (j = 0; j < ATM_PVC_NUMBER; j++) {
+				if (conn->sw_txq_tbl & BIT(j))
+					seq_printf(seq, "%d ", j);
+			}
+			seq_puts(seq, "\n   Prio: ");
+			for (j = 0; j < ATM_PRIO_Q_NUM; j++)
+				seq_printf(seq, "%d ", j);
+			seq_puts(seq, "\n   Qid:  ");
+			for (j = 0; j < ATM_PRIO_Q_NUM; j++)
+				seq_printf(seq, "%d ",
+					conn->prio_queue_map[j]);
+			seq_puts(seq, "\n");
+		}
+	}
+	return 0;
+}
+
+static int proc_atm_read_prio_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_atm_read_prio, PDE_DATA(inode));
+}
+
+static const struct file_operations vrx318_atm_prio_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_atm_read_prio_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.write		= proc_atm_write_prio,
+	.release	= single_release,
+};
+
+static int pvc_mib_seq_show(struct seq_file *seq, void *v)
+{
+	struct atm_pvc *pvc = (struct atm_pvc *)v;
+	int j;
+	struct vrx318_atm_tc *priv = seq->private;
+
+	spin_lock_bh(&priv->atm_lock);
+	if (pvc == NULL || pvc->vcc == NULL || pvc->dev == NULL) {
+		spin_unlock_bh(&priv->atm_lock);
+		return 0;
+	}
+	seq_printf(seq, "PVC %u/%u, dev: %s, MIB:\n",
+		pvc->vcc->vpi, pvc->vcc->vci,
+		(pvc->dev) ? pvc->dev->name : "N.A");
+	spin_unlock_bh(&priv->atm_lock);
+
+	print_stat_mib(seq, &pvc->stats);
+
+	for (j = 0; j < ATM_PRIO_Q_NUM; j++) {
+		if (pvc->prio_tx_packets[j] != 0) {
+			seq_printf(seq, "Queue[%d]: TX PKTs:\t %u\n",
+				j, pvc->prio_tx_packets[j]);
+		}
+	}
+	seq_puts(seq, "\n");
+
+	return 0;
+}
+static void *pvc_mib_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	struct vrx318_atm_tc *priv = seq->private;
+
+	if (!priv->pvc_tbl)
+		return NULL;
+
+	if (*pos >= ATM_PVC_NUMBER)
+		return NULL;
+
+	return &priv->conn[*pos];
+}
+
+static void *pvc_mib_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	struct vrx318_atm_tc *priv = seq->private;
+
+	if (++*pos < ATM_PVC_NUMBER)
+		return &priv->conn[*pos];
+
+	return NULL;
+}
+
+static void pvc_mib_seq_stop(struct seq_file *seq, void *v)
+{
+
+}
+
+static const struct seq_operations pvc_mib_seq_ops = {
+	.start = pvc_mib_seq_start,
+	.next = pvc_mib_seq_next,
+	.stop = pvc_mib_seq_stop,
+	.show = pvc_mib_seq_show,
+};
+
+static int proc_read_pvc_mib_seq_open(struct inode *inode, struct file *file)
+{
+	int ret = seq_open(file, &pvc_mib_seq_ops);
+	if (ret == 0) {
+		struct seq_file *m = file->private_data;
+		m->private = PDE_DATA(inode);
+	}
+	return ret;
+}
+
+static const struct file_operations vrx318_atm_pvc_mib_proc_fops = {
+	.owner	= THIS_MODULE,
+	.open	= proc_read_pvc_mib_seq_open,
+	.read	= seq_read,
+	.llseek	= seq_lseek,
+	.release = seq_release,
+};
+
+int vrx318_atm_proc_init(void *atm_priv)
+{
+	struct proc_dir_entry *entry;
+	struct proc_dir_entry *vrx318_dir;
+	struct vrx318_atm_tc *priv = (struct vrx318_atm_tc *)atm_priv;
+
+	vrx318_dir = proc_mkdir("atm", priv->frwk->proc_dir);
+	if (!vrx318_dir)
+		return -ENOMEM;
+
+	entry = proc_create_data("cfg", 0644,
+			vrx318_dir, &vrx318_atm_cfg_proc_fops, (void *)priv);
+	if (!entry)
+		goto err1;
+
+	entry = proc_create_data("mem", 0644,
+			vrx318_dir, &vrx318_mem_proc_fops, (void *)priv);
+	if (!entry)
+		goto err2;
+
+	entry = proc_create_data("pp32", 0644,
+			vrx318_dir, &vrx318_pp32_proc_fops, (void *)priv);
+	if (!entry)
+		goto err3;
+
+	entry = proc_create_data("wanmib", 0644,
+			vrx318_dir, &vrx318_wanmib_proc_fops, (void *)priv);
+	if (!entry)
+		goto err4;
+
+	entry = proc_create_data("htu", 0644,
+			vrx318_dir, &vrx318_htu_proc_fops, (void *)priv);
+	if (!entry)
+		goto err5;
+
+	entry = proc_create_data("queue", 0644,
+			vrx318_dir, &vrx318_queue_proc_fops, (void *)priv);
+	if (!entry)
+		goto err6;
+
+	entry = proc_create_data("ver", 0644,
+			vrx318_dir, &vrx318_atm_ver_proc_fops, (void *)priv);
+	if (!entry)
+		goto err7;
+
+	entry = proc_create_data("prio", 0644,
+			vrx318_dir, &vrx318_atm_prio_proc_fops, (void *)priv);
+	if (!entry)
+		goto err8;
+
+	entry = proc_create_data("pvc_mib", 0644,
+			vrx318_dir, &vrx318_atm_pvc_mib_proc_fops,
+			(void *)priv);
+	if (!entry)
+		goto err9;
+
+	priv->proc_dir = vrx318_dir;
+
+	return 0;
+
+err9:
+	remove_proc_entry("prio", vrx318_dir);
+err8:
+	remove_proc_entry("ver", vrx318_dir);
+err7:
+	remove_proc_entry("queue", vrx318_dir);
+err6:
+	remove_proc_entry("htu", vrx318_dir);
+err5:
+	remove_proc_entry("wanmib", vrx318_dir);
+err4:
+	remove_proc_entry("pp32", vrx318_dir);
+err3:
+	remove_proc_entry("mem", vrx318_dir);
+err2:
+	remove_proc_entry("cfg", vrx318_dir);
+err1:
+	remove_proc_entry("driver/ltq_vrx318/atm/", NULL);
+	return -ENOMEM;
+}
+EXPORT_SYMBOL(vrx318_atm_proc_init);
+
+void vrx318_atm_proc_exit(void *atm_priv)
+{
+	struct vrx318_atm_tc *priv = (struct vrx318_atm_tc *)atm_priv;
+	remove_proc_entry("cfg", priv->proc_dir);
+	remove_proc_entry("mem", priv->proc_dir);
+	remove_proc_entry("pp32", priv->proc_dir);
+	remove_proc_entry("wanmib", priv->proc_dir);
+	remove_proc_entry("htu", priv->proc_dir);
+	remove_proc_entry("queue", priv->proc_dir);
+	remove_proc_entry("ver", priv->proc_dir);
+	remove_proc_entry("prio", priv->proc_dir);
+	remove_proc_entry("pvc_mib", priv->proc_dir);
+	remove_proc_entry("atm", priv->frwk->proc_dir);
+}
+EXPORT_SYMBOL(vrx318_atm_proc_exit);
+
+
+static int proc_read_vrx_cfg(struct seq_file *seq, void *v)
+{
+	struct vrx318_priv *priv = (struct vrx318_priv *)seq->private;
+	const char *tc_mode_str[] = {
+		"VRX318 Running",
+		"VRX318 Init",
+		"VRX318 NO_TC_Loaded",
+		"VRX318 Switching",
+		"VRX318 Exit"
+	};
+
+	seq_printf(seq, "VRX318 TC mode: %s\n",
+		tc_mode_str[priv->tc_stat]);
+	seq_printf(seq, "DFE loopback: %s\n",
+		priv->param.dfe_loopback ? "Enable" : "Disable");
+	seq_printf(seq, "P2P: %s\n",
+		priv->param.p2p_en ? "Enable" : "Disable");
+	seq_printf(seq, "CDMA_WRITE: %s\n",
+		priv->param.cdma_wr_en ? "Enable" : "Disable");
+	seq_printf(seq, "Link List in SB: %s\n",
+		priv->param.lle_in_sb ? "Enable" : "Disable");
+	seq_printf(seq, "PMAC Enable: %s\n",
+		priv->param.pmac_en ? "Yes" : "No");
+	seq_printf(seq, "ATM QOS: %s\n",
+		priv->param.atm_qos ? "Yes" : "No");
+	seq_printf(seq, "DP ID: %d\n", priv->port_id);
+
+	seq_puts(seq, "ATM parameters:\n");
+	seq_printf(seq, "ATM OAM PRIO: %d\n", priv->param.oam_prio);
+	seq_printf(seq, "ATM QSB_SRVM: %d\n", priv->param.qsb_srvm);
+	seq_printf(seq, "ATM QSB_TAU: %d\n", priv->param.qsb_tau);
+	seq_printf(seq, "ATM QSB_TSTEP: %d\n", priv->param.qsb_tstep);
+	seq_printf(seq, "ATM AAL5 RX MAX PKTSZ: %d\n",
+		priv->param.aal5r_max_pktsz);
+	seq_printf(seq, "ATM AAL5 RX MAX PKTSZ: %d\n",
+		priv->param.aal5r_min_pktsz);
+	seq_printf(seq, "ATM AAL5 TX MAX PKTSZ: %d\n",
+		priv->param.aal5s_max_pktsz);
+
+	return 0;
+}
+
+static int proc_read_vrx_cfg_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_vrx_cfg, PDE_DATA(inode));
+}
+
+static const struct file_operations vrx318_cfg_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_vrx_cfg_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static ssize_t proc_write_dbg(struct file *file, const char __user *buf,
+			size_t count, loff_t *data)
+{
+	char str[32];
+	int len, rlen, i, j;
+	int num, enable = 0;
+	char *param_list[20];
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+
+	num = dp_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+
+	if ((dp_strcmpi(param_list[0], "enable") == 0)
+		|| (dp_strcmpi(param_list[0], "en") == 0)) {
+		enable = 1;
+	} else if (dp_strcmpi(param_list[0], "disable") == 0
+		|| (dp_strcmpi(param_list[0], "dis") == 0)) {
+		enable = -1;
+	} else {
+		goto proc_dbg_help;
+	}
+	if (!param_list[1]) {
+		set_vrx_dbg_flag(g_vrx318_dbg, enable, -1);
+		return count;
+	}
+	for (i = 1; i < num; i++) {
+		for (j = 0; j < ARRAY_SIZE(vrx_dbg_flag_str); j++) {
+			if (dp_strcmpi(param_list[i], vrx_dbg_flag_str[j]) == 0) {
+				set_vrx_dbg_flag(g_vrx318_dbg, enable, BIT(j));
+				break;
+			}
+		}
+	}
+	vrx318_dbg(DBG_INFO, "dbg write:%d\n", g_vrx318_dbg);
+
+	return count;
+
+proc_dbg_help:
+	vrx318_dbg(DBG_INFO, "echo enable err/rx/tx/event/rx_dump/tx_dump/init/info/oam_rx/oam_tx/oam_rx_dump/oam_tx_dump/qos/tc/loopback > dbg\n");
+	vrx318_dbg(DBG_INFO, "echo disable err/rx/tx/event/rx_dump/tx_dump/init/info/oam_rx/oam_tx/oam_rx_dump/oam_tx_dump/qos/tc/loopback > dbg\n");
+	return count;
+}
+
+static int proc_read_dbg(struct seq_file *seq, void *v)
+{
+	int i;
+	seq_printf(seq, "Dbg Enable:0x%08x\n", g_vrx318_dbg);
+	for (i = 0; i < ARRAY_SIZE(vrx_dbg_flag_str); i++) {
+		if ((g_vrx318_dbg & BIT(i)) == BIT(i))
+			seq_printf(seq, "%s ", vrx_dbg_flag_str[i]);
+	}
+	seq_puts(seq, "\n");
+	return 0;
+}
+
+static int proc_read_dbg_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_dbg, PDE_DATA(inode));
+}
+
+static const struct file_operations vrx318_dbg_proc_fops = {
+	.owner      = THIS_MODULE,
+	.open       = proc_read_dbg_seq_open,
+	.read       = seq_read,
+	.write      = proc_write_dbg,
+	.llseek     = seq_lseek,
+	.release    = single_release,
+};
+
+static ssize_t proc_write_tc_switch(struct file *file, const char __user *buf,
+			size_t count, loff_t *data)
+{
+	char str[32];
+	int len, rlen;
+	int num, epid;
+	char *param_list[20];
+	struct vrx318_priv *priv;
+
+	priv = (struct vrx318_priv *)PDE_DATA(file_inode(file));
+
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+	num = dp_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+	if (dp_strcmpi(param_list[0], "unload") == 0) {
+		spin_lock_bh(&priv->fw_lock);
+		priv->tc_stat = VRX318_SWITCHING;
+		spin_unlock_bh(&priv->fw_lock);
+		epid = dp_atoi(param_list[1]);
+		if (epid < priv->ep_num)
+			vrx318_unload_tc(priv, epid);
+		else {
+			vrx318_dbg(DBG_ERR, "epid is not correct\n");
+			return count;
+		}
+		priv->tc_mode[0] = TC_NONE_MODE;
+		spin_lock_bh(&priv->fw_lock);
+		priv->tc_stat = VRX318_NO_TC;
+		spin_unlock_bh(&priv->fw_lock);
+	} else if (dp_strcmpi(param_list[0], "load") == 0) {
+		if (priv->tc_stat != VRX318_NO_TC) {
+			vrx318_dbg(DBG_ERR, "VRX318 Status is not correct\n");
+			return count;
+		}
+		epid = dp_atoi(param_list[2]);
+		if (epid > priv->ep_num - 1) {
+			vrx318_dbg(DBG_ERR, "epid is not correct\n");
+			return count;
+		}
+		if (dp_strcmpi(param_list[1], "atm") == 0) {
+			vrx318_load_tc(priv, epid, TC_ATM_SL_MODE);
+			priv->tc_mode[0] = TC_ATM_SL_MODE;
+		} else if (dp_strcmpi(param_list[1], "ptm") == 0) {
+			vrx318_load_tc(priv, epid, TC_PTM_SL_MODE);
+			priv->tc_mode[0] = TC_PTM_SL_MODE;
+		} else if (dp_strcmpi(param_list[1], "bond") == 0) {
+			vrx318_load_tc(priv, epid, TC_PTM_BND_MODE);
+			priv->tc_mode[0] = TC_PTM_BND_MODE;
+		} else {
+			vrx318_dbg(DBG_ERR, "mode is not correct\n");
+			goto proc_tc_switch_help;
+		}
+
+		spin_lock_bh(&priv->fw_lock);
+		priv->tc_stat = VRX318_RUNNING;
+		spin_unlock_bh(&priv->fw_lock);
+	} else
+		goto proc_tc_switch_help;
+
+	return count;
+
+proc_tc_switch_help:
+	vrx318_dbg(DBG_INFO, "echo load atm/ptm/bond [epid] > tc_switch\n");
+	vrx318_dbg(DBG_INFO, "echo unload [epid] > tc_switch\n");
+	return count;
+}
+
+static const struct file_operations vrx318_tc_switch_proc_fops = {
+	.owner      = THIS_MODULE,
+	.write      = proc_write_tc_switch,
+	.llseek     = noop_llseek,
+};
+static ssize_t proc_write_show_time(struct file *file, const char __user *buf,
+			size_t count, loff_t *data)
+{
+	char str[32];
+	int len, rlen;
+	int num, epid;
+	char *param_list[20];
+	struct vrx318_priv *priv;
+
+	priv = (struct vrx318_priv *)PDE_DATA(file_inode(file));
+
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+	num = dp_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+	if (dp_strcmpi(param_list[1], "yes") == 0) {
+		epid = dp_atoi(param_list[0]);
+		if (epid > 1) {
+			vrx318_dbg(DBG_ERR, "epid is not correct\n");
+			return count;
+			}
+	priv->show_time_stat[epid] = 1;
+	} else if (dp_strcmpi(param_list[1], "no") == 0) {
+		epid = dp_atoi(param_list[0]);
+		if (epid > 1) {
+			vrx318_dbg(DBG_ERR, "epid is not correct\n");
+			return count;
+		}
+	priv->show_time_stat[epid] = 0;
+	} else {
+		goto proc_show_time_help;
+	}
+
+	return count;
+
+proc_show_time_help:
+	vrx318_dbg(DBG_INFO, "echo [epid] yes/no > show_time\n");
+	return count;
+}
+
+static const struct file_operations vrx318_show_time_proc_fops = {
+	.owner      = THIS_MODULE,
+	.write      = proc_write_show_time,
+	.llseek     = noop_llseek,
+};
+
+static int proc_read_ver(struct seq_file *seq, void *v)
+{
+	char *drv_name, *drv_ver;
+
+	get_vrx318_drv_ver(&drv_name, &drv_ver);
+	seq_printf(seq, "%s: Version: %s\n", drv_name, drv_ver);
+
+	return 0;
+}
+
+static int proc_read_ver_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_ver, PDE_DATA(inode));
+}
+
+static const struct file_operations vrx318_ver_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_ver_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+int vrx318_proc_init(struct vrx318_priv *priv)
+{
+	struct proc_dir_entry *entry;
+	struct proc_dir_entry *vrx318_dir;
+
+	vrx318_dir = proc_mkdir("driver/ltq_vrx318", NULL);
+	if (!vrx318_dir)
+		return -ENOMEM;
+
+	entry = proc_create_data("cfg", 0644,
+			vrx318_dir, &vrx318_cfg_proc_fops, (void *)priv);
+	if (!entry)
+		goto err1;
+
+	entry = proc_create_data("dbg", 0644,
+			vrx318_dir, &vrx318_dbg_proc_fops, (void *)priv);
+	if (!entry)
+		goto err2;
+
+	entry = proc_create_data("tc_switch", 0200,
+			vrx318_dir, &vrx318_tc_switch_proc_fops, (void *)priv);
+	if (!entry)
+		goto err3;
+
+	entry = proc_create_data("show_time", 0200,
+			vrx318_dir, &vrx318_show_time_proc_fops, (void *)priv);
+	if (!entry)
+		goto err4;
+
+	entry = proc_create_data("ver", 0644,
+			vrx318_dir, &vrx318_ver_proc_fops, (void *)priv);
+	if (!entry)
+		goto err5;
+
+	priv->proc_dir = vrx318_dir;
+
+	return 0;
+
+err5:
+	remove_proc_entry("show_time", vrx318_dir);
+err4:
+	remove_proc_entry("tc_swtich", vrx318_dir);
+err3:
+	remove_proc_entry("dbg", vrx318_dir);
+err2:
+	remove_proc_entry("cfg", vrx318_dir);
+err1:
+	remove_proc_entry("driver/ltq_vrx318", NULL);
+	return -ENOMEM;
+}
+
+void vrx318_proc_exit(struct vrx318_priv *priv)
+{
+	remove_proc_entry("cfg", priv->proc_dir);
+	remove_proc_entry("dbg", priv->proc_dir);
+	remove_proc_entry("tc_switch", priv->proc_dir);
+	remove_proc_entry("show_time", priv->proc_dir);
+	remove_proc_entry("ver", priv->proc_dir);
+	remove_proc_entry("driver/ltq_vrx318", NULL);
+}
+
+static int proc_read_ptm_wanmib_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_ptm_wanmib, PDE_DATA(inode));
+}
+
+static const struct file_operations vrx318_ptm_wanmib_proc_fops = {
+	.owner      = THIS_MODULE,
+	.open       = proc_read_ptm_wanmib_seq_open,
+	.read       = seq_read,
+	.write      = proc_write_ptm_wanmib,
+	.llseek     = seq_lseek,
+	.release    = single_release,
+};
+
+static int proc_ptm_read_ver(struct seq_file *seq, void *v)
+{
+	struct vrx318_ptm_tc *priv = (struct vrx318_ptm_tc *)seq->private;
+	int i, j;
+	char buf[128];
+
+	if (priv->tc_mode == TC_PTM_BND_MODE) {
+		for (i = 0; i < MAX_VRX318_NUM; i++) {
+			for (j = 0; j < 2; j++) {
+				print_fw_version(buf, &priv->fw_ver[i][j]);
+				seq_printf(seq, "%s", buf);
+			}
+		}
+	} else {
+		for (j = 0; j < 2; j++) {
+			print_fw_version(buf, &priv->fw_ver[priv->ep_id][j]);
+			seq_printf(seq, "%s", buf);
+		}
+	}
+	return 0;
+}
+
+static int proc_ptm_read_ver_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_ptm_read_ver, PDE_DATA(inode));
+}
+
+static const struct file_operations vrx318_ptm_ver_proc_fops = {
+	.owner      = THIS_MODULE,
+	.open       = proc_ptm_read_ver_seq_open,
+	.read       = seq_read,
+	.llseek     = seq_lseek,
+	.release    = single_release,
+};
+
+static int proc_ptm_read_cfg(struct seq_file *seq, void *v)
+{
+	struct vrx318_ptm_tc *priv = (struct vrx318_ptm_tc *)seq->private;
+
+	seq_printf(seq, "PTM mode: %s\n",
+		(priv->tc_mode == TC_PTM_BND_MODE) ?
+		"PTM Bonding mode" : "PTM Single Line mode");
+	if (priv->tc_mode != TC_PTM_BND_MODE)
+		seq_printf(seq, "VRX318 on line: %d\n", priv->ep_id);
+	seq_printf(seq, "Showtime: %d\n", ptm_in_showtime());
+	seq_printf(seq, "Power Saving: %s\n",
+		ptm_power_saving(priv, 0, 0) == 1 ? "Enable" : "Disable");
+	return 0;
+}
+
+static int proc_read_cfg_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_ptm_read_cfg, PDE_DATA(inode));
+}
+
+static ssize_t vrx318_ptm_cfg_proc_write(struct file *file,
+			const char __user *buf, size_t count, loff_t *data)
+{
+	struct vrx318_ptm_tc *priv;
+	u32 base, ep_id, en;
+	int num, len, rlen;
+	char *param_list[32];
+	char str[128];
+
+	priv = (struct vrx318_ptm_tc *)PDE_DATA(file_inode(file));
+	ep_id = priv->ep_id;
+	base = (u32)priv->frwk->ep_dev[ep_id].membase;
+
+	if (!access_ok(VERIFY_READ, buf, count))
+		return -EFAULT;
+
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+	num = dp_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+
+	if (dp_strcmpi(param_list[0], "en") == 0
+		|| dp_strcmpi(param_list[0], "enble") == 0) {
+		en = 1;
+	} else if (dp_strcmpi(param_list[0], "dis") == 0
+		|| dp_strcmpi(param_list[0], "disable") == 0) {
+		en = 0;
+	} else
+		goto proc_ptm_cfg_help;
+
+	if (dp_strcmpi(param_list[1], "ps") == 0
+		|| dp_strcmpi(param_list[1], "powersaving") == 0) {
+		ptm_power_saving(priv, en, 1);
+	}
+
+	return count;
+
+proc_ptm_cfg_help:
+	vrx318_dbg(DBG_INFO, "echo [enable | disable] powersaving > cfg\n");
+	return count;
+}
+
+
+static const struct file_operations vrx318_ptm_cfg_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = proc_read_cfg_seq_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = vrx318_ptm_cfg_proc_write,
+	.release = single_release,
+};
+
+ssize_t proc_ptm_write_prio(struct file *file, const char __user *buf,
+				size_t count, loff_t *data)
+{
+	struct vrx318_ptm_tc *priv;
+	char local_buf[256];
+	int len;
+	char *p1;
+	int prio = -1;
+	int queue = -1;
+	int num;
+	int i;
+	char *param_list[20];
+
+	len = sizeof(local_buf) < count ? sizeof(local_buf) - 1 : count;
+	len = len - copy_from_user(local_buf, buf, len);
+	local_buf[len] = 0;
+	p1 = local_buf;
+
+	num = dp_split_buffer(local_buf, param_list, ARRAY_SIZE(param_list));
+	priv =  (struct vrx318_ptm_tc *)PDE_DATA(file_inode(file));
+	if (dp_strcmpi(param_list[0], "help") == 0)
+		goto proc_ptm_prio_help;
+	else {
+		for (i = 0; i < num; i += 4) {
+			if ((dp_strcmpi(param_list[i], "prio") == 0)
+				|| (dp_strcmpi(param_list[i], "p") == 0))
+				prio = dp_atoi(param_list[i+1]);
+			else
+				vrx318_dbg(DBG_ERR, "Error: expecting prio\n");
+
+			if ((dp_strcmpi(param_list[i+2], "queue") == 0) ||
+				(dp_strcmpi(param_list[i+2], "q") == 0))
+				queue = dp_atoi(param_list[i+3]);
+			else
+				vrx318_dbg(DBG_ERR, "Error: expecting queue\n");
+
+			if (queue < 0 || queue >= PTM_PRIO_Q_NUM
+				|| prio < 0 || prio >= PTM_PRIO_Q_NUM) {
+				vrx318_dbg(DBG_ERR, "%s: invalid parameter: prio: %d, queue: %d\n",
+					__func__, prio, queue);
+				goto proc_ptm_prio_help;
+			} else {
+				vrx318_dbg(DBG_INFO, "prio: %d, queue: %d\n", prio, queue);
+				priv->ptm_prio_queue_map[prio] = queue;
+			}
+		}
+	}
+	return count;
+
+proc_ptm_prio_help:
+	vrx318_dbg(DBG_INFO, "echo prio xx queue xx [prio xx queue xx] > prio\n");
+	return count;
+}
+
+static int proc_ptm_read_prio(struct seq_file *seq, void *v)
+{
+	int i;
+	struct vrx318_ptm_tc *priv = (struct vrx318_ptm_tc *)seq->private;
+		seq_puts(seq, "\n   Prio: ");
+		for (i = 0; i < PTM_PRIO_Q_NUM; i++)
+			seq_printf(seq, "%d ", i);
+			seq_puts(seq, "\n   Qid:  ");
+		for (i = 0; i < PTM_PRIO_Q_NUM; i++)
+			seq_printf(seq, "%d ",
+				priv->ptm_prio_queue_map[i]);
+			seq_puts(seq, "\n");
+	return 0;
+}
+
+static int proc_ptm_read_prio_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_ptm_read_prio, PDE_DATA(inode));
+}
+
+static const struct file_operations vrx318_ptm_prio_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_ptm_read_prio_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.write		= proc_ptm_write_prio,
+	.release	= single_release,
+};
+
+int vrx318_ptm_proc_init(void *ptm_priv)
+{
+	struct proc_dir_entry *entry;
+	struct proc_dir_entry *vrx318_dir;
+	struct vrx318_ptm_tc *priv = (struct vrx318_ptm_tc *)ptm_priv;
+
+	vrx318_dir = proc_mkdir("ptm", priv->frwk->proc_dir);
+	if (!vrx318_dir)
+		return -ENOMEM;
+
+	entry = proc_create_data("mem", 0644,
+			vrx318_dir, &vrx318_mem_proc_fops, (void *)priv);
+	if (!entry)
+		goto err1;
+
+	entry = proc_create_data("pp32", 0644,
+			vrx318_dir, &vrx318_pp32_proc_fops, (void *)priv);
+	if (!entry)
+		goto err2;
+
+	entry = proc_create_data("wanmib", 0644,
+			vrx318_dir, &vrx318_ptm_wanmib_proc_fops, (void *)priv);
+	if (!entry)
+		goto err3;
+
+	entry = proc_create_data("ver", 0644,
+			vrx318_dir, &vrx318_ptm_ver_proc_fops, (void *)priv);
+	if (!entry)
+		goto err4;
+
+	entry = proc_create_data("cfg", 0644,
+			vrx318_dir, &vrx318_ptm_cfg_proc_fops, (void *)priv);
+	if (!entry)
+		goto err5;
+
+	entry = proc_create_data("prio", 0644,
+			vrx318_dir, &vrx318_ptm_prio_proc_fops, (void *)priv);
+	if (!entry)
+		goto err6;
+
+	priv->proc_dir = vrx318_dir;
+	return 0;
+
+err6:
+	remove_proc_entry("cfg", vrx318_dir);
+err5:
+	remove_proc_entry("ver", vrx318_dir);
+err4:
+	remove_proc_entry("wanmib", vrx318_dir);
+err3:
+	remove_proc_entry("pp32", vrx318_dir);
+err2:
+	remove_proc_entry("mem", vrx318_dir);
+err1:
+	remove_proc_entry("driver/ltq_vrx318/ptm/", NULL);
+	return -ENOMEM;
+}
+EXPORT_SYMBOL(vrx318_ptm_proc_init);
+
+void vrx318_ptm_proc_exit(void *ptm_priv)
+{
+	struct vrx318_ptm_tc *priv = (struct vrx318_ptm_tc *)ptm_priv;
+	remove_proc_entry("cfg", priv->proc_dir);
+	remove_proc_entry("ver", priv->proc_dir);
+	remove_proc_entry("wanmib", priv->proc_dir);
+	remove_proc_entry("mem", priv->proc_dir);
+	remove_proc_entry("pp32", priv->proc_dir);
+	remove_proc_entry("prio", priv->proc_dir);
+	remove_proc_entry("ptm", priv->frwk->proc_dir);
+}
+EXPORT_SYMBOL(vrx318_ptm_proc_exit);
diff --git a/drivers/net/ethernet/lantiq/vrx318/vrx318_ptm_tc.c b/drivers/net/ethernet/lantiq/vrx318/vrx318_ptm_tc.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/vrx318/vrx318_ptm_tc.c
@@ -0,0 +1,2990 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * Copyright (C) 2015 Zhu YiXin<yixin.zhu@lantiq.com>
+ */
+#define DEBUG
+#include <linux/ctype.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/jiffies.h>
+#include <linux/seq_file.h>
+#include <linux/printk.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/completion.h>
+#include <net/datapath_api.h>
+#include <net/lantiq_cbm.h>
+#include <net/lantiq_cbm_api.h>
+#include <net/datapath_proc_api.h>
+#include <net/vrx318_dsl_api.h>
+#include <net/ppa_stack_al.h>
+
+#include <lantiq.h>
+#include <lantiq_soc.h>
+#include <lantiq_irq.h>
+#include <lantiq_pcie.h>
+#include <lantiq_ptm.h>
+
+#include "include/vrx318_ppe_fw_const.h"
+#include "include/vrx318_edma.h"
+#include "include/vrx318_fw_prereq.h"
+#include "include/vrx318_ppe_ptm_tc_ds.h"
+#include "include/vrx318_ppe_fw_ds.h"
+#include "include/vrx318_ppe_bonding_ds.h"
+#include "include/unified_qos_ds_be.h"
+#include "include/vrx318_e1_addr_def.h"
+
+#include "include/vrx318_common.h"
+#include "include/vrx318_framework.h"
+#include "include/vrx318_ptm_tc.h"
+#include "include/vrx318_api.h"
+
+#include "include/vrx318_proc.h"
+#include "fw/vrx318_e1.h"
+#include "fw/vrx318_pp32_1.h"
+
+
+static struct vrx318_ptm_tc *g_ptm_tc;
+static const char const *g_ptm_dev_name = "VRX318_PTM_SL";
+static const char const *g_bnd_dev_name[2]
+	= {"VRX318_US_BONDING", "VRX318_DS_BONDING"};
+
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+enum ltq_cpufreq_state ptm_coc_state = LTQ_CPUFREQ_PS_D0;
+static void do_coc_tasklet(unsigned long);
+static DECLARE_TASKLET(g_coc_tasklet, do_coc_tasklet, 0);
+#endif
+
+static int ptm_open(struct net_device *);
+static int ptm_stop(struct net_device *);
+static struct net_device_stats *ptm_get_stats(struct net_device *);
+static int ptm_set_mac_address(struct net_device *, void *);
+static void ptm_tx_timeout(struct net_device *);
+static int ptm_ioctl(struct net_device *, struct ifreq *, int);
+static int ptm_change_mtu(struct net_device *, int);
+static int ptm_xmit(struct sk_buff *, struct net_device *);
+
+static inline void ether_addr_copy(u8 *dst, const u8 *src)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+	*(u32 *)dst = *(const u32 *)src;
+	*(u16 *)(dst + 4) = *(const u16 *)(src + 4);
+#else
+	u16 *a = (u16 *)dst;
+	const u16 *b = (const u16 *)src;
+
+	a[0] = b[0];
+	a[1] = b[1];
+	a[2] = b[2];
+#endif
+}
+
+void vrx318_ptm_param_setup(struct vrx318_priv *priv, int *q_map)
+{
+	int i, j;
+	int *q_g_map = priv->param.q_gamma_map;
+
+	for (i = 0; i < ARRAY_SIZE(priv->param.q_gamma_map); i++) {
+		q_g_map[i] = q_map[i] & ((1 << 8) - 1);
+		for (j = 0; j < i; j++)
+			q_g_map[i] &= ~(q_g_map[j]);
+	}
+}
+
+static int vrx318_bonding_init(struct vrx318_ptm_tc *priv,
+				struct vrx318_priv *frwk_priv)
+{
+	if (!frwk_priv->param.p2p_en) {
+		priv->ptm_bnd_cfg.soc_peer_membase
+			= get_zeroed_page(GFP_KERNEL);
+		if (!priv->ptm_bnd_cfg.soc_peer_membase) {
+			vrx318_dbg(DBG_INIT,
+				"peer sync memory allocation fail\n");
+			return -ENOMEM;
+		}
+		priv->ptm_bnd_cfg.soc_peer_phybase
+			= dma_map_single(frwk_priv->pdev,
+				(void *)priv->ptm_bnd_cfg.soc_peer_membase,
+				PAGE_SIZE, DMA_TO_DEVICE);
+		if (dma_mapping_error(frwk_priv->pdev,
+			priv->ptm_bnd_cfg.soc_peer_phybase)) {
+			free_page(priv->ptm_bnd_cfg.soc_peer_membase);
+			return -EFAULT;
+		}
+	}
+
+	return 0;
+}
+
+static struct net_device_ops g_ptm_netdev_ops = {
+	.ndo_open		= ptm_open,
+	.ndo_stop		= ptm_stop,
+	.ndo_get_stats		= ptm_get_stats,
+	.ndo_set_mac_address	= ptm_set_mac_address,
+	.ndo_start_xmit		= ptm_xmit,
+	.ndo_tx_timeout		= ptm_tx_timeout,
+	.ndo_do_ioctl		= ptm_ioctl,
+	.ndo_change_mtu		= ptm_change_mtu,
+};
+
+/*TODO: LED RELATED STAFF */
+static int ptm_open(struct net_device *dev)
+{
+	struct vrx318_ptm_tc *priv = netdev_priv(dev);
+	dp_subif_t dp_id;
+
+	vrx318_dbg(DBG_EVENT, "ptm open\n");
+
+	dp_id.port_id = priv->frwk->port_id;
+	dp_id.subif = -1;
+
+	if (dp_register_subif(priv->frwk->owner, dev,
+		dev->name, &dp_id, 0) != DP_SUCCESS) {
+		vrx318_dbg(DBG_ERR, "%s: failed to register subif: %s\n",
+			__func__, dev->name);
+		return -EIO;
+	}
+	priv->subif_id = dp_id.subif;
+	netif_tx_start_all_queues(dev);
+
+	return 0;
+}
+
+static int ptm_stop(struct net_device *dev)
+{
+	struct vrx318_ptm_tc *priv = netdev_priv(dev);
+	dp_subif_t dp_id;
+
+	vrx318_dbg(DBG_EVENT, "ptm stop\n");
+
+	dp_id.port_id = priv->frwk->port_id;
+	dp_id.subif = priv->subif_id;
+
+	if (dp_register_subif(priv->frwk->owner, dev,
+		dev->name, &dp_id, DP_F_DEREGISTER) != DP_SUCCESS) {
+		vrx318_dbg(DBG_ERR, "%s: failed to close for device: %s\n",
+			__func__, dev->name);
+		return -EIO;
+	}
+
+	netif_tx_stop_all_queues(dev);
+	return 0;
+}
+
+static struct net_device_stats *ptm_get_stats(struct net_device *dev)
+{
+	struct vrx318_ptm_tc *priv = netdev_priv(dev);
+
+	return &priv->stats;
+}
+
+static int ptm_set_mac_address(struct net_device *dev, void *p)
+{
+	struct sockaddr *addr = (struct sockaddr *)p;
+
+	if (netif_running(dev))
+		return -EBUSY;
+
+	vrx318_dbg(DBG_EVENT, "ptm mac address update!\n");
+	ether_addr_copy(dev->dev_addr, addr->sa_data);
+	return 0;
+}
+
+static void ptm_tx_timeout(struct net_device *dev)
+{
+	struct vrx318_ptm_tc *priv = netdev_priv(dev);
+
+	vrx318_dbg(DBG_EVENT, "PTM tx timeout\n");
+	dev->trans_start = jiffies;
+	priv->stats.tx_errors++;
+
+	netif_tx_wake_all_queues(dev);
+}
+
+static int ptm_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	switch (cmd) {
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* Change the MTU value of the netwrok device interfaces */
+static int ptm_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if (new_mtu < ETH_ZLEN || new_mtu > (MAX_MTU + PMAC_SIZE - ETH_HLEN))
+		return -EINVAL;
+
+	vrx318_dbg(DBG_EVENT, "PTM MTU update: %d\n", new_mtu);
+	dev->mtu = new_mtu;
+
+	return 0;
+}
+
+static int ptm_showtime_enter(const unsigned char line_idx,
+		struct port_cell_info *port_cell, void *xdata_addr)
+{
+	struct vrx318_priv *priv;
+
+	priv = g_ptm_tc->frwk;
+	if (line_idx >= priv->ep_num)
+		return -EINVAL;
+
+	priv->show_time_stat[line_idx] = 1;
+	return 0;
+}
+
+static int ptm_showtime_exit(const unsigned char line_idx)
+{
+	struct vrx318_priv *priv;
+
+	priv = g_ptm_tc->frwk;
+	if (line_idx >= priv->ep_num)
+		return -EINVAL;
+
+	priv->show_time_stat[line_idx] = 0;
+	return 0;
+}
+
+int ptm_in_showtime(void)
+{
+	int i;
+
+	struct vrx318_ptm_tc *priv = g_ptm_tc;
+	if (priv->frwk->param.dfe_loopback)
+		return 1;
+
+	if (priv->tc_mode == TC_PTM_BND_MODE) {
+		for (i = 0; i < MAX_VRX318_NUM; i++) {
+			if (priv->frwk->show_time_stat[i] != 0)
+				return 1;
+		}
+		return 0;
+	} else {
+		return priv->frwk->show_time_stat[priv->ep_id];
+	}
+}
+
+/**
+ *  ps_en:  1 - Enable powersaving, 0 -Disable Powersaving
+ *  flag:   0 - Get the powersaving cfg, 1 - Set the powersaving
+ */
+int ptm_power_saving(struct vrx318_ptm_tc *priv, int ps_en, int flag)
+{
+	struct psave_cfg ps_cfg;
+	u32 base;
+
+	base = (u32)priv->frwk->ep_dev[priv->ep_id].membase;
+	dword_clear(&ps_cfg, sizeof(ps_cfg));
+	dword_mem_read(&ps_cfg, SB_BUFFER(__PSAVE_CFG),
+			sizeof(ps_cfg), base);
+	if (!flag)
+		return ps_cfg.sleep_en;
+	else {
+		ps_cfg.sleep_en = !!(ps_en);
+		dword_mem_write(SB_BUFFER(__PSAVE_CFG), &ps_cfg,
+			sizeof(ps_cfg), base);
+	}
+
+	return 0;
+}
+
+static inline void dump_skb_info(struct sk_buff *skb)
+{
+	vrx318_dbg(DBG_PKT_TX,
+		"skb: head: 0x%x, data: 0x%x, tail: 0x%x, end: 0x%x, len: %d\n",
+		(u32)skb->head, (u32)skb->data, (u32)skb->tail,
+		(u32)skb->end, skb->len);
+	vrx318_dbg(DBG_PKT_TX,
+		"skb: clone: %d, users: %d\n",
+		skb->cloned, atomic_read(&skb->users));
+	vrx318_dbg(DBG_PKT_TX,
+		"skb: nfrag: %d\n", skb_shinfo(skb)->nr_frags);
+}
+
+static int ptm_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct vrx318_ptm_tc *priv = netdev_priv(dev);
+	dp_subif_t dp_id;
+	int qid, prio;
+
+	if (!ptm_in_showtime())
+		goto PTM_XMIT_DROP;
+
+	if (skb_padto(skb, ETH_ZLEN))
+		goto PTM_XMIT_DROP;
+
+	dump_skb_info(skb);
+
+	prio = skb->priority < PTM_PRIO_Q_NUM ?
+			skb->priority : PTM_PRIO_Q_NUM - 1;
+	qid = priv->ptm_prio_queue_map[prio];
+	dp_id.subif = priv->subif_id | PTM_DESC_QID(qid);
+	/* Set EP */
+	skb->DW1 = (skb->DW1 & (~0xF00)) | ((priv->frwk->port_id & 0xF) << 8);
+	/* Set Subif */
+	skb->DW0 = (skb->DW0 & (~0x7FFF)) | (dp_id.subif);
+
+	dp_id.port_id = priv->frwk->port_id;
+
+	if (dp_xmit(dev, &dp_id, skb, skb->len, 0) == 0) {
+		priv->stats.tx_packets++;
+		priv->stats.tx_bytes += skb->len;
+	} else {
+		priv->stats.tx_dropped++;
+	}
+
+	return 0;
+
+PTM_XMIT_DROP:
+	dev_kfree_skb_any(skb);
+	priv->stats.tx_dropped++;
+	return 0;
+}
+
+static int32_t ptm_dp_stop_tx(struct net_device *dev)
+{
+	netif_tx_stop_all_queues(dev);
+
+	return 0;
+}
+
+static int32_t ptm_dp_restart_tx(struct net_device *dev)
+{
+	netif_tx_start_all_queues(dev);
+	return 0;
+}
+
+static void ptm_rx(struct vrx318_ptm_tc *priv,
+	int len, struct sk_buff *skb)
+{
+	if (skb->len < ETH_ZLEN || skb->len > MAX_MTU) {
+		vrx318_dbg(DBG_ERR, "illegal packet len: %d\n", skb->len);
+		priv->stats.rx_length_errors++;
+		goto rx_err_exit;
+	}
+
+	skb->protocol = eth_type_trans(skb, priv->dev);
+
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += len;
+
+	if (netif_rx(skb) == NET_RX_DROP)
+		priv->stats.rx_dropped++;
+
+	return;
+
+rx_err_exit:
+	dev_kfree_skb_any(skb);
+	priv->stats.rx_errors++;
+
+	return;
+}
+
+
+static int32_t ptm_dp_rx(struct net_device *rx_dev,
+		struct net_device *tx_dev, struct sk_buff *skb, int32_t len)
+{
+	int32_t err;
+	struct vrx318_ptm_tc *priv = g_ptm_tc;
+
+	if (likely(rx_dev == priv->dev)) {
+		vrx318_dbg(DBG_PKT_RX, "Receive Packet from VRX318\n");
+	} else if (tx_dev == priv->dev)
+		vrx318_dbg(DBG_PKT_RX, "rcv a undeliver packet from DP lib, itf:%s\n",
+			tx_dev->name);
+	else {
+		vrx318_dbg(DBG_PKT_RX,
+			"unknown packet forward to VRX318 ptm driver!!!, RX: %s, TX: %s\n",
+			!rx_dev ? "None" : rx_dev->name,
+			!tx_dev ? "None" : tx_dev->name);
+		err = -ENODEV;
+		goto rx_err_exit;
+	}
+
+	/* remove PMAC header */
+	skb_pull(skb, 8);
+
+	ptm_rx(priv, len, skb);
+	return 0;
+
+rx_err_exit:
+	dev_kfree_skb_any(skb);
+	priv->stats.rx_errors++;
+
+	return err;
+}
+
+static int ptm_get_subif_id(struct net_device *netif, struct sk_buff *skb,
+			struct atm_vcc *vcc, uint8_t dst_mac[MAX_ETH_ALEN],
+			dp_subif_t *subif, uint32_t flags)
+{
+	struct vrx318_ptm_tc *priv = g_ptm_tc;
+	int qid, prio;
+	if (subif->port_id != priv->frwk->port_id) {
+		vrx318_dbg(DBG_ERR,
+			"%s: Port_id not compliance: Input: %d, Local: %d\n",
+			__func__, subif->port_id, priv->frwk->port_id);
+		return -EINVAL;
+	}
+	if (skb)
+			prio = skb->priority < PTM_PRIO_Q_NUM ?
+					skb->priority : PTM_PRIO_Q_NUM - 1;
+	else
+			prio = 0;
+	qid = priv->ptm_prio_queue_map[prio];
+	subif->subif = priv->subif_id | PTM_DESC_QID(qid);
+
+	return 0;
+}
+
+static void ptm_setup(struct net_device *dev)
+{
+	ether_setup(dev);
+	dev->watchdog_timeo = 10 * HZ;
+	dev->netdev_ops = &g_ptm_netdev_ops;
+}
+
+static void vrx318_ptm_cfg_init(struct vrx318_priv *priv,
+				enum dsl_tc_mode tc_mode)
+{
+	/* PTM Single Line or bonding P2P CDMA WR is *must* enabled */
+	if (tc_mode == TC_PTM_SL_MODE
+		|| (tc_mode == TC_PTM_BND_MODE && priv->param.p2p_en))
+		priv->param.cdma_wr_en = 1;
+	else
+		priv->param.cdma_wr_en = 0;
+}
+
+static int vrx318_ptm_dev_init(struct vrx318_priv *frwk_priv,
+				enum dsl_tc_mode tc_mode)
+{
+	int err;
+	struct net_device *dev;
+	struct vrx318_ptm_tc *priv;
+	const char macaddr[ETH_ALEN]
+		= {0xAC, 0x9A, 0x96, 0x11, 0x22, 0x33};
+
+	dev = alloc_netdev(sizeof(*priv), "ptm%d", ptm_setup);
+	if (!dev) {
+		vrx318_dbg(DBG_INIT, "Cannot alloc net device\n");
+		return -ENOMEM;
+	}
+	priv = netdev_priv(dev);
+	priv->dev = dev;
+	priv->frwk = frwk_priv;
+	ether_addr_copy(dev->dev_addr, macaddr);
+	SET_NETDEV_DEV(dev, frwk_priv->pdev);
+	spin_lock_init(&priv->ptm_lock);
+	init_completion(&priv->comp);
+
+	/* Initial bonding */
+	if (tc_mode == TC_PTM_BND_MODE) {
+		err = vrx318_bonding_init(priv, frwk_priv);
+		if (err)
+			goto err1;
+	}
+
+	err = register_netdev(priv->dev);
+	if (err)
+		goto err1;
+
+	g_ptm_tc = priv;
+
+	return 0;
+err1:
+	free_netdev(priv->dev);
+	g_ptm_tc = NULL;
+
+	return err;
+}
+
+void vrx318_ptm_exit(void)
+{
+	struct vrx318_ptm_tc *priv = g_ptm_tc;
+
+	if (!priv)
+		return;
+
+	unregister_netdev(priv->dev);
+	free_netdev(priv->dev);
+
+	if (priv->ptm_bnd_cfg.soc_peer_membase != 0)
+		free_page(priv->ptm_bnd_cfg.soc_peer_membase);
+	kfree(priv);
+	g_ptm_tc = 0;
+
+	vrx318_dbg(DBG_INFO, "VRX318 PTM exited!\n");
+}
+
+static void vrx318_tc_reg_init(unsigned long base)
+{
+	u32 val;
+
+	/* TODO: convert to meaningful configuration */
+	vrx318_w32(0x00020000, PPE_SFSM_PGCNT0, base);
+	vrx318_w32(0x00020000, PPE_SFSM_PGCNT1, base);
+
+	vrx318_w32(0x000001E0, PPE_DREG_AT_CFG0, base);
+	vrx318_w32(0x000001E0, PPE_DREG_AT_CFG1, base);
+	vrx318_w32(0x00000000, PPE_DREG_AT_IDLE0, base);
+	vrx318_w32(0x00000000, PPE_DREG_AT_IDLE1, base);
+
+	vrx318_w32(0x000001F0, PPE_DREG_AR_CFG0, base);
+	vrx318_w32(0x000001F0, PPE_DREG_AR_CFG1, base);
+	vrx318_w32(0x00000000, PPE_DREG_AR_IDLE0, base);
+	vrx318_w32(0x00000000, PPE_DREG_AR_IDLE1, base);
+
+	vrx318_w32(0x0000080C, PPE_DREG_B0_LADR, base);
+	vrx318_w32(0x0000080C, PPE_DREG_B1_LADR, base);
+
+	vrx318_w32(0x00003000, PPE_SFSM_DBA0, base);
+	vrx318_w32(0x00003EE0, PPE_SFSM_CBA0, base);
+	vrx318_w32(0x00003770, PPE_SFSM_DBA1, base);
+	vrx318_w32(0x00003F50, PPE_SFSM_CBA1, base);
+
+	vrx318_w32(0x00002000, PPE_FFSM_DBA0, base);
+	vrx318_w32(0x00002550, PPE_FFSM_DBA1, base);
+
+	vrx318_w32(0x00030070, PPE_SFSM_CFG0, base);
+	vrx318_w32(0x00030070, PPE_SFSM_CFG1, base);
+
+	/* KEEP IDLE (BC0 & BC1) */
+	val = vrx318_r32(PPE_SFSM_CFG0, base) | (1 << 15);
+	vrx318_w32(val, PPE_SFSM_CFG0, base);
+	val = vrx318_r32(PPE_SFSM_CFG1, base) | (1 << 15);
+	vrx318_w32(val, PPE_SFSM_CFG1, base);
+
+	/* Enable SFSM (BC0 & BC1) */
+	val = vrx318_r32(PPE_SFSM_CFG0, base) | (1 << 14);
+	vrx318_w32(val, PPE_SFSM_CFG0, base);
+	val = vrx318_r32(PPE_SFSM_CFG1, base) | (1 << 14);
+	vrx318_w32(val, PPE_SFSM_CFG1, base);
+
+	vrx318_w32(0xF0D10000, PPE_FFSM_IDLE_HEAD_BC0, base);
+	vrx318_w32(0xF0D10000, PPE_FFSM_IDLE_HEAD_BC1, base);
+
+	vrx318_w32(0x00030050, PPE_FFSM_CFG0, base);
+	vrx318_w32(0x00030050, PPE_FFSM_CFG1, base);
+
+	return;
+}
+
+static void vrx318_pdma_init(unsigned long base, int is_bonding)
+{
+	/* TODO: convert to meaningful configuration */
+	vrx318_w32(0x00000001, PPE_PDMA_CFG, base);
+	vrx318_w32(0x00082C00, PPE_PDMA_RX_CTX_CFG, base);
+	vrx318_w32(0x00081B00, PPE_PDMA_TX_CTX_CFG, base);
+	vrx318_w32(PPE_PDMA_RX_MAX_LEN_REG_CONF, PPE_PDMA_RX_MAX_LEN_REG, base);
+
+	vrx318_w32(0x000F003F, PPE_PDMA_RX_DELAY_CFG, base);
+	vrx318_dbg(DBG_INIT, "%s: Configure PDMA for jumbo 0x%08X\n",
+						__func__, PPE_PDMA_RX_MAX_LEN_REG_CONF);
+
+	vrx318_w32(0x00000011, PPE_SAR_MODE_CFG, base);
+	vrx318_w32(0x00081200, PPE_SAR_RX_CTX_CFG, base);
+	vrx318_w32(0x00082E00, PPE_SAR_TX_CTX_CFG, base);
+	vrx318_w32(0x00001021, PPE_SAR_POLY_CFG_SET0, base);
+	vrx318_w32(0x1EDC6F41, PPE_SAR_POLY_CFG_SET1, base);
+	vrx318_w32(0x04C11DB7, PPE_SAR_POLY_CFG_SET2, base);
+	vrx318_w32(0x00000F3E, PPE_SAR_CRC_SIZE_CFG, base);
+
+	vrx318_w32(0x01001900, PPE_SAR_PDMA_RX_CMDBUF_CFG, base);
+	vrx318_w32(0x01001A00, PPE_SAR_PDMA_TX_CMDBUF_CFG, base);
+
+	vrx318_w32(0x00203FC0, PPE_SAR_PDMA_RX_FW_CMDBUF_CFG, base);
+	vrx318_w32(0x00203FE0, PPE_SAR_PDMA_TX_FW_CMDBUF_CFG, base);
+
+	vrx318_w32(0x00000007, PPE_PDMA_IER, base);
+
+	return;
+}
+
+static void vrx318_tc_hw_init(u32 base, int is_bonding)
+{
+	vrx318_tc_reg_init(base);
+	vrx318_pdma_init(base, is_bonding);
+}
+
+void vrx318_tc_fw_init(u32 base, int is_bonding, int pmac_en)
+{
+	std_des_cfg_t std_des_cfg;
+	qos_cfg_t qos_cfg;
+	qosq_flow_ctrl_cfg_t qosq_flow_ctrl_cfg;
+	struct psave_cfg ps_cfg;
+	struct test_mode test_mode;
+	struct rx_bc_cfg rx_bc_cfg;
+	struct tx_bc_cfg tx_bc_cfg;
+	struct rx_gamma_itf_cfg rx_gamma_itf_cfg;
+	struct tx_gamma_itf_cfg tx_gamma_itf_cfg;
+
+	u32 dst_addr;
+	int i;
+
+	vrx318_w32(0x3C30, DS_FLOW_CTRL_CFG, base);
+
+	dword_clear(&std_des_cfg, sizeof(std_des_cfg));
+	/* this field replaces byte_off in rx descriptor of VDSL ingress */
+	std_des_cfg.byte_off = is_bonding ? 2 : 0;
+	std_des_cfg.data_len = DMA_PACKET_SIZE;
+	dword_mem_write(SB_BUFFER(__STD_DES_CFG), &std_des_cfg,
+		sizeof(std_des_cfg), base);
+
+	dword_clear(&qos_cfg, sizeof(qos_cfg));
+	/* 16 * (cgu_get_pp32_clock() / 1000000) */
+	qos_cfg.time_tick = get_ppe_clk(base) / 62500;
+	qos_cfg.qosq_num = QOSQ_NUM;
+	qos_cfg.qos_en = 0;
+	dword_mem_write(SB_BUFFER(__QOS_CFG), &qos_cfg, sizeof(qos_cfg), base);
+
+	dword_clear(&ps_cfg, sizeof(ps_cfg));
+	ps_cfg.start_state = 0;
+	ps_cfg.sleep_en = 0; /* Disable sleep mode by default */
+	dword_mem_write(SB_BUFFER(__PSAVE_CFG), &ps_cfg, sizeof(ps_cfg), base);
+
+	dword_clear(&qosq_flow_ctrl_cfg, sizeof(qosq_flow_ctrl_cfg));
+	qosq_flow_ctrl_cfg.large_frame_size = 128;
+	qosq_flow_ctrl_cfg.large_frame_drop_th = 16;
+	dword_mem_write(SB_BUFFER(__QOSQ_FLOW_CTRL_CFG), &qosq_flow_ctrl_cfg,
+			sizeof(qosq_flow_ctrl_cfg), base);
+
+	dword_clear(&test_mode, sizeof(test_mode));
+	test_mode.mib_clear_mode    = 0;
+	test_mode.test_mode         = 0;
+	dword_mem_write(SB_BUFFER(__TEST_MODE), &test_mode,
+		sizeof(test_mode), base);
+
+	vrx318_w32(DMA_PACKET_SIZE, SB_BUFFER(__MAX_PKT_SIZE_CFG), base);
+
+	dword_clear(&rx_bc_cfg, sizeof(rx_bc_cfg));
+	rx_bc_cfg.local_state   = 0;
+	rx_bc_cfg.remote_state  = 0;
+	rx_bc_cfg.to_false_th   = 7;
+	rx_bc_cfg.to_looking_th = 3;
+	for (i = 0; i < 2; i++) {
+		dst_addr = __RX_BC0_CFG_STATS_CFG + (i * sizeof(rx_bc_cfg) / 4);
+		dword_mem_write(SB_BUFFER(dst_addr), &rx_bc_cfg,
+			sizeof(rx_bc_cfg), base);
+	}
+
+	dword_clear(&tx_bc_cfg, sizeof(tx_bc_cfg));
+	tx_bc_cfg.fill_wm = 2;
+	tx_bc_cfg.uflw_wm = 2;
+	for (i = 0; i < 2; i++) {
+		dst_addr = __TX_BC0_CFG_STATS_CFG + (i * sizeof(tx_bc_cfg) / 4);
+		dword_mem_write(SB_BUFFER(dst_addr), &tx_bc_cfg,
+			sizeof(tx_bc_cfg), base);
+	}
+
+	dword_clear(&rx_gamma_itf_cfg, sizeof(rx_gamma_itf_cfg));
+	rx_gamma_itf_cfg.receive_state		= 0;
+	rx_gamma_itf_cfg.rx_min_len		= 64;
+	rx_gamma_itf_cfg.rx_pad_en		= 1;
+	/* disable Ethernet FCS verification during bonding */
+	rx_gamma_itf_cfg.rx_eth_fcs_ver_dis	= is_bonding ? 1 : 0;
+	rx_gamma_itf_cfg.rx_rm_eth_fcs		= is_bonding ? 0 : 1;
+	rx_gamma_itf_cfg.rx_tc_crc_ver_dis	= 0;
+	rx_gamma_itf_cfg.rx_tc_crc_size		= 1;
+	rx_gamma_itf_cfg.rx_eth_fcs_result	= 0xC704DD7B;
+	rx_gamma_itf_cfg.rx_tc_crc_result	= 0x1D0F1D0F;
+	rx_gamma_itf_cfg.rx_crc_cfg		= 0x2500;
+	rx_gamma_itf_cfg.rx_eth_fcs_init_value	= 0xFFFFFFFF;
+	rx_gamma_itf_cfg.rx_tc_crc_init_value	= 0x0000FFFF;
+	rx_gamma_itf_cfg.rx_max_len_sel		= 0;
+	rx_gamma_itf_cfg.rx_edit_num2		= 0;
+	rx_gamma_itf_cfg.rx_edit_pos2		= 0;
+	rx_gamma_itf_cfg.rx_edit_type2		= 0;
+	rx_gamma_itf_cfg.rx_edit_en2		= 0;
+	/* no PMAC header insertion during bonding or grx350 platform*/
+	rx_gamma_itf_cfg.rx_edit_num1		= (is_bonding || !pmac_en) ? 0 : 4;
+	rx_gamma_itf_cfg.rx_edit_pos1		= 0;
+	/* no PMAC header insertion during bonding or grx350 platform*/
+	rx_gamma_itf_cfg.rx_edit_type1		= (is_bonding || !pmac_en) ? 0 : 1;
+	rx_gamma_itf_cfg.rx_edit_en1		= (is_bonding || !pmac_en) ? 0 : 1;
+	/*  E5: byte swap of value 0x07000000 */
+	rx_gamma_itf_cfg.rx_inserted_bytes_1l	= 0x00000007;
+	rx_gamma_itf_cfg.rx_inserted_bytes_1h	= 0;
+	rx_gamma_itf_cfg.rx_inserted_bytes_2l	= 0;
+	rx_gamma_itf_cfg.rx_inserted_bytes_2h	= 0;
+	rx_gamma_itf_cfg.rx_len_adj		= -2;
+	for (i = 0; i < 4; i++) {
+		dst_addr = __RX_GIF0_CFG_STATS_CFG +
+			(i * sizeof(rx_gamma_itf_cfg) / 4);
+		dword_mem_write(SB_BUFFER(dst_addr), &rx_gamma_itf_cfg,
+			sizeof(rx_gamma_itf_cfg), base);
+	}
+
+	dword_clear(&tx_gamma_itf_cfg, sizeof(tx_gamma_itf_cfg));
+	tx_gamma_itf_cfg.tx_len_adj		= is_bonding ? 2 : 6;
+	tx_gamma_itf_cfg.tx_crc_off_adj		= 6;
+	tx_gamma_itf_cfg.tx_min_len		= 0;
+	tx_gamma_itf_cfg.tx_eth_fcs_gen_dis	= is_bonding ? 1 : 0;
+	tx_gamma_itf_cfg.tx_tc_crc_size		= 1;
+	tx_gamma_itf_cfg.tx_crc_cfg		= is_bonding ? 0x2F02 : 0x2F00;
+	tx_gamma_itf_cfg.tx_eth_fcs_init_value	= 0xFFFFFFFF;
+	tx_gamma_itf_cfg.tx_tc_crc_init_value	= 0x0000FFFF;
+	for (i = 0; i < 4; i++) {
+		/*  queue_mapping is reserved in VRX318
+		* tx_gamma_itf_cfg.queue_mapping = g_queue_gamma_map[i];
+		*/
+		dst_addr = __TX_GIF0_CFG_STATS_CFG +
+			(i * sizeof(tx_gamma_itf_cfg) / 4);
+		dword_mem_write(SB_BUFFER(dst_addr), &tx_gamma_itf_cfg,
+			sizeof(tx_gamma_itf_cfg), base);
+	}
+
+	/* Initialize TX Ctrl K Table */
+	vrx318_w32(0x90111293, TX_CTRL_K_TABLE(0), base);
+	vrx318_w32(0x14959617, TX_CTRL_K_TABLE(1), base);
+	vrx318_w32(0x18999A1B, TX_CTRL_K_TABLE(2), base);
+	vrx318_w32(0x9C1D1E9F, TX_CTRL_K_TABLE(3), base);
+	vrx318_w32(0xA02122A3, TX_CTRL_K_TABLE(4), base);
+	vrx318_w32(0x24A5A627, TX_CTRL_K_TABLE(5), base);
+	vrx318_w32(0x28A9AA2B, TX_CTRL_K_TABLE(6), base);
+	vrx318_w32(0xAC2D2EAF, TX_CTRL_K_TABLE(7), base);
+	vrx318_w32(0x30B1B233, TX_CTRL_K_TABLE(8), base);
+	vrx318_w32(0xB43536B7, TX_CTRL_K_TABLE(9), base);
+	vrx318_w32(0xB8393ABB, TX_CTRL_K_TABLE(10), base);
+	vrx318_w32(0x3CBDBE3F, TX_CTRL_K_TABLE(11), base);
+	vrx318_w32(0xC04142C3, TX_CTRL_K_TABLE(12), base);
+	vrx318_w32(0x44C5C647, TX_CTRL_K_TABLE(13), base);
+	vrx318_w32(0x48C9CA4B, TX_CTRL_K_TABLE(14), base);
+	vrx318_w32(0xCC4D4ECF, TX_CTRL_K_TABLE(15), base);
+
+	return;
+}
+
+/**
+* Initialize VRX318 PPE FW General Configuration
+* is_bonding = 0               : single line application
+* is_bonding = 1, ep_id = 0: bonding application, us_bonding_master
+* is_bonding = 1, ep_id = 1: bonding application, ds_bonding_master
+*/
+static void vrx318_gen_cfg_init(struct vrx318_ptm_tc *priv, u32 base,
+		int is_bonding, u32 ep_id, u32 peer_base,
+		int cdma_write_data_en, int pmac_en)
+{
+	task_cfg_t task_cfg[2];
+
+	dword_clear(&task_cfg, sizeof(task_cfg));
+	/* Default Task Configuration (Single-Line) */
+	task_cfg[0].pp32_core_id	= 0;	task_cfg[1].pp32_core_id	= 1;
+	task_cfg[0].us_bonding_master	= 0;	task_cfg[1].us_bonding_master	= 0;
+	task_cfg[0].us_segment_en	= 0;	task_cfg[1].us_segment_en	= 0;
+	task_cfg[0].us_buf_release_en	= 0;	task_cfg[1].us_buf_release_en	= 0;
+
+	task_cfg[0].ds_bonding_master	= 0;	task_cfg[1].ds_bonding_master	= 0;
+	task_cfg[0].ds_pkt_dispatch_en	= 0;	task_cfg[1].ds_pkt_dispatch_en	= 0;
+	task_cfg[0].ds_pkt_reconstruct_en = 0;	task_cfg[1].ds_pkt_reconstruct_en = 0;
+	task_cfg[0].ds_pkt_flush_en	= 0;	task_cfg[1].ds_pkt_flush_en	= 0;
+
+	task_cfg[0].tc_us_en		= 1;	task_cfg[1].tc_us_en		= 0;
+	task_cfg[0].tc_ds_en		= 1;	task_cfg[1].tc_ds_en		= 0;
+
+	task_cfg[0].des_sync_en		= 0;	task_cfg[1].des_sync_en		= 1;
+	task_cfg[0].edma_write_lle_gen_en = 0;	task_cfg[1].edma_write_lle_gen_en = 1;
+	task_cfg[0].edma_read_lle_gen_en = 0;   task_cfg[1].edma_read_lle_gen_en = 1;
+	task_cfg[0].edma_post_proc_en	= 0;	task_cfg[1].edma_post_proc_en	= 1;
+	task_cfg[0].qos_wfq_shaping_en	= 0;	task_cfg[1].qos_wfq_shaping_en	= 1;
+	task_cfg[0].qos_dispatch_en	= 0;	task_cfg[1].qos_dispatch_en	= 1;
+	task_cfg[0].qos_replenish_en	= 0;	task_cfg[1].qos_replenish_en	= 1; /* enable for QoS */
+
+	if (is_bonding == 1) {
+		bond_conf_t bond_conf;
+		dword_clear(&bond_conf, sizeof(bond_conf));
+
+		bond_conf.dplus_fp_fcs_en   = 0x1;
+		bond_conf.max_frag_size     = 0x200;
+		/* 0x4 if two bearer channels are enabled */
+		bond_conf.bg_num            = 0x2;
+		bond_conf.bond_mode         = 0x0;
+		bond_conf.e1_bond_en        = 0x1;
+		bond_conf.d5_acc_dis        = 0x1;
+		bond_conf.d5_b1_en          = 0x1;
+
+		dword_mem_write(SB_BUFFER(__BOND_CONF), &bond_conf,
+			sizeof(bond_conf), base);
+
+		/**
+		* Get Peer-Base Address
+		* address = ((PPE_BASE + 0x6000 * 4) & FPI_address_mask) + 0x20000000 + peer_base
+		* PI concept required to use peer to peer write. pcie switch issue is retained.
+		* The address from driver's perspective is 0x6000 larger than FW. so by default, driver factor in 0x6000
+		* so that FW no need to re-calcuate the address.
+		* Give FW the base address, by put 6000 DWORDS offset by default.
+		*/
+		if (cdma_write_data_en) {/* TODO: for GRX350, need check the new peer addr mapping */
+			vrx318_w32_sb(((PPE_BASE + FW_BASE_ADDR_OFFSET * 4) & VRX318_SMASK) + VRX318_OB_BADDR + peer_base,
+				__BOND_PEER_SB_BASE, base);
+		} else {
+			/**
+			* As FW cannot write to the peer due to pcie switch don't support it.
+			* Driver will read it out and write to the peer.
+			* The peer address will be write to 0 to remind FW to use local address.
+			*/
+			vrx318_w32_sb(0, __BOND_PEER_SB_BASE, base);
+		}
+		vrx318_w32_sb(0x07800000, __DS_PKT_PMAC_HEADER, base);
+	}
+
+	if ((is_bonding == 1) && (ep_id == US_BONDING_MASTER)) {
+
+		vrx318_w32_sb(0x0000FE01, __US_BG_QMAP, base);
+		vrx318_w32_sb(0x00002211, __US_BG_GMAP, base);
+
+		task_cfg[1].us_bonding_master	= 1;
+		task_cfg[1].us_segment_en	= 1;
+		task_cfg[1].us_buf_release_en	= 1;
+
+		task_cfg[0].us_bonding_des_sync	= 0;	task_cfg[1].us_bonding_des_sync	= 1;
+		task_cfg[0].ds_bonding_des_sync	= 0;	task_cfg[1].ds_bonding_des_sync	= 1;
+
+		task_cfg[0].des_sync_en		= 0;	task_cfg[1].des_sync_en		= 1;
+		task_cfg[0].edma_write_lle_gen_en = 0;	task_cfg[1].edma_write_lle_gen_en = 1;
+		task_cfg[0].edma_read_lle_gen_en = 0;	task_cfg[1].edma_read_lle_gen_en = 1;
+		task_cfg[0].edma_post_proc_en	= 0;	task_cfg[1].edma_post_proc_en	= 1;
+
+		task_cfg[0].qos_wfq_shaping_en	= 1;	task_cfg[1].qos_wfq_shaping_en	= 0;
+		task_cfg[0].qos_dispatch_en	= 1;	task_cfg[1].qos_dispatch_en	= 0;
+		task_cfg[0].qos_replenish_en	= 1;	task_cfg[1].qos_replenish_en	= 0;
+
+	} else if ((is_bonding == 1) && (ep_id == DS_BONDING_MASTER)) {
+
+		task_cfg[1].ds_bonding_master	= 1;
+		task_cfg[1].ds_pkt_dispatch_en	= 1;
+		task_cfg[1].ds_pkt_reconstruct_en = 1;
+		task_cfg[1].ds_pkt_flush_en	= 1;
+
+		task_cfg[0].us_bonding_des_sync	= 0;	task_cfg[1].us_bonding_des_sync	= 1;
+		task_cfg[0].ds_bonding_des_sync	= 0;	task_cfg[1].ds_bonding_des_sync	= 1;
+
+		task_cfg[0].des_sync_en		= 1;	task_cfg[1].des_sync_en		= 0;
+		task_cfg[0].edma_write_lle_gen_en = 0;	task_cfg[1].edma_write_lle_gen_en = 1;
+		task_cfg[0].edma_read_lle_gen_en = 0;	task_cfg[1].edma_read_lle_gen_en = 1;
+		task_cfg[0].edma_post_proc_en	= 0;	task_cfg[1].edma_post_proc_en	= 1;
+
+		task_cfg[0].qos_wfq_shaping_en	= 0;	task_cfg[1].qos_wfq_shaping_en	= 0;
+		task_cfg[0].qos_dispatch_en	= 0;	task_cfg[1].qos_dispatch_en	= 0;
+		task_cfg[0].qos_replenish_en	= 0;	task_cfg[1].qos_replenish_en	= 0;
+
+		vrx318_w32_sb(0x00002211, __DS_BG_GMAP, base);
+	}
+
+	dword_mem_write(SB_BUFFER(__PP32_0_TASK_CFG), &task_cfg, sizeof(task_cfg), base);
+
+	if (!pmac_en)
+		vrx318_w32_sb(1, __SOC_FAMILY, base);
+}
+
+/* Initialize eDMA Configuration Registers and PPE FW eDMA Context
+* Single line applcation:   MUST be called
+* Bonding line application: MUST be called for both VRX318
+*/
+static void vrx318_edma_init(u32 base, int lle_in_sb, int cdma_write_data_en)
+{
+	unsigned int dst_addr;
+	edma_ch_ctrl_t edma_ch_ctrl;
+	edma_lle_link_t edma_lle_link;
+	edma_ch_ctxt_t edma_ch_ctxt;
+
+	/* edma hang detection init James */
+	vrx318_w32_sb(10, __EDMA_HANG_DETECT_TH, base);
+
+	/* Initialize eDMA Channel Control Register - Data Structure */
+	dword_clear(&edma_ch_ctrl, sizeof(edma_ch_ctrl));
+
+	edma_ch_ctrl.at = 0; /* ??? Address Translation (AT) */
+	edma_ch_ctrl.tc = 0; /* Traffic Class (TC) */
+	edma_ch_ctrl.td = 0; /* Traffic Digest, the PCIe core adds the ECRC */
+	/* field and sets the TD bit in TLP header */
+	edma_ch_ctrl.ro = 1; /* Releaxed Ording */
+	edma_ch_ctrl.ns = 0; /* No Snoop */
+	/* ??? Function Number (FN) for generated MRd/MWr DMA TLPs */
+	edma_ch_ctrl.fn = 0;
+	/* The core uses this when generating the RID for the MRd/MWr DMA TLP */
+	edma_ch_ctrl.ll_en = 1;	/* link list enable */
+	/* Consumer Cycles State (CCS).
+	* Used in Link List mode only. It is used to synchronize
+	* the Producer (Software) and the Consumer (DMA).
+	* *You must initialize this bit.* The DMA updates
+	* this bit during linked list operation
+	*/
+	edma_ch_ctrl.ccs = 1;
+	/* Channel Status (CS)
+	* The Channel Status bits identify the current operational
+	* state of the DMA write or read channel.
+	* 00: Reserved
+	* 01: Running, this channel is active and transferring data
+	* 10: Halted. An error condition has been detected.
+	* and the DMA has stopped this channel
+	* 11: Stopped. The DMA has transferred all data for
+	* this channel or you have prematurely stopped
+	* this channel by writing to the Stop field of
+	* of the DMA R/W doorbell register
+	*/
+	edma_ch_ctrl.cs	= 3;
+
+	edma_ch_ctrl.rie = 0; /* remote interrupt enable */
+	edma_ch_ctrl.lie = 0; /* local interrupt enable */
+	/* load link pointer (LLP)
+	* Used in link list mode only. Indicates that
+	* this linked list element is a link element, and
+	* it's LL element pointer DWORDs are pointint to the next
+	* (non-contiguous) element
+	* the DMA loads this field with the LLP of the
+	* linked list element
+	*/
+	edma_ch_ctrl.llp = 0;
+	/* Toggle Cycle Bit (TCB)
+	* Indicates to the DMA to toglle its intepreation of
+	* the CB. Used in linked list mode only. It is used
+	* to synchorize the Producer (Software) and the
+	* Consumer (DMA).
+	* The DMA loads this field with the TCB of the linked
+	* list element.
+	* Note: this field is not defined in a ata LL element
+	*/
+	edma_ch_ctrl.tcb = 0;
+	/* Cycle Bit (CB)
+	* Unsed in Linked list mode only.  It is used
+	* to synchorize the Producer (Software) and the
+	* Consumer (DMA).
+	* The DMA loads this field with the CB of the linked
+	* list elment
+	*/
+	edma_ch_ctrl.cb = 0;
+
+	if (cdma_write_data_en == 0) {
+		/* Configure eDMA Write Channel */
+
+		/* Disable eDMA Write Channel */
+		vrx318_w32(0, EDMA_WCH_EN, base);
+
+		/* Select Write Channel */
+		vrx318_w32(EDMA_WRITE_CH, EDMA_CH_IDX, base);
+
+		/* Setup eDMA Channel Control Register */
+		dword_mem_write(EDMA_CH_CTRL, &edma_ch_ctrl,
+				sizeof(edma_ch_ctrl), base);
+
+		vrx318_w32(0, EDMA_TRANSFER_SIZE, base);
+		vrx318_w32(0, EDMA_SAR_LOW, base);
+		vrx318_w32(0, EDMA_SAR_HIGH, base);
+		vrx318_w32(0, EDMA_DAR_LOW, base);
+		vrx318_w32(0, EDMA_DAR_HIGH, base);
+
+		if (lle_in_sb == 1)
+			vrx318_w32(SB_BUFFER(__DS_EDMA_LLE_BASE),
+					EDMA_LL_PTR_LOW, base);
+		else
+			vrx318_w32(__DS_EDMA_LLE_FPI_BASE,
+					EDMA_LL_PTR_LOW, base);
+
+		vrx318_w32(0, EDMA_LL_PTR_HIGH, base);
+
+		/* Setup Write Channel Link List Elements */
+		dword_clear(&edma_lle_link, sizeof(edma_lle_link));
+		edma_lle_link.tcb = 1;
+		edma_lle_link.llp = 1;
+		if (lle_in_sb == 1) {
+			edma_lle_link.lle_ptr_low
+				= SB_BUFFER(__DS_EDMA_LLE_BASE);
+			dst_addr = SB_BUFFER(__DS_EDMA_LLE_BASE);
+		} else {
+			edma_lle_link.lle_ptr_low = __DS_EDMA_LLE_FPI_BASE;
+			dst_addr = __DS_EDMA_LLE_FPI_BASE;
+		}
+
+		dword_ep_clear(dst_addr,
+			(EDMA_WCH_DATA_LLE_NUM * sizeof(edma_lle_data_t)),
+			base);
+		dst_addr += EDMA_WCH_DATA_LLE_NUM * sizeof(edma_lle_data_t);
+		dword_mem_write(dst_addr, &edma_lle_link,
+				sizeof(edma_lle_link), base);
+
+		/* Setup EDMA Write Channel Context */
+		dword_clear(&edma_ch_ctxt, sizeof(edma_ch_ctxt));
+		edma_ch_ctxt.edma_ch_type = EDMA_WRITE_CH;
+		edma_ch_ctxt.edma_pcs = 1;
+		edma_ch_ctxt.edma_lle_num = EDMA_WCH_DATA_LLE_NUM;
+		edma_ch_ctxt.edma_lle_sb_size = EDMA_WCH_DATA_LLE_NUM * 6;
+		edma_ch_ctxt.edma_lle_sb_base = __DS_EDMA_LLE_BASE;
+		edma_ch_ctxt.edma_lle_ext_sb_base = __DS_EDMA_LLE_EXT_BASE;
+		if (lle_in_sb == 1)
+			edma_ch_ctxt.edma_lle_fpi_base
+				= SB_BUFFER(__DS_EDMA_LLE_BASE);
+		else
+			edma_ch_ctxt.edma_lle_fpi_base
+				= __DS_EDMA_LLE_FPI_BASE;
+
+		edma_ch_ctxt.edma_ch_status = EDMA_STOPPED;
+		dword_mem_write(SB_BUFFER(__DS_EDMA_WRITE_CH_CFG_CTXT),
+			&edma_ch_ctxt, sizeof(edma_ch_ctxt), base);
+
+		/* Enable eDMA Write Channel */
+		vrx318_w32(1, EDMA_WCH_EN, base);
+	}
+
+	/* Configure eDMA Read Channel */
+
+	/* Disable eDMA Read Channel */
+	vrx318_w32(0, EDMA_RCH_EN, base);
+
+	/* Select Read Channel */
+	vrx318_w32(EDMA_READ_CH, EDMA_CH_IDX, base);
+
+	/* Setup eDMA Channel Control Register */
+	dword_mem_write(EDMA_CH_CTRL, &edma_ch_ctrl,
+			sizeof(edma_ch_ctrl), base);
+
+	vrx318_w32(0, EDMA_TRANSFER_SIZE, base);
+	vrx318_w32(0, EDMA_SAR_LOW, base);
+	vrx318_w32(0, EDMA_SAR_HIGH, base);
+	vrx318_w32(0, EDMA_DAR_LOW, base);
+	vrx318_w32(0, EDMA_DAR_HIGH, base);
+
+	if (lle_in_sb == 1)
+		vrx318_w32(SB_BUFFER(__US_EDMA_LLE_BASE),
+			EDMA_LL_PTR_LOW, base);
+	else
+		vrx318_w32(__US_EDMA_LLE_FPI_BASE, EDMA_LL_PTR_LOW, base);
+
+	vrx318_w32(0, EDMA_LL_PTR_HIGH, base);
+
+	/* Setup Read Channel Link List Elements */
+	dword_clear(&edma_lle_link, sizeof(edma_lle_link));
+	edma_lle_link.tcb = 1;
+	edma_lle_link.llp = 1;
+	if (lle_in_sb == 1) {
+		edma_lle_link.lle_ptr_low = SB_BUFFER(__US_EDMA_LLE_BASE);
+		dst_addr = SB_BUFFER(__US_EDMA_LLE_BASE);
+	} else {
+		edma_lle_link.lle_ptr_low = __US_EDMA_LLE_FPI_BASE;
+		dst_addr = __US_EDMA_LLE_FPI_BASE;
+	}
+
+	dword_ep_clear(dst_addr,
+		(EDMA_RCH_DATA_LLE_NUM * sizeof(edma_lle_data_t)),
+		base);
+	dst_addr += EDMA_RCH_DATA_LLE_NUM * sizeof(edma_lle_data_t);
+	dword_mem_write(dst_addr, &edma_lle_link, sizeof(edma_lle_link), base);
+
+	/* Setup EDMA Read Channel Context */
+	dword_clear(&edma_ch_ctxt, sizeof(edma_ch_ctxt));
+	edma_ch_ctxt.edma_ch_type = EDMA_READ_CH;
+	edma_ch_ctxt.edma_pcs = 1;
+	edma_ch_ctxt.edma_lle_num = EDMA_RCH_DATA_LLE_NUM;
+	edma_ch_ctxt.edma_lle_sb_size = EDMA_RCH_DATA_LLE_NUM * 6;
+	edma_ch_ctxt.edma_lle_sb_base = __US_EDMA_LLE_BASE;
+	edma_ch_ctxt.edma_lle_ext_sb_base = __US_EDMA_LLE_EXT_BASE;
+	if (lle_in_sb == 1)
+		edma_ch_ctxt.edma_lle_fpi_base
+			= SB_BUFFER(__US_EDMA_LLE_BASE);
+	else
+		edma_ch_ctxt.edma_lle_fpi_base
+			= __US_EDMA_LLE_FPI_BASE;
+
+	edma_ch_ctxt.edma_ch_status = EDMA_STOPPED;
+	dword_mem_write(SB_BUFFER(__US_EDMA_READ_CH_CFG_CTXT), &edma_ch_ctxt,
+			sizeof(edma_ch_ctxt), base);
+
+	/* Enable eDMA Read Channel */
+	vrx318_w32(1, EDMA_RCH_EN, base);
+
+	return;
+}
+
+/**
+ *  Initialize Fastpath descriptor queue config contxt
+ *  Initialize dest list of the desq_cfg_ctxt
+ */
+static void vrx318_us_fastpath_desq_cfg_ctxt_init(struct vrx318_priv *priv, u32 base)
+{
+	desq_cfg_ctxt_t desq_cfg;
+	int i;
+	u32 desc_addr;
+	rx_descriptor_t rx_desc;
+
+	if (!priv->soc_cfg.soc_fp_us_dnum)
+		return;
+
+	dword_clear(&desq_cfg, sizeof(desq_cfg));
+	/* Initialize US Fast-Path Descriptor Queue Config/Context */
+	desq_cfg.des_in_own_val	= US_FASTPATH_DES_OWN;
+	desq_cfg.fast_path	= 1;
+	desq_cfg.mbox_int_en	= 0;
+	desq_cfg.des_sync_needed = 1;
+	desq_cfg.des_num	= priv->soc_cfg.soc_fp_us_dnum; /* max: 64 */
+	desq_cfg.des_base_addr	= __US_FAST_PATH_DES_LIST_BASE;
+
+	dword_mem_write(SB_BUFFER(__US_FP_INQ_DES_CFG_CTXT),
+		&desq_cfg, sizeof(desq_cfg), base);
+
+	/* Initialize Descriptors in Shadow Fast Path Descriptor List */
+	/* Shadow descriptor list of SoC, only own bit is required for init */
+	dword_clear(&rx_desc, sizeof(rx_desc));
+	rx_desc.own = !desq_cfg.des_in_own_val;
+	desc_addr = desq_cfg.des_base_addr;
+	for (i = 0; i < desq_cfg.des_num; i++) {
+		dword_mem_write(SB_BUFFER(desc_addr),
+			&rx_desc, sizeof(rx_desc), base);
+		desc_addr += sizeof(rx_desc)/sizeof(u32);
+	}
+}
+
+/**
+ *  Initialize CPU path descriptor queue config contxt
+ *  Initialize dest list of the desq_cfg_ctxt
+ */
+static void vrx318_us_cpupath_desq_cfg_ctxt_init(struct vrx318_priv *priv, u32 base)
+{
+	desq_cfg_ctxt_t desq_cfg;
+	int i;
+	u32 desc_addr;
+	rx_descriptor_t rx_desc;
+
+	if (!priv->soc_cfg.soc_cpu_us_dnum)
+		return;
+
+	dword_clear(&desq_cfg, sizeof(desq_cfg));
+	/* Initialize US CPU-Path Descriptor Queue Config/Context */
+	desq_cfg.des_in_own_val	= US_CPUPATH_DES_OWN;
+	desq_cfg.fast_path	= 0;
+	desq_cfg.mbox_int_en	= 0;
+	desq_cfg.des_sync_needed = 1;
+	desq_cfg.des_num	= priv->soc_cfg.soc_cpu_us_dnum; /* max: 64 */
+	desq_cfg.des_base_addr	= __US_CPU_PATH_DEST_LIST_BASE;
+
+	dword_mem_write(SB_BUFFER(__US_CPU_INQ_DES_CFG_CTXT),
+		&desq_cfg, sizeof(desq_cfg), base);
+
+	/* Initialize Descriptors in Shadow CPU Path Descriptor List */
+	/* Shadow descriptor list of SoC, only own bit is required for init */
+	dword_clear(&rx_desc, sizeof(rx_desc));
+	rx_desc.own = !desq_cfg.des_in_own_val;
+	desc_addr = desq_cfg.des_base_addr;
+	for (i = 0; i < desq_cfg.des_num; i++) {
+		dword_mem_write(SB_BUFFER(desc_addr),
+			&rx_desc, sizeof(rx_desc), base);
+		desc_addr += sizeof(rx_desc)/sizeof(u32);
+	}
+}
+
+static void vrx318_ds_pkt_desq_cfg_ctxt_init(struct vrx318_priv *priv, u32 base)
+{
+	desq_cfg_ctxt_t desq_cfg;
+	int i;
+	u32 desc_addr, *soc_ds_base;
+	rx_descriptor_t rx_desc;
+	dma_addr_t phy_addr;
+
+	if (!priv->soc_cfg.soc_ds_dnum)
+		return;
+
+	dword_clear(&desq_cfg, sizeof(desq_cfg));
+	/* Initialize DS PKT Descriptor Queue Config/Context */
+	desq_cfg.des_in_own_val	= DS_PKT_DES_OWN;
+	desq_cfg.fast_path	= 0;
+	desq_cfg.mbox_int_en	= 0;
+	desq_cfg.des_sync_needed = 1;
+	desq_cfg.des_num	= priv->soc_cfg.soc_ds_dnum;
+	desq_cfg.des_base_addr	= __DS_PKT_DES_LIST_BASE;
+
+	dword_mem_write(SB_BUFFER(__DS_PKT_DESQ_CFG_CTXT),
+		&desq_cfg, sizeof(desq_cfg), base);
+
+	/* Initialize Descriptors in Shadow DS Path Descriptor List */
+	/**
+	* Shadow descriptor list of SoC, in GRX350, the descriptor pointer
+	* should be synced from SoC. in GRX330, it should be allocated by
+	* VRX318 itself.
+	*/
+	dword_clear(&rx_desc, sizeof(rx_desc));
+	rx_desc.own = !desq_cfg.des_in_own_val;
+	rx_desc.sop = 1;
+	rx_desc.eop = 1;
+	rx_desc.data_len = DMA_PACKET_SIZE;
+
+	desc_addr = desq_cfg.des_base_addr;
+	soc_ds_base = (u32 *)priv->soc_cfg.soc_ds_dbase;
+
+	for (i = 0; i < desq_cfg.des_num; i++) {
+		if (!priv->param.pmac_en) /* GRX500 */
+			rx_desc.data_ptr
+				= soc_ds_base[i * 2 + 1] + VRX318_OB_BADDR;
+		else { /* GRX330 */
+			if (alloc_data_buffer(priv, rx_desc.data_len,
+					&phy_addr, NULL)) {
+				vrx318_dbg(DBG_INIT, "%s/%d: Alloc buffer failed\n",
+					__func__, __LINE__);
+				BUG();
+				return;
+			}
+			rx_desc.data_ptr = VRX318_OB_BADDR + phy_addr;
+		}
+		dword_mem_write(SB_BUFFER(desc_addr),
+			&rx_desc, sizeof(rx_desc), base);
+		desc_addr += sizeof(rx_desc)/sizeof(u32);
+	}
+}
+
+/**
+ * 1. Initialize FASTPATH/CPU PATH/DS PATH SoC Sync Config Context
+ * 2. Initialize FASTPATH/CPU PATH/DS PATH Des Config Context
+ * 3. Initialize Descriptor list that associated to the above Des Config Context
+ * 4. Initialize (if required) SoC part Descriptor list
+ */
+void vrx318_des_sync_init(struct vrx318_priv *priv,
+			u32 base, int is_bonding, u32 ep_id)
+{
+	des_sync_cfg_ctxt_t sync_cfg;
+	int idx = 0;
+	struct vrx318_soc_cfg *soc_cfg = &priv->soc_cfg;
+
+	if ((is_bonding == 0) ||
+		((is_bonding == 1) && (ep_id == US_BONDING_MASTER))) {
+		/* Fast-Path Sync Config/Context */
+		if (soc_cfg->soc_fp_us_dnum) {
+			dword_clear(&sync_cfg, sizeof(sync_cfg));
+			sync_cfg.sync_type = US_READ_WRITE_SYNC;
+			sync_cfg.max_polling_intv = 4;
+			sync_cfg.desq_cfg_ctxt = __US_FP_INQ_DES_CFG_CTXT;
+			sync_cfg.soc_des_own_val = soc_cfg->soc_us_desc_own;
+			sync_cfg.ext_desc_base_addr
+				= VRX318_OB_BADDR + soc_cfg->soc_fp_us_phybase;
+			dword_mem_write(DES_SYNC_CFG_CTXT(idx),
+				&sync_cfg, sizeof(sync_cfg), base);
+			idx += 1;
+			vrx318_us_fastpath_desq_cfg_ctxt_init(priv, base);
+		}
+
+		/* CPU-Path Sync Config/Context */
+		if (soc_cfg->soc_cpu_us_dnum) {
+			dword_clear(&sync_cfg, sizeof(sync_cfg));
+			sync_cfg.sync_type = US_READ_WRITE_SYNC;
+			sync_cfg.max_polling_intv = 10;
+			sync_cfg.desq_cfg_ctxt = __US_CPU_INQ_DES_CFG_CTXT;
+			sync_cfg.soc_des_own_val = soc_cfg->soc_us_desc_own;
+			sync_cfg.ext_desc_base_addr
+				= VRX318_OB_BADDR + soc_cfg->soc_cpu_us_phybase;
+			dword_mem_write(DES_SYNC_CFG_CTXT(idx),
+				&sync_cfg, sizeof(sync_cfg), base);
+			idx += 1;
+			vrx318_us_cpupath_desq_cfg_ctxt_init(priv, base);
+		}
+	}
+
+	if ((is_bonding == 0) ||
+		((is_bonding == 1) && (ep_id == DS_BONDING_MASTER))) {
+
+		/* Downstream Sync Config/Context */
+		if (soc_cfg->soc_ds_dnum) {
+			sync_cfg.sync_type = DS_WRITE_READ_SYNC;
+			sync_cfg.max_polling_intv = 1;
+			sync_cfg.desq_cfg_ctxt = __DS_PKT_DESQ_CFG_CTXT;
+			sync_cfg.soc_des_own_val = soc_cfg->soc_ds_desc_own;
+			sync_cfg.ext_desc_base_addr
+				= VRX318_OB_BADDR + soc_cfg->soc_ds_phybase;
+			dword_mem_write(DES_SYNC_CFG_CTXT(idx),
+				&sync_cfg, sizeof(sync_cfg), base);
+			idx += 1;
+			vrx318_ds_pkt_desq_cfg_ctxt_init(priv, base);
+		}
+	}
+
+	return;
+}
+
+void vrx318_us_fragq_desq_cfg_ctxt_init(struct vrx318_ptm_tc *priv,
+					u32 base, int is_bonding, u32 ep_id)
+{
+	int i, j;
+	unsigned int start_fragq_id;
+	desq_cfg_ctxt_t desq_cfg;
+	tx_descriptor_t *p_tx_desc;
+	rx_descriptor_t rx_desc;
+	dma_addr_t phy_addr;
+	unsigned int dst_addr;
+
+	if (is_bonding == 0)
+		return;
+
+	dword_clear(&desq_cfg, sizeof(desq_cfg));
+
+	if (ep_id == DS_BONDING_MASTER)
+		start_fragq_id = 4;
+	else
+		start_fragq_id = 0;
+
+	for (i = start_fragq_id; i < MAX_FRAGQ_NUM; i++) {
+		/* Initialize Upstream Descriptor Queue Config/Context */
+		desq_cfg.des_in_own_val  = 1;
+		desq_cfg.fast_path       = 0;
+		desq_cfg.mbox_int_en     = 0;
+		desq_cfg.des_sync_needed = 0;
+		desq_cfg.gif_id          = i;
+		desq_cfg.des_num         = 16;
+		desq_cfg.des_base_addr
+			= __US_FRAGQ_DES_LIST_BASE + (i * 3 * desq_cfg.des_num);
+		desq_cfg.bp_des_base_addr
+			= __US_FRAGQ_DES_LIST_BASE + (i * 3 * desq_cfg.des_num)
+				+ (2 * desq_cfg.des_num);
+
+		dword_mem_write(SB_BUFFER(__US_FRAGQ_CFG_CTXT_BASE + (i * (sizeof(desq_cfg) / sizeof(unsigned int)))),
+			&desq_cfg, sizeof(desq_cfg), base);
+
+		/* Only OWN bit initialization is required in FragmentQ Descriptor List */
+		dword_clear(&rx_desc, sizeof(rx_desc));
+		rx_desc.own = !US_FRAGQ_DES_OWN;
+		dst_addr = __US_FRAGQ_DES_LIST_BASE;
+		for (j = 0; j < desq_cfg.des_num; j++) {
+			dword_mem_write(SB_BUFFER(dst_addr), &rx_desc, sizeof(rx_desc), base);
+			dst_addr += i * 48 + j * 2;
+		}
+
+		if (ep_id == DS_BONDING_MASTER) {
+			/* Initialize the Upstream Shadow Descriptors in SoC */
+			for (j = 0; j < desq_cfg.des_num; j++) {
+				if ((j % 4) == 0) {
+					p_tx_desc = (tx_descriptor_t *)(priv->ptm_bnd_cfg.soc_peer_membase
+						+ ((i - 4) * (128 * 4)) + ((j / 4) * 64) + 8);
+					p_tx_desc->own = !desq_cfg.des_in_own_val;
+				}
+			}
+		}
+	}
+
+	phy_addr = dma_map_single(priv->frwk->pdev,
+			(void *)priv->ptm_bnd_cfg.soc_peer_membase,
+			PAGE_SIZE, DMA_TO_DEVICE);
+	if (unlikely(dma_mapping_error(priv->frwk->pdev, phy_addr)))
+		BUG();
+	dma_unmap_single(priv->frwk->pdev, phy_addr, PAGE_SIZE, DMA_TO_DEVICE);
+
+	return;
+}
+
+
+/**
+ * SOC Memory format:
+ * Enqueue Counter | Dequeue Counter | Des 0 | BP_Des 0 | Des 1 | BP_Des 1 |
+ * Des 2 | BP_Des2 | Des 3 | BP_Des 3 |  res 0 | res 1 |
+ * Enequeue counter:  1 DW
+ * Dequeue  counter:  1 DW
+ * Des x                 :  2 DWs, total 2 * 4 = 8 DWs
+ * BP_Des x            :  1 DW,  total 1 * 4 = 4 DW
+ * res 0                  :  1 DW
+ * res 1                  :  1 DW
+ * Total = 16 DWs
+ * FW sync structure by structure, which means it will sync
+ * 4 Descriptors in one time. Driver only need to set 1st descriptor's owerbit
+ * Each GIF has 4 of above structure.  4 * 16 = 64 DWs
+ * Total 4 GIFs. so total 4* 64 = 256 DWs.
+ *
+ * Driver pre-alloc one page(4KB) for bonding descriptor synchronization
+ * for US sync, max 512 DWs, by now , we use 256 DWs.
+ * for DS sync, max 512 DWs, by now,  we use 256 DWs.
+ */
+void vrx318_bonding_des_sync_init(struct vrx318_ptm_tc *priv,
+				u32 base, int is_bonding, u32 ep_id)
+{
+	unsigned int i;
+	bond_des_sync_cfg_ctxt_t sync_cfg;
+
+	if (is_bonding == 0 || priv->frwk->param.p2p_en)
+		return;
+
+	dword_clear(&sync_cfg, sizeof(sync_cfg));
+
+	/* Initialize Upstream Bonding Descriptor Synchronization Data Structures */
+	for (i = 0; i < 4; i++) {
+		sync_cfg.des_idx = 0;
+		sync_cfg.dir = UPSTREAM;
+		sync_cfg.state = __BOND_DES_SYNC_IDLE_STATE;
+		if (ep_id == US_BONDING_MASTER)
+			sync_cfg.sync_type = WRITE_READ_SYNC;
+		else
+			sync_cfg.sync_type = READ_WRITE_SYNC;
+		/*sync only need sync frag q from q4 to q7, that's reason offset (4 * 8) */
+		sync_cfg.desq_cfg_ctxt
+			= (__US_FRAGQ_CFG_CTXT_BASE + (4 * 8)) + (i * 8);
+		sync_cfg.soc_sync_addr = VRX318_OB_BADDR +
+			priv->ptm_bnd_cfg.soc_peer_phybase + (i * 64 * 4);
+		sync_cfg.cdma_rx_des_dw1
+			= SB_BUFFER(__BOND_US_DES_SYNC_BUF_BASE);
+
+		dword_mem_write(BOND_US_DES_SYNC_CFG_CTXT(i),
+			&sync_cfg, sizeof(sync_cfg), base);
+
+		vrx318_w32_sb(VRX318_OB_BADDR + priv->ptm_bnd_cfg.soc_peer_phybase + (i * 64 * 4),
+			__US_BOND_SOC_SYNC_ADDR_GIF4 + i, base);
+
+		/* Only Initialize 1 US Bonding Descriptor Synchornization Config/Context */
+		/* Only one GIF interface available by now */
+		i = 3;
+	}
+	vrx318_w32_sb(SB_BUFFER(__BOND_US_DES_SYNC_BUF_BASE),
+		__BOND_US_DES_SYNC_RX_DES_DW1, base);
+
+	/* Initialize Downstream Bonding Descriptor Synchronization Data Structures */
+	dword_clear(&sync_cfg, sizeof(sync_cfg));
+
+	sync_cfg.des_idx = 0;
+	sync_cfg.dir = DOWNSTREAM;
+	sync_cfg.state = __BOND_DES_SYNC_IDLE_STATE;
+	if (ep_id == US_BONDING_MASTER)
+		sync_cfg.sync_type = WRITE_READ_SYNC;
+	else
+		sync_cfg.sync_type = READ_WRITE_SYNC;
+	sync_cfg.desq_cfg_ctxt = __DS_FRAGQ_CFG_CTXT_BASE;
+
+	sync_cfg.soc_sync_addr
+		= VRX318_OB_BADDR + priv->ptm_bnd_cfg.soc_peer_phybase
+		+ BOND_SOC_SYNC_US_BUF_SIZE;
+
+	sync_cfg.cdma_rx_des_dw1 = SB_BUFFER(__BOND_DS_DES_SYNC_BUF_BASE);
+
+	dword_mem_write(SB_BUFFER(__BOND_DS_DES_SYNC_CFG_CTXT),
+		&sync_cfg, sizeof(sync_cfg), base);
+
+	vrx318_w32_sb(VRX318_OB_BADDR + priv->ptm_bnd_cfg.soc_peer_phybase + BOND_SOC_SYNC_US_BUF_SIZE,
+		__DS_BOND_SOC_SYNC_ADDR, base);
+	vrx318_w32_sb(VRX318_OB_BADDR + priv->ptm_bnd_cfg.soc_peer_phybase + BOND_SOC_SYNC_US_BUF_SIZE,
+		__DS_BOND_SOC_SYNC_ENQ_CNT_ADDR, base);
+	vrx318_w32_sb(VRX318_OB_BADDR + priv->ptm_bnd_cfg.soc_peer_phybase + BOND_SOC_SYNC_US_BUF_SIZE + 4,
+		__DS_BOND_SOC_SYNC_DEQ_CNT_ADDR, base);
+
+	/* Initialize fragq(GIF0-GIF7) des_cfg_ctxt and descriptor list */
+	vrx318_us_fragq_desq_cfg_ctxt_init(priv, base, is_bonding, ep_id);
+
+	return;
+}
+
+static void vrx318_us_qos_desq_cfg_ctxt_init(struct vrx318_ptm_tc *priv,
+			u32 base, int is_bonding, u32 ep_id)
+{
+	qosq_cfg_ctxt_t qosq_cfg_ctxt;
+	int offset, i;
+	rx_descriptor_t rx_desc;
+	dma_addr_t phy_addr;
+
+	if ((is_bonding == 1) && (ep_id == DS_BONDING_MASTER))
+		return;
+
+	/* Setup QoSQ_CFG_CTXT */
+	dword_clear(&qosq_cfg_ctxt, sizeof(qosq_cfg_ctxt));
+
+	qosq_cfg_ctxt.threshold = 8;
+	qosq_cfg_ctxt.des_num	= TOTAL_QOS_DES_NUM / QOSQ_NUM;
+
+	offset = 0;
+	for (i = 0; i < QOSQ_NUM; i++) {
+		qosq_cfg_ctxt.des_base_addr = __US_QOSQ_DES_LIST_BASE + offset;
+		dword_mem_write(SB_BUFFER((__QOSQ_CFG_CTXT_BASE + (i * __QOSQ_CFG_CTXT_SIZE))),
+			&qosq_cfg_ctxt, sizeof(qosq_cfg_ctxt), base);
+		offset += qosq_cfg_ctxt.des_num * sizeof(qosq_cfg_ctxt) / sizeof(unsigned int);
+	}
+
+	dword_clear(&rx_desc, sizeof(rx_desc));
+	rx_desc.own = __QOS_DISPATCH_OWN;
+	rx_desc.data_len = DMA_PACKET_SIZE;
+
+	/* Initialize QoSQ Descriptors */
+	for (i = 0; i < TOTAL_QOS_DES_NUM; i++) {
+		if (alloc_data_buffer(priv->frwk, rx_desc.data_len,
+			&phy_addr, NULL)) {
+			vrx318_dbg(DBG_INIT, "%s/%d: Alloc buffer failed\n",
+				__func__, __LINE__);
+			BUG();
+			return;
+		}
+		rx_desc.data_ptr = phy_addr + VRX318_OB_BADDR;
+		dword_mem_write(SB_BUFFER(__US_QOSQ_DES_LIST_BASE + (i * 2)),
+			&rx_desc, sizeof(rx_desc), base);
+	}
+}
+
+static void vrx318_us_outq_desq_cfg_ctxt_init(struct vrx318_ptm_tc *priv,
+			u32 base, int is_bonding, u32 ep_id)
+{
+	outq_qos_cfg_ctxt_t outq_qos_cfg_ctxt;
+	desq_cfg_ctxt_t desq_cfg;
+	u32 dst_addr;
+	rx_descriptor_t rx_desc;
+	dma_addr_t phy_addr;
+	int i;
+
+	/* Setup OUTQ_QoS_CFG_CTXT */
+	/* NOTE: By default, Shaping & WFQ both are DISABLED!! */
+	dword_clear(&outq_qos_cfg_ctxt, sizeof(outq_qos_cfg_ctxt));
+	outq_qos_cfg_ctxt.overhd_bytes  = is_bonding ? 20 : 24;
+
+	/* Output Queue 0  --reserve for pre-emption queue */
+	outq_qos_cfg_ctxt.qmap                  = priv->frwk->param.q_gamma_map[3];
+	outq_qos_cfg_ctxt.l2_shaping_cfg_ptr    = 0;
+	outq_qos_cfg_ctxt.l2_shaping_cfg_idx    = QOSQ_PORT_SSID;
+	outq_qos_cfg_ctxt.l3_shaping_cfg_ptr    = 0;
+	outq_qos_cfg_ctxt.l3_shaping_cfg_idx    = QOSQ_L3_SHAPER_ID;
+	outq_qos_cfg_ctxt.desq_cfg_ctxt		= __US_QOS_OUTQ_DES_CFG_CTXT_BASE
+			+ sizeof(desq_cfg_ctxt_t)/sizeof(unsigned int);
+	dst_addr = __OUTQ_QOS_CFG_CTXT_BASE;
+	dword_mem_write(SB_BUFFER(dst_addr), &outq_qos_cfg_ctxt,
+		sizeof(outq_qos_cfg_ctxt), base);
+
+	/* Output Queue 1  */
+	outq_qos_cfg_ctxt.qmap                  = priv->frwk->param.q_gamma_map[2];
+	outq_qos_cfg_ctxt.l2_shaping_cfg_ptr    = 0;
+	outq_qos_cfg_ctxt.l2_shaping_cfg_idx    = QOSQ_PORT_SSID + 1;
+	outq_qos_cfg_ctxt.l3_shaping_cfg_ptr    = 0;
+	outq_qos_cfg_ctxt.l3_shaping_cfg_idx    = QOSQ_L3_SHAPER_ID;
+	outq_qos_cfg_ctxt.desq_cfg_ctxt         = __US_QOS_OUTQ_DES_CFG_CTXT_BASE;
+	dst_addr                                += sizeof(outq_qos_cfg_ctxt_t)/sizeof(unsigned int);
+	dword_mem_write(SB_BUFFER(dst_addr), &outq_qos_cfg_ctxt,
+		sizeof(outq_qos_cfg_ctxt), base);
+
+	/* Output Queue 2 -->Point to Q1 desc queue */
+	outq_qos_cfg_ctxt.qmap                  = priv->frwk->param.q_gamma_map[1];
+	outq_qos_cfg_ctxt.l2_shaping_cfg_ptr    = 0;
+	outq_qos_cfg_ctxt.l2_shaping_cfg_idx    = QOSQ_PORT_SSID + 2;
+	outq_qos_cfg_ctxt.l3_shaping_cfg_ptr    = 0;
+	outq_qos_cfg_ctxt.l3_shaping_cfg_idx    = QOSQ_L3_SHAPER_ID;
+	dst_addr                                += sizeof(outq_qos_cfg_ctxt_t)/sizeof(unsigned int);
+	dword_mem_write(SB_BUFFER(dst_addr), &outq_qos_cfg_ctxt,
+		sizeof(outq_qos_cfg_ctxt), base);
+
+	/* Output Queue 3 --> Point to Q1 desc queue */
+	outq_qos_cfg_ctxt.qmap                  = priv->frwk->param.q_gamma_map[0];
+	outq_qos_cfg_ctxt.l2_shaping_cfg_ptr    = 0;
+	outq_qos_cfg_ctxt.l2_shaping_cfg_idx    = QOSQ_PORT_SSID + 3;
+	outq_qos_cfg_ctxt.l3_shaping_cfg_ptr    = 0;
+	outq_qos_cfg_ctxt.l3_shaping_cfg_idx    = QOSQ_L3_SHAPER_ID;
+	dst_addr                                += sizeof(outq_qos_cfg_ctxt_t)/sizeof(unsigned int);
+	dword_mem_write(SB_BUFFER(dst_addr), (&outq_qos_cfg_ctxt),
+		sizeof(outq_qos_cfg_ctxt), base);
+
+	/* Setup DESQ_CFG_CTXT for Output Queues */
+	dword_clear(&desq_cfg, sizeof(desq_cfg));
+
+	desq_cfg.des_in_own_val	= US_OUTQ_DES_OWN;
+	desq_cfg.mbox_int_en	= 0;
+	desq_cfg.des_sync_needed = 0;
+	/**
+	* set to 32 in order to improve performance for 129-byte frame size;
+	* Please note, the BC1's memory space is overwritten by BC0, and BC1
+	* use illegal memory space.
+	*/
+	desq_cfg.des_num = 32;
+	desq_cfg.des_base_addr = __US_OUTQ_DES_LIST_BASE;
+	dst_addr = __US_QOS_OUTQ_DES_CFG_CTXT_BASE;
+	dword_mem_write(SB_BUFFER(dst_addr), &desq_cfg, sizeof(desq_cfg), base);
+
+	desq_cfg.des_base_addr += desq_cfg.des_num * 2;
+	dst_addr += sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int);
+	dword_mem_write(SB_BUFFER(dst_addr), &desq_cfg, sizeof(desq_cfg), base);
+
+	desq_cfg.des_base_addr += desq_cfg.des_num * 2;
+	dst_addr += sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int);
+	dword_mem_write(SB_BUFFER(dst_addr), &desq_cfg, sizeof(desq_cfg), base);
+
+	desq_cfg.des_base_addr += desq_cfg.des_num * 2;
+	dst_addr += sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int);
+	dword_mem_write(SB_BUFFER(dst_addr), &desq_cfg, sizeof(desq_cfg), base);
+
+	/* Initialize the outq descriptor list */
+	dword_clear(&rx_desc, sizeof(rx_desc));
+	rx_desc.own = !desq_cfg.des_in_own_val;
+	rx_desc.data_len = DMA_PACKET_SIZE;
+
+	/* Initialize QoSQ Descriptors */
+	for (i = 0; i < OUTQ_NUM; i++) {
+		if (alloc_data_buffer(priv->frwk, rx_desc.data_len,
+			&phy_addr, NULL)) {
+			vrx318_dbg(DBG_INIT, "%s/%d: Alloc buffer failed\n",
+				__func__, __LINE__);
+			BUG();
+			return;
+		}
+		rx_desc.data_ptr = phy_addr + VRX318_OB_BADDR;
+		dword_mem_write(SB_BUFFER(__US_OUTQ_DES_LIST_BASE + (i * 2)),
+			&rx_desc, sizeof(rx_desc), base);
+	}
+
+	return;
+}
+/*
+* Initialize QoS related configuration for VRX318
+* Initializes the below PPE FW Data Structures
+* 1. INQ_QoS_CFG
+* 2. QoSQ_CFG_CTXT
+* 3. OUTQ_QoS_CFG_CTXT
+* 4. SHAPING_WFQ_CFG
+* 5. QOSQ_MIB
+* 6. QOSQ_FLOW_CTRL_CFG
+* 7. STD_DES_CFG
+* Single line applicaiton : MUST be called
+* Bonding application     : MUST be called for US_BONDING_MASTER
+*		MUST NOT be called for DS_BONDING_MASTER
+*/
+void vrx318_us_qos_cfg_init(struct vrx318_ptm_tc *priv,
+			u32 base, int is_bonding, u32 ep_id)
+{
+	inq_qos_cfg_t fp_qos_cfg, cpu_qos_cfg;
+
+	if ((is_bonding == 1) && (ep_id == DS_BONDING_MASTER))
+		return;
+
+	/* Setup INQ_QoS_CFG for Fast-Path & CPU-Path */
+	dword_clear(&fp_qos_cfg, sizeof(fp_qos_cfg));
+	dword_clear(&cpu_qos_cfg, sizeof(cpu_qos_cfg));
+
+	/* By default, support 8 queues only */
+	if (priv->frwk->soc_cfg.soc_fp_us_dnum) {
+		fp_qos_cfg.qos_en         = 1;
+		fp_qos_cfg.qid_mask       = QOSQ_ID_MASK;
+		fp_qos_cfg.qosq_base_qid  = 0;
+		fp_qos_cfg.desq_cfg_ctxt  = __US_FP_INQ_DES_CFG_CTXT;
+		dword_mem_write(INQ_QOS_CFG_BASE(0), &fp_qos_cfg,
+				sizeof(fp_qos_cfg), base);
+	}
+
+	if (priv->frwk->soc_cfg.soc_cpu_us_dnum) {
+		cpu_qos_cfg.qos_en        = 1;
+		cpu_qos_cfg.qid_mask      = QOSQ_ID_MASK;
+		cpu_qos_cfg.qosq_base_qid = 0;
+		cpu_qos_cfg.desq_cfg_ctxt = __US_CPU_INQ_DES_CFG_CTXT;
+		dword_mem_write(INQ_QOS_CFG_BASE(1), &cpu_qos_cfg,
+				 sizeof(cpu_qos_cfg), base);
+	}
+
+	vrx318_us_qos_desq_cfg_ctxt_init(priv, base, is_bonding, ep_id);
+
+	vrx318_us_outq_desq_cfg_ctxt_init(priv, base, is_bonding, ep_id);
+
+	return;
+}
+
+static void vrx318_us_bg_ctxt_init(u32 base, int is_bonding, int ep_id)
+{
+	int i;
+	us_bg_ctxt_t us_bg_ctxt;
+	u32 dst_addr;
+
+	if (!is_bonding || ep_id == DS_BONDING_MASTER)
+		return;
+
+	dword_clear(&us_bg_ctxt, sizeof(us_bg_ctxt));
+	for (i = 0; i < 4; i++) {
+		us_bg_ctxt.desq_cfg_ctxt_ptr = __US_QOS_OUTQ_DES_CFG_CTXT_BASE
+			+ (i * (sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int)));
+		dst_addr = SB_BUFFER(__US_BG_CTXT_BASE + (i * (sizeof(us_bg_ctxt_t) / sizeof(unsigned int))));
+		dword_mem_write(dst_addr, &us_bg_ctxt, sizeof(us_bg_ctxt_t), base);
+	}
+
+	return;
+}
+
+static void vrx318_ds_bg_ctxt_init(u32 base, int is_bonding, int ep_id)
+{
+	int i;
+	u32 dst_addr;
+	ds_bg_ctxt_t ds_bg_ctxt;
+
+	if (!is_bonding || ep_id == US_BONDING_MASTER)
+		return;
+
+	dword_clear(&ds_bg_ctxt, sizeof(ds_bg_ctxt_t));
+	ds_bg_ctxt.last_eop = 1;
+
+	dst_addr = __DS_BG_CTXT_BASE;
+	for (i = 0; i < 4; i++) {
+		dword_mem_write(SB_BUFFER(dst_addr), &ds_bg_ctxt, sizeof(ds_bg_ctxt_t), base);
+		dst_addr = dst_addr + sizeof(ds_bg_ctxt_t)/sizeof(unsigned int);
+	}
+
+	return;
+}
+
+/**
+ * Total 256 free descriptor, 9(1 free frag link list, 8 (2(BC) * 4(GIF)) frag link list
+ * 256 free desciptor in free frag link list on initialization.
+ */
+void vrx318_ds_ll_ctxt_init(struct vrx318_priv *priv,
+			u32 base, int is_bonding, int ep_id)
+{
+	int i;
+	u32 dst_addr;
+	ds_bond_gif_ll_ctxt_t ds_bond_gif_ll_ctxt;
+	ds_bond_gif_ll_des_t ll_desc;
+	dma_addr_t phy_addr;
+
+	if (!is_bonding || ep_id == US_BONDING_MASTER)
+		return;
+
+	dword_clear(&ds_bond_gif_ll_ctxt, sizeof(ds_bond_gif_ll_ctxt_t));
+
+	ds_bond_gif_ll_ctxt.max_des_num	= 128;
+	ds_bond_gif_ll_ctxt.to_buff_thres = 16; /* when free_des_num <= 16, timeout any frag */
+	ds_bond_gif_ll_ctxt.max_delay	= 1000; /*  TODO: fix the number */
+
+	dst_addr = __DS_BOND_LL_CTXT_BASE;
+	for (i = 0; i < 9; i++) {
+		dword_mem_write(SB_BUFFER(dst_addr), &ds_bond_gif_ll_ctxt, sizeof(ds_bond_gif_ll_ctxt_t), base);
+		dst_addr += sizeof(ds_bond_gif_ll_ctxt_t)/sizeof(unsigned int);
+	}
+
+	ds_bond_gif_ll_ctxt.head_ptr = __DS_BOND_GIF_LL_DES_BA;
+	ds_bond_gif_ll_ctxt.tail_ptr = __DS_BOND_GIF_LL_DES_BA + (255 * 2);
+	ds_bond_gif_ll_ctxt.des_num = 256;
+	dword_mem_write(SB_BUFFER(__DS_BOND_LL_CTXT_BASE),
+		&ds_bond_gif_ll_ctxt,
+		sizeof(ds_bond_gif_ll_ctxt), base);
+
+	/* Initialize DS GIF LL Descriptors */
+	for (i = 0; i < DS_BOND_GIF_LL_DES_LEN; i++) {/* link list, last one pointer back to the first one */
+		ll_desc.next_des_ptr = __DS_BOND_GIF_LL_DES_BA + (((i + 1) & 0xFF) << 1);
+		ll_desc.data_len = DMA_PACKET_SIZE;
+		if (alloc_data_buffer(priv, ll_desc.data_len,
+			&phy_addr, NULL)) {
+			vrx318_dbg(DBG_ERR, "%s/%d: Alloc buffer failed\n",
+				__func__, __LINE__);
+			BUG();
+			return;
+		}
+		ll_desc.data_ptr = VRX318_OB_BADDR + phy_addr;
+		dword_mem_write(DS_BOND_GIF_LL_DES_BA(i), &ll_desc,
+			sizeof(ll_desc), base);
+	}
+
+	return;
+}
+
+void vrx318_edma_copy_ch_init(u32 base, int is_bonding, u32 ep_id, int cdma_write_data_en)
+{
+	edma_copy_ch_cfg_t copy_ch_cfg;
+	desq_cfg_ctxt_t local_desq_cfg_ctxt;
+	int i, offset;
+	unsigned int des_cnt;
+	unsigned int us_des_alloc[] = {15, 3, 0, 0};
+	u32 dst_addr;
+
+	if (is_bonding == 0) {/* TODO: edma copy channel must be continues setting ? */
+		/* Setup 4 UpStream eDMA Copy Channel 1 for each GIF */
+		for (i = 0; i < 4; i++) {
+			if (!us_des_alloc[i])
+				continue;
+			offset = i * sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int);
+			copy_ch_cfg.srcq_ctxt_ptr
+				= __US_QOS_OUTQ_DES_CFG_CTXT_BASE + offset;
+			copy_ch_cfg.dstq_ctxt_ptr
+				= __US_TC_LOCAL_Q_CFG_CTXT_BASE + offset;
+			dst_addr = SB_BUFFER(__US_EDMA_COPY_CH_CFG + i * sizeof(edma_copy_ch_cfg_t) / sizeof(unsigned int));
+			dword_mem_write(dst_addr, &copy_ch_cfg, sizeof(copy_ch_cfg), base);
+		}
+
+		/* Setup the Local DESQ Configuration/Context for 4 UpStream Queues */
+		dword_clear(&local_desq_cfg_ctxt, sizeof(local_desq_cfg_ctxt));
+		local_desq_cfg_ctxt.des_in_own_val = US_LOCALQ_DES_OWN;
+		des_cnt = 0;
+		for (i = 0; i < 4; i++) {
+			local_desq_cfg_ctxt.des_num = us_des_alloc[i];
+			local_desq_cfg_ctxt.des_base_addr = __US_TC_LOCAL_Q_DES_LIST_BASE + (des_cnt * 2);
+			dst_addr = SB_BUFFER(__US_TC_LOCAL_Q_CFG_CTXT_BASE + (i * (sizeof(desq_cfg_ctxt_t)/sizeof(unsigned int))));
+			dword_mem_write(dst_addr, &local_desq_cfg_ctxt, sizeof(desq_cfg_ctxt_t), base);
+			des_cnt += us_des_alloc[i];
+		}
+
+		if (cdma_write_data_en == 0) {
+			/* Setup 1 DownStream eDMA Copy Channel */
+			copy_ch_cfg.srcq_ctxt_ptr = __DS_TC_LOCAL_Q_CFG_CTXT;
+			copy_ch_cfg.dstq_ctxt_ptr = __DS_PKT_DESQ_CFG_CTXT;
+			dword_mem_write(SB_BUFFER(__DS_EDMA_COPY_CH_CFG), &copy_ch_cfg,
+					sizeof(copy_ch_cfg), base);
+		}
+
+		/* Setup the Local DESQ Configuration/Context for DownStream Queues */
+		dword_clear(&local_desq_cfg_ctxt, sizeof(local_desq_cfg_ctxt));
+		local_desq_cfg_ctxt.des_in_own_val = cdma_write_data_en ? 1 : 0;
+		local_desq_cfg_ctxt.des_num = __DS_TC_LOCAL_Q_DES_LIST_NUM;
+		local_desq_cfg_ctxt.des_base_addr = __DS_TC_LOCAL_Q_DES_LIST_BASE;
+		dword_mem_write(SB_BUFFER(__DS_TC_LOCAL_Q_CFG_CTXT),
+			&local_desq_cfg_ctxt, sizeof(local_desq_cfg_ctxt), base);
+	} else if ((is_bonding == 1) && (ep_id == US_BONDING_MASTER)) {
+		/* Setup 4 UpStream eDMA Copy Channel 1 for each GIF */
+		for (i = 0; i < 4; i++) {
+			if (!us_des_alloc[i])
+				continue;
+			offset = i * sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int);
+			copy_ch_cfg.srcq_ctxt_ptr
+				= __US_FRAGQ_CFG_CTXT_BASE + offset;
+			copy_ch_cfg.dstq_ctxt_ptr
+				= __US_TC_LOCAL_Q_CFG_CTXT_BASE + offset;
+			dst_addr = SB_BUFFER(__US_EDMA_COPY_CH_CFG + i * sizeof(edma_copy_ch_cfg_t) / sizeof(unsigned int));
+			dword_mem_write(dst_addr, &copy_ch_cfg, sizeof(copy_ch_cfg), base);
+		}
+
+		/*Setup the Local DESQ Configuration/Context for 4 UpStream Queues*/
+		dword_clear(&local_desq_cfg_ctxt, sizeof(local_desq_cfg_ctxt));
+		local_desq_cfg_ctxt.des_in_own_val = 1;
+		des_cnt = 0;
+		for (i = 0; i < 4; i++) {
+			local_desq_cfg_ctxt.des_num = us_des_alloc[i];
+			local_desq_cfg_ctxt.des_base_addr = __US_TC_LOCAL_Q_DES_LIST_BASE + (des_cnt * 2);
+			local_desq_cfg_ctxt.bp_des_base_addr = __US_BP_TC_LOCAL_Q_CFG_CTXT_BASE + (des_cnt * 1);
+			dst_addr = SB_BUFFER(__US_TC_LOCAL_Q_CFG_CTXT_BASE + (i * (sizeof(desq_cfg_ctxt_t)/sizeof(unsigned int))));
+			dword_mem_write(dst_addr, (&local_desq_cfg_ctxt), sizeof(desq_cfg_ctxt_t), base);
+			des_cnt = des_cnt + us_des_alloc[i];
+		}
+
+		/*Setup 1 DownStream eDMA Copy Channel*/
+		copy_ch_cfg.srcq_ctxt_ptr = __DS_TC_LOCAL_Q_CFG_CTXT;
+		copy_ch_cfg.dstq_ctxt_ptr = __DS_FRAGQ_CFG_CTXT_BASE;
+		dword_mem_write(SB_BUFFER(__DS_EDMA_COPY_CH_CFG), &copy_ch_cfg, sizeof(copy_ch_cfg), base);
+
+		/*Setup the Local DESQ Configuration/Context for DownStream Queues*/
+		dword_clear(&local_desq_cfg_ctxt, sizeof(local_desq_cfg_ctxt));
+		local_desq_cfg_ctxt.des_in_own_val = cdma_write_data_en ? 1 : 0;
+		local_desq_cfg_ctxt.des_num = __DS_TC_LOCAL_Q_DES_LIST_NUM;
+		local_desq_cfg_ctxt.des_base_addr = __DS_TC_LOCAL_Q_DES_LIST_BASE;
+		local_desq_cfg_ctxt.bp_des_base_addr = __DS_TC_LOCAL_Q_DES_LIST_BASE + (16 * 2);
+		dst_addr = SB_BUFFER(__DS_TC_LOCAL_Q_CFG_CTXT);
+		dword_mem_write(dst_addr, &local_desq_cfg_ctxt, sizeof(desq_cfg_ctxt_t), base);
+
+	} else if ((is_bonding == 1) && (ep_id == DS_BONDING_MASTER)) {
+
+		/* Setup 4 UpStream eDMA Copy Channel 1 for each GIF */
+		/*DS Master copy channel fraq start from 4 to 7 */
+		for (i = 0; i < 4; i++) {
+			if (!us_des_alloc[i])
+				continue;
+			copy_ch_cfg.srcq_ctxt_ptr = __US_FRAGQ_CFG_CTXT_BASE
+				+ (i + 4) * sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int);
+			copy_ch_cfg.dstq_ctxt_ptr = __US_TC_LOCAL_Q_CFG_CTXT_BASE
+				+ i * sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int);
+			dst_addr = SB_BUFFER(__US_EDMA_COPY_CH_CFG + i * sizeof(edma_copy_ch_cfg_t) / sizeof(unsigned int));
+			dword_mem_write(dst_addr, &copy_ch_cfg, sizeof(copy_ch_cfg), base);
+		}
+
+		/* Setup the Local DESQ Configuration/Context for 4 UpStream Queues */
+		dword_clear(&local_desq_cfg_ctxt, sizeof(local_desq_cfg_ctxt));
+		local_desq_cfg_ctxt.des_in_own_val = 1;
+		des_cnt = 0;
+		for (i = 0; i < 4; i++) {
+			local_desq_cfg_ctxt.des_num = us_des_alloc[i];
+			local_desq_cfg_ctxt.des_base_addr = __US_TC_LOCAL_Q_DES_LIST_BASE + (des_cnt * 2);
+			local_desq_cfg_ctxt.bp_des_base_addr = __US_BP_TC_LOCAL_Q_CFG_CTXT_BASE + (des_cnt * 1);
+			dst_addr = SB_BUFFER(__US_TC_LOCAL_Q_CFG_CTXT_BASE + (i * (sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int))));
+			dword_mem_write(dst_addr, (unsigned int *)(&local_desq_cfg_ctxt), sizeof(desq_cfg_ctxt_t), base);
+			des_cnt = des_cnt + us_des_alloc[i];
+		}
+
+		if (cdma_write_data_en == 0) {
+			/* Setup 1 DownStream eDMA Copy Channel */
+			/* DownStream Master use eDMA copy channel to copy data from local to ds_frag_des_list2 */
+			copy_ch_cfg.srcq_ctxt_ptr = __DS_TC_LOCAL_Q_CFG_CTXT;
+			/* offset 0 is reserved for US master's downstream data */
+			copy_ch_cfg.dstq_ctxt_ptr = __DS_FRAGQ_CFG_CTXT_BASE + sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int);
+			dst_addr = SB_BUFFER(__DS_EDMA_COPY_CH_CFG);
+			dword_mem_write(dst_addr, &copy_ch_cfg, sizeof(copy_ch_cfg), base);
+		}
+
+		/* Setup the Local DESQ Configuration/Context for DownStream Queues */
+		dword_clear(&local_desq_cfg_ctxt, sizeof(local_desq_cfg_ctxt));
+		local_desq_cfg_ctxt.des_in_own_val = cdma_write_data_en ? 1 : 0;
+		local_desq_cfg_ctxt.des_num = __DS_TC_LOCAL_Q_DES_LIST_NUM;
+		local_desq_cfg_ctxt.des_base_addr = __DS_TC_LOCAL_Q_DES_LIST_BASE;
+		local_desq_cfg_ctxt.bp_des_base_addr = __DS_TC_LOCAL_Q_DES_LIST_BASE + (16 * 2);
+		dst_addr = SB_BUFFER(__DS_TC_LOCAL_Q_CFG_CTXT);
+		dword_mem_write(dst_addr, &local_desq_cfg_ctxt, sizeof(desq_cfg_ctxt_t), base);
+	}
+
+	return;
+}
+
+/**
+ * Initialize VRX318 TC Local Descriptor List
+ * Performs below actions
+ *      (1) Allocate and Initialize TC UpStream Local Descriptors
+ *      (2) Allocate and Initialize TC DownStream Local Descriptors
+ *      Before PPA2.16: US: EDMA read, DS: EDMA write
+ *      PPA2.16: US: EDMA read, DS: CDMA write
+ */
+void vrx318_local_des_init(u32 base, int cdma_write_data_en)
+{
+	int i;
+	u32 dst_addr, ds_local_addr;
+	rx_descriptor_t rx_desc;
+
+	dword_clear(&rx_desc, sizeof(rx_desc));
+	rx_desc.own = !US_LOCALQ_DES_OWN;
+	rx_desc.data_len = DMA_PACKET_SIZE;
+
+	/* Initialize UpStream Descriptors */
+	for (i = 0; i < __US_TC_LOCAL_Q_DES_LIST_NUM; i++) {
+		rx_desc.data_ptr = (PDBRAM_TX_PKT_BUF_BASE + (i * DMA_PACKET_SIZE));
+		dst_addr = SB_BUFFER(__US_TC_LOCAL_Q_DES_LIST_BASE + (i * 2));
+		dword_mem_write(dst_addr, &rx_desc, sizeof(rx_desc), base);
+	}
+
+	dword_clear(&rx_desc, sizeof(rx_desc));
+	/* CDMA: own: 0--->CPU, 1--->DMA */
+	rx_desc.own = !cdma_write_data_en;
+	rx_desc.data_len = DMA_PACKET_SIZE;
+
+	/* Initialize DownStream Descriptors */
+	ds_local_addr = PDBRAM_TX_PKT_BUF_BASE + __US_TC_LOCAL_Q_DES_LIST_NUM * DMA_PACKET_SIZE;
+	for (i = 0; i < __DS_TC_LOCAL_Q_DES_LIST_NUM; i++) {
+		rx_desc.data_ptr = (ds_local_addr + (i * DMA_PACKET_SIZE));
+		dst_addr = SB_BUFFER(__DS_TC_LOCAL_Q_DES_LIST_BASE + (i * 2));
+		dword_mem_write(dst_addr, &rx_desc, sizeof(rx_desc), base);
+	}
+
+	return;
+}
+
+void vrx318_ds_fragq_desq_cfg_ctxt_init(struct vrx318_ptm_tc *priv,
+					u32 base, int is_bonding, u32 ep_id)
+{
+	int i;
+	u32 dst_addr;
+	unsigned int end_fragq_id = 1;
+	desq_cfg_ctxt_t desq_cfg;
+	rx_descriptor_t rx_desc, *p_rx_desc;
+	dma_addr_t phy_addr;
+
+	if (!is_bonding)
+		return;
+
+	dword_clear(&desq_cfg, sizeof(desq_cfg));
+
+	if (ep_id == DS_BONDING_MASTER)
+		end_fragq_id = 2;
+	else if (ep_id == US_BONDING_MASTER)
+		end_fragq_id = 1;
+
+	for (i = 0; i < end_fragq_id; i++) {
+		/* Initialize Downstream Descriptor Queue Config/Context */
+		desq_cfg.des_in_own_val  = DS_FRAGQ_DES_OWN;
+		desq_cfg.fast_path       = 0;
+		desq_cfg.mbox_int_en     = 0;
+		desq_cfg.des_sync_needed = 0;
+		desq_cfg.gif_id          = (i == 1) ? 4 : 0;
+		desq_cfg.des_num         = (i == 0) ?
+			DS_FRAG_DES_LIST1_LEN : DS_FRAG_DES_LIST2_LEN;
+		desq_cfg.des_base_addr   = __DS_FRAGQ_DES_LIST_BASE
+				+ (i * 3 * desq_cfg.des_num);
+		desq_cfg.bp_des_base_addr = __DS_FRAGQ_DES_LIST_BASE
+				+ (i * 3 * desq_cfg.des_num) + (2 * desq_cfg.des_num);
+
+		dst_addr = SB_BUFFER(__DS_FRAGQ_CFG_CTXT_BASE + (i * (sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int))));
+		dword_mem_write(dst_addr, &desq_cfg, sizeof(desq_cfg), base);
+	}
+	/* Initialize OWN bit of all the Descriptors in FragmentQ Descriptor List */
+	dword_clear(&rx_desc, sizeof(rx_desc));
+	rx_desc.own = !desq_cfg.des_in_own_val;
+	rx_desc.data_len = DMA_PACKET_SIZE;
+
+	if (ep_id == US_BONDING_MASTER) {
+		dword_mem_read(&desq_cfg, SB_BUFFER(__DS_FRAGQ_CFG_CTXT_BASE),
+				sizeof(desq_cfg), base);
+	} else if (ep_id == DS_BONDING_MASTER) {
+		dword_mem_read(&desq_cfg,
+				SB_BUFFER(__DS_FRAGQ_CFG_CTXT_BASE + sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int)),
+				sizeof(desq_cfg), base);
+	}
+
+	for (i = 0; i < desq_cfg.des_num; i++) {
+		dst_addr = desq_cfg.des_base_addr
+			+ i * sizeof(rx_desc) / sizeof(unsigned int);
+		if (alloc_data_buffer(priv->frwk, DMA_PACKET_SIZE,
+				&phy_addr, (unsigned int *)NULL)) {
+			vrx318_dbg(DBG_ERR,
+				"Failed to alloc buffer for ds fraq des\n");
+			BUG();
+			return;
+		}
+		rx_desc.data_ptr
+			= (unsigned int)phy_addr + VRX318_OB_BADDR;
+		dword_mem_write(SB_BUFFER(dst_addr), &rx_desc,
+				sizeof(rx_desc), base);
+	}
+
+	if (ep_id == US_BONDING_MASTER) {
+		/* Initialize the Downstream Shadow Descriptors in SoC */
+		for (i = 0; i < desq_cfg.des_num; i++) {
+			if (i % 4 == 0) {
+				p_rx_desc = (rx_descriptor_t *)(priv->ptm_bnd_cfg.soc_peer_membase + BOND_SOC_SYNC_US_BUF_SIZE + ((i/4) * 64) + 8);
+				p_rx_desc->own = !desq_cfg.des_in_own_val;
+			}
+		}
+		phy_addr = dma_map_single(priv->frwk->pdev,
+			(void *)priv->ptm_bnd_cfg.soc_peer_membase,
+			PAGE_SIZE, DMA_TO_DEVICE);
+		if (unlikely(dma_mapping_error(priv->frwk->pdev, phy_addr)))
+			BUG();
+		dma_unmap_single(priv->frwk->pdev, phy_addr, PAGE_SIZE, DMA_TO_DEVICE);
+	}
+
+	return;
+}
+
+void vrx318_cdma_copy_ch_init(u32 base, int is_bonding, u32 ep_id, int cdma_write_data_en)
+{
+	cdma_copy_ch_cfg_t cdma_ch_cfg;
+	u32 dst_addr;
+
+	if (!cdma_write_data_en)
+		return;
+
+	dst_addr = SB_BUFFER(__DS_CDMA_COPY_CH_CFG);
+	if (is_bonding == 0) {
+		cdma_ch_cfg.srcq_ctxt_ptr = __DS_TC_LOCAL_Q_CFG_CTXT;
+		cdma_ch_cfg.dstq_ctxt_ptr = __DS_PKT_DESQ_CFG_CTXT;
+
+	} else if (is_bonding == 1 && ep_id == US_BONDING_MASTER) {
+		cdma_ch_cfg.srcq_ctxt_ptr = __DS_TC_LOCAL_Q_CFG_CTXT;
+		cdma_ch_cfg.dstq_ctxt_ptr = __DS_FRAGQ_CFG_CTXT_BASE;
+
+	} else if (is_bonding == 1 && ep_id == DS_BONDING_MASTER) {
+		cdma_ch_cfg.srcq_ctxt_ptr = __DS_TC_LOCAL_Q_CFG_CTXT;
+		cdma_ch_cfg.dstq_ctxt_ptr = __DS_FRAGQ_CFG_CTXT_BASE + 8;
+	}
+
+	dword_mem_write(dst_addr, &cdma_ch_cfg, sizeof(cdma_ch_cfg), base);
+
+	return;
+}
+
+static inline void vrx318_enable_cdma(int cid, u32 base, int en)
+{
+	u32 reg_val;
+	vrx318_w32(cid, DMA_CS, base);
+
+	if (en)
+		reg_val = vrx318_r32(DMA_CCTRL, base) | 0x00000001;
+	else
+		reg_val = vrx318_r32(DMA_CCTRL, base) & (~0x00000001);
+
+	vrx318_w32(reg_val, DMA_CCTRL, base);
+}
+
+/* Only 1 descriptor is initialized per copy channel */
+static inline void vrx318_cfg_cdma_cpch(int rx_cid, int tx_cid,
+					u32 rx_dbase, u32 tx_dbase,
+					u32 rx_dnum, u32 tx_dnum, u32 base)
+{
+	/* Setup RX DMA Channel */
+	vrx318_w32(rx_cid, DMA_CS, base);
+	vrx318_w32(rx_dbase, DMA_CBA, base);
+	vrx318_w32(rx_dnum, DMA_CDLEN, base);
+
+	/* Setup TX DMA Channel */
+	vrx318_w32(tx_cid, DMA_CS, base);
+	vrx318_w32(tx_dbase, DMA_CBA, base);
+	vrx318_w32(tx_dnum, DMA_CDLEN, base);
+
+	vrx318_enable_cdma(rx_cid, base, 1);
+	vrx318_enable_cdma(tx_cid, base, 1);
+
+	return;
+}
+
+static inline void vrx318_setup_sync_cdma(int rx_cid, int tx_cid,
+						int off, u32 base)
+{
+	u32 rx_dbase, tx_dbase, rx_daddr;
+	/* Calculate all the offset for RX descriptor base address, RX data pointer, and Tx descriptor base address*/
+	const u32 rx_desc_off = offsetof(des_sync_cfg_ctxt_t, cdma_dst_des_dw0) / 4; /* offset 11 */
+	const u32 rx_data_off = offsetof(des_sync_cfg_ctxt_t, rd_des_buf[0]) / 4; /* offset 16 */
+	const u32 tx_desc_off = offsetof(des_sync_cfg_ctxt_t, rd_cmd_sar) / 4;  /* offset 6 */
+
+	off = off * sizeof(des_sync_cfg_ctxt_t) / sizeof(int);
+
+	rx_dbase = __DES_SYNC_CFG_CTXT + off + rx_desc_off;
+	rx_daddr = __DES_SYNC_CFG_CTXT + off + rx_data_off;
+	tx_dbase = __DES_SYNC_CFG_CTXT + off + tx_desc_off;
+
+	/* Setup RX descriptor */
+	vrx318_w32_sb(0xF0000040, rx_dbase, base);
+	vrx318_w32_sb(SB_BUFFER(rx_daddr), rx_dbase + 1, base);
+
+	/* Setup TX descriptor */
+	vrx318_w32_sb(0x0, tx_dbase, base);
+	vrx318_w32_sb(0x0, tx_dbase + 1, base);
+
+	vrx318_cfg_cdma_cpch(rx_cid, tx_cid, SB_BUFFER(rx_dbase), SB_BUFFER(tx_dbase), 1, 1, base);
+}
+
+void vrx318_cdma_init(struct vrx318_ptm_tc *priv,
+	u32 base, int is_bonding, u32 ep_id, int cdma_write_data_en)
+{
+	u32 reg_val;
+	int off;
+	u32 rx_dbase, tx_dbase;
+	u32 rx_des_off, tx_des_off;
+
+	/* Enable POWER to CDMA */
+	reg_val = vrx318_r32(PMU_PWDCR, base) & (~0x00000004);
+	vrx318_w32(reg_val, PMU_PWDCR, base);
+
+	vrx318_w32(0x80000040, DMA_CPOLL, base);
+	vrx318_w32(0x00000004, DMA_PS, base);
+	reg_val = (vrx318_r32(DMA_PCTRL, base) & ~(0x0000003C)) | (0x0000003C);
+	vrx318_w32(reg_val, DMA_PCTRL, base);
+
+	/* Setup DMA COPY Channel (RXCH 2 /TXCH 3) : 1 Descriptor */
+	off = 0;
+	vrx318_setup_sync_cdma(0, 1, off, base);
+	off++;
+
+	if ((is_bonding == 0) || (is_bonding == 1 && ep_id == US_BONDING_MASTER)) {
+		/* Setup DMA COPY Channel (RXCH 2 /TXCH 3) : 1 Descriptor */
+		vrx318_setup_sync_cdma(2, 3, off, base);
+		off++;
+	} else if (is_bonding == 1 && ep_id == DS_BONDING_MASTER) {
+		/* Setup DMA COPY Channel (RXCH 2 /TXCH 3) : 1 Descriptor */
+		/* Bonding Descriptor Sync, obesolete */
+		/* RXCH: __BOND_US_DES_SYNC_RX_DES_DW0 /__BOND_US_DES_SYNC_RX_DES_DW1 */
+		/* TXCH: __BOND_US_DES_SYNC_TX_DES_DW0/ __BOND_US_DES_SYNC_TX_DES_DW1 */
+		/* Disable cdma channel by default */
+		vrx318_w32_sb(0x0, __BOND_US_DES_SYNC_RX_DES_DW0, base);
+		vrx318_w32_sb(0x0, __BOND_US_DES_SYNC_RX_DES_DW1, base);
+		vrx318_w32_sb(0x0, __BOND_US_DES_SYNC_TX_DES_DW0, base);
+		vrx318_w32_sb(0x0, __BOND_US_DES_SYNC_TX_DES_DW1, base);
+		vrx318_cfg_cdma_cpch(2, 3,
+				SB_BUFFER(__BOND_US_DES_SYNC_RX_DES_DW0),
+				SB_BUFFER(__BOND_US_DES_SYNC_TX_DES_DW0),
+				1, 1, base);
+		vrx318_enable_cdma(3, base, 0);
+		vrx318_enable_cdma(2, base, 0);
+	}
+
+	if (is_bonding == 0) {
+		/* Setup DMA COPY Channel (RXCH 4 / TXCH 5): 1 Descriptor */
+		vrx318_setup_sync_cdma(4, 5, off, base);
+		off++;
+
+		if (cdma_write_data_en)
+			/*Setup DMA COPY Channel (RXCH 6/ TXCH 7): 1 Descriptor */
+			vrx318_cfg_cdma_cpch(6, 7,
+				SB_BUFFER(__DS_PKT_DES_LIST_BASE),
+				SB_BUFFER(__DS_TC_LOCAL_Q_DES_LIST_BASE),
+				priv->frwk->soc_cfg.soc_ds_dnum,
+				__DS_TC_LOCAL_Q_DES_LIST_NUM, base);
+	}
+
+	if (is_bonding == 1 && ep_id == US_BONDING_MASTER) {
+		/* Setup DMA Channel (RXCH 4 / TXCH 5) : 1 Descriptor */
+		/* RXCH __BOND_US_DES_SYNC_RX_DES_DW0 / __BOND_US_DES_SYNC_RX_DES_DW1 */
+		/* TXCH __BOND_US_DES_SYNC_TX_DES_DW0 / __BOND_US_DES_SYNC_TX_DES_DW1 */
+		/* obesolete, Disable cdma channel by default */
+		vrx318_w32_sb(0x0, __BOND_US_DES_SYNC_RX_DES_DW0, base);
+		vrx318_w32_sb(0x0, __BOND_US_DES_SYNC_RX_DES_DW1, base);
+		vrx318_w32_sb(0x0, __BOND_US_DES_SYNC_TX_DES_DW0, base);
+		vrx318_w32_sb(0x0, __BOND_US_DES_SYNC_TX_DES_DW1, base);
+		vrx318_cfg_cdma_cpch(4, 5,
+				SB_BUFFER(__BOND_US_DES_SYNC_RX_DES_DW0),
+				SB_BUFFER(__BOND_US_DES_SYNC_TX_DES_DW0),
+				1, 1, base);
+		vrx318_enable_cdma(5, base, 0);
+		vrx318_enable_cdma(4, base, 0);
+
+		if (cdma_write_data_en)
+			/* CDMA write ds_tc_local_q_des_list to ds_frag_des_list1(TX CH to RX CH) */
+			/* Setup DMA Channel (RXCH 6 / TXCH 7) */
+			vrx318_cfg_cdma_cpch(6, 7,
+				SB_BUFFER(__DS_FRAGQ_DES_LIST_BASE),
+				SB_BUFFER(__DS_TC_LOCAL_Q_DES_LIST_BASE),
+				DS_FRAG_DES_LIST1_LEN,
+				__DS_TC_LOCAL_Q_DES_LIST_NUM, base);
+	}
+
+	if (is_bonding == 1 && ep_id == DS_BONDING_MASTER) {
+		/* Setup DMA Channel  (RX CH 4 / TX CH5) : 1 Descriptor */
+		/* Bond DS des sync cfg ctxt */
+		rx_des_off = offsetof(bond_des_sync_cfg_ctxt_t, cdma_rx_des_dw0) / 4;
+		rx_dbase = __BOND_DS_DES_SYNC_CFG_CTXT + rx_des_off;
+		vrx318_w32_sb(0x0, rx_dbase, base);
+		vrx318_w32_sb(0x0, rx_dbase + 1, base);
+		tx_des_off = offsetof(bond_des_sync_cfg_ctxt_t, cdma_tx_des_dw0) / 4;
+		tx_dbase = __BOND_DS_DES_SYNC_CFG_CTXT + tx_des_off;
+		vrx318_w32_sb(0x0, tx_dbase, base);
+		vrx318_w32_sb(0x0, tx_dbase + 1, base);
+		vrx318_cfg_cdma_cpch(4, 5, SB_BUFFER(rx_dbase), SB_BUFFER(tx_dbase), 1, 1, base);
+
+		if (cdma_write_data_en) {
+			/* CDMA write ds_tc_local_q_des_list to ds_frag_des_list2(TX CH to RX CH) */
+			/* Setup DMA Channel (RX CH6 / TX CH7) */
+			vrx318_cfg_cdma_cpch(6, 7,
+				SB_BUFFER(__DS_FRAGQ_DES_LIST_BASE + (DS_FRAG_DES_LIST1_LEN_MAX * 2)),
+				SB_BUFFER(__DS_TC_LOCAL_Q_DES_LIST_BASE),
+				DS_FRAG_DES_LIST2_LEN, __DS_TC_LOCAL_Q_DES_LIST_NUM, base);
+		}
+	}
+
+	/* if peer to peer is not enabled, then the DMA CH 6 & 7 are used to sync the bonding fragment descriptors */
+	if (is_bonding == 1 && ep_id == US_BONDING_MASTER && (cdma_write_data_en == 0)) {
+		/* Setup DMA Channel (RXCH 6 /TXCH 7) : 1 Descriptor */
+		rx_des_off = offsetof(bond_des_sync_cfg_ctxt_t, cdma_rx_des_dw0) / 4;
+		rx_dbase = __BOND_DS_DES_SYNC_CFG_CTXT + rx_des_off;
+		vrx318_w32_sb(0x0, rx_dbase, base);
+		vrx318_w32_sb(0x0, rx_dbase + 1, base);
+		tx_des_off = offsetof(bond_des_sync_cfg_ctxt_t, cdma_tx_des_dw0) / 4;
+		tx_dbase = __BOND_DS_DES_SYNC_CFG_CTXT + tx_des_off;
+		vrx318_w32_sb(0x0, tx_dbase, base);
+		vrx318_w32_sb(0x0, tx_dbase + 1, base);
+		vrx318_cfg_cdma_cpch(6, 7, SB_BUFFER(rx_dbase), SB_BUFFER(tx_dbase), 1, 1, base);
+	}
+
+	return;
+}
+
+
+/*************************************************************************
+ *  PTM TC - Initialization : Entry Point
+ *  dev         - PCIe endpoint device
+ *  peer_dev    - PCIe endpoint device of peer bonding device
+ *  tc_mode  - ptm single line /ptm bonding
+ *  ep_id   - 0: upstream bonding master, 1: downstream bonding master
+ *  sync_buf    - memory base address of bonding US/DS descriptor sync buffer
+ *  lle_in_sb   - 0: LLE in PDBRAM, 1: LLE in SB
+*************************************************************************/
+static int ppe_ptm_fw_hw_init(struct vrx318_ptm_tc *priv,
+				u32 ep_id, enum dsl_tc_mode tc_mode)
+{
+	u32 base;
+	int pmac_en, cdma_wr_en, is_bonding, lle_in_sb;
+	struct vrx318_priv *frwk_priv;
+
+	frwk_priv = priv->frwk;
+	base = (u32)frwk_priv->ep_dev[ep_id].membase;
+	pmac_en = frwk_priv->param.pmac_en ? 1 : 0;
+	cdma_wr_en = frwk_priv->param.cdma_wr_en ? 1 : 0;
+	is_bonding = tc_mode == TC_PTM_BND_MODE ? 1 : 0;
+	lle_in_sb = frwk_priv->param.lle_in_sb ? 1 : 0;
+
+	vrx318_sb_clear(base);
+
+	vrx318_tc_hw_init(base, is_bonding);
+	vrx318_tc_fw_init(base, is_bonding, pmac_en);
+
+	vrx318_gen_cfg_init(priv, base, is_bonding, ep_id,
+		frwk_priv->ep_dev[ep_id].peer_phy_membase[0],
+		cdma_wr_en, pmac_en);
+	vrx318_edma_init(base, lle_in_sb, cdma_wr_en);
+
+	/* US/DS des sync cfg ctxt init and related desq_cfg_ctxt init */
+	vrx318_des_sync_init(frwk_priv, base, is_bonding, ep_id);
+	/* Bonding des sync cfg ctxt init */
+	vrx318_bonding_des_sync_init(priv, base, is_bonding, ep_id);
+
+	vrx318_us_qos_cfg_init(priv, base, is_bonding, ep_id);
+
+	vrx318_us_bg_ctxt_init(base, is_bonding, ep_id);
+
+	vrx318_edma_copy_ch_init(base, is_bonding, ep_id, cdma_wr_en);
+
+	vrx318_local_des_init(base, cdma_wr_en);
+
+	vrx318_ds_bg_ctxt_init(base, is_bonding, ep_id);
+	vrx318_ds_ll_ctxt_init(priv->frwk, base, is_bonding, ep_id);
+
+	vrx318_ds_fragq_desq_cfg_ctxt_init(priv, base, is_bonding, ep_id);
+
+	vrx318_cdma_copy_ch_init(base, is_bonding, ep_id, cdma_wr_en);
+	vrx318_cdma_init(priv, base, is_bonding, ep_id, cdma_wr_en);
+
+	return 0;
+}
+
+static void pp32_load(u32 base)
+{
+	int ret;
+
+	/*  download firmware   */
+	vrx318_dbg(DBG_INIT, "Download E1 FW\n");
+	ret = pp32_download_code(base, 0,
+		vrx218_e1_fw_code, ARRAY_SIZE(vrx218_e1_fw_code),
+		vrx218_e1_fw_data, ARRAY_SIZE(vrx218_e1_fw_data));
+	if (ret) {
+		vrx318_dbg(DBG_ERR, "Download E1 FW code fail\n");
+		BUG();
+	}
+
+	vrx318_dbg(DBG_INIT, "Downdload B1 FW\n");
+	ret = pp32_download_code(base, 1,
+		vrx218_pp32_1_fw_code, ARRAY_SIZE(vrx218_pp32_1_fw_code),
+		vrx218_pp32_1_fw_data, ARRAY_SIZE(vrx218_pp32_1_fw_data));
+	if (ret) {
+		vrx318_dbg(DBG_ERR, "Download B1 FW code fail\n");
+		BUG();
+	}
+}
+
+static inline void ptm_print_fw_ver(struct vrx318_ptm_tc *priv, int ep_id)
+{
+	int i;
+
+	for (i = 0; i < 2; i++)
+		print_fw_version(NULL, &priv->fw_ver[ep_id][i]);
+}
+
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+extern int dp_coc_new_stat_req(enum ltq_cpufreq_state new_state
+	, uint32_t flag);
+static void do_coc_tasklet(unsigned long arg)
+{
+	/* change state to D0 */
+	ptm_coc_state = LTQ_CPUFREQ_PS_D0;
+	/* call datapath to inform about the new state */
+	dp_coc_new_stat_req(ptm_coc_state, DP_COC_REQ_VRX318);
+}
+#endif
+
+static irqreturn_t vrx318_irq_handler(int irq, void *dev_id)
+{
+	u32 mbox1_isr, mbox1_ier, mbox1_isrc;
+	u32 base, peer_state, peer_base;
+	struct vrx318_ptm_tc *priv = g_ptm_tc;
+	struct pcie_ep_dev *ep_dev = dev_id;
+
+	base = (u32)ep_dev->membase;
+	mbox1_ier = vrx318_r32(MBOX_IGU1_IER, base);
+	mbox1_isrc = vrx318_r32(MBOX_IGU1_ISR, base);
+
+	mbox1_isr = mbox1_isrc & mbox1_ier;
+
+	if (mbox1_isr & P2P_STAT_INTR) { /* Bit 4  Peer to Peer link state update */
+		if (priv->tc_mode == TC_PTM_BND_MODE) {
+			peer_state = vrx318_r32_sb(__PEER_GIF_LINK_STATE_TMP, base);
+			peer_base = (u32)ep_dev->peer_membase[0];
+			vrx318_w32_sb(peer_state, __PEER_GIF_LINK_STATE, peer_base);
+		}
+	}
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+	if (mbox1_isr & PKT_RX_INTR) {
+		mbox1_ier &= ~PKT_RX_INTR;
+		mbox_set_ier(MBOX_IGU1, mbox1_ier, base);
+		tasklet_schedule(&g_coc_tasklet);
+	}
+#endif
+	vrx318_w32(mbox1_isrc, MBOX_IGU1_ISRC, base);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+static int32_t ptm_coc_confirm_stat(enum ltq_cpufreq_state new_state,
+	enum ltq_cpufreq_state old_state,
+	uint32_t flags)
+{
+	struct vrx318_ptm_tc *priv = g_ptm_tc;
+	int ret = -ENODEV;
+	u32 base;
+	int ep_id;
+
+	ep_id = priv->ep_id;
+	base = (u32)priv->frwk->ep_dev[ep_id].membase;
+	vrx318_dbg(DBG_COC, "Current state: %u, old [%u] to [%u]\n",
+		ptm_coc_state, (u32)old_state, (u32)new_state);
+
+	if (new_state != ptm_coc_state) {
+		/* assign new state */
+		vrx318_dbg(DBG_COC, "Change from current state %u to new %u\n",
+			ptm_coc_state, new_state);
+		ptm_coc_state = new_state;
+		/* check for D3 state */
+		if (ptm_coc_state == LTQ_CPUFREQ_PS_D3) {
+			u32 mbox1_ier;
+			vrx318_dbg(DBG_COC, "Change to D3, enable interrupt\n");
+			/* Enable interrupt for DS packet */
+			mbox1_ier = vrx318_r32(MBOX_IGU1_IER, base);
+			mbox_set_ier(MBOX_IGU1, mbox1_ier | PKT_RX_INTR, base);
+		} else {
+			/* Disable interrupt for DS packet */
+			u32 mbox1_ier;
+			vrx318_dbg(DBG_COC, "Change to %u, disable interrupt\n", ptm_coc_state);
+			/* Disable interrupt for DS packet */
+			mbox1_ier = vrx318_r32(MBOX_IGU1_IER, base);
+			mbox1_ier &= ~PKT_RX_INTR;
+			mbox_set_ier(MBOX_IGU1, mbox1_ier, base);
+		}
+	}
+	vrx318_dbg(DBG_COC, "Complete\n");
+	return ret;
+}
+#endif
+
+static void vrx318_ptm_datapath_init(struct vrx318_ptm_tc *priv,
+				enum dsl_tc_mode tc_mode, int ep_id)
+{
+	const char *dev_name;
+	int ret;
+
+	if (tc_mode == TC_PTM_BND_MODE)
+		dev_name = g_bnd_dev_name[ep_id];
+	else
+		dev_name = g_ptm_dev_name;
+
+	ret = devm_request_irq(priv->frwk->pdev, priv->frwk->ep_dev[ep_id].irq,
+			vrx318_irq_handler, 0, dev_name,
+			(void *)&priv->frwk->ep_dev[ep_id]);
+
+	if (ret) {
+		vrx318_dbg(DBG_ERR, "PTM Register Interrupt Fail!\n");
+		BUG();
+	}
+
+	vrx318_cb_setup(ptm_dp_rx, ptm_dp_stop_tx, ptm_dp_restart_tx, ptm_get_subif_id
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+		, ptm_coc_confirm_stat
+#endif
+	);
+	ppa_callback_set(LTQ_MEI_SHOWTIME_ENTER, ptm_showtime_enter);
+	ppa_callback_set(LTQ_MEI_SHOWTIME_EXIT, ptm_showtime_exit);
+}
+
+static inline void get_fw_version(struct fw_ver_id *ver, u32 base)
+{
+	u32 version;
+
+	version = vrx318_r32_sb(__FW_VER_ID, base);
+	*ver = *(struct fw_ver_id *)&version;
+}
+
+/**
+*  US des sync: CDMA read and dmal write
+*  US data copy: (DDR to PDBRAM) EDMA read
+*  peer to peer write: dmal write
+*  DS data copy: (PDBRAM to DDR) CDMA write
+*  DS des sync: dmal write and CDMA read
+*  EDMA no outbound base address, pcie will handle it.
+*  DMAL and CDMA NEED outbound base address.
+*/
+static int vrx318_ptm_tc_hw_fw_init(struct vrx318_ptm_tc *priv,
+				int ep_id, enum dsl_tc_mode tc_mode)
+{
+	u32 base;
+	int ret;
+	int i;
+
+	base = (u32)priv->frwk->ep_dev[ep_id].membase;
+
+	vrx318_dbg(DBG_TC_SWITCH, "vrx318 id  = %d\n", ep_id);
+	vrx318_dbg(DBG_TC_SWITCH, "irq        = %u\n",
+		priv->frwk->ep_dev[ep_id].irq);
+	vrx318_dbg(DBG_TC_SWITCH, "membase    = 0x%08x\n",
+		(unsigned int)priv->frwk->ep_dev[ep_id].membase);
+	vrx318_dbg(DBG_TC_SWITCH, "phy_membase = 0x%08x\n",
+		priv->frwk->ep_dev[ep_id].phy_membase);
+	vrx318_dbg(DBG_TC_SWITCH, "peer_num    = %u\n",
+		priv->frwk->ep_dev[ep_id].peer_num);
+	vrx318_dbg(DBG_TC_SWITCH, "tc_mode         = %s\n",
+		tc_mode == TC_PTM_SL_MODE ? "PTM Single Line" : "PTM Bonding");
+
+	/* Reset PPE HW */
+	reset_ppe(base);
+	/* Activate VRX318 */
+	enable_ppe_ema(base);
+	/* Set VRX318 PPE clock 432MHz */
+	set_ppe_clk(432, base);
+	/* Clear and disable mailbox   */
+	mbox_clr_isr(MBOX_IGU0, 0xFFFFFFFF, base);
+	mbox_clr_isr(MBOX_IGU1, 0xFFFFFFFF, base);
+	mbox_set_ier(MBOX_IGU0, 0, base);
+	mbox_set_ier(MBOX_IGU1, 0, base);
+
+	/* Freeze PP32 */
+	pp32_stop(base);
+	ret = ppe_ptm_fw_hw_init(priv, ep_id, tc_mode);
+	if (ret)
+		return ret;
+
+	pp32_load(base);
+
+	/* init datapath */
+	vrx318_ptm_datapath_init(priv, tc_mode, ep_id);
+
+	/* start hardware */
+	setup_dfe_loopback(priv->frwk, base);
+	for (i = 0; i < PP32_NUM; i++) {
+		pp32_start(i, base);
+		get_fw_version(&priv->fw_ver[ep_id][i], base);
+	}
+	dfe_loopback_linkup(priv->frwk, base);
+
+	/* Indicate DSL FW all configuration is ready */
+	/* PPE FW is ready to receive/send packets */
+	vrx318_tc_indicate(tc_mode, base, 1);
+
+	/* enable mailbox */
+	if (tc_mode == TC_PTM_BND_MODE && !priv->frwk->param.p2p_en)
+		mbox_set_ier(MBOX_IGU1, P2P_STAT_INTR | FW_UNLOAD_INTR, base);
+	else
+		mbox_set_ier(MBOX_IGU1, FW_UNLOAD_INTR, base);
+
+	ptm_print_fw_ver(priv, ep_id);
+
+	vrx318_dbg(DBG_TC_SWITCH, "VRX318 PTM init HW successfully\n");
+	return 0;
+}
+
+void vrx318_ptm_pmac_cfg_init(int pid, enum dsl_tc_mode tc_mode)
+{
+	struct dp_pmac_cfg pmac_cfg;
+
+	memset(&pmac_cfg, 0, sizeof(pmac_cfg));
+
+	pmac_cfg.eg_pmac_flags = EG_PMAC_F_PMAC | EG_PMAC_F_FCS | EG_PMAC_F_TCENA;
+
+	pmac_cfg.eg_pmac.pmac = 0;
+	pmac_cfg.eg_pmac.tc_enable = 1;
+	pmac_cfg.eg_pmac.fcs = (tc_mode == TC_PTM_BND_MODE) ? 1 : 0;
+
+	pmac_cfg.ig_pmac_flags = IG_PMAC_F_PRESENT | IG_PMAC_F_SPID
+				| IG_PMAC_F_PMACHDR3 | IG_PMAC_F_PMACHDR5;
+
+	pmac_cfg.ig_pmac.pmac = 0;
+	pmac_cfg.ig_pmac.def_pmac_src_port = 1;
+	pmac_cfg.ig_pmac.def_pmac_hdr[2] = (pid & 0xF) << 4;
+	pmac_cfg.ig_pmac.def_pmac_hdr[4] = 0x80; /* Packet has FCS */
+
+	dp_pmac_set(pid, &pmac_cfg);
+
+}
+
+int vrx318_ptm_tc_init(struct vrx318_priv *frwk_priv,
+			int ep_id, enum dsl_tc_mode tc_mode)
+{
+	struct vrx318_ptm_tc *priv;
+	int err;
+	struct net_device *dev;
+	int i;
+
+	if (frwk_priv->ep_num <= 1 && tc_mode == TC_PTM_BND_MODE)
+		return -EINVAL;
+
+	if (!g_ptm_tc) {
+		err = vrx318_ptm_dev_init(frwk_priv, tc_mode);
+		if (err)
+			return err;
+	}
+	priv = g_ptm_tc;
+	priv->ep_id = ep_id;
+	priv->tc_mode = tc_mode;
+	dev = priv->dev;
+
+	vrx318_ptm_cfg_init(frwk_priv, tc_mode);
+	if (tc_mode == TC_PTM_SL_MODE) {
+		err = vrx318_ptm_tc_hw_fw_init(priv, ep_id, tc_mode);
+		if (err)
+			return err;
+	} else if (tc_mode == TC_PTM_BND_MODE) {
+		for (i = 0; i < MAX_VRX318_NUM; i++) {
+			err = vrx318_ptm_tc_hw_fw_init(priv, i, tc_mode);
+			if (err)
+				return err;
+		}
+	}
+	frwk_priv->tc_priv = priv;
+
+	/* pmac configuration */
+	vrx318_ptm_pmac_cfg_init(frwk_priv->port_id, tc_mode);
+
+	/* Proc Init */
+	vrx318_ptm_proc_init(priv);
+
+	/* Send userspace TC UP message */
+
+	vrx_tc_msg_send(0, PTM_TC, TC_LOADED,
+		(tc_mode == TC_PTM_BND_MODE) ? BONDING_MODE : NON_BONDING_MODE,
+		ep_id);
+
+	vrx318_dbg(DBG_TC_SWITCH, "VRX318 PTM TC is successfully loaded\n");
+
+	return 0;
+}
+
+static void vrx318_ptm_free_mem(struct vrx318_ptm_tc *priv,
+				int ep_id, u32 base, int is_bonding)
+{
+	int i;
+	int phy_addr;
+	desq_cfg_ctxt_t desq_cfg;
+	ds_bond_gif_ll_des_t ll_desc;
+
+	/* Free QoS/OUTQ queue buffers */
+	if (!is_bonding || ep_id == US_BONDING_MASTER) {
+		for (i = 0; i < TOTAL_QOS_DES_NUM; i++) {
+			phy_addr = vrx318_r32_sb(__US_QOSQ_DES_LIST_BASE + (i * 2) + 1,	base) - VRX318_OB_BADDR;
+			free_data_buffer(phy_addr);
+		}
+		for (i = 0; i < OUTQ_NUM; i++) {
+			phy_addr = vrx318_r32_sb(__US_OUTQ_DES_LIST_BASE + (i * 2) + 1, base) - VRX318_OB_BADDR;
+			free_data_buffer(phy_addr);
+		}
+	}
+
+	/* Free DS pkt des list, not required in GRX350 */
+
+	/* Free DS FRAGQ dest buffers */
+	if (is_bonding) {
+		if (ep_id == US_BONDING_MASTER)
+			dword_mem_read(&desq_cfg,
+					SB_BUFFER(__DS_FRAGQ_CFG_CTXT_BASE),
+					sizeof(desq_cfg), base);
+		else
+			dword_mem_read(&desq_cfg,
+				SB_BUFFER(__DS_FRAGQ_CFG_CTXT_BASE) + sizeof(desq_cfg) / sizeof(unsigned int),
+				sizeof(desq_cfg), base);
+
+		for (i = 0; i < desq_cfg.des_num; i++) {
+			phy_addr = vrx318_r32_sb(desq_cfg.des_base_addr + (i * 2) + 1, base) - VRX318_OB_BADDR;
+			free_data_buffer(phy_addr);
+		}
+	}
+
+	/* Free Link list buffers */
+	if (is_bonding && ep_id == DS_BONDING_MASTER) {
+		for (i = 0; i < DS_BOND_GIF_LL_DES_LEN; i++) {
+			dword_mem_read(&ll_desc, DS_BOND_GIF_LL_DES_BA(i),
+				sizeof(ll_desc), base);
+			phy_addr = ll_desc.data_ptr - VRX318_OB_BADDR;
+			free_data_buffer(phy_addr);
+		}
+	}
+
+	return;
+}
+
+static void ptm_unload_tc(int ep_id, int is_bonding)
+{
+	struct vrx318_ptm_tc *priv = g_ptm_tc;
+	struct vrx318_priv *frwk = priv->frwk;
+	u32 base = (u32)frwk->ep_dev[ep_id].membase;
+	int err;
+
+	/* Indicate DSL FW TC Clear */
+	vrx318_tc_indicate(0, base, 0);
+
+	/* Reset xDSL MEI */
+	/* vrx318_reset_xdsl(base); */
+
+	/* Stop ptm device and Unregister subif id */
+	/* dev_close(priv->dev); */
+
+	/* Indicate PPE FW to stop */
+	priv->comp.done = 0;
+	vrx318_w32(1, PPE_TC_SWITCH, base);
+	err = wait_for_completion_timeout(&priv->comp,
+			msecs_to_jiffies(FW_STOP_TIMEOUT));
+
+	if (err < 0)
+		vrx318_dbg(DBG_TC_SWITCH, "Wait process got interrupted\n");
+
+	if (!err)
+		vrx318_dbg(DBG_TC_SWITCH, "Wait process Timeout\n");
+
+	/* Stop PPE FW */
+	pp32_stop(base);
+
+	/* Unregister Interrupt handler */
+	devm_free_irq(frwk->pdev, frwk->ep_dev[ep_id].irq,
+		(void *)&frwk->ep_dev[ep_id]);
+
+	/* Disable and Clear all Interrupts */
+	mbox_set_ier(MBOX_IGU0, 0, base);
+	mbox_set_ier(MBOX_IGU1, 0, base);
+	mbox_clr_isr(MBOX_IGU0, 0xFFFFFFFF, base);
+	mbox_clr_isr(MBOX_IGU1, 0xFFFFFFFF, base);
+
+	/* Free CBM resources */
+	vrx318_ptm_free_mem(priv, ep_id, base, is_bonding);
+
+	return;
+}
+
+int vrx318_unload_ptm_tc(struct vrx318_priv *frwk_priv,
+			int ep_id, enum dsl_tc_mode tc_mode)
+{
+	if (in_interrupt()) {
+		vrx318_dbg(DBG_ERR, "VRX318 cannot be unloaded in interrupt context\n");
+		return -EINVAL;
+	}
+
+	if (frwk_priv->tc_priv != g_ptm_tc) {
+		vrx318_dbg(DBG_ERR, "TC pointer not match as PTM TC pointer\n");
+		return -ENODEV;
+	}
+
+	if (tc_mode == TC_PTM_BND_MODE) {
+		if (frwk_priv->ep_num <= 1)
+			return -EINVAL;
+		ptm_unload_tc(US_BONDING_MASTER, 1);
+		ptm_unload_tc(DS_BONDING_MASTER, 1);
+	} else {
+		ptm_unload_tc(ep_id, 0);
+	}
+
+	/* Reset CBM EQM/DQM idx */
+	soc_vrx318_cfg_reset();
+
+	/* Free Proc */
+	vrx318_ptm_proc_exit(g_ptm_tc);
+
+	/* message for TC DOWN */
+	vrx_tc_msg_send(0, PTM_TC, TC_UNLOADED,
+		(tc_mode == TC_PTM_BND_MODE) ? BONDING_MODE : NON_BONDING_MODE,
+		ep_id);
+
+	vrx318_dbg(DBG_TC_SWITCH, "Unload PTM TC successfully!!!\n");
+
+	return 0;
+}
+
+
+static void print_ptm_drv_mib(struct seq_file *seq, struct vrx318_ptm_tc *priv)
+{
+	seq_puts(seq, "Driver MIB:\n");
+
+	seq_printf(seq, "RX PKTs:\t %lu\n", priv->stats.rx_packets);
+	seq_printf(seq, "RX Bytes:\t %lu\n", priv->stats.rx_bytes);
+	seq_printf(seq, "RX Error:\t %lu\n", priv->stats.rx_errors);
+	seq_printf(seq, "RX Drop:\t %lu\n\n", priv->stats.rx_dropped);
+	seq_printf(seq, "TX PKTs:\t %lu\n", priv->stats.tx_packets);
+	seq_printf(seq, "TX Bytes:\t %lu\n", priv->stats.tx_bytes);
+	seq_printf(seq, "TX Err:\t %lu\n", priv->stats.tx_errors);
+	seq_printf(seq, "TX Drop:\t %lu\n", priv->stats.tx_dropped);
+}
+
+int proc_read_ptm_wanmib(struct seq_file *seq, void *v)
+{
+	struct vrx318_ptm_tc *priv = (struct vrx318_ptm_tc *)seq->private;
+	u32 base = (u32)priv->frwk->ep_dev[priv->ep_id].membase;
+	unsigned int wrx_total_pdu[4]		= {PPE_DREG_AR_AIIDLE_CNT0, PPE_DREG_AR_HEC_CNT0, PPE_DREG_AR_AIIDLE_CNT1, PPE_DREG_AR_HEC_CNT1};
+	unsigned int wrx_crc_err_pdu[4]		= {GIF0_RX_CRC_ERR_CNT, GIF1_RX_CRC_ERR_CNT, GIF2_RX_CRC_ERR_CNT, GIF3_RX_CRC_ERR_CNT};
+	unsigned int wrx_cv_cw_cnt[4]		= {GIF0_RX_CV_CNT, GIF1_RX_CV_CNT, GIF2_RX_CV_CNT, GIF3_RX_CV_CNT};
+	unsigned int wrx_bc_overdrop_cnt[2]	= {DREG_B0_OVERDROP_CNT, DREG_B1_OVERDROP_CNT};
+	int i;
+	int idx = priv->ep_id;
+	unsigned int cur_cnt, last_cnt;
+	struct wan_rx_mib_table rx_mib;
+
+	seq_puts(seq, "FW MIB:\n");
+	seq_puts(seq, "RX (Bearer Channels[0-1]):\n");
+	seq_puts(seq, "   wrx_bc_overdrop:");
+	for (i = 0; i < 2; i++) {
+		if (i != 0)
+			seq_printf(seq, ", ");
+		cur_cnt = vrx318_r32(wrx_bc_overdrop_cnt[i], base);
+		last_cnt = priv->ptm_mib[idx].rx_bc_overdrop_cnt[i];
+		seq_printf(seq, "%10u", cur_cnt >= last_cnt
+			? cur_cnt - last_cnt
+			: cur_cnt + ((unsigned int)(-1) - last_cnt));
+	}
+	seq_puts(seq, "\n");
+	seq_puts(seq, "   wrx_bc_user_cw: ");
+	for (i = 0; i < 2; i++) {
+		if (i != 0)
+			seq_puts(seq, ", ");
+		seq_printf(seq, "%10u", vrx318_r32_sb(__RECEIVE_NON_IDLE_CELL_CNT_0 + i, base));
+	}
+	seq_puts(seq, "\n");
+	seq_puts(seq, "   wrx_bc_idle_cw: ");
+	for (i = 0; i < 2; i++) {
+		if (i != 0)
+			seq_puts(seq, ", ");
+		seq_printf(seq, "%10u", vrx318_r32_sb(__RECEIVE_IDLE_CELL_CNT_0 + i, base));
+	}
+	seq_puts(seq, "\n");
+
+	seq_puts(seq, "RX (Gamma Interfaces[0-3]):\n");
+	seq_puts(seq, "  wrx_total_pdu:   ");
+	for (i = 0; i < 4; i++) {
+		if (i != 0)
+			seq_puts(seq, ", ");
+		cur_cnt = vrx318_r32(wrx_total_pdu[i], base);
+		last_cnt = priv->ptm_mib[idx].rx_total_pdu[i];
+		seq_printf(seq, "%10u", cur_cnt >= last_cnt
+			? cur_cnt - last_cnt
+			: cur_cnt + ((unsigned int)(-1) - last_cnt));
+	}
+	seq_puts(seq, "\n");
+
+	seq_puts(seq, "  wrx_dropdes_pdu: ");
+	for (i = 0; i < 4; i++) {
+		if (i != 0)
+			seq_puts(seq, ", ");
+		dword_mem_read(&rx_mib,
+			SB_BUFFER(__RX_GIF_MIB_BASE + (i * sizeof(rx_mib) / 4)),
+			sizeof(rx_mib), base);
+		seq_printf(seq, "%10u", rx_mib.wrx_dropdes_pdu);
+	}
+	seq_puts(seq, "\n");
+
+	seq_puts(seq, "  wrx_crc_err_pdu: ");
+	for (i = 0; i < 4; i++) {
+		if (i != 0)
+			seq_puts(seq, ", ");
+		cur_cnt = vrx318_r32(wrx_crc_err_pdu[i], base);
+		last_cnt = priv->ptm_mib[idx].rx_crc_err_pdu[i];
+		seq_printf(seq, "%10u", cur_cnt >= last_cnt
+			? cur_cnt - last_cnt
+			: cur_cnt + ((unsigned int)(-1) - last_cnt));
+	}
+	seq_puts(seq, "\n");
+
+	seq_puts(seq, "  wrx_violated_cw: ");
+	for (i = 0; i < 4; i++) {
+		if (i != 0)
+			seq_puts(seq, ", ");
+		cur_cnt = vrx318_r32(wrx_cv_cw_cnt[i], base);
+		last_cnt = priv->ptm_mib[idx].rx_cv_cw_cnt[i];
+		seq_printf(seq, "%10u", cur_cnt >= last_cnt
+			? cur_cnt - last_cnt
+			: cur_cnt + ((unsigned int)(-1) - last_cnt));
+	}
+	seq_puts(seq, "\n");
+
+	seq_puts(seq, "  wrx_total_bytes: ");
+	for (i = 0; i < 4; i++) {
+		if (i != 0)
+			seq_puts(seq, ", ");
+		dword_mem_read(&rx_mib,
+			SB_BUFFER(__RX_GIF_MIB_BASE + (i * sizeof(rx_mib) / 4)),
+			sizeof(rx_mib), base);
+		seq_printf(seq, "%10u", rx_mib.wrx_total_bytes);
+	}
+	seq_puts(seq, "\n");
+
+	seq_puts(seq, "TX (Bearer Channels[0-1]):\n");
+	seq_printf(seq, "  total_tx_cw:     %10u, %10u\n",
+		vrx318_r32_sb(__TRANSMIT_CELL_CNT_0, base),
+		vrx318_r32_sb(__TRANSMIT_CELL_CNT_1, base));
+
+	seq_puts(seq, "TX (Gamma Interfaces[0-3]):\n");
+	seq_puts(seq, "  tx_total_pdu:    ");
+	for (i = 0; i < 4; i++) {
+		if (i != 0)
+			seq_puts(seq, ", ");
+		cur_cnt = vrx318_r32_sb(__US_TC_LOCAL_Q_CFG_CTXT_BASE +
+				i * sizeof(desq_cfg_ctxt_t) / 4 +
+				offsetof(desq_cfg_ctxt_t, deq_pkt_cnt) / 4,
+				base);
+		last_cnt = priv->ptm_mib[idx].tx_total_pdu[i];
+		seq_printf(seq, "%10u", cur_cnt >= last_cnt
+			? cur_cnt - last_cnt
+			: cur_cnt + ((unsigned int)(-1) - last_cnt));
+	}
+	seq_puts(seq, "\n");
+
+	seq_puts(seq, "  tx_total_bytes:  ");
+	for (i = 0; i < 4; i++) {
+		if (i != 0)
+			seq_puts(seq, ", ");
+		cur_cnt = vrx318_r32_sb(__US_TC_LOCAL_Q_CFG_CTXT_BASE +
+				i * sizeof(desq_cfg_ctxt_t) / 4 +
+				offsetof(desq_cfg_ctxt_t, deq_byte_cnt) / 4,
+				base);
+		last_cnt = priv->ptm_mib[idx].tx_total_bytes[i];
+		seq_printf(seq, "%10u", cur_cnt >= last_cnt
+			? cur_cnt - last_cnt
+			: cur_cnt + ((unsigned int)(-1) - last_cnt));
+	}
+	seq_puts(seq, "\n");
+
+	print_ptm_drv_mib(seq, priv);
+
+	return 0;
+}
+
+ssize_t proc_write_ptm_wanmib(struct file *file, const char __user *buf, size_t count, loff_t *data)
+{
+	char str[32];
+	int len, rlen;
+	u32 base;
+	int num;
+	char *param_list[20];
+	struct vrx318_ptm_tc *priv;
+	unsigned int wrx_total_pdu[4]         = {PPE_DREG_AR_AIIDLE_CNT0, PPE_DREG_AR_HEC_CNT0, PPE_DREG_AR_AIIDLE_CNT1, PPE_DREG_AR_HEC_CNT1};
+	unsigned int wrx_crc_err_pdu[4]       = {GIF0_RX_CRC_ERR_CNT, GIF1_RX_CRC_ERR_CNT, GIF2_RX_CRC_ERR_CNT, GIF3_RX_CRC_ERR_CNT};
+	unsigned int wrx_cv_cw_cnt[4]         = {GIF0_RX_CV_CNT, GIF1_RX_CV_CNT, GIF2_RX_CV_CNT, GIF3_RX_CV_CNT};
+	unsigned int wrx_bc_overdrop_cnt[2]   = {DREG_B0_OVERDROP_CNT, DREG_B1_OVERDROP_CNT};
+	int i;
+	int idx;
+
+	priv = (struct vrx318_ptm_tc *)PDE_DATA(file_inode(file));
+	idx = priv->ep_id;
+	base = (u32)priv->frwk->ep_dev[idx].membase;
+
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+
+	num = dp_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+	if ((dp_strcmpi(param_list[0], "clear") == 0)
+		|| (dp_strcmpi(param_list[0], "clean") == 0)
+		|| (dp_strcmpi(param_list[0], "c") == 0)) {
+		for (i = 0; i < 4; i++) {
+			priv->ptm_mib[idx].rx_total_pdu[i]
+				= vrx318_r32(wrx_total_pdu[i], base);
+			priv->ptm_mib[idx].rx_crc_err_pdu[i]
+				= vrx318_r32(wrx_crc_err_pdu[i], base);
+			priv->ptm_mib[idx].rx_cv_cw_cnt[i]
+				= vrx318_r32(wrx_cv_cw_cnt[i], base);
+			priv->ptm_mib[idx].tx_total_pdu[i]
+				= vrx318_r32_sb(__US_TC_LOCAL_Q_CFG_CTXT_BASE +
+					i * sizeof(desq_cfg_ctxt_t) / 4 +
+					offsetof(desq_cfg_ctxt_t, deq_pkt_cnt) / 4,
+					base);
+			priv->ptm_mib[idx].tx_total_bytes[i]
+				= vrx318_r32_sb(__US_TC_LOCAL_Q_CFG_CTXT_BASE +
+					i * sizeof(desq_cfg_ctxt_t) / 4 +
+					offsetof(desq_cfg_ctxt_t, deq_byte_cnt) / 4,
+					base);
+
+			if (i < 2) {
+				priv->ptm_mib[idx].rx_bc_overdrop_cnt[i]
+					= vrx318_r32(wrx_bc_overdrop_cnt[i], base);
+				vrx318_w32_sb(0, __RECEIVE_NON_IDLE_CELL_CNT_0 + i, base);
+				vrx318_w32_sb(0, __RECEIVE_IDLE_CELL_CNT_0 + i, base);
+				vrx318_w32_sb(0, __TRANSMIT_CELL_CNT_0 + i, base);
+			}
+			dword_ep_clear(SB_BUFFER(__RX_GIF_MIB_BASE +
+				i * sizeof(struct wan_rx_mib_table) / 4),
+				sizeof(struct wan_rx_mib_table), base);
+		}
+		for (i = 0; i < QOSQ_NUM; i++) {
+			dword_ep_clear(SB_BUFFER(__QOSQ_MIB_BASE +
+				i * sizeof(qosq_mib_t) / 4),
+				sizeof(qosq_mib_t), base);
+		}
+
+		memset(&priv->stats, 0, sizeof(priv->stats));
+	} else
+		goto proc_ptm_wanmib_help;
+
+	return count;
+
+proc_ptm_wanmib_help:
+	pr_info("echo clear/clean/c > wanmib\n");
+	return count;
+}
diff --git a/include/net/vrx318_dsl_api.h b/include/net/vrx318_dsl_api.h
new file mode 100644
--- /dev/null
+++ b/include/net/vrx318_dsl_api.h
@@ -0,0 +1,51 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2015 Zhu YiXin<yixin.zhu@lantiq.com>
+ */
+
+#ifndef __VRX318_DSL_API_H__
+#define __VRX318_DSL_API_H__
+
+#include <net/genetlink.h>
+
+#define VERSION_NR 1
+
+enum vrx318_attr {
+	VRX_TC_A_UNSPEC,
+	VRX_TC_A_TC_MODE,
+	VRX_TC_A_TC_ACTION,
+	VRX_TC_A_BOND,
+	VRX_TC_A_LINENO,
+	__VRX_TC_A_MAX,
+};
+#define VRX_TC_A_MAX (__VRX_TC_A_MAX - 1)
+
+enum vrx318_cmd {
+	VRX_TC_C_UNSPEC,
+	VRX_TC_C_NOTIFY,
+	__VRX_TC_C_MAX,
+};
+#define VRX_TC_C_MAX (__VRX_TC_C_MAX - 1)
+
+#define VRX_MCAST_GRP_NAME "vrx_mcgrp"
+#define VRX_FAMILY_NAME "vrx_tc_notify"
+
+enum vrx318_tc_type {
+	ATM_TC = 1,
+	PTM_TC,
+};
+
+enum vrx318_tc_action {
+	TC_UNLOADED = 0,
+	TC_LOADED,
+};
+
+enum vrx318_bonding_stat {
+	NON_BONDING_MODE = 0,
+	BONDING_MODE,
+};
+
+#endif /* __VRX318_DSL_API_H__ */
