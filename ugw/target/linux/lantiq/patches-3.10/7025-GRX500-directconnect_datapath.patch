# HG changeset patch
# Parent f1bd4d43b8d80ff481b71979f09d1d6b842621bf

diff --git a/drivers/net/ethernet/lantiq/Kconfig b/drivers/net/ethernet/lantiq/Kconfig
--- a/drivers/net/ethernet/lantiq/Kconfig
+++ b/drivers/net/ethernet/lantiq/Kconfig
@@ -64,5 +64,6 @@ source "drivers/net/ethernet/lantiq/swit
 source "drivers/net/ethernet/lantiq/tmu/Kconfig"
 source "drivers/net/ethernet/lantiq/cbm/Kconfig"
 source "drivers/net/ethernet/lantiq/vrx318/Kconfig"
+source "drivers/net/ethernet/lantiq/directconnect_dp/Kconfig"
 
 endif # NET_VENDOR_LANTIQ
diff --git a/drivers/net/ethernet/lantiq/Makefile b/drivers/net/ethernet/lantiq/Makefile
--- a/drivers/net/ethernet/lantiq/Makefile
+++ b/drivers/net/ethernet/lantiq/Makefile
@@ -6,3 +6,4 @@ obj-$(CONFIG_LTQ_CBM) += cbm/
 obj-$(CONFIG_LTQ_ETH_XRX500) += ltq_eth_drv_xrx500.o
 obj-$(CONFIG_LTQ_TOE_DRIVER) += ltq_toe_drv.o
 obj-$(CONFIG_VRX318_DATAPATH) += vrx318/
+obj-$(CONFIG_LTQ_DIRECTCONNECT_DP) += directconnect_dp/
diff --git a/drivers/net/ethernet/lantiq/directconnect_dp/Kconfig b/drivers/net/ethernet/lantiq/directconnect_dp/Kconfig
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/directconnect_dp/Kconfig
@@ -0,0 +1,19 @@
+#
+# DirectConnect Datapath Driver
+#
+config LTQ_DIRECTCONNECT_DP
+	tristate "Lantiq DirectConnect Datapath driver for XRX500 series"	
+	default n
+	depends on LANTIQ && SOC_GRX500 && LTQ_DATAPATH && LTQ_HWMCPY
+	---help---
+	  Lantiq DirectConnect Datapath driver for XRX500 series. 
+
+config LTQ_DIRECTCONNECT_DP_DBG
+	bool "Datapath Debug Tool"
+	default y
+	depends on LTQ_DIRECTCONNECT_DP
+	---help---
+	  Directconnect Datapath Debug Tool is used to provide simple debug proc tool
+	  Each flag can be enabled/disabled easily
+	  Once this flag is enabled, the debugging information will be printed out
+	  otherwise, no debugging information for this flag will be printed
diff --git a/drivers/net/ethernet/lantiq/directconnect_dp/Makefile b/drivers/net/ethernet/lantiq/directconnect_dp/Makefile
new file mode 100755
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/directconnect_dp/Makefile
@@ -0,0 +1,6 @@
+obj-$(CONFIG_LTQ_DIRECTCONNECT_DP) = ltq_directconnect_datapath.o
+ltq_directconnect_datapath-objs = directconnect_dp_api.o
+ltq_directconnect_datapath-objs += directconnect_dp_pmac.o
+ltq_directconnect_datapath-objs += directconnect_dp_wave500_api.o
+ltq_directconnect_datapath-objs += directconnect_dp_wave500_sta.o
+ltq_directconnect_datapath-objs += directconnect_dp_proc.o
diff --git a/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp.h b/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp.h
@@ -0,0 +1,152 @@
+#ifndef _DIRECTCONNECT_DP_H_
+#define _DIRECTCONNECT_DP_H_
+
+#include <net/ltq_wave500_dp_api.h>
+
+#define DC_DP_MAX_SUBIF_PER_DEV 16
+#if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE
+#define DC_DP_MAX_DEV_NUM       4
+#else /* #if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE */
+#define DC_DP_MAX_DEV_NUM       1
+#endif /* #else */
+
+#define DC_DP_LOCK    spin_lock_bh
+#define DC_DP_UNLOCK  spin_unlock_bh
+
+#define DC_DP_VAPID_OFFSET		8
+#define DC_DP_VAPID_MASK		0xF
+#define DC_DP_STAID_OFFSET		0
+#define DC_DP_STAID_MASK		0xFF
+
+#define DC_WIFI_CLASS_MASK		0x7
+
+#define DC_DP_DBG_FLAG_DBG					0x1
+#define DC_DP_DBG_FLAG_DUMP_RX_DATA			0x10
+#define DC_DP_DBG_FLAG_DUMP_RX_DESCRIPTOR	0x20
+#define DC_DP_DBG_FLAG_DUMP_RX_PMAC			0x40
+#define DC_DP_DBG_FLAG_DUMP_RX  (DC_DP_DBG_FLAG_DUMP_RX_DATA |\
+			      DC_DP_DBG_FLAG_DUMP_RX_DESCRIPTOR |\
+			      DC_DP_DBG_FLAG_DUMP_RX_PMAC)
+#define DC_DP_DBG_FLAG_DUMP_TX_DATA			0x100
+#define DC_DP_DBG_FLAG_DUMP_TX_DESCRIPTOR	0x200
+#define DC_DP_DBG_FLAG_DUMP_TX_PMAC			0x400
+#define DC_DP_DBG_FLAG_DUMP_TX  (DC_DP_DBG_FLAG_DUMP_TX_DATA |\
+			      DC_DP_DBG_FLAG_DUMP_TX_DESCRIPTOR |\
+			      DC_DP_DBG_FLAG_DUMP_TX_PMAC)
+#define DC_DP_DBG_FLAG_ERR					0x10000000
+
+#define DC_DP_ERROR(fmt, args...) pr_err("DC DP [%s:%d] " fmt, __func__, __LINE__, ##args)
+
+			//if (unlikely((g_dc_dp_dbg_flag & flags))) {
+#if defined(CONFIG_LTQ_DIRECTCONNECT_DP_DBG) && CONFIG_LTQ_DIRECTCONNECT_DP_DBG
+	#define DC_DP_DEBUG(flags, fmt, args...) \
+		do { \
+			if ((g_dc_dp_dbg_flag & flags)) { \
+				pr_info("DC DP [%s:%d] " fmt, __func__, __LINE__, ##args); \
+			} \
+		} while (0)
+#else /* #if defined(CONFIG_LTQ_DIRECTCONNECT_DP_DBG) && CONFIG_LTQ_DIRECTCONNECT_DP_DBG */
+	#define DC_DP_DBG(level, fmt, args...)
+#endif /* #else */
+
+#if 0
+/*! 
+   \brief Macro that specifies network interface data structure
+ */
+typedef struct net_device NETIF;
+#endif
+
+#define STA_HASH_BITS 4
+#define STA_HASH_SIZE (1 << STA_HASH_BITS)
+
+#define DC_DP_UMT_PERIOD_DEFAULT     200 /* in micro second */
+
+#define MIN(a, b) (((a) < (b)) ? (a) : (b))
+
+/*! Station detail information */
+typedef struct dc_dp_priv_sta_entry {
+	struct hlist_node hlist;
+	struct rcu_head rcu;
+	uint8_t mac_addr[ETH_ALEN];
+	uint8_t sta_id;
+	struct net_device *netif;
+} dc_dp_priv_sta_entry_t;
+
+typedef struct dc_dp_priv_sta_info {
+	spinlock_t sta_hash_lock;
+	struct hlist_head sta_hash[STA_HASH_SIZE];
+} dc_dp_priv_sta_info_t;
+
+/*! Sub interface detail information */
+typedef struct dc_dp_priv_subif_info {
+	int32_t flags;
+#define DC_DP_SUBIF_FREE       0x0
+#define DC_DP_SUBIF_REGISTERED 0x1
+	uint32_t subif:15;
+	struct net_device  *netif;   /*! pointer to  net_device*/
+	char device_name[IFNAMSIZ];  /*! devide name, like wlan0, */
+} dc_dp_priv_subif_info_t;
+
+typedef struct dc_dp_priv_dev_info {
+	int32_t flags;	/*! port flags */
+#define DC_DP_DEV_FREE             0x0
+#define DC_DP_DEV_PORT_ALLOCATED   0x1
+#define DC_DP_DEV_REGISTERED       0x2
+#define DC_DP_DEV_SUBIF_REGISTERED 0x3
+	int32_t alloc_flags;       /* the flags saved when calling dc_dp_alloc_port */
+	struct module *owner;
+	struct net_device *dev;
+	uint32_t dev_port;
+	int32_t port_id;
+	int32_t cbm_pid;
+	int32_t umt_id;
+	int32_t umt_period;
+	dc_dp_cb_t cb;         /*! Callback Pointer to DIRECTPATH_CB */
+	uint32_t num_subif;
+	dc_dp_priv_subif_info_t subif_info[DC_DP_MAX_SUBIF_PER_DEV];
+	uint32_t dma_ch;
+
+	/* DMA1-TX ring buffer information */
+	uint32_t num_bufpools;
+    dc_dp_buf_pool_t *virt_buflist_base;
+#ifndef SWAS_3_8
+	void *buflist_virt_base;
+#endif /* #ifndef SWAS_3_8 */
+
+	/* WMM map information */
+	uint8_t prio2wmm[DC_DP_MAX_WIFI_CLASS];
+	uint8_t class2prio[16];
+} dc_dp_priv_dev_info_t;
+
+/* Extern variables */
+extern spinlock_t g_dc_dp_lock;
+extern dc_dp_priv_dev_info_t g_priv_info[DC_DP_MAX_DEV_NUM];
+extern uint32_t g_dc_dp_dbg_flag;
+extern dc_dp_priv_sta_info_t g_sta_info;
+extern int32_t g_size_tx_buffers;
+
+/* Extern functions */
+extern int32_t
+_dc_dp_register_dev_private(struct module *owner, uint32_t port_id,
+							struct net_device *dev, dc_dp_cb_t *datapathcb,
+							uint32_t num_bufs_req, void *umt_base, int32_t umt_len,
+							dc_dp_res_t *resources, uint32_t flags);
+#if IS_ENABLED(CONFIG_LTQ_PPA_API)
+extern int ppa_br_fdb_delete(struct net_device *dev, const unsigned char *addr);
+#endif /* #if IS_ENABLED(CONFIG_LTQ_PPA_API) */
+
+extern int32_t _dc_dp_gsw_pmac_init(int32_t port_id, int32_t dma_cid);
+
+int32_t dc_dp_sta_info_init(void);
+void dc_dp_sta_info_exit(void);
+dc_dp_priv_sta_entry_t *_dc_dp_find_sta_entry_by_macaddr(const uint8_t *macaddr);
+int32_t _dc_dp_find_staid_by_macaddr_rcu(const uint8_t *macaddr, uint32_t *staid);
+dc_dp_priv_sta_entry_t *_dc_dp_add_sta_entry(struct net_device *dev,
+								const uint8_t *macaddr, const uint32_t sta_id);
+void _dc_dp_delete_sta_entry(dc_dp_priv_sta_entry_t *sta_entry);
+
+int32_t dc_dp_proc_init(void);
+void dc_dp_proc_exit(void);
+
+
+#endif /* _DIRECTCONNECT_DP_H_ */
diff --git a/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp_api.c b/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp_api.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp_api.c
@@ -0,0 +1,1608 @@
+/* Includes */
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/jhash.h>
+#include <linux/interrupt.h>
+
+#include <lantiq_dmax.h>
+#include <net/lantiq_cbm.h>
+#include <net/lantiq_cbm_api.h>
+#include <linux/ltq_hwmcpy.h>
+#if IS_ENABLED(CONFIG_LTQ_PPA_API)
+#include <net/ppa_api.h>
+#endif /* #if IS_ENABLED(CONFIG_LTQ_PPA_API) */
+
+#include "directconnect_dp.h"
+
+/* Defines */
+#define DRV_MODULE_NAME             "ltq_directconnect_datapath"
+#define DRV_MODULE_VERSION          "1.3.1"
+
+#define NEED_PMAC_HDR_REMOVAL 		1
+
+/* Local variables */
+spinlock_t g_dc_dp_lock;
+static int32_t g_dc_dp_init_ok = 0;
+uint32_t g_dc_dp_dbg_flag = 0x1;
+
+int32_t g_size_tx_buffers = DC_DP_DMA_BUF_SIZE_DEFAULT;
+dc_dp_priv_dev_info_t g_priv_info[DC_DP_MAX_DEV_NUM];
+
+/* Function prototypes */
+/* Callbacks */
+#if NEED_PMAC_HDR_REMOVAL
+static int32_t
+dc_dp_rx_cb(struct net_device *rxif, struct net_device *txif,
+				 struct sk_buff *skb, int32_t len);
+#endif /* #if NEED_PMAC_HDR_REMOVAL */
+static int32_t
+dc_dp_check_if_netif_fastpath_cb(struct net_device *netif, char *ifname, uint32_t flags);
+static int32_t
+dc_dp_get_netif_subifid_cb(struct net_device *netif, struct sk_buff *skb,
+								void *subif_data, uint8_t dst_mac[MAX_ETH_ALEN],
+								dp_subif_t *subif, uint32_t flags);
+#if IS_ENABLED(CONFIG_LTQ_PPA_API)
+static int32_t
+dc_dp_qos_class2prio_cb(int32_t port_id, struct net_device *netif, uint8_t *class2prio);
+#endif /* #if IS_ENABLED(CONFIG_LTQ_PPA_API) */
+
+/* Local */
+static int32_t
+_dc_dp_alloc_buf(int32_t dev_idx, uint32_t num_bufs_req, int32_t *num_bufpools, dc_dp_buf_pool_t **buflist);
+static void _dc_dp_free_buf(int32_t dev_idx);
+static int32_t _dc_dp_setup_dma(uint32_t chan, uint32_t desc_num);
+static void _dc_dp_cleanup_dma(uint32_t chan);
+
+static inline int32_t
+_dc_dp_get_dev_idx_by_module_port(struct module *owner, int32_t port_id);
+static int32_t _dc_dp_get_idx_via_dev_private(struct net_device *dev);
+static int32_t _dc_dp_get_idx_via_ifname_private(char *ifname);
+static inline int32_t _dc_dp_get_dev_idx_by_port(int32_t port_id);
+#if defined(CONFIG_LTQ_DIRECTCONNECT_DP_DBG) && CONFIG_LTQ_DIRECTCONNECT_DP_DBG
+static void _dc_dp_dump_raw_data(char *buf, int len, char *prefix_str);
+static void _dc_dp_dump_rx_pmac(struct pmac_rx_hdr *pmac);
+#endif /* #if defined(CONFIG_LTQ_DIRECTCONNECT_DP_DBG) && CONFIG_LTQ_DIRECTCONNECT_DP_DBG */
+static inline uint8_t
+_dc_dp_get_class2wmm(int32_t dev_idx, uint8_t class, bool is_class);
+
+/* Extern */
+extern void mcast_helper_register_module(struct net_device *dev, struct module *modName,
+										 char *addl_name, dc_dp_mcast_callback_fn_t cb, unsigned int flags);
+
+/*
+ * ========================================================================
+ * Local Interface API
+ * ========================================================================
+ */
+
+static int32_t
+_dc_dp_alloc_buf(int32_t dev_idx, uint32_t num_bufs_req, int32_t *num_bufpools, dc_dp_buf_pool_t **buflist)
+{
+	int32_t i;
+	uint32_t order;
+	uint32_t max_buf_pool_sz;
+	uint32_t max_buf_pool_num;
+	uint32_t max_bufs_req_sz;
+	size_t virt_buflist_sz;
+	size_t phys_buflist_sz;
+	dc_dp_buf_pool_t *virt_buflist_base = NULL;
+	dc_dp_buf_pool_t *phys_buflist_base = NULL;
+	uint32_t num_buf_req_rem;
+	uint32_t tmp_num_bufs_req;
+	uint32_t tmp_buf_pool_sz;
+	uint8_t *buf_addr_base = NULL;
+
+	if (num_bufs_req <= 0) {
+		return -1;
+	}
+
+	max_buf_pool_sz = 0x400000; //4MB : (2 ^ (MAX_ORDER - 1)) * PAGE_SIZE;
+	max_buf_pool_num = 2048; //(max_buf_pool_sz / g_size_tx_buffers);
+	max_bufs_req_sz = num_bufs_req * g_size_tx_buffers;
+
+	*num_bufpools = (num_bufs_req + (max_buf_pool_num - 1)) / max_buf_pool_num;
+
+	virt_buflist_sz = (*num_bufpools * sizeof(dc_dp_buf_pool_t)); /* virt buflist size */
+	phys_buflist_sz = virt_buflist_sz; /* phys buflist size */
+
+	/* Allocate Tx buffers */
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Allocating %d DMA1-Tx buffer lists.\n", *num_bufpools);
+	virt_buflist_base = (dc_dp_buf_pool_t *) kmalloc((virt_buflist_sz + phys_buflist_sz), GFP_KERNEL);
+	if (!virt_buflist_base) {
+		DC_DP_ERROR("failed to allocate %d buffer lists!!!\n", *num_bufpools);
+		return -ENOMEM;
+	}
+	memset((void *)virt_buflist_base, 0, (virt_buflist_sz + phys_buflist_sz));
+
+	g_priv_info[dev_idx].num_bufpools = *num_bufpools;
+	g_priv_info[dev_idx].virt_buflist_base = (void *)virt_buflist_base;
+
+	phys_buflist_base = (dc_dp_buf_pool_t *)((uint8_t *)virt_buflist_base + virt_buflist_sz);
+	*buflist = phys_buflist_base;
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "buflist=0x%p.\n", *buflist);
+
+	num_buf_req_rem = num_bufs_req;
+	for (i = 0; i < *num_bufpools; i++) {
+		tmp_num_bufs_req = MIN(num_buf_req_rem, max_buf_pool_num);
+		tmp_buf_pool_sz = tmp_num_bufs_req * g_size_tx_buffers;
+		order = get_order(tmp_buf_pool_sz);
+
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "allocating pool %d of size %d KB.\n",
+					(i + 1), (tmp_buf_pool_sz >> 10));
+		buf_addr_base = (uint8_t *)__get_free_pages(GFP_KERNEL, order);
+		if (!buf_addr_base) {
+			DC_DP_ERROR("failed to allocate pool %d of size %d bytes!!!\n",
+							(i + 1), tmp_buf_pool_sz);
+			goto err_out_free_buf;
+		}
+
+		/* Virtual buffer pool */
+		g_priv_info[dev_idx].virt_buflist_base[i].pool = (void *)buf_addr_base;
+		g_priv_info[dev_idx].virt_buflist_base[i].size = tmp_buf_pool_sz;
+
+		/* Physical buffer pool */
+		phys_buflist_base[i].pool = (void *)virt_to_phys(buf_addr_base);
+		phys_buflist_base[i].size = tmp_buf_pool_sz;
+
+		num_buf_req_rem -= tmp_num_bufs_req;
+	}
+
+	return 0;
+
+err_out_free_buf:
+	_dc_dp_free_buf(dev_idx);
+
+	return -ENOMEM;
+}
+
+static void
+_dc_dp_free_buf(int32_t dev_idx)
+{
+	int32_t i;
+	uint32_t order;
+
+	/* De-allocate Tx buffer pool */
+	for (i = 0; i < g_priv_info[dev_idx].num_bufpools; i++) {
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "De-allocating pool %d (0x%p) of size %d bytes.\n",
+						(i + 1), g_priv_info[dev_idx].virt_buflist_base[i].pool, g_priv_info[dev_idx].virt_buflist_base[i].size);
+		if (g_priv_info[dev_idx].virt_buflist_base[i].pool) {
+   			order = get_order(g_priv_info[dev_idx].virt_buflist_base[i].size);
+			free_pages((unsigned long)g_priv_info[dev_idx].virt_buflist_base[i].pool, order);
+			g_priv_info[dev_idx].virt_buflist_base[i].pool = NULL;
+			g_priv_info[dev_idx].virt_buflist_base[i].size = 0;
+		}
+	}
+
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "De-allocating %d buffer lists.\n", g_priv_info[dev_idx].num_bufpools);
+	if (g_priv_info[dev_idx].virt_buflist_base) {
+		kfree(g_priv_info[dev_idx].virt_buflist_base);
+		g_priv_info[dev_idx].virt_buflist_base = NULL;
+	}
+
+	g_priv_info[dev_idx].num_bufpools = 0;
+}
+
+static int32_t
+_dc_dp_setup_dma(uint32_t chan, uint32_t desc_num)
+{
+	int32_t ret;
+
+	/* Allocate DMA1-TX DMA channel */
+	ret = ltq_request_dma(chan, "dma1 tx wlan");
+	if (ret) {
+		DC_DP_ERROR("failed to allocate DMA1-TX DMA channel 0x%x!!!\n", chan);
+		return ret;
+	}
+
+	/* Initialize DMA1-TX DMA channel descriptors */
+	ret = ltq_dma_chan_desc_alloc(chan, desc_num);
+	if (ret) {
+		DC_DP_ERROR("failed to allocate %d descriptors for DMA1-TX DMA channel 0x%x!!!\n", desc_num, chan);
+		ltq_free_dma(chan);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void
+_dc_dp_cleanup_dma(uint32_t chan)
+{
+	/* Free the DMA1-TX DMA channel descriptors */
+	if (ltq_dma_chan_desc_free(chan)) {
+		DC_DP_ERROR("failed to free descriptors for DMA1-TX DMA channel 0x%x!!!\n", chan);
+	}
+
+	/* Free DMA1-TX DMA channel */
+	if (ltq_free_dma(chan)) {
+		DC_DP_ERROR("failed to free DMA1-TX DMA channel 0x%x!!!\n", chan);
+	}
+}
+
+static inline int32_t
+_dc_dp_get_dev_idx_by_module_port(struct module *owner, int32_t port_id)
+{
+	int32_t i;
+
+	for (i = 0; i < DC_DP_MAX_DEV_NUM; i++) {
+		if (g_priv_info[i].flags == DC_DP_DEV_FREE)
+			continue;
+
+		if (g_priv_info[i].owner == owner &&
+			g_priv_info[i].port_id == port_id) {
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+static int32_t
+_dc_dp_get_idx_via_dev_private(struct net_device *dev)
+{
+	int32_t i, j;
+
+	for (i = 0; i < DC_DP_MAX_DEV_NUM; i++) {
+		if (g_priv_info[i].flags != DC_DP_DEV_SUBIF_REGISTERED)
+			continue;
+
+		for (j = 0; j < DC_DP_MAX_SUBIF_PER_DEV; j++) {
+			if (g_priv_info[i].subif_info[j].flags == DC_DP_SUBIF_FREE)
+				continue;
+
+			if (g_priv_info[i].subif_info[j].netif == dev) {
+				return i;
+			}
+		}
+	}
+
+	return DP_FAILURE;
+}
+
+static int32_t
+_dc_dp_get_idx_via_ifname_private(char *ifname)
+{
+	int32_t i, j;
+
+	for (i = 0; i < DC_DP_MAX_DEV_NUM; i++) {
+		if (g_priv_info[i].flags != DC_DP_DEV_SUBIF_REGISTERED)
+			continue;
+
+		for (j = 0; j < DC_DP_MAX_SUBIF_PER_DEV; j++) {
+			if (g_priv_info[i].subif_info[j].flags == DC_DP_SUBIF_FREE)
+				continue;
+
+			if (!strncmp(g_priv_info[i].subif_info[j].device_name, ifname, IFNAMSIZ)) {
+				return i;
+			}
+		}
+	}
+
+	return DP_FAILURE;
+}
+
+static inline int32_t
+_dc_dp_get_dev_idx_by_port(int32_t port_id)
+{
+	int32_t i;
+
+	for (i = 0; i < DC_DP_MAX_DEV_NUM; i++) {
+		if (g_priv_info[i].flags == DC_DP_DEV_FREE)
+			continue;
+
+		if (g_priv_info[i].port_id == port_id) {
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+#if defined(CONFIG_LTQ_DIRECTCONNECT_DP_DBG) && CONFIG_LTQ_DIRECTCONNECT_DP_DBG
+static void
+_dc_dp_dump_raw_data(char *buf, int len, char *prefix_str) 
+{
+	int i;
+	int r;
+	int line_num = 32;
+	unsigned char *p = (unsigned char *)buf;
+
+	if (!p) {
+		pr_err("[%s:%d] p NULL ?\n", __func__, __LINE__);
+		return ;
+	}
+
+	printk("%s in hex (len = %d) at 0x%p\n", prefix_str ? (char *)prefix_str : "Data", len, p);
+	for (i = 0; i < len; i++) {
+		r = i % line_num;
+		if (r== 0)
+			printk(" %04d: ", i);
+		else if (r == (line_num/2))
+			printk(" "); /*inser seperator*/
+		printk("%02x ", p[i]);
+		if (r == (line_num - 1))
+			printk("\n"); /*insert new line */
+	}
+	printk("\n");
+}
+
+static void
+_dc_dp_dump_rx_pmac(struct pmac_rx_hdr *pmac)
+{
+	int i;
+	unsigned char *p = (char *)pmac;
+
+	if (!pmac) {
+		pr_err("dump_rx_pmac pmac NULL ??\n");
+		return ;
+	}
+	
+	pr_info("PMAC at 0x%p: ", p);
+	for (i = 0; i < 8; i++)
+		pr_info("0x%02x ", p[i]);
+	pr_info("\n");
+	
+	/*byte 0 */
+	pr_info("  byte 0:res=%d ver_done=%d ip_offset=%d\n", pmac->res1,
+	       pmac->ver_done, pmac->ip_offset);
+	/*byte 1 */
+	pr_info("  byte 1:tcp_h_offset=%d tcp_type=%d\n", pmac->tcp_h_offset,
+	       pmac->tcp_type);
+	/*byte 2 */
+	pr_info("  byte 2:ppid=%d class=%d\n", pmac->sppid, pmac->class);
+	/*byte 3 */
+	pr_info("  byte 3:res=%d pkt_type=%d\n", pmac->res2, pmac->pkt_type);
+	/*byte 4 */
+	pr_info("  byte 4:res=%d redirect=%d res2=%d src_sub_inf_id=%d\n",
+	       pmac->res3, pmac->redirect, pmac->res4, pmac->src_sub_inf_id);
+	/*byte 5 */
+	pr_info("  byte 5:src_sub_inf_id2=%d\n", pmac->src_sub_inf_id2);
+	/*byte 6 */
+	pr_info("  byte 6:port_map=%d\n", pmac->port_map);
+	/*byte 7 */
+	pr_info("  byte 7:port_map2=%d\n", pmac->port_map2);
+}
+#endif /* #if defined(CONFIG_LTQ_DIRECTCONNECT_DP_DBG) && CONFIG_LTQ_DIRECTCONNECT_DP_DBG */
+
+static inline uint8_t
+_dc_dp_get_class2wmm(int32_t dev_idx, uint8_t class, bool is_class)
+{
+	uint8_t wmm;
+	uint8_t prio;
+
+	if (is_class) {
+		class = (class & 0x0F);
+		prio = g_priv_info[dev_idx].class2prio[class];
+	} else {
+		prio = class;
+	}
+
+	prio = (prio & DC_WIFI_CLASS_MASK);
+	wmm = g_priv_info[dev_idx].prio2wmm[prio];
+
+	return wmm;
+}
+
+/*
+ * ========================================================================
+ * Direct Connect Driver Interface API
+ * ========================================================================
+ */
+int32_t
+dc_dp_alloc_port(struct module *owner, uint32_t dev_port,
+				 struct net_device *dev, int32_t port_id, uint32_t flags)
+{
+	int32_t ret;
+	int32_t i;
+	int32_t dev_idx;
+	int32_t ep_id;
+	uint32_t cbm_pid = 0;
+	uint32_t dma_ctrlid = 0;
+	uint32_t dma_cid = 0;
+	uint32_t umt_id = 0;
+
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "owner=%p, dev_port=%u, dev=%p, port_id=%d, flags=0x%08X\n",
+					owner, dev_port, dev, port_id, flags);
+
+	/* Validate input arguments */
+	if (!owner) {
+		DC_DP_ERROR("failed to allocate/de-allocate port as owner=%p!!!\n", owner);
+		return DP_FAILURE;
+	}
+
+	/* De-register */
+	if (flags & DP_F_DEREGISTER) {
+		DC_DP_LOCK(&g_dc_dp_lock);
+
+		/* Find the registered device index */
+		dev_idx = _dc_dp_get_dev_idx_by_module_port(owner, port_id);
+		if (dev_idx < 0) {
+			DC_DP_ERROR("failed to de-allocate port_id=%d as port is not allocated yet!!!\n", port_id);
+			DC_DP_UNLOCK(&g_dc_dp_lock);
+			return DP_FAILURE;
+		}
+
+		if (g_priv_info[dev_idx].flags != DC_DP_DEV_PORT_ALLOCATED) {
+			DC_DP_ERROR("failed to de-allocate port_id=%d as it is in unknown state!!!\n", port_id);
+			DC_DP_UNLOCK(&g_dc_dp_lock);
+			return DP_FAILURE;
+		}
+
+#if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE
+		/* Release UMT port */
+		ret = ltq_umt_release(g_priv_info[dev_idx].umt_id, port_id);
+		if (ret < 0) {
+			DC_DP_ERROR("failed to release umt_id=%d, port_id=%d!!!\n", g_priv_info[dev_idx].umt_id, port_id);
+			DC_DP_UNLOCK(&g_dc_dp_lock);
+			return DP_FAILURE;
+		}
+#endif /* #if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE */
+
+		ret = dp_alloc_port(owner, dev, dev_port, port_id, NULL, flags);
+		if (ret != DP_SUCCESS) {
+		    DC_DP_ERROR("failed to de-allocate port_id=%d from datapath library/core!!!\n", port_id);
+			DC_DP_UNLOCK(&g_dc_dp_lock);
+			return DP_FAILURE;
+		}
+
+		memset(&g_priv_info[dev_idx], 0, sizeof(dc_dp_priv_dev_info_t));
+
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Success, returned %d\n", DP_SUCCESS);
+		return DP_SUCCESS;
+	}
+
+	DC_DP_LOCK(&g_dc_dp_lock);
+
+	/* Find a free device index */
+	for (i = 0; i < DC_DP_MAX_DEV_NUM; i++) {
+		if (g_priv_info[i].flags == DC_DP_DEV_FREE) {
+			break;
+		}
+	}
+
+	if (i >= DC_DP_MAX_DEV_NUM) {
+        DC_DP_ERROR("failed to allocate port as it reaches maximum directconnect device limit - %d!!!\n", DC_DP_MAX_DEV_NUM);
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+		return DP_FAILURE;
+	}
+	dev_idx = i;
+
+	ret = dp_alloc_port(owner, dev, dev_port, port_id, NULL, flags);
+	if (ret == DP_FAILURE) {
+		DC_DP_ERROR("failed to allocate port in datapath library/core!!!\n");
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+		return DP_FAILURE;
+	}
+	ep_id = ret;
+
+	ret = cbm_get_wlan_umt_pid(ep_id, &cbm_pid);
+	if (ret < 0) {
+		DC_DP_ERROR("failed to acquire CBM pid!!!\n");
+		goto err_out_free_port;
+	}
+
+#if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE
+	/* Request for UMT port */
+	ret = ltq_umt_request(ep_id, cbm_pid, &dma_ctrlid, &dma_cid, &umt_id);
+	if (ret < 0) {
+		DC_DP_ERROR("failed to allocate umt port for ep_id=%d, cbm_pid=%d!!!\n", ep_id, cbm_pid);
+		goto err_out_free_port;
+	}
+#else /* #if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE */
+	dma_ctrlid = DMA1TX;
+	dma_cid = DMA_CHANNEL_7;
+	umt_id = 0;
+#endif /* #else */
+
+	/* Configure GSWIP-R PMAC port */
+    if (_dc_dp_gsw_pmac_init(ep_id, dma_cid) < 0) {
+		DC_DP_ERROR("failed to configure GSWIP-R PMAC port %d!!!\n", ep_id);
+		goto err_out_release_umt;
+	}
+
+	memset(&g_priv_info[dev_idx], 0, sizeof(dc_dp_priv_dev_info_t));
+	g_priv_info[dev_idx].owner = owner;
+	g_priv_info[dev_idx].dev = dev;
+	g_priv_info[dev_idx].dev_port = dev_port;
+	g_priv_info[dev_idx].port_id = ep_id;
+	g_priv_info[dev_idx].cbm_pid = cbm_pid;
+	g_priv_info[dev_idx].dma_ch = _DMA_C(dma_ctrlid, DMA1TX_PORT, dma_cid);
+	g_priv_info[dev_idx].umt_id = umt_id;
+	g_priv_info[dev_idx].alloc_flags = flags;
+	g_priv_info[dev_idx].flags = DC_DP_DEV_PORT_ALLOCATED;
+
+	DC_DP_UNLOCK(&g_dc_dp_lock);
+
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Success, returned port_id=%d.\n", ep_id);
+	return ep_id;
+
+err_out_release_umt:
+#if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE
+	ltq_umt_release(umt_id, ep_id);
+#endif /* #if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE */
+
+err_out_free_port:
+	dp_alloc_port(owner, dev, dev_port, ep_id, NULL, DP_F_DEREGISTER);
+
+	DC_DP_UNLOCK(&g_dc_dp_lock);
+
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Failure, returned %d.\n", DP_FAILURE);
+	return DP_FAILURE;
+}
+EXPORT_SYMBOL(dc_dp_alloc_port);
+
+int32_t
+_dc_dp_register_dev_private(struct module *owner, uint32_t port_id,
+							struct net_device *dev, dc_dp_cb_t *datapathcb,
+							uint32_t num_bufs_req, void *umt_base, int32_t umt_len,
+							dc_dp_res_t *resources, uint32_t flags)
+{
+	int32_t ret;
+	int32_t i;
+	int32_t dev_idx;
+	dp_cb_t dp_cb = {0};
+	int32_t num_bufpools = 0;
+	dc_dp_buf_pool_t *buflist = NULL;
+	cbm_dq_port_res_t cbm_res = {0};
+
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "owner=%p, port_id=%u, dev=%p, datapathcb=%p, \
+					num_bufs_req=%d, umt_base=%p, umt_len=%d, resources=%p, flags=0x%08X\n",
+					owner, port_id, dev, datapathcb, num_bufs_req, umt_base, umt_len, resources, flags);
+
+	/* Find the device index */
+	dev_idx = _dc_dp_get_dev_idx_by_module_port(owner, port_id);
+	if (dev_idx < 0) {
+		DC_DP_ERROR("failed to register/de-register dev, as port_id=%d is not allocated yet!!!\n", port_id);
+		return DP_FAILURE;
+	}
+
+	/* De-register */
+	if (flags & DP_F_DEREGISTER) {
+		if (g_priv_info[dev_idx].flags < DC_DP_DEV_REGISTERED) {
+			DC_DP_ERROR("failed to de-register dev as port_id=%d is in unknown state!!!\n", port_id);
+			return DP_FAILURE;
+		}
+
+		if (g_priv_info[dev_idx].num_subif > 0) {
+			/* De-register subif from Datapath Library/Core, if any */
+			dp_subif_t subif_id = {0};
+			for (i = 0; i < DC_DP_MAX_SUBIF_PER_DEV; i++) {
+				if (g_priv_info[dev_idx].subif_info[i].flags == DC_DP_SUBIF_REGISTERED) {
+					subif_id.port_id = port_id;
+					subif_id.subif = g_priv_info[dev_idx].subif_info[i].subif;
+
+					ret = dp_register_subif(owner, dev, dev->name, &subif_id, flags);
+					if (ret != DP_SUCCESS) {
+						DC_DP_ERROR("failed to de-register subif=0x%x!!!\n", subif_id.subif);
+					}
+
+					memset(&g_priv_info[dev_idx].subif_info[i], 0, sizeof(dc_dp_priv_subif_info_t));
+					g_priv_info[dev_idx].num_subif--;
+				}
+			}
+
+#if IS_ENABLED(CONFIG_LTQ_PPA_API)
+			if (ppa_register_qos_class2prio_hook_fn) {
+				ret = ppa_register_qos_class2prio_hook_fn(port_id, dev, NULL, WMM_QOS_DEV_F_DREG);
+				if (ret) {
+					DC_DP_ERROR("failed to de-register class2prio callback from PPA!!!\n");
+				}
+			}
+#endif /* #if IS_ENABLED(CONFIG_LTQ_PPA_API) */
+
+			/* Disable DMA1-TX DMA channel */
+			ret = ltq_dma_chan_close(g_priv_info[dev_idx].dma_ch);
+			if (ret != DP_SUCCESS) {
+				DC_DP_ERROR("failed to close DMA channel 0x%x!!!\n", g_priv_info[dev_idx].dma_ch);
+			}
+
+			/* Disable UMT HW */
+			DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Disabling UMT HW.\n");
+#if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE
+			ret = ltq_umt_enable(g_priv_info[dev_idx].umt_id, port_id, 0);
+#else /* #if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE */
+			ret = ltq_umt_enable(0);
+#endif /* #else */
+
+			g_priv_info[dev_idx].flags = DC_DP_DEV_REGISTERED;
+		}
+
+		ret = dp_register_dev(owner, port_id, &dp_cb, flags);
+		if (ret != DP_SUCCESS) {
+			DC_DP_ERROR("failed to de-register device for the port_id %d!!!\n", port_id);
+		}
+
+		/* Cleanup DMA1-TX DMA Channel */
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "De-configuring DMA1-Tx channel 0x%x.\n",
+					g_priv_info[dev_idx].dma_ch);
+		_dc_dp_cleanup_dma(g_priv_info[dev_idx].dma_ch);
+
+		/* De-allocate Tx buffer pool */
+		_dc_dp_free_buf(dev_idx);
+
+		g_priv_info[dev_idx].flags = DC_DP_DEV_PORT_ALLOCATED;
+
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Success, returned %d.\n", DP_SUCCESS);
+		return DP_SUCCESS;
+	}
+
+	if (!datapathcb && !resources) {
+		DC_DP_ERROR("failed to register dev as datapathcb=%p, resources=%p!!!\n", datapathcb, resources);
+		return DP_FAILURE;
+	}
+
+	if (g_priv_info[dev_idx].flags != DC_DP_DEV_PORT_ALLOCATED) {
+		DC_DP_ERROR("failed to register dev as port_id=%d is in unknown state!!!\n", port_id);
+		return DP_FAILURE;
+	}
+
+	/* Datapath Library callback registration */
+#if NEED_PMAC_HDR_REMOVAL
+	dp_cb.rx_fn = dc_dp_rx_cb;
+#else /* #if NEED_PMAC_HDR_REMOVAL */
+	dp_cb.rx_fn = datapathcb->rx_fn;
+#endif /* #else */
+	dp_cb.stop_fn = datapathcb->stop_fn;
+	dp_cb.restart_fn = datapathcb->restart_fn;
+	dp_cb.get_subifid_fn = dc_dp_get_netif_subifid_cb;
+	dp_cb.reset_mib_fn = datapathcb->reset_mib_fn;
+	dp_cb.get_mib_fn = datapathcb->get_mib_fn;
+
+	ret = dp_register_dev(owner, port_id, &dp_cb, flags);
+	if (ret != DP_SUCCESS) {
+		DC_DP_ERROR("failed to register dev to Datapath Library/Core!!!\n");
+		return DP_FAILURE;
+	}
+
+	/* Allocate Tx buffers */
+	ret = _dc_dp_alloc_buf(dev_idx, num_bufs_req, &num_bufpools, &buflist);
+    if (ret) {
+		DC_DP_ERROR("failed to register dev as tx buffer allocation failure!!!\n");
+	    dp_register_dev(owner, port_id, &dp_cb, DP_F_DEREGISTER);
+		return DP_FAILURE;
+	}
+
+	resources->num_bufpools = num_bufpools;
+	resources->buflist = buflist;
+
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Configuring DMA1-Tx channel 0x%x.\n",
+				g_priv_info[dev_idx].dma_ch);
+	/* Configure DMA1-TX DMA Channel */
+	ret = _dc_dp_setup_dma(g_priv_info[dev_idx].dma_ch, num_bufs_req);
+	if (ret != DP_SUCCESS) {
+		DC_DP_ERROR("failed to configure DMA1-TX DMA channel 0x%x!!!\n",
+						g_priv_info[dev_idx].dma_ch);
+		goto err_out_free_buf;
+	}
+
+	/* Update returned 'resource' structure */
+	resources->num_dma_desc = num_bufs_req;
+	resources->dmatx_ring_base = (void *)ltq_dma_chan_get_desc_phys_base(g_priv_info[dev_idx].dma_ch);
+
+	/* UMT */
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Configuring UMT HW with dest address 0x%p.\n",
+				(uint32_t *)umt_base);
+#if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE
+	ret = ltq_umt_set_mode(g_priv_info[dev_idx].umt_id, port_id, 0, 3, (uint32_t)umt_base, DC_DP_UMT_PERIOD_DEFAULT, 0);
+#else /* #if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE */
+	ret = ltq_umt_set_mode(0, 3, (uint32_t)umt_base, DC_DP_UMT_PERIOD_DEFAULT, 0);
+#endif /* #else */
+	if (ret) {
+		DC_DP_ERROR("failed to configure UMT transfer!!!\n");
+		goto err_out_free_dma;
+	}
+
+	/* CBM Resources */
+	ret = cbm_dequeue_port_resources_get(port_id, &cbm_res, 0);
+	if (ret != CBM_OK) {
+		DC_DP_ERROR("failed to get CBM dequeue port resources for the port %d!!!", port_id);
+		goto err_out_free_dma;
+	}
+
+#if 0
+#if defined(CONFIG_LTQ_DIRECTCONNECT_DP_DBG) && CONFIG_LTQ_DIRECTCONNECT_DP_DBG
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "cbm_res.cbm_buf_free_base = 0x%p.\n", cbm_res.cbm_buf_free_base);
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "cbm_res.num_free_entries = %d.\n", cbm_res.num_free_entries);
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "cbm_res.num_deq_ports = %d.\n", cbm_res.num_deq_ports);
+#endif /* #if defined(CONFIG_LTQ_DIRECTCONNECT_DP_DBG) && CONFIG_LTQ_DIRECTCONNECT_DP_DBG */
+#endif
+
+	resources->cbm_buf_free_base = (void *)RPHYSADDR((uint32_t)cbm_res.cbm_buf_free_base);
+	resources->num_free_bufs = 32; // FIXME : cbm_res.num_free_entries;
+	if (cbm_res.num_deq_ports) {
+#if 0
+#if defined(CONFIG_LTQ_DIRECTCONNECT_DP_DBG) && CONFIG_LTQ_DIRECTCONNECT_DP_DBG
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "cbm_res.deq_info[0].port_no = %d.\n",
+					cbm_res.deq_info[0].port_no);
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "cbm_res.deq_info[0].cbm_dq_port_base = 0x%p.\n",
+					cbm_res.deq_info[0].cbm_dq_port_base);
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "cbm_res.deq_info[0].dma_tx_chan = %d.\n",
+					cbm_res.deq_info[0].dma_tx_chan);
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "cbm_res.deq_info[0].num_desc = %d.\n",
+					cbm_res.deq_info[0].num_desc);
+#endif /* #if defined(CONFIG_LTQ_DIRECTCONNECT_DP_DBG) && CONFIG_LTQ_DIRECTCONNECT_DP_DBG */
+#endif
+
+		resources->cbm_dequeue_base = (void *)RPHYSADDR((uint32_t)cbm_res.deq_info[0].cbm_dq_port_base);
+		resources->num_dequeue_bufs = cbm_res.deq_info[0].num_desc;
+
+		kfree(cbm_res.deq_info);
+	}
+
+#if IS_ENABLED(CONFIG_LTQ_PPA_API)
+	if (ppa_register_qos_class2prio_hook_fn) {
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+		ret = ppa_register_qos_class2prio_hook_fn(port_id, dev, dc_dp_qos_class2prio_cb, WMM_QOS_DEV_F_REG);
+		if (ret) {
+			DC_DP_ERROR("failed to register class2prio callback to PPA!!!\n");
+			DC_DP_LOCK(&g_dc_dp_lock);
+			goto err_out_free_dma;
+		}
+		DC_DP_LOCK(&g_dc_dp_lock);
+	} else {
+		for (i = 0; i < 16; i++) {
+			g_priv_info[dev_idx].class2prio[i] = (i >> 1);
+		}
+	}
+#endif /* #if IS_ENABLED(CONFIG_LTQ_PPA_API) */
+
+	/* Keep the callback registered by WLAN driver */
+	g_priv_info[dev_idx].cb = *datapathcb;
+	g_priv_info[dev_idx].umt_period = DC_DP_UMT_PERIOD_DEFAULT;
+	g_priv_info[dev_idx].flags = DC_DP_DEV_REGISTERED;
+
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Success, returned %d.\n", ret);
+	return ret;
+
+err_out_free_dma:
+	/* Cleanup DMA Tx Channel */
+	_dc_dp_cleanup_dma(g_priv_info[dev_idx].dma_ch);
+
+err_out_free_buf:
+	/* De-allocate Tx buffers */
+	_dc_dp_free_buf(dev_idx);
+
+	dp_register_dev(owner, port_id, &dp_cb, DP_F_DEREGISTER);
+
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Failure, returned %d.\n", DP_FAILURE);
+	return DP_FAILURE;
+}
+
+int32_t
+dc_dp_register_dev(struct module *owner, uint32_t port_id,
+				   struct net_device *dev, dc_dp_cb_t *datapathcb,
+				   uint32_t num_bufs_req, void *umt_base, int32_t umt_len,
+				   dc_dp_res_t *resources, uint32_t flags)
+{
+	int32_t ret;
+
+	DC_DP_LOCK(&g_dc_dp_lock);
+	ret = _dc_dp_register_dev_private(owner, port_id, dev, datapathcb, num_bufs_req, umt_base, umt_len, resources, flags);
+	DC_DP_UNLOCK(&g_dc_dp_lock);
+
+#if defined(CONFIG_LTQ_DIRECTCONNECT_DP_DBG) && CONFIG_LTQ_DIRECTCONNECT_DP_DBG
+	if ( !(flags & DP_F_DEREGISTER) ) {
+		int32_t i;
+
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "resources->num_bufpools = %d\n", resources->num_bufpools);
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "resources->buflist = %p\n", resources->buflist);
+		for (i = 0; i < resources->num_bufpools; i++) {
+			DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Bufpool %d : pool = %p of size %d\n",
+							(i + 1), resources->buflist[i].pool, resources->buflist[i].size);
+		}
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "resources->num_dma_desc = %d\n", resources->num_dma_desc);
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "resources->dmatx_ring_base = 0x%p\n", resources->dmatx_ring_base);
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "resources->cbm_dequeue_base = 0x%p.\n", resources->cbm_dequeue_base);
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "resources->num_dequeue_bufs = %d.\n", resources->num_dequeue_bufs);
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "resources->cbm_buf_free_base = 0x%p.\n", resources->cbm_buf_free_base);
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "resources->num_free_bufs = %d.\n", resources->num_free_bufs);
+	}
+#endif /* #if defined(CONFIG_LTQ_DIRECTCONNECT_DP_DBG) && CONFIG_LTQ_DIRECTCONNECT_DP_DBG */
+
+	return ret;
+}
+EXPORT_SYMBOL(dc_dp_register_dev);
+
+int32_t
+dc_dp_register_subif(struct module *owner, struct net_device *dev,
+					 dp_subif_t *subif_id, uint32_t flags)
+{
+	int32_t ret;
+	int32_t dev_idx;
+	int32_t subif_idx;
+
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "owner=%p, dev=%p, subif_id=%p, flags=0x%08X\n",
+					owner, dev, subif_id, flags);
+
+	if (!owner) {
+		DC_DP_ERROR("failed to register/de-register subif as owner=%p!!!\n", owner);
+		return DP_FAILURE;
+	}
+
+	if (!dev || !subif_id) {
+		DC_DP_ERROR("failed to register/de-register subif as dev=%p or subif_id=%p!!!\n", dev, subif_id);
+		return DP_FAILURE;
+	}
+
+	DC_DP_LOCK(&g_dc_dp_lock);
+
+	/* Find the registered device index */
+	dev_idx = _dc_dp_get_dev_idx_by_module_port(owner, subif_id->port_id);
+	if (dev_idx < 0) {
+		DC_DP_ERROR("failed to register/de-register subif as port_id=%d is not allocated yet!!!\n", subif_id->port_id);
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+		return DP_FAILURE;
+	}
+
+	/* De-register */
+	if (flags & DP_F_DEREGISTER) {
+
+		if (g_priv_info[dev_idx].flags != DC_DP_DEV_SUBIF_REGISTERED) {
+		    DC_DP_ERROR("failed to de-register subif as port_id=%d is in unknown state!!!\n", subif_id->port_id);
+			DC_DP_UNLOCK(&g_dc_dp_lock);
+			return DP_FAILURE;
+		}
+
+		/* Find the registered subif index (for multiple vap) */
+		subif_idx = ((subif_id->subif >> DC_DP_VAPID_OFFSET) & DC_DP_VAPID_MASK);
+		if (g_priv_info[dev_idx].subif_info[subif_idx].flags != DC_DP_SUBIF_REGISTERED) {
+		    DC_DP_ERROR("failed to de-register subif as subif_id=%d is in unknown state!!!\n", subif_idx);
+			DC_DP_UNLOCK(&g_dc_dp_lock);
+			return DP_FAILURE;
+		}
+
+		/* De-register subif from Datapath Library/Core */
+		ret = dp_register_subif(owner, dev, dev->name, subif_id, flags);
+		if (ret != DP_SUCCESS) {
+		    DC_DP_ERROR("failed to de-register subif from Datapath Library/Core!!!\n");
+			DC_DP_UNLOCK(&g_dc_dp_lock);
+			return DP_FAILURE;
+		}
+
+		/* Reset private structure corresponding to the subif */
+		memset(&g_priv_info[dev_idx].subif_info[subif_idx], 0, sizeof(dc_dp_priv_subif_info_t));
+
+		g_priv_info[dev_idx].num_subif--;
+
+		/* For the last subif, disable DMA1-TX DMA channel */
+		if (g_priv_info[dev_idx].num_subif == 0) {
+			if (ltq_dma_chan_close(g_priv_info[dev_idx].dma_ch)) {
+				DC_DP_ERROR("failed to close dma1-tx dma channel 0x%x!!!\n", g_priv_info[dev_idx].dma_ch);
+			}
+
+			/* Disable UMT hw */
+			DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Disabling UMT.\n");
+#if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE
+			if (ltq_umt_enable(g_priv_info[dev_idx].umt_id, g_priv_info[dev_idx].port_id, 0)) {
+				DC_DP_ERROR("failed to disable umt_id=%d, port_id=%d!!!\n",
+								g_priv_info[dev_idx].umt_id, g_priv_info[dev_idx].port_id);
+			}
+#else /* #if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE */
+			if (ltq_umt_enable(0)) {
+				DC_DP_ERROR("failed to disable UMT!!!\n");
+			}
+#endif /* #else */
+
+			g_priv_info[dev_idx].flags = DC_DP_DEV_REGISTERED;
+		}
+
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Success, returned %d.\n", DP_SUCCESS);
+		return DP_SUCCESS;
+	}
+
+	if (g_priv_info[dev_idx].flags < DC_DP_DEV_REGISTERED) {
+		DC_DP_ERROR("failed to register subif as port_id=%d is in unknown state!!!\n", subif_id->port_id);
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+		return DP_FAILURE;
+	}
+
+	/* Register subif to Datapath Library/Core */
+	ret = dp_register_subif(owner, dev, dev->name, subif_id, flags);
+	if (ret != DP_SUCCESS) {
+		DC_DP_ERROR("failed to register subif to Datapath Library/Core!!!\n");
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+		return DP_FAILURE;
+	}
+
+	/* Initialize private structure with device and subif information */
+	subif_idx = ((subif_id->subif >> DC_DP_VAPID_OFFSET) & DC_DP_VAPID_MASK);
+	if (g_priv_info[dev_idx].subif_info[subif_idx].flags != DC_DP_SUBIF_FREE) {
+		DC_DP_ERROR("failed to find free subif entry for the subif_id=%d!!!\n", subif_idx);
+		goto err_out_deregister_subif;
+	}
+
+	/* For the first subif, enable DMA1-TX DMA channel */
+	if (g_priv_info[dev_idx].num_subif == 0) {
+		/* Enable UMT hw */
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Enabling UMT HW.\n");
+#if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE
+		ret = ltq_umt_enable(g_priv_info[dev_idx].umt_id, g_priv_info[dev_idx].port_id, 1);
+#else /* #if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE */
+		ret = ltq_umt_enable(1);
+#endif /* #else */
+		if (ret) {
+	        DC_DP_ERROR("failed to enable umt_id=%d, port_id=%d!!!\n",
+							g_priv_info[dev_idx].umt_id, g_priv_info[dev_idx].port_id);
+			goto err_out_deregister_subif;
+		}
+
+		/* Enable DMA1-TX DMA channel */
+		if (ltq_dma_chan_open(g_priv_info[dev_idx].dma_ch)) {
+			DC_DP_ERROR("failed to open dma1-tx dma channel=0x%x!!!\n", g_priv_info[dev_idx].dma_ch);
+			goto err_out_disable_umt;
+		}
+	}
+
+	g_priv_info[dev_idx].subif_info[subif_idx].flags = DC_DP_SUBIF_REGISTERED;
+	g_priv_info[dev_idx].subif_info[subif_idx].netif = dev;
+	g_priv_info[dev_idx].subif_info[subif_idx].subif = subif_id->subif;
+	strcpy(g_priv_info[dev_idx].subif_info[subif_idx].device_name, dev->name);
+
+	g_priv_info[dev_idx].flags = DC_DP_DEV_SUBIF_REGISTERED;
+	g_priv_info[dev_idx].num_subif++;
+
+	DC_DP_UNLOCK(&g_dc_dp_lock);
+
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Success, returned %d.\n", ret);
+	return ret;
+
+err_out_disable_umt:
+#if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE
+	ltq_umt_enable(g_priv_info[dev_idx].umt_id, g_priv_info[dev_idx].port_id, 0);
+#else /* #if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE */
+	ltq_umt_enable(0);
+#endif /* #else */
+
+err_out_deregister_subif:
+	dp_register_subif(owner, dev, dev->name, subif_id, DP_F_DEREGISTER);
+
+	DC_DP_UNLOCK(&g_dc_dp_lock);
+
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Failure, returned %d.\n", DP_FAILURE);
+	return DP_FAILURE;
+}
+EXPORT_SYMBOL(dc_dp_register_subif);
+
+int32_t
+dc_dp_xmit(struct net_device *rx_if, dp_subif_t *rx_subif,
+		   struct sk_buff *buf, int32_t len, uint32_t flags)
+{
+	int32_t ret;
+
+	if (!buf) {
+		DC_DP_ERROR("failed to xmit as buf=%p!!!", buf);
+		return DP_FAILURE;
+	}
+
+	/* Send it to Datapath library for transmit */
+	ret = dp_xmit(rx_if, rx_subif, buf, len, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(dc_dp_xmit);
+
+int32_t
+dc_dp_disconn_if(struct net_device *netif, dp_subif_t *subif_id,
+				 uint8_t mac_addr[MAX_ETH_ALEN], uint32_t flags)
+{
+	int32_t ret = DP_SUCCESS;
+
+#if IS_ENABLED(CONFIG_LTQ_PPA_API)
+	/* Remove all the sessions from PPA */
+	ret = ppa_hook_disconn_if_fn(netif, subif_id, mac_addr, flags);
+#endif /* #if IS_ENABLED(CONFIG_LTQ_PPA_API) */
+
+	return ret;
+}
+EXPORT_SYMBOL(dc_dp_disconn_if);
+
+/*
+ * ========================================================================
+ * Callbacks Registered to Datapath Library/Core
+ * ========================================================================
+ */
+#if NEED_PMAC_HDR_REMOVAL
+static int32_t
+dc_dp_rx_cb(struct net_device *rxif, struct net_device *txif,
+			struct sk_buff *skb, int32_t len)
+{
+	int32_t dev_idx;
+	struct pmac_rx_hdr *pmac;
+	dp_subif_t rx_subif = {0};
+
+    if (!skb) {
+        DC_DP_ERROR("failed to receive as skb=%p!!!\n", skb);
+        return -1;
+    }
+
+    if (!rxif) {
+        DC_DP_ERROR("failed to receive as rxif=%p!!!\n", rxif);
+		dev_kfree_skb_any(skb);
+        return -1;
+    }
+
+	pmac = (struct pmac_rx_hdr *)(skb->data);
+	rx_subif.port_id = pmac->sppid;
+	rx_subif.subif = (pmac->src_sub_inf_id << 8);
+	rx_subif.subif |= pmac->src_sub_inf_id2;
+
+	DC_DP_LOCK(&g_dc_dp_lock);
+#if defined(CONFIG_LTQ_DIRECTCONNECT_DP_DBG) && CONFIG_LTQ_DIRECTCONNECT_DP_DBG
+	if (g_dc_dp_dbg_flag & DC_DP_DBG_FLAG_DUMP_RX_PMAC)
+		_dc_dp_dump_rx_pmac(pmac);
+	if (g_dc_dp_dbg_flag & DC_DP_DBG_FLAG_DUMP_RX_DATA)
+		_dc_dp_dump_raw_data(skb->data, skb->len, "Recv Data");
+#endif /* #if defined(CONFIG_LTQ_DIRECTCONNECT_DP_DBG) && CONFIG_LTQ_DIRECTCONNECT_DP_DBG */
+	dev_idx = _dc_dp_get_dev_idx_by_port(rx_subif.port_id);
+	DC_DP_UNLOCK(&g_dc_dp_lock);
+	if (dev_idx < 0) {
+        DC_DP_ERROR("port_id=%d does not exist for the rxif=%s!!!\n",
+						rx_subif.port_id, rxif->name);
+		dev_kfree_skb_any(skb);
+		return -1;
+	}
+
+	len -= sizeof(struct pmac_rx_hdr);
+	skb_pull(skb, sizeof(struct pmac_rx_hdr));
+	if (g_priv_info[dev_idx].cb.rx_fn) {
+		g_priv_info[dev_idx].cb.rx_fn(rxif, txif, &rx_subif, skb, skb->len);
+	} else {
+        DC_DP_ERROR("rx_fn callback is not registered on rxif->name=%s!!!\n",
+						rxif->name);
+		dev_kfree_skb_any(skb);
+		return -1;
+	}
+
+	return 0;
+}
+#endif /* #if NEED_PMAC_HDR_REMOVAL */
+
+static int32_t
+dc_dp_check_if_netif_fastpath_cb(struct net_device *netif, char *ifname, uint32_t flags)
+{
+	int32_t ret = 1;
+	int32_t idx;
+
+	if (!netif && !ifname) {
+		DC_DP_ERROR("failed as netif=%p and ifname=%p!!!", netif, ifname);
+		return 0;
+	}
+
+	DC_DP_LOCK(&g_dc_dp_lock);
+
+	if (netif)
+		idx = _dc_dp_get_idx_via_dev_private(netif);
+	else if (ifname)
+		idx = _dc_dp_get_idx_via_ifname_private(ifname);
+
+	DC_DP_UNLOCK(&g_dc_dp_lock);
+
+	if (idx < 0) {
+		ret = 0;
+	}
+
+    DC_DP_DEBUG((DC_DP_DBG_FLAG_DUMP_TX|DC_DP_DBG_FLAG_DUMP_RX), "ifname=%s, fastpath(directconnect)=%d.\n",
+					(netif? netif->name : ifname), ret);
+	return ret;
+}
+
+static int32_t
+dc_dp_get_netif_subifid_cb(struct net_device *netif, struct sk_buff *skb,
+						   void *subif_data, uint8_t dst_mac[MAX_ETH_ALEN],
+						   dp_subif_t *subif, uint32_t flags)
+{
+	int32_t ret = -1;
+	int32_t i, j;
+	int32_t (*subif_fn_t)(int32_t port_id, struct net_device *netif, char *mac_addr, uint32_t *sta_id);
+	int32_t subifid = -1;
+	uint32_t staid = 0;
+	uint8_t macaddr[ETH_ALEN] = {0};
+
+	if (!netif) {
+		DC_DP_ERROR("failed to get subifid as netif=%p!!!\n", netif);
+		return ret;
+	}
+
+	if (!subif) {
+		DC_DP_ERROR("failed to get subifid as subif=%p!!!\n", subif);
+		return ret;
+	}
+
+	/* Find Port ID and DC VAP ID */
+	DC_DP_LOCK(&g_dc_dp_lock);
+	for (i = 0; i < DC_DP_MAX_DEV_NUM; i++) {
+		if (g_priv_info[i].port_id != subif->port_id)
+			continue;
+
+		for (j = 0; j < DC_DP_MAX_SUBIF_PER_DEV; j++) {
+			if (g_priv_info[i].subif_info[j].flags == DC_DP_SUBIF_FREE)
+				continue;
+
+			if (g_priv_info[i].subif_info[j].netif == netif) {
+				subifid = g_priv_info[i].subif_info[j].subif;
+				subif_fn_t = g_priv_info[i].cb.get_subif_fn;
+
+				break;
+			}
+		}
+		if (j < DC_DP_MAX_SUBIF_PER_DEV) {
+			break;
+		}
+	}
+	DC_DP_UNLOCK(&g_dc_dp_lock);
+
+	if (subifid < 0) {
+		DC_DP_ERROR("failed to get subifid for netif->name=%s!!!\n", netif->name);
+		return ret;
+	}
+
+	/* Optionally, find WAVE500 Station ID */
+	if ((dst_mac || skb) && subif_fn_t) {
+
+		if (dst_mac) {
+			memcpy(macaddr, dst_mac, ETH_ALEN);
+		} else if (skb) {
+			memcpy(macaddr, eth_hdr(skb)->h_dest, ETH_ALEN);
+		}
+
+		ret = _dc_dp_find_staid_by_macaddr_rcu(macaddr, &staid);
+
+		if (!ret) {
+			ret = subif_fn_t(subif->port_id, netif, macaddr, &staid);
+			if (ret) {
+				DC_DP_ERROR("failed to get subifid for netif->name=%s!!!\n", netif->name);
+				return ret;
+			}
+
+			/* Add to <macaddr-staid> mapping table */
+			_dc_dp_add_sta_entry(netif, macaddr, staid);
+		}
+
+		subifid |= (staid & DC_DP_STAID_MASK);
+	}
+
+	subif->subif = subifid;
+
+	ret = 0; /*according to SWAS, return 1 means subifid found */
+    DC_DP_DEBUG((DC_DP_DBG_FLAG_DUMP_TX|DC_DP_DBG_FLAG_DUMP_RX), "subifid=0x%04x for netif->name=%s.\n",
+					subif->subif, netif->name);
+	return ret;
+}
+
+#if IS_ENABLED(CONFIG_LTQ_PPA_API)
+static int32_t
+dc_dp_qos_class2prio_cb(int32_t port_id, struct net_device *netif, uint8_t *class2prio)
+{
+	int32_t dev_idx;
+
+	if (!class2prio) {
+		DC_DP_ERROR("failed to update class2prio map, as port_id=%d, netif=%p, class2prio=%p!!!\n",
+						port_id, netif, class2prio);
+		return DP_FAILURE;
+	}
+
+	DC_DP_LOCK(&g_dc_dp_lock);
+
+	/* Find the registered device index */
+	dev_idx = _dc_dp_get_dev_idx_by_port(port_id);
+	if (dev_idx < 0) {
+		DC_DP_ERROR("failed to find port=%d in device table!!!\n", port_id);
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+		return DP_FAILURE;
+	}
+
+	/* Update local QoS Class2Priority map table */
+	memcpy(g_priv_info[dev_idx].class2prio, class2prio, sizeof(g_priv_info[dev_idx].class2prio));
+
+	/* Configure the egress PMAC table to mark the WMM/TID in the descriptor DW1[7:4] */
+#if 0 // FIXME
+	dp_pmac_cfg_t pmac_cfg;
+
+	ret = dp_pmac_set(port_id, &pmac_cfg);
+#else
+{
+	uint8_t i = 0, j = 0;
+	GSW_PMAC_Glbl_Cfg_t pmac_glb;
+	GSW_PMAC_Eg_Cfg_t egcfg;
+	GSW_API_HANDLE gswr;
+	uint8_t wmm;
+
+	/* Do the GSW-R configuration */
+	gswr = gsw_api_kopen("/dev/switch_api/1");
+	if (gswr == 0) {
+		DC_DP_ERROR("failed to open SWAPI device!!!\n");
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+		return -EIO;
+	}
+
+	memset(&pmac_glb, 0, sizeof(pmac_glb));
+	gsw_api_kioctl(gswr, GSW_PMAC_GLBL_CFG_GET,
+		       (u32) &pmac_glb);
+
+	/* GSWIP-R PMAC Egress Configuration Table */
+	for (i = 0; i <= 15; i++) {
+		wmm = _dc_dp_get_class2wmm(dev_idx, i, 1);
+
+		for (j = 0; j <= 3; j++) {
+			memset((void *)&egcfg, 0x00, sizeof(egcfg));
+
+			egcfg.nRxDmaChanId  = 0;
+			egcfg.bPmacEna      = 0;
+			egcfg.bFcsEna       = 0;
+			egcfg.bRemL2Hdr     = 0;
+			egcfg.numBytesRem   = 0;
+			egcfg.nResDW1       = wmm;
+			egcfg.nRes1DW0      = 0;
+			egcfg.nRes2DW0      = 0;
+			egcfg.nDestPortId   = port_id;
+			egcfg.nTrafficClass = i;
+			egcfg.bMpe1Flag     = 0;
+			egcfg.bMpe2Flag     = 0;
+			egcfg.bEncFlag      = 0;
+			egcfg.bDecFlag      = 0;
+			egcfg.nFlowIDMsb    = j;
+			egcfg.bTCEnable	    = 1;
+			egcfg.bProcFlagsSelect = pmac_glb.bProcFlagsEgCfgEna;
+
+			gsw_api_kioctl(gswr, GSW_PMAC_EG_CFG_SET, (unsigned int)&egcfg);		
+		}
+	}
+
+	gsw_api_kclose(gswr);
+}
+#endif
+
+	DC_DP_UNLOCK(&g_dc_dp_lock);
+
+	return DP_SUCCESS;
+}
+#endif /* #if IS_ENABLED(CONFIG_LTQ_PPA_API) */
+
+/*
+ * ========================================================================
+ * Misclleneous API
+ * ========================================================================
+ */
+int32_t
+dc_dp_register_mcast_module(struct net_device *dev, struct module *owner,
+							dc_dp_mcast_callback_fn_t cb, unsigned int flags)
+{
+#if defined(CONFIG_LANTIQ_MCAST_HELPER_MODULE) || defined(CONFIG_LANTIQ_MCAST_HELPER)
+	mcast_helper_register_module(dev, owner, NULL, cb, flags);
+	return DP_SUCCESS;
+#else /* #if defined(CONFIG_LANTIQ_MCAST_HELPER_MODULE) || defined(CONFIG_LANTIQ_MCAST_HELPER) */
+	return DP_FAILURE;
+#endif /* #else */
+}
+EXPORT_SYMBOL(dc_dp_register_mcast_module);
+
+int32_t
+dc_dp_map_prio_wmm_class(int32_t port_id, struct net_device *netif, uint8_t prio2wmm[DC_DP_MAX_WIFI_CLASS])
+{
+	//int32_t ret;
+	int32_t dev_idx;
+	uint8_t wmm;
+
+	if (!netif) {
+		DC_DP_ERROR("failed to set prio2wmm map: port_id=%d, netif=%p, prio2wmm=%p!!!\n",
+						port_id, netif, prio2wmm);
+		return DP_FAILURE;
+	}
+
+	DC_DP_LOCK(&g_dc_dp_lock);
+
+	/* Find the registered device index */
+	dev_idx = _dc_dp_get_dev_idx_by_port(port_id);
+	if (dev_idx < 0) {
+		DC_DP_ERROR("failed to find port=%d in device table!!!\n", port_id);
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+		return DP_FAILURE;
+	}
+
+	/* Update local prio2wmm map table */
+	if (prio2wmm)
+		memcpy(g_priv_info[dev_idx].prio2wmm, prio2wmm, sizeof(g_priv_info[dev_idx].prio2wmm));
+	else
+		memset(g_priv_info[dev_idx].prio2wmm, 0, sizeof(g_priv_info[dev_idx].prio2wmm));
+
+	/* Configure the egress PMAC table to mark the WMM/TID in the descriptor DW1[7:4] */
+#if 0 // FIXME
+	dp_pmac_cfg_t pmac_cfg;
+
+	ret = dp_pmac_set(port_id, &pmac_cfg);
+#else
+{
+	uint8_t i = 0, j = 0;
+	GSW_PMAC_Glbl_Cfg_t pmac_glb;
+	GSW_PMAC_Eg_Cfg_t egcfg;
+	GSW_API_HANDLE gswr;
+
+	/* Do the GSW-R configuration */
+	gswr = gsw_api_kopen("/dev/switch_api/1");
+	if (gswr == 0) {
+		DC_DP_ERROR("failed to open SWAPI device!!!\n");
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+		return -EIO;
+	}
+
+	memset(&pmac_glb, 0, sizeof(pmac_glb));
+	gsw_api_kioctl(gswr, GSW_PMAC_GLBL_CFG_GET,
+		       (u32) &pmac_glb);
+
+	/* GSWIP-R PMAC Egress Configuration Table */
+	for (i = 0; i <= 15; i++) {
+		if (prio2wmm)
+			wmm = _dc_dp_get_class2wmm(dev_idx, i, 1);
+		else
+			wmm = 0;
+
+		for (j = 0; j <= 3; j++) {
+			memset((void *)&egcfg, 0x00, sizeof(egcfg));
+
+			egcfg.nRxDmaChanId  = 0;
+			egcfg.bPmacEna      = 0;
+			egcfg.bFcsEna       = 0;
+			egcfg.bRemL2Hdr     = 0;
+			egcfg.numBytesRem   = 0;
+			egcfg.nResDW1       = wmm;
+			egcfg.nRes1DW0      = 0;
+			egcfg.nRes2DW0      = 0;
+			egcfg.nDestPortId   = port_id;
+			egcfg.nTrafficClass = i;
+			egcfg.bMpe1Flag     = 0;
+			egcfg.bMpe2Flag     = 0;
+			egcfg.bEncFlag      = 0;
+			egcfg.bDecFlag      = 0;
+			egcfg.nFlowIDMsb    = j;
+			egcfg.bTCEnable	    = 1;
+			egcfg.bProcFlagsSelect = pmac_glb.bProcFlagsEgCfgEna;
+
+			gsw_api_kioctl(gswr, GSW_PMAC_EG_CFG_SET, (unsigned int)&egcfg);		
+		}
+	}
+
+	gsw_api_kclose(gswr);
+}
+#endif
+
+	DC_DP_UNLOCK(&g_dc_dp_lock);
+
+	return DP_SUCCESS;
+}
+EXPORT_SYMBOL(dc_dp_map_prio_wmm_class);
+
+int32_t
+dc_dp_mark_pkt_wmm(int32_t port_id, struct net_device *dst_netif, struct sk_buff *skb)
+{
+	int32_t dev_idx;
+	struct dma_tx_desc_1 *desc_1 = (struct dma_tx_desc_1 *) &skb->DW1;
+	int32_t class_prio;
+	int32_t wmm;
+	bool is_class = 1;
+
+	DC_DP_LOCK(&g_dc_dp_lock);
+
+	/* Find the registered device index */
+	dev_idx = _dc_dp_get_dev_idx_by_port(port_id);
+	if (dev_idx < 0) {
+		DC_DP_ERROR("failed to find port=%d in device table!!!\n", port_id);
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+		return DP_FAILURE;
+	}
+
+#ifdef CONFIG_NETWORK_EXTMARK
+	GET_DATA_FROM_MARK_OPT(skb->extmark, QUEPRIO_MASK, QUEPRIO_START_BIT_POS, class_prio);
+	class_prio -= 1; /* extmark value is in <1-8>, where corresponding class value is expected in <0-7> */
+#else /* #ifdef CONFIG_NETWORK_EXTMARK */
+	class_prio = skb->priority;
+	is_class = 0;
+#endif /* #else */
+
+	wmm = _dc_dp_get_class2wmm(dev_idx, class_prio, is_class);
+
+	DC_DP_UNLOCK(&g_dc_dp_lock);
+
+	desc_1->field.resv1 = wmm;
+
+	return wmm;
+}
+EXPORT_SYMBOL(dc_dp_mark_pkt_wmm);
+
+int32_t
+dc_dp_get_netif_stats(struct net_device *netif, dp_subif_t *subif_id,
+					  struct rtnl_link_stats64 *if_stats, uint32_t flags)
+{
+	return dp_get_netif_stats(netif, subif_id, if_stats, flags);
+}
+EXPORT_SYMBOL(dc_dp_get_netif_stats);
+
+int32_t
+dc_dp_clear_netif_stats(struct net_device *netif, dp_subif_t *subif_id, uint32_t flags)
+{
+	return dp_clear_netif_stats(netif, subif_id, flags);
+}
+EXPORT_SYMBOL(dc_dp_clear_netif_stats);
+
+int32_t
+dc_dp_get_wol_cfg(dc_dp_wol_cfg_t *cfg, uint32_t flags)
+{
+    /* TODO */
+	return DP_FAILURE;
+}
+EXPORT_SYMBOL(dc_dp_get_wol_cfg);
+
+int32_t
+dc_dp_set_wol_cfg(dc_dp_wol_cfg_t *cfg, uint32_t flags)
+{
+    /* TODO */
+	return DP_FAILURE;
+}
+EXPORT_SYMBOL(dc_dp_set_wol_cfg);
+
+int32_t
+dc_dp_set_wol_ctrl(int32_t port_id, uint32_t enable)
+{
+    /* TODO */
+	return DP_FAILURE;
+}
+EXPORT_SYMBOL(dc_dp_set_wol_ctrl);
+
+int32_t
+dc_dp_get_wol_ctrl_status(int32_t port_id)
+{
+    /* TODO */
+	return DP_FAILURE;
+}
+EXPORT_SYMBOL(dc_dp_get_wol_ctrl_status);
+
+int32_t
+dc_dp_add_class_rule(dc_dp_class_rule_t *rule, uint32_t flags)
+{
+    /* TODO */
+	return DP_FAILURE;
+}
+EXPORT_SYMBOL(dc_dp_add_class_rule);
+
+int32_t
+dc_dp_mod_class_rule(dc_dp_class_rule_t *rule, uint32_t flags)
+{
+    /* TODO */
+	return DP_FAILURE;
+}
+EXPORT_SYMBOL(dc_dp_mod_class_rule);
+
+int32_t
+dc_dp_del_class_rule(dc_dp_class_rule_t *rule, uint32_t flags)
+{
+    /* TODO */
+	return DP_FAILURE;
+}
+EXPORT_SYMBOL(dc_dp_del_class_rule);
+
+int32_t
+dc_dp_get_class_rule(dc_dp_class_rule_t *rule, uint32_t flags)
+{
+    /* TODO */
+	return DP_FAILURE;
+}
+EXPORT_SYMBOL(dc_dp_get_class_rule);
+
+int32_t
+dc_dp_register_power_notifier(struct notifier_block *nb, uint32_t notify_type, uint32_t flags)
+{
+    /* TODO */
+	return DP_FAILURE;
+}
+EXPORT_SYMBOL(dc_dp_register_power_notifier);
+
+int32_t
+dc_dp_req_power_state(dc_dp_power_module_t module, uint8_t module_nr, dc_dp_power_state_t new_state)
+{
+    /* TODO */
+	return DP_FAILURE;
+}
+EXPORT_SYMBOL(dc_dp_req_power_state);
+
+int32_t
+dc_dp_get_ps_poll_period(dc_dp_power_module_t module, uint8_t module_nr)
+{
+    /* TODO */
+	return DP_FAILURE;
+}
+EXPORT_SYMBOL(dc_dp_get_ps_poll_period);
+
+dc_dp_ps_threshold_t *
+dc_dp_get_ps_threshold(dc_dp_power_module_t module, uint8_t module_nr)
+{
+    /* TODO */
+	return NULL;
+}
+EXPORT_SYMBOL(dc_dp_get_ps_threshold);
+
+int32_t
+dc_dp_mod_ps_list(struct list_head *head, int32_t add)
+{
+    /* TODO */
+	return DP_FAILURE;
+}
+EXPORT_SYMBOL(dc_dp_mod_ps_list);
+
+dc_dp_power_state_t
+dc_dp_get_ps_from_khz(uint32_t freq_khz)
+{
+    /* TODO */
+	return DP_FAILURE;
+}
+EXPORT_SYMBOL(dc_dp_get_ps_from_khz);
+
+/*
+ * ========================================================================
+ * Module Init/Exit API
+ * ========================================================================
+ */
+static __init int dc_dp_init_module(void)
+{
+	int32_t ret = 0;
+
+	spin_lock_init(&g_dc_dp_lock);
+
+	DC_DP_LOCK(&g_dc_dp_lock);
+
+	if (!g_dc_dp_init_ok) {
+		memset(g_priv_info, 0, sizeof(g_priv_info));
+
+		/* Initialize <MAC, StaId> map table */
+		ret = dc_dp_sta_info_init();
+
+#if IS_ENABLED(CONFIG_LTQ_PPA_API)
+		ppa_check_if_netif_fastpath_fn = dc_dp_check_if_netif_fastpath_cb;
+#endif /* #if IS_ENABLED(CONFIG_LTQ_PPA_API) */
+
+#ifdef CONFIG_PROC_FS
+		dc_dp_proc_init();
+#endif /* #ifdef CONFIG_PROC_FS */
+
+		g_dc_dp_init_ok = 1;
+	}
+
+	DC_DP_UNLOCK(&g_dc_dp_lock);
+
+	return ret;
+}
+
+static __exit void dc_dp_exit_module(void)
+{
+	if (g_dc_dp_init_ok) {
+
+		DC_DP_LOCK(&g_dc_dp_lock);
+
+#ifdef CONFIG_PROC_FS
+		dc_dp_proc_exit();
+#endif /* #ifdef CONFIG_PROC_FS */
+
+#if IS_ENABLED(CONFIG_LTQ_PPA_API)
+		ppa_check_if_netif_fastpath_fn = NULL;
+#endif /* #if IS_ENABLED(CONFIG_LTQ_PPA_API) */
+
+		dc_dp_sta_info_exit();
+
+		/* Reset private data structure */
+		memset(g_priv_info, 0, sizeof(g_priv_info));
+		g_dc_dp_init_ok = 0;
+
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+	}
+}
+
+module_init(dc_dp_init_module);
+module_exit(dc_dp_exit_module);
+
+MODULE_AUTHOR("Anath Bandhu Garai");
+MODULE_DESCRIPTION("Lantiq DirectConnect datapath driver (Supported XRX500)");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_MODULE_VERSION);
diff --git a/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp_pmac.c b/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp_pmac.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp_pmac.c
@@ -0,0 +1,93 @@
+#include <xway/switch-api/lantiq_gsw_api.h>
+
+#include "directconnect_dp.h"
+
+int32_t
+_dc_dp_gsw_pmac_init(int32_t port_id, int32_t dma_cid)
+{
+	u8 i = 0, j = 0;
+	GSW_PMAC_Eg_Cfg_t egCfg;
+	GSW_PMAC_Ig_Cfg_t igCfg;
+	GSW_register_t regCfg;
+	GSW_API_HANDLE gswr;
+
+	memset((void *)&egCfg, 0x00, sizeof(egCfg));
+	memset((void *)&igCfg, 0x00, sizeof(igCfg));
+
+	/* Do the GSW-R configuration */
+	gswr = gsw_api_kopen("/dev/switch_api/1");
+	if (gswr == 0) {
+		DC_DP_ERROR("Open SWAPI device FAILED!!!\n");
+		return -EIO;
+	}
+
+	/* GSWIP-R PMAC Egress Configuration Table */
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "PMAC_EG_CFG_SET for GSW-R.\n");
+	for (i = 0; i <= 15; i++) {
+		for (j = 0; j <= 3; j++) {
+			egCfg.nRxDmaChanId  = 0;
+			egCfg.bPmacEna      = 0;
+			egCfg.bFcsEna       = 0;
+			egCfg.bRemL2Hdr     = 0;
+			egCfg.numBytesRem   = 0;
+			egCfg.nResDW1       = 0;
+			egCfg.nRes1DW0      = 0;
+			egCfg.nRes2DW0      = 0;
+			egCfg.nDestPortId   = port_id;
+			egCfg.nTrafficClass = i;
+			egCfg.bMpe1Flag     = 0;
+			egCfg.bMpe2Flag     = 0;
+			egCfg.bEncFlag      = 0;
+			egCfg.bDecFlag      = 0;
+			egCfg.nFlowIDMsb    = j;
+			egCfg.bTCEnable	    = 1;
+
+			gsw_api_kioctl(gswr, GSW_PMAC_EG_CFG_SET, (unsigned int)&egCfg);		
+		}
+	}
+
+	/* GSWIP-R PMAC Ingress Configuration Table */
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "PMAC_IG_CFG_SET for GSW-R.\n");
+	igCfg.nTxDmaChanId  = dma_cid;
+	igCfg.bPmacPresent  = 0;
+	igCfg.bSpIdDefault  = 1; 
+	igCfg.bSubIdDefault = 0;
+	igCfg.bClassDefault = 0; 
+	igCfg.bClassEna     = 0; 
+	igCfg.bErrPktsDisc  = 1; 
+
+	igCfg.bPmapDefault  = 1;
+	igCfg.bPmapEna      = 1;
+
+	igCfg.defPmacHdr[0] = 0;
+	igCfg.defPmacHdr[1] = 0;
+	igCfg.defPmacHdr[2] = port_id << 4;
+	igCfg.defPmacHdr[3] = 0x80;
+	igCfg.defPmacHdr[4] = 0;
+	igCfg.defPmacHdr[5] = 0;
+	igCfg.defPmacHdr[6] = 0xFF;
+	igCfg.defPmacHdr[7] = 0xFF;
+
+	gsw_api_kioctl(gswr, GSW_PMAC_IG_CFG_SET, (unsigned int)&igCfg);
+
+	/* Allow traffic from one VAP to any VAP */
+
+	/* PCE_PCTRL_3 */
+	memset((void *)&regCfg, 0x00, sizeof(regCfg));
+	regCfg.nRegAddr = 0x483 + (10 * port_id);
+	gsw_api_kioctl(gswr, GSW_REGISTER_GET, (unsigned int)&regCfg);
+	regCfg.nData |= 0x4000;
+	gsw_api_kioctl(gswr, GSW_REGISTER_SET, (unsigned int)&regCfg);
+
+	/* PCE_IGPTRM */
+	memset((void *)&regCfg, 0x00, sizeof(regCfg));
+	regCfg.nRegAddr = 0x544 + (16 * port_id);
+	gsw_api_kioctl(gswr, GSW_REGISTER_GET, (unsigned int)&regCfg);
+	regCfg.nData |= 0xFFFF;
+	gsw_api_kioctl(gswr, GSW_REGISTER_SET, (unsigned int)&regCfg);
+
+	gsw_api_kclose(gswr);
+
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "GSW PMAC Init Done.\n");
+	return 0;
+}
diff --git a/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp_proc.c b/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp_proc.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp_proc.c
@@ -0,0 +1,643 @@
+/*
+ * ####################################
+ *              Head File
+ * ####################################
+ */
+
+/*
+ *  Common Head File
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/rculist.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#include <linux/interrupt.h>
+#include <lantiq_dmax.h>
+#include <linux/ltq_hwmcpy.h>
+#include "directconnect_dp.h"
+
+#define DC_DP_PROC "dc_dp"
+#define DC_DP_PROC_DBG "dbg"
+#define DC_DP_PROC_DEV "dev"
+#define DC_DP_PROC_STA "wave500_sta"
+
+/*
+ * ####################################
+ *             Declaration
+ * ####################################
+ */
+
+static int proc_read_dc_dp_dbg_seq_open(struct inode *, struct file *);
+static ssize_t proc_write_dc_dp_dbg(struct file *, const char __user *, size_t , loff_t *);
+static void *proc_read_dc_dp_dev_seq_start(struct seq_file *seq, loff_t *ppos);
+static void proc_read_dc_dp_dev_seq_stop(struct seq_file *seq, void *v);
+static void *proc_read_dc_dp_dev_seq_next(struct seq_file *seq, void *v, loff_t *ppos);
+static int proc_read_dc_dp_dev_seq_show(struct seq_file *seq, void *v);
+static int proc_read_dc_dp_dev_seq_open(struct inode *, struct file *);
+static ssize_t proc_write_dc_dp_dev(struct file *, const char __user *, size_t , loff_t *);
+static int proc_read_dc_dp_wave500_sta_seq_open(struct inode *, struct file *);
+static int proc_read_dc_dp_wave500_sta(struct seq_file *seq, void *v);
+
+/*
+ * ####################################
+ *           Global Variable
+ * ####################################
+ */
+
+#undef DP_F_ENUM_OR_STRING
+#define DP_F_ENUM_OR_STRING(name,value, short_name) short_name
+static int8_t *g_dc_dp_port_type_str[] = {
+	DP_F_FLAG_LIST
+};
+#undef DP_F_ENUM_OR_STRING
+
+#undef DP_F_ENUM_OR_STRING
+#define DP_F_ENUM_OR_STRING(name,value, short_name) value
+static uint32_t g_dc_dp_port_flag[] = {
+	DP_F_FLAG_LIST
+};
+#undef DP_F_ENUM_OR_STRING
+
+static int8_t *g_dc_dp_port_status_str[] = {
+	"PORT_FREE",
+	"PORT_ALLOCATED",
+	"PORT_DEV_REGISTERED",
+	"PORT_SUBIF_REGISTERED",
+	"Invalid"
+};
+
+static int8_t *g_dc_dp_dbg_flag_str[] = {
+	"dbg",			/*DC_DP_DBG_FLAG_DBG */
+
+	"rx",			/*DC_DP_DBG_FLAG_DUMP_RX */
+	"rx_data",		/*DC_DP_DBG_FLAG_DUMP_RX_DATA*/
+	"rx_desc",		/*DC_DP_DBG_FLAG_DUMP_RX_DESCRIPTOR */
+	"rx_pmac",		/*DC_DP_DBG_FLAG_DUMP_RX_PMAC */
+
+	"tx",			/*DC_DP_DBG_FLAG_DUMP_TX */
+	"tx_data",		/*DC_DP_DBG_FLAG_DUMP_TX_DATA */
+	"tx_desc",		/*DC_DP_DBG_FLAG_DUMP_TX_DESCRIPTOR */
+	"tx_pmac",		/*DC_DP_DBG_FLAG_DUMP_TX_PMAC */
+
+	/*the last one*/
+	"err"
+};
+
+static uint32_t g_dc_dp_dbg_flag_list[] = {
+	DC_DP_DBG_FLAG_DBG,
+
+	DC_DP_DBG_FLAG_DUMP_RX,
+	DC_DP_DBG_FLAG_DUMP_RX_DATA,
+	DC_DP_DBG_FLAG_DUMP_RX_DESCRIPTOR,
+	DC_DP_DBG_FLAG_DUMP_RX_PMAC,
+
+	DC_DP_DBG_FLAG_DUMP_TX,
+	DC_DP_DBG_FLAG_DUMP_TX_DATA,
+	DC_DP_DBG_FLAG_DUMP_TX_DESCRIPTOR,
+	DC_DP_DBG_FLAG_DUMP_TX_PMAC,
+
+	/*The last one*/
+	DC_DP_DBG_FLAG_ERR
+};
+
+static inline int32_t _dc_dp_get_port_type_str_size(void)
+{
+    return ARRAY_SIZE(g_dc_dp_port_type_str);
+}   
+
+static inline int32_t _dc_dp_get_dbg_flag_str_size(void)
+{   
+    return ARRAY_SIZE(g_dc_dp_dbg_flag_str);
+}
+
+static inline int32_t _dc_dp_get_port_status_str_size(void)
+{   
+    return ARRAY_SIZE(g_dc_dp_port_status_str);
+}   
+
+static struct proc_dir_entry *g_dc_dp_proc = NULL;
+
+static struct file_operations g_dc_dp_dbg_proc_fops = {
+    .owner      = THIS_MODULE,
+    .open       = proc_read_dc_dp_dbg_seq_open,
+    .read       = seq_read,
+    .write      = proc_write_dc_dp_dbg,
+    .llseek     = seq_lseek,
+    .release    = seq_release,
+};
+
+static struct seq_operations g_proc_read_dc_dp_dev_seq_ops = {
+    .start      = proc_read_dc_dp_dev_seq_start,
+    .next       = proc_read_dc_dp_dev_seq_next,
+    .stop       = proc_read_dc_dp_dev_seq_stop,
+    .show       = proc_read_dc_dp_dev_seq_show,
+};
+
+static struct file_operations g_dc_dp_dev_proc_fops = {
+    .owner      = THIS_MODULE,
+    .open       = proc_read_dc_dp_dev_seq_open,
+    .read       = seq_read,
+    .write      = proc_write_dc_dp_dev,
+    .llseek     = seq_lseek,
+    .release    = seq_release,
+};
+
+static struct file_operations g_dc_dp_sta_proc_fops = {
+    .owner      = THIS_MODULE,
+    .open       = proc_read_dc_dp_wave500_sta_seq_open,
+    .read       = seq_read,
+    .write      = NULL,
+    .llseek     = seq_lseek,
+    .release    = seq_release,
+};
+
+/*
+ * ####################################
+ *           Extern Variable
+ * ####################################
+ */
+extern spinlock_t g_dc_dp_lock;
+extern dc_dp_priv_dev_info_t g_priv_info[DC_DP_MAX_DEV_NUM];
+extern dc_dp_priv_sta_info_t g_sta_info;
+
+/*
+ * ####################################
+ *            Extern Function
+ * ####################################
+ */
+
+/*
+ * ####################################
+ *            Local Function
+ * ####################################
+ */
+static void proc_write_dc_dp_dbg_usage(void)
+{
+	pr_info("usage:\n");
+	pr_info("    echo [enable|disable] dbg tx tx_data tx_desc rx rx_data rx_desc > /proc/%s/%s\n", DC_DP_PROC, DC_DP_PROC_DBG);
+}
+
+static void proc_write_dc_dp_dev_usage(void)
+{
+	pr_info("usage:\n");
+	//pr_info("    echo show dev <idx> > /proc/%s/%s\n", DC_DP_PROC, DC_DP_PROC_DEV);
+	pr_info("    echo set dev <idx> umt_period <us> > /proc/%s/%s\n", DC_DP_PROC, DC_DP_PROC_DEV);
+	pr_info("    echo set dev <idx> umt <0|1> > /proc/%s/%s\n", DC_DP_PROC, DC_DP_PROC_DEV);
+	pr_info("    echo set dev <idx> dma <0|1> > /proc/%s/%s\n", DC_DP_PROC, DC_DP_PROC_DEV);
+}
+
+static int proc_read_dc_dp_dbg(struct seq_file *seq, void *v)
+{
+	int i;
+
+	seq_printf(seq, "g_dc_dp_dbg_flag=0x%08x\n", g_dc_dp_dbg_flag);
+	seq_printf(seq, "Supported Flags =%d\n",
+		   _dc_dp_get_dbg_flag_str_size());
+	seq_printf(seq, "Enabled Flags(0x%0x):", g_dc_dp_dbg_flag);
+
+	for (i = 0; i < _dc_dp_get_dbg_flag_str_size(); i++)
+		if ((g_dc_dp_dbg_flag & g_dc_dp_dbg_flag_list[i]) == g_dc_dp_dbg_flag_list[i])
+			seq_printf(seq, "%s ", g_dc_dp_dbg_flag_str[i]);
+
+	seq_printf(seq, "\n");
+
+    return 0;
+}
+
+static int proc_read_dc_dp_dbg_seq_open(struct inode *inode, struct file *file)
+{
+    return single_open(file, proc_read_dc_dp_dbg, NULL);
+}
+
+static ssize_t proc_write_dc_dp_dbg(struct file *file, const char __user *buf, size_t count, loff_t *data)
+{
+    int len;
+    char str[40];
+    char *p;
+	int f_enable;
+
+    len = min(count, (size_t)(sizeof(str) - 1));
+    len -= copy_from_user(str, buf, len);
+    while ( len && str[len - 1] <= ' ' )
+        len--;
+    str[len] = 0;
+    for ( p = str; *p && *p <= ' '; p++, len-- );
+    if ( !*p ) {
+		goto help;
+	}
+
+	if (!strncmp(p, "enable", 6)) {
+		f_enable = 1;
+	} else if (!strncmp(p, "disable", 7)) {
+		f_enable = 0;
+	} else {
+		goto help;
+	}
+
+#if 0
+	for (i = 1; i < num; i++) {
+		for (j = 0; j < _dc_dp_get_dbg_flag_str_size(); j++) {
+			if (!strncmp(param_list[i],
+				       g_dc_dp_dbg_flag_str[j])) {
+				set_ltq_dbg_flag(g_dc_dp_dbg_flag,
+						 f_enable, g_dc_dp_dbg_flag_list[j]);
+				break;
+			}
+		}
+	}
+#endif
+    return len; 
+
+help:
+	proc_write_dc_dp_dbg_usage();
+	return count;
+}
+
+static void *proc_read_dc_dp_dev_seq_start(struct seq_file *seq, loff_t *ppos)
+{
+#if 1
+	int32_t dev_idx = (int32_t)*ppos;
+
+	if (dev_idx < DC_DP_MAX_DEV_NUM) {
+		return &g_priv_info[dev_idx];
+	} else {
+		return NULL;
+	}
+#else
+	if (*ppos == 0) {
+		return ppos;
+	} else {
+		return NULL;
+	}
+#endif
+}
+
+static void proc_read_dc_dp_dev_seq_stop(struct seq_file *seq, void *v)
+{
+	return;
+}
+
+static void *proc_read_dc_dp_dev_seq_next(struct seq_file *seq, void *v, loff_t *ppos)
+{
+#if 1
+	int32_t dev_idx = ++(*ppos);
+
+	if (dev_idx < DC_DP_MAX_DEV_NUM) {
+		return &g_priv_info[dev_idx];
+	} else {
+		return NULL;
+	}
+#else
+	loff_t *dev_idx_p = (loff_t *)v;
+
+	(*dev_idx_p)++;
+	if (*dev_idx_p < DC_DP_MAX_DEV_NUM && *dev_idx_p >= 0) {
+		return v;
+	} else {
+		return NULL;
+	}
+#endif
+}
+
+static int proc_read_dc_dp_dev_seq_show(struct seq_file *seq, void *v)
+{
+	int i;
+#if 1
+	int32_t pos = 0;
+	dc_dp_priv_dev_info_t *dev_info = (dc_dp_priv_dev_info_t *)v;
+#else
+	int32_t pos = (int32_t)(*(loff_t *)v);
+	dc_dp_priv_dev_info_t *dev_info;
+
+	if (pos >= DC_DP_MAX_DEV_NUM) {
+		return -1;
+	}
+
+	dev_info = &g_priv_info[pos];
+#endif
+
+	DC_DP_LOCK(&g_dc_dp_lock);
+
+	if (dev_info->flags == DC_DP_DEV_FREE) {
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+		seq_printf(seq, "%d: Not registered\n", pos);
+		return 0;
+	}
+
+	seq_printf(seq,
+		   "%d: module=0x%08x(name:%8s) dev_port=%02d dp_port=%02d\n",
+		   pos, (uint32_t)dev_info->owner, dev_info->owner->name,
+		   dev_info->dev_port, dev_info->port_id);
+	seq_printf(seq,  "    status:            %s\n",
+		g_dc_dp_port_status_str[dev_info->flags]);
+
+	seq_printf(seq, "    allocate_flags:    ");
+	for (i = 0; i < _dc_dp_get_port_type_str_size(); i++) {
+		if (dev_info->alloc_flags & g_dc_dp_port_flag[i])
+			seq_printf(seq,  "%s ", g_dc_dp_port_type_str[i]);
+	}
+	seq_printf(seq, "\n");
+
+	seq_printf(seq, "    cb->rx_fn:         0x%0x\n",
+		(uint32_t) dev_info->cb.rx_fn);
+	seq_printf(seq, "    cb->restart_fn:    0x%0x\n",
+		(uint32_t) dev_info->cb.restart_fn);
+	seq_printf(seq, "    cb->stop_fn:       0x%0x\n",
+		(uint32_t) dev_info->cb.stop_fn);
+	seq_printf(seq, "    cb->get_staid_fn:  0x%0x\n",
+		(uint32_t) dev_info->cb.get_staid_fn);
+
+	seq_printf(seq, "    cbm_pid:           %d\n",
+		   dev_info->cbm_pid);
+
+	seq_printf(seq, "    dma_ch:            %d\n",
+		   _DMA_CHANNEL(dev_info->dma_ch));
+
+	seq_printf(seq, "    num_bufpools:      %02d\n",
+		   dev_info->num_bufpools);
+	for (i = 0; i < dev_info->num_bufpools; i++) {
+		seq_printf(seq, "    buflist %d:\n",
+		   	(i + 1));
+		seq_printf(seq, "      virtual range:    0x%p-0x%p (%d KB)\n",
+		   	dev_info->virt_buflist_base[i].pool,
+			((uint8_t *)dev_info->virt_buflist_base[i].pool + dev_info->virt_buflist_base[i].size),
+			(dev_info->virt_buflist_base[i].size >> 10));
+		seq_printf(seq, "      physical range:   0x%p-0x%p (%d KB)\n",
+		   	(void *)virt_to_phys(dev_info->virt_buflist_base[i].pool),
+			(void *)((uint8_t *)virt_to_phys(dev_info->virt_buflist_base[i].pool) + dev_info->virt_buflist_base[i].size),
+			(dev_info->virt_buflist_base[i].size >> 10));
+	}
+
+	seq_printf(seq, "    umt_id:            %d\n",
+		   dev_info->umt_id);
+	seq_printf(seq, "    umt_period:        %d (in micro second)\n",
+		   dev_info->umt_period);
+	seq_printf(seq, "    class2prio:        ");
+	for (i = 0; i < 16; i++) {
+		seq_printf(seq, "[%d->%d],", i, dev_info->class2prio[i]);
+	}
+	seq_printf(seq, "\n");
+	seq_printf(seq, "    prio2wmm:          ");
+	for (i = 0; i < DC_DP_MAX_WIFI_CLASS; i++) {
+		seq_printf(seq, "[%d->%d],", i, dev_info->prio2wmm[i]);
+	}
+	seq_printf(seq, "\n");
+
+	seq_printf(seq, "    num_subif:         %02d\n",
+		   dev_info->num_subif);
+	for (i = 0; i < DC_DP_MAX_SUBIF_PER_DEV; i++) {
+		if (dev_info->subif_info[i].flags) {
+			seq_printf(seq,
+				   "      [%02d]: subif=0x%04x(vap=%d) netif=0x%0x(name=%s), device_name=%s\n",
+				   i, dev_info->subif_info[i].subif,
+				   (dev_info->
+				    subif_info[i].subif >> DC_DP_VAPID_OFFSET)
+				   & DC_DP_VAPID_MASK, (uint32_t)dev_info->subif_info[i].netif,
+				   dev_info->subif_info[i].netif ? dev_info->subif_info[i].netif->name : "NULL",
+				   dev_info->subif_info[i].device_name);
+		}
+	}
+
+	DC_DP_UNLOCK(&g_dc_dp_lock);
+
+	return 0;
+}
+
+static int proc_read_dc_dp_dev_seq_open(struct inode *inode, struct file *file)
+{
+    return seq_open(file, &g_proc_read_dc_dp_dev_seq_ops);
+}
+
+static __always_inline char *parse_token(char **str, char *delim)
+{
+	*str = strim(*str);
+	return strsep(str, delim);
+}
+
+static uint32_t btoi(char *str)
+{
+	unsigned int sum = 0;
+	signed len = 0, i = 0;
+
+	len = strlen(str);
+	len = len - 1;
+	while (len >= 0) {
+		if (*(str + len) == '1')
+			sum = (sum | (1 << i));
+		i++;
+		len--;
+	}
+	return sum;
+}
+
+static int32_t dc_dp_atoi(uint8_t *str)
+{
+	uint32_t n = 0;
+	int32_t i = 0;
+	int32_t nega_sign = 0;
+
+	if (!str)
+		return 0;
+	//dp_replace_ch(str, strlen(str), '.', 0);
+	//dp_replace_ch(str, strlen(str), ' ', 0);
+	//dp_replace_ch(str, strlen(str), '\r', 0);
+	//dp_replace_ch(str, strlen(str), '\n', 0);
+	if (str[0] == 0)
+		return 0;
+
+	if (str[0] == 'b' || str[0] == 'B') {	/*binary format */
+		n = btoi(str + 1);
+	} else if ((str[0] == '0') && ((str[1] == 'x') || (str[1] == 'X'))) {
+		/*hex format */
+		str += 2;
+
+		while (str[i]) {
+			n = n * 16;
+			if (('0' <= str[i] && str[i] <= '9')) {
+				n += str[i] - '0';
+			} else if (('A' <= str[i] && str[i] <= 'F')) {
+				n += str[i] - 'A' + 10;
+				;
+			} else if (('a' <= str[i] && str[i] <= 'f')) {
+				n += str[i] - 'a' + 10;
+				;
+			} else
+				DC_DP_ERROR("Wrong value:%u\n", str[i]);
+			
+			i++;
+		}
+
+	} else {
+		if (str[i] == '-') {	/*negative sign */
+			nega_sign = 1;
+			i++;
+		}
+		while (str[i]) {
+			n *= 10;
+			n += str[i] - '0';
+			i++;
+		}
+	}
+	if (nega_sign)
+		n = -(int)n;
+	return n;
+}
+
+static ssize_t proc_write_dc_dp_dev(struct file *file, const char __user *buf, size_t count, loff_t *data)
+{
+    int len;
+    char str[40] = {0};
+    char *p, *param_name = NULL, *param_val = NULL;
+	int32_t dev_idx;
+	char *delim = " \t\n\v\f\r";
+	int32_t value;
+
+    len = min(count, (size_t)(sizeof(str) - 1));
+    len -= copy_from_user(str, buf, len);
+
+	p = str;
+
+	if (!strncmp(p, "set", 3)) {
+		/* set ... */
+		parse_token(&p, delim); //Skip command 'set'
+		if (!p) {
+			goto help;
+		}
+		param_name = parse_token(&p, delim);
+		if (!p) {
+			goto help;
+		}
+		if (strncmp(param_name, "dev", 3)) {
+			goto help;
+		}
+		param_val = parse_token(&p, delim);
+		if (!p) {
+			goto help;
+		}
+		dev_idx = dc_dp_atoi(param_val);
+		if (dev_idx >= DC_DP_MAX_DEV_NUM) {
+			goto help;
+		}
+		param_name = parse_token(&p, delim);
+		if (!p) {
+			goto help;
+		}
+		param_val = parse_token(&p, delim);
+		value = dc_dp_atoi(param_val);
+
+		if (!strncmp(param_name, "umt_period", strlen("umt_period"))) {
+			g_priv_info[dev_idx].umt_period = value;
+#if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE
+			ltq_umt_set_period(g_priv_info[dev_idx].umt_id, g_priv_info[dev_idx].port_id, value);
+#else /* #if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE */
+			ltq_umt_set_period(value);
+#endif /* #else */
+
+		} else if (!strncmp(param_name, "umt", 3)) {
+			if (value == 0) {
+#if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE
+				ltq_umt_enable(g_priv_info[dev_idx].umt_id, g_priv_info[dev_idx].port_id, 0);
+#else /* #if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE */
+				ltq_umt_enable(0);
+#endif /* #else */
+
+			} else {
+#if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE
+				ltq_umt_enable(g_priv_info[dev_idx].umt_id, g_priv_info[dev_idx].port_id, 1);
+#else /* #if defined(CONFIG_LTQ_UMT_EXPAND_MODE) && CONFIG_LTQ_UMT_EXPAND_MODE */
+				ltq_umt_enable(1);
+#endif /* #else */
+			}
+
+		} else if (!strncmp(param_name, "dma", 3)) {
+			if (value == 0) {
+				ltq_dma_chan_off(g_priv_info[dev_idx].dma_ch);
+			} else {
+				ltq_dma_chan_on(g_priv_info[dev_idx].dma_ch);
+			}
+		} else {
+			goto help;
+		}
+	} else {
+		goto help;
+	}
+
+    return len; 
+
+help:
+	proc_write_dc_dp_dev_usage();
+    return count;
+}
+
+static int proc_read_dc_dp_wave500_sta(struct seq_file *seq, void *v)
+{
+	int32_t i;
+
+	seq_printf(seq, "mac addr             sta id    iface\n");
+
+	spin_lock_bh(&g_sta_info.sta_hash_lock);
+	for (i = 0; i < STA_HASH_SIZE; i++) {
+		dc_dp_priv_sta_entry_t *sta_entry;
+
+		hlist_for_each_entry_rcu(sta_entry, &g_sta_info.sta_hash[i], hlist) {
+			seq_printf(seq, "%pM    %d        %s\n",
+				sta_entry->mac_addr, sta_entry->sta_id,
+				((sta_entry->netif) ? sta_entry->netif->name : NULL));
+		}
+	}
+	spin_unlock_bh(&g_sta_info.sta_hash_lock);
+
+    return 0;
+}
+
+static int proc_read_dc_dp_wave500_sta_seq_open(struct inode *inode, struct file *file)
+{
+    return single_open(file, proc_read_dc_dp_wave500_sta, NULL);
+}
+
+int32_t dc_dp_proc_init(void)
+{
+    struct proc_dir_entry *entry;
+    
+	g_dc_dp_proc = proc_mkdir(DC_DP_PROC, NULL);
+	if (!g_dc_dp_proc)
+		return -ENOMEM;
+
+    entry = proc_create_data(DC_DP_PROC_DBG, 0, g_dc_dp_proc,
+			&g_dc_dp_dbg_proc_fops, NULL);
+	if (!entry)
+		goto __dbg_proc_err;
+
+    entry = proc_create_data(DC_DP_PROC_DEV, 0, g_dc_dp_proc,
+            &g_dc_dp_dev_proc_fops, NULL);
+	if (!entry)
+		goto __dev_proc_err;
+
+    entry = proc_create_data(DC_DP_PROC_STA, 0, g_dc_dp_proc,
+            &g_dc_dp_sta_proc_fops, NULL);
+	if (!entry)
+		goto __sta_proc_err;
+
+	return 0;
+
+__sta_proc_err:
+	remove_proc_entry(DC_DP_PROC_DEV, g_dc_dp_proc);
+
+__dev_proc_err:
+	remove_proc_entry(DC_DP_PROC_DBG, g_dc_dp_proc);
+
+__dbg_proc_err:
+	proc_remove(g_dc_dp_proc);
+	return -ENOMEM;
+}
+
+void dc_dp_proc_exit(void)
+{
+	remove_proc_entry(DC_DP_PROC_STA, g_dc_dp_proc);
+	remove_proc_entry(DC_DP_PROC_DEV, g_dc_dp_proc);
+	remove_proc_entry(DC_DP_PROC_DBG, g_dc_dp_proc);
+	proc_remove(g_dc_dp_proc);
+	g_dc_dp_proc = NULL;
+}
diff --git a/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp_wave500_api.c b/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp_wave500_api.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp_wave500_api.c
@@ -0,0 +1,187 @@
+#include "directconnect_dp.h"
+
+#ifndef SWAS_3_8
+static inline int32_t
+_wave500_dp_get_dev_idx_by_module_port(struct module *owner, int32_t port_id)
+{
+	int32_t i;
+
+	for (i = 0; i < DC_DP_MAX_DEV_NUM; i++) {
+		if (g_priv_info[i].flags == DC_DP_DEV_FREE)
+			continue;
+
+		if (g_priv_info[i].owner == owner &&
+			g_priv_info[i].port_id == port_id) {
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+int32_t
+wave500_dp_register_dev(struct module *owner, uint32_t port_id,
+						struct net_device *dev, wave500_dp_cb_t *datapathcb,
+						uint32_t num_bufs_req, void *umt_base, int32_t umt_len,
+						wave500_dp_res_t *resources, uint32_t flags)
+{
+	int32_t ret;
+	int32_t dev_idx;
+	dc_dp_res_t dc_dp_res = {0};
+	int32_t i, j;
+	size_t buflist_virt_sz;
+	struct list_head *buflist_virt_base = NULL;
+	uint32_t num_buf_req_rem;
+	uint32_t tmp_num_bufs_req;
+	bufptr_t *tmp_buf_node = NULL;
+	uint8_t *tmp_buf = NULL;
+
+	DC_DP_LOCK(&g_dc_dp_lock);
+
+	/* Convert resource structure */
+	if (resources) {
+		dc_dp_res.num_dma_desc = resources->num_dma_desc;
+		dc_dp_res.dmatx_ring_base = resources->dmatx_ring_base;
+		dc_dp_res.cbm_dequeue_base = resources->cbm_dequeue_base;
+		dc_dp_res.num_dequeue_bufs = resources->num_dequeue_bufs;
+		dc_dp_res.cbm_buf_free_base = resources->cbm_buf_free_base;
+		dc_dp_res.num_free_bufs = resources->num_free_bufs;
+	}
+
+	ret = _dc_dp_register_dev_private(owner, port_id, dev, datapathcb, num_bufs_req, umt_base, umt_len, &dc_dp_res, flags);
+	if (ret != DP_SUCCESS) {
+		DC_DP_ERROR("failed to register/de-register dev for the port_id=%d!!!\n", port_id);
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+		return ret;
+	}
+
+	/* Find the device index */
+	dev_idx = _wave500_dp_get_dev_idx_by_module_port(owner, port_id);
+	if (dev_idx < 0) {
+		DC_DP_ERROR("failed to register/de-register dev, as port_id=%d is not allocated yet!!!\n", port_id);
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+		return DP_FAILURE;
+	}
+
+	/* De-register */
+	if (flags & DP_F_DEREGISTER) {
+		if (g_priv_info[dev_idx].buflist_virt_base) {
+			kfree(g_priv_info[dev_idx].buflist_virt_base);
+			g_priv_info[dev_idx].buflist_virt_base = NULL;
+		}
+
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+		return ret;
+	}
+
+	/* Convert resource structure */
+	if (resources) {
+		resources->num_dma_desc = dc_dp_res.num_dma_desc;
+		resources->dmatx_ring_base = dc_dp_res.dmatx_ring_base;
+		resources->cbm_dequeue_base = dc_dp_res.cbm_dequeue_base;
+		resources->num_dequeue_bufs = dc_dp_res.num_dequeue_bufs;
+		resources->cbm_buf_free_base = dc_dp_res.cbm_buf_free_base;
+		resources->num_free_bufs = dc_dp_res.num_free_bufs;
+	}
+
+	buflist_virt_sz = (sizeof(struct list_head) + (num_bufs_req * sizeof(bufptr_t)));
+
+	/* Allocate Tx buffers */
+	DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Allocating %d DMA1-Tx buffer lists.\n", dc_dp_res.num_bufpools);
+	buflist_virt_base = (struct list_head *) kmalloc(buflist_virt_sz, GFP_KERNEL);
+	if (!buflist_virt_base) {
+		DC_DP_ERROR("failed to allocate %d buffer lists!!!\n", dc_dp_res.num_bufpools);
+		_dc_dp_register_dev_private(owner, port_id, dev, datapathcb, num_bufs_req, umt_base, umt_len, &dc_dp_res, DP_F_DEREGISTER);
+		DC_DP_UNLOCK(&g_dc_dp_lock);
+		return DP_FAILURE;
+	}
+	memset((void *)buflist_virt_base, 0, buflist_virt_sz);
+	g_priv_info[dev_idx].buflist_virt_base = buflist_virt_base;
+
+	INIT_LIST_HEAD(buflist_virt_base);
+
+	tmp_buf_node = (bufptr_t *)((uint8_t *)buflist_virt_base + sizeof(struct list_head));
+	num_buf_req_rem = num_bufs_req;
+	for (i = 0; i < dc_dp_res.num_bufpools; i++) {
+		tmp_buf = (uint8_t *)dc_dp_res.buflist[i].pool;
+		tmp_num_bufs_req = MIN(num_buf_req_rem, (dc_dp_res.buflist[i].size / g_size_tx_buffers));
+		for (j = 0; j < tmp_num_bufs_req; j++) {
+			tmp_buf_node->pktbuf = tmp_buf;
+
+			/* Populate it into the list returned 'buflist' */
+			list_add_tail(&tmp_buf_node->list, buflist_virt_base);
+
+			tmp_buf_node = (bufptr_t *)((uint8_t *)tmp_buf_node + sizeof(bufptr_t));
+			tmp_buf += g_size_tx_buffers;
+		}
+
+		num_buf_req_rem -= tmp_num_bufs_req;
+	}
+
+	resources->buflist = (struct list_head *) buflist_virt_base;
+#if defined(CONFIG_LTQ_DIRECTCONNECT_DP_DBG) && CONFIG_LTQ_DIRECTCONNECT_DP_DBG
+	if ( !(flags & DP_F_DEREGISTER) ) {
+		int32_t i;
+
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "resources->buflist = %p\n", resources->buflist);
+		i = 0;
+		list_for_each_entry(tmp_buf_node, resources->buflist, list) {
+			DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "Buffer %d : 0x%p.\n", (i + 1), (void *)tmp_buf_node->pktbuf);
+			if(i >= 5) {
+				break;
+			} else {
+				i++;
+			}
+		}
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "resources->num_dma_desc = %d\n", resources->num_dma_desc);
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "resources->dmatx_ring_base = 0x%p\n", resources->dmatx_ring_base);
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "resources->cbm_dequeue_base = 0x%p.\n", resources->cbm_dequeue_base);
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "resources->num_dequeue_bufs = %d.\n", resources->num_dequeue_bufs);
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "resources->cbm_buf_free_base = 0x%p.\n", resources->cbm_buf_free_base);
+		DC_DP_DEBUG(DC_DP_DBG_FLAG_DBG, "resources->num_free_bufs = %d.\n", resources->num_free_bufs);
+	}
+#endif /* #if defined(CONFIG_LTQ_DIRECTCONNECT_DP_DBG) && CONFIG_LTQ_DIRECTCONNECT_DP_DBG */
+
+	DC_DP_UNLOCK(&g_dc_dp_lock);
+	return ret;
+}
+EXPORT_SYMBOL(wave500_dp_register_dev);
+#endif /* #ifndef SWAS_3_8 */
+
+int32_t
+wave500_dp_disconn_staid(uint8_t sta_id, uint8_t macaddr[MAX_ETH_ALEN])
+{
+	int32_t ret = 0;
+	struct net_device *dev;
+	dc_dp_priv_sta_entry_t *sta_entry;
+
+	DC_DP_DEBUG((DC_DP_DBG_FLAG_DUMP_TX | DC_DP_DBG_FLAG_DUMP_RX),
+					"sta_id=%d, macaddr=%pM\n", sta_id, macaddr);
+
+	spin_lock_bh(&g_sta_info.sta_hash_lock);
+
+	sta_entry = _dc_dp_find_sta_entry_by_macaddr(macaddr);
+	if (!sta_entry) {
+		DC_DP_DEBUG((DC_DP_DBG_FLAG_DUMP_TX|DC_DP_DBG_FLAG_DUMP_RX), "No entry found for staid %d and macaddr %pM!!!\n", sta_id, macaddr);
+		spin_unlock_bh(&g_sta_info.sta_hash_lock);
+		return ret;
+	}
+
+	dev = sta_entry->netif;
+
+	/* Delete from <macaddr-staid> mapping table */
+	_dc_dp_delete_sta_entry(sta_entry);
+
+	spin_unlock_bh(&g_sta_info.sta_hash_lock);
+
+	/* Remove all the sessions from PPA */
+	ret = dc_dp_disconn_if(NULL, NULL, macaddr, 0);
+
+	/* Remove the Linux bridge entry */
+	ppa_br_fdb_delete(dev, macaddr);
+
+	DC_DP_DEBUG((DC_DP_DBG_FLAG_DUMP_TX|DC_DP_DBG_FLAG_DUMP_RX),
+					"Exit, returned=%d.\n", ret);
+	return ret;
+}
+EXPORT_SYMBOL(wave500_dp_disconn_staid);
diff --git a/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp_wave500_sta.c b/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp_wave500_sta.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/directconnect_dp/directconnect_dp_wave500_sta.c
@@ -0,0 +1,128 @@
+#include <linux/kernel.h>
+#include <linux/jhash.h>
+
+#include "directconnect_dp.h"
+
+dc_dp_priv_sta_info_t g_sta_info;
+static struct kmem_cache *g_sta_info_cache __read_mostly;
+static uint32_t g_sta_info_salt __read_mostly;
+
+static inline int _dc_dp_mac_hash(const uint8_t *macaddr);
+//static dc_dp_priv_sta_entry_t *_dc_dp_find_sta_entry_by_macaddr(const uint8_t *macaddr);
+//static int32_t _dc_dp_find_staid_by_macaddr_rcu(const uint8_t *macaddr, uint32_t *staid);
+static void _dc_dp_rcu_free_sta_entry(struct rcu_head *head);
+///static dc_dp_priv_sta_entry_t *_dc_dp_add_sta_entry(struct net_device *dev,
+///			const uint8_t *macaddr, const uint32_t sta_id);
+///static void _dc_dp_delete_sta_entry(dc_dp_priv_sta_entry_t *sta_entry);
+
+static inline int _dc_dp_mac_hash(const uint8_t *macaddr)
+{
+	/* use 1 byte of OUI and 3 bytes of NIC */
+	uint32_t key = get_unaligned((uint32_t *)(macaddr + 2));
+
+	return jhash_1word(key, g_sta_info_salt) & (STA_HASH_SIZE - 1);
+}
+
+int32_t
+_dc_dp_find_staid_by_macaddr_rcu(const uint8_t *macaddr, uint32_t *staid)
+{
+	dc_dp_priv_sta_entry_t *sta_entry;
+	struct hlist_head *head = &g_sta_info.sta_hash[_dc_dp_mac_hash(macaddr)];
+
+	rcu_read_lock();
+	hlist_for_each_entry_rcu(sta_entry, head, hlist) {
+		if (!memcmp(sta_entry->mac_addr, macaddr, ETH_ALEN)) {
+			*staid = sta_entry->sta_id;
+			return 1;
+		}
+	}
+	rcu_read_unlock();
+
+	return 0;
+}
+
+dc_dp_priv_sta_entry_t *
+_dc_dp_find_sta_entry_by_macaddr(const uint8_t *macaddr)
+{
+	dc_dp_priv_sta_entry_t *sta_entry;
+	struct hlist_head *head = &g_sta_info.sta_hash[_dc_dp_mac_hash(macaddr)];
+
+	hlist_for_each_entry(sta_entry, head, hlist) {
+		if (!memcmp(sta_entry->mac_addr, macaddr, ETH_ALEN)) {
+			return sta_entry;
+		}
+	}
+
+	return NULL;
+}
+
+dc_dp_priv_sta_entry_t *
+_dc_dp_add_sta_entry(struct net_device *dev, const uint8_t *macaddr, const uint32_t sta_id)
+{
+	dc_dp_priv_sta_entry_t *sta_entry;
+	struct hlist_head *head = &g_sta_info.sta_hash[_dc_dp_mac_hash(macaddr)];
+
+	spin_lock_bh(&g_sta_info.sta_hash_lock);
+
+	sta_entry = _dc_dp_find_sta_entry_by_macaddr(macaddr);
+	if (sta_entry) {
+		return sta_entry;
+	}
+
+	sta_entry = kmem_cache_alloc(g_sta_info_cache, GFP_ATOMIC);
+	if (sta_entry) {
+		INIT_HLIST_NODE(&sta_entry->hlist);
+		memcpy(sta_entry->mac_addr, macaddr, ETH_ALEN);
+		sta_entry->sta_id = sta_id;
+		sta_entry->netif = dev;
+		hlist_add_head_rcu(&sta_entry->hlist, head);
+	} else {
+		DC_DP_ERROR("failed to allocate station entry for station id %d!!!\n", sta_id);
+	}
+
+	spin_unlock_bh(&g_sta_info.sta_hash_lock);
+
+	return sta_entry;
+}
+
+static void
+_dc_dp_rcu_free_sta_entry(struct rcu_head *head)
+{
+	dc_dp_priv_sta_entry_t *sta_entry = container_of(head, dc_dp_priv_sta_entry_t, rcu);
+	kmem_cache_free(g_sta_info_cache, sta_entry);
+}
+
+void
+_dc_dp_delete_sta_entry(dc_dp_priv_sta_entry_t *sta_entry)
+{
+	hlist_del_rcu(&sta_entry->hlist);
+	call_rcu(&sta_entry->rcu, _dc_dp_rcu_free_sta_entry);
+}
+
+int32_t
+dc_dp_sta_info_init(void)
+{
+	int32_t i;
+
+	g_sta_info_cache = kmem_cache_create("g_sta_info_cache",
+					 sizeof(dc_dp_priv_sta_entry_t),
+					 0,
+					 SLAB_HWCACHE_ALIGN, NULL);
+	if (!g_sta_info_cache)
+		return -ENOMEM;
+
+	get_random_bytes(&g_sta_info_salt, sizeof(g_sta_info_salt));
+
+	spin_lock_init(&g_sta_info.sta_hash_lock);
+	for (i = 0; i < STA_HASH_SIZE; i++) {
+		INIT_HLIST_HEAD(&g_sta_info.sta_hash[i]);
+	}
+
+	return 0;
+}
+
+void
+dc_dp_sta_info_exit(void)
+{
+	kmem_cache_destroy(g_sta_info_cache);
+}
diff --git a/include/net/directconnect_dp_api.h b/include/net/directconnect_dp_api.h
new file mode 100755
--- /dev/null
+++ b/include/net/directconnect_dp_api.h
@@ -0,0 +1,1340 @@
+#ifndef _UGW_DIRECTCONNECT_DP_API_H_
+#define _UGW_DIRECTCONNECT_DP_API_H_
+
+#include <net/datapath_api.h>
+
+/** \file directconnect_dp_api.h  This file defines all the APIs and associated data structures for DirectConnect (DC) compliant peripherals. */
+
+/** \defgroup DirectConnect_Datapath_Driver_Defines Direct Connect Defines
+  \brief This section groups all the constant defines used in DirectConnect data structures.
+*/
+
+/** \defgroup DirectConnect_Datapath_Driver_Enums Direct Connect Enums
+  \brief This section groups all the enumeration definitons used in DirectConnect data structures.
+*/
+
+/** \defgroup DirectConnect_Datapath_Driver_Unions Direct Connect Unions
+  \brief This section groups all the Union type data structures definitons used in DirectConnect.
+*/
+
+/** \defgroup DirectConnect_Datapath_Driver_Structs Direct Connect Structures
+  \brief This section groups all the Struct type data structures definitons used in DirectConnect.
+*/
+
+/** \defgroup DirectConnect_Datapath_Driver_APIs Direct Connect APIs
+  \brief This section groups all the APIs definitons used in DirectConnect.
+*/
+
+/** \defgroup DirectConnect_Datapath_Driver_Power_Management_Wrapper_APIs  Direct Connect Power Management APIs
+  \brief This section provides all the Power Management Wrapper API
+*/
+
+/** \addtogroup DirectConnect_Datapath_Driver_Defines */
+/* @{ */
+
+/**
+  \brief DMA1-TX DMA default data buffer size
+*/
+#define DC_DP_DMA_BUF_SIZE_DEFAULT		2048
+
+/**
+  \brief Multicast (MC) module register request
+*/
+#define DC_DP_F_MC_REGISTER				0x01
+
+/**
+  \brief Multicast module de-register request
+*/
+#define DC_DP_F_MC_DEREGISTER			0x02
+
+/**
+  \brief A new multicast group membership add request
+*/
+#define DC_DP_MC_F_ADD					0x01
+
+/**
+  \brief An existing multicast group membership delete request
+*/
+#define DC_DP_MC_F_DEL					0x02
+
+/**
+  \brief WLAN Number of WiFi WMM Class/TID
+*/
+#define DC_DP_MAX_WIFI_CLASS			8
+
+/**
+  \brief Power Saving (Cpufreq) callback register request
+*/
+#define DC_DP_F_PS_REGISTER				0x01
+
+/**
+  \brief Power Saving (PS) callback de-register request
+*/
+#define DC_DP_F_PS_DEREGISTER			0x02
+
+/**
+  \brief Power Saving (PS) notifier list type - Transition Notifier
+*/
+#define DC_DP_PS_TRANSITION_NOTIFIER	(0)
+/**
+  \brief Power Saving (PS) notifier list type - Policy Notifier
+*/
+#define DC_DP_PS_POLICY_NOTIFIER		(1)
+
+/** \brief PS (CPUFreq) Operation Success */
+#define DC_DP_PS_SUCCESS				0
+/** \brief PS (CPUFreq) Operation Denied */
+#define DC_DP_PS_DENIED					1
+/** \brief Called function just return without doing anything; used only in callback functions */
+#define DC_DP_PS_NOACTIVITY				3
+/** \brief It is used if callback function is not defined */
+#define DC_DP_PS_NOTDEFINED				4
+
+/**
+  \brief PS (Cpufreq) notifier list Add Operation
+*/
+#define DC_DP_PS_LIST_ADD				1
+/**
+  \brief PS (Cpufreq) notifier list Delete Operation
+*/
+#define DC_DP_PS_LIST_DEL				0
+
+/* @} */
+
+
+/** \addtogroup DirectConnect_Datapath_Driver_Enums */
+/* @{ */
+
+/** \brief Definition of the IP Type used.
+*/
+typedef enum {
+  /** IPv4 Type selector */
+	IPV4 = 0,
+  /** IPv6 Type selector */
+	IPV6 = 1,
+  /** None IP selector */
+	INVALID,
+} dc_dp_iptype_t;
+
+/** \brief Classification Location - GSW-L (LAN2LAN) or GSW-R (All traffic) device.
+    Used by \ref dc_dp_class_rule_t. */
+typedef enum {
+	DC_DP_GSWR_INGRESS=0, 	/*!< GSWIP-R ingress traffic*/
+	DC_DP_GSWL_INGRESS=1	/*!< GSWIP-L ingress traffic*/
+} dc_dp_class_devingress_t;
+
+/** \brief Classification Rule Category.
+    Used by \ref dc_dp_class_rule_t. */
+typedef enum {
+	DC_DP_CAT_NONE=0,	/*!< DP category none */
+	DC_DP_CAT_FILTER,	/*!< DP category filter */
+	DC_DP_CAT_VLAN,	/*!< DP category VLAN */
+	DC_DP_CAT_FWD,		/*!< DP category forward */
+	DC_DP_CAT_USQOS,	/*!< DP category US QOS */
+	DC_DP_CAT_DSQOS,	/*!< DP category DS QOS */
+	DC_DP_CAT_MGMT,	/*!< DP category Management */
+	DC_DP_CAT_LRO,		/*!< DP category LRO */
+	DC_DP_CAT_TUN,		/*!< DP category TUNNEL */
+	DC_DP_CAT_MAX		/*!< DP category MAX*/
+} dc_dp_class_category_t;
+
+/** \brief Classification Rule Sub-Category.
+    Used by \ref dc_dp_class_rule_t. */
+typedef enum {
+	DC_DP_SUBCAT_NONE=0,		/*!< DP sub category none */
+	DC_DP_SUBCAT_WLAN_FILTER,	/*!< DP category wlan filter */
+	DC_DP_SUBCAT_MAX			/*!< DP category max */
+} dc_dp_class_sub_category_t;
+
+/** \brief Classification Learning Action Configuration.
+    Used by \ref dc_dp_class_action_t. */
+typedef enum {
+	DC_DP_LEARNING_DISABLE=0,		/*!< DP class action learning disable */
+	DC_DP_LEARNING_REGULAR=1,		/*!< DP class action learning regular (enable) */
+	DC_DP_LEARNING_FORCE_NOT = 2,	/*!< DP class action learning force not*/
+	DC_DP_LEARNING_FORCE = 3		/*!< DP class action Forced Learning */
+} dc_dp_class_action_learning_t;
+
+/** \brief Classification Metering Action Configuration.
+    Used by \ref dc_dp_class_action_t. */
+typedef enum {
+	DC_DP_METER_DISABLE = 0,	/*!< DP class action meter disable */
+	DC_DP_METER_REGULAR = 1,	/*!< DP class action meter regular (enable) */
+	DC_DP_METER_1 = 2,			/*!< DP class action single meter */
+	DC_DP_METER_1_2 = 3		/*!< DP class action pair of cascaded meters */
+} dc_dp_class_action_meter_t;
+
+/** \brief Classification TrafficClass (TC) Action Configuration.
+    Used by \ref dc_dp_class_action_t. */
+typedef enum {
+	DC_DP_TRAFFIC_CLASS_DISABLE = 0,		/*!< DP class action trafficclass disable */
+	DC_DP_TRAFFIC_CLASS_REGULAR = 1,		/*!< DP class action trafficclass regular */
+	DC_DP_TRAFFIC_CLASS_ALTERNATIVE = 2	/*!< DP class action trafficclassalternative */
+} dc_dp_class_action_trafficclass_t;
+
+/** \brief Classification Interrupt Action Configuration.
+    Used by \ref dc_dp_class_action_t. */
+typedef enum {
+	DC_DP_IRQ_DISABLE = 0,		/*!< DP class action irq diasble */
+	DC_DP_IRQ_REGULAR = 1,		/*!< DP class action irq regular */
+	DC_DP_IRQ_EVENT = 2		/*!< DP class action irq event */
+} dc_dp_class_action_irq_t;
+
+/** \brief Classification Cross State Action Configuration.
+    Used by \ref dc_dp_class_action_t. */
+typedef enum {
+	DC_DP_CROSS_STATE_DISABLE = 0,	/*!< DP class action crossstate disable*/
+	DC_DP_CROSS_STATE_REGULAR = 1,	/*!< DP class action crossstate regular */
+	DC_DP_CROSS_STATE_CROSS = 2	/*!< DP class action crossstate cross*/
+} dc_dp_class_action_crossstate_t;
+
+/** \brief Classification Critical Frame Action Configuration.
+    Used by \ref dc_dp_class_action_t. */
+typedef enum {
+	DC_DP_FRAME_DISABLE = 0,		/*!< DP class action criticalframe disable */
+	DC_DP_FRAME_REGULAR = 1,		/*!< DP class action criticalframe regular */
+	DC_DP_FRAME_CRITICAL = 2		/*!< DP class action criticalframe critical*/
+} dc_dp_class_action_criticalframe_t;
+
+/** \brief Classification Timestamp Action Configuration.
+    Used by \ref dc_dp_class_action_t. */
+typedef enum {
+	DC_DP_TIMESTAMP_DISABLE = 0,	/*!< DP class action timestamp disable */
+	DC_DP_TIMESTAMP_REGULAR = 1,	/*!< DP class action timestamp regular */
+	DC_DP_TIMESTAMP_STORED = 2		/*!< DP class action timestamp stored */
+} dc_dp_class_action_timestamp_t;
+
+/** \brief Classification PortMap Action Configuration.
+    Used by \ref dc_dp_class_action_t. */
+typedef enum {
+	DC_DP_PORTMAP_DISABLE = 0,					/*!< DP class action portmap disable */
+	DC_DP_PORTMAP_REGULAR = 1,					/*!< DP class action portmap  regular*/
+	DC_DP_PORTMAP_DISCARD = 2,					/*!< DP class action portmap discard*/
+	DC_DP_PORTMAP_CPU = 3,						/*!< DP class action portmap CPU*/
+	DC_DP_PORTMAP_ALTERNATIVE = 4,				/*!< DP class action portmap alternative*/
+	DC_DP_PORTMAP_MULTICAST_ROUTER = 5,		/*!< DP class action portmap router*/
+	DC_DP_PORTMAP_MULTICAST_HW_TABLE = 6,		/*!< DP class action portmap hw table*/
+	DC_DP_PORTMAP_ALTERNATIVE_VLAN = 7,		/*!< DP class action portmap VLAN*/
+	DC_DP_PORTMAP_ALTERNATIVE_STAG_VLAN = 8	/*!< DP class action portmap STAG VLAN*/
+} dc_dp_class_action_portmap_t;
+
+/** \brief Classification VLAN Action Configuration.
+    Used by \ref dc_dp_class_action_t. */
+typedef enum {
+	DC_DP_VLAN_DISABLE = 0,		/*!< DP class action vlan disable*/
+	DC_DP_VLAN_REGULAR = 1,		/*!< DP class action vlan regular*/
+	DC_DP_VLAN_ALTERNATIVE = 2		/*!< DP class action vlan alternative*/
+} dc_dp_class_action_vlan_t;
+
+/** \brief Classification Port Filter Action Type.
+    Used by \ref dc_dp_class_action_t. */
+typedef enum {
+	DC_DP_PORT_FILTER_ACTION_UNUSED = 0,	/*!< DP class action portfilter disabled*/
+	DC_DP_PORT_FILTER_ACTION_1 = 1,		/*!< DP class action portfilter action 1*/
+	DC_DP_PORT_FILTER_ACTION_2 = 2,		/*!< DP class action portfilter action 2*/
+	DC_DP_PORT_FILTER_ACTION_3 = 3,		/*!< DP class action portfilter action 3*/
+	DC_DP_PORT_FILTER_ACTION_4 = 4,		/*!< DP class action portfilter action 4*/
+	DC_DP_PORT_FILTER_ACTION_5 = 5,		/*!< DP class action portfilter action 5*/
+	DC_DP_PORT_FILTER_ACTION_6 = 6			/*!< DP class action portfilter action 6*/
+} dc_dp_class_action_portfilter_t;
+
+/** \brief Classification Action Interface Type.
+    Used by \ref dc_dp_class_action_t. */
+typedef enum {
+	DC_DP_IF_CATEGORY_ETHLAN, /*!< Ethernet LAN interface category. */
+	DC_DP_IF_CATEGORY_ETHWAN, /*!< Ethernet WAN interface category. */
+	DC_DP_IF_CATEGORY_PTMWAN, /*!< xDSL PTM WAN interface category. */
+	DC_DP_IF_CATEGORY_ATMWAN, /*!< xDSL ATM WAN interface category. */
+	DC_DP_IF_CATEGORY_LTEWAN, /*!< LTE WAN interface category. */
+	DC_DP_IF_CATEGORY_WLANDP, /*!< WLAN in Directpath interface category. */
+	DC_DP_IF_CATEGORY_WLANNDP, /*!< WLAN in Non-directpath interface category. */
+	DC_DP_IF_CATEGORY_LOCAL, /*!< Local interface category. */
+	DC_DP_IF_CATEGORY_MAX /*!< Max interface category count. */
+} dc_dp_class_action_iftype_t;
+
+/** \brief Processing Path Selectors. (None, 1, 2, or Both)
+    Used by \ref dc_dp_class_action_t. */
+typedef enum {
+	DC_DP_PROCESSING_PATH_UNUSED = 0, 	/*!< DP class action processing path disabled*/
+	DC_DP_PROCESSING_PATH_1 = 1,		/*!< DP class action processing path-1*/
+	DC_DP_PROCESSING_PATH_2 = 2, 		/*!< DP class action processing path-2*/
+	DC_DP_PROCESSING_PATH_1_N_2 = 3 		/*!< DP class action processing path-1 & -2*/
+} dc_dp_class_action_processingpath_t;
+
+/** \brief Cross VLAN action in classification rule.
+    Used by \ref dc_dp_class_action_t. */
+typedef enum {
+	DC_DP_CROSS_VLAN_DISABLE = 0,	/*!< DP class action crossvlan disabled*/
+	DC_DP_CROSS_VLAN_REGULAR = 1,	/*!< DP class action crossvlan regular*/
+	DC_DP_CROSS_VLAN_CROSS = 2		/*!< DP class action crossvlan cross*/
+} dc_dp_class_action_crossvlan_t;
+
+/** \brief Rule selection for IPv4/IPv6.
+    Used by \ref dc_dp_class_pattern_t. */
+typedef enum
+{
+	/** Rule Pattern for IP selection disabled. */
+	DC_DP_PCE_IP_DISABLED  = 0,
+	/** Rule Pattern for IPv4. */
+	DC_DP_PCE_IP_V4    = 1,
+	/** Rule Pattern for IPv6. */
+	DC_DP_PCE_IP_V6    = 2
+} dc_dp_pce_ip_t;
+
+/** \brief Definition of power management module identifier
+*/
+typedef enum {
+	DC_DP_PS_MODULE_CPU	,
+	DC_DP_PS_MODULE_WLAN	,
+	DC_DP_PS_MODULE_VE	,
+	DC_DP_PS_MODULE_PPE	,
+	DC_DP_PS_MODULE_SWITCH,
+	DC_DP_PS_MODULE_UART	,
+	DC_DP_PS_MODULE_GPTC	,
+	DC_DP_PS_MODULE_PCIE	,
+	DC_DP_PS_MODULE_USB	,
+	DC_DP_PS_MODULE_DEU	,
+	DC_DP_PS_MODULE_DP	,	/*Direct Path driver*/
+	DC_DP_PS_MODULE_DPL	,	/*Direct Path Lib*/
+	DC_DP_PS_MODULE_ETH	,	/*Ethernet driver*/
+	DC_DP_PS_MODULE_PATM	,	/*PTM/ATM driver*/
+	DC_DP_PS_MODULE_I2C	,
+	DC_DP_PS_MODULE_ID_MAX,
+} dc_dp_power_module_t;
+
+/** \brief Definition of power management state
+*/
+typedef enum dc_dp_ps_state {
+	/** Power State Invalid. */
+	DC_DP_PS_UNDEF,
+	/** Power State D0. normal operation freq */
+	DC_DP_PS_D0,
+	/** Power State D1.  intermediate freq */
+	DC_DP_PS_D1,
+	/** Power State D2.  intermediate freq */
+	DC_DP_PS_D2,
+	/** Power State D3. lowest freq */
+	DC_DP_PS_D3,
+	/** Power State don't care */
+	DC_DP_PS_D0D3,
+	/** Power State BOOST highest freq, time limited because of thermal aspects */
+	DC_DP_PS_BOOST,
+} dc_dp_power_state_t;
+
+/* @} */
+
+
+/** \addtogroup DirectConnect_Datapath_Driver_Unions */
+/* @{ */
+
+/** \brief This is a union to describe the IPv4 and IPv6 Address in numeric representation.
+		   Used by multiple Structures and APIs. The member selection would be based upon \ref dc_dp_pce_ip_t */
+typedef union
+{
+   /** Describe the IPv4 address.
+       Only used if the IPv4 address should be read or configured.
+       Cannot be used together with the IPv6 address fields. */
+   uint32_t  ipv4;
+   /** Describe the IPv6 address.
+       Only used if the IPv6 address should be read or configured.
+       Cannot be used together with the IPv4 address fields. */
+   uint16_t  ipv6[8];
+} dc_dp_ip_t;
+
+/* @} */
+
+
+/** \addtogroup DirectConnect_Datapath_Driver_Structs */
+/* @{ */
+
+/** \brief  Rx function callback - basic data struct for ACA Peripherals.
+   \param[in] rx_if  Rx If netdevice pointer
+   \param[in] tx_if  Tx If netdevice pointer - optional
+   \param[in] rx_subif  Rx SubIf pointer
+   \param[in] skb  Pointer to packet buffer, like sk_buff
+   \param[in] len  Length of the packet (optional as also present in skb->len)
+   \return 0 if OK / -1 if error
+   \note The receive callback is must to register and is invoked by DirectConnect datapath driver to pass the packets to the peripheral driver
+*/
+typedef int32_t (*dc_dp_rx_fn_t)(struct net_device *rxif, struct net_device *txif, dp_subif_t *rx_subif, struct sk_buff *skb, int32_t len); /*!< Rx function callback */
+
+/**
+   \brief   Get Meta-SubInterface Integer Indentifier (e.g. Station Id) callback
+   \param[in] port_id  Port Id of port through which dst MAC address mac_addr can be reached [optional]
+   \param[in] netif  Network interface through which packet to dst MAC address mac_addr will be transmitted
+   \param[in] mac_addr  MAC Address of Station
+   \param[out] meta_sub_id  Meta Sub Interface Id (e.g. STA Id) returned
+   \return 0 if OK, -1 on ERROR
+*/
+typedef int32_t (*dc_dp_get_netif_subinterface_fn_t)(int32_t port_id, struct net_device *netif, char *mac_addr, uint32_t *subinterface); /*!< Get Meta SubInterface Id callback. */
+
+typedef struct dc_dp_recovery_stats dc_dp_recovery_stats_t; /* forward declaration */
+/**
+   \brief   Get ring/Buffer recovery stats callback
+   \param[in] netif  Pointer to Linux netdevice structure
+   \param[in] port_id  PMAC port number
+   \param[out] stats  Pointer to dc_dp_recovery_stats_t structure
+   \param[in] flags  Reserved for future use
+   \return 0 if OK, -1 on ERROR
+   \note Optional recovery stats callback. The DC datapath driver can tally up the buffer and
+   ring stats on the DC peripheral and on the host SoC side, and trigger recovery - for exampe,
+   through rebooting system if significant buffrs lost
+*/
+typedef int32_t (*dc_dp_get_recovery_stats_fn_t)(struct net_device *netif, int32_t port_id, dc_dp_recovery_stats_t *stats, uint32_t flags);
+
+/**
+   \brief DirectConnect Datapath Driver Registration Callback.
+*/
+typedef struct dc_dp_cb {
+	dc_dp_rx_fn_t rx_fn;   /*!< Rx function callback */
+	dp_stop_tx_fn_t stop_fn;  /*!< Stop Tx function callback for Tx flow control - Optional (NULL) */
+	dp_restart_tx_fn_t restart_fn;  /*!< Start Tx function callback for Tx flow control - Optional (NULL)*/
+	dc_dp_get_netif_subinterface_fn_t get_subif_fn;  /*!< Get Subinterface metaid callback */
+#define get_staid_fn get_subif_fn
+	dp_reset_mib_fn_t reset_mib_fn;  /*!< reset registered device's network mib counters */
+	dp_get_mib_fn_t get_mib_fn;  /*!< reset registered device's network mib counters */
+	dc_dp_get_recovery_stats_fn_t recovery_fn; /*!< Get Recovery related stats */
+} dc_dp_cb_t;
+
+/**
+   \brief DirectConnect Buffer pools/Chunks Data structure.
+*/
+typedef struct dc_dp_buf_pool {
+	void *pool; /*!< Pointer to pool */
+	uint32_t size; /*!< Size of pool in bytes */
+} dc_dp_buf_pool_t;
+
+/**
+   \brief DirectConnect Datapath Driver Resource structure
+*/
+typedef struct dc_dp_res {
+	int32_t num_bufpools; /*!< Number of buffer pools/chunks allocated for the desired no of buffers */
+	dc_dp_buf_pool_t *buflist; /*!< Allocated list of buffer chunks from which packet buffers are carved out.
+									Caller needs to free the memory given by buflist pointer. */
+	uint32_t num_dma_desc; /*!< Number of DMA descriptors to be programmed to Tx DMA channel of PAE */
+	void *dmatx_ring_base; /*!< Physical Base address of the DMA ring */
+	void *cbm_dequeue_base; /*!< CBM Dequeue Port Base address for DirectConnect Dequeue Port */
+	uint32_t num_dequeue_bufs; /*!< Number of Dequeue descriptors in ring. 32 in DirectConnect Dequeue port, even more for FW based
+								    additional DirectConnect support */
+	void *cbm_buf_free_base; /*!< CBM Buffer Free port Base address for DirectConnect Buffer Free Port */
+	uint32_t num_free_bufs; /*!< Number of free buffer descriptors in ring. 32 in DirectConnect Buffer Free port, even more for FW
+								 based additional DirectConnect support. */
+} dc_dp_res_t;
+
+/** \brief  Multicast module callback to add/delete a mcast group membership to/from a DirectConnect interface.
+   \param[in] grp_id  Multicast group id.
+   \param[in] dev  Registered net device.
+   \param[in] mc_stream  Multicast stream information.
+   \param[in] flags  :
+       DC_DP_MC_F_ADD - Add a new mcast group membership to a DirectConnect interface.
+       DC_DP_MC_F_DEL - Delete an existing mcast group membership from a DirectConnect interface.
+   \return none
+   \note Group Identifier is allocated and managed by Multicast Subsystem.
+*/
+typedef void (*dc_dp_mcast_callback_fn_t)(uint32_t grp_id, struct net_device *dev, void *mc_stream, uint32_t flags);
+
+/**
+   \brief IP address data structure - used in Multicast registration.
+*/
+typedef struct dc_dp_ip_addr {
+	dc_dp_iptype_t ip_type; /*!< IPv4 or IPv6 Type */
+	union {
+		struct in_addr ip4_addr; /*!< IPv4 address */
+		struct in6_addr ip6_addr; /*!< IPv6 address */
+	} u;  /*!< Union name u */
+} dc_dp_ip_addr_t;
+
+/**
+   \brief Mutlicast stream (5-tuple) structure
+*/
+typedef struct dc_dp_mcast_stream {
+	struct net_device *mem_dev;	/*!< Member Netdevice */
+	dc_dp_ip_addr_t src_ip; /*!< Source ip : can be ipv4 or ipv6 */
+	dc_dp_ip_addr_t dst_ip; /*!< Destination ip - GA : can be ipv4 or ipv6 */
+	uint32_t proto;	/*!< Protocol type : Mostly UDP for Multicast */
+	uint32_t src_port; /*!< Source port */
+	uint32_t dst_port; /*!< Destination port */
+	uint8_t mac_addr[MAX_ETH_ALEN]; /*!< Member MAC address */
+} dc_dp_mcast_stream_t;
+
+/** \brief Classification Rule's matching Pattern Configuration data structure. */
+typedef struct dc_dp_class_pattern {
+   /** Rule Index */
+   int32_t	index;
+
+   /** Index is used (enabled) or set to unused (disabled) */
+   bool	enable;
+
+   /** Port ID used  for ingress packet classification */
+   bool	port_id_enable;
+   /** Port ID value of incoming packets used for classification */
+   uint8_t	port_id;
+   /** Exclude Port Id Value - When set exclusion of specified port_id takes effect. */
+   bool	port_id_exclude;
+
+   /** Incoming Sub-Interface ID Enable */
+   bool	subif_id_enable;
+   /** Incoming Sub-Interface ID value */
+   uint16_t	subif_id;
+   /** Exclude of specified Sub-Interface Id value in subif_id */
+   bool	subif_id_exclude;
+
+   /** DSCP value used */
+   bool	dscp_enable;
+   /** DSCP value */
+   uint8_t		dscp;
+   /** Exclude (Outer) DSCP value */
+   bool	dscp_exclude;
+
+   /** Inner DSCP value */
+   bool	inner_dscp_enable;
+   /** Inner DSCP value */
+   uint8_t		inner_dscp;
+   /** Exclude of Inner DSCP (inner_dscp) value */
+   bool	inner_dscp_exclude;
+
+   /** CTAG VLAN PCP value used */
+   bool	pcp_enable;
+   /** CTAG VLAN PCP value */
+   uint8_t		pcp;
+   /* Exclude CTAG  value */
+//   bool	ctags_exclude;
+   /** Exclude CTAG PCP & DEI value */
+   bool	ctag_pcp_dei_exclude;
+
+   /** STAG VLAN PCP/DEI value used */
+   bool	stag_pcp_dei_enable;
+   /** STAG VLAN PCP value */
+   uint8_t		stag_pcp_dei;
+   /* Exclude STAG  value */
+//   bool	stag_exclude;
+   /** Exclude STAG PCP & DEI value */
+   bool	stag_pcp_dei_exclude;
+
+   /** Packet length used for classification */
+   bool	pkt_lng_enable;
+   /** Packet length in bytes */
+   uint16_t		pkt_lng;
+   /** Packet length Range (from pkt_lng to pkt_lng_range) */
+   uint16_t		pkt_lng_range;
+   /** Exclude of Packet Length or range value */
+   bool	pkt_lng_exclude;
+
+   /** Destination MAC address used */
+   bool	mac_dst_enable;
+   /** Destination MAC address */
+   uint8_t		mac_dst[6];
+   /** Destination MAC address nibble mask.
+       Please clear the bits of the nibbles that are not marked out and set all other bits.
+       The LSB bit represents the lowest data nibble, the next bit the next nibble,
+       and so on. */
+   uint16_t	mac_dst_mask;
+   /** Exclude Destination MAC Address */
+   bool	dst_mac_exclude;
+
+   /** Source MAC address used */
+   bool	mac_src_enable;
+   /** Source MAC address */
+   uint8_t	mac_src[6];
+   /** Source MAC address nibble mask.
+       Please clear the bits of the nibbles that are not marked out and set all other bits.
+       The LSB bit represents the lowest data nibble, the next bit the next nibble,
+       and so on. */
+   uint16_t	mac_src_mask;
+   /** Exclude Source MAC Address */
+   bool	src_mac_exclude;
+
+   /** MSB Application field used */
+   bool	app_data_msb_enable;
+   /** MSB Application field.
+       The first 2 bytes of the packet content following the IP header
+       for TCP/UDP packets (source port field), or the first 2 bytes of packet content
+       following the Ethertype for non-IP packets. Any part of this
+       content can be masked-out by a programmable bit
+       mask 'app_mask_range_msb'. */
+   uint16_t	app_data_msb;
+   /** MSB Application mask/range selection.
+       If set to TRUE, the field 'app_mask_range_msb' is used as a
+       range parameter, otherwise it is used as a nibble mask field. */
+   bool	app_mask_range_msb_select;
+   /** MSB Application mask/range. When used as a range parameter,
+       1 bit represents 1 nibble mask of the 'app_data_msb' field.
+       Please clear the bits of the nibbles that are not marked out and set all other bits.
+       The LSB bit represents the lowest data nibble, the next bit the next nibble,
+       and so on. */
+   uint16_t	app_mask_range_msb;
+   /** MSB Application Data Exclude */
+   bool	app_msb_exclude;
+
+   /** LSB Application used */
+   bool	app_data_lsb_enable;
+   /** LSB Application field.
+       The following 2 bytes of the packet behind the 'app_data_msb' field.
+       This is the destination port field for TCP/UDP packets,
+       or byte 3 and byte 4 of the packet content following the Ethertype
+       for non-IP packets. Any part of this content can be masked-out
+       by a programmable bit mask 'app_mask_range_lsb'. */
+   uint16_t	app_data_lsb;
+   /** LSB Application mask/range selection.
+       If set to TRUE, the field 'app_mask_range_lsb' is used as
+       a range parameter, otherwise it is used as a nibble mask field. */
+   bool	app_mask_range_lsb_select;
+   /** LSB Application mask/range. When used as a range parameter,
+       1 bit represents 1 nibble mask of the 'app_data_lsb' field.
+       Please clear the bits of the nibbles that are not marked out and set all other bits.
+       The LSB bit represents the lowest data nibble, the next bit the next nibble,
+       and so on. */
+   uint16_t	app_mask_range_lsb;
+   /** LSB Application Data Exclude */
+   bool	app_lsb_exclude;
+
+   /** Destination IP Selection. */
+   dc_dp_pce_ip_t	dst_ip_select;
+   /** Destination IP */
+   dc_dp_ip_t	dst_ip;
+   /** Destination IP Nibble Mask.
+       1 bit represents 1 nibble mask of the 'dst_ip' field.
+       Please clear the bits of the nibbles that are not marked out and set all other bits.
+       The LSB bit represents the lowest data nibble, the next bit the next nibble,
+       and so on. */
+   uint32_t	dst_ip_mask;
+   /** Exclude Destination IP Value */
+   bool	dst_ip_exclude;
+
+   /** Inner Destination IP Selection. */
+   dc_dp_pce_ip_t	inner_dst_ip_select;
+   /** Inner Destination IP*/
+   dc_dp_ip_t	inner_dst_ip;
+   /** Inner Destination IP Nibble Mask.
+       1 bit represents 1 nibble mask of the 'inner_dst_iP' field.
+       Please clear the bits of the nibbles that are not marked out and set all other bits.
+       The LSB bit represents the lowest data nibble, the next bit the next nibble,
+       and so on. */
+   uint32_t	inner_dst_ip_mask;
+   /** Exclude Inner Destination IP Value */
+   bool	inner_dst_ip_exclude;
+
+   /** Source IP Selection. */
+   dc_dp_pce_ip_t	src_ip_select;
+   /** Source IP */
+   dc_dp_ip_t	src_ip;
+   /** Source IP Nibble Mask.
+       1 bit represents 1 nibble mask of the 'src_ip' field.
+       Please clear the bits of the nibbles that are not marked out and set all other bits.
+       The LSB bit represents the lowest data nibble, the next bit the next nibble,
+       and so on. */
+   uint32_t	src_ip_mask;
+   /** Exclude Source IP Value */
+   bool	src_ip_exclude;
+
+   /** Inner Source IP Selection. */
+   dc_dp_pce_ip_t	inner_src_ip_select;
+   /** Inner Source IP */
+   dc_dp_ip_t	inner_src_ip;
+   /** Inner Src IP Nibble Mask.
+       1 bit represents 1 nibble mask of the 'inner_src_ip' field.
+       Please clear the bits of the nibbles that are not marked out and set all other bits.
+       The LSB bit represents the lowest data nibble, the next bit the next nibble,
+       and so on. */
+   uint32_t	inner_src_ip_mask;
+   /** Exclude Inner Source IP Value */
+   bool	inner_src_ip_exclude;
+
+   /** Ethertype used. */
+   bool	ether_type_enable;
+   /** Ethertype */
+   uint16_t	ether_type;
+   /** Ethertype Mask.
+       1 bit represents 1 nibble mask of the 'ether_type' field.
+       Please clear the bits of the nibbles that are not marked out and set all other bits.
+       The LSB bit represents the lowest data nibble, the next bit the next nibble,
+       and so on. */
+   uint16_t	ether_type_mask;
+   /** Exclude for Ether Type Value. */
+   bool	ether_type_exclude;
+
+   /** IP protocol used */
+   bool	protocol_enable;
+   /** IP protocol Value */
+   uint8_t	protocol;
+   /** IP protocol Mask.
+       1 bit represents 1 nibble mask of the 'protocol' field.
+       Please clear the bits of the nibbles that are not marked out and set all other bits i.e. a set bit 1 indicates that bit is masked out (not compared).
+       The LSB bit represents the lowest data nibble, the next bit the next nibble,
+       and so on. */
+   uint8_t	protocol_mask;
+   /** Exclude for IP Protocol Value. */
+   bool	protocol_exclude;
+
+   /** Inner IP protocol used. */
+   bool	inner_protocol_enable;
+   /** Inner IP protocol Value. */
+   uint8_t	inner_protocol;
+   /** Inner IP protocol Bit Mask. */
+   uint8_t	inner_protocol_mask;
+   /** Exclude for Inner IP Protocol Value. */
+   bool	inner_protocol_exclude;
+
+   /** PPPoE used. */
+   bool	session_id_enable;
+   /** PPPoE Session Id */
+   uint16_t	session_id;
+   /** Exclude for PPPoE Session Value. */
+   bool	session_id_exclude;
+
+   /** PPP Protocol used */
+   bool	ppp_protocol_enable;
+   /** PPP Protocol Value */
+   uint16_t	ppp_protocol;
+   /** PPP protocol Bit Mask (Positional bit 1 signifies masking of corresponding bit value in ppp_protocol). */
+   uint16_t	ppp_protocol_mask;
+   /** Exclude for PPP Protocol Value. */
+   bool	ppp_protocol_exclude;
+
+   /** VLAN ID (CVID) used. */
+   bool	vid_enable;
+   /** VLAN ID (CVID) */
+   uint16_t	vid;
+   /** VID mask/range selection.
+       If set to 1, the field 'vid_range' is used as
+       a range parameter, otherwise it is used as a mask field. */
+   bool	vid_range_select;
+   /** VLAN ID Range (CVID). Gets used as mask to nVid in case vid_range_select is set to 0 */
+   uint16_t	vid_range;
+   /** Exclude for VLAN Id (CVLAN). */
+   bool	vid_exclude;
+
+   /** STAG VLAN ID used. */
+   bool	slan_vid_enable;
+   /** STAG VLAN ID */
+   uint16_t	slan_vid;
+   /** Exclude for SVLAN Id (SVLAN). */
+   bool	slan_vid_exclude;
+
+   /** Payload-1 used */
+   bool	payload1_src_enable;
+   /** Payload-1 Value (16-bits) */
+   uint16_t	payload1;
+   /** Payload1 mask/range selection.
+       If set to TRUE, the field 'payload1' is used as
+       a range parameter, otherwise it is used as a bit mask field. */
+   bool	payload1_mask_range_select;
+   /** Payload-1 Bit mask */
+   uint16_t	payload1_mask;
+   /** Exclude Payload-1 */
+   bool	payload1_exclude;
+
+   /** Payload-2 */
+   bool	payload2_src_enable;
+   /** Payload-2 Value (16-bits) */
+   uint16_t	payload2;
+   /** Payload2 mask/range selection.
+       If set to TRUE, the field 'payload2' is used as
+       a range parameter, otherwise it is used as a bit mask field. */
+   bool	payload2_mask_range_select;
+   /** Payload-2 Bit mask */
+   uint16_t	payload2_mask;
+   /** Exclude Payload-2 */
+   bool	payload2_exclude;
+
+   /** Parser Flag LSW (Bit position 15 to 0) is used */
+   bool	parser_flag_lsb_enable;
+   /** Parser Flag LSW Value - each bit indicates specific parsed result */
+   uint16_t	parser_flag_lsb;
+   /** Corresponding LSW Parser Flag Mask - when the bit is set to 1 corresponding flag gets masked out (ignored). */
+   uint16_t	parser_flag_lsb_mask;
+   /** Exclude for Parser Flag LSW specified in parser_flag_lsb */
+   bool	parser_flag_lsb_exclude;
+
+   /** Parser Flag MSW (Bit 31 to 16) is used */
+   bool	parser_flag_msb_enable;
+   /** Parser Flag MSW Value - each bit indicates specific parsed result */
+   uint16_t	parser_flag_msb;
+   /** Corresponding Parser Flag MSW Mask - when the bit is set to 1 corresponding flag gets masked out (ignored). */
+   uint16_t	parser_flag_msb_mask;
+   /** Exclude for Parser Flag MSW specified in parser_flag_msb */
+   bool	parser_flag_msb_exclude;
+} dc_dp_class_pattern_t;
+
+/** \brief Classification Rule's filter action data structure. */
+typedef struct dc_dp_class_filter_action {
+	dc_dp_class_action_portfilter_t portfilter;	/*!< DP class filter action portfilter*/
+	dc_dp_class_action_crossstate_t crossstate;	/*!< DP class filter action crossstate*/
+} dc_dp_class_filter_action_t;
+
+/** \brief Classification Rule's VLAN action data structure. */
+typedef struct dc_dp_class_vlan_action {
+	dc_dp_class_action_vlan_t cvlan;			/*!< DP class vlan_action cvlan*/
+	uint16_t vlan_id;					/*!< DP class vlan_action vlanid*/
+	uint8_t fid;						/*!< DP class vlan_action fid*/
+	dc_dp_class_action_vlan_t svlan;			/*!< DP class vlan_action svlan*/
+	uint16_t svlan_id;					/*!< DP class vlan_action svlanid*/
+	dc_dp_class_action_crossvlan_t cross_vlan;		/*!< DP class vlan_action crossvlan*/
+	uint8_t cvlan_ignore;					/*!< DP class vlan_action cvlan ignore*/
+} dc_dp_class_vlan_action_t;
+
+/** \brief Classification Rule's Forwarding action data structure. */
+typedef struct dc_dp_class_action_fwd {
+	dc_dp_class_action_learning_t learning;		/*!< DP class action_fwd learning*/
+	uint8_t port_trunk;				/*!< DP class action_fwd port trunk*/
+	dc_dp_class_action_portmap_t portmap;		/*!< DP class action_fwd portmap*/
+	uint32_t forward_portmap;			/*!< DP class action_fwd forward_portmap*/
+	uint16_t forward_subifid;			/*!< DP class action_fwd forward_subifid*/
+	uint8_t routextid_enable;			/*!< DP class action_fwd routextid_enable*/
+	uint8_t routextid;				/*!< DP class action_fwd routextid*/
+	uint8_t rtdestportmaskcmp;			/*!< DP class action_fwd rt dest port compare*/
+	uint8_t rtsrcportmaskcmp;			/*!< DP class action_fwd rt src port compare*/
+	uint8_t rtdstipmaskcmp;				/*!< DP class action_fwd rt dest ip compare*/
+	uint8_t rtsrcipmaskcmp;				/*!< DP class action_fwd rt src ip compare*/
+	uint8_t rtinneripaskey;				/*!< DP class action_fwd rt inner ip compare enable*/
+	uint8_t rtaccelenable;				/*!< DP class action_fwd rt acceleration enable*/
+	uint8_t rtctrlenable;				/*!< DP class action_fwd rt ctrl enable*/
+	dc_dp_class_action_processingpath_t processpath;  /*!< DP class action_fwd processing path*/
+} dc_dp_class_action_fwd_t;
+
+/** \brief Classification Rule's QoS action data structure. */
+typedef struct dc_dp_class_action_qos {
+	dc_dp_class_action_trafficclass_t trafficclass;	/*!< DP class action_qos trafficclass*/
+	uint8_t alt_trafficclass;				/*!< DP class action_qos alternate traffic class*/
+	dc_dp_class_action_meter_t meter;			/*!< DP class action_qos meter*/
+	uint8_t meterid;					/*!< DP class action_qos meter id*/
+	dc_dp_class_action_criticalframe_t criticalframe;	/*!< DP class action_qos critical frame*/
+	uint8_t remark;						/*!< DP class action_qos remark*/
+	uint8_t remarkpcp;					/*!< DP class action_qos remark pcp*/
+	uint8_t new_pcp;					/*!< DP class action_qos new pcp*/
+	uint8_t remark_stagpcp;					/*!< DP class action_qos remark stag pcp*/
+	uint8_t remark_stagdei;					/*!< DP class action_qos remark stag dei*/
+	uint8_t remark_dscp;					/*!< DP class action_qos remark dscp*/
+	uint8_t remark_class;					/*!< DP class action_qos remark class*/
+	uint8_t flowid_enabled;					/*!< DP class action_qos flowid enable*/
+	uint16_t flowid; 					/*!< DP class action_qos flowid*/
+} dc_dp_class_action_qos_t;
+
+/** \brief Classification Rule's Management (such as IRQ & Timestamp) action data structure. */
+typedef struct dc_dp_class_action_mgmt {
+	dc_dp_class_action_irq_t irq;					/*!< DP class action_mgmt irq action*/
+	dc_dp_class_action_timestamp_t timestamp;		/*!< DP class action_mgmt timestamp action*/
+} dc_dp_class_action_mgmt_t;
+
+/** \brief Classification Rule's Overall grouped action data structure. */
+typedef struct dc_dp_class_action {
+	dc_dp_class_filter_action_t filter_action;	/*!< DP filtering actions */
+	dc_dp_class_vlan_action_t vlan_action;		/*!< DP VLAN actions */
+	dc_dp_class_action_fwd_t fwd_action;		/*!< DP forwarding actions */
+	dc_dp_class_action_qos_t qos_action;		/*!< DP QOS actions */
+	dc_dp_class_action_mgmt_t mgmt_action;		/*!< DP Management actions */
+	dc_dp_class_action_iftype_t iftype;		/*!< DP Interface type actions */
+	uint8_t rmon_action;				/*!< DP RMON actions */
+	uint8_t rmon_id;				/*!< DP RMON id to be used */
+} dc_dp_class_action_t;
+
+/** \brief Classification Rule Overall Configuration data structure. */
+typedef struct dc_dp_class_rule {
+	dc_dp_class_devingress_t in_dev; 		/*!< DP ingress device id*/
+	uint8_t order;					/*!< DP order within the category selected */
+	dc_dp_class_category_t category;		/*!< DP category of the classifier rule */
+	dc_dp_class_sub_category_t subcategory;	/*!< DP subcategory of the classifier rule */
+	char owner[32];							/*!< DP owner of the rule to be configures */
+	dc_dp_class_pattern_t pattern;			/*!< DP pattern of the rule to be configured */
+	dc_dp_class_action_t action;			/*!< DP action of the rule to be confiured */
+	uint16_t uidx;							/*!< DP unique ID returned by the classification API upon successful addition of rule */
+} dc_dp_class_rule_t;
+
+/**
+   \brief DirectConnect Power Saving (CoC) Thresholds values for different power states.
+*/
+typedef struct dc_dp_ps_threshold {
+	int32_t th_d0; /*!< Power State D0 (Highest Power) Threshold Level */
+	int32_t th_d1; /*!< Power State D1 Threshold Level */
+	int32_t th_d2; /*!< Power State D2 Threshold Level */
+	int32_t th_d3; /*!< Power State D3 (Lowest Power) Threshold Level */
+} dc_dp_ps_threshold_t;
+
+/**
+   \brief DirectConnect Power State Module Information to be used for registration.
+*/
+typedef struct dc_dp_ps_module_info {
+    struct list_head        list;  /*!< List Head - TBC */
+    char                *module_name;  /*!< Power State registeirng module Name */
+    dc_dp_power_module_t     pmcu_module; /*!< Enum of Modules */
+    uint32_t            pmcu_module_nr; /*!< PMCU Module NR number */
+    int32_t             power_feature_stat; /*!< Current Power State */
+    int32_t (*dc_dp_ps_state_get) (dc_dp_power_state_t *pmcu_state);  /*!< Callback to query current power state */
+    int32_t (*dc_dp_ps_state_switch) (int32_t pmcu_pwr_state_ena); /*!< Callback to enable power state */
+} dc_dp_ps_module_info_t;
+
+/**
+   \brief Wake-on-LAN Config Structure
+*/
+typedef struct dc_dp_wol_cfg {
+	uint8_t wol_mac[MAX_ETH_ALEN]; /*!< Wake-on-LAN MAC address - part of Magic packet (16 times repeat)*/
+	bool wol_passwd_enable; /*!< Wake-on-LAN password enable */
+	uint8_t wol_passwd[MAX_ETH_ALEN]; /*!< Wake-on-LAN password */
+} dc_dp_wol_cfg_t;
+
+/**
+   \brief Ring recovery stats Structure
+   \note If stats difference exceeds pre-configured threshold the system would be rebooted to recover from loss of descriptiors.
+*/
+typedef struct dc_dp_recovery_stats {
+	uint32_t cbm_announced_desc_cum; /*!< Announced cumulative desc count by UMT*/
+	uint32_t cbm_to_be_pulled_counter; /*!< desc count to be pulled from DC CBM Dequeue port */
+	uint32_t cbm_to_be_freed_buffer; /*!< buffer count to be freed to DC CBM Dequeue Free port */
+	uint32_t dc_rx_outstanding_desc; /*!< DC client driver/fw HD ring outstanding decsriptors-
+					 Add num_desc when written to HD ring and subtract num_desc based on UMT message received. */
+} dc_dp_recovery_stats_t;
+
+/* @} */
+
+
+/** \addtogroup DirectConnect_Datapath_Driver_APIs */
+/* @{ */
+
+/** \brief  DirectConnect Datapath Allocate Data structure port may map to an exclusive netdevice
+    like in the case of ethernet LAN ports.	In other cases like WLAN, the physical port is a Radio port,
+    while netdevices are Virtual Access Points (VAPs). In this case, the AP netdevice can be passed.
+    Alternately, driver_port & driver_id will be used to identify this port.
+   \param[in] owner  Kernel module pointer which owns the port
+   \param[in] dev_port  Physical Port Number of this device managed by the driver
+   \param[in] dev  Pointer to Linux netdevice structure (optional)
+   \param[in] port_id  Optional port_id number requested. Usually, 0 and allocated by driver
+   \param[in] flags  : Use Datapath driver flags for Datapath Port Alloc
+   	-  DC_DP_F_FAST_WLAN : Allocate the port
+   	-  DC_DP_F_DEREGISTER : Deallocate the already allocated port
+   \return  Returns PMAC Port number / -1 if error
+*/
+int32_t
+dc_dp_alloc_port (
+	struct module *owner,
+	uint32_t dev_port,
+	struct net_device *dev,
+	int32_t port_id,
+	uint32_t flags
+);
+
+/** \brief  Higher layer Driver Datapath registration API
+   \param[in] owner  Kernel module pointer which owns the port
+   \param[in] port_id  Datapath Port Id (PMAC Port No) on which to register
+   \param[in] dev  Pointer to Linux netdevice structure
+   \param[in] datapathcb  Callback registration structure
+   \param[in] num_bufs_req  Number of Tx buffers to allocate (DirectConnect Peripheral -> GRX500 SoC PAE direction)
+   \param[in] umt_base  Base address of UMT write location (in DirectConnect HW memory)
+   \param[in] umt_len  Number of bytes of UMT message to write to umt_base
+   \param[out] resources  Buffer, DMA ring and CBM port resource addresses
+   \param[in] flags  : Special input flags to alloc routine
+   		- DP_F_DEREGISTER : Deregister the device
+   \return 0 if OK / -1 if error
+   \note This is the first registration to be invoked by any ACA peripheral. Subsequently additional registrations like Multicast, Ring-Recovery or Power Saving (PS) to be done.
+*/
+int32_t
+dc_dp_register_dev (
+	struct module *owner,
+	uint32_t port_id,
+	struct net_device *dev,
+	dc_dp_cb_t *datapathcb,
+	uint32_t num_bufs_req,
+	void *umt_base,
+	int32_t umt_len,
+	dc_dp_res_t *resources,
+	uint32_t flags
+);
+
+/** \brief  Allocates datapath subif number to a sub-interface netdevice.
+    Sub-interface value must be passed to the driver.
+    The port may map to an exclusive netdevice like in the case of ethernet LAN ports.
+   \param[in] owner  Kernel module pointer which owns the port
+   \param[in] dev  Pointer to Linux netdevice structure
+   \param[in,out] subif_id  Pointer to subif_id structure including port_id
+   \param[in] flags :
+       DP_F_DEREGISTER - De-register already registered subif/vap
+   \return 0 if OK / -1 if error
+   \note Sub-Interface is applicable for logical or virtual interfaces liek VAP (SSID) or VLAN.
+*/
+int32_t
+dc_dp_register_subif (
+	struct module *owner,
+	struct net_device *dev,
+	dp_subif_t *subif_id,
+	uint32_t flags
+);
+
+/** \brief  Transmit packet to low-level Datapath driver
+   \param[in] rx_if  Rx If netdevice pointer - optional
+   \param[in] rx_subif  Rx SubIf pointer - optional
+   \param[in] skb  Pointer to packet buffer like sk_buff
+   \param[in] len  Length of packet to transmit
+   \param[in] flags : Reserved for future use.
+   \return 0 if OK / -1 if error
+   \note Either rx_if or rx_subif would be passed in this routine.
+*/
+int32_t
+dc_dp_xmit (
+	struct net_device *rx_if,
+	dp_subif_t *rx_subif,
+	struct sk_buff *skb,
+	int32_t len,
+	uint32_t flags
+);
+
+/** \brief  Set port id in DMA Desc DWORD 1 (DW1).
+   \param[in,out] desc_dw  Pointer to descriptor DWORD
+   \param[in] port_id  port identifier value
+   \param[in] flags : Reserved
+   \return  0 if OK / -1 if error
+   \note  This utility function will set and return DMA Decriptor's DWord-1 from given port value.
+*/
+static inline int32_t
+dc_dp_set_ep_pkt (
+	uint32_t *desc_dw,
+	int32_t port_id,
+	uint32_t flags
+)
+{
+	struct dma_tx_desc_1 *desc_1 = (struct dma_tx_desc_1 *) desc_dw;
+
+	if (!desc_1) {
+		return DP_FAILURE;
+	}
+
+	desc_1->field.ep = port_id;
+
+	return DP_SUCCESS;
+}
+
+/** \brief  Get port id from DMA Desc DWORD 1 (DW1).
+   \param[in] desc_dw  Pointer to descriptor DWORD
+   \param[out] port_id  Port identifier value
+   \param[in] flags  : Reserved
+   \return  0 if OK / -1 if error
+   \note This utility funciton will extract port identifier fromgiven DMA Descriptor's DWord-1.
+*/
+static inline int32_t
+dc_dp_get_ep_pkt (
+	uint32_t *desc_dw,
+	int32_t *port_id,
+	uint32_t flags
+)
+{
+	struct dma_tx_desc_1 *desc_1 = (struct dma_tx_desc_1 *) desc_dw;
+
+	if (!desc_1 || !port_id) {
+		return DP_FAILURE;
+	}
+
+	*port_id = desc_1->field.ep;
+
+	return DP_SUCCESS;
+}
+
+/** \brief  Set sub-interface id in DMA Desc DWORD 0 (DW0).
+   \param[in,out] desc_dw  Pointer to descriptor DWORD
+   \param[in] subif_id  subinterface id value
+   \param[in] flags : Reserved
+   \return  0 if OK / -1 if error
+   \note This funciton will return DMA Descriptior's DWord-0 by setting the given sub-interface id value.
+*/
+static inline int32_t
+dc_dp_set_subifid_pkt (
+	uint32_t *desc_dw,
+	int32_t subif_id,
+	uint32_t flags
+)
+{
+	struct dma_tx_desc_0 *desc_0 = (struct dma_tx_desc_0 *) desc_dw;
+
+	if (!desc_0) {
+		return DP_FAILURE;
+	}
+
+	desc_0->field.dest_sub_if_id = subif_id;
+
+	return DP_SUCCESS;
+}
+
+/** \brief  Get sub-interface id from DMA Desc DWORD 0 (DW0).
+   \param[in] desc_dw  Pointer to descriptor DWORD
+   \param[out] subif_id  subinterface id value
+   \param[in] flags  : Reserved
+   \return  0 if OK / -1 if error
+   \note This utility function will extract sub-interface id from given DMA Descriptor DWord-0.
+*/
+static inline int32_t
+dc_dp_get_subifid_pkt (
+	uint32_t *desc_dw,
+	int32_t *subif_id,
+	uint32_t flags
+)
+{
+	struct dma_tx_desc_0 *desc_0 = (struct dma_tx_desc_0 *) desc_dw;
+
+	if (!desc_0 || !subif_id) {
+		return DP_FAILURE;
+	}
+
+	*subif_id = desc_0->field.dest_sub_if_id;
+
+	return DP_SUCCESS;
+}
+
+/** \brief  Disconnect a particular MAC addr or an network device - remove all MAC table entries
+    and/or routing sessions which use the specified MAC address.
+   \param[in] netif  netdevice pointer through which all entries must be removed from acceleration - optional
+   \param[in] subif_id  Sub-interface identifier to remove on netif
+   \param[in] mac_addr  MAC address to remove
+   \param[in] flags  Reserved for future use
+   \return 0 if OK / -1 if error
+   \note One of subif_id, mac_addr or netif must be specified
+*/
+int32_t
+dc_dp_disconn_if (
+	struct net_device *netif,
+	dp_subif_t *subif_id,
+	uint8_t mac_addr[MAX_ETH_ALEN],
+	uint32_t flags
+);
+
+/** \brief  Register/De-register a DirectConnect interface to MCAST helper module
+   \param[in] dev  Net device to be registered, e.g., wlan0_0.
+   \param[in] owner  Kernel module pointer which owns the port.
+   \param[in] cb  Multicast callback function.
+   \param[in] flags  :
+       DC_DP_F_MC_REGISTER - Register a DirectConnect interface.
+       DC_DP_F_MC_DEREGISTER - De-register already registered DirectConnect interface.
+   \return 0 if OK / -1 if error
+   \note
+*/
+int32_t
+dc_dp_register_mcast_module (
+	struct net_device *dev,
+	struct module *owner,
+	dc_dp_mcast_callback_fn_t cb,
+	uint32_t flags
+);
+
+/** \brief  Provide a Priority (802.1D Priority) to WMM Class/TID map for the
+ * given WiFi Radio/net_device
+   \param[in] port_id  Port Id on which mapping is to be updated
+   \param[in] netif  Pointer to stack network interface structure on which mapping is to be updated
+   \param[in] prio2wmm Array of priority to WMM Class/TID mapping values
+   \return 0 if OK / -1 if error
+   \note  One of port_id or netif must be specified
+   \note The DC driver must  configure the Egress PMAC table to mark the WMM Class/TID in the descriptor DW1[7:4]
+*/
+int32_t
+dc_dp_map_prio_wmm_class (
+	int32_t	port_id,
+	struct net_device *netif,
+	uint8_t prio2wmm[DC_DP_MAX_WIFI_CLASS]
+);
+
+/** \brief  Provide WMM AC/TID mapping for a given packet
+   \param[in] port_id  Port Id on which mapping is to be updated
+   \param[in] dst_netif  Pointer to stack network interface structure
+   \param[in] skb  : pointer to network packet/sk_buff structure
+   \return  WMM value marked if successful, -1 on error
+   \note The WAVE/ DC Datapath driver needs to use skb->extmark/skb->priority to mark and return WMM Class/TID
+*/
+/* static inline */int32_t
+dc_dp_mark_pkt_wmm (
+	int32_t	port_id,
+	struct net_device *dst_netif,
+	struct sk_buff *skb
+);
+
+/** \brief  Get DirectConnect interface statistics. Either netdevice or subif_id has to be passed to this API.
+   \param[in] netif  Pointer to Linux netdevice structure
+   \param[in] subif_id  Datapath Port Number and Sub-Interface (if applicable else -1).
+   \param[out] if_stats  Pointer to Linux rtnl_link_stats64 structure
+   \param[in] flags  :
+       DP_F_SUBIF_LOGICAL - to be used when the interface is subif type
+   \return 0 if OK / -1 if error
+*/
+int32_t
+dc_dp_get_netif_stats (
+	struct net_device *netif,
+	dp_subif_t *subif_id,
+	struct rtnl_link_stats64 *if_stats,
+	uint32_t flags
+);
+
+/** \brief  Clear DirectConnect interface statistics. Either netdevice or subif_id has to be passed.
+   \param[in] netif  Pointer to Linux netdevice structure
+   \param[in] subif_id  Datapath Port Number and Sub-Interface (if applicable else -1).
+   \param[in] flags  Flag Type to pass additional info such as
+       DP_F_SUBIF_LOGICAL - to be used when the interface is subif type
+   \return 0 if OK / -1 if error
+*/
+int32_t
+dc_dp_clear_netif_stats (
+	struct net_device *netif,
+	dp_subif_t *subif_id,
+	uint32_t flags
+);
+
+/** \brief  Add a classifier rule entry - pattern and action to the table of the packet classification engine.
+   The pattern part describes the pattern to identify an incoming packet to which the dedicated actions should be applied.
+   \param[in] rule  Pointer to Classifier
+   \param[in] flags  Reserved for future use
+   \return 0 if OK / -1 if error
+*/
+int32_t
+dc_dp_add_class_rule (
+	dc_dp_class_rule_t *rule,
+	uint32_t flags
+);
+
+/** \brief  Modify a classifier rule entry - pattern and action to the table of the packet classification engine.
+   The pattern part describes the parameter to identify an incoming packet to which the dedicated actions should be applied.
+   \param[in] rule  Pointer to Classifier
+   \param[in] flags  Reserved for future use
+   \return 0 if OK / -1 if error
+*/
+int32_t
+dc_dp_mod_class_rule (
+	dc_dp_class_rule_t *rule,
+	uint32_t flags
+);
+
+/** \brief  Delete a classifier rule entry for given reference.
+   \param[in] rule  Pointer to Classifier with key of (Category & Order values) or Switch PCE Rule Index
+   \param[in] flags  Reserved for future use
+   \return 0 if OK / -1 if error
+*/
+int32_t
+dc_dp_del_class_rule (
+	dc_dp_class_rule_t *rule,
+	uint32_t flags
+);
+
+/** \brief  Read a classifier rule entry for given reference.
+   \param[in,out] rule  Pointer to Classifier
+   \param[in] flags  Reserved for future use
+   \return 0 if OK / -1 if error
+*/
+int32_t
+dc_dp_get_class_rule (
+	dc_dp_class_rule_t *rule,
+	uint32_t flags
+);
+
+/** \brief  Get Wake-on-LAN configuration.
+   \param[out] cfg  Wake-on-LAN Configuration
+   \param[in] flags  : Reserved
+   \return 0 if OK / -1 if error
+*/
+int32_t
+dc_dp_get_wol_cfg (
+	dc_dp_wol_cfg_t *cfg,
+	uint32_t flags
+);
+
+/** \brief  Set Wake-on-LAN config
+   \param[in] cfg  Wake-on-LAN Configuration
+   \param[in] flags  : Reserved
+   \return  0 if OK / -1 if error
+*/
+int32_t
+dc_dp_set_wol_cfg (
+	dc_dp_wol_cfg_t *cfg,
+	uint32_t flags
+);
+
+/** \brief  Enable/Disable Wake-on-LAN functionality
+   \param[in] port_id  PMAC port number
+   \param[in] enable  Enable Wake-on-LAN if 1, disable Wake-on-LAN if 0
+   \return  0 if OK / -1 if error
+*/
+int32_t
+dc_dp_set_wol_ctrl (
+	int32_t port_id,
+	uint32_t enable
+);
+
+/** \brief  Get Wake-on-LAN status
+   \param[in] port_id  PMAC port number
+   \return  1 if Enabled/ 0 if Disabled / -1 if error
+*/
+int32_t
+dc_dp_get_wol_ctrl_status (
+	int32_t port_id
+);
+
+/* @} */
+
+
+/** \addtogroup DirectConnect_Datapath_Driver_Power_Management_Wrapper_API */
+/* @{ */
+
+/** \brief  Register/De-register to/from the CPUFreq framework
+   \param[in] nb  Notifier function to register
+   \param[in] notify_type  Notifier list type (DC_DP_PS_TRANSITION_NOTIFIER / DC_DP_PS_POLICY_NOTIFIER)
+   \param[in] flags  :
+   	-  DC_DP_F_PS_REGISTER : Register to CPUFreq framework
+   	-  DC_DP_F_PS_DEREGISTER : De-register from CPUFreq framework
+   \return  0 if OK / < 0 if error
+*/
+int32_t
+dc_dp_register_power_notifier (
+	struct notifier_block *nb,
+	uint32_t notify_type,
+	uint32_t flags
+);
+
+/** \brief  Request new system power state
+   \param[in] module  Module identifier
+   \param[in] module_nr Module Number
+   \param[in] new_state  Power state as defined in dc_dp_power_state_t
+   \return  DC_DP_PS_SUCCESS / DC_DP_PS_DENIED / DC_DP_PS_NOACTIVITY / DC_DP_PS_NOTDEFINED
+*/
+int32_t
+dc_dp_req_power_state (
+	dc_dp_power_module_t module,
+	uint8_t module_nr,
+	dc_dp_power_state_t new_state
+);
+
+/** \brief  Get Power Mgmt polling period per module
+   \param[in] module  Module identifier
+   \param[in] module_nr
+   \return  Polling period
+*/
+int32_t
+dc_dp_get_ps_poll_period (
+	dc_dp_power_module_t module,
+	uint8_t module_nr
+);
+
+/** \brief  Get power state related threshold values per module
+   \param[in] module  Module identifier
+   \param[in] module_nr
+   \return  dc_dp_ps_threshold_t pointer if OK / NULL if error
+*/
+dc_dp_ps_threshold_t *
+dc_dp_get_ps_threshold (
+	dc_dp_power_module_t module,
+	uint8_t module_nr
+);
+
+/** \brief  Add/Delete module from CPUFReq module list
+   \param[in] head  Module list head pointer
+   \param[in] add  DC_DP_PS_LIST_ADD / DC_DP_PS_LIST_DEL
+   \return  0 if OK / < 0 if error
+*/
+int32_t
+dc_dp_mod_ps_list (
+	struct list_head *head,
+	int32_t add
+);
+
+/** \brief  Convert frequency to power state
+   \param[in] freq_khz frequency (in khz)
+   \return  power state if OK / < 0 if error
+*/
+dc_dp_power_state_t
+dc_dp_get_ps_from_khz (
+	uint32_t freq_khz
+);
+
+/* @} */
+
+#endif /* _UGW_DIRECTCONNECT_DP_API_H_ */
diff --git a/include/net/ltq_wave500_dp_api.h b/include/net/ltq_wave500_dp_api.h
new file mode 100644
--- /dev/null
+++ b/include/net/ltq_wave500_dp_api.h
@@ -0,0 +1,567 @@
+#ifndef _UGW_WAVE500_DP_API_H_
+#define _UGW_WAVE500_DP_API_H_
+
+#include <net/directconnect_dp_api.h>
+
+/** \file ltq_wave500_dp_api.h  This file defines all the APIs and associated data structures for WAVE500 peripheral. */
+
+/** \defgroup WAVE500_Datapath_Driver_Defines WAVE500 Defines
+  \brief This section groups all the constant defines used in WAVE500 data structures.
+*/
+
+/** \defgroup WAVE500_Datapath_Driver_Enums WAVE500 Enums
+  \brief This section groups all the enumeration definitons used in WAVE500 data structures.
+*/
+
+/** \defgroup WAVE500_Datapath_Driver_Unions WAVE500 Unions
+  \brief This section groups all the Union type data structures definitons used in WAVE500.
+*/
+
+/** \defgroup WAVE500_Datapath_Driver_Structs WAVE500 Structures
+  \brief This section groups all the Struct type data structures definitons used in WAVE500.
+*/
+
+/** \defgroup WAVE500_Datapath_Driver_APIs WAVE500 APIs
+  \brief This section groups all the APIs definitons used in WAVE500.
+*/
+
+/** \defgroup WAVE500_Datapath_Driver_Power_Management_Wrapper_API  WAVE500 Power Management APIs
+  \brief This section provides all the Power Management Wrapper API
+*/
+
+/** \addtogroup WAVE500_Datapath_Driver_Defines */
+/* @{ */
+
+/**
+  \brief WAVE500 DMA1-TX DMA default data buffer size
+*/
+#define WAVE500_DATA_BUF_MAX_SIZE	DC_DP_DMA_BUF_SIZE_DEFAULT
+
+/**
+  \brief WAVE500 Multicast (MC) module register request
+*/
+#define WAVE500_DP_F_MC_REGISTER	DC_DP_F_MC_REGISTER
+
+/**
+  \brief WAVE500 Multicast module de-register request
+*/
+#define WAVE500_DP_F_MC_DEREGISTER	DC_DP_F_MC_DEREGISTER
+
+/**
+  \brief WAVE500 A new multicast group membership add request
+*/
+#define WAVE500_MC_F_ADD 			DC_DP_MC_F_ADD
+
+/**
+  \brief WAVE500 An existing multicast group membership delete request
+*/
+#define WAVE500_MC_F_DEL			DC_DP_MC_F_DEL
+
+/**
+  \brief WLAN Number of WiFi WMM Class/TID
+*/
+#define WAVE500_DP_MAX_WIFI_CLASS	DC_DP_MAX_WIFI_CLASS
+
+/**
+  \brief Power Saving (Cpufreq) callback register request
+*/
+#define WAVE500_DP_F_PS_REGISTER	DC_DP_F_PS_REGISTER
+
+/**
+  \brief Power Saving (PS) callback de-register request
+*/
+#define WAVE500_DP_F_PS_DEREGISTER	DC_DP_F_PS_DEREGISTER	
+
+/**
+  \brief Power Saving (PS) notifier list type - Transition Notifier
+*/
+#define WAVE500_DP_PS_TRANSITION_NOTIFIER	DC_DP_PS_TRANSITION_NOTIFIER
+/**
+  \brief Power Saving (PS) notifier list type - Policy Notifier
+*/
+#define WAVE500_DP_PS_POLICY_NOTIFIER	DC_DP_PS_POLICY_NOTIFIER
+
+/** \brief PS (CPUFreq) Operation Success */
+#define WAVE500_DP_PS_SUCCESS	DC_DP_PS_SUCCESS
+/** \brief PS (CPUFreq) Operation Denied */
+#define WAVE500_DP_PS_DENIED		DC_DP_PS_DENIED
+/** \brief Called function just return without doing anything; used only in callback functions */
+#define WAVE500_DP_PS_NOACTIVITY	DC_DP_PS_NOACTIVITY
+/** \brief It is used if callback function is not defined */
+#define WAVE500_DP_PS_NOTDEFINED	DC_DP_PS_NOTDEFINED	
+
+/**
+  \brief PS (Cpufreq) notifier list Add Operation
+*/
+#define WAVE500_DP_PS_LIST_ADD		DC_DP_PS_LIST_ADD
+/**
+  \brief PS (Cpufreq) notifier list Delete Operation
+*/
+#define WAVE500_DP_PS_LIST_DEL		DC_DP_PS_LIST_DEL	
+
+/* @} */
+
+
+/** \addtogroup WAVE500_Datapath_Driver_Enums */
+/* @{ */
+
+/**
+  \brief WAVE500 IP Type structure
+*/
+typedef dc_dp_iptype_t wave500_dp_iptype_t;
+
+/**
+  \brief WAVE500 Classification Location - LAN2LAN (GSWIP-L) or All traffic (PAE)
+*/
+typedef dc_dp_class_devingress_t wave500_dp_class_devingress_t;
+
+/**
+  \brief WAVE500 Classification Rule Category
+*/
+typedef dc_dp_class_category_t wave500_dp_class_category_t;
+
+/**
+  \brief WAVE500 Classification Rule Sub-Category
+*/
+typedef dc_dp_class_sub_category_t wave500_dp_class_sub_category_t;
+
+/**
+  \brief WAVE500 Classification Learning Action Configuration
+*/
+typedef dc_dp_class_action_learning_t wave500_dp_class_action_learning_t;
+
+/**
+  \brief WAVE500 Classification Metering Action Configuration
+*/
+typedef dc_dp_class_action_meter_t wave500_dp_class_action_meter_t;
+
+/**
+  \brief WAVE500 Classification Action Traffic Class Configuration
+*/
+typedef dc_dp_class_action_trafficclass_t wave500_dp_class_action_trafficclass_t;
+
+/**
+  \brief WAVE500 Classification Interrupt action Configuration
+*/
+typedef dc_dp_class_action_irq_t wave500_dp_class_action_irq_t;
+
+/**
+  \brief WAVE500 Classification Cross State Action Configuration
+*/
+typedef dc_dp_class_action_crossstate_t wave500_dp_class_action_crossstate_t;
+
+/**
+  \brief WAVE500 Set subifid = subinterface[12:8]  routine
+*/
+typedef dc_dp_class_action_criticalframe_t wave500_dp_class_action_criticalframe_t;
+
+/**
+  \brief WAVE500 Classification Timestamp Action Configuration
+*/
+typedef dc_dp_class_action_timestamp_t wave500_dp_class_action_timestamp_t;
+
+/**
+  \brief WAVE500 Classification PortMap Action Configuration
+*/
+typedef dc_dp_class_action_portmap_t wave500_dp_class_action_portmap_t;
+
+/**
+  \brief WAVE500 Classification VLAN Action Configuration
+*/
+typedef dc_dp_class_action_vlan_t wave500_dp_class_action_vlan_t;
+
+/**
+  \brief WAVE500 Classification Port Filter Action Type
+*/
+typedef dc_dp_class_action_portfilter_t wave500_dp_class_action_portfilter_t;
+
+/**
+  \brief WAVE500 Classification Action Interface Type
+*/
+typedef dc_dp_class_action_iftype_t wave500_dp_class_action_iftype_t;
+
+/**
+  \brief WAVE500 Processing Path Selectors
+*/
+typedef dc_dp_class_action_processingpath_t wave500_dp_class_action_processingpath_t;
+
+/**
+  \brief WAVE500 Cross VLAN action
+*/
+typedef dc_dp_class_action_crossvlan_t wave500_dp_class_action_crossvlan_t;
+
+/**
+  \brief WAVE500 Rule selection for IPv4/IPv6
+*/
+typedef dc_dp_pce_ip_t wave500_dp_pce_ip_t;
+
+/**
+  \brief WAVE500 Power module identifier
+*/
+typedef dc_dp_power_module_t wave500_dp_power_module_t;
+
+/**
+  \brief WAVE500 Power State structure
+*/
+typedef dc_dp_power_state_t wave500_dp_power_state_t;
+
+/* @} */
+
+/** \addtogroup WAVE500_Datapath_Driver_Unions */
+/* @{ */
+
+/** \brief WAVE500 IPv4 and IPv6 address type in numeric representation */
+typedef dc_dp_ip_t wave500_dp_ip_t;
+
+/* @} */
+
+
+/** \addtogroup WAVE500_Datapath_Driver_Structs */
+/* @{ */
+
+/**
+  \brief WAVE500 Rx function callback
+*/
+typedef dc_dp_rx_fn_t wave500_dp_rx_fn_t;
+
+/*!
+   \brief   Get Station Id callback
+   \param[in] port_id  Port Id of port through which dst MAC address mac_addr can be reached [optional]
+   \param[in] netif  Network interface through which packet to dst MAC address mac_addr will be transmitted
+   \param[in] mac_addr  MAC Address of Station
+   \param[out] sta_id  Station Id returned
+   \return 0 if OK, -1 on ERROR
+*/
+typedef int32_t (*wave500_get_staid_fn_t)(int32_t port_id, struct net_device *netif, char *mac_addr, uint32_t *sta_id);
+
+/**
+  \brief WAVE500 Get Ring/Buffer recovery stats callback
+*/
+typedef dc_dp_get_recovery_stats_fn_t wave500_get_recovery_stats_fn_t;
+
+#if 0
+/**
+   \brief WAVE500 Datapath Driver Registration Callback.
+   \param rx_fn  Rx function callback
+   \param stop_fn  Stop Tx function callback for flow control
+   \param restart_fn  Start Tx function callback for flow control
+   \param get_staid_fn  Get Station Id callback for MAC address
+   \note
+*/
+typedef struct wave500_dp_cb {
+	wave500_dp_rx_fn_t rx_fn;   /*!< Rx function callback */
+	dp_stop_tx_fn_t stop_fn;  /*!< Stop Tx function callback for Tx flow control */
+	dp_restart_tx_fn_t restart_fn;  /*!< Start Tx function callback for Tx flow control */
+	wave500_get_staid_fn_t get_staid_fn;  /*!< Get Station Id callback for MAC address */
+	wave500_get_recovery_stats_fn_t recovery_fn; /*!< Get Recovery related stats */
+} wave500_dp_cb_t;
+#else /* #if 0 */
+typedef dc_dp_cb_t wave500_dp_cb_t;
+#endif /* #else */
+
+#ifdef SWAS_3_8
+/**
+  \brief WAVE500 Buffer Pool Data structure
+*/
+typedef dc_dp_buf_pool_t wave500_dp_buf_pool_t;
+#else /* #ifdef SWAS_3_8 */
+/**
+   \brief Buffer list node structure.
+   \param list  Pointer to next buffer list node
+   \param pktbuf  Pointer to buffer
+   \note
+*/
+typedef struct bufptr {
+	struct list_head list; /*!< Pointer to next buffer list node */
+	uint8_t *pktbuf; /*!< Pointer to buffer */
+} bufptr_t;
+#endif /* #else */
+
+/**
+  \brief WAVE500 Datapath Resources structure
+*/
+typedef struct wave500_dp_res {
+#ifdef SWAS_3_8
+	int32_t num_bufpools; /*!< Number of buffer pools/chunks allocated for the desired no of buffers */
+	dc_dp_buf_pool_t *buflist; /*!< Allocated list of buffer chunks from which packet buffers are carved out.
+									Caller needs to free the memory given by buflist pointer. */
+#else /* #ifdef SWAS_3_8 */
+	struct list_head *buflist; /*!< Allocate list of buffers */
+#endif /* #else */
+	uint32_t num_dma_desc; /*!< Number of DMA descriptors to be programmed to Tx DMA channel of PAE */
+	void *dmatx_ring_base; /*!< Physical Base address of the DMA ring */
+	void *cbm_dequeue_base; /*!< CBM Dequeue Port Base address for DirectConnect Dequeue Port */
+	uint32_t num_dequeue_bufs; /*!< Number of Dequeue descriptors in ring. 32 in DirectConnect Dequeue port, even more for FW based
+								    additional DirectConnect support */
+	void *cbm_buf_free_base; /*!< CBM Buffer Free port Base address for DirectConnect Buffer Free Port */
+	uint32_t num_free_bufs; /*!< Number of free buffer descriptors in ring. 32 in DirectConnect Buffer Free port, even more for FW
+								 based additional DirectConnect support. */
+} wave500_dp_res_t;
+
+/**
+  \brief WAVE500 multicast module callback
+*/
+typedef dc_dp_mcast_callback_fn_t wave500_dp_mcast_callback_fn_t;
+
+/**
+  \brief WAVE500 IP address data structure
+*/
+typedef dc_dp_ip_addr_t ip_addr_t;
+
+/**
+  \brief WAVE500 Multicast stream structure
+*/
+typedef dc_dp_mcast_stream_t mcast_stream_t;
+
+/**
+  \brief WAVE500 Classifier Pattern structure
+*/
+typedef dc_dp_class_pattern_t wave500_dp_class_pattern_t;
+
+/**
+  \brief WAVE500 Classification Action Structure
+*/
+typedef dc_dp_class_filter_action_t wave500_dp_class_filter_action_t;
+
+/**
+  \brief WAVE500 Classifier VLAN action structure
+*/
+typedef dc_dp_class_vlan_action_t wave500_dp_class_vlan_action_t;
+
+/**
+  \brief WAVE500 Classifier Action Forwarding struct
+*/
+typedef dc_dp_class_action_fwd_t wave500_dp_class_action_fwd_t;
+
+/**
+  \brief WAVE500 Classifier action QoS struct
+*/
+typedef dc_dp_class_action_qos_t wave500_dp_class_action_qos_t;
+
+/**
+  \brief WAVE500 Classification action IRQ/Timestamp struct for mgmt
+*/
+typedef dc_dp_class_action_mgmt_t wave500_dp_class_action_mgmt_t;
+
+/**
+  \brief WAVE500 Classification Overall Action struct
+*/
+typedef dc_dp_class_action_t wave500_dp_class_action_t;
+
+/**
+  \brief WAVE500 Classification Rule Overall Configuration structure
+*/
+typedef dc_dp_class_rule_t wave500_dp_class_rule_t;
+
+/**
+  \brief WAVE500 Power Saving Thresholds values for different power states
+*/
+typedef dc_dp_ps_threshold_t wave500_dc_dp_ps_threshold_t;
+
+/**
+  \brief WAVE500 Power State Module Info for registration
+*/
+typedef dc_dp_ps_module_info_t wave500_dc_dp_ps_module_info_t;
+
+/**
+  \brief WAVE500 Wake-on-LAN Structure
+*/
+typedef dc_dp_wol_cfg_t wave500_dp_wol_cfg_t;
+
+/**
+  \brief WAVE500 Ring Recovery stats Structure
+*/
+typedef dc_dp_recovery_stats_t wave500_dp_recovery_stats_t;
+
+/* @} */
+
+
+/** \addtogroup WAVE500_Datapath_Driver_APIs */
+/* @{ */
+
+/**
+  \brief WAVE500 DP Alloc port routine
+*/
+#define wave500_dp_alloc_port dc_dp_alloc_port
+
+#ifdef SWAS_3_8
+/**
+  \brief WAVE500 DP Register dev routine
+*/
+#define wave500_dp_register_dev dc_dp_register_dev
+#else /* #ifdef SWAS_3_8 */
+
+/*! \brief  Higher layer Driver Datapath registration API
+   \param[in] owner  Kernel module pointer which owns the port
+   \param[in] port_id  Datapath Port Id (PMAC Port No) on which to register
+   \param[in] dev  Pointer to Linux netdevice structure
+   \param[in] datapathcb  Callback registration structure
+   \param[in] num_bufs_req  Number of Tx buffers to allocate (WLAN -> GRX500 SoC PAE direction)
+   \param[in] umt_base  Base address of UMT write location (in WAVE500 HW memory)
+   \param[in] umt_len  Number of bytes of UMT message to write to umt_base
+   \param[out] resources  Buffer, DMA ring and CBM port resource addresses
+   \param[in] flags  : Special input flags to alloc routine
+   		- DP_F_DEREGISTER : Deregister the device
+   \return 0 if OK / -1 if error
+   \note
+*/
+int32_t
+wave500_dp_register_dev (
+	struct module *owner,
+	uint32_t port_id,
+	struct net_device *dev,
+	wave500_dp_cb_t *datapathcb,
+	uint32_t num_bufs_req,
+	void *umt_base,
+	int32_t umt_len,
+	wave500_dp_res_t *resources,
+	uint32_t flags
+);
+#endif /* #else */
+
+/**
+  \brief WAVE500 DP Register subif routine
+*/
+#define wave500_dp_register_subif dc_dp_register_subif
+
+/**
+  \brief WAVE500 DP xmit routine calling dc_dp_xmit
+*/
+#define wave500_dp_xmit dc_dp_xmit
+
+/**
+  \brief WAVE500 Set Egress Port  in packet
+*/
+#define wave500_dp_set_ep_pkt dc_dp_set_ep_pkt
+
+/**
+  \brief WAVE500 Get Egress port in packet
+*/
+#define wave500_dp_get_ep_pkt dc_dp_get_ep_pkt
+
+/**
+  \brief WAVE500 Set subifid = subinterface[12:8]  routine
+*/
+#define wave500_dp_set_subifid_pkt dc_dp_set_subifid_pkt
+
+/**
+  \brief WAVE500 Get subifid = subinterface[12:8]  routine
+*/
+#define wave500_dp_get_subifid_pkt dc_dp_get_subifid_pkt
+
+/** \brief  Disconnect a particular MAC addr - remove all MAC table entries
+    and/or routing sessions which use the specified MAC address.
+   \param[in] sta_id  Station ID to remove
+   \param[out] macaddr  MAC address to remove
+   \return 0 if OK / -1 if error
+   \note  Calls dc_dp_disconn_if() internally.
+*/
+/* static inline */int32_t
+wave500_dp_disconn_staid (
+	uint8_t sta_id,
+	uint8_t macaddr[MAX_ETH_ALEN]
+);
+
+/**
+  \brief WAVE500 Regiser Mcast Module
+*/
+#define wave500_dp_register_mcast_module dc_dp_register_mcast_module
+
+/**
+  \brief  Provide a Priority (802.1D Priority) to WMM Class/TID map for the
+  given WiFi Radio/net_device
+*/
+#define wave500_dp_map_prio_wmm_class dc_dp_map_prio_wmm_class
+
+/**
+  \brief  Provide WMM AC/TID mapping for a given packet
+*/
+#define wave500_dp_mark_pkt_wmm dc_dp_mark_pkt_wmm
+
+/**
+  \brief WAVE500 Get network interface stats
+*/
+#define wave500_dp_get_netif_stats dc_dp_get_netif_stats
+
+/**
+  \brief WAVE500 DP Clear Netif Stats
+*/
+#define wave500_dp_clear_netif_stats dc_dp_clear_netif_stats
+
+/**
+  \brief WAVE500 Add Classifier Rule
+*/
+#define wave500_dp_add_class_rule dc_dp_add_class_rule
+
+/**
+  \brief WAVE500 Modify Classifier Rule
+*/
+#define wave500_dp_mod_class_rule dc_dp_mod_class_rule
+
+/**
+  \brief WAVE500 Delete Classifier Rule
+*/
+#define wave500_dp_del_class_rule dc_dp_del_class_rule
+
+/**
+  \brief WAVE500 Get Classifier Rule
+*/
+#define wave500_dp_get_class_rule dc_dp_get_class_rule
+
+/**
+  \brief WAVE500 Get Wake on LAN config
+*/
+#define wave500_dp_get_wol_cfg dc_dp_get_wol_cfg
+
+/**
+  \brief WAVE500 Set Wake on LAN configuration
+*/
+#define wave500_dp_set_wol_cfg dc_dp_set_wol_cfg
+
+/**
+  \brief WAVE500 Set Wake on LAN enable/disable
+*/
+#define wave500_dp_set_wol_ctrl dc_dp_set_wol_ctrl
+
+/**
+  \brief WAVE500 Get Wake on LAN enable/disable
+*/
+#define wave500_dp_get_wol_ctrl_status dc_dp_get_wol_ctrl_status
+
+/* @} */
+
+/** \addtogroup WAVE500_Datapath_Driver_Power_Management_Wrapper_API */
+/* @{ */
+
+/**
+  \brief WAVE500 Register Power Mgmt Notifier (with cpufreq driver)
+*/
+#define wave500_dp_register_power_notifier dc_dp_register_power_notifier
+
+/**
+  \brief WAVE500 Request new power state
+*/
+#define wave500_dp_req_power_state dc_dp_req_power_state
+
+/**
+  \brief WAVE500 Get Power Mgmt polling period = subinterface[12:8]  routine
+*/
+#define wave500_dp_get_ps_poll_period dc_dp_get_ps_poll_period
+
+/**
+  \brief WAVE500 Get Power State thresholds
+*/
+#define wave500_dp_get_ps_threshold dc_dp_get_ps_threshold
+
+/**
+  \brief WAVE500 Add/Delete module from Power State list
+*/
+#define wave500_dp_mod_ps_list dc_dp_mod_ps_list
+
+/**
+  \brief WAVE500 Convert CPU frequency to Power state
+*/
+#define wave500_dp_get_ps_from_khz dc_dp_get_ps_from_khz
+/* @} */
+
+#endif /* _UGW_WAVE500_DP_API_H_ */
diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -771,6 +771,31 @@ static int __br_fdb_delete(struct net_br
 	return err;
 }
 
+#if ((defined(CONFIG_LTQ_PPA_API) && CONFIG_LTQ_PPA_API) || \
+	(defined(CONFIG_LTQ_PPA_API_MODULE) && CONFIG_LTQ_PPA_API_MODULE))
+int ppa_br_fdb_delete(struct net_device *dev, const unsigned char *addr)
+{
+	struct net_bridge_port *p;
+	int err;
+
+	if (!dev || !addr) {
+		return -EINVAL;
+	}
+
+	p = br_port_get_rcu(dev);
+	if (!p) {
+		pr_info("bridge: %s not a bridge port\n",
+			dev->name);
+		return -EINVAL;
+	}
+
+	err = __br_fdb_delete(p, addr, 0);
+
+	return err;
+}
+EXPORT_SYMBOL(ppa_br_fdb_delete);
+#endif
+
 /* Remove neighbor entry with RTM_DELNEIGH */
 int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 		  struct net_device *dev,
