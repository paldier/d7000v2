# HG changeset patch
# Parent 1cdecebe8a3da27995eccdc7f2a965c695e5b128

diff --git a/drivers/net/ethernet/lantiq/Makefile b/drivers/net/ethernet/lantiq/Makefile
--- a/drivers/net/ethernet/lantiq/Makefile
+++ b/drivers/net/ethernet/lantiq/Makefile
@@ -4,3 +4,4 @@ obj-$(CONFIG_LTQ_ETHSW_API) += switch-ap
 obj-$(CONFIG_LTQ_TMU) += tmu/
 obj-$(CONFIG_LTQ_CBM) += cbm/
 obj-$(CONFIG_LTQ_ETH_XRX500) += ltq_eth_drv_xrx500.o
+obj-$(CONFIG_LTQ_TOE_DRIVER) += ltq_toe_drv.o
diff --git a/drivers/net/ethernet/lantiq/ltq_toe_drv.c b/drivers/net/ethernet/lantiq/ltq_toe_drv.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/ltq_toe_drv.c
@@ -0,0 +1,2308 @@
+/******************************************************************************
+**
+** FILE NAME    : ltq_toe_drv.c
+** AUTHOR       : Suresh Nagaraj
+** DESCRIPTION  : Lantiq ToE driver for XRX500 series
+** COPYRIGHT    :       Copyright (c) 2015
+**                      Lantiq Deutschland
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date                $Author                 $Comment
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/seq_file.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/tcp.h>
+
+#include <lantiq.h>
+#include <lantiq_soc.h>
+#include <lantiq_irq.h>
+#include <lantiq_dmax.h>
+#include <net/lantiq_cbm.h>
+#include <net/lantiq_cbm_api.h>
+#include <net/datapath_api.h>
+
+#include "ltq_toe_reg.h"
+#include "ltq_toe_drv.h"
+
+#undef CONFIG_USE_SKB_FRAGS_ARRAY
+#define CONFIG_LTQ_TOE_USE_SW_POLLING
+
+#define PORT_REQ_CMD_REG0(port)  (PORT_REQ_CMD_REG0_0 + ((port))*0x20)
+#define PORT_REQ_CMD_REG1(port)  (PORT_REQ_CMD_REG1_0 + ((port))*0x20)
+#define PORT_REQ_CMD_REG2(port)  (PORT_REQ_CMD_REG2_0 + ((port))*0x20)
+#define PORT_REQ_CMD_REG3(port)  (PORT_REQ_CMD_REG3_0 + ((port))*0x20)
+#define PORT_REQ_CMD_REG4(port)  (PORT_REQ_CMD_REG4_0 + ((port))*0x20)
+#define PORT_REQ_CMD_REG5(port)  (PORT_REQ_CMD_REG5_0 + ((port))*0x20)
+#define PORT_RES_REG1(port)	(PORT_RES_REG1_0 + ((port))*0x20)
+#define PORT_RES_REG0(port)	(PORT_RES_REG0_0 + ((port))*0x20)
+
+#define LRO_FID(port)	   (LRO_FID_0 + ((port)*0x8))
+#define LRO_TO_REG(port)   (LRO_TO_REG_0 + ((port)*0x8))
+#define LRO_OC_FLAG(port,ctx)  (LRO_OC_FLAG_0 + ((port*2)+ctx)*0x100)
+#define LRO_OC_OWNER(port,ctx)  (LRO_OC_OWNER_0 + ((port*2)+ctx)*0x100)
+
+#define LRO_MAX_AGP 20
+#define PMAC_HDR_SIZE 8
+#define L2_HDR_LEN 14
+
+#define DEFAULT_WAIT_CYCLES 1000
+
+/*unsigned int toe_membase = 0xE2000000;*/
+static unsigned char __iomem *ltq_toe_membase; /* Virtual */
+/*static const unsigned char __iomem *lro_sram_membase_res0 = (unsigned char *)0xE2013000;*/
+static const unsigned char __iomem *lro_sram_membase_res0;
+/*static unsigned int lro_sram_membase_res1 = 0xE2013100;*/
+
+static struct device *g_toe_dev;
+
+#undef LRO_DEBUG
+
+#ifdef LRO_DEBUG
+#define LRO_MAX_DBG_INFO 20000
+struct lro_dbg_info {
+	u32 except_reason;
+	u32 tcp_seq_no;
+	u32 aggr_len;
+}lro_dbg_info;
+static struct lro_dbg_info dbg_info[LRO_MAX_DBG_INFO];
+u32 dbg_head = 0;
+#endif
+static unsigned int tso_num_tx[LTQ_MAX_TSO_PORTS];
+
+static unsigned char ltq_large_buf[NR_CPUS][65536]__attribute__((aligned(32)));
+unsigned char *toe_large_debug_ptr;
+static struct proc_dir_entry *g_toe_dir;
+#define LRO_MAX_EXCEPTION_COUNT 9
+static u32 lro_num_except[LRO_MAX_EXCEPTION_COUNT], lro_num_success;
+static u32 lro_budget_left[21];
+static u32 lro_num_except_entries[32];
+static u32 g_unmatched_entry;
+
+static int ltq_toe_exit(struct platform_device *pdev);
+static int tso_configure_dma(void);
+static void configure_tso(void);
+
+#ifndef CONFIG_LTQ_TOE_USE_SW_POLLING
+static void ltq_tso_tasklet(unsigned long);
+static irqreturn_t ltq_tso_tx_int(int irq, void *_port);
+static struct tasklet_struct tso_tasklet[NR_CPUS];
+#endif
+
+static void ltq_lro_tasklet(unsigned long);
+static struct tasklet_struct lro_tasklet[LTQ_MAX_LRO_PORTS];
+static struct tasklet_struct lro_exception_tasklet;
+
+static void ltq_lro_ovflow_tasklet(unsigned long);
+static struct tasklet_struct lro_ovflow_tasklet;
+
+static void configure_lro(void);
+int lro_stop_flow (int session_id, int timeout, int flags);
+int lro_start_flow (int session_id, int timeout, int flags, struct cpumask cpumask);
+static void lro_process_output_context(int port, int oc_flag_no);
+
+spinlock_t tso_tx_lock;	/*!< spin lock */
+spinlock_t tso_register_lock;
+
+#define skb_tso_size(x)       (skb_shinfo(x)->gso_size)
+
+#define ltq_toe_r32(x)			ltq_r32(ltq_toe_membase + (x))
+#define ltq_toe_w32(x, y)		ltq_w32(x, ltq_toe_membase + (y))
+#define ltq_toe_w32_mask(x, y, z)	\
+	ltq_w32_mask(x, y,  ltq_toe_membase + (z))
+
+#define	ltq_tso_w32_cmd(x, y, z)	\
+	ltq_w32(x, (ltq_tso_port[z].membase + (y*4)))
+
+#define	ltq_tso_r32(x, y)	\
+	ltq_r32(ltq_tso_port[x].membase + (y*4))
+
+#define ltq_lro_sram_mem(x, y, z) \
+	ltq_r32(lro_sram_membase_res0 + (0x150 * x) + (0xA8 * y) + (z))
+
+#define ltq_lro_sram_unmatched_mem(x, y) \
+	ltq_r32(lro_sram_membase_res0 + 0xA80 + (0x10*(x)) + (y))
+
+#define ltq_lro_sram_except_mem(x, y) \
+	ltq_r32(lro_sram_membase_res0 + 0xB00 + (0x10*x) + (y))
+
+#define toe_fill_cmd0(sphy, dphy, ie, g, chunk, len, others, port) do {   \
+  unsigned int reg=(others);                      \
+  reg = (sphy) << PORT_REQ_CMD_REG0_0_SPHY_POS |  \
+        (dphy) << PORT_REQ_CMD_REG0_0_DPHY_POS | \
+        (ie) << PORT_REQ_CMD_REG0_0_IE_POS | \
+        (g) << PORT_REQ_CMD_REG0_0_G_POS | \
+        (chunk) << PORT_REQ_CMD_REG0_0_CHUNK_SIZ_POS | \
+        (len) << PORT_REQ_CMD_REG0_0_LEN_POS | \
+        (others) ;                                        \
+ /*   printk("REG0 = %X\n", reg); */\
+		ltq_toe_w32(reg, PORT_REQ_CMD_REG0(port));  \
+}while(0)
+
+#define toe_fill_cmd1_frags(srcbuf, cachewb, port, lenn) do { \
+	  	unsigned int physaddr; \
+    if (cachewb) {  \
+		physaddr = dma_map_single(g_toe_dev, (void *) srcbuf, \
+							lenn, DMA_TO_DEVICE); \
+			if (dma_mapping_error(g_toe_dev, physaddr)) { \
+				pr_err("%s DMA map failed\n", __func__); \
+				return -1; \
+			} \
+    }\
+	/* CMD1 */  \
+	pr_debug("physical address of the src data: %d = %08x and len = %d\n", \
+					(unsigned int)srcbuf, (unsigned int)physaddr, lenn);\
+   /* printk("REG1 = %X\n", physaddr); */\
+	ltq_toe_w32(physaddr, PORT_REQ_CMD_REG1(port)); \
+}while(0) 
+
+#define toe_fill_cmd1(srcbuf, cachewb, port, lenn) do { \
+	  	unsigned int physaddr; \
+    if (cachewb) {  \
+		physaddr = dma_map_single(g_toe_dev, (void *) srcbuf, \
+							lenn, DMA_BIDIRECTIONAL); \
+			if (dma_mapping_error(g_toe_dev, physaddr)) { \
+				pr_err("%s DMA map failed\n", __func__); \
+				return -1; \
+			} \
+    }\
+	/* CMD1 */  \
+	pr_debug("physical address of the src data: %d = %08x and len = %d\n", \
+					(unsigned int)srcbuf, (unsigned int)physaddr, lenn);\
+	ltq_r32(srcbuf + lenn - 4); \
+   /* printk("REG1 = %X\n", physaddr); */\
+	ltq_toe_w32(physaddr, PORT_REQ_CMD_REG1(port)); \
+}while(0) 
+
+#define toe_fill_cmd4(buf, port) do { \
+			/* CMD4 */ \
+	    unsigned int physaddr; \
+			physaddr = CPHYSADDR((buf)); \
+			pr_debug("address of the large buffer: = %08x \n", (unsigned int)(physaddr)); \
+/*      printk("REG4 = %X\n", physaddr); */\
+			ltq_toe_w32(physaddr, PORT_REQ_CMD_REG4(port)); \
+}while(0) 
+
+#define toe_fill_cmd4_sbk(buff, port) do { \
+			/* CMD4 */ \
+			pr_debug("address of the large buffer: = %08x \n", (unsigned int)(buff)); \
+  /*    printk("REG4_skb = %X\n", buff); */\
+			ltq_toe_w32(buff, PORT_REQ_CMD_REG4(port)); \
+}while(0) 
+
+#define toe_fill_cmd2(dw0, port) do { \
+		/* CMD2 */ \
+  /*  printk("REG2 = %X\n", dw0); */\
+		ltq_toe_w32((dw0), PORT_REQ_CMD_REG2(port)); \
+}while(0)
+
+#define toe_fill_cmd3(dw1, port) do { \
+		/* CMD3 */ \
+  /*  printk("REG3 = %X\n", dw1); */\
+		ltq_toe_w32((dw1), PORT_REQ_CMD_REG3(port)); \
+}while(0)
+
+#define toe_fill_cmd5(tso_mss, tirq, port) do { \
+    unsigned int reg; \
+		/* CMD5 */ \
+		/* Set the segment size */ \
+		pr_debug("segment size: %d \n", skb_tso_size(skb)); \
+    reg = tso_mss << PORT_REQ_CMD_REG5_0_SEG_LEN_POS; \
+		/* Enable TIRQ */ \
+    reg |= (tirq) << PORT_REQ_CMD_REG5_0_TIRQ_POS; \
+    /* Flag TSO to kickstart processing of this CMD */ \
+    /* reg |= 1 << PORT_REQ_CMD_REG5_0_OWN_POS; */ \
+    /* Write to CMD5 reg */ \
+  /*  printk("REG5 = %X\n", reg); */\
+		ltq_toe_w32(reg, PORT_REQ_CMD_REG5(port)); \
+}while(0)
+
+#define toe_get_cmd_own(port) { \
+  unsigned long OwnReg;  \
+  do { \
+			OwnReg = ltq_toe_r32(PORT_REQ_CMD_REG5(port));  \
+   /*   printk("Own = %X\n", OwnReg); */\
+  }while (!test_bit(31, &OwnReg)); \
+}
+
+
+enum tso_desc_base {
+	/* TSO Port 0 */
+	DMA3_TOE_MEMCPY_CHAN_4_DESC_BASE = 0xA2010600,
+	DMA3_TOE_MEMCPY_CHAN_5_DESC_BASE = 0xA2010620,
+	DMA3_TOE_MEMCPY_CHAN_0_DESC_BASE = 0xA2014800,
+	DMA3_TOE_MEMCPY_CHAN_1_DESC_BASE = 0xA2014820,
+	DMA3_TOE_MEMCPY_CHAN_2_DESC_BASE = 0xA2014840,
+	DMA3_TOE_MEMCPY_CHAN_3_DESC_BASE = 0xA2014860,
+	DMA3_TOE_MEMCPY_CHAN_8_DESC_BASE = 0xA2015800,
+	DMA3_TOE_MEMCPY_CHAN_9_DESC_BASE = 0xA2015810,
+	DMA3_TOE_MEMCPY_CHAN_10_DESC_BASE = 0xA2015820,
+	DMA3_TOE_MEMCPY_CHAN_11_DESC_BASE = 0xA2015830,
+
+	/* TSO Port 1 */
+	DMA3_TOE_MEMCPY_CHAN_6_DESC_BASE = 0xA2010700,
+	DMA3_TOE_MEMCPY_CHAN_7_DESC_BASE = 0xA2010720,
+	DMA3_TOE_MEMCPY_CHAN_30_DESC_BASE = 0xA2014900,
+	DMA3_TOE_MEMCPY_CHAN_31_DESC_BASE = 0xA2014920,
+	DMA3_TOE_MEMCPY_CHAN_32_DESC_BASE = 0xA2014940,
+	DMA3_TOE_MEMCPY_CHAN_33_DESC_BASE = 0xA2014960,
+	DMA3_TOE_MEMCPY_CHAN_38_DESC_BASE = 0xA2015900,
+	DMA3_TOE_MEMCPY_CHAN_39_DESC_BASE = 0xA2015910,
+	DMA3_TOE_MEMCPY_CHAN_40_DESC_BASE = 0xA2015920,
+	DMA3_TOE_MEMCPY_CHAN_41_DESC_BASE = 0xA2015930,
+
+	/* TSO Port 2 */
+	DMA3_TOE_MEMCPY_CHAN_34_DESC_BASE = 0xA2010800,
+	DMA3_TOE_MEMCPY_CHAN_35_DESC_BASE = 0xA2010820,
+	DMA3_TOE_MEMCPY_CHAN_54_DESC_BASE = 0xA2014a00,
+	DMA3_TOE_MEMCPY_CHAN_55_DESC_BASE = 0xA2014a20,
+	DMA3_TOE_MEMCPY_CHAN_42_DESC_BASE = 0xA2014a40,
+	DMA3_TOE_MEMCPY_CHAN_43_DESC_BASE = 0xA2014a60,
+	DMA3_TOE_MEMCPY_CHAN_48_DESC_BASE = 0xA2015a00,
+	DMA3_TOE_MEMCPY_CHAN_49_DESC_BASE = 0xA2015a10,
+	DMA3_TOE_MEMCPY_CHAN_50_DESC_BASE = 0xA2015a20,
+	DMA3_TOE_MEMCPY_CHAN_51_DESC_BASE = 0xA2015a30,
+
+	/* TSO Port 3 */
+	DMA3_TOE_MEMCPY_CHAN_36_DESC_BASE = 0xA2010900,
+	DMA3_TOE_MEMCPY_CHAN_37_DESC_BASE = 0xA2010920,
+	DMA3_TOE_MEMCPY_CHAN_62_DESC_BASE = 0xA2014b00,
+	DMA3_TOE_MEMCPY_CHAN_63_DESC_BASE = 0xA2014b20,
+	DMA3_TOE_MEMCPY_CHAN_52_DESC_BASE = 0xA2014b40,
+	DMA3_TOE_MEMCPY_CHAN_53_DESC_BASE = 0xA2014b60,
+	DMA3_TOE_MEMCPY_CHAN_58_DESC_BASE = 0xA2015b00,
+	DMA3_TOE_MEMCPY_CHAN_59_DESC_BASE = 0xA2015b10,
+	DMA3_TOE_MEMCPY_CHAN_60_DESC_BASE = 0xA2015b20,
+	DMA3_TOE_MEMCPY_CHAN_61_DESC_BASE = 0xA2015b30
+};
+
+#if 0
+static irqreturn_t lro_port_except_isr (int irq, void *priv)
+{
+	//u32 int_status,except_flag, oc_flag_0, oc_flag_1;
+	u32 int_status,except_flag;
+
+	pr_debug ("%s called with irq: %d\n", __func__, irq);
+
+	/* Mask the interrupt */
+	ltq_toe_w32_mask(0, (1 << TOE_INT_MASK_LRO_EXP_POS), TOE_INT_MASK);
+
+	/* Read the Exception flag */
+	except_flag = ltq_toe_r32(LRO_EXP_EFLAG);
+
+#if 0
+	oc_flag_0 = ltq_toe_r32(LRO_OC_FLAG(0));
+	oc_flag_1 = ltq_toe_r32(LRO_OC_FLAG(1));
+
+	if (!(oc_flag_0 & LRO_OC_FLAG_0_EXCPT_MASK) || 
+			!(oc_flag_1 & LRO_OC_FLAG_0_EXCPT_MASK)) {
+		pr_info("BUG ! got exception, but OC_FLAG 2nd bit not set\n");
+		/* Give the exception ownership back to LRO */
+		ltq_toe_w32(except_flag, LRO_EXP_EFLAG);
+	}
+
+    if (except_flag & 0x1)
+		ltq_toe_w32(1, LRO_EXP_EFLAG);
+
+	if (except_flag & 0x2)
+		ltq_toe_w32(2, LRO_EXP_EFLAG);
+#endif
+
+	/* Read the interrupt status */
+	int_status = ltq_toe_r32(TOE_INT_STAT);
+
+	/* Clear the exception and interrupt if there is any */
+	if (int_status & TOE_INT_STAT_LRO_EXP_MASK)
+		ltq_toe_w32(TOE_INT_STAT_LRO_EXP_MASK, TOE_INT_STAT);
+
+	/* Unmask the interrupt */
+	ltq_toe_w32_mask((1 << TOE_INT_MASK_LRO_EXP_POS), 0 , TOE_INT_MASK);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+static irqreturn_t lro_port_except_isr (int irq, void *priv)
+{
+	uint32_t except_entries, int_status;
+	int i;
+	unsigned long tso_rl_flags;
+
+	//printk("except_isr\n");
+
+	spin_lock_irqsave(&tso_register_lock, tso_rl_flags);
+	/* Mask the interrupt */
+	ltq_toe_w32_mask((1 << TOE_INT_MASK_LRO_EXP_POS), 0, TOE_INT_EN);
+	spin_unlock_irqrestore(&tso_register_lock, tso_rl_flags);
+
+	except_entries = ltq_toe_r32(LRO_EXP_EFLAG);
+	for(i=0; i<32; i++) {
+		if(except_entries&(1<<i)) lro_num_except_entries[i]++;
+	}
+
+	/* Clear the exception and interrupt if there is any */
+	int_status = ltq_toe_r32(TOE_INT_STAT);
+	if(int_status & TOE_INT_STAT_LRO_EXP_MASK)
+		ltq_toe_w32(TOE_INT_STAT_LRO_EXP_MASK, TOE_INT_STAT);
+
+	tasklet_schedule(&lro_exception_tasklet);
+
+	return IRQ_HANDLED;
+}
+
+static void ltq_lro_ovflow_tasklet(unsigned long dev)
+{
+	u32 int_status, i, pos;
+	volatile unsigned long except_flag, flag_wr = 0;
+
+	/* Read the interrupt status */
+	int_status = ltq_toe_r32(TOE_INT_STAT);
+
+	/* Read the Exception flag */
+	except_flag = ltq_toe_r32(LRO_EXP_EFLAG);
+
+	/* Find the first bit set in the flag */
+	for(i=0; i<(2*LTQ_MAX_LRO_PORTS); i++) {
+		pos = ffs(except_flag);
+		if (!pos) {
+			break;
+		} else {
+			clear_bit(pos, &except_flag);
+			flag_wr |= 1 << (pos-1);
+			pr_debug("ecovfl writing: %x bcos except_flag = %x at pos =%d !\n", (unsigned int)flag_wr, (unsigned int)except_flag, pos);
+			ltq_toe_w32(flag_wr, LRO_EXP_EFLAG);
+		}
+	}
+
+	/* unmask the interrupt */
+	ltq_toe_w32_mask((1 << TOE_INT_MASK_S22_POS), 0 , TOE_INT_MASK);
+}
+
+static irqreturn_t lro_port_overflow_isr (int irq, void *priv)
+{
+#if 1
+	unsigned long tso_rl_flags;
+
+	spin_lock_irqsave(&tso_register_lock, tso_rl_flags);
+	ltq_toe_w32_mask((1 << TOE_INT_EN_S22_POS), 0, TOE_INT_EN);
+	spin_unlock_irqrestore(&tso_register_lock, tso_rl_flags);
+	return IRQ_HANDLED;
+#else
+	/* mask the interrupt */
+	ltq_toe_w32_mask(0, (1 << TOE_INT_MASK_S22_POS), TOE_INT_MASK);
+
+	/* clear the interrupt */
+	ltq_toe_w32((1 << TOE_INT_MASK_S22_POS), TOE_INT_STAT);
+
+	/* schedule the tasklet for housekeeping */
+	tasklet_schedule(&lro_ovflow_tasklet);
+
+	return IRQ_HANDLED;
+#endif
+}
+
+static irqreturn_t lro_port_context_isr (int irq, void *priv)
+{
+	struct ltq_lro_port *pport = (struct ltq_lro_port *)priv;
+	unsigned long tso_rl_flags;
+
+	pr_info_once("%s called with irq: %d\n", __func__, irq);
+
+	if (!(ltq_toe_r32(TOE_INT_STAT) & (1 << (pport->port_num + TOE_INT_MASK_LRO0_POS)))) {
+	      return IRQ_NONE;
+	}
+
+	spin_lock_irqsave(&tso_register_lock, tso_rl_flags);
+	/* Mask the interrupt */
+	ltq_toe_w32_mask((1 << (pport->port_num + TOE_INT_MASK_LRO0_POS)), 0, TOE_INT_EN);
+
+	spin_unlock_irqrestore(&tso_register_lock, tso_rl_flags);
+
+	/* Clear the interrupt */
+	ltq_toe_w32((1 << (pport->port_num + TOE_INT_MASK_LRO0_POS)), TOE_INT_STAT);
+
+	/* Schedule the tasklet for housekeeping */
+	tasklet_schedule(&lro_tasklet[pport->port_num]);
+		
+	return IRQ_HANDLED;
+}
+
+#if 1
+static inline void dump_data(u32 len, char *pData){
+	int i;
+	u32 *data = (u32 *) pData;
+	for(i=0;i<len/4;i++){
+		printk("%8.8x ",(u32)(data[i]));
+		if (i % 4 == 3)
+			printk("\n");
+	}
+	printk("\n");
+}
+#endif
+
+#if 0
+static inline void dump_data(u32 len, char *pData){
+	int i;
+	for(i=0;i<len;i++){
+		printk("%2.2x ",(u8)(pData[i]));
+		if (i % 16 == 15)
+			printk("\n");
+	}
+	printk("\n");
+}
+#endif
+
+static void lro_process_output_context(int port, int oc_flag_no)
+{
+	u32 oc_flag;
+	u8 *data_ptr;
+	int i, j, data_len, temp_len, real_len, no_segs;
+	u16 frag_len, offset;
+	u8 *frag_addr;
+	struct sk_buff *skb;
+	u32 desc0, desc1, desc2, desc3, out_of_sequence = 0;
+	u32 except_flag = 0, except_reason = LRO_MAX_EXCEPTION_COUNT + 1;
+#ifdef LRO_DEBUG
+	struct tcphdr *tcp_hdr;
+#endif
+
+#ifdef CONFIG_USE_SKB_FRAGS_ARRAY
+	struct page *page;
+#else
+	struct sk_buff *frag_skb = NULL, *last_frag_skb = NULL;
+#endif
+	unsigned long tso_rl_flags;
+
+	oc_flag = ltq_toe_r32(LRO_OC_FLAG(port, oc_flag_no));
+	pr_debug("LRO done and OC_FLAG: %x\n", oc_flag);
+	no_segs = (oc_flag & LRO_OC_FLAG_0_SEG_NR_MASK) >> LRO_OC_FLAG_0_SEG_NR_POS;
+	pr_debug("First look into LRO success and later exception.. \n");
+
+	if (oc_flag & LRO_OC_FLAG_0_EXCPT_MASK) {
+			except_flag = ltq_toe_r32(LRO_EXP_EFLAG);
+
+			if (except_flag & (1 << ((port*2) + oc_flag_no)))
+				except_flag = 1;
+			else
+				except_flag = 0;
+			pr_debug("LRO exception with EXP_EFLAG = %x ..\n", except_flag);
+			except_reason = (oc_flag & LRO_OC_FLAG_0_EXP_CASE_MASK) >> LRO_OC_FLAG_0_EXP_CASE_POS;
+			if (except_flag && except_reason != 6)
+				out_of_sequence = 1;
+			if (except_reason < LRO_MAX_EXCEPTION_COUNT)
+				lro_num_except[except_reason]++;
+			else 
+				pr_err("spurious exception !!\n");
+			if ((except_reason == 0) && (no_segs == 0))
+				pr_info("flush exception with no_segs = %d for OC..%d\n", no_segs, oc_flag_no);
+	}
+
+	if (no_segs > 0) {
+
+		if (no_segs == LRO_MAX_AGP) {
+			lro_num_success++;
+		} else if (except_reason == (LRO_MAX_EXCEPTION_COUNT + 1)) {
+			pr_info("BUG! no exception no_segs = %d and OC_FLAG = %x!\n", no_segs, oc_flag);
+		}
+				desc0 = ltq_lro_sram_mem(port, oc_flag_no, 0);
+				desc1 = ltq_lro_sram_mem(port, oc_flag_no, 4);
+				desc2 = ltq_lro_sram_mem(port, oc_flag_no, 8);
+				desc3 = ltq_lro_sram_mem(port, oc_flag_no, 0xc);
+
+				/* Build the SKB */
+				data_len = desc3 & 0x0000FFFF;
+				data_ptr = (unsigned char *) __va(desc2);
+				offset = (desc3 & 0x3800000) >> 23;
+				dma_cache_inv((unsigned long) data_ptr+offset, data_len);
+
+				temp_len = data_len + 128 + NET_IP_ALIGN + NET_SKB_PAD;
+				real_len = SKB_DATA_ALIGN(temp_len) + SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
+				/*first_len = ltq_toe_r32(lro_sram_membase_res0 + 0xc) & 0x0000FFFF;*/
+				if (port == 0xff)
+					pr_info("buffer pointer of the first packet: %x and length:%d no_segs = %d\n", (unsigned int)data_ptr, real_len, no_segs);
+				//skb = build_skb((void *) (data_ptr + ((desc3 & 0x3800000) >> 23) - 128 - NET_IP_ALIGN), real_len);
+				skb = cbm_build_skb((void *) (data_ptr + (offset - 128 - NET_IP_ALIGN - NET_SKB_PAD)), real_len, GFP_ATOMIC);
+
+				/* Get the Descriptor words */
+				if (skb) {
+					skb_reserve(skb,  128 + NET_IP_ALIGN + NET_SKB_PAD);
+					skb->DW0 = desc0;
+					skb->DW1 = desc1;
+					/*skb->DW2 = desc2;*/
+					skb->DW2 = (u32)data_ptr;
+					skb->DW3 = desc3;
+					skb_put(skb, data_len);
+				} else {
+					pr_err("failure in allocating skb\r\n");
+					return;
+				}
+
+				for (i = 1, j = 0; i < no_segs; i++, j++) {
+					frag_addr = (uint8_t *) __va((ltq_lro_sram_mem(port, oc_flag_no , 0x14 + (j*8))));
+					if (port == 0xff)
+						pr_info("Buffer pointer of the %i packet: %x\n", i, (unsigned int)frag_addr);
+					frag_len = ltq_lro_sram_mem(port, oc_flag_no, 0x10 + (j*8)) & 0x0000FFFF;
+					offset = (ltq_lro_sram_mem(port, oc_flag_no, 0x10 + (j*8)) & 0xFFFF0000) >> 16;
+					if (port == 0xff)
+						pr_info("Offset: %d Fragment Length: %d\n", offset, frag_len);
+					dma_cache_inv((unsigned long) frag_addr+offset, frag_len);
+
+#ifdef CONFIG_USE_SKB_FRAGS_ARRAY
+					/* Append to the first skb */
+					page = alloc_page(GFP_ATOMIC);
+					memcpy(page_address(page), frag_addr + offset, frag_len);
+					pr_debug("adding page: %d address: %x\n", j, (unsigned int)page_address(page));
+					skb_add_rx_frag(skb, j, page, 0, frag_len, frag_len);
+					/*skb_fill_page_desc(skb, j, page, 0, frag_len);*/
+
+					/* Free the CBM buffer */
+					cbm_buffer_free(0, (u32)frag_addr, 0);
+#else
+					real_len =  frag_len + SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
+					frag_skb = cbm_build_skb((void *) (frag_addr + offset), real_len, GFP_ATOMIC);
+					if (frag_skb) {
+						skb_put(frag_skb, frag_len);
+						if (last_frag_skb) 
+							last_frag_skb->next = frag_skb;
+						else
+							skb_shinfo(skb)->frag_list = frag_skb;
+
+						last_frag_skb = frag_skb;	
+						skb->len += frag_len;
+						skb->data_len += frag_len;
+						skb->truesize += frag_skb->truesize;
+						if (except_reason == 88)
+							dump_data(100, (u8 *) frag_skb->data);
+					} else {
+							pr_err("%s: cbm_build_skb failed !!\n", __func__);
+						}
+#endif
+				}
+#ifdef LRO_DEBUG
+				tcp_hdr = (struct tcphdr *) (skb->data + 42);
+				dbg_info[dbg_head].tcp_seq_no = ntohl(tcp_hdr->seq);
+				dbg_info[dbg_head].except_reason = except_reason;
+				dbg_info[dbg_head].aggr_len = skb->len - 62;
+				dbg_head = (dbg_head + 1) % LRO_MAX_DBG_INFO;
+#endif
+				/* Send it to datapath library */
+				dp_rx(skb, 0);
+	} 
+
+	if (out_of_sequence) {
+
+			desc0 = ltq_lro_sram_except_mem(port, 0);
+			desc1 = ltq_lro_sram_except_mem(port, 4);
+			desc2 = ltq_lro_sram_except_mem(port, 8);
+			desc3 = ltq_lro_sram_except_mem(port, 0xc);
+
+			/* Build the SKB */
+			data_len = desc3 & 0x0000FFFF;
+			data_ptr = (unsigned char *) __va(desc2);
+			offset = (desc3 & 0x3800000) >> 23;
+			dma_cache_inv((unsigned long) data_ptr+offset, data_len);
+
+			temp_len = data_len + 128 + NET_IP_ALIGN + NET_SKB_PAD;
+			real_len = SKB_DATA_ALIGN(temp_len) + SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
+			/*first_len = ltq_toe_r32(lro_sram_membase_res0 + 0xc) & 0x0000FFFF;*/
+			
+			if (port == 0xff)
+				pr_debug("buffer pointer of the exception packet: %x and length:%d \n", (unsigned int)data_ptr, data_len);
+			//skb = build_skb((void *) (data_ptr + ((desc3 & 0x3800000) >> 23) - 128 - NET_IP_ALIGN), real_len);
+			skb = cbm_build_skb((void *) (data_ptr + (offset - 128 - NET_IP_ALIGN - NET_SKB_PAD)), real_len, GFP_ATOMIC);
+
+			/* Get the Descriptor words */
+			if (skb) {
+				skb_reserve(skb,  128 + NET_IP_ALIGN + NET_SKB_PAD);
+				skb->DW0 = desc0;
+				skb->DW1 = desc1;
+				/*skb->DW2 = desc2;*/
+				skb->DW2 = (u32)data_ptr;
+				skb->DW3 = desc3;
+				skb_put(skb, data_len);
+			} else {
+				pr_err("failure in allocating skb\r\n");
+				return;
+			}
+
+			if (except_reason == 88)
+				dump_data(100, (u8 *) skb->data);
+#ifdef LRO_DEBUG
+			dbg_info[dbg_head].except_reason = except_reason;
+			tcp_hdr = (struct tcphdr *) (skb->data + 42);
+			dbg_info[dbg_head].tcp_seq_no = ntohl(tcp_hdr->seq);
+			dbg_info[dbg_head].aggr_len = skb->len - 62;
+			dbg_head = (dbg_head + 1) % LRO_MAX_DBG_INFO;
+#endif
+
+			dp_rx(skb, 0);
+
+			asm("sync");
+			if (except_reason == 0)
+				pr_debug("eflag = %x\n", ltq_toe_r32(LRO_EXP_EFLAG));
+	}
+
+	/* Give the exception ownership back to LRO */
+	if (except_flag) {
+		spin_lock_irqsave(&tso_register_lock, tso_rl_flags);
+		ltq_toe_w32(1 << ((port*2) + oc_flag_no), LRO_EXP_EFLAG);
+		spin_unlock_irqrestore(&tso_register_lock, tso_rl_flags);
+	}
+
+
+	/* Give the ownership back to LRO */
+	ltq_toe_w32_mask(0, LRO_OC_OWNER_0_OWNER_MASK, LRO_OC_OWNER(port,oc_flag_no));
+	asm("sync");
+
+#if 0
+	i=0;
+	do {
+		owner = ltq_toe_r32(LRO_OC_OWNER(port + oc_flag_no));
+	} while (((owner & LRO_OC_OWNER_0_OWNER_MASK) == LRO_OC_OWNER_0_OWNER_MASK) && ((i++) < DEFAULT_WAIT_CYCLES));
+	owner = ltq_toe_r32(LRO_OC_OWNER(port,oc_flag_no));
+	if ((owner & LRO_OC_OWNER_0_OWNER_MASK) == LRO_OC_OWNER_0_OWNER_MASK)
+		pr_err("couldn't give the ownership back to LRO..\n");
+#endif
+}
+
+#if 0
+static void ltq_lro_tasklet (unsigned long dev)
+{
+	u32 lro_done_0, port;
+	struct ltq_lro_port *pport = (struct ltq_lro_port *)dev;
+	int l_read = pport->to_read;
+	u32 lro_done = 0;
+
+	port = pport->port_num;
+
+	/* Keep checking the ownership bit till its not HW */
+	do {
+		lro_done_0 = ltq_toe_r32(LRO_OC_OWNER(port,l_read));
+		if ((lro_done_0 & LRO_OC_OWNER_0_OWNER_MASK)) {
+			pr_debug("lro status: %x and current OC is %d \n", lro_done_0, l_read);
+			lro_process_output_context(port, l_read);
+			l_read = !l_read;
+		}
+
+		lro_done = ltq_toe_r32(LRO_OC_OWNER(port,l_read));
+	} while(lro_done); 
+
+	pport->to_read = l_read;
+	/* Unmask the interrupt for other output context */
+	ltq_toe_w32_mask((1 << (pport->port_num + TOE_INT_MASK_LRO0_POS)), 0, TOE_INT_MASK);
+
+	return;
+}
+
+static void ltq_lro_tasklet (unsigned long dev)
+{
+	u32 lro_done_0, lro_done_1, port, oc_flag_no;
+	struct ltq_lro_port *pport = (struct ltq_lro_port *)dev;
+	//u16 lro_tasklet_buget = 20;
+	unsigned long tso_rl_flags;
+
+	port = pport->port_num;
+
+	lro_done_0 = ltq_toe_r32(LRO_OC_OWNER(port, 0));
+	lro_done_1 = ltq_toe_r32(LRO_OC_OWNER(port, 1));
+
+	/* Keep checking the ownership bit till its not HW */
+	do {
+		if ((lro_done_0 >> LRO_OC_OWNER_0_OWNER_POS) & 0x1) {
+			oc_flag_no = 0;
+			pr_debug("lro status: %x and current OC is %d \n", lro_done_0, oc_flag_no);
+			lro_process_output_context(port, oc_flag_no);
+		}
+
+		if ((lro_done_1 >> LRO_OC_OWNER_0_OWNER_POS) & 0x1) {
+			oc_flag_no = 1;
+			pr_debug("lro status: %x and current OC is %d \n", lro_done_1, oc_flag_no);
+			lro_process_output_context(port, oc_flag_no);
+		}
+#if 0
+		lro_tasklet_buget--;
+#endif
+		lro_done_0 = ltq_toe_r32(LRO_OC_OWNER(port, 0));
+		lro_done_1 = ltq_toe_r32(LRO_OC_OWNER(port, 1));
+	//} while(lro_done_0 && lro_done_1 && lro_tasklet_buget);
+	} while(lro_done_0 || lro_done_1);
+
+#if 0
+	lro_done_0 = ltq_toe_r32(LRO_OC_OWNER(port, 0));
+	lro_done_1 = ltq_toe_r32(LRO_OC_OWNER(port, 1));
+
+	if ((lro_done_0 & LRO_OC_OWNER_0_OWNER_MASK) || (lro_done_1 & LRO_OC_OWNER_0_OWNER_MASK))	
+		tasklet_schedule(&lro_tasklet[port]);
+
+	/* Check if there was an exception overflow */
+	spin_lock_irqsave(&tso_tx_lock, sys_flag);
+	if (g_ecovfl) {
+		for (i=port; i<2; i++) {
+			if (g_except_flag & ((port*2) + i)) {
+				clear_bit((port*2) + i, &g_except_flag);
+				ltq_toe_w32(g_except_flag, LRO_EXP_EFLAG);
+			}
+		}
+		g_ecovfl = 0;
+	}
+	spin_unlock_irqrestore(&tso_tx_lock, sys_flag);
+#endif
+
+	spin_lock_irqsave(&tso_register_lock, tso_rl_flags);
+	/* Unmask the interrupt for other output context */
+	ltq_toe_w32_mask(0, (1 << (pport->port_num + TOE_INT_MASK_LRO0_POS)), TOE_INT_EN);
+	spin_unlock_irqrestore(&tso_register_lock, tso_rl_flags);
+	return;
+}
+#endif
+
+static void ltq_lro_exception_tasklet(unsigned long dev __maybe_unused)
+{
+	uint32_t entries, clear_entries=0;
+	uint32_t desc0, desc1, desc2, desc3;
+	int i, temp_len, real_len, data_len;
+	unsigned long tso_rl_flags;
+	static int read_pos = 0;
+	u8 *data_ptr;
+	struct sk_buff *skb;
+	u16 offset;
+
+	entries = ltq_toe_r32(LRO_EXP_EFLAG);
+
+	if(entries & ~(LRO_EXP_EFLAG_UNMATCH_MASK | LRO_EXP_EFLAG_EXP_MASK)) {
+		pr_err("flush entries found (EFLAG: %x)\n", entries);
+	}
+
+	for(i = read_pos; entries & (1 << (i + LRO_EXP_EFLAG_UNMATCH_POS)); i=(i+1)%8) {
+		//if(i>23) printk("PHU: unexpected flush entries\n");
+		desc0 = ltq_lro_sram_unmatched_mem(i, 0);
+		desc1 = ltq_lro_sram_unmatched_mem(i, 4);
+		desc2 = ltq_lro_sram_unmatched_mem(i, 8);
+		desc3 = ltq_lro_sram_unmatched_mem(i, 0xc);
+		printk("read unmatched buffer %#x from index %d\n", desc2, i);
+#ifdef ZERO_SRAM_DBG
+		ltq_w32(0, lro_sram_membase_res0 + 0xA80 + (0x10*i) + (8));
+#endif
+		spin_lock_irqsave(&tso_register_lock, tso_rl_flags);
+
+		asm("sync");
+
+		clear_entries = 1 << (i + LRO_EXP_EFLAG_UNMATCH_POS);
+		ltq_toe_w32(clear_entries, LRO_EXP_EFLAG);
+
+		spin_unlock_irqrestore(&tso_register_lock, tso_rl_flags);
+
+		/* Build the SKB */
+		data_len = desc3 & 0x0000FFFF;
+		data_ptr = (unsigned char *) __va(desc2);
+		offset = (desc3 & 0x3800000) >> 23;
+		dma_cache_inv((unsigned long) data_ptr+offset, data_len);
+
+		temp_len = data_len + 128 + NET_IP_ALIGN + NET_SKB_PAD;
+		real_len = SKB_DATA_ALIGN(temp_len) + SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
+			
+		skb = cbm_build_skb((void *) (data_ptr + (offset - 128 - NET_IP_ALIGN - NET_SKB_PAD)), real_len, GFP_ATOMIC);
+
+		/* Get the Descriptor words */
+		if (skb) {
+			skb_reserve(skb,  128 + NET_IP_ALIGN + NET_SKB_PAD);
+			skb->DW0 = desc0;
+			skb->DW1 = desc1;
+			/*skb->DW2 = desc2;*/
+			skb->DW2 = (u32)data_ptr;
+			skb->DW3 = desc3;
+			skb_put(skb, data_len);
+		} else {
+			pr_err("failure in allocating skb\r\n");
+			return;
+		}
+
+		dp_rx(skb, 0);
+		g_unmatched_entry++;
+	}
+
+#if 0
+	read_pos = i;
+	if(entries & LRO_EXP_EFLAG_UNMATCH_MASK )  {
+		static int i=16;
+		int j;
+		printk("TOE_INT_STAT: %x\n", ltq_toe_r32(TOE_INT_STAT));
+		for(j=0; j<0x10; j+=4) {
+			desc0 = ltq_lro_sram_unmatched_mem(i-16, j);
+			printk("PHU: exception context entry %d: %#x %s %s\n",
+			       i,
+			       desc0,
+			       (u32)__va(desc0) ? "<- cbm!" : "",
+			       (entries & (1 << i)) ? "<- set!" : ""
+			      );
+		}
+		if(entries & (1 << i) ) {
+			ltq_toe_w32(1 << i, LRO_EXP_EFLAG);
+			if(i>23) i=16;
+		}
+
+	}
+#endif
+	spin_lock_irqsave(&tso_register_lock, tso_rl_flags);
+
+	/* Unmask the interrupt */
+	ltq_toe_w32_mask(0, (1 << TOE_INT_MASK_LRO_EXP_POS), TOE_INT_EN);
+	spin_unlock_irqrestore(&tso_register_lock, tso_rl_flags);
+	return;
+}
+
+static void ltq_lro_tasklet (unsigned long dev)
+{
+	uint32_t port, context_ready;
+	uint32_t current_context;
+	struct ltq_lro_port *pport = (struct ltq_lro_port *)dev;
+	uint8_t lro_tasklet_budget = 20;
+	unsigned long tso_rl_flags;
+	static atomic_t scheduled[8] = {{0}};
+	static uint32_t last_context[8] = {0};
+
+	if(atomic_add_return(1, &scheduled[pport->port_num]) > 1) {
+		printk("lro_tasklet concurrency detected on port %d\n", pport->port_num);
+	}
+
+	port = pport->port_num;
+
+	current_context = last_context[port];
+	BUG_ON(current_context > 1);
+	context_ready = ltq_toe_r32(LRO_OC_OWNER(port, current_context));
+	if(!context_ready) {
+		printk("no context ready :(\n");
+		goto leave;
+	}
+
+	/* Keep checking the ownership bit till its not HW */
+	do {
+		if ((ltq_toe_r32(TOE_INT_STAT) & (1 << (port + TOE_INT_MASK_LRO0_POS)))) {
+			/* Clear the interrupt */
+			ltq_toe_w32((1 << (port + TOE_INT_MASK_LRO0_POS)), TOE_INT_STAT);
+		}
+		lro_process_output_context(port, current_context);
+		current_context = !current_context;
+		context_ready = ltq_toe_r32(LRO_OC_OWNER(port, current_context));
+	} while(context_ready && --lro_tasklet_budget);
+
+	lro_budget_left[lro_tasklet_budget]++;
+	last_context[port] = current_context;
+
+	if((ltq_toe_r32(TOE_INT_STAT) & (1 << (port + TOE_INT_MASK_LRO0_POS))) ||
+	   context_ready) {
+		tasklet_schedule(&lro_tasklet[port]);
+		atomic_dec(&scheduled[port]);
+		return;
+	}
+
+leave:
+	spin_lock_irqsave(&tso_register_lock, tso_rl_flags);
+	/* Unmask the interrupt for other output context */
+	ltq_toe_w32_mask(0, (1 << (pport->port_num + TOE_INT_MASK_LRO0_POS)), TOE_INT_EN);
+	spin_unlock_irqrestore(&tso_register_lock, tso_rl_flags);
+
+	atomic_dec(&scheduled[port]);
+	return;
+}
+
+static struct ltq_lro_port *ltq_allocate_lro_port (void)
+{
+	int i;
+
+	for (i = 0; i < LTQ_MAX_LRO_PORTS; i++) {
+		if (!ltq_lro_port[i].in_use) {
+			ltq_lro_port[i].in_use = 1;
+			return &ltq_lro_port[i];
+		}
+	}
+	return NULL;
+}
+
+int lro_start_flow (int session_id, int timeout, int flags, struct cpumask cpumask)
+{
+	struct ltq_lro_port *pport;
+	u32 port;
+	int ret;
+
+	/* Allocate a LRO port for the session */
+	pport = ltq_allocate_lro_port();
+
+	if (!pport)
+		return -EBUSY;
+
+	port = pport->port_num;
+	pport->session_id = session_id & LRO_FID_0_LRO_FID_MASK;
+
+	/*pr_info("%s called with session_id = %x and port is: %d \n", __func__, session_id & LRO_FID_0_LRO_FID_MASK, port);*/
+
+	ltq_toe_w32(timeout, LRO_TO_REG(port));
+
+	/* Test values */
+	/* Set the timeout to large value */
+	//ltq_toe_w32(0xffffffff, LRO_TO_REG(port));
+	//ltq_toe_w32(0x7270e00, LRO_TO_REG(port));
+	//ltq_toe_w32(0x4c25A00, LRO_TO_REG(port));
+	//ltq_toe_w32(0xa270e00, LRO_TO_REG(port));
+	//ltq_toe_w32(0x19fd94, LRO_TO_REG(port)); /*5ms*/
+	//ltq_toe_w32(0x90000, LRO_TO_REG(port)); /*2ms*/
+	//ltq_toe_w32(0xe666, LRO_TO_REG(port)); /* 200 us */
+
+	/* Set the Flow ID */
+	ltq_toe_w32_mask(LRO_FID_0_LRO_FID_MASK, 0, LRO_FID(port));
+	ltq_toe_w32_mask(0, (session_id & LRO_FID_0_LRO_FID_MASK) << LRO_FID_0_LRO_FID_POS, LRO_FID(port));
+	ltq_toe_w32_mask(LRO_FID_0_S_END_MASK, 0, LRO_FID(port));
+	ltq_toe_w32_mask(LRO_FID_0_OWNER_MASK, 0, LRO_FID(port));
+
+	/* Set the IRQ affinity */
+	cpumask.bits[0] = 0x1;
+	ret = irq_set_affinity(pport->irq_num, &cpumask);
+	if (ret) {
+		pr_err("%s: can not set affinity for IRQ - %d", __func__, pport->irq_num);
+		return ret;
+	}
+
+	ret = irq_set_affinity(190, &cpumask);
+	if (ret) {
+		pr_err("%s: can not set affinity for IRQ - %d", __func__, 190);
+		return ret;
+	}
+
+	enable_irq(pport->irq_num);
+	return ret;
+}
+EXPORT_SYMBOL(lro_start_flow);
+
+static struct ltq_lro_port *ltq_lookup_lro_port(int session_id)
+{
+	int i;
+
+	for (i = 0; i < LTQ_MAX_LRO_PORTS; i++) {
+		if (ltq_lro_port[i].session_id == session_id) {
+			return &ltq_lro_port[i];
+		}
+	}
+	return NULL;
+}
+
+int lro_stop_flow (int session_id, int timeout, int flags)
+{
+	struct ltq_lro_port *pport;
+	u32 port;
+
+	/* Allocate a LRO port for the session */
+	pport = ltq_lookup_lro_port(session_id);
+
+	if (!pport)
+		return -EINVAL;
+
+	/*pr_info("%s called\n", __func__);*/
+
+	/* Disable the interrupt */
+	disable_irq(pport->irq_num);
+
+	port = pport->port_num;
+
+	/* Set the S_END */
+	ltq_toe_w32_mask(0, 1 << LRO_FID_0_S_END_POS, LRO_FID(port));
+
+	/* Clear the OWNER */
+	ltq_toe_w32_mask(LRO_FID_0_OWNER_MASK, 0,  LRO_FID(port));
+
+	/* Make the port available */
+	pport->in_use = 0;
+
+	return 0;
+}
+EXPORT_SYMBOL(lro_stop_flow);
+
+static int tso_configure_dma (void)
+{
+	int rxchan;
+	int txchan;
+
+	/* ----------------------------*/
+	/*      TSO Port 0 channels   */
+	/* ----------------------------*/
+
+	pr_debug ("Initializing TSO Port 0 channels..\n");
+
+	rxchan = DMA3_TOE_MEMCOPY_CLASS2_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS2_TX;
+
+	/* Configure Pre-Processing Channels (4,5) */
+	if ((ltq_request_dma(rxchan, "dma3 rx 4")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 4 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 5")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 5 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_4_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 4\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_5_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 5\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	/* Configure Seg0 channels (0,1) */
+	rxchan = DMA3_TOE_MEMCOPY_CLASS0_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS0_TX;
+
+	if ((ltq_request_dma(rxchan, "dma3 rx 0")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 0 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 1")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 1 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_0_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 0\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_1_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 1\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	/* Configure Seg1 channels (2,3) */
+	rxchan = DMA3_TOE_MEMCOPY_CLASS1_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS1_TX;
+
+	if ((ltq_request_dma(rxchan, "dma3 rx 2")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 2 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 3")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 3 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_2_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 0\r\n", __func__);
+    }
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_3_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 1\r\n", __func__);
+    }
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	/* Enqueue 0 channels (8,9) */
+	rxchan = DMA3_TOE_MEMCOPY_CLASS4_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS4_TX;
+
+	if ((ltq_request_dma(rxchan, "dma3 rx 8")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 8 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 9")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 9 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_8_DESC_BASE, 1)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 8\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_9_DESC_BASE, 1)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 9\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	/* Enqueue 1 channels (10,11) */
+	rxchan = DMA3_TOE_MEMCOPY_CLASS5_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS5_TX;
+
+	if ((ltq_request_dma(rxchan, "dma3 rx 10")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 10 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 11")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 11 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_10_DESC_BASE, 1)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 10\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t)DMA3_TOE_MEMCPY_CHAN_11_DESC_BASE, 1)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 11\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	pr_debug ("Initializing TSO Port 0 channels: Done !\n");
+
+#if 1
+	/* ----------------------------*/
+	/*      TSO Port 1 channels   */
+	/* ----------------------------*/
+
+	pr_debug ("Initializing TSO Port 1 channels !\n");
+
+	rxchan = DMA3_TOE_MEMCOPY_CLASS3_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS3_TX;
+
+	/* Configure Pre-Processing Channels (6,7) */
+	if ((ltq_request_dma(rxchan, "dma3 rx 6")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 6 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 7")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 7 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_6_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 6\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_7_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 7\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	/* Configure Seg0 channels (30,31) */
+	rxchan = DMA3_TOE_MEMCOPY_CLASS15_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS15_TX;
+
+	if ((ltq_request_dma(rxchan, "dma3 rx 30")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 30 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 31")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 31 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_30_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 0\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_31_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 1\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	/* Configure Seg1 channels (32,33) */
+	rxchan = DMA3_TOE_MEMCOPY_CLASS16_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS16_TX;
+
+	if ((ltq_request_dma(rxchan, "dma3 rx 32")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 32 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 33")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 33 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_32_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 32\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_33_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 33\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	/* Enqueue 0 channels (38,39) */
+	rxchan = DMA3_TOE_MEMCOPY_CLASS19_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS19_TX;
+
+	if ((ltq_request_dma(rxchan, "dma3 rx 38")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 38 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 39")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 39 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_38_DESC_BASE, 1)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 38\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_39_DESC_BASE, 1)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 39\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	/* Enqueue 1 channels (40,41) */
+	rxchan = DMA3_TOE_MEMCOPY_CLASS20_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS20_TX;
+
+	if ((ltq_request_dma(rxchan, "dma3 rx 40")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 40 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 41")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 41 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_40_DESC_BASE, 1)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 40\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t)DMA3_TOE_MEMCPY_CHAN_41_DESC_BASE, 1)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 41\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	pr_debug ("Initializing TSO Port 1 channels: Done !\n");
+
+	/* ----------------------------*/
+	/*      TSO Port 2 channels   */
+	/* ----------------------------*/
+	pr_debug ("Initializing TSO Port 2 channels ! \n");
+
+	rxchan = DMA3_TOE_MEMCOPY_CLASS17_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS17_TX;
+
+	/* Configure Pre-Processing Channels (34,35) */
+	if ((ltq_request_dma(rxchan, "dma3 rx 34")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 34 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 35")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 35 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_34_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 34\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_35_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 35\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	/* Configure Seg0 channels (54,55) */
+	rxchan = DMA3_TOE_MEMCOPY_CLASS27_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS27_TX;
+
+	if ((ltq_request_dma(rxchan, "dma3 rx 54")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 54 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 55")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 55 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_54_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 54\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_55_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 55\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	/* Configure Seg1 channels (42,43) */
+	rxchan = DMA3_TOE_MEMCOPY_CLASS21_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS21_TX;
+
+	if ((ltq_request_dma(rxchan, "dma3 rx 42")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 42 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 43")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 43 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_42_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 42\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_43_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 43\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	/* Enqueue 0 channels (48,49) */
+	rxchan = DMA3_TOE_MEMCOPY_CLASS24_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS24_TX;
+
+	if ((ltq_request_dma(rxchan, "dma3 rx 48")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 48 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 49")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 49 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_48_DESC_BASE, 1)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 48\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t) DMA3_TOE_MEMCPY_CHAN_49_DESC_BASE, 1)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 49\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	/* Enqueue 1 channels (50,51) */
+	rxchan = DMA3_TOE_MEMCOPY_CLASS25_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS25_TX;
+
+	if ((ltq_request_dma(rxchan, "dma3 rx 50")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 50 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 51")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 51 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t)DMA3_TOE_MEMCPY_CHAN_50_DESC_BASE, 1)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 50\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t)DMA3_TOE_MEMCPY_CHAN_51_DESC_BASE, 1)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 51\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	pr_debug ("Initializing TSO Port 2 channels: Done! \n");
+
+	/* ----------------------------*/
+	/*      TSO Port 3 channels   */
+	/* ----------------------------*/
+
+	pr_debug ("Initializing TSO Port 3 channels ! \n");
+
+	rxchan = DMA3_TOE_MEMCOPY_CLASS18_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS18_TX;
+
+	/* Configure Pre-Processing Channels (36,37) */
+	if ((ltq_request_dma(rxchan, "dma3 rx 36")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 36 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 37")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 37 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t)DMA3_TOE_MEMCPY_CHAN_36_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 36\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t)DMA3_TOE_MEMCPY_CHAN_37_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 37\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	/* Configure Seg0 channels (62,63) */
+	rxchan = DMA3_TOE_MEMCOPY_CLASS31_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS31_TX;
+
+	if ((ltq_request_dma(rxchan, "dma3 rx 62")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 62 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 63")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 63 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t)DMA3_TOE_MEMCPY_CHAN_62_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 62\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t)DMA3_TOE_MEMCPY_CHAN_63_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 63\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	/* Configure Seg1 channels (52,53) */
+	rxchan = DMA3_TOE_MEMCOPY_CLASS26_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS26_TX;
+
+	if ((ltq_request_dma(rxchan, "dma3 rx 52")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 52 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 53")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 53 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t)DMA3_TOE_MEMCPY_CHAN_52_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 52\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t)DMA3_TOE_MEMCPY_CHAN_53_DESC_BASE, 2)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 53\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+	/* Enqueue 0 channels (58,59) */
+	rxchan = DMA3_TOE_MEMCOPY_CLASS29_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS29_TX;
+
+	if ((ltq_request_dma(rxchan, "dma3 rx 58")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 58 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 49")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 59 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t)DMA3_TOE_MEMCPY_CHAN_58_DESC_BASE, 1)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 58\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t)DMA3_TOE_MEMCPY_CHAN_59_DESC_BASE, 1)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 59\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+
+	/* Enqueue 1 channels (60,61) */
+	rxchan = DMA3_TOE_MEMCOPY_CLASS30_RX;
+	txchan = DMA3_TOE_MEMCOPY_CLASS30_TX;
+
+	if ((ltq_request_dma(rxchan, "dma3 rx 60")) < 0)
+		pr_debug(" %s failed to open chan for dma3 rx chan 60 \n", __func__);
+
+	if ((ltq_request_dma(txchan, "dma3 tx 61")) < 0)
+		pr_debug(" %s failed to open chan for dma3 tx chan 61 \n", __func__);
+
+	if ((ltq_dma_chan_desc_cfg(rxchan, (dma_addr_t)DMA3_TOE_MEMCPY_CHAN_60_DESC_BASE, 1)) < 0) {
+		pr_debug(" %s failed to setup chan desc for rxchan 60\r\n", __func__);
+	}
+
+	if ((ltq_dma_chan_desc_cfg(txchan, (dma_addr_t)DMA3_TOE_MEMCPY_CHAN_61_DESC_BASE, 1)) < 0) {
+		pr_debug(" %s failed to setup chan desc for txchan 61\r\n", __func__);
+	}
+
+	ltq_dma_chan_irq_enable(rxchan);
+	ltq_dma_chan_irq_enable(txchan);
+
+#if 0
+	ltq_dma_chan_enable_polling(rxchan);
+	ltq_dma_chan_enable_polling(txchan);
+	ltq_dma_chan_desc_info(rxchan);
+	ltq_dma_chan_desc_info(txchan);
+#endif
+
+	ltq_dma_chan_on(rxchan);
+	ltq_dma_chan_on(txchan);
+
+
+	pr_debug ("Initializing TSO Port 3 channels: Done! \n");
+#endif
+	return 0;
+}
+
+static void configure_lro(void)
+{
+	int i;
+	u32 lro_en = 0;
+
+	/* Maximum aggregation size to 2 */
+	ltq_toe_w32_mask(TSO_GCTRL_LRO_MAX_AGP_MASK, (LRO_MAX_AGP << TSO_GCTRL_LRO_MAX_AGP_POS), TSO_GCTRL);
+
+	/* Enable all the LRO ports */
+	for (i = 0; i < LTQ_MAX_LRO_PORTS; i++)
+		lro_en |= (1 << (TSO_GCTRL_LRO0_EN_POS + i));
+	ltq_toe_w32_mask(0, lro_en, TSO_GCTRL);
+
+	/* Enable the interrupts */
+	for (i = 0; i < LTQ_MAX_LRO_PORTS; i++)
+		lro_en |= (1 << (TOE_INT_EN_LRO0_POS + i));
+	ltq_toe_w32_mask(0, lro_en, TOE_INT_EN);
+
+	/*ltq_toe_w32_mask(0, (1 << TOE_INT_EN_LRO_EXP_POS), TOE_INT_EN);*/
+	ltq_toe_w32_mask(0, (1 << TOE_INT_EN_S20_POS), TOE_INT_EN);
+	/*ltq_toe_w32_mask(0, (1 << TOE_INT_EN_S21_POS), TOE_INT_EN);*/
+	ltq_toe_w32_mask(0, (1 << TOE_INT_EN_S22_POS), TOE_INT_EN);
+	ltq_toe_w32_mask(0, (1 << TOE_INT_EN_S23_POS), TOE_INT_EN);
+
+	/* Unmask LRO interrupts */
+	for (i = 0; i < LTQ_MAX_LRO_PORTS; i++)
+		lro_en |= (1 << (TOE_INT_MASK_LRO0_POS + i));
+	ltq_toe_w32_mask(lro_en, 0, TOE_INT_MASK);
+
+	/*ltq_toe_w32_mask((1 << TOE_INT_MASK_LRO_EXP_POS), 0, TOE_INT_MASK);*/
+	ltq_toe_w32_mask((1 << TOE_INT_MASK_S20_POS), 0, TOE_INT_MASK);
+	/*ltq_toe_w32_mask((1 << TOE_INT_MASK_S21_POS), 0, TOE_INT_MASK);*/
+	ltq_toe_w32_mask((1 << TOE_INT_MASK_S22_POS), 0, TOE_INT_MASK);
+	ltq_toe_w32_mask((1 << TOE_INT_MASK_S23_POS), 0, TOE_INT_MASK);
+}
+
+static void configure_tso (void)
+{
+	pr_debug ("Enabling the TSO..\n");
+
+	/* Enable the TSO */
+	ltq_toe_w32_mask(0, (1 << TSO_GCTRL_ENA_P0_POS), TSO_GCTRL);
+	ltq_toe_w32_mask(0, (1 << TSO_GCTRL_ENA_P1_POS), TSO_GCTRL);
+	ltq_toe_w32_mask(0, (1 << TSO_GCTRL_ENA_P2_POS), TSO_GCTRL);
+	ltq_toe_w32_mask(0, (1 << TSO_GCTRL_ENA_P3_POS), TSO_GCTRL);
+
+	pr_debug ("Setup the SRAM address as scratchpad.. \n");
+	/* Setup the SRAM addresses for scratchpad */
+	ltq_toe_w32(0x1F806000, HDR_BASE_SEG0);
+	/*ltq_toe_w32(0x1F806800, toe_membase + HDR_BASE_SEG1);*/
+	ltq_toe_w32(0x1F807000, HDR_BASE_SEG1);
+
+	/* Disable the swap */
+	/*ltq_toe_w32_mask(TSO_GCTRL_OCP_CTRL_ENDI_B_MASK, 0, TSO_GCTRL);*/
+	/* Enable the word swap */
+	ltq_toe_w32_mask(0, (1 << TSO_GCTRL_OCP_CTRL_ENDI_W_POS), TSO_GCTRL);
+
+	/* Enable the DMA MCOPY Interrupts */
+	ltq_toe_w32_mask(0, (1 << TSO_INTL_INT_EN_MCPY0_DONE_POS), TSO_INTL_INT_EN);
+	ltq_toe_w32_mask(0, (1 << TSO_INTL_INT_EN_MCPY1_DONE_POS), TSO_INTL_INT_EN);
+	ltq_toe_w32_mask(0, (1 << TSO_INTL_INT_EN_MCPY2_DONE_POS), TSO_INTL_INT_EN);
+	ltq_toe_w32_mask(0, (1 << TSO_INTL_INT_EN_MCPY3_DONE_POS), TSO_INTL_INT_EN);
+
+	/* Enable the interrupts */
+	ltq_toe_w32_mask(0, (1 << TOE_INT_EN_TOE0_POS), TOE_INT_EN);
+	ltq_toe_w32_mask(0, (1 << TOE_INT_EN_TOE1_POS), TOE_INT_EN);
+	ltq_toe_w32_mask(0, (1 << TOE_INT_EN_TOE2_POS), TOE_INT_EN);
+	ltq_toe_w32_mask(0, (1 << TOE_INT_EN_TOE3_POS), TOE_INT_EN);
+
+	/* Unmask only TSO interrupts */
+#ifndef CONFIG_LTQ_TOE_USE_SW_POLLING
+	ltq_toe_w32_mask((1 << TOE_INT_MASK_TOE0_POS), 0, TOE_INT_MASK);
+	ltq_toe_w32_mask((1 << TOE_INT_MASK_TOE1_POS), 0, TOE_INT_MASK);
+	ltq_toe_w32_mask((1 << TOE_INT_MASK_TOE2_POS), 0, TOE_INT_MASK);
+	ltq_toe_w32_mask((1 << TOE_INT_MASK_TOE3_POS), 0, TOE_INT_MASK);
+#endif
+}
+
+#ifndef CONFIG_LTQ_TOE_USE_SW_POLLING
+static void ltq_tso_tasklet(unsigned long cpu_id)
+{
+	u32 tso_done;
+	/*ltq_tso_port_t *port = &(ltq_tso_port[cpu_id]);*/
+	struct sk_buff *skb;
+
+    tso_done = ltq_toe_r32(PORT_RES_REG1(cpu_id));
+    tso_done = 1 & (tso_done >> PORT_RES_REG1_0_DONE_POS);
+
+    if (tso_done) {
+			/* free the skb */
+			skb = (struct sk_buff *) ltq_toe_r32(PORT_RES_REG0(cpu_id));
+			pr_debug("skb = %x\n", (unsigned int)skb);
+			dev_kfree_skb_any(skb);
+
+			/* Unmask the interrupt */
+			ltq_toe_w32_mask(1<<cpu_id, 0, TOE_INT_MASK);
+	} else {
+		pr_err("TSO not done ! but got the interrupt \n");
+	}
+	
+	return;
+}
+
+static irqreturn_t ltq_tso_tx_int(int irq, void *_port)
+{
+	int cpu = smp_processor_id();
+	struct sk_buff *skb;
+	u32 tso_done;
+
+	/* Mask the interrupt */
+	ltq_toe_w32_mask(0, (1<<cpu), TOE_INT_MASK);
+
+	/* Clear the interrupt */
+	ltq_toe_w32_mask(0, (1<<cpu), TOE_INT_STAT);
+
+	skb = (struct sk_buff *) ltq_toe_r32(PORT_RES_REG0(cpu));
+	pr_debug("skb = %x\n", (unsigned int)skb);
+	dev_kfree_skb_any(skb);
+
+    tso_done = ltq_toe_r32(PORT_RES_REG1(cpu));
+
+	/* Unmask the interrupt */
+	ltq_toe_w32_mask(1<<cpu, 0, TOE_INT_MASK);
+
+	/* Schedule the tasklet for housekeeping */
+	//tasklet_schedule(&tso_tasklet[cpu]);
+	return IRQ_HANDLED;
+}
+#endif
+
+int ltq_tso_xmit (struct sk_buff *skb, int egress_port, int flags)
+{
+	int i, len;
+#ifndef CONFIG_LTQ_TOE_USE_SW_POLLING
+	unsigned long cmd5_reg, sys_flag;
+#endif
+	unsigned long tso_done = 0;
+	void *frag_addr;
+	const skb_frag_t *frag;
+#ifndef CONFIG_LTQ_TOE_USE_SW_POLLING
+	ltq_tso_port_t *p_tso_port;
+#endif
+	int port;
+	struct skb_shared_info *shinfo=NULL;
+  	unsigned long toe_g = 1;
+  	unsigned long toe_sioc = 0;
+  	unsigned long toe_last = 0;
+  	unsigned char *cmd4_buf;
+
+	/*spin_lock_irqsave(&tso_tx_lock, sys_flag);*/
+
+#ifndef CONFIG_LTQ_TOE_USE_SW_POLLING
+	p_tso_port = &ltq_tso_port[port];
+
+	/* Wait till the Ownership belongs to CPU */
+	do {
+		cmd5_reg = ltq_toe_r32(PORT_REQ_CMD_REG5(port));
+		pr_debug("cmd5_reg = %x\n", cmd5_reg);
+	} while (!test_bit(31, &cmd5_reg));
+
+	local_irq_save(sys_flag);
+#else
+	port = smp_processor_id();
+#endif
+
+	pr_debug("%s: called.. with len:%d on port: %d\n", 
+					__FUNCTION__, skb->len, port);
+
+  	cmd4_buf = (unsigned char *)ltq_large_buf[port];
+
+  	shinfo = skb_shinfo(skb);
+
+  	if (skb->data) {
+		 if (shinfo->nr_frags == 0) {
+		   toe_g = 0;
+		   cmd4_buf = (unsigned char *)skb;
+		   toe_last |= (1 << PORT_REQ_CMD_REG0_0_LAST_POS);
+		 }
+    } else if (shinfo->nr_frags == 1) {
+		 toe_g = 0;
+   	 	 cmd4_buf = (unsigned char *)skb;
+   	     toe_last |= (1 << PORT_REQ_CMD_REG0_0_LAST_POS);
+  	}
+	
+ 	/* Setup 1st command of gather in cmd registers */
+ 	/* Check that CMD port is available */
+ 	toe_get_cmd_own(port);
+ 	len = skb->len - skb->data_len;
+ 	toe_fill_cmd0(1, 1, 1, toe_g, 2, len, toe_last, port);
+ 	toe_fill_cmd1(skb->data, ~toe_sioc, port, len);
+ 	toe_fill_cmd2(skb->DW0, port);
+ 	toe_fill_cmd3(skb->DW1, port);
+ 	toe_fill_cmd4(cmd4_buf, port);
+	/*udelay(10);*/
+	asm("sync");
+ 	toe_fill_cmd5(skb_tso_size(skb), 1, port);
+
+	/* Write the command registers to start the gathering*/
+	for (i = 0; i < shinfo->nr_frags ; i++) {
+			/* Check if last segment of Gather */
+			if (i == (shinfo->nr_frags - 1)) {
+				toe_last = (1 << PORT_REQ_CMD_REG0_0_LAST_POS) | (1 << PORT_REQ_CMD_REG0_0_IE_POS);
+			}
+			frag = &shinfo->frags[i];
+
+			/* Check that CMD port is available */
+			toe_get_cmd_own(port);
+			/* CMD0 - Fill frag length */
+			toe_fill_cmd0(1, 1, 1, toe_g, 2, skb_frag_size(frag), toe_last, port);
+
+			/* CMD1 - Fill frag i */
+			frag_addr = skb_frag_address(frag);
+			toe_fill_cmd1_frags(frag_addr, ~toe_sioc, port, skb_frag_size(frag));
+
+			/* */
+			toe_fill_cmd4_sbk((u32)skb, port);
+
+			/* CMD5 */
+			toe_fill_cmd5(skb_tso_size(skb), 1, port);
+
+			pr_debug ("start for packet:%d with G.. \n", i);
+	}
+
+#ifdef CONFIG_LTQ_TOE_USE_SW_POLLING
+	do {
+		tso_done = ltq_toe_r32(PORT_RES_REG1(port));
+		pr_debug ("checking tso status: %x\n", (unsigned int)tso_done);
+		tso_done = 1 & (tso_done >> PORT_RES_REG1_0_DONE_POS);
+		if (tso_done)
+			break;
+		/*udelay (1000);*/
+	} while (1);
+
+	if (skb_is_nonlinear(skb))
+		pr_debug("!");
+	pr_debug("tso_done !!!\n");
+
+	/* Free the SKB */
+	dev_kfree_skb_any(skb);
+
+	/*spin_unlock_irqrestore(&tso_tx_lock, sys_flag);*/
+#endif
+
+#ifndef CONFIG_LTQ_TOE_USE_SW_POLLING
+	local_irq_restore(sys_flag);
+#endif
+	tso_num_tx[port]++;
+	return 0;
+}
+EXPORT_SYMBOL(ltq_tso_xmit);
+
+static int toe_reg_read_proc(struct seq_file *s, void *v)
+{
+	seq_puts(s, "===============Global Regs ==================\n");
+	seq_printf(s, "ToE base address 0x%08x\n", (unsigned int) ltq_toe_membase);
+	seq_printf(s, "TSO_GCTRL: addr 0x%08x value 0x%08x\t\n", (unsigned int)(ltq_toe_membase + TSO_GCTRL), ltq_toe_r32(TSO_GCTRL));
+	seq_printf(s, "HDR_BASE_SEG0: addr 0x%08x value 0x%08x\t\n", (unsigned int) (ltq_toe_membase + HDR_BASE_SEG0), ltq_toe_r32(HDR_BASE_SEG0));
+	seq_printf(s, "HDR_BASE_SEG1: addr 0x%08x value 0x%08x\t\n", (unsigned int) (ltq_toe_membase + HDR_BASE_SEG1), ltq_toe_r32(HDR_BASE_SEG1));
+	seq_printf(s, "TOE_INT_MASK: addr 0x%08x value 0x%08x\t\n", (unsigned int)(ltq_toe_membase + TOE_INT_MASK), ltq_toe_r32(TOE_INT_MASK));
+	seq_printf(s, "TOE_INT_STAT: addr 0x%08x value 0x%08x\t\n", (unsigned int)(ltq_toe_membase + TOE_INT_STAT), ltq_toe_r32(TOE_INT_STAT));
+	seq_printf(s, "=============== Port 0 TSO CMD Regs ============\n");
+	seq_printf(s, "PORT_REQ_CMD_REG0_0: addr 0x%08x value 0x%08x\t\n", (unsigned int)(ltq_toe_membase + TSO_GCTRL), ltq_toe_r32(PORT_REQ_CMD_REG0_0));
+	seq_printf(s, "PORT_REQ_CMD_REG1_0: addr 0x%08x value 0x%08x\t\n", (unsigned int)(ltq_toe_membase + TSO_GCTRL), ltq_toe_r32(PORT_REQ_CMD_REG1_0));
+	seq_printf(s, "PORT_REQ_CMD_REG2_0: addr 0x%08x value 0x%08x\t\n", (unsigned int)(ltq_toe_membase + TSO_GCTRL), ltq_toe_r32(PORT_REQ_CMD_REG2_0));
+	seq_printf(s, "PORT_REQ_CMD_REG3_0: addr 0x%08x value 0x%08x\t\n", (unsigned int)(ltq_toe_membase + TSO_GCTRL), ltq_toe_r32(PORT_REQ_CMD_REG3_0));
+	seq_printf(s, "PORT_REQ_CMD_REG4_0: addr 0x%08x value 0x%08x\t\n", (unsigned int)(ltq_toe_membase + TSO_GCTRL), ltq_toe_r32(PORT_REQ_CMD_REG4_0));
+	seq_printf(s, "PORT_REQ_CMD_REG5_0: addr 0x%08x value 0x%08x\t\n", (unsigned int)(ltq_toe_membase + TSO_GCTRL), ltq_toe_r32(PORT_REQ_CMD_REG5_0));
+	seq_printf(s, "=============== Port 0 LRO Regs ============\n");
+	seq_printf(s, "LRO_FID_0: addr 0x%08x value 0x%08x\t\n", (unsigned int) (ltq_toe_membase + LRO_FID_0), ltq_toe_r32(LRO_FID_0));
+	seq_printf(s, "LRO_TO_REG_0: addr 0x%08x value 0x%08x\t\n", (unsigned int) (ltq_toe_membase + LRO_TO_REG_0), ltq_toe_r32(LRO_TO_REG_0));
+	seq_printf(s, "LRO_OC_FLAG_0: addr 0x%08x value 0x%08x\t\n", (unsigned int) (ltq_toe_membase + LRO_OC_FLAG_0), ltq_toe_r32(LRO_OC_FLAG_0));
+	return 0;
+}
+
+static int ltq_reg_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, toe_reg_read_proc, NULL);
+}
+
+static const struct file_operations ltq_toe_reg_proc_fops = {
+	.open = ltq_reg_seq_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+static int lro_stats_read_proc(struct seq_file *s, void *v)
+{
+	int i,port;
+
+	seq_puts(s, "===============LRO Stats==================\n");
+	for (i=0; i<LRO_MAX_EXCEPTION_COUNT; i++)
+		seq_printf(s, "Exceptions %i: %d\t\n", i, (unsigned int) lro_num_except[i]);
+	seq_printf(s, "Number of success %d\t\n", (unsigned int) lro_num_success);
+	seq_printf(s, "=============== Port 0 LRO Regs ============\n");
+	seq_printf(s, "LRO_OC_FLAG_0: addr 0x%08x value 0x%08x\t\n", (unsigned int) (ltq_toe_membase + LRO_OC_FLAG_0), ltq_toe_r32(LRO_OC_FLAG_0));
+	seq_printf(s, "LRO_OC_FLAG_1: addr 0x%08x value 0x%08x\t\n", (unsigned int) (ltq_toe_membase + LRO_OC_FLAG_1), ltq_toe_r32(LRO_OC_FLAG_1));
+	seq_printf(s, "LRO_OC_OWNER_0: addr 0x%08x value 0x%08x\t\n", (unsigned int) (ltq_toe_membase + LRO_OC_OWNER_0), ltq_toe_r32(LRO_OC_OWNER_0));
+	seq_printf(s, "LRO_OC_OWNER_1: addr 0x%08x value 0x%08x\t\n", (unsigned int) (ltq_toe_membase + LRO_OC_OWNER_1), ltq_toe_r32(LRO_OC_OWNER_1));
+	seq_puts(s, "===============TSO Stats==================\n");
+	for (port=0; port < LTQ_MAX_TSO_PORTS; port++)
+		seq_printf(s, "Number of tx %d\t\n", (unsigned int) tso_num_tx[port]);
+	return 0;
+}
+
+static int ltq_lro_stats_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, lro_stats_read_proc, NULL);
+}
+
+ssize_t lro_proc_write(struct file *file, const char *buf, size_t count,
+			     loff_t *ppos)
+{
+	u32 flow_id;
+
+	/* Read the Flow ID */
+	flow_id = ltq_toe_r32(LRO_FID(0)) & LRO_FID_0_LRO_FID_MASK;
+	pr_info("current flow id = %d\n", flow_id);
+
+	/* Stop the flow */
+	if (lro_stop_flow(flow_id, 0, 0) < 0)
+		pr_err("session couldn't be deleted..\n");
+	else
+		pr_info("session %d deleted..\n", flow_id);
+	return count;
+}
+
+static const struct file_operations ltq_lro_stats_proc_fops = {
+	.open = ltq_lro_stats_seq_open,
+	.read = seq_read,
+	.write = lro_proc_write,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+/* Debug info related proc */
+#ifdef LRO_DEBUG
+static void *lro_dbg_info_seq_start(struct seq_file *s, loff_t *pos)
+{
+	if (*pos > dbg_head)
+		return NULL;
+	return &dbg_info[*pos];
+}
+
+static void *lro_dbg_info_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	if (++*pos > dbg_head)
+		return NULL;
+	return &dbg_info[*pos];
+}
+
+static void lro_dbg_info_seq_stop(struct seq_file *s, void *v)
+{
+
+}
+
+static int lro_dbg_info_seq_show(struct seq_file *s, void *v)
+{
+	struct lro_dbg_info *pinfo = (struct lro_dbg_info *)v;
+
+	seq_puts(s, "===============LRO Debug info==================\n");
+	seq_printf(s, "Except reason: %d \t\n", pinfo->except_reason);
+	seq_printf(s, "TCP sequence no: %x \t\n", pinfo->tcp_seq_no);
+	seq_printf(s, "Total aggr len: %d \t\n", pinfo->aggr_len);
+	seq_puts(s, "<===============>\n");
+	return 0;
+}
+
+static const struct seq_operations lro_debug_info_seq_ops = {
+	.start = lro_dbg_info_seq_start,
+	.next = lro_dbg_info_seq_next,
+	.stop = lro_dbg_info_seq_stop,
+	.show = lro_dbg_info_seq_show,
+};
+
+static int ltq_lro_dbg_info_seq_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &lro_debug_info_seq_ops);
+}
+
+static const struct file_operations ltq_lro_debug_info_proc_fops = {
+	.open = ltq_lro_dbg_info_seq_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+#endif
+
+/** create proc for debug  info, used ifx_dma_init_module */
+static int ltq_toe_proc_init (void)
+{
+	struct proc_dir_entry *entry;
+
+	g_toe_dir = proc_mkdir("driver/ltq_toe", NULL);
+	if (!g_toe_dir)
+		return -ENOMEM;
+
+	entry = proc_create("register", 0,
+			g_toe_dir, &ltq_toe_reg_proc_fops);
+	if (!entry)
+		goto err1;
+
+	entry = proc_create("lro_stats", 0,
+			g_toe_dir, &ltq_lro_stats_proc_fops);
+	if (!entry)
+		goto err1;
+
+#ifdef LRO_DEBUG
+	entry = proc_create("lro_dbg_info", 0,
+			g_toe_dir, &ltq_lro_debug_info_proc_fops);
+	if (!entry)
+		goto err1;
+#endif
+
+	return 0;
+err1:
+	remove_proc_entry("driver/ltq_toe", NULL);
+	return -ENOMEM;
+}
+
+static int ltq_toe_init(struct platform_device *pdev)
+{
+	struct resource *r;
+	struct resource irqres[15];
+#ifndef CONFIG_LTQ_TOE_USE_SW_POLLING
+	int tso_irq;
+	struct cpumask cpumask;
+#endif
+	struct device_node *node = pdev->dev.of_node;
+	int ret_val, i;
+
+	/* Get the TOE base address */
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		dev_err(&pdev->dev, "platform_get_resource\n");
+		ret_val = -ENOENT;
+		return ret_val;
+	}
+
+	r = devm_request_mem_region(&pdev->dev, r->start, resource_size(r),
+			pdev->name);
+	if (!r) {
+		dev_err(&pdev->dev, "failed to request memory region\n");
+		ret_val = -ENXIO;
+		return ret_val;
+	}
+
+	pr_debug ("ltq_toe_membase from DT: %x \n", (unsigned int) r->start);
+	ltq_toe_membase = devm_ioremap_nocache(&pdev->dev,
+		r->start, resource_size(r));
+
+	if (!ltq_toe_membase) {
+		dev_err(&pdev->dev, "failed to remap memory region\n");
+		ret_val = -ENXIO;
+		return ret_val;
+	}
+
+	/* Get the LRO output context base address */
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (r == NULL) {
+		dev_err(&pdev->dev, "platform_get_resource failed for LRO\n");
+		ret_val = -ENOENT;
+		return ret_val;
+	}
+
+	r = devm_request_mem_region(&pdev->dev, r->start, resource_size(r),
+			pdev->name);
+	if (!r) {
+		dev_err(&pdev->dev, "failed to request LRO memory region\n");
+		ret_val = -ENXIO;
+		return ret_val;
+	}
+
+	pr_info ("lro_sram_membase_res0 from DT: %x \n", (unsigned int) r->start);
+	lro_sram_membase_res0 = devm_ioremap_nocache(&pdev->dev,
+		r->start, resource_size(r));
+
+	if (!lro_sram_membase_res0) {
+		dev_err(&pdev->dev, "failed to remap memory region for LRO\n");
+		ret_val = -ENXIO;
+		return ret_val;
+	}
+
+	/* Get the interrupt numbers */
+	ret_val = of_irq_to_resource_table(node, irqres, 15);
+	if (ret_val != 15) {
+		dev_err(&pdev->dev,
+			"failed to get irq for toe port\n");
+		return -ENODEV;
+	}
+
+	pr_info("ltq_toe_membase: %x and lro_sram_membase_res0: %x\n", (unsigned int)ltq_toe_membase, (unsigned int)lro_sram_membase_res0);
+
+	/* Initialise the 4 ports */
+	for_each_online_cpu(i) {
+		ltq_tso_port[i].membase = ltq_toe_membase + (i*0x20);
+
+#ifndef CONFIG_LTQ_TOE_USE_SW_POLLING
+		/* Register the interrupt handler for TSO */
+		tso_irq = irqres[i+1].start;
+		ret_val = request_irq(tso_irq, ltq_tso_tx_int,
+									0, "tso_irq", NULL);
+		if (ret_val) {
+			pr_err("failed to request tso_tx_irq \n");
+			return ret_val;
+		}
+
+		/* Set the affinity */
+		cpumask.bits[0] = (1 << i);
+		if (irq_set_affinity(tso_irq, &cpumask))
+			pr_err("can not set affinity for IRQ - %d", tso_irq);
+
+		tasklet_init(&tso_tasklet[i],
+			ltq_tso_tasklet, (unsigned long) i);
+#endif
+	}
+
+	/* Register the interrupt handlers for the LRO */
+	for (i = 7; i < (7 + LTQ_MAX_LRO_PORTS); i++) {
+		ltq_lro_port[i-7].port_num = i-7;
+		ltq_lro_port[i-7].irq_num = irqres[i].start;
+		ret_val = request_irq(irqres[i].start, lro_port_context_isr,
+					0, "lro_irq", &ltq_lro_port[i-7]);
+		if (ret_val) {
+			pr_err("failed to request lro_irq \n");
+			return ret_val;
+		}
+		tasklet_init(&lro_tasklet[i-7],
+			ltq_lro_tasklet, (unsigned long) &ltq_lro_port[i-7]);
+		disable_irq(irqres[i].start);
+	}
+
+#if 1
+	ret_val = request_irq(191, lro_port_except_isr,
+					0, "lro_except_irq", NULL);
+	if (ret_val) {
+		pr_err("failed to request lro exception irq \n");
+		return ret_val;
+	}
+	tasklet_init(&lro_exception_tasklet, ltq_lro_exception_tasklet, 0l);
+#endif
+	ret_val = request_irq(190, lro_port_overflow_isr,
+					0, "lro_ovflow_irq", NULL);
+
+	if (ret_val) {
+		pr_err("failed to request lro overflow irq \n");
+		return ret_val;
+	}
+	tasklet_init(&lro_ovflow_tasklet, ltq_lro_ovflow_tasklet, 0);
+
+	/* Set up the DMA3 for ToE */
+	tso_configure_dma();
+
+	/* Enable the ToE at top level */
+	ltq_toe_w32_mask(0, (CONST_TSO_GCTRL_ENABLE_EN << TSO_GCTRL_ENABLE_POS), TSO_GCTRL);
+
+	/* Mask all the interrupts */
+	ltq_toe_w32(0xffffffff, TOE_INT_MASK);
+
+	/* Configure and enable the TSO */
+	configure_tso();
+
+	/* Configure and enable the LRO */
+	configure_lro();
+
+	/* Initialise the proc filesystem */
+	ltq_toe_proc_init();
+
+	spin_lock_init(&tso_register_lock);
+	spin_lock_init(&tso_tx_lock);
+
+	g_toe_dev = &pdev->dev;
+
+	pr_info("TOE Init Done !!\n");
+	return 0;
+}
+
+static int ltq_toe_exit(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static const struct of_device_id ltq_toe_match[] = {
+	{ .compatible = "lantiq,toe-xrx500" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ltq_toe_match);
+
+static struct platform_driver ltq_toe_driver = {
+	.probe = ltq_toe_init,
+	.remove = ltq_toe_exit,
+	.driver = {
+		.name = "toe-xrx500",
+		.owner = THIS_MODULE,
+		.of_match_table = ltq_toe_match,
+	},
+};
+
+module_platform_driver(ltq_toe_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Suresh Nagaraj, suresh.nagaraj@lantiq.com");
+MODULE_DESCRIPTION("Lantiq TOE driver");
+MODULE_SUPPORTED_DEVICE("Lantiq TOE IP module");
diff --git a/drivers/net/ethernet/lantiq/ltq_toe_drv.h b/drivers/net/ethernet/lantiq/ltq_toe_drv.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/ltq_toe_drv.h
@@ -0,0 +1,20 @@
+#define LTQ_MAX_TSO_PORTS 4
+#define MAX_NUMBER_OF_CMDS 100
+#define LTQ_MAX_LRO_PORTS 8
+
+typedef struct ltq_tso_port {
+	unsigned char __iomem *membase; /* Virtual */
+} ltq_tso_port_t;
+
+typedef struct ltq_lro_port {
+	unsigned char __iomem *membase; /* Virtual */
+	u32 port_num;
+	unsigned int irq_num;
+	bool in_use;
+	int session_id;
+	int to_read;
+} ltq_lro_port_t;
+
+static ltq_tso_port_t ltq_tso_port[NR_CPUS];
+
+static ltq_lro_port_t ltq_lro_port[LTQ_MAX_LRO_PORTS];
diff --git a/drivers/net/ethernet/lantiq/ltq_toe_reg.h b/drivers/net/ethernet/lantiq/ltq_toe_reg.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/ltq_toe_reg.h
@@ -0,0 +1,4787 @@
+//-----------------------------------------------------------------------------
+// LSD Generator
+//-----------------------------------------------------------------------------
+// Perl Package        : LSD::generator::targetC (v1.1)
+// LSD Source          : D:/Users/shij/Perforce/l1033.grx500.win.v_shij.priv.dfv.grx500.dfv/ipg_lsd/lsd_sys/source/xml/reg_files/TSO.xml
+// Register File Name  : TOE_CTRL
+// Register File Title : TOE module Register Description
+// Register Width      : 32
+// Note                : Doxygen compliant comments
+//-----------------------------------------------------------------------------
+
+#ifndef _TOE_CTRL_H
+#define _TOE_CTRL_H
+
+//! \defgroup TOE_CTRL Register File TOE_CTRL - TOE module Register Description
+//! @{
+
+
+//! \defgroup PORT_REQ_CMD_REG0_0 Register PORT_REQ_CMD_REG0_0 - Port 0 request command register 0
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG0_0 0x0
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG0_0_RST 0x00000000u
+
+//! Field LEN - Data Block/Segment Length
+#define PORT_REQ_CMD_REG0_0_LEN_POS 0
+//! Field LEN - Data Block/Segment Length
+#define PORT_REQ_CMD_REG0_0_LEN_MASK 0xFFFFFu
+
+//! Field CHUNK_SIZ - Chunk size index
+#define PORT_REQ_CMD_REG0_0_CHUNK_SIZ_POS 20
+//! Field CHUNK_SIZ - Chunk size index
+#define PORT_REQ_CMD_REG0_0_CHUNK_SIZ_MASK 0x700000u
+
+//! Field SIOC - IOCU1 Address Translation for Source Address
+#define PORT_REQ_CMD_REG0_0_SIOC_POS 23
+//! Field SIOC - IOCU1 Address Translation for Source Address
+#define PORT_REQ_CMD_REG0_0_SIOC_MASK 0x800000u
+//! Constant NIL - no translation (default)
+#define CONST_PORT_REQ_CMD_REG0_0_SIOC_NIL 0x0
+//! Constant SIOC - Do translation
+#define CONST_PORT_REQ_CMD_REG0_0_SIOC_SIOC 0x1
+
+//! Field LAST - Last fragment of gathering
+#define PORT_REQ_CMD_REG0_0_LAST_POS 24
+//! Field LAST - Last fragment of gathering
+#define PORT_REQ_CMD_REG0_0_LAST_MASK 0x1000000u
+//! Constant NIL - not (default)
+#define CONST_PORT_REQ_CMD_REG0_0_LAST_NIL 0x0
+//! Constant LAST - Last fragment of gathering
+#define CONST_PORT_REQ_CMD_REG0_0_LAST_LAST 0x1
+
+//! Field G - Indication of gathering
+#define PORT_REQ_CMD_REG0_0_G_POS 25
+//! Field G - Indication of gathering
+#define PORT_REQ_CMD_REG0_0_G_MASK 0x2000000u
+//! Constant NIL - not (default)
+#define CONST_PORT_REQ_CMD_REG0_0_G_NIL 0x0
+//! Constant GATH - fragment of gathering
+#define CONST_PORT_REQ_CMD_REG0_0_G_GATH 0x1
+
+//! Field DIOC - Destination address needs to be translated into IOCU range
+#define PORT_REQ_CMD_REG0_0_DIOC_POS 26
+//! Field DIOC - Destination address needs to be translated into IOCU range
+#define PORT_REQ_CMD_REG0_0_DIOC_MASK 0x4000000u
+
+//! Field IE - Enable Interrupt for this port
+#define PORT_REQ_CMD_REG0_0_IE_POS 29
+//! Field IE - Enable Interrupt for this port
+#define PORT_REQ_CMD_REG0_0_IE_MASK 0x20000000u
+//! Constant NIL - not (default)
+#define CONST_PORT_REQ_CMD_REG0_0_IE_NIL 0x0
+//! Constant IE - Generate INT
+#define CONST_PORT_REQ_CMD_REG0_0_IE_IE 0x1
+
+//! Field DPHY - Destination address is Physical address
+#define PORT_REQ_CMD_REG0_0_DPHY_POS 30
+//! Field DPHY - Destination address is Physical address
+#define PORT_REQ_CMD_REG0_0_DPHY_MASK 0x40000000u
+
+//! Field SPHY - Source address is physical address
+#define PORT_REQ_CMD_REG0_0_SPHY_POS 31
+//! Field SPHY - Source address is physical address
+#define PORT_REQ_CMD_REG0_0_SPHY_MASK 0x80000000u
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG1_0 Register PORT_REQ_CMD_REG1_0 - Request Command Source Buffer Pointer
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG1_0 0x4
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG1_0_RST 0x00000000u
+
+//! Field SRC_A - Source Address of data block
+#define PORT_REQ_CMD_REG1_0_SRC_A_POS 0
+//! Field SRC_A - Source Address of data block
+#define PORT_REQ_CMD_REG1_0_SRC_A_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG2_0 Register PORT_REQ_CMD_REG2_0 - Request command register 2
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG2_0 0x8
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG2_0_RST 0x00000000u
+
+//! Field DMA_WORD0 - DMA Descriptor sideband DWORD 0
+#define PORT_REQ_CMD_REG2_0_DMA_WORD0_POS 0
+//! Field DMA_WORD0 - DMA Descriptor sideband DWORD 0
+#define PORT_REQ_CMD_REG2_0_DMA_WORD0_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG3_0 Register PORT_REQ_CMD_REG3_0 - Request command register 3
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG3_0 0xC
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG3_0_RST 0x00000000u
+
+//! Field DMA_WORD1 - DMA Descriptor sideband DWORD1
+#define PORT_REQ_CMD_REG3_0_DMA_WORD1_POS 0
+//! Field DMA_WORD1 - DMA Descriptor sideband DWORD1
+#define PORT_REQ_CMD_REG3_0_DMA_WORD1_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG4_0 Register PORT_REQ_CMD_REG4_0 - Request Command Packet Buffer Pointer
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG4_0 0x10
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG4_0_RST 0x00000000u
+
+//! Field PKT_A - Packet buffer address
+#define PORT_REQ_CMD_REG4_0_PKT_A_POS 0
+//! Field PKT_A - Packet buffer address
+#define PORT_REQ_CMD_REG4_0_PKT_A_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG5_0 Register PORT_REQ_CMD_REG5_0 - Request Command register 5
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG5_0 0x14
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG5_0_RST 0x80000000u
+
+//! Field SEG_LEN - SEGMENT LENGTH
+#define PORT_REQ_CMD_REG5_0_SEG_LEN_POS 0
+//! Field SEG_LEN - SEGMENT LENGTH
+#define PORT_REQ_CMD_REG5_0_SEG_LEN_MASK 0x1FFFu
+
+//! Field JUMBO - Indication of Segment Length exceeds Standard Packet Size
+#define PORT_REQ_CMD_REG5_0_JUMBO_POS 13
+//! Field JUMBO - Indication of Segment Length exceeds Standard Packet Size
+#define PORT_REQ_CMD_REG5_0_JUMBO_MASK 0x2000u
+//! Constant STD - Segment Length not exceeds 1.5KB
+#define CONST_PORT_REQ_CMD_REG5_0_JUMBO_STD 0x0
+//! Constant JUMBO - Segment Length exceeds 1.5KB, up to 4KBytes
+#define CONST_PORT_REQ_CMD_REG5_0_JUMBO_JUMBO 0x1
+
+//! Field TCP - TCP Packet Indication
+#define PORT_REQ_CMD_REG5_0_TCP_POS 14
+//! Field TCP - TCP Packet Indication
+#define PORT_REQ_CMD_REG5_0_TCP_MASK 0x4000u
+//! Constant OTH - No TCP Packet
+#define CONST_PORT_REQ_CMD_REG5_0_TCP_OTH 0x0
+//! Constant TCP - Packet is TCP packet
+#define CONST_PORT_REQ_CMD_REG5_0_TCP_TCP 0x1
+
+//! Field TIRQ - Enable TSO Interrupt for the CMD port
+#define PORT_REQ_CMD_REG5_0_TIRQ_POS 30
+//! Field TIRQ - Enable TSO Interrupt for the CMD port
+#define PORT_REQ_CMD_REG5_0_TIRQ_MASK 0x40000000u
+//! Constant DIS - No interrupt after TSO
+#define CONST_PORT_REQ_CMD_REG5_0_TIRQ_DIS 0x0
+//! Constant EN - Enable Interrupt
+#define CONST_PORT_REQ_CMD_REG5_0_TIRQ_EN 0x1
+
+//! Field OWN - OWNER bit of the Command
+#define PORT_REQ_CMD_REG5_0_OWN_POS 31
+//! Field OWN - OWNER bit of the Command
+#define PORT_REQ_CMD_REG5_0_OWN_MASK 0x80000000u
+//! Constant TSO - TSO owns the command
+#define CONST_PORT_REQ_CMD_REG5_0_OWN_TSO 0x0
+//! Constant CPU - CPU Owns the command
+#define CONST_PORT_REQ_CMD_REG5_0_OWN_CPU 0x1
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG0_1 Register PORT_REQ_CMD_REG0_1 - Port 0 request command register 0
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG0_1 0x20
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG0_1_RST 0x00000000u
+
+//! Field LEN - Data Block/Segment Length
+#define PORT_REQ_CMD_REG0_1_LEN_POS 0
+//! Field LEN - Data Block/Segment Length
+#define PORT_REQ_CMD_REG0_1_LEN_MASK 0xFFFFFu
+
+//! Field CHUNK_SIZ - Chunk size index
+#define PORT_REQ_CMD_REG0_1_CHUNK_SIZ_POS 20
+//! Field CHUNK_SIZ - Chunk size index
+#define PORT_REQ_CMD_REG0_1_CHUNK_SIZ_MASK 0x700000u
+
+//! Field SIOC - IOCU1 Address Translation for Source Address
+#define PORT_REQ_CMD_REG0_1_SIOC_POS 23
+//! Field SIOC - IOCU1 Address Translation for Source Address
+#define PORT_REQ_CMD_REG0_1_SIOC_MASK 0x800000u
+//! Constant NIL - no translation (default)
+#define CONST_PORT_REQ_CMD_REG0_1_SIOC_NIL 0x0
+//! Constant SIOC - Do translation
+#define CONST_PORT_REQ_CMD_REG0_1_SIOC_SIOC 0x1
+
+//! Field LAST - Last fragment of gathering
+#define PORT_REQ_CMD_REG0_1_LAST_POS 24
+//! Field LAST - Last fragment of gathering
+#define PORT_REQ_CMD_REG0_1_LAST_MASK 0x1000000u
+//! Constant NIL - not (default)
+#define CONST_PORT_REQ_CMD_REG0_1_LAST_NIL 0x0
+//! Constant LAST - Last fragment of gathering
+#define CONST_PORT_REQ_CMD_REG0_1_LAST_LAST 0x1
+
+//! Field G - Indication of gathering
+#define PORT_REQ_CMD_REG0_1_G_POS 25
+//! Field G - Indication of gathering
+#define PORT_REQ_CMD_REG0_1_G_MASK 0x2000000u
+//! Constant NIL - not (default)
+#define CONST_PORT_REQ_CMD_REG0_1_G_NIL 0x0
+//! Constant GATH - fragment of gathering
+#define CONST_PORT_REQ_CMD_REG0_1_G_GATH 0x1
+
+//! Field DIOC - Destination address needs to be translated into IOCU range
+#define PORT_REQ_CMD_REG0_1_DIOC_POS 26
+//! Field DIOC - Destination address needs to be translated into IOCU range
+#define PORT_REQ_CMD_REG0_1_DIOC_MASK 0x4000000u
+
+//! Field IE - Enable Interrupt for this port
+#define PORT_REQ_CMD_REG0_1_IE_POS 29
+//! Field IE - Enable Interrupt for this port
+#define PORT_REQ_CMD_REG0_1_IE_MASK 0x20000000u
+//! Constant NIL - not (default)
+#define CONST_PORT_REQ_CMD_REG0_1_IE_NIL 0x0
+//! Constant IE - Generate INT
+#define CONST_PORT_REQ_CMD_REG0_1_IE_IE 0x1
+
+//! Field DPHY - Destination address is Physical address
+#define PORT_REQ_CMD_REG0_1_DPHY_POS 30
+//! Field DPHY - Destination address is Physical address
+#define PORT_REQ_CMD_REG0_1_DPHY_MASK 0x40000000u
+
+//! Field SPHY - Source address is physical address
+#define PORT_REQ_CMD_REG0_1_SPHY_POS 31
+//! Field SPHY - Source address is physical address
+#define PORT_REQ_CMD_REG0_1_SPHY_MASK 0x80000000u
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG1_1 Register PORT_REQ_CMD_REG1_1 - Request Command Source Buffer Pointer
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG1_1 0x24
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG1_1_RST 0x00000000u
+
+//! Field SRC_A - Source Address of data block
+#define PORT_REQ_CMD_REG1_1_SRC_A_POS 0
+//! Field SRC_A - Source Address of data block
+#define PORT_REQ_CMD_REG1_1_SRC_A_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG2_1 Register PORT_REQ_CMD_REG2_1 - Request command register 2
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG2_1 0x28
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG2_1_RST 0x00000000u
+
+//! Field DMA_WORD0 - DMA Descriptor sideband DWORD 0
+#define PORT_REQ_CMD_REG2_1_DMA_WORD0_POS 0
+//! Field DMA_WORD0 - DMA Descriptor sideband DWORD 0
+#define PORT_REQ_CMD_REG2_1_DMA_WORD0_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG3_1 Register PORT_REQ_CMD_REG3_1 - Request command register 3
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG3_1 0x2C
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG3_1_RST 0x00000000u
+
+//! Field DMA_WORD1 - DMA Descriptor sideband DWORD1
+#define PORT_REQ_CMD_REG3_1_DMA_WORD1_POS 0
+//! Field DMA_WORD1 - DMA Descriptor sideband DWORD1
+#define PORT_REQ_CMD_REG3_1_DMA_WORD1_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG4_1 Register PORT_REQ_CMD_REG4_1 - Request Command Packet Buffer Pointer
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG4_1 0x30
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG4_1_RST 0x00000000u
+
+//! Field PKT_A - Packet buffer address
+#define PORT_REQ_CMD_REG4_1_PKT_A_POS 0
+//! Field PKT_A - Packet buffer address
+#define PORT_REQ_CMD_REG4_1_PKT_A_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG5_1 Register PORT_REQ_CMD_REG5_1 - Request Command register 5
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG5_1 0x34
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG5_1_RST 0x80000000u
+
+//! Field SEG_LEN - SEGMENT LENGTH
+#define PORT_REQ_CMD_REG5_1_SEG_LEN_POS 0
+//! Field SEG_LEN - SEGMENT LENGTH
+#define PORT_REQ_CMD_REG5_1_SEG_LEN_MASK 0x1FFFu
+
+//! Field JUMBO - Indication of Segment Length exceeds Standard Packet Size
+#define PORT_REQ_CMD_REG5_1_JUMBO_POS 13
+//! Field JUMBO - Indication of Segment Length exceeds Standard Packet Size
+#define PORT_REQ_CMD_REG5_1_JUMBO_MASK 0x2000u
+//! Constant STD - Segment Length not exceeds 1.5KB
+#define CONST_PORT_REQ_CMD_REG5_1_JUMBO_STD 0x0
+//! Constant JUMBO - Segment Length exceeds 1.5KB, up to 4KBytes
+#define CONST_PORT_REQ_CMD_REG5_1_JUMBO_JUMBO 0x1
+
+//! Field TCP - TCP Packet Indication
+#define PORT_REQ_CMD_REG5_1_TCP_POS 14
+//! Field TCP - TCP Packet Indication
+#define PORT_REQ_CMD_REG5_1_TCP_MASK 0x4000u
+//! Constant OTH - No TCP Packet
+#define CONST_PORT_REQ_CMD_REG5_1_TCP_OTH 0x0
+//! Constant TCP - Packet is TCP packet
+#define CONST_PORT_REQ_CMD_REG5_1_TCP_TCP 0x1
+
+//! Field TIRQ - Enable TSO Interrupt for the CMD port
+#define PORT_REQ_CMD_REG5_1_TIRQ_POS 30
+//! Field TIRQ - Enable TSO Interrupt for the CMD port
+#define PORT_REQ_CMD_REG5_1_TIRQ_MASK 0x40000000u
+//! Constant DIS - No interrupt after TSO
+#define CONST_PORT_REQ_CMD_REG5_1_TIRQ_DIS 0x0
+//! Constant EN - Enable Interrupt
+#define CONST_PORT_REQ_CMD_REG5_1_TIRQ_EN 0x1
+
+//! Field OWN - OWNER bit of the Command
+#define PORT_REQ_CMD_REG5_1_OWN_POS 31
+//! Field OWN - OWNER bit of the Command
+#define PORT_REQ_CMD_REG5_1_OWN_MASK 0x80000000u
+//! Constant TSO - TSO owns the command
+#define CONST_PORT_REQ_CMD_REG5_1_OWN_TSO 0x0
+//! Constant CPU - CPU Owns the command
+#define CONST_PORT_REQ_CMD_REG5_1_OWN_CPU 0x1
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG0_2 Register PORT_REQ_CMD_REG0_2 - Port 0 request command register 0
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG0_2 0x40
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG0_2_RST 0x00000000u
+
+//! Field LEN - Data Block/Segment Length
+#define PORT_REQ_CMD_REG0_2_LEN_POS 0
+//! Field LEN - Data Block/Segment Length
+#define PORT_REQ_CMD_REG0_2_LEN_MASK 0xFFFFFu
+
+//! Field CHUNK_SIZ - Chunk size index
+#define PORT_REQ_CMD_REG0_2_CHUNK_SIZ_POS 20
+//! Field CHUNK_SIZ - Chunk size index
+#define PORT_REQ_CMD_REG0_2_CHUNK_SIZ_MASK 0x700000u
+
+//! Field SIOC - IOCU1 Address Translation for Source Address
+#define PORT_REQ_CMD_REG0_2_SIOC_POS 23
+//! Field SIOC - IOCU1 Address Translation for Source Address
+#define PORT_REQ_CMD_REG0_2_SIOC_MASK 0x800000u
+//! Constant NIL - no translation (default)
+#define CONST_PORT_REQ_CMD_REG0_2_SIOC_NIL 0x0
+//! Constant SIOC - Do translation
+#define CONST_PORT_REQ_CMD_REG0_2_SIOC_SIOC 0x1
+
+//! Field LAST - Last fragment of gathering
+#define PORT_REQ_CMD_REG0_2_LAST_POS 24
+//! Field LAST - Last fragment of gathering
+#define PORT_REQ_CMD_REG0_2_LAST_MASK 0x1000000u
+//! Constant NIL - not (default)
+#define CONST_PORT_REQ_CMD_REG0_2_LAST_NIL 0x0
+//! Constant LAST - Last fragment of gathering
+#define CONST_PORT_REQ_CMD_REG0_2_LAST_LAST 0x1
+
+//! Field G - Indication of gathering
+#define PORT_REQ_CMD_REG0_2_G_POS 25
+//! Field G - Indication of gathering
+#define PORT_REQ_CMD_REG0_2_G_MASK 0x2000000u
+//! Constant NIL - not (default)
+#define CONST_PORT_REQ_CMD_REG0_2_G_NIL 0x0
+//! Constant GATH - fragment of gathering
+#define CONST_PORT_REQ_CMD_REG0_2_G_GATH 0x1
+
+//! Field DIOC - Destination address needs to be translated into IOCU range
+#define PORT_REQ_CMD_REG0_2_DIOC_POS 26
+//! Field DIOC - Destination address needs to be translated into IOCU range
+#define PORT_REQ_CMD_REG0_2_DIOC_MASK 0x4000000u
+
+//! Field IE - Enable Interrupt for this port
+#define PORT_REQ_CMD_REG0_2_IE_POS 29
+//! Field IE - Enable Interrupt for this port
+#define PORT_REQ_CMD_REG0_2_IE_MASK 0x20000000u
+//! Constant NIL - not (default)
+#define CONST_PORT_REQ_CMD_REG0_2_IE_NIL 0x0
+//! Constant IE - Generate INT
+#define CONST_PORT_REQ_CMD_REG0_2_IE_IE 0x1
+
+//! Field DPHY - Destination address is Physical address
+#define PORT_REQ_CMD_REG0_2_DPHY_POS 30
+//! Field DPHY - Destination address is Physical address
+#define PORT_REQ_CMD_REG0_2_DPHY_MASK 0x40000000u
+
+//! Field SPHY - Source address is physical address
+#define PORT_REQ_CMD_REG0_2_SPHY_POS 31
+//! Field SPHY - Source address is physical address
+#define PORT_REQ_CMD_REG0_2_SPHY_MASK 0x80000000u
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG1_2 Register PORT_REQ_CMD_REG1_2 - Request Command Source Buffer Pointer
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG1_2 0x44
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG1_2_RST 0x00000000u
+
+//! Field SRC_A - Source Address of data block
+#define PORT_REQ_CMD_REG1_2_SRC_A_POS 0
+//! Field SRC_A - Source Address of data block
+#define PORT_REQ_CMD_REG1_2_SRC_A_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG2_2 Register PORT_REQ_CMD_REG2_2 - Request command register 2
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG2_2 0x48
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG2_2_RST 0x00000000u
+
+//! Field DMA_WORD0 - DMA Descriptor sideband DWORD 0
+#define PORT_REQ_CMD_REG2_2_DMA_WORD0_POS 0
+//! Field DMA_WORD0 - DMA Descriptor sideband DWORD 0
+#define PORT_REQ_CMD_REG2_2_DMA_WORD0_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG3_2 Register PORT_REQ_CMD_REG3_2 - Request command register 3
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG3_2 0x4C
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG3_2_RST 0x00000000u
+
+//! Field DMA_WORD1 - DMA Descriptor sideband DWORD1
+#define PORT_REQ_CMD_REG3_2_DMA_WORD1_POS 0
+//! Field DMA_WORD1 - DMA Descriptor sideband DWORD1
+#define PORT_REQ_CMD_REG3_2_DMA_WORD1_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG4_2 Register PORT_REQ_CMD_REG4_2 - Request Command Packet Buffer Pointer
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG4_2 0x50
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG4_2_RST 0x00000000u
+
+//! Field PKT_A - Packet buffer address
+#define PORT_REQ_CMD_REG4_2_PKT_A_POS 0
+//! Field PKT_A - Packet buffer address
+#define PORT_REQ_CMD_REG4_2_PKT_A_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG5_2 Register PORT_REQ_CMD_REG5_2 - Request Command register 5
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG5_2 0x54
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG5_2_RST 0x80000000u
+
+//! Field SEG_LEN - SEGMENT LENGTH
+#define PORT_REQ_CMD_REG5_2_SEG_LEN_POS 0
+//! Field SEG_LEN - SEGMENT LENGTH
+#define PORT_REQ_CMD_REG5_2_SEG_LEN_MASK 0x1FFFu
+
+//! Field JUMBO - Indication of Segment Length exceeds Standard Packet Size
+#define PORT_REQ_CMD_REG5_2_JUMBO_POS 13
+//! Field JUMBO - Indication of Segment Length exceeds Standard Packet Size
+#define PORT_REQ_CMD_REG5_2_JUMBO_MASK 0x2000u
+//! Constant STD - Segment Length not exceeds 1.5KB
+#define CONST_PORT_REQ_CMD_REG5_2_JUMBO_STD 0x0
+//! Constant JUMBO - Segment Length exceeds 1.5KB, up to 4KBytes
+#define CONST_PORT_REQ_CMD_REG5_2_JUMBO_JUMBO 0x1
+
+//! Field TCP - TCP Packet Indication
+#define PORT_REQ_CMD_REG5_2_TCP_POS 14
+//! Field TCP - TCP Packet Indication
+#define PORT_REQ_CMD_REG5_2_TCP_MASK 0x4000u
+//! Constant OTH - No TCP Packet
+#define CONST_PORT_REQ_CMD_REG5_2_TCP_OTH 0x0
+//! Constant TCP - Packet is TCP packet
+#define CONST_PORT_REQ_CMD_REG5_2_TCP_TCP 0x1
+
+//! Field TIRQ - Enable TSO Interrupt for the CMD port
+#define PORT_REQ_CMD_REG5_2_TIRQ_POS 30
+//! Field TIRQ - Enable TSO Interrupt for the CMD port
+#define PORT_REQ_CMD_REG5_2_TIRQ_MASK 0x40000000u
+//! Constant DIS - No interrupt after TSO
+#define CONST_PORT_REQ_CMD_REG5_2_TIRQ_DIS 0x0
+//! Constant EN - Enable Interrupt
+#define CONST_PORT_REQ_CMD_REG5_2_TIRQ_EN 0x1
+
+//! Field OWN - OWNER bit of the Command
+#define PORT_REQ_CMD_REG5_2_OWN_POS 31
+//! Field OWN - OWNER bit of the Command
+#define PORT_REQ_CMD_REG5_2_OWN_MASK 0x80000000u
+//! Constant TSO - TSO owns the command
+#define CONST_PORT_REQ_CMD_REG5_2_OWN_TSO 0x0
+//! Constant CPU - CPU Owns the command
+#define CONST_PORT_REQ_CMD_REG5_2_OWN_CPU 0x1
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG0_3 Register PORT_REQ_CMD_REG0_3 - Port 0 request command register 0
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG0_3 0x60
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG0_3_RST 0x00000000u
+
+//! Field LEN - Data Block/Segment Length
+#define PORT_REQ_CMD_REG0_3_LEN_POS 0
+//! Field LEN - Data Block/Segment Length
+#define PORT_REQ_CMD_REG0_3_LEN_MASK 0xFFFFFu
+
+//! Field CHUNK_SIZ - Chunk size index
+#define PORT_REQ_CMD_REG0_3_CHUNK_SIZ_POS 20
+//! Field CHUNK_SIZ - Chunk size index
+#define PORT_REQ_CMD_REG0_3_CHUNK_SIZ_MASK 0x700000u
+
+//! Field SIOC - IOCU1 Address Translation for Source Address
+#define PORT_REQ_CMD_REG0_3_SIOC_POS 23
+//! Field SIOC - IOCU1 Address Translation for Source Address
+#define PORT_REQ_CMD_REG0_3_SIOC_MASK 0x800000u
+//! Constant NIL - no translation (default)
+#define CONST_PORT_REQ_CMD_REG0_3_SIOC_NIL 0x0
+//! Constant SIOC - Do translation
+#define CONST_PORT_REQ_CMD_REG0_3_SIOC_SIOC 0x1
+
+//! Field LAST - Last fragment of gathering
+#define PORT_REQ_CMD_REG0_3_LAST_POS 24
+//! Field LAST - Last fragment of gathering
+#define PORT_REQ_CMD_REG0_3_LAST_MASK 0x1000000u
+//! Constant NIL - not (default)
+#define CONST_PORT_REQ_CMD_REG0_3_LAST_NIL 0x0
+//! Constant LAST - Last fragment of gathering
+#define CONST_PORT_REQ_CMD_REG0_3_LAST_LAST 0x1
+
+//! Field G - Indication of gathering
+#define PORT_REQ_CMD_REG0_3_G_POS 25
+//! Field G - Indication of gathering
+#define PORT_REQ_CMD_REG0_3_G_MASK 0x2000000u
+//! Constant NIL - not (default)
+#define CONST_PORT_REQ_CMD_REG0_3_G_NIL 0x0
+//! Constant GATH - fragment of gathering
+#define CONST_PORT_REQ_CMD_REG0_3_G_GATH 0x1
+
+//! Field DIOC - Destination address needs to be translated into IOCU range
+#define PORT_REQ_CMD_REG0_3_DIOC_POS 26
+//! Field DIOC - Destination address needs to be translated into IOCU range
+#define PORT_REQ_CMD_REG0_3_DIOC_MASK 0x4000000u
+
+//! Field IE - Enable Interrupt for this port
+#define PORT_REQ_CMD_REG0_3_IE_POS 29
+//! Field IE - Enable Interrupt for this port
+#define PORT_REQ_CMD_REG0_3_IE_MASK 0x20000000u
+//! Constant NIL - not (default)
+#define CONST_PORT_REQ_CMD_REG0_3_IE_NIL 0x0
+//! Constant IE - Generate INT
+#define CONST_PORT_REQ_CMD_REG0_3_IE_IE 0x1
+
+//! Field DPHY - Destination address is Physical address
+#define PORT_REQ_CMD_REG0_3_DPHY_POS 30
+//! Field DPHY - Destination address is Physical address
+#define PORT_REQ_CMD_REG0_3_DPHY_MASK 0x40000000u
+
+//! Field SPHY - Source address is physical address
+#define PORT_REQ_CMD_REG0_3_SPHY_POS 31
+//! Field SPHY - Source address is physical address
+#define PORT_REQ_CMD_REG0_3_SPHY_MASK 0x80000000u
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG1_3 Register PORT_REQ_CMD_REG1_3 - Request Command Source Buffer Pointer
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG1_3 0x64
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG1_3_RST 0x00000000u
+
+//! Field SRC_A - Source Address of data block
+#define PORT_REQ_CMD_REG1_3_SRC_A_POS 0
+//! Field SRC_A - Source Address of data block
+#define PORT_REQ_CMD_REG1_3_SRC_A_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG2_3 Register PORT_REQ_CMD_REG2_3 - Request command register 2
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG2_3 0x68
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG2_3_RST 0x00000000u
+
+//! Field DMA_WORD0 - DMA Descriptor sideband DWORD 0
+#define PORT_REQ_CMD_REG2_3_DMA_WORD0_POS 0
+//! Field DMA_WORD0 - DMA Descriptor sideband DWORD 0
+#define PORT_REQ_CMD_REG2_3_DMA_WORD0_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG3_3 Register PORT_REQ_CMD_REG3_3 - Request command register 3
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG3_3 0x6C
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG3_3_RST 0x00000000u
+
+//! Field DMA_WORD1 - DMA Descriptor sideband DWORD1
+#define PORT_REQ_CMD_REG3_3_DMA_WORD1_POS 0
+//! Field DMA_WORD1 - DMA Descriptor sideband DWORD1
+#define PORT_REQ_CMD_REG3_3_DMA_WORD1_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG4_3 Register PORT_REQ_CMD_REG4_3 - Request Command Packet Buffer Pointer
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG4_3 0x70
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG4_3_RST 0x00000000u
+
+//! Field PKT_A - Packet buffer address
+#define PORT_REQ_CMD_REG4_3_PKT_A_POS 0
+//! Field PKT_A - Packet buffer address
+#define PORT_REQ_CMD_REG4_3_PKT_A_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_REQ_CMD_REG5_3 Register PORT_REQ_CMD_REG5_3 - Request Command register 5
+//! @{
+
+//! Register Offset (relative)
+#define PORT_REQ_CMD_REG5_3 0x74
+
+//! Register Reset Value
+#define PORT_REQ_CMD_REG5_3_RST 0x80000000u
+
+//! Field SEG_LEN - SEGMENT LENGTH
+#define PORT_REQ_CMD_REG5_3_SEG_LEN_POS 0
+//! Field SEG_LEN - SEGMENT LENGTH
+#define PORT_REQ_CMD_REG5_3_SEG_LEN_MASK 0x1FFFu
+
+//! Field JUMBO - Indication of Segment Length exceeds Standard Packet Size
+#define PORT_REQ_CMD_REG5_3_JUMBO_POS 13
+//! Field JUMBO - Indication of Segment Length exceeds Standard Packet Size
+#define PORT_REQ_CMD_REG5_3_JUMBO_MASK 0x2000u
+//! Constant STD - Segment Length not exceeds 1.5KB
+#define CONST_PORT_REQ_CMD_REG5_3_JUMBO_STD 0x0
+//! Constant JUMBO - Segment Length exceeds 1.5KB, up to 4KBytes
+#define CONST_PORT_REQ_CMD_REG5_3_JUMBO_JUMBO 0x1
+
+//! Field TCP - TCP Packet Indication
+#define PORT_REQ_CMD_REG5_3_TCP_POS 14
+//! Field TCP - TCP Packet Indication
+#define PORT_REQ_CMD_REG5_3_TCP_MASK 0x4000u
+//! Constant OTH - No TCP Packet
+#define CONST_PORT_REQ_CMD_REG5_3_TCP_OTH 0x0
+//! Constant TCP - Packet is TCP packet
+#define CONST_PORT_REQ_CMD_REG5_3_TCP_TCP 0x1
+
+//! Field TIRQ - Enable TSO Interrupt for the CMD port
+#define PORT_REQ_CMD_REG5_3_TIRQ_POS 30
+//! Field TIRQ - Enable TSO Interrupt for the CMD port
+#define PORT_REQ_CMD_REG5_3_TIRQ_MASK 0x40000000u
+//! Constant DIS - No interrupt after TSO
+#define CONST_PORT_REQ_CMD_REG5_3_TIRQ_DIS 0x0
+//! Constant EN - Enable Interrupt
+#define CONST_PORT_REQ_CMD_REG5_3_TIRQ_EN 0x1
+
+//! Field OWN - OWNER bit of the Command
+#define PORT_REQ_CMD_REG5_3_OWN_POS 31
+//! Field OWN - OWNER bit of the Command
+#define PORT_REQ_CMD_REG5_3_OWN_MASK 0x80000000u
+//! Constant TSO - TSO owns the command
+#define CONST_PORT_REQ_CMD_REG5_3_OWN_TSO 0x0
+//! Constant CPU - CPU Owns the command
+#define CONST_PORT_REQ_CMD_REG5_3_OWN_CPU 0x1
+
+//! @}
+
+//! \defgroup PORT_RES_REG0_0 Register PORT_RES_REG0_0 - Response register 0
+//! @{
+
+//! Register Offset (relative)
+#define PORT_RES_REG0_0 0x100
+
+//! Register Reset Value
+#define PORT_RES_REG0_0_RST 0x00000000u
+
+//! Field PKT_A - Packet buffer address
+#define PORT_RES_REG0_0_PKT_A_POS 0
+//! Field PKT_A - Packet buffer address
+#define PORT_RES_REG0_0_PKT_A_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_RES_REG1_0 Register PORT_RES_REG1_0 - Response register 1
+//! @{
+
+//! Register Offset (relative)
+#define PORT_RES_REG1_0 0x104
+
+//! Register Reset Value
+#define PORT_RES_REG1_0_RST 0x00000000u
+
+//! Field SEG_NR - Number of segments
+#define PORT_RES_REG1_0_SEG_NR_POS 0
+//! Field SEG_NR - Number of segments
+#define PORT_RES_REG1_0_SEG_NR_MASK 0x1Fu
+
+//! Field CONTEXT - Total Length of all segments
+#define PORT_RES_REG1_0_CONTEXT_POS 6
+//! Field CONTEXT - Total Length of all segments
+#define PORT_RES_REG1_0_CONTEXT_MASK 0x7FFFC0u
+
+//! Field ABORT - Abort by SW
+#define PORT_RES_REG1_0_ABORT_POS 29
+//! Field ABORT - Abort by SW
+#define PORT_RES_REG1_0_ABORT_MASK 0x20000000u
+
+//! Field ERR - TSO Error
+#define PORT_RES_REG1_0_ERR_POS 30
+//! Field ERR - TSO Error
+#define PORT_RES_REG1_0_ERR_MASK 0x40000000u
+//! Constant NIL - no error
+#define CONST_PORT_RES_REG1_0_ERR_NIL 0x0
+//! Constant ERR - TSO is error
+#define CONST_PORT_RES_REG1_0_ERR_ERR 0x1
+
+//! Field DONE - TSO done
+#define PORT_RES_REG1_0_DONE_POS 31
+//! Field DONE - TSO done
+#define PORT_RES_REG1_0_DONE_MASK 0x80000000u
+//! Constant NIL - not done.
+#define CONST_PORT_RES_REG1_0_DONE_NIL 0x0
+//! Constant DONE - TSO is completed
+#define CONST_PORT_RES_REG1_0_DONE_DONE 0x1
+
+//! @}
+
+//! \defgroup PORT_RES_REG0_1 Register PORT_RES_REG0_1 - Response register 0
+//! @{
+
+//! Register Offset (relative)
+#define PORT_RES_REG0_1 0x120
+
+//! Register Reset Value
+#define PORT_RES_REG0_1_RST 0x00000000u
+
+//! Field PKT_A - Packet buffer address
+#define PORT_RES_REG0_1_PKT_A_POS 0
+//! Field PKT_A - Packet buffer address
+#define PORT_RES_REG0_1_PKT_A_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_RES_REG1_1 Register PORT_RES_REG1_1 - Response register 1
+//! @{
+
+//! Register Offset (relative)
+#define PORT_RES_REG1_1 0x124
+
+//! Register Reset Value
+#define PORT_RES_REG1_1_RST 0x00000000u
+
+//! Field SEG_NR - Number of segments
+#define PORT_RES_REG1_1_SEG_NR_POS 0
+//! Field SEG_NR - Number of segments
+#define PORT_RES_REG1_1_SEG_NR_MASK 0x1Fu
+
+//! Field CONTEXT - Total Length of all segments
+#define PORT_RES_REG1_1_CONTEXT_POS 6
+//! Field CONTEXT - Total Length of all segments
+#define PORT_RES_REG1_1_CONTEXT_MASK 0x7FFFC0u
+
+//! Field ABORT - Abort by SW
+#define PORT_RES_REG1_1_ABORT_POS 29
+//! Field ABORT - Abort by SW
+#define PORT_RES_REG1_1_ABORT_MASK 0x20000000u
+
+//! Field ERR - TSO Error
+#define PORT_RES_REG1_1_ERR_POS 30
+//! Field ERR - TSO Error
+#define PORT_RES_REG1_1_ERR_MASK 0x40000000u
+//! Constant NIL - no error
+#define CONST_PORT_RES_REG1_1_ERR_NIL 0x0
+//! Constant ERR - TSO is error
+#define CONST_PORT_RES_REG1_1_ERR_ERR 0x1
+
+//! Field DONE - TSO done
+#define PORT_RES_REG1_1_DONE_POS 31
+//! Field DONE - TSO done
+#define PORT_RES_REG1_1_DONE_MASK 0x80000000u
+//! Constant NIL - not done.
+#define CONST_PORT_RES_REG1_1_DONE_NIL 0x0
+//! Constant DONE - TSO is completed
+#define CONST_PORT_RES_REG1_1_DONE_DONE 0x1
+
+//! @}
+
+//! \defgroup PORT_RES_REG0_2 Register PORT_RES_REG0_2 - Response register 0
+//! @{
+
+//! Register Offset (relative)
+#define PORT_RES_REG0_2 0x140
+
+//! Register Reset Value
+#define PORT_RES_REG0_2_RST 0x00000000u
+
+//! Field PKT_A - Packet buffer address
+#define PORT_RES_REG0_2_PKT_A_POS 0
+//! Field PKT_A - Packet buffer address
+#define PORT_RES_REG0_2_PKT_A_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_RES_REG1_2 Register PORT_RES_REG1_2 - Response register 1
+//! @{
+
+//! Register Offset (relative)
+#define PORT_RES_REG1_2 0x144
+
+//! Register Reset Value
+#define PORT_RES_REG1_2_RST 0x00000000u
+
+//! Field SEG_NR - Number of segments
+#define PORT_RES_REG1_2_SEG_NR_POS 0
+//! Field SEG_NR - Number of segments
+#define PORT_RES_REG1_2_SEG_NR_MASK 0x1Fu
+
+//! Field CONTEXT - Total Length of all segments
+#define PORT_RES_REG1_2_CONTEXT_POS 6
+//! Field CONTEXT - Total Length of all segments
+#define PORT_RES_REG1_2_CONTEXT_MASK 0x7FFFC0u
+
+//! Field ABORT - Abort by SW
+#define PORT_RES_REG1_2_ABORT_POS 29
+//! Field ABORT - Abort by SW
+#define PORT_RES_REG1_2_ABORT_MASK 0x20000000u
+
+//! Field ERR - TSO Error
+#define PORT_RES_REG1_2_ERR_POS 30
+//! Field ERR - TSO Error
+#define PORT_RES_REG1_2_ERR_MASK 0x40000000u
+//! Constant NIL - no error
+#define CONST_PORT_RES_REG1_2_ERR_NIL 0x0
+//! Constant ERR - TSO is error
+#define CONST_PORT_RES_REG1_2_ERR_ERR 0x1
+
+//! Field DONE - TSO done
+#define PORT_RES_REG1_2_DONE_POS 31
+//! Field DONE - TSO done
+#define PORT_RES_REG1_2_DONE_MASK 0x80000000u
+//! Constant NIL - not done.
+#define CONST_PORT_RES_REG1_2_DONE_NIL 0x0
+//! Constant DONE - TSO is completed
+#define CONST_PORT_RES_REG1_2_DONE_DONE 0x1
+
+//! @}
+
+//! \defgroup PORT_RES_REG0_3 Register PORT_RES_REG0_3 - Response register 0
+//! @{
+
+//! Register Offset (relative)
+#define PORT_RES_REG0_3 0x160
+
+//! Register Reset Value
+#define PORT_RES_REG0_3_RST 0x00000000u
+
+//! Field PKT_A - Packet buffer address
+#define PORT_RES_REG0_3_PKT_A_POS 0
+//! Field PKT_A - Packet buffer address
+#define PORT_RES_REG0_3_PKT_A_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup PORT_RES_REG1_3 Register PORT_RES_REG1_3 - Response register 1
+//! @{
+
+//! Register Offset (relative)
+#define PORT_RES_REG1_3 0x164
+
+//! Register Reset Value
+#define PORT_RES_REG1_3_RST 0x00000000u
+
+//! Field SEG_NR - Number of segments
+#define PORT_RES_REG1_3_SEG_NR_POS 0
+//! Field SEG_NR - Number of segments
+#define PORT_RES_REG1_3_SEG_NR_MASK 0x1Fu
+
+//! Field CONTEXT - Total Length of all segments
+#define PORT_RES_REG1_3_CONTEXT_POS 6
+//! Field CONTEXT - Total Length of all segments
+#define PORT_RES_REG1_3_CONTEXT_MASK 0x7FFFC0u
+
+//! Field ABORT - Abort by SW
+#define PORT_RES_REG1_3_ABORT_POS 29
+//! Field ABORT - Abort by SW
+#define PORT_RES_REG1_3_ABORT_MASK 0x20000000u
+
+//! Field ERR - TSO Error
+#define PORT_RES_REG1_3_ERR_POS 30
+//! Field ERR - TSO Error
+#define PORT_RES_REG1_3_ERR_MASK 0x40000000u
+//! Constant NIL - no error
+#define CONST_PORT_RES_REG1_3_ERR_NIL 0x0
+//! Constant ERR - TSO is error
+#define CONST_PORT_RES_REG1_3_ERR_ERR 0x1
+
+//! Field DONE - TSO done
+#define PORT_RES_REG1_3_DONE_POS 31
+//! Field DONE - TSO done
+#define PORT_RES_REG1_3_DONE_MASK 0x80000000u
+//! Constant NIL - not done.
+#define CONST_PORT_RES_REG1_3_DONE_NIL 0x0
+//! Constant DONE - TSO is completed
+#define CONST_PORT_RES_REG1_3_DONE_DONE 0x1
+
+//! @}
+
+//! \defgroup TSO_GCTRL Register TSO_GCTRL - Global Control Register
+//! @{
+
+//! Register Offset (relative)
+#define TSO_GCTRL 0x200
+
+//! Register Reset Value
+#define TSO_GCTRL_RST 0x00040000u
+
+//! Field ENABLE - Enable ToE
+#define TSO_GCTRL_ENABLE_POS 0
+//! Field ENABLE - Enable ToE
+#define TSO_GCTRL_ENABLE_MASK 0x1u
+//! Constant DIS - Disable ToE
+#define CONST_TSO_GCTRL_ENABLE_DIS 0x0
+//! Constant EN - Enable ToE
+#define CONST_TSO_GCTRL_ENABLE_EN 0x1
+
+//! Field ENA_P0 - Enable TSO for PORT0
+#define TSO_GCTRL_ENA_P0_POS 1
+//! Field ENA_P0 - Enable TSO for PORT0
+#define TSO_GCTRL_ENA_P0_MASK 0x2u
+//! Constant DIS - Disable TSO
+#define CONST_TSO_GCTRL_ENA_P0_DIS 0x0
+//! Constant EN - Enable TSO
+#define CONST_TSO_GCTRL_ENA_P0_EN 0x1
+
+//! Field ENA_P1 - Enable TSO for PORT1
+#define TSO_GCTRL_ENA_P1_POS 2
+//! Field ENA_P1 - Enable TSO for PORT1
+#define TSO_GCTRL_ENA_P1_MASK 0x4u
+//! Constant DIS - Disable TSO
+#define CONST_TSO_GCTRL_ENA_P1_DIS 0x0
+//! Constant EN - Enable TSO
+#define CONST_TSO_GCTRL_ENA_P1_EN 0x1
+
+//! Field ENA_P2 - Enable TSO for PORT2
+#define TSO_GCTRL_ENA_P2_POS 3
+//! Field ENA_P2 - Enable TSO for PORT2
+#define TSO_GCTRL_ENA_P2_MASK 0x8u
+//! Constant DIS - Disable TSO
+#define CONST_TSO_GCTRL_ENA_P2_DIS 0x0
+//! Constant EN - Enable TSO
+#define CONST_TSO_GCTRL_ENA_P2_EN 0x1
+
+//! Field ENA_P3 - Enable TSO for PORT3
+#define TSO_GCTRL_ENA_P3_POS 4
+//! Field ENA_P3 - Enable TSO for PORT3
+#define TSO_GCTRL_ENA_P3_MASK 0x10u
+//! Constant DIS - Disable TSO
+#define CONST_TSO_GCTRL_ENA_P3_DIS 0x0
+//! Constant EN - Enable TSO
+#define CONST_TSO_GCTRL_ENA_P3_EN 0x1
+
+//! Field DEBUG_STEP_TSO - Step debugging
+#define TSO_GCTRL_DEBUG_STEP_TSO_POS 5
+//! Field DEBUG_STEP_TSO - Step debugging
+#define TSO_GCTRL_DEBUG_STEP_TSO_MASK 0x20u
+//! Constant OVER - step complete
+#define CONST_TSO_GCTRL_DEBUG_STEP_TSO_OVER 0x0
+//! Constant STEP - step ahead
+#define CONST_TSO_GCTRL_DEBUG_STEP_TSO_STEP 0x1
+
+//! Field DEBUG_STEP_LRO - Step debugging
+#define TSO_GCTRL_DEBUG_STEP_LRO_POS 6
+//! Field DEBUG_STEP_LRO - Step debugging
+#define TSO_GCTRL_DEBUG_STEP_LRO_MASK 0x40u
+//! Constant OVER - step complete
+#define CONST_TSO_GCTRL_DEBUG_STEP_LRO_OVER 0x0
+//! Constant STEP - step ahead
+#define CONST_TSO_GCTRL_DEBUG_STEP_LRO_STEP 0x1
+
+//! Field LRO0_EN - ENABLE LRO 0
+#define TSO_GCTRL_LRO0_EN_POS 8
+//! Field LRO0_EN - ENABLE LRO 0
+#define TSO_GCTRL_LRO0_EN_MASK 0x100u
+//! Constant DISU - DISABLE LRO
+#define CONST_TSO_GCTRL_LRO0_EN_DISU 0x0
+//! Constant ENU - ENABLE LRO
+#define CONST_TSO_GCTRL_LRO0_EN_ENU 0x1
+
+//! Field LRO1_EN - ENABLE LRO 1
+#define TSO_GCTRL_LRO1_EN_POS 9
+//! Field LRO1_EN - ENABLE LRO 1
+#define TSO_GCTRL_LRO1_EN_MASK 0x200u
+//! Constant DISU - DISABLE LRO
+#define CONST_TSO_GCTRL_LRO1_EN_DISU 0x0
+//! Constant ENU - ENABLE LRO
+#define CONST_TSO_GCTRL_LRO1_EN_ENU 0x1
+
+//! Field LRO2_EN - ENABLE LRO 2
+#define TSO_GCTRL_LRO2_EN_POS 10
+//! Field LRO2_EN - ENABLE LRO 2
+#define TSO_GCTRL_LRO2_EN_MASK 0x400u
+//! Constant DISU - DISABLE LRO
+#define CONST_TSO_GCTRL_LRO2_EN_DISU 0x0
+//! Constant ENU - ENABLE LRO
+#define CONST_TSO_GCTRL_LRO2_EN_ENU 0x1
+
+//! Field LRO3_EN - ENABLE LRO 3
+#define TSO_GCTRL_LRO3_EN_POS 11
+//! Field LRO3_EN - ENABLE LRO 3
+#define TSO_GCTRL_LRO3_EN_MASK 0x800u
+//! Constant DISU - DISABLE LRO
+#define CONST_TSO_GCTRL_LRO3_EN_DISU 0x0
+//! Constant ENU - ENABLE LRO
+#define CONST_TSO_GCTRL_LRO3_EN_ENU 0x1
+
+//! Field LRO4_EN - ENABLE LRO 4
+#define TSO_GCTRL_LRO4_EN_POS 12
+//! Field LRO4_EN - ENABLE LRO 4
+#define TSO_GCTRL_LRO4_EN_MASK 0x1000u
+//! Constant DISU - DISABLE LRO
+#define CONST_TSO_GCTRL_LRO4_EN_DISU 0x0
+//! Constant ENU - ENABLE LRO
+#define CONST_TSO_GCTRL_LRO4_EN_ENU 0x1
+
+//! Field LRO5_EN - ENABLE LRO 5
+#define TSO_GCTRL_LRO5_EN_POS 13
+//! Field LRO5_EN - ENABLE LRO 5
+#define TSO_GCTRL_LRO5_EN_MASK 0x2000u
+//! Constant DISU - DISABLE LRO
+#define CONST_TSO_GCTRL_LRO5_EN_DISU 0x0
+//! Constant ENU - ENABLE LRO
+#define CONST_TSO_GCTRL_LRO5_EN_ENU 0x1
+
+//! Field LRO6_EN - ENABLE LRO 6
+#define TSO_GCTRL_LRO6_EN_POS 14
+//! Field LRO6_EN - ENABLE LRO 6
+#define TSO_GCTRL_LRO6_EN_MASK 0x4000u
+//! Constant DISU - DISABLE LRO
+#define CONST_TSO_GCTRL_LRO6_EN_DISU 0x0
+//! Constant ENU - ENABLE LRO
+#define CONST_TSO_GCTRL_LRO6_EN_ENU 0x1
+
+//! Field LRO7_EN - ENABLE LRO 7
+#define TSO_GCTRL_LRO7_EN_POS 15
+//! Field LRO7_EN - ENABLE LRO 7
+#define TSO_GCTRL_LRO7_EN_MASK 0x8000u
+//! Constant DISU - DISABLE LRO
+#define CONST_TSO_GCTRL_LRO7_EN_DISU 0x0
+//! Constant ENU - ENABLE LRO
+#define CONST_TSO_GCTRL_LRO7_EN_ENU 0x1
+
+//! Field TOE_RST - Reset TSO and LRO
+#define TSO_GCTRL_TOE_RST_POS 16
+//! Field TOE_RST - Reset TSO and LRO
+#define TSO_GCTRL_TOE_RST_MASK 0x10000u
+//! Constant TOENRST - SW writes 0 to release of reset
+#define CONST_TSO_GCTRL_TOE_RST_TOENRST 0x0
+//! Constant TOERST - SW writes 1 to reset
+#define CONST_TSO_GCTRL_TOE_RST_TOERST 0x1
+
+//! Field OCP_CTRL_ENDI_B - Control OCP SWAPPER byte
+#define TSO_GCTRL_OCP_CTRL_ENDI_B_POS 18
+//! Field OCP_CTRL_ENDI_B - Control OCP SWAPPER byte
+#define TSO_GCTRL_OCP_CTRL_ENDI_B_MASK 0x40000u
+//! Constant NO_SWP
+#define CONST_TSO_GCTRL_OCP_CTRL_ENDI_B_NO_SWP 0x0
+//! Constant SWAP
+#define CONST_TSO_GCTRL_OCP_CTRL_ENDI_B_SWAP 0x1
+
+//! Field OCP_CTRL_ENDI_W - Control OCP SWAPPER WORD
+#define TSO_GCTRL_OCP_CTRL_ENDI_W_POS 19
+//! Field OCP_CTRL_ENDI_W - Control OCP SWAPPER WORD
+#define TSO_GCTRL_OCP_CTRL_ENDI_W_MASK 0x80000u
+//! Constant NO_SWP
+#define CONST_TSO_GCTRL_OCP_CTRL_ENDI_W_NO_SWP 0x0
+//! Constant SWAP
+#define CONST_TSO_GCTRL_OCP_CTRL_ENDI_W_SWAP 0x1
+
+//! Field LRO_MAX_AGP - LRO Maximum numbers of Packets to be aggregated
+#define TSO_GCTRL_LRO_MAX_AGP_POS 24
+//! Field LRO_MAX_AGP - LRO Maximum numbers of Packets to be aggregated
+#define TSO_GCTRL_LRO_MAX_AGP_MASK 0x1F000000u
+
+//! Field DEBUG_PAUSE_TSO - PAUSE HW for Debug Access of TSO
+#define TSO_GCTRL_DEBUG_PAUSE_TSO_POS 30
+//! Field DEBUG_PAUSE_TSO - PAUSE HW for Debug Access of TSO
+#define TSO_GCTRL_DEBUG_PAUSE_TSO_MASK 0x40000000u
+//! Constant NORM - Normal operating
+#define CONST_TSO_GCTRL_DEBUG_PAUSE_TSO_NORM 0x0
+//! Constant PAUSE - force HW pause
+#define CONST_TSO_GCTRL_DEBUG_PAUSE_TSO_PAUSE 0x1
+
+//! Field DEBUG_PAUSE_LRO - PAUSE HW for Debug Access of LRO
+#define TSO_GCTRL_DEBUG_PAUSE_LRO_POS 31
+//! Field DEBUG_PAUSE_LRO - PAUSE HW for Debug Access of LRO
+#define TSO_GCTRL_DEBUG_PAUSE_LRO_MASK 0x80000000u
+//! Constant NORM - Normal operating
+#define CONST_TSO_GCTRL_DEBUG_PAUSE_LRO_NORM 0x0
+//! Constant PAUSE - force HW pause
+#define CONST_TSO_GCTRL_DEBUG_PAUSE_LRO_PAUSE 0x1
+
+//! @}
+
+//! \defgroup POLL_INTERVAL Register POLL_INTERVAL - Global polling interval counter for TOE HW polling events
+//! @{
+
+//! Register Offset (relative)
+#define POLL_INTERVAL 0x204
+
+//! Register Reset Value
+#define POLL_INTERVAL_RST 0x00000000u
+
+//! Field POLL - set the polling interval
+#define POLL_INTERVAL_POLL_POS 0
+//! Field POLL - set the polling interval
+#define POLL_INTERVAL_POLL_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup HDR_BASE_SEG0 Register HDR_BASE_SEG0 - Header Base Address for Segment
+//! @{
+
+//! Register Offset (relative)
+#define HDR_BASE_SEG0 0x220
+
+//! Register Reset Value
+#define HDR_BASE_SEG0_RST 0x00000000u
+
+//! Field BASE - Header Base Address for Segment
+#define HDR_BASE_SEG0_BASE_POS 0
+//! Field BASE - Header Base Address for Segment
+#define HDR_BASE_SEG0_BASE_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup HDR_BASE_SEG1 Register HDR_BASE_SEG1 - Header Base Address for Segment
+//! @{
+
+//! Register Offset (relative)
+#define HDR_BASE_SEG1 0x224
+
+//! Register Reset Value
+#define HDR_BASE_SEG1_RST 0x00000000u
+
+//! Field BASE - Header Base Address for Segment
+#define HDR_BASE_SEG1_BASE_POS 0
+//! Field BASE - Header Base Address for Segment
+#define HDR_BASE_SEG1_BASE_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup MIPS_CFG_0 Register MIPS_CFG_0 - EVA Mapping Info Register
+//! @{
+
+//! Register Offset (relative)
+#define MIPS_CFG_0 0x240
+
+//! Register Reset Value
+#define MIPS_CFG_0_RST 0x00000000u
+
+//! Field CFG0 - EVA Mapping information for MIPS SegCtl[2:0] split into 6 registers
+#define MIPS_CFG_0_CFG0_POS 0
+//! Field CFG0 - EVA Mapping information for MIPS SegCtl[2:0] split into 6 registers
+#define MIPS_CFG_0_CFG0_MASK 0xFFFFu
+
+//! @}
+
+//! \defgroup MIPS_CFG_1 Register MIPS_CFG_1 - EVA Mapping Info Register
+//! @{
+
+//! Register Offset (relative)
+#define MIPS_CFG_1 0x250
+
+//! Register Reset Value
+#define MIPS_CFG_1_RST 0x00000000u
+
+//! Field CFG0 - EVA Mapping information for MIPS SegCtl[2:0] split into 6 registers
+#define MIPS_CFG_1_CFG0_POS 0
+//! Field CFG0 - EVA Mapping information for MIPS SegCtl[2:0] split into 6 registers
+#define MIPS_CFG_1_CFG0_MASK 0xFFFFu
+
+//! @}
+
+//! \defgroup MIPS_CFG_2 Register MIPS_CFG_2 - EVA Mapping Info Register
+//! @{
+
+//! Register Offset (relative)
+#define MIPS_CFG_2 0x260
+
+//! Register Reset Value
+#define MIPS_CFG_2_RST 0x00000000u
+
+//! Field CFG0 - EVA Mapping information for MIPS SegCtl[2:0] split into 6 registers
+#define MIPS_CFG_2_CFG0_POS 0
+//! Field CFG0 - EVA Mapping information for MIPS SegCtl[2:0] split into 6 registers
+#define MIPS_CFG_2_CFG0_MASK 0xFFFFu
+
+//! @}
+
+//! \defgroup MIPS_CFG_3 Register MIPS_CFG_3 - EVA Mapping Info Register
+//! @{
+
+//! Register Offset (relative)
+#define MIPS_CFG_3 0x270
+
+//! Register Reset Value
+#define MIPS_CFG_3_RST 0x00000000u
+
+//! Field CFG0 - EVA Mapping information for MIPS SegCtl[2:0] split into 6 registers
+#define MIPS_CFG_3_CFG0_POS 0
+//! Field CFG0 - EVA Mapping information for MIPS SegCtl[2:0] split into 6 registers
+#define MIPS_CFG_3_CFG0_MASK 0xFFFFu
+
+//! @}
+
+//! \defgroup MIPS_CFG_4 Register MIPS_CFG_4 - EVA Mapping Info Register
+//! @{
+
+//! Register Offset (relative)
+#define MIPS_CFG_4 0x280
+
+//! Register Reset Value
+#define MIPS_CFG_4_RST 0x00000000u
+
+//! Field CFG0 - EVA Mapping information for MIPS SegCtl[2:0] split into 6 registers
+#define MIPS_CFG_4_CFG0_POS 0
+//! Field CFG0 - EVA Mapping information for MIPS SegCtl[2:0] split into 6 registers
+#define MIPS_CFG_4_CFG0_MASK 0xFFFFu
+
+//! @}
+
+//! \defgroup MIPS_CFG_5 Register MIPS_CFG_5 - EVA Mapping Info Register
+//! @{
+
+//! Register Offset (relative)
+#define MIPS_CFG_5 0x290
+
+//! Register Reset Value
+#define MIPS_CFG_5_RST 0x00000000u
+
+//! Field CFG0 - EVA Mapping information for MIPS SegCtl[2:0] split into 6 registers
+#define MIPS_CFG_5_CFG0_POS 0
+//! Field CFG0 - EVA Mapping information for MIPS SegCtl[2:0] split into 6 registers
+#define MIPS_CFG_5_CFG0_MASK 0xFFFFu
+
+//! @}
+
+//! \defgroup LRO_FID_0 Register LRO_FID_0 - FLOW ID for LRO Session
+//! @{
+
+//! Register Offset (relative)
+#define LRO_FID_0 0x1000
+
+//! Register Reset Value
+#define LRO_FID_0_RST 0xC0000000u
+
+//! Field LRO_FID - FLOW ID for LRO Session
+#define LRO_FID_0_LRO_FID_POS 0
+//! Field LRO_FID - FLOW ID for LRO Session
+#define LRO_FID_0_LRO_FID_MASK 0x3Fu
+
+//! Field S_END - SW Indicates that session is ended
+#define LRO_FID_0_S_END_POS 30
+//! Field S_END - SW Indicates that session is ended
+#define LRO_FID_0_S_END_MASK 0x40000000u
+//! Constant NEND - Not end
+#define CONST_LRO_FID_0_S_END_NEND 0x0
+//! Constant END - Session end
+#define CONST_LRO_FID_0_S_END_END 0x1
+
+//! Field OWNER - OWNER bit of the Command
+#define LRO_FID_0_OWNER_POS 31
+//! Field OWNER - OWNER bit of the Command
+#define LRO_FID_0_OWNER_MASK 0x80000000u
+//! Constant HW - HW owns it
+#define CONST_LRO_FID_0_OWNER_HW 0x0
+//! Constant CPU - CPU owns it
+#define CONST_LRO_FID_0_OWNER_CPU 0x1
+
+//! @}
+
+//! \defgroup LRO_TO_REG_0 Register LRO_TO_REG_0 - LRO Time Out Window
+//! @{
+
+//! Register Offset (relative)
+#define LRO_TO_REG_0 0x1004
+
+//! Register Reset Value
+#define LRO_TO_REG_0_RST 0x00000000u
+
+//! Field LRO_TO - LRO Time Out Window
+#define LRO_TO_REG_0_LRO_TO_POS 0
+//! Field LRO_TO - LRO Time Out Window
+#define LRO_TO_REG_0_LRO_TO_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup LRO_FID_1 Register LRO_FID_1 - FLOW ID for LRO Session
+//! @{
+
+//! Register Offset (relative)
+#define LRO_FID_1 0x1008
+
+//! Register Reset Value
+#define LRO_FID_1_RST 0xC0000000u
+
+//! Field LRO_FID - FLOW ID for LRO Session
+#define LRO_FID_1_LRO_FID_POS 0
+//! Field LRO_FID - FLOW ID for LRO Session
+#define LRO_FID_1_LRO_FID_MASK 0x3Fu
+
+//! Field S_END - SW Indicates that session is ended
+#define LRO_FID_1_S_END_POS 30
+//! Field S_END - SW Indicates that session is ended
+#define LRO_FID_1_S_END_MASK 0x40000000u
+//! Constant NEND - Not end
+#define CONST_LRO_FID_1_S_END_NEND 0x0
+//! Constant END - Session end
+#define CONST_LRO_FID_1_S_END_END 0x1
+
+//! Field OWNER - OWNER bit of the Command
+#define LRO_FID_1_OWNER_POS 31
+//! Field OWNER - OWNER bit of the Command
+#define LRO_FID_1_OWNER_MASK 0x80000000u
+//! Constant HW - HW owns it
+#define CONST_LRO_FID_1_OWNER_HW 0x0
+//! Constant CPU - CPU owns it
+#define CONST_LRO_FID_1_OWNER_CPU 0x1
+
+//! @}
+
+//! \defgroup LRO_TO_REG_1 Register LRO_TO_REG_1 - LRO Time Out Window
+//! @{
+
+//! Register Offset (relative)
+#define LRO_TO_REG_1 0x100C
+
+//! Register Reset Value
+#define LRO_TO_REG_1_RST 0x00000000u
+
+//! Field LRO_TO - LRO Time Out Window
+#define LRO_TO_REG_1_LRO_TO_POS 0
+//! Field LRO_TO - LRO Time Out Window
+#define LRO_TO_REG_1_LRO_TO_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup LRO_FID_2 Register LRO_FID_2 - FLOW ID for LRO Session
+//! @{
+
+//! Register Offset (relative)
+#define LRO_FID_2 0x1010
+
+//! Register Reset Value
+#define LRO_FID_2_RST 0xC0000000u
+
+//! Field LRO_FID - FLOW ID for LRO Session
+#define LRO_FID_2_LRO_FID_POS 0
+//! Field LRO_FID - FLOW ID for LRO Session
+#define LRO_FID_2_LRO_FID_MASK 0x3Fu
+
+//! Field S_END - SW Indicates that session is ended
+#define LRO_FID_2_S_END_POS 30
+//! Field S_END - SW Indicates that session is ended
+#define LRO_FID_2_S_END_MASK 0x40000000u
+//! Constant NEND - Not end
+#define CONST_LRO_FID_2_S_END_NEND 0x0
+//! Constant END - Session end
+#define CONST_LRO_FID_2_S_END_END 0x1
+
+//! Field OWNER - OWNER bit of the Command
+#define LRO_FID_2_OWNER_POS 31
+//! Field OWNER - OWNER bit of the Command
+#define LRO_FID_2_OWNER_MASK 0x80000000u
+//! Constant HW - HW owns it
+#define CONST_LRO_FID_2_OWNER_HW 0x0
+//! Constant CPU - CPU owns it
+#define CONST_LRO_FID_2_OWNER_CPU 0x1
+
+//! @}
+
+//! \defgroup LRO_TO_REG_2 Register LRO_TO_REG_2 - LRO Time Out Window
+//! @{
+
+//! Register Offset (relative)
+#define LRO_TO_REG_2 0x1014
+
+//! Register Reset Value
+#define LRO_TO_REG_2_RST 0x00000000u
+
+//! Field LRO_TO - LRO Time Out Window
+#define LRO_TO_REG_2_LRO_TO_POS 0
+//! Field LRO_TO - LRO Time Out Window
+#define LRO_TO_REG_2_LRO_TO_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup LRO_FID_3 Register LRO_FID_3 - FLOW ID for LRO Session
+//! @{
+
+//! Register Offset (relative)
+#define LRO_FID_3 0x1018
+
+//! Register Reset Value
+#define LRO_FID_3_RST 0xC0000000u
+
+//! Field LRO_FID - FLOW ID for LRO Session
+#define LRO_FID_3_LRO_FID_POS 0
+//! Field LRO_FID - FLOW ID for LRO Session
+#define LRO_FID_3_LRO_FID_MASK 0x3Fu
+
+//! Field S_END - SW Indicates that session is ended
+#define LRO_FID_3_S_END_POS 30
+//! Field S_END - SW Indicates that session is ended
+#define LRO_FID_3_S_END_MASK 0x40000000u
+//! Constant NEND - Not end
+#define CONST_LRO_FID_3_S_END_NEND 0x0
+//! Constant END - Session end
+#define CONST_LRO_FID_3_S_END_END 0x1
+
+//! Field OWNER - OWNER bit of the Command
+#define LRO_FID_3_OWNER_POS 31
+//! Field OWNER - OWNER bit of the Command
+#define LRO_FID_3_OWNER_MASK 0x80000000u
+//! Constant HW - HW owns it
+#define CONST_LRO_FID_3_OWNER_HW 0x0
+//! Constant CPU - CPU owns it
+#define CONST_LRO_FID_3_OWNER_CPU 0x1
+
+//! @}
+
+//! \defgroup LRO_TO_REG_3 Register LRO_TO_REG_3 - LRO Time Out Window
+//! @{
+
+//! Register Offset (relative)
+#define LRO_TO_REG_3 0x101C
+
+//! Register Reset Value
+#define LRO_TO_REG_3_RST 0x00000000u
+
+//! Field LRO_TO - LRO Time Out Window
+#define LRO_TO_REG_3_LRO_TO_POS 0
+//! Field LRO_TO - LRO Time Out Window
+#define LRO_TO_REG_3_LRO_TO_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup LRO_FID_4 Register LRO_FID_4 - FLOW ID for LRO Session
+//! @{
+
+//! Register Offset (relative)
+#define LRO_FID_4 0x1020
+
+//! Register Reset Value
+#define LRO_FID_4_RST 0xC0000000u
+
+//! Field LRO_FID - FLOW ID for LRO Session
+#define LRO_FID_4_LRO_FID_POS 0
+//! Field LRO_FID - FLOW ID for LRO Session
+#define LRO_FID_4_LRO_FID_MASK 0x3Fu
+
+//! Field S_END - SW Indicates that session is ended
+#define LRO_FID_4_S_END_POS 30
+//! Field S_END - SW Indicates that session is ended
+#define LRO_FID_4_S_END_MASK 0x40000000u
+//! Constant NEND - Not end
+#define CONST_LRO_FID_4_S_END_NEND 0x0
+//! Constant END - Session end
+#define CONST_LRO_FID_4_S_END_END 0x1
+
+//! Field OWNER - OWNER bit of the Command
+#define LRO_FID_4_OWNER_POS 31
+//! Field OWNER - OWNER bit of the Command
+#define LRO_FID_4_OWNER_MASK 0x80000000u
+//! Constant HW - HW owns it
+#define CONST_LRO_FID_4_OWNER_HW 0x0
+//! Constant CPU - CPU owns it
+#define CONST_LRO_FID_4_OWNER_CPU 0x1
+
+//! @}
+
+//! \defgroup LRO_TO_REG_4 Register LRO_TO_REG_4 - LRO Time Out Window
+//! @{
+
+//! Register Offset (relative)
+#define LRO_TO_REG_4 0x1024
+
+//! Register Reset Value
+#define LRO_TO_REG_4_RST 0x00000000u
+
+//! Field LRO_TO - LRO Time Out Window
+#define LRO_TO_REG_4_LRO_TO_POS 0
+//! Field LRO_TO - LRO Time Out Window
+#define LRO_TO_REG_4_LRO_TO_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup LRO_FID_5 Register LRO_FID_5 - FLOW ID for LRO Session
+//! @{
+
+//! Register Offset (relative)
+#define LRO_FID_5 0x1028
+
+//! Register Reset Value
+#define LRO_FID_5_RST 0xC0000000u
+
+//! Field LRO_FID - FLOW ID for LRO Session
+#define LRO_FID_5_LRO_FID_POS 0
+//! Field LRO_FID - FLOW ID for LRO Session
+#define LRO_FID_5_LRO_FID_MASK 0x3Fu
+
+//! Field S_END - SW Indicates that session is ended
+#define LRO_FID_5_S_END_POS 30
+//! Field S_END - SW Indicates that session is ended
+#define LRO_FID_5_S_END_MASK 0x40000000u
+//! Constant NEND - Not end
+#define CONST_LRO_FID_5_S_END_NEND 0x0
+//! Constant END - Session end
+#define CONST_LRO_FID_5_S_END_END 0x1
+
+//! Field OWNER - OWNER bit of the Command
+#define LRO_FID_5_OWNER_POS 31
+//! Field OWNER - OWNER bit of the Command
+#define LRO_FID_5_OWNER_MASK 0x80000000u
+//! Constant HW - HW owns it
+#define CONST_LRO_FID_5_OWNER_HW 0x0
+//! Constant CPU - CPU owns it
+#define CONST_LRO_FID_5_OWNER_CPU 0x1
+
+//! @}
+
+//! \defgroup LRO_TO_REG_5 Register LRO_TO_REG_5 - LRO Time Out Window
+//! @{
+
+//! Register Offset (relative)
+#define LRO_TO_REG_5 0x102C
+
+//! Register Reset Value
+#define LRO_TO_REG_5_RST 0x00000000u
+
+//! Field LRO_TO - LRO Time Out Window
+#define LRO_TO_REG_5_LRO_TO_POS 0
+//! Field LRO_TO - LRO Time Out Window
+#define LRO_TO_REG_5_LRO_TO_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup LRO_FID_6 Register LRO_FID_6 - FLOW ID for LRO Session
+//! @{
+
+//! Register Offset (relative)
+#define LRO_FID_6 0x1030
+
+//! Register Reset Value
+#define LRO_FID_6_RST 0xC0000000u
+
+//! Field LRO_FID - FLOW ID for LRO Session
+#define LRO_FID_6_LRO_FID_POS 0
+//! Field LRO_FID - FLOW ID for LRO Session
+#define LRO_FID_6_LRO_FID_MASK 0x3Fu
+
+//! Field S_END - SW Indicates that session is ended
+#define LRO_FID_6_S_END_POS 30
+//! Field S_END - SW Indicates that session is ended
+#define LRO_FID_6_S_END_MASK 0x40000000u
+//! Constant NEND - Not end
+#define CONST_LRO_FID_6_S_END_NEND 0x0
+//! Constant END - Session end
+#define CONST_LRO_FID_6_S_END_END 0x1
+
+//! Field OWNER - OWNER bit of the Command
+#define LRO_FID_6_OWNER_POS 31
+//! Field OWNER - OWNER bit of the Command
+#define LRO_FID_6_OWNER_MASK 0x80000000u
+//! Constant HW - HW owns it
+#define CONST_LRO_FID_6_OWNER_HW 0x0
+//! Constant CPU - CPU owns it
+#define CONST_LRO_FID_6_OWNER_CPU 0x1
+
+//! @}
+
+//! \defgroup LRO_TO_REG_6 Register LRO_TO_REG_6 - LRO Time Out Window
+//! @{
+
+//! Register Offset (relative)
+#define LRO_TO_REG_6 0x1034
+
+//! Register Reset Value
+#define LRO_TO_REG_6_RST 0x00000000u
+
+//! Field LRO_TO - LRO Time Out Window
+#define LRO_TO_REG_6_LRO_TO_POS 0
+//! Field LRO_TO - LRO Time Out Window
+#define LRO_TO_REG_6_LRO_TO_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup LRO_FID_7 Register LRO_FID_7 - FLOW ID for LRO Session
+//! @{
+
+//! Register Offset (relative)
+#define LRO_FID_7 0x1038
+
+//! Register Reset Value
+#define LRO_FID_7_RST 0xC0000000u
+
+//! Field LRO_FID - FLOW ID for LRO Session
+#define LRO_FID_7_LRO_FID_POS 0
+//! Field LRO_FID - FLOW ID for LRO Session
+#define LRO_FID_7_LRO_FID_MASK 0x3Fu
+
+//! Field S_END - SW Indicates that session is ended
+#define LRO_FID_7_S_END_POS 30
+//! Field S_END - SW Indicates that session is ended
+#define LRO_FID_7_S_END_MASK 0x40000000u
+//! Constant NEND - Not end
+#define CONST_LRO_FID_7_S_END_NEND 0x0
+//! Constant END - Session end
+#define CONST_LRO_FID_7_S_END_END 0x1
+
+//! Field OWNER - OWNER bit of the Command
+#define LRO_FID_7_OWNER_POS 31
+//! Field OWNER - OWNER bit of the Command
+#define LRO_FID_7_OWNER_MASK 0x80000000u
+//! Constant HW - HW owns it
+#define CONST_LRO_FID_7_OWNER_HW 0x0
+//! Constant CPU - CPU owns it
+#define CONST_LRO_FID_7_OWNER_CPU 0x1
+
+//! @}
+
+//! \defgroup LRO_TO_REG_7 Register LRO_TO_REG_7 - LRO Time Out Window
+//! @{
+
+//! Register Offset (relative)
+#define LRO_TO_REG_7 0x103C
+
+//! Register Reset Value
+#define LRO_TO_REG_7_RST 0x00000000u
+
+//! Field LRO_TO - LRO Time Out Window
+#define LRO_TO_REG_7_LRO_TO_POS 0
+//! Field LRO_TO - LRO Time Out Window
+#define LRO_TO_REG_7_LRO_TO_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TOE_INT_MASK Register TOE_INT_MASK - Module Interrupt Mask register
+//! @{
+
+//! Register Offset (relative)
+#define TOE_INT_MASK 0x1044
+
+//! Register Reset Value
+#define TOE_INT_MASK_RST 0x00000000u
+
+//! Field TOE0 - Interrupt Mask bit
+#define TOE_INT_MASK_TOE0_POS 0
+//! Field TOE0 - Interrupt Mask bit
+#define TOE_INT_MASK_TOE0_MASK 0x1u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_TOE0_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_TOE0_M 0x1
+
+//! Field TOE1 - Interrupt Mask bit
+#define TOE_INT_MASK_TOE1_POS 1
+//! Field TOE1 - Interrupt Mask bit
+#define TOE_INT_MASK_TOE1_MASK 0x2u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_TOE1_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_TOE1_M 0x1
+
+//! Field TOE2 - Interrupt Mask bit
+#define TOE_INT_MASK_TOE2_POS 2
+//! Field TOE2 - Interrupt Mask bit
+#define TOE_INT_MASK_TOE2_MASK 0x4u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_TOE2_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_TOE2_M 0x1
+
+//! Field TOE3 - Interrupt Mask bit
+#define TOE_INT_MASK_TOE3_POS 3
+//! Field TOE3 - Interrupt Mask bit
+#define TOE_INT_MASK_TOE3_MASK 0x8u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_TOE3_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_TOE3_M 0x1
+
+//! Field LRO0 - Interrupt Mask bit
+#define TOE_INT_MASK_LRO0_POS 4
+//! Field LRO0 - Interrupt Mask bit
+#define TOE_INT_MASK_LRO0_MASK 0x10u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_LRO0_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_LRO0_M 0x1
+
+//! Field LRO1 - Interrupt Mask bit
+#define TOE_INT_MASK_LRO1_POS 5
+//! Field LRO1 - Interrupt Mask bit
+#define TOE_INT_MASK_LRO1_MASK 0x20u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_LRO1_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_LRO1_M 0x1
+
+//! Field LRO2 - Interrupt Mask bit
+#define TOE_INT_MASK_LRO2_POS 6
+//! Field LRO2 - Interrupt Mask bit
+#define TOE_INT_MASK_LRO2_MASK 0x40u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_LRO2_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_LRO2_M 0x1
+
+//! Field LRO3 - Interrupt Mask bit
+#define TOE_INT_MASK_LRO3_POS 7
+//! Field LRO3 - Interrupt Mask bit
+#define TOE_INT_MASK_LRO3_MASK 0x80u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_LRO3_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_LRO3_M 0x1
+
+//! Field LRO4 - Interrupt Mask bit
+#define TOE_INT_MASK_LRO4_POS 8
+//! Field LRO4 - Interrupt Mask bit
+#define TOE_INT_MASK_LRO4_MASK 0x100u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_LRO4_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_LRO4_M 0x1
+
+//! Field LRO5 - Interrupt Mask bit
+#define TOE_INT_MASK_LRO5_POS 9
+//! Field LRO5 - Interrupt Mask bit
+#define TOE_INT_MASK_LRO5_MASK 0x200u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_LRO5_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_LRO5_M 0x1
+
+//! Field LRO6 - Interrupt Mask bit
+#define TOE_INT_MASK_LRO6_POS 10
+//! Field LRO6 - Interrupt Mask bit
+#define TOE_INT_MASK_LRO6_MASK 0x400u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_LRO6_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_LRO6_M 0x1
+
+//! Field LRO7 - Interrupt Mask bit
+#define TOE_INT_MASK_LRO7_POS 11
+//! Field LRO7 - Interrupt Mask bit
+#define TOE_INT_MASK_LRO7_MASK 0x800u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_LRO7_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_LRO7_M 0x1
+
+//! Field LRO_EXP - Interrupt Mask bit
+#define TOE_INT_MASK_LRO_EXP_POS 12
+//! Field LRO_EXP - Interrupt Mask bit
+#define TOE_INT_MASK_LRO_EXP_MASK 0x1000u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_LRO_EXP_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_LRO_EXP_M 0x1
+
+//! Field S16 - Interrupt Mask bit
+#define TOE_INT_MASK_S16_POS 16
+//! Field S16 - Interrupt Mask bit
+#define TOE_INT_MASK_S16_MASK 0x10000u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_S16_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_S16_M 0x1
+
+//! Field S17 - Interrupt Mask bit
+#define TOE_INT_MASK_S17_POS 17
+//! Field S17 - Interrupt Mask bit
+#define TOE_INT_MASK_S17_MASK 0x20000u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_S17_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_S17_M 0x1
+
+//! Field S18 - Interrupt Mask bit
+#define TOE_INT_MASK_S18_POS 18
+//! Field S18 - Interrupt Mask bit
+#define TOE_INT_MASK_S18_MASK 0x40000u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_S18_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_S18_M 0x1
+
+//! Field S19 - Interrupt Mask bit
+#define TOE_INT_MASK_S19_POS 19
+//! Field S19 - Interrupt Mask bit
+#define TOE_INT_MASK_S19_MASK 0x80000u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_S19_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_S19_M 0x1
+
+//! Field S20 - Interrupt Mask bit
+#define TOE_INT_MASK_S20_POS 20
+//! Field S20 - Interrupt Mask bit
+#define TOE_INT_MASK_S20_MASK 0x100000u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_S20_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_S20_M 0x1
+
+//! Field S21 - Interrupt Mask bit
+#define TOE_INT_MASK_S21_POS 21
+//! Field S21 - Interrupt Mask bit
+#define TOE_INT_MASK_S21_MASK 0x200000u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_S21_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_S21_M 0x1
+
+//! Field S22 - Interrupt Mask bit
+#define TOE_INT_MASK_S22_POS 22
+//! Field S22 - Interrupt Mask bit
+#define TOE_INT_MASK_S22_MASK 0x400000u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_S22_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_S22_M 0x1
+
+//! Field S23 - Interrupt Mask bit
+#define TOE_INT_MASK_S23_POS 23
+//! Field S23 - Interrupt Mask bit
+#define TOE_INT_MASK_S23_MASK 0x800000u
+//! Constant UM - Mask out this bit
+#define CONST_TOE_INT_MASK_S23_UM 0x0
+//! Constant M - Mask to Select this bit
+#define CONST_TOE_INT_MASK_S23_M 0x1
+
+//! @}
+
+//! \defgroup TOE_INT_EN Register TOE_INT_EN - Module Interrupt EN register
+//! @{
+
+//! Register Offset (relative)
+#define TOE_INT_EN 0x1048
+
+//! Register Reset Value
+#define TOE_INT_EN_RST 0x00000000u
+
+//! Field TOE0 - Interrupt Enable bit
+#define TOE_INT_EN_TOE0_POS 0
+//! Field TOE0 - Interrupt Enable bit
+#define TOE_INT_EN_TOE0_MASK 0x1u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_TOE0_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_TOE0_EN 0x1
+
+//! Field TOE1 - Interrupt Enable bit
+#define TOE_INT_EN_TOE1_POS 1
+//! Field TOE1 - Interrupt Enable bit
+#define TOE_INT_EN_TOE1_MASK 0x2u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_TOE1_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_TOE1_EN 0x1
+
+//! Field TOE2 - Interrupt Enable bit
+#define TOE_INT_EN_TOE2_POS 2
+//! Field TOE2 - Interrupt Enable bit
+#define TOE_INT_EN_TOE2_MASK 0x4u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_TOE2_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_TOE2_EN 0x1
+
+//! Field TOE3 - Interrupt Enable bit
+#define TOE_INT_EN_TOE3_POS 3
+//! Field TOE3 - Interrupt Enable bit
+#define TOE_INT_EN_TOE3_MASK 0x8u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_TOE3_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_TOE3_EN 0x1
+
+//! Field LRO0 - Interrupt Enable bit
+#define TOE_INT_EN_LRO0_POS 4
+//! Field LRO0 - Interrupt Enable bit
+#define TOE_INT_EN_LRO0_MASK 0x10u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_LRO0_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_LRO0_EN 0x1
+
+//! Field LRO1 - Interrupt Enable bit
+#define TOE_INT_EN_LRO1_POS 5
+//! Field LRO1 - Interrupt Enable bit
+#define TOE_INT_EN_LRO1_MASK 0x20u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_LRO1_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_LRO1_EN 0x1
+
+//! Field LRO2 - Interrupt Enable bit
+#define TOE_INT_EN_LRO2_POS 6
+//! Field LRO2 - Interrupt Enable bit
+#define TOE_INT_EN_LRO2_MASK 0x40u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_LRO2_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_LRO2_EN 0x1
+
+//! Field LRO3 - Interrupt Enable bit
+#define TOE_INT_EN_LRO3_POS 7
+//! Field LRO3 - Interrupt Enable bit
+#define TOE_INT_EN_LRO3_MASK 0x80u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_LRO3_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_LRO3_EN 0x1
+
+//! Field LRO4 - Interrupt Enable bit
+#define TOE_INT_EN_LRO4_POS 8
+//! Field LRO4 - Interrupt Enable bit
+#define TOE_INT_EN_LRO4_MASK 0x100u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_LRO4_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_LRO4_EN 0x1
+
+//! Field LRO5 - Interrupt Enable bit
+#define TOE_INT_EN_LRO5_POS 9
+//! Field LRO5 - Interrupt Enable bit
+#define TOE_INT_EN_LRO5_MASK 0x200u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_LRO5_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_LRO5_EN 0x1
+
+//! Field LRO6 - Interrupt Enable bit
+#define TOE_INT_EN_LRO6_POS 10
+//! Field LRO6 - Interrupt Enable bit
+#define TOE_INT_EN_LRO6_MASK 0x400u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_LRO6_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_LRO6_EN 0x1
+
+//! Field LRO7 - Interrupt Enable bit
+#define TOE_INT_EN_LRO7_POS 11
+//! Field LRO7 - Interrupt Enable bit
+#define TOE_INT_EN_LRO7_MASK 0x800u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_LRO7_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_LRO7_EN 0x1
+
+//! Field LRO_EXP - Interrupt Enable bit
+#define TOE_INT_EN_LRO_EXP_POS 12
+//! Field LRO_EXP - Interrupt Enable bit
+#define TOE_INT_EN_LRO_EXP_MASK 0x1000u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_LRO_EXP_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_LRO_EXP_EN 0x1
+
+//! Field S16 - Interrupt Enable bit
+#define TOE_INT_EN_S16_POS 16
+//! Field S16 - Interrupt Enable bit
+#define TOE_INT_EN_S16_MASK 0x10000u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_S16_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_S16_EN 0x1
+
+//! Field S17 - Interrupt Enable bit
+#define TOE_INT_EN_S17_POS 17
+//! Field S17 - Interrupt Enable bit
+#define TOE_INT_EN_S17_MASK 0x20000u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_S17_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_S17_EN 0x1
+
+//! Field S18 - Interrupt Enable bit
+#define TOE_INT_EN_S18_POS 18
+//! Field S18 - Interrupt Enable bit
+#define TOE_INT_EN_S18_MASK 0x40000u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_S18_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_S18_EN 0x1
+
+//! Field S19 - Interrupt Enable bit
+#define TOE_INT_EN_S19_POS 19
+//! Field S19 - Interrupt Enable bit
+#define TOE_INT_EN_S19_MASK 0x80000u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_S19_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_S19_EN 0x1
+
+//! Field S20 - Interrupt Enable bit
+#define TOE_INT_EN_S20_POS 20
+//! Field S20 - Interrupt Enable bit
+#define TOE_INT_EN_S20_MASK 0x100000u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_S20_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_S20_EN 0x1
+
+//! Field S21 - Interrupt Enable bit
+#define TOE_INT_EN_S21_POS 21
+//! Field S21 - Interrupt Enable bit
+#define TOE_INT_EN_S21_MASK 0x200000u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_S21_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_S21_EN 0x1
+
+//! Field S22 - Interrupt Enable bit
+#define TOE_INT_EN_S22_POS 22
+//! Field S22 - Interrupt Enable bit
+#define TOE_INT_EN_S22_MASK 0x400000u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_S22_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_S22_EN 0x1
+
+//! Field S23 - Interrupt Enable bit
+#define TOE_INT_EN_S23_POS 23
+//! Field S23 - Interrupt Enable bit
+#define TOE_INT_EN_S23_MASK 0x800000u
+//! Constant UEN - Disable this bit
+#define CONST_TOE_INT_EN_S23_UEN 0x0
+//! Constant EN - Enable this bit
+#define CONST_TOE_INT_EN_S23_EN 0x1
+
+//! @}
+
+//! \defgroup TOE_INT_STAT Register TOE_INT_STAT - Module Interrupt States register
+//! @{
+
+//! Register Offset (relative)
+#define TOE_INT_STAT 0x104C
+
+//! Register Reset Value
+#define TOE_INT_STAT_RST 0x00000000u
+
+//! Field TOE0 - Interrupt States bit
+#define TOE_INT_STAT_TOE0_POS 0
+//! Field TOE0 - Interrupt States bit
+#define TOE_INT_STAT_TOE0_MASK 0x1u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_TOE0_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_TOE0_EN 0x1
+
+//! Field TOE1 - Interrupt States bit
+#define TOE_INT_STAT_TOE1_POS 1
+//! Field TOE1 - Interrupt States bit
+#define TOE_INT_STAT_TOE1_MASK 0x2u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_TOE1_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_TOE1_EN 0x1
+
+//! Field TOE2 - Interrupt States bit
+#define TOE_INT_STAT_TOE2_POS 2
+//! Field TOE2 - Interrupt States bit
+#define TOE_INT_STAT_TOE2_MASK 0x4u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_TOE2_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_TOE2_EN 0x1
+
+//! Field TOE3 - Interrupt States bit
+#define TOE_INT_STAT_TOE3_POS 3
+//! Field TOE3 - Interrupt States bit
+#define TOE_INT_STAT_TOE3_MASK 0x8u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_TOE3_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_TOE3_EN 0x1
+
+//! Field LRO0 - Interrupt States bit
+#define TOE_INT_STAT_LRO0_POS 4
+//! Field LRO0 - Interrupt States bit
+#define TOE_INT_STAT_LRO0_MASK 0x10u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_LRO0_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_LRO0_EN 0x1
+
+//! Field LRO1 - Interrupt States bit
+#define TOE_INT_STAT_LRO1_POS 5
+//! Field LRO1 - Interrupt States bit
+#define TOE_INT_STAT_LRO1_MASK 0x20u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_LRO1_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_LRO1_EN 0x1
+
+//! Field LRO2 - Interrupt States bit
+#define TOE_INT_STAT_LRO2_POS 6
+//! Field LRO2 - Interrupt States bit
+#define TOE_INT_STAT_LRO2_MASK 0x40u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_LRO2_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_LRO2_EN 0x1
+
+//! Field LRO3 - Interrupt States bit
+#define TOE_INT_STAT_LRO3_POS 7
+//! Field LRO3 - Interrupt States bit
+#define TOE_INT_STAT_LRO3_MASK 0x80u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_LRO3_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_LRO3_EN 0x1
+
+//! Field LRO4 - Interrupt States bit
+#define TOE_INT_STAT_LRO4_POS 8
+//! Field LRO4 - Interrupt States bit
+#define TOE_INT_STAT_LRO4_MASK 0x100u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_LRO4_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_LRO4_EN 0x1
+
+//! Field LRO5 - Interrupt States bit
+#define TOE_INT_STAT_LRO5_POS 9
+//! Field LRO5 - Interrupt States bit
+#define TOE_INT_STAT_LRO5_MASK 0x200u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_LRO5_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_LRO5_EN 0x1
+
+//! Field LRO6 - Interrupt States bit
+#define TOE_INT_STAT_LRO6_POS 10
+//! Field LRO6 - Interrupt States bit
+#define TOE_INT_STAT_LRO6_MASK 0x400u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_LRO6_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_LRO6_EN 0x1
+
+//! Field LRO7 - Interrupt States bit
+#define TOE_INT_STAT_LRO7_POS 11
+//! Field LRO7 - Interrupt States bit
+#define TOE_INT_STAT_LRO7_MASK 0x800u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_LRO7_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_LRO7_EN 0x1
+
+//! Field LRO_EXP - Interrupt States bit
+#define TOE_INT_STAT_LRO_EXP_POS 12
+//! Field LRO_EXP - Interrupt States bit
+#define TOE_INT_STAT_LRO_EXP_MASK 0x1000u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_LRO_EXP_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_LRO_EXP_EN 0x1
+
+//! Field S16 - Interrupt States bit
+#define TOE_INT_STAT_S16_POS 16
+//! Field S16 - Interrupt States bit
+#define TOE_INT_STAT_S16_MASK 0x10000u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_S16_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_S16_EN 0x1
+
+//! Field S17 - Interrupt States bit
+#define TOE_INT_STAT_S17_POS 17
+//! Field S17 - Interrupt States bit
+#define TOE_INT_STAT_S17_MASK 0x20000u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_S17_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_S17_EN 0x1
+
+//! Field S18 - Interrupt States bit
+#define TOE_INT_STAT_S18_POS 18
+//! Field S18 - Interrupt States bit
+#define TOE_INT_STAT_S18_MASK 0x40000u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_S18_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_S18_EN 0x1
+
+//! Field S19 - Interrupt States bit
+#define TOE_INT_STAT_S19_POS 19
+//! Field S19 - Interrupt States bit
+#define TOE_INT_STAT_S19_MASK 0x80000u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_S19_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_S19_EN 0x1
+
+//! Field S20 - Interrupt States bit for no match flag overflow
+#define TOE_INT_STAT_S20_POS 20
+//! Field S20 - Interrupt States bit for no match flag overflow
+#define TOE_INT_STAT_S20_MASK 0x100000u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_S20_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_S20_EN 0x1
+
+//! Field S21 - Interrupt States bit for OC flag overflow
+#define TOE_INT_STAT_S21_POS 21
+//! Field S21 - Interrupt States bit for OC flag overflow
+#define TOE_INT_STAT_S21_MASK 0x200000u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_S21_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_S21_EN 0x1
+
+//! Field S22 - Interrupt States bit for exception error flag overflow
+#define TOE_INT_STAT_S22_POS 22
+//! Field S22 - Interrupt States bit for exception error flag overflow
+#define TOE_INT_STAT_S22_MASK 0x400000u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_S22_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_S22_EN 0x1
+
+//! Field S23 - Interrupt States bit for OCP bus error
+#define TOE_INT_STAT_S23_POS 23
+//! Field S23 - Interrupt States bit for OCP bus error
+#define TOE_INT_STAT_S23_MASK 0x800000u
+//! Constant UEN - Disabled this bit
+#define CONST_TOE_INT_STAT_S23_UEN 0x0
+//! Constant EN - Enabled this bit
+#define CONST_TOE_INT_STAT_S23_EN 0x1
+
+//! @}
+
+//! \defgroup TSO_DEBUG_CFG Register TSO_DEBUG_CFG
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DEBUG_CFG 0x1050
+
+//! Register Reset Value
+#define TSO_DEBUG_CFG_RST 0x00000000u
+
+//! Field S_FSM - S FSM states
+#define TSO_DEBUG_CFG_S_FSM_POS 0
+//! Field S_FSM - S FSM states
+#define TSO_DEBUG_CFG_S_FSM_MASK 0xFu
+
+//! Field E_FSM - E FSM States
+#define TSO_DEBUG_CFG_E_FSM_POS 4
+//! Field E_FSM - E FSM States
+#define TSO_DEBUG_CFG_E_FSM_MASK 0xF0u
+
+//! Field S_PP_FLAG - S PP FLAG
+#define TSO_DEBUG_CFG_S_PP_FLAG_POS 8
+//! Field S_PP_FLAG - S PP FLAG
+#define TSO_DEBUG_CFG_S_PP_FLAG_MASK 0x100u
+
+//! Field E_PP_FLAG - E PP FLAG
+#define TSO_DEBUG_CFG_E_PP_FLAG_POS 9
+//! Field E_PP_FLAG - E PP FLAG
+#define TSO_DEBUG_CFG_E_PP_FLAG_MASK 0x200u
+
+//! Field PING_VLD - PING Valid
+#define TSO_DEBUG_CFG_PING_VLD_POS 10
+//! Field PING_VLD - PING Valid
+#define TSO_DEBUG_CFG_PING_VLD_MASK 0x400u
+
+//! Field PONG_VLD - PONG Valid
+#define TSO_DEBUG_CFG_PONG_VLD_POS 11
+//! Field PONG_VLD - PONG Valid
+#define TSO_DEBUG_CFG_PONG_VLD_MASK 0x800u
+
+//! Field LAST_VLD - LAST Valid
+#define TSO_DEBUG_CFG_LAST_VLD_POS 12
+//! Field LAST_VLD - LAST Valid
+#define TSO_DEBUG_CFG_LAST_VLD_MASK 0x1000u
+
+//! Field FINAL_VLD - Final valid
+#define TSO_DEBUG_CFG_FINAL_VLD_POS 13
+//! Field FINAL_VLD - Final valid
+#define TSO_DEBUG_CFG_FINAL_VLD_MASK 0x2000u
+
+//! Field CBM_SDES_FLG - CBM Descriptor Flag
+#define TSO_DEBUG_CFG_CBM_SDES_FLG_POS 14
+//! Field CBM_SDES_FLG - CBM Descriptor Flag
+#define TSO_DEBUG_CFG_CBM_SDES_FLG_MASK 0x4000u
+
+//! Field CBM_JDES_FLG - CBM Descriptor Flag
+#define TSO_DEBUG_CFG_CBM_JDES_FLG_POS 15
+//! Field CBM_JDES_FLG - CBM Descriptor Flag
+#define TSO_DEBUG_CFG_CBM_JDES_FLG_MASK 0x8000u
+
+//! Field VER - TSO Version code
+#define TSO_DEBUG_CFG_VER_POS 28
+//! Field VER - TSO Version code
+#define TSO_DEBUG_CFG_VER_MASK 0xF0000000u
+
+//! @}
+
+//! \defgroup TSO_INTL_INT_STAT Register TSO_INTL_INT_STAT - Internal Interrupt Status
+//! @{
+
+//! Register Offset (relative)
+#define TSO_INTL_INT_STAT 0x1054
+
+//! Register Reset Value
+#define TSO_INTL_INT_STAT_RST 0x00000000u
+
+//! Field MCPY0_DONE
+#define TSO_INTL_INT_STAT_MCPY0_DONE_POS 0
+//! Field MCPY0_DONE
+#define TSO_INTL_INT_STAT_MCPY0_DONE_MASK 0x1u
+
+//! Field MCPY1_DONE
+#define TSO_INTL_INT_STAT_MCPY1_DONE_POS 1
+//! Field MCPY1_DONE
+#define TSO_INTL_INT_STAT_MCPY1_DONE_MASK 0x2u
+
+//! Field MCPY2_DONE
+#define TSO_INTL_INT_STAT_MCPY2_DONE_POS 2
+//! Field MCPY2_DONE
+#define TSO_INTL_INT_STAT_MCPY2_DONE_MASK 0x4u
+
+//! Field MCPY3_DONE
+#define TSO_INTL_INT_STAT_MCPY3_DONE_POS 3
+//! Field MCPY3_DONE
+#define TSO_INTL_INT_STAT_MCPY3_DONE_MASK 0x8u
+
+//! Field MCPY0_CMD_ERR
+#define TSO_INTL_INT_STAT_MCPY0_CMD_ERR_POS 4
+//! Field MCPY0_CMD_ERR
+#define TSO_INTL_INT_STAT_MCPY0_CMD_ERR_MASK 0x10u
+
+//! Field MCPY1_CMD_ERR
+#define TSO_INTL_INT_STAT_MCPY1_CMD_ERR_POS 5
+//! Field MCPY1_CMD_ERR
+#define TSO_INTL_INT_STAT_MCPY1_CMD_ERR_MASK 0x20u
+
+//! Field MCPY2_CMD_ERR
+#define TSO_INTL_INT_STAT_MCPY2_CMD_ERR_POS 6
+//! Field MCPY2_CMD_ERR
+#define TSO_INTL_INT_STAT_MCPY2_CMD_ERR_MASK 0x40u
+
+//! Field MCPY3_CMD_ERR
+#define TSO_INTL_INT_STAT_MCPY3_CMD_ERR_POS 7
+//! Field MCPY3_CMD_ERR
+#define TSO_INTL_INT_STAT_MCPY3_CMD_ERR_MASK 0x80u
+
+//! Field MCPY0_LEN_ERR
+#define TSO_INTL_INT_STAT_MCPY0_LEN_ERR_POS 8
+//! Field MCPY0_LEN_ERR
+#define TSO_INTL_INT_STAT_MCPY0_LEN_ERR_MASK 0x100u
+
+//! Field MCPY1_LEN_ERR
+#define TSO_INTL_INT_STAT_MCPY1_LEN_ERR_POS 9
+//! Field MCPY1_LEN_ERR
+#define TSO_INTL_INT_STAT_MCPY1_LEN_ERR_MASK 0x200u
+
+//! Field MCPY2_LEN_ERR
+#define TSO_INTL_INT_STAT_MCPY2_LEN_ERR_POS 10
+//! Field MCPY2_LEN_ERR
+#define TSO_INTL_INT_STAT_MCPY2_LEN_ERR_MASK 0x400u
+
+//! Field MCPY3_LEN_ERR
+#define TSO_INTL_INT_STAT_MCPY3_LEN_ERR_POS 11
+//! Field MCPY3_LEN_ERR
+#define TSO_INTL_INT_STAT_MCPY3_LEN_ERR_MASK 0x800u
+
+//! Field TSO0_TCP_ERR
+#define TSO_INTL_INT_STAT_TSO0_TCP_ERR_POS 12
+//! Field TSO0_TCP_ERR
+#define TSO_INTL_INT_STAT_TSO0_TCP_ERR_MASK 0x1000u
+
+//! Field TSO1_TCP_ERR
+#define TSO_INTL_INT_STAT_TSO1_TCP_ERR_POS 13
+//! Field TSO1_TCP_ERR
+#define TSO_INTL_INT_STAT_TSO1_TCP_ERR_MASK 0x2000u
+
+//! Field TSO2_TCP_ERR
+#define TSO_INTL_INT_STAT_TSO2_TCP_ERR_POS 14
+//! Field TSO2_TCP_ERR
+#define TSO_INTL_INT_STAT_TSO2_TCP_ERR_MASK 0x4000u
+
+//! Field TSO3_TCP_ERR
+#define TSO_INTL_INT_STAT_TSO3_TCP_ERR_POS 15
+//! Field TSO3_TCP_ERR
+#define TSO_INTL_INT_STAT_TSO3_TCP_ERR_MASK 0x8000u
+
+//! Field TSO0_BUS_ERR
+#define TSO_INTL_INT_STAT_TSO0_BUS_ERR_POS 16
+//! Field TSO0_BUS_ERR
+#define TSO_INTL_INT_STAT_TSO0_BUS_ERR_MASK 0x10000u
+
+//! Field TSO1_BUS_ERR
+#define TSO_INTL_INT_STAT_TSO1_BUS_ERR_POS 17
+//! Field TSO1_BUS_ERR
+#define TSO_INTL_INT_STAT_TSO1_BUS_ERR_MASK 0x20000u
+
+//! Field TSO2_BUS_ERR
+#define TSO_INTL_INT_STAT_TSO2_BUS_ERR_POS 18
+//! Field TSO2_BUS_ERR
+#define TSO_INTL_INT_STAT_TSO2_BUS_ERR_MASK 0x40000u
+
+//! Field TSO3_BUS_ERR
+#define TSO_INTL_INT_STAT_TSO3_BUS_ERR_POS 19
+//! Field TSO3_BUS_ERR
+#define TSO_INTL_INT_STAT_TSO3_BUS_ERR_MASK 0x80000u
+
+//! @}
+
+//! \defgroup TSO_INTL_INT_EN Register TSO_INTL_INT_EN - Internal Interrupt Status
+//! @{
+
+//! Register Offset (relative)
+#define TSO_INTL_INT_EN 0x1058
+
+//! Register Reset Value
+#define TSO_INTL_INT_EN_RST 0x00000000u
+
+//! Field MCPY0_DONE
+#define TSO_INTL_INT_EN_MCPY0_DONE_POS 0
+//! Field MCPY0_DONE
+#define TSO_INTL_INT_EN_MCPY0_DONE_MASK 0x1u
+
+//! Field MCPY1_DONE
+#define TSO_INTL_INT_EN_MCPY1_DONE_POS 1
+//! Field MCPY1_DONE
+#define TSO_INTL_INT_EN_MCPY1_DONE_MASK 0x2u
+
+//! Field MCPY2_DONE
+#define TSO_INTL_INT_EN_MCPY2_DONE_POS 2
+//! Field MCPY2_DONE
+#define TSO_INTL_INT_EN_MCPY2_DONE_MASK 0x4u
+
+//! Field MCPY3_DONE
+#define TSO_INTL_INT_EN_MCPY3_DONE_POS 3
+//! Field MCPY3_DONE
+#define TSO_INTL_INT_EN_MCPY3_DONE_MASK 0x8u
+
+//! Field MCPY0_CMD_ERR
+#define TSO_INTL_INT_EN_MCPY0_CMD_ERR_POS 4
+//! Field MCPY0_CMD_ERR
+#define TSO_INTL_INT_EN_MCPY0_CMD_ERR_MASK 0x10u
+
+//! Field MCPY1_CMD_ERR
+#define TSO_INTL_INT_EN_MCPY1_CMD_ERR_POS 5
+//! Field MCPY1_CMD_ERR
+#define TSO_INTL_INT_EN_MCPY1_CMD_ERR_MASK 0x20u
+
+//! Field MCPY2_CMD_ERR
+#define TSO_INTL_INT_EN_MCPY2_CMD_ERR_POS 6
+//! Field MCPY2_CMD_ERR
+#define TSO_INTL_INT_EN_MCPY2_CMD_ERR_MASK 0x40u
+
+//! Field MCPY3_CMD_ERR
+#define TSO_INTL_INT_EN_MCPY3_CMD_ERR_POS 7
+//! Field MCPY3_CMD_ERR
+#define TSO_INTL_INT_EN_MCPY3_CMD_ERR_MASK 0x80u
+
+//! Field MCPY0_LEN_ERR
+#define TSO_INTL_INT_EN_MCPY0_LEN_ERR_POS 8
+//! Field MCPY0_LEN_ERR
+#define TSO_INTL_INT_EN_MCPY0_LEN_ERR_MASK 0x100u
+
+//! Field MCPY1_LEN_ERR
+#define TSO_INTL_INT_EN_MCPY1_LEN_ERR_POS 9
+//! Field MCPY1_LEN_ERR
+#define TSO_INTL_INT_EN_MCPY1_LEN_ERR_MASK 0x200u
+
+//! Field MCPY2_LEN_ERR
+#define TSO_INTL_INT_EN_MCPY2_LEN_ERR_POS 10
+//! Field MCPY2_LEN_ERR
+#define TSO_INTL_INT_EN_MCPY2_LEN_ERR_MASK 0x400u
+
+//! Field MCPY3_LEN_ERR
+#define TSO_INTL_INT_EN_MCPY3_LEN_ERR_POS 11
+//! Field MCPY3_LEN_ERR
+#define TSO_INTL_INT_EN_MCPY3_LEN_ERR_MASK 0x800u
+
+//! Field TSO0_TCP_ERR
+#define TSO_INTL_INT_EN_TSO0_TCP_ERR_POS 12
+//! Field TSO0_TCP_ERR
+#define TSO_INTL_INT_EN_TSO0_TCP_ERR_MASK 0x1000u
+
+//! Field TSO1_TCP_ERR
+#define TSO_INTL_INT_EN_TSO1_TCP_ERR_POS 13
+//! Field TSO1_TCP_ERR
+#define TSO_INTL_INT_EN_TSO1_TCP_ERR_MASK 0x2000u
+
+//! Field TSO2_TCP_ERR
+#define TSO_INTL_INT_EN_TSO2_TCP_ERR_POS 14
+//! Field TSO2_TCP_ERR
+#define TSO_INTL_INT_EN_TSO2_TCP_ERR_MASK 0x4000u
+
+//! Field TSO3_TCP_ERR
+#define TSO_INTL_INT_EN_TSO3_TCP_ERR_POS 15
+//! Field TSO3_TCP_ERR
+#define TSO_INTL_INT_EN_TSO3_TCP_ERR_MASK 0x8000u
+
+//! Field TSO0_BUS_ERR
+#define TSO_INTL_INT_EN_TSO0_BUS_ERR_POS 16
+//! Field TSO0_BUS_ERR
+#define TSO_INTL_INT_EN_TSO0_BUS_ERR_MASK 0x10000u
+
+//! Field TSO1_BUS_ERR
+#define TSO_INTL_INT_EN_TSO1_BUS_ERR_POS 17
+//! Field TSO1_BUS_ERR
+#define TSO_INTL_INT_EN_TSO1_BUS_ERR_MASK 0x20000u
+
+//! Field TSO2_BUS_ERR
+#define TSO_INTL_INT_EN_TSO2_BUS_ERR_POS 18
+//! Field TSO2_BUS_ERR
+#define TSO_INTL_INT_EN_TSO2_BUS_ERR_MASK 0x40000u
+
+//! Field TSO3_BUS_ERR
+#define TSO_INTL_INT_EN_TSO3_BUS_ERR_POS 19
+//! Field TSO3_BUS_ERR
+#define TSO_INTL_INT_EN_TSO3_BUS_ERR_MASK 0x80000u
+
+//! @}
+
+//! \defgroup TSO_INTL_INT_MASK Register TSO_INTL_INT_MASK - Internal Interrupt Status
+//! @{
+
+//! Register Offset (relative)
+#define TSO_INTL_INT_MASK 0x105C
+
+//! Register Reset Value
+#define TSO_INTL_INT_MASK_RST 0x00000000u
+
+//! Field MCPY0_DONE
+#define TSO_INTL_INT_MASK_MCPY0_DONE_POS 0
+//! Field MCPY0_DONE
+#define TSO_INTL_INT_MASK_MCPY0_DONE_MASK 0x1u
+
+//! Field MCPY1_DONE
+#define TSO_INTL_INT_MASK_MCPY1_DONE_POS 1
+//! Field MCPY1_DONE
+#define TSO_INTL_INT_MASK_MCPY1_DONE_MASK 0x2u
+
+//! Field MCPY2_DONE
+#define TSO_INTL_INT_MASK_MCPY2_DONE_POS 2
+//! Field MCPY2_DONE
+#define TSO_INTL_INT_MASK_MCPY2_DONE_MASK 0x4u
+
+//! Field MCPY3_DONE
+#define TSO_INTL_INT_MASK_MCPY3_DONE_POS 3
+//! Field MCPY3_DONE
+#define TSO_INTL_INT_MASK_MCPY3_DONE_MASK 0x8u
+
+//! Field MCPY0_CMD_ERR
+#define TSO_INTL_INT_MASK_MCPY0_CMD_ERR_POS 4
+//! Field MCPY0_CMD_ERR
+#define TSO_INTL_INT_MASK_MCPY0_CMD_ERR_MASK 0x10u
+
+//! Field MCPY1_CMD_ERR
+#define TSO_INTL_INT_MASK_MCPY1_CMD_ERR_POS 5
+//! Field MCPY1_CMD_ERR
+#define TSO_INTL_INT_MASK_MCPY1_CMD_ERR_MASK 0x20u
+
+//! Field MCPY2_CMD_ERR
+#define TSO_INTL_INT_MASK_MCPY2_CMD_ERR_POS 6
+//! Field MCPY2_CMD_ERR
+#define TSO_INTL_INT_MASK_MCPY2_CMD_ERR_MASK 0x40u
+
+//! Field MCPY3_CMD_ERR
+#define TSO_INTL_INT_MASK_MCPY3_CMD_ERR_POS 7
+//! Field MCPY3_CMD_ERR
+#define TSO_INTL_INT_MASK_MCPY3_CMD_ERR_MASK 0x80u
+
+//! Field MCPY0_LEN_ERR
+#define TSO_INTL_INT_MASK_MCPY0_LEN_ERR_POS 8
+//! Field MCPY0_LEN_ERR
+#define TSO_INTL_INT_MASK_MCPY0_LEN_ERR_MASK 0x100u
+
+//! Field MCPY1_LEN_ERR
+#define TSO_INTL_INT_MASK_MCPY1_LEN_ERR_POS 9
+//! Field MCPY1_LEN_ERR
+#define TSO_INTL_INT_MASK_MCPY1_LEN_ERR_MASK 0x200u
+
+//! Field MCPY2_LEN_ERR
+#define TSO_INTL_INT_MASK_MCPY2_LEN_ERR_POS 10
+//! Field MCPY2_LEN_ERR
+#define TSO_INTL_INT_MASK_MCPY2_LEN_ERR_MASK 0x400u
+
+//! Field MCPY3_LEN_ERR
+#define TSO_INTL_INT_MASK_MCPY3_LEN_ERR_POS 11
+//! Field MCPY3_LEN_ERR
+#define TSO_INTL_INT_MASK_MCPY3_LEN_ERR_MASK 0x800u
+
+//! Field TSO0_TCP_ERR
+#define TSO_INTL_INT_MASK_TSO0_TCP_ERR_POS 12
+//! Field TSO0_TCP_ERR
+#define TSO_INTL_INT_MASK_TSO0_TCP_ERR_MASK 0x1000u
+
+//! Field TSO1_TCP_ERR
+#define TSO_INTL_INT_MASK_TSO1_TCP_ERR_POS 13
+//! Field TSO1_TCP_ERR
+#define TSO_INTL_INT_MASK_TSO1_TCP_ERR_MASK 0x2000u
+
+//! Field TSO2_TCP_ERR
+#define TSO_INTL_INT_MASK_TSO2_TCP_ERR_POS 14
+//! Field TSO2_TCP_ERR
+#define TSO_INTL_INT_MASK_TSO2_TCP_ERR_MASK 0x4000u
+
+//! Field TSO3_TCP_ERR
+#define TSO_INTL_INT_MASK_TSO3_TCP_ERR_POS 15
+//! Field TSO3_TCP_ERR
+#define TSO_INTL_INT_MASK_TSO3_TCP_ERR_MASK 0x8000u
+
+//! Field TSO0_BUS_ERR
+#define TSO_INTL_INT_MASK_TSO0_BUS_ERR_POS 16
+//! Field TSO0_BUS_ERR
+#define TSO_INTL_INT_MASK_TSO0_BUS_ERR_MASK 0x10000u
+
+//! Field TSO1_BUS_ERR
+#define TSO_INTL_INT_MASK_TSO1_BUS_ERR_POS 17
+//! Field TSO1_BUS_ERR
+#define TSO_INTL_INT_MASK_TSO1_BUS_ERR_MASK 0x20000u
+
+//! Field TSO2_BUS_ERR
+#define TSO_INTL_INT_MASK_TSO2_BUS_ERR_POS 18
+//! Field TSO2_BUS_ERR
+#define TSO_INTL_INT_MASK_TSO2_BUS_ERR_MASK 0x40000u
+
+//! Field TSO3_BUS_ERR
+#define TSO_INTL_INT_MASK_TSO3_BUS_ERR_POS 19
+//! Field TSO3_BUS_ERR
+#define TSO_INTL_INT_MASK_TSO3_BUS_ERR_MASK 0x80000u
+
+//! @}
+
+//! \defgroup TSO_DBG_HPIN_D_RX0 Register TSO_DBG_HPIN_D_RX0
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_HPIN_D_RX0 0x1060
+
+//! Register Reset Value
+#define TSO_DBG_HPIN_D_RX0_RST 0x00000000u
+
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_HPIN_D_RX0_DOWRD0_POS 0
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_HPIN_D_RX0_DOWRD0_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_HPIN_D_RX1 Register TSO_DBG_HPIN_D_RX1
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_HPIN_D_RX1 0x1064
+
+//! Register Reset Value
+#define TSO_DBG_HPIN_D_RX1_RST 0x00000000u
+
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_HPIN_D_RX1_DWORD1_POS 0
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_HPIN_D_RX1_DWORD1_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_DPIN_D_RX0 Register TSO_DBG_DPIN_D_RX0
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_DPIN_D_RX0 0x1068
+
+//! Register Reset Value
+#define TSO_DBG_DPIN_D_RX0_RST 0x00000000u
+
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_DPIN_D_RX0_DOWRD0_POS 0
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_DPIN_D_RX0_DOWRD0_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_DPIN_D_RX1 Register TSO_DBG_DPIN_D_RX1
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_DPIN_D_RX1 0x106C
+
+//! Register Reset Value
+#define TSO_DBG_DPIN_D_RX1_RST 0x00000000u
+
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_DPIN_D_RX1_DWORD1_POS 0
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_DPIN_D_RX1_DWORD1_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_HPIN_D_TX0 Register TSO_DBG_HPIN_D_TX0
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_HPIN_D_TX0 0x1070
+
+//! Register Reset Value
+#define TSO_DBG_HPIN_D_TX0_RST 0x00000000u
+
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_HPIN_D_TX0_DOWRD0_POS 0
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_HPIN_D_TX0_DOWRD0_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_HPIN_D_TX1 Register TSO_DBG_HPIN_D_TX1
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_HPIN_D_TX1 0x1074
+
+//! Register Reset Value
+#define TSO_DBG_HPIN_D_TX1_RST 0x00000000u
+
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_HPIN_D_TX1_DWORD1_POS 0
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_HPIN_D_TX1_DWORD1_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_DPIN_D_TX0 Register TSO_DBG_DPIN_D_TX0
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_DPIN_D_TX0 0x1078
+
+//! Register Reset Value
+#define TSO_DBG_DPIN_D_TX0_RST 0x00000000u
+
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_DPIN_D_TX0_DOWRD0_POS 0
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_DPIN_D_TX0_DOWRD0_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_DPIN_D_TX1 Register TSO_DBG_DPIN_D_TX1
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_DPIN_D_TX1 0x107C
+
+//! Register Reset Value
+#define TSO_DBG_DPIN_D_TX1_RST 0x00000000u
+
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_DPIN_D_TX1_DWORD1_POS 0
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_DPIN_D_TX1_DWORD1_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_HPON_D_RX0 Register TSO_DBG_HPON_D_RX0
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_HPON_D_RX0 0x1080
+
+//! Register Reset Value
+#define TSO_DBG_HPON_D_RX0_RST 0x00000000u
+
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_HPON_D_RX0_DOWRD0_POS 0
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_HPON_D_RX0_DOWRD0_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_HPON_D_RX1 Register TSO_DBG_HPON_D_RX1
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_HPON_D_RX1 0x1084
+
+//! Register Reset Value
+#define TSO_DBG_HPON_D_RX1_RST 0x00000000u
+
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_HPON_D_RX1_DWORD1_POS 0
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_HPON_D_RX1_DWORD1_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_DPON_D_RX0 Register TSO_DBG_DPON_D_RX0
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_DPON_D_RX0 0x1088
+
+//! Register Reset Value
+#define TSO_DBG_DPON_D_RX0_RST 0x00000000u
+
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_DPON_D_RX0_DOWRD0_POS 0
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_DPON_D_RX0_DOWRD0_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_DPON_D_RX1 Register TSO_DBG_DPON_D_RX1
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_DPON_D_RX1 0x108C
+
+//! Register Reset Value
+#define TSO_DBG_DPON_D_RX1_RST 0x00000000u
+
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_DPON_D_RX1_DWORD1_POS 0
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_DPON_D_RX1_DWORD1_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_HPON_D_TX0 Register TSO_DBG_HPON_D_TX0
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_HPON_D_TX0 0x1090
+
+//! Register Reset Value
+#define TSO_DBG_HPON_D_TX0_RST 0x00000000u
+
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_HPON_D_TX0_DOWRD0_POS 0
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_HPON_D_TX0_DOWRD0_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_HPON_D_TX1 Register TSO_DBG_HPON_D_TX1
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_HPON_D_TX1 0x1094
+
+//! Register Reset Value
+#define TSO_DBG_HPON_D_TX1_RST 0x00000000u
+
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_HPON_D_TX1_DWORD1_POS 0
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_HPON_D_TX1_DWORD1_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_DPON_D_TX0 Register TSO_DBG_DPON_D_TX0
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_DPON_D_TX0 0x1098
+
+//! Register Reset Value
+#define TSO_DBG_DPON_D_TX0_RST 0x00000000u
+
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_DPON_D_TX0_DOWRD0_POS 0
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_DPON_D_TX0_DOWRD0_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_DPON_D_TX1 Register TSO_DBG_DPON_D_TX1
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_DPON_D_TX1 0x109C
+
+//! Register Reset Value
+#define TSO_DBG_DPON_D_TX1_RST 0x00000000u
+
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_DPON_D_TX1_DWORD1_POS 0
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_DPON_D_TX1_DWORD1_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_EPIN_D_RX0 Register TSO_DBG_EPIN_D_RX0
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_EPIN_D_RX0 0x10A0
+
+//! Register Reset Value
+#define TSO_DBG_EPIN_D_RX0_RST 0x00000000u
+
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_EPIN_D_RX0_DOWRD0_POS 0
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_EPIN_D_RX0_DOWRD0_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_EPIN_D_RX1 Register TSO_DBG_EPIN_D_RX1
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_EPIN_D_RX1 0x10A4
+
+//! Register Reset Value
+#define TSO_DBG_EPIN_D_RX1_RST 0x00000000u
+
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_EPIN_D_RX1_DWORD1_POS 0
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_EPIN_D_RX1_DWORD1_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_EPIN_D_TX0 Register TSO_DBG_EPIN_D_TX0
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_EPIN_D_TX0 0x10A8
+
+//! Register Reset Value
+#define TSO_DBG_EPIN_D_TX0_RST 0x00000000u
+
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_EPIN_D_TX0_DOWRD0_POS 0
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_EPIN_D_TX0_DOWRD0_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_EPIN_D_TX1 Register TSO_DBG_EPIN_D_TX1
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_EPIN_D_TX1 0x10AC
+
+//! Register Reset Value
+#define TSO_DBG_EPIN_D_TX1_RST 0x00000000u
+
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_EPIN_D_TX1_DWORD1_POS 0
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_EPIN_D_TX1_DWORD1_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_EPON_D_RX0 Register TSO_DBG_EPON_D_RX0
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_EPON_D_RX0 0x10B0
+
+//! Register Reset Value
+#define TSO_DBG_EPON_D_RX0_RST 0x00000000u
+
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_EPON_D_RX0_DOWRD0_POS 0
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_EPON_D_RX0_DOWRD0_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_EPON_D_RX1 Register TSO_DBG_EPON_D_RX1
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_EPON_D_RX1 0x10B4
+
+//! Register Reset Value
+#define TSO_DBG_EPON_D_RX1_RST 0x00000000u
+
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_EPON_D_RX1_DWORD1_POS 0
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_EPON_D_RX1_DWORD1_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_EPON_D_TX0 Register TSO_DBG_EPON_D_TX0
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_EPON_D_TX0 0x10B8
+
+//! Register Reset Value
+#define TSO_DBG_EPON_D_TX0_RST 0x00000000u
+
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_EPON_D_TX0_DOWRD0_POS 0
+//! Field DOWRD0 - Descriptor Word 0
+#define TSO_DBG_EPON_D_TX0_DOWRD0_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_EPON_D_TX1 Register TSO_DBG_EPON_D_TX1
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_EPON_D_TX1 0x10BC
+
+//! Register Reset Value
+#define TSO_DBG_EPON_D_TX1_RST 0x00000000u
+
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_EPON_D_TX1_DWORD1_POS 0
+//! Field DWORD1 - Descriptor 1
+#define TSO_DBG_EPON_D_TX1_DWORD1_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_OCP_RDATA_0 Register TSO_DBG_OCP_RDATA_0
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_OCP_RDATA_0 0x10C0
+
+//! Register Reset Value
+#define TSO_DBG_OCP_RDATA_0_RST 0x00000000u
+
+//! Field READ_DATA - OCP Master read data
+#define TSO_DBG_OCP_RDATA_0_READ_DATA_POS 0
+//! Field READ_DATA - OCP Master read data
+#define TSO_DBG_OCP_RDATA_0_READ_DATA_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_OCP_RDATA_1 Register TSO_DBG_OCP_RDATA_1
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_OCP_RDATA_1 0x10C4
+
+//! Register Reset Value
+#define TSO_DBG_OCP_RDATA_1_RST 0x00000000u
+
+//! Field READ_DATA - OCP Master read data
+#define TSO_DBG_OCP_RDATA_1_READ_DATA_POS 0
+//! Field READ_DATA - OCP Master read data
+#define TSO_DBG_OCP_RDATA_1_READ_DATA_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_OCP_RDATA_2 Register TSO_DBG_OCP_RDATA_2
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_OCP_RDATA_2 0x10C8
+
+//! Register Reset Value
+#define TSO_DBG_OCP_RDATA_2_RST 0x00000000u
+
+//! Field READ_DATA - OCP Master read data
+#define TSO_DBG_OCP_RDATA_2_READ_DATA_POS 0
+//! Field READ_DATA - OCP Master read data
+#define TSO_DBG_OCP_RDATA_2_READ_DATA_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_DBG_OCP_RDATA_3 Register TSO_DBG_OCP_RDATA_3
+//! @{
+
+//! Register Offset (relative)
+#define TSO_DBG_OCP_RDATA_3 0x10CC
+
+//! Register Reset Value
+#define TSO_DBG_OCP_RDATA_3_RST 0x00000000u
+
+//! Field READ_DATA - OCP Master read data
+#define TSO_DBG_OCP_RDATA_3_READ_DATA_POS 0
+//! Field READ_DATA - OCP Master read data
+#define TSO_DBG_OCP_RDATA_3_READ_DATA_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup LRO_DBG_OCP_RDATA_0 Register LRO_DBG_OCP_RDATA_0
+//! @{
+
+//! Register Offset (relative)
+#define LRO_DBG_OCP_RDATA_0 0x10D0
+
+//! Register Reset Value
+#define LRO_DBG_OCP_RDATA_0_RST 0x00000000u
+
+//! Field READ_DATA - OCP Master read data
+#define LRO_DBG_OCP_RDATA_0_READ_DATA_POS 0
+//! Field READ_DATA - OCP Master read data
+#define LRO_DBG_OCP_RDATA_0_READ_DATA_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup LRO_DBG_OCP_RDATA_1 Register LRO_DBG_OCP_RDATA_1
+//! @{
+
+//! Register Offset (relative)
+#define LRO_DBG_OCP_RDATA_1 0x10D4
+
+//! Register Reset Value
+#define LRO_DBG_OCP_RDATA_1_RST 0x00000000u
+
+//! Field READ_DATA - OCP Master read data
+#define LRO_DBG_OCP_RDATA_1_READ_DATA_POS 0
+//! Field READ_DATA - OCP Master read data
+#define LRO_DBG_OCP_RDATA_1_READ_DATA_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup LRO_DBG_OCP_RDATA_2 Register LRO_DBG_OCP_RDATA_2
+//! @{
+
+//! Register Offset (relative)
+#define LRO_DBG_OCP_RDATA_2 0x10D8
+
+//! Register Reset Value
+#define LRO_DBG_OCP_RDATA_2_RST 0x00000000u
+
+//! Field READ_DATA - OCP Master read data
+#define LRO_DBG_OCP_RDATA_2_READ_DATA_POS 0
+//! Field READ_DATA - OCP Master read data
+#define LRO_DBG_OCP_RDATA_2_READ_DATA_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup LRO_DBG_OCP_RDATA_3 Register LRO_DBG_OCP_RDATA_3
+//! @{
+
+//! Register Offset (relative)
+#define LRO_DBG_OCP_RDATA_3 0x10DC
+
+//! Register Reset Value
+#define LRO_DBG_OCP_RDATA_3_RST 0x00000000u
+
+//! Field READ_DATA - OCP Master read data
+#define LRO_DBG_OCP_RDATA_3_READ_DATA_POS 0
+//! Field READ_DATA - OCP Master read data
+#define LRO_DBG_OCP_RDATA_3_READ_DATA_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup LRO_DBG_INFO Register LRO_DBG_INFO
+//! @{
+
+//! Register Offset (relative)
+#define LRO_DBG_INFO 0x10E0
+
+//! Register Reset Value
+#define LRO_DBG_INFO_RST 0x00000000u
+
+//! Field LRO_FSM - LRO FSM
+#define LRO_DBG_INFO_LRO_FSM_POS 0
+//! Field LRO_FSM - LRO FSM
+#define LRO_DBG_INFO_LRO_FSM_MASK 0x1Fu
+
+//! Field SRAM_FSM - SRAM FSM
+#define LRO_DBG_INFO_SRAM_FSM_POS 5
+//! Field SRAM_FSM - SRAM FSM
+#define LRO_DBG_INFO_SRAM_FSM_MASK 0xE0u
+
+//! Field OCPM - OCPM Debug
+#define LRO_DBG_INFO_OCPM_POS 8
+//! Field OCPM - OCPM Debug
+#define LRO_DBG_INFO_OCPM_MASK 0x700u
+
+//! @}
+
+//! \defgroup TOE_MEM_BYPASS Register TOE_MEM_BYPASS
+//! @{
+
+//! Register Offset (relative)
+#define TOE_MEM_BYPASS 0x10E4
+
+//! Register Reset Value
+#define TOE_MEM_BYPASS_RST 0x00000000u
+
+//! Field LS_MEM_BYPASS - control the MEMORY Access
+#define TOE_MEM_BYPASS_LS_MEM_BYPASS_POS 0
+//! Field LS_MEM_BYPASS - control the MEMORY Access
+#define TOE_MEM_BYPASS_LS_MEM_BYPASS_MASK 0x1u
+//! Constant NOBYP - not bypass
+#define CONST_TOE_MEM_BYPASS_LS_MEM_BYPASS_NOBYP 0x0
+//! Constant BYP - Bypassed for debugging
+#define CONST_TOE_MEM_BYPASS_LS_MEM_BYPASS_BYP 0x1
+
+//! @}
+
+//! \defgroup TSO_SPARE_TIE0 Register TSO_SPARE_TIE0
+//! @{
+
+//! Register Offset (relative)
+#define TSO_SPARE_TIE0 0x10E8
+
+//! Register Reset Value
+#define TSO_SPARE_TIE0_RST 0x00000000u
+
+//! Field TSO_SPARE - SPARE register
+#define TSO_SPARE_TIE0_TSO_SPARE_POS 0
+//! Field TSO_SPARE - SPARE register
+#define TSO_SPARE_TIE0_TSO_SPARE_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup TSO_SPARE_TIE1 Register TSO_SPARE_TIE1
+//! @{
+
+//! Register Offset (relative)
+#define TSO_SPARE_TIE1 0x10EC
+
+//! Register Reset Value
+#define TSO_SPARE_TIE1_RST 0xFFFFFFFFu
+
+//! Field TSO_SPARE - SPARE register
+#define TSO_SPARE_TIE1_TSO_SPARE_POS 0
+//! Field TSO_SPARE - SPARE register
+#define TSO_SPARE_TIE1_TSO_SPARE_MASK 0xFFFFFFFFu
+
+//! @}
+
+//! \defgroup LRO_OC_FLAG_0 Register LRO_OC_FLAG_0 - LRO Output Context Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_FLAG_0 0x20A8
+
+//! Register Reset Value
+#define LRO_OC_FLAG_0_RST 0x00000000u
+
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_0_AGG_POS 0
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_0_AGG_MASK 0x1u
+//! Constant AGG0 - single packet session
+#define CONST_LRO_OC_FLAG_0_AGG_AGG0 0x0
+//! Constant AGG1 - Aggregation is performance; more than one segment
+#define CONST_LRO_OC_FLAG_0_AGG_AGG1 0x1
+
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_0_TCP_TS_POS 1
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_0_TCP_TS_MASK 0x2u
+//! Constant NIL - not done
+#define CONST_LRO_OC_FLAG_0_TCP_TS_NIL 0x0
+//! Constant TS_D - Done TCP Timestamp check
+#define CONST_LRO_OC_FLAG_0_TCP_TS_TS_D 0x1
+
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_0_EXCPT_POS 2
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_0_EXCPT_MASK 0x4u
+//! Constant NIL - No exception
+#define CONST_LRO_OC_FLAG_0_EXCPT_NIL 0x0
+//! Constant EXP - any exception happened
+#define CONST_LRO_OC_FLAG_0_EXCPT_EXP 0x1
+
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_0_EXP_CASE_POS 3
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_0_EXP_CASE_MASK 0x78u
+//! Constant E0 - Flush based on GSWIP indication given
+#define CONST_LRO_OC_FLAG_0_EXP_CASE_E0 0x0
+//! Constant E1 - TCP check sum error
+#define CONST_LRO_OC_FLAG_0_EXP_CASE_E1 0x1
+//! Constant E2 - FID mismatch(not used)
+#define CONST_LRO_OC_FLAG_0_EXP_CASE_E2 0x2
+//! Constant E3 - TCP zero length packet
+#define CONST_LRO_OC_FLAG_0_EXP_CASE_E3 0x3
+//! Constant E4 - TCP Timestamp check error
+#define CONST_LRO_OC_FLAG_0_EXP_CASE_E4 0x4
+//! Constant E5 - Excessive length
+#define CONST_LRO_OC_FLAG_0_EXP_CASE_E5 0x5
+//! Constant E6 - session timeout
+#define CONST_LRO_OC_FLAG_0_EXP_CASE_E6 0x6
+//! Constant E7 - TCP sequence number out of order
+#define CONST_LRO_OC_FLAG_0_EXP_CASE_E7 0x7
+
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_0_SEG_NR_POS 10
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_0_SEG_NR_MASK 0x7C00u
+
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_0_TPL_POS 15
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_0_TPL_MASK 0x7FFF8000u
+
+//! @}
+
+//! \defgroup LRO_OC_OWNER_0 Register LRO_OC_OWNER_0 - Owner bit for the output context
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_OWNER_0 0x20B0
+
+//! Register Reset Value
+#define LRO_OC_OWNER_0_RST 0x00000000u
+
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_0_OWNER_POS 31
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_0_OWNER_MASK 0x80000000u
+//! Constant LRO - SW writes 1 to clear it to 0 .
+#define CONST_LRO_OC_OWNER_0_OWNER_LRO 0x0
+//! Constant SW - LRO HW writes '1' to give ownership to SW
+#define CONST_LRO_OC_OWNER_0_OWNER_SW 0x1
+
+//! @}
+
+//! \defgroup LRO_OC_FLAG_1 Register LRO_OC_FLAG_1 - LRO Output Context Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_FLAG_1 0x21A8
+
+//! Register Reset Value
+#define LRO_OC_FLAG_1_RST 0x00000000u
+
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_1_AGG_POS 0
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_1_AGG_MASK 0x1u
+//! Constant AGG0 - single packet session
+#define CONST_LRO_OC_FLAG_1_AGG_AGG0 0x0
+//! Constant AGG1 - Aggregation is performance; more than one segment
+#define CONST_LRO_OC_FLAG_1_AGG_AGG1 0x1
+
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_1_TCP_TS_POS 1
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_1_TCP_TS_MASK 0x2u
+//! Constant NIL - not done
+#define CONST_LRO_OC_FLAG_1_TCP_TS_NIL 0x0
+//! Constant TS_D - Done TCP Timestamp check
+#define CONST_LRO_OC_FLAG_1_TCP_TS_TS_D 0x1
+
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_1_EXCPT_POS 2
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_1_EXCPT_MASK 0x4u
+//! Constant NIL - No exception
+#define CONST_LRO_OC_FLAG_1_EXCPT_NIL 0x0
+//! Constant EXP - any exception happened
+#define CONST_LRO_OC_FLAG_1_EXCPT_EXP 0x1
+
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_1_EXP_CASE_POS 3
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_1_EXP_CASE_MASK 0x78u
+//! Constant E0 - Flush based on GSWIP indication given
+#define CONST_LRO_OC_FLAG_1_EXP_CASE_E0 0x0
+//! Constant E1 - TCP check sum error
+#define CONST_LRO_OC_FLAG_1_EXP_CASE_E1 0x1
+//! Constant E2 - FID mismatch(not used)
+#define CONST_LRO_OC_FLAG_1_EXP_CASE_E2 0x2
+//! Constant E3 - TCP zero length packet
+#define CONST_LRO_OC_FLAG_1_EXP_CASE_E3 0x3
+//! Constant E4 - TCP Timestamp check error
+#define CONST_LRO_OC_FLAG_1_EXP_CASE_E4 0x4
+//! Constant E5 - Excessive length
+#define CONST_LRO_OC_FLAG_1_EXP_CASE_E5 0x5
+//! Constant E6 - session timeout
+#define CONST_LRO_OC_FLAG_1_EXP_CASE_E6 0x6
+//! Constant E7 - TCP sequence number out of order
+#define CONST_LRO_OC_FLAG_1_EXP_CASE_E7 0x7
+
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_1_SEG_NR_POS 10
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_1_SEG_NR_MASK 0x7C00u
+
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_1_TPL_POS 15
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_1_TPL_MASK 0x7FFF8000u
+
+//! @}
+
+//! \defgroup LRO_OC_OWNER_1 Register LRO_OC_OWNER_1 - Owner bit for the output context
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_OWNER_1 0x21B0
+
+//! Register Reset Value
+#define LRO_OC_OWNER_1_RST 0x00000000u
+
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_1_OWNER_POS 31
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_1_OWNER_MASK 0x80000000u
+//! Constant LRO - SW writes 1 to clear it to 0 .
+#define CONST_LRO_OC_OWNER_1_OWNER_LRO 0x0
+//! Constant SW - LRO HW writes '1' to give ownership to SW
+#define CONST_LRO_OC_OWNER_1_OWNER_SW 0x1
+
+//! @}
+
+//! \defgroup LRO_OC_FLAG_2 Register LRO_OC_FLAG_2 - LRO Output Context Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_FLAG_2 0x22A8
+
+//! Register Reset Value
+#define LRO_OC_FLAG_2_RST 0x00000000u
+
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_2_AGG_POS 0
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_2_AGG_MASK 0x1u
+//! Constant AGG0 - single packet session
+#define CONST_LRO_OC_FLAG_2_AGG_AGG0 0x0
+//! Constant AGG1 - Aggregation is performance; more than one segment
+#define CONST_LRO_OC_FLAG_2_AGG_AGG1 0x1
+
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_2_TCP_TS_POS 1
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_2_TCP_TS_MASK 0x2u
+//! Constant NIL - not done
+#define CONST_LRO_OC_FLAG_2_TCP_TS_NIL 0x0
+//! Constant TS_D - Done TCP Timestamp check
+#define CONST_LRO_OC_FLAG_2_TCP_TS_TS_D 0x1
+
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_2_EXCPT_POS 2
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_2_EXCPT_MASK 0x4u
+//! Constant NIL - No exception
+#define CONST_LRO_OC_FLAG_2_EXCPT_NIL 0x0
+//! Constant EXP - any exception happened
+#define CONST_LRO_OC_FLAG_2_EXCPT_EXP 0x1
+
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_2_EXP_CASE_POS 3
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_2_EXP_CASE_MASK 0x78u
+//! Constant E0 - Flush based on GSWIP indication given
+#define CONST_LRO_OC_FLAG_2_EXP_CASE_E0 0x0
+//! Constant E1 - TCP check sum error
+#define CONST_LRO_OC_FLAG_2_EXP_CASE_E1 0x1
+//! Constant E2 - FID mismatch(not used)
+#define CONST_LRO_OC_FLAG_2_EXP_CASE_E2 0x2
+//! Constant E3 - TCP zero length packet
+#define CONST_LRO_OC_FLAG_2_EXP_CASE_E3 0x3
+//! Constant E4 - TCP Timestamp check error
+#define CONST_LRO_OC_FLAG_2_EXP_CASE_E4 0x4
+//! Constant E5 - Excessive length
+#define CONST_LRO_OC_FLAG_2_EXP_CASE_E5 0x5
+//! Constant E6 - session timeout
+#define CONST_LRO_OC_FLAG_2_EXP_CASE_E6 0x6
+//! Constant E7 - TCP sequence number out of order
+#define CONST_LRO_OC_FLAG_2_EXP_CASE_E7 0x7
+
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_2_SEG_NR_POS 10
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_2_SEG_NR_MASK 0x7C00u
+
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_2_TPL_POS 15
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_2_TPL_MASK 0x7FFF8000u
+
+//! @}
+
+//! \defgroup LRO_OC_OWNER_2 Register LRO_OC_OWNER_2 - Owner bit for the output context
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_OWNER_2 0x22B0
+
+//! Register Reset Value
+#define LRO_OC_OWNER_2_RST 0x00000000u
+
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_2_OWNER_POS 31
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_2_OWNER_MASK 0x80000000u
+//! Constant LRO - SW writes 1 to clear it to 0 .
+#define CONST_LRO_OC_OWNER_2_OWNER_LRO 0x0
+//! Constant SW - LRO HW writes '1' to give ownership to SW
+#define CONST_LRO_OC_OWNER_2_OWNER_SW 0x1
+
+//! @}
+
+//! \defgroup LRO_OC_FLAG_3 Register LRO_OC_FLAG_3 - LRO Output Context Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_FLAG_3 0x23A8
+
+//! Register Reset Value
+#define LRO_OC_FLAG_3_RST 0x00000000u
+
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_3_AGG_POS 0
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_3_AGG_MASK 0x1u
+//! Constant AGG0 - single packet session
+#define CONST_LRO_OC_FLAG_3_AGG_AGG0 0x0
+//! Constant AGG1 - Aggregation is performance; more than one segment
+#define CONST_LRO_OC_FLAG_3_AGG_AGG1 0x1
+
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_3_TCP_TS_POS 1
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_3_TCP_TS_MASK 0x2u
+//! Constant NIL - not done
+#define CONST_LRO_OC_FLAG_3_TCP_TS_NIL 0x0
+//! Constant TS_D - Done TCP Timestamp check
+#define CONST_LRO_OC_FLAG_3_TCP_TS_TS_D 0x1
+
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_3_EXCPT_POS 2
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_3_EXCPT_MASK 0x4u
+//! Constant NIL - No exception
+#define CONST_LRO_OC_FLAG_3_EXCPT_NIL 0x0
+//! Constant EXP - any exception happened
+#define CONST_LRO_OC_FLAG_3_EXCPT_EXP 0x1
+
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_3_EXP_CASE_POS 3
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_3_EXP_CASE_MASK 0x78u
+//! Constant E0 - Flush based on GSWIP indication given
+#define CONST_LRO_OC_FLAG_3_EXP_CASE_E0 0x0
+//! Constant E1 - TCP check sum error
+#define CONST_LRO_OC_FLAG_3_EXP_CASE_E1 0x1
+//! Constant E2 - FID mismatch(not used)
+#define CONST_LRO_OC_FLAG_3_EXP_CASE_E2 0x2
+//! Constant E3 - TCP zero length packet
+#define CONST_LRO_OC_FLAG_3_EXP_CASE_E3 0x3
+//! Constant E4 - TCP Timestamp check error
+#define CONST_LRO_OC_FLAG_3_EXP_CASE_E4 0x4
+//! Constant E5 - Excessive length
+#define CONST_LRO_OC_FLAG_3_EXP_CASE_E5 0x5
+//! Constant E6 - session timeout
+#define CONST_LRO_OC_FLAG_3_EXP_CASE_E6 0x6
+//! Constant E7 - TCP sequence number out of order
+#define CONST_LRO_OC_FLAG_3_EXP_CASE_E7 0x7
+
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_3_SEG_NR_POS 10
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_3_SEG_NR_MASK 0x7C00u
+
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_3_TPL_POS 15
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_3_TPL_MASK 0x7FFF8000u
+
+//! @}
+
+//! \defgroup LRO_OC_OWNER_3 Register LRO_OC_OWNER_3 - Owner bit for the output context
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_OWNER_3 0x23B0
+
+//! Register Reset Value
+#define LRO_OC_OWNER_3_RST 0x00000000u
+
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_3_OWNER_POS 31
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_3_OWNER_MASK 0x80000000u
+//! Constant LRO - SW writes 1 to clear it to 0 .
+#define CONST_LRO_OC_OWNER_3_OWNER_LRO 0x0
+//! Constant SW - LRO HW writes '1' to give ownership to SW
+#define CONST_LRO_OC_OWNER_3_OWNER_SW 0x1
+
+//! @}
+
+//! \defgroup LRO_OC_FLAG_4 Register LRO_OC_FLAG_4 - LRO Output Context Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_FLAG_4 0x24A8
+
+//! Register Reset Value
+#define LRO_OC_FLAG_4_RST 0x00000000u
+
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_4_AGG_POS 0
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_4_AGG_MASK 0x1u
+//! Constant AGG0 - single packet session
+#define CONST_LRO_OC_FLAG_4_AGG_AGG0 0x0
+//! Constant AGG1 - Aggregation is performance; more than one segment
+#define CONST_LRO_OC_FLAG_4_AGG_AGG1 0x1
+
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_4_TCP_TS_POS 1
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_4_TCP_TS_MASK 0x2u
+//! Constant NIL - not done
+#define CONST_LRO_OC_FLAG_4_TCP_TS_NIL 0x0
+//! Constant TS_D - Done TCP Timestamp check
+#define CONST_LRO_OC_FLAG_4_TCP_TS_TS_D 0x1
+
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_4_EXCPT_POS 2
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_4_EXCPT_MASK 0x4u
+//! Constant NIL - No exception
+#define CONST_LRO_OC_FLAG_4_EXCPT_NIL 0x0
+//! Constant EXP - any exception happened
+#define CONST_LRO_OC_FLAG_4_EXCPT_EXP 0x1
+
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_4_EXP_CASE_POS 3
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_4_EXP_CASE_MASK 0x78u
+//! Constant E0 - Flush based on GSWIP indication given
+#define CONST_LRO_OC_FLAG_4_EXP_CASE_E0 0x0
+//! Constant E1 - TCP check sum error
+#define CONST_LRO_OC_FLAG_4_EXP_CASE_E1 0x1
+//! Constant E2 - FID mismatch(not used)
+#define CONST_LRO_OC_FLAG_4_EXP_CASE_E2 0x2
+//! Constant E3 - TCP zero length packet
+#define CONST_LRO_OC_FLAG_4_EXP_CASE_E3 0x3
+//! Constant E4 - TCP Timestamp check error
+#define CONST_LRO_OC_FLAG_4_EXP_CASE_E4 0x4
+//! Constant E5 - Excessive length
+#define CONST_LRO_OC_FLAG_4_EXP_CASE_E5 0x5
+//! Constant E6 - session timeout
+#define CONST_LRO_OC_FLAG_4_EXP_CASE_E6 0x6
+//! Constant E7 - TCP sequence number out of order
+#define CONST_LRO_OC_FLAG_4_EXP_CASE_E7 0x7
+
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_4_SEG_NR_POS 10
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_4_SEG_NR_MASK 0x7C00u
+
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_4_TPL_POS 15
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_4_TPL_MASK 0x7FFF8000u
+
+//! @}
+
+//! \defgroup LRO_OC_OWNER_4 Register LRO_OC_OWNER_4 - Owner bit for the output context
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_OWNER_4 0x24B0
+
+//! Register Reset Value
+#define LRO_OC_OWNER_4_RST 0x00000000u
+
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_4_OWNER_POS 31
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_4_OWNER_MASK 0x80000000u
+//! Constant LRO - SW writes 1 to clear it to 0 .
+#define CONST_LRO_OC_OWNER_4_OWNER_LRO 0x0
+//! Constant SW - LRO HW writes '1' to give ownership to SW
+#define CONST_LRO_OC_OWNER_4_OWNER_SW 0x1
+
+//! @}
+
+//! \defgroup LRO_OC_FLAG_5 Register LRO_OC_FLAG_5 - LRO Output Context Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_FLAG_5 0x25A8
+
+//! Register Reset Value
+#define LRO_OC_FLAG_5_RST 0x00000000u
+
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_5_AGG_POS 0
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_5_AGG_MASK 0x1u
+//! Constant AGG0 - single packet session
+#define CONST_LRO_OC_FLAG_5_AGG_AGG0 0x0
+//! Constant AGG1 - Aggregation is performance; more than one segment
+#define CONST_LRO_OC_FLAG_5_AGG_AGG1 0x1
+
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_5_TCP_TS_POS 1
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_5_TCP_TS_MASK 0x2u
+//! Constant NIL - not done
+#define CONST_LRO_OC_FLAG_5_TCP_TS_NIL 0x0
+//! Constant TS_D - Done TCP Timestamp check
+#define CONST_LRO_OC_FLAG_5_TCP_TS_TS_D 0x1
+
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_5_EXCPT_POS 2
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_5_EXCPT_MASK 0x4u
+//! Constant NIL - No exception
+#define CONST_LRO_OC_FLAG_5_EXCPT_NIL 0x0
+//! Constant EXP - any exception happened
+#define CONST_LRO_OC_FLAG_5_EXCPT_EXP 0x1
+
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_5_EXP_CASE_POS 3
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_5_EXP_CASE_MASK 0x78u
+//! Constant E0 - Flush based on GSWIP indication given
+#define CONST_LRO_OC_FLAG_5_EXP_CASE_E0 0x0
+//! Constant E1 - TCP check sum error
+#define CONST_LRO_OC_FLAG_5_EXP_CASE_E1 0x1
+//! Constant E2 - FID mismatch(not used)
+#define CONST_LRO_OC_FLAG_5_EXP_CASE_E2 0x2
+//! Constant E3 - TCP zero length packet
+#define CONST_LRO_OC_FLAG_5_EXP_CASE_E3 0x3
+//! Constant E4 - TCP Timestamp check error
+#define CONST_LRO_OC_FLAG_5_EXP_CASE_E4 0x4
+//! Constant E5 - Excessive length
+#define CONST_LRO_OC_FLAG_5_EXP_CASE_E5 0x5
+//! Constant E6 - session timeout
+#define CONST_LRO_OC_FLAG_5_EXP_CASE_E6 0x6
+//! Constant E7 - TCP sequence number out of order
+#define CONST_LRO_OC_FLAG_5_EXP_CASE_E7 0x7
+
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_5_SEG_NR_POS 10
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_5_SEG_NR_MASK 0x7C00u
+
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_5_TPL_POS 15
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_5_TPL_MASK 0x7FFF8000u
+
+//! @}
+
+//! \defgroup LRO_OC_OWNER_5 Register LRO_OC_OWNER_5 - Owner bit for the output context
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_OWNER_5 0x25B0
+
+//! Register Reset Value
+#define LRO_OC_OWNER_5_RST 0x00000000u
+
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_5_OWNER_POS 31
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_5_OWNER_MASK 0x80000000u
+//! Constant LRO - SW writes 1 to clear it to 0 .
+#define CONST_LRO_OC_OWNER_5_OWNER_LRO 0x0
+//! Constant SW - LRO HW writes '1' to give ownership to SW
+#define CONST_LRO_OC_OWNER_5_OWNER_SW 0x1
+
+//! @}
+
+//! \defgroup LRO_OC_FLAG_6 Register LRO_OC_FLAG_6 - LRO Output Context Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_FLAG_6 0x26A8
+
+//! Register Reset Value
+#define LRO_OC_FLAG_6_RST 0x00000000u
+
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_6_AGG_POS 0
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_6_AGG_MASK 0x1u
+//! Constant AGG0 - single packet session
+#define CONST_LRO_OC_FLAG_6_AGG_AGG0 0x0
+//! Constant AGG1 - Aggregation is performance; more than one segment
+#define CONST_LRO_OC_FLAG_6_AGG_AGG1 0x1
+
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_6_TCP_TS_POS 1
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_6_TCP_TS_MASK 0x2u
+//! Constant NIL - not done
+#define CONST_LRO_OC_FLAG_6_TCP_TS_NIL 0x0
+//! Constant TS_D - Done TCP Timestamp check
+#define CONST_LRO_OC_FLAG_6_TCP_TS_TS_D 0x1
+
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_6_EXCPT_POS 2
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_6_EXCPT_MASK 0x4u
+//! Constant NIL - No exception
+#define CONST_LRO_OC_FLAG_6_EXCPT_NIL 0x0
+//! Constant EXP - any exception happened
+#define CONST_LRO_OC_FLAG_6_EXCPT_EXP 0x1
+
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_6_EXP_CASE_POS 3
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_6_EXP_CASE_MASK 0x78u
+//! Constant E0 - Flush based on GSWIP indication given
+#define CONST_LRO_OC_FLAG_6_EXP_CASE_E0 0x0
+//! Constant E1 - TCP check sum error
+#define CONST_LRO_OC_FLAG_6_EXP_CASE_E1 0x1
+//! Constant E2 - FID mismatch(not used)
+#define CONST_LRO_OC_FLAG_6_EXP_CASE_E2 0x2
+//! Constant E3 - TCP zero length packet
+#define CONST_LRO_OC_FLAG_6_EXP_CASE_E3 0x3
+//! Constant E4 - TCP Timestamp check error
+#define CONST_LRO_OC_FLAG_6_EXP_CASE_E4 0x4
+//! Constant E5 - Excessive length
+#define CONST_LRO_OC_FLAG_6_EXP_CASE_E5 0x5
+//! Constant E6 - session timeout
+#define CONST_LRO_OC_FLAG_6_EXP_CASE_E6 0x6
+//! Constant E7 - TCP sequence number out of order
+#define CONST_LRO_OC_FLAG_6_EXP_CASE_E7 0x7
+
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_6_SEG_NR_POS 10
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_6_SEG_NR_MASK 0x7C00u
+
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_6_TPL_POS 15
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_6_TPL_MASK 0x7FFF8000u
+
+//! @}
+
+//! \defgroup LRO_OC_OWNER_6 Register LRO_OC_OWNER_6 - Owner bit for the output context
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_OWNER_6 0x26B0
+
+//! Register Reset Value
+#define LRO_OC_OWNER_6_RST 0x00000000u
+
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_6_OWNER_POS 31
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_6_OWNER_MASK 0x80000000u
+//! Constant LRO - SW writes 1 to clear it to 0 .
+#define CONST_LRO_OC_OWNER_6_OWNER_LRO 0x0
+//! Constant SW - LRO HW writes '1' to give ownership to SW
+#define CONST_LRO_OC_OWNER_6_OWNER_SW 0x1
+
+//! @}
+
+//! \defgroup LRO_OC_FLAG_7 Register LRO_OC_FLAG_7 - LRO Output Context Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_FLAG_7 0x27A8
+
+//! Register Reset Value
+#define LRO_OC_FLAG_7_RST 0x00000000u
+
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_7_AGG_POS 0
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_7_AGG_MASK 0x1u
+//! Constant AGG0 - single packet session
+#define CONST_LRO_OC_FLAG_7_AGG_AGG0 0x0
+//! Constant AGG1 - Aggregation is performance; more than one segment
+#define CONST_LRO_OC_FLAG_7_AGG_AGG1 0x1
+
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_7_TCP_TS_POS 1
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_7_TCP_TS_MASK 0x2u
+//! Constant NIL - not done
+#define CONST_LRO_OC_FLAG_7_TCP_TS_NIL 0x0
+//! Constant TS_D - Done TCP Timestamp check
+#define CONST_LRO_OC_FLAG_7_TCP_TS_TS_D 0x1
+
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_7_EXCPT_POS 2
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_7_EXCPT_MASK 0x4u
+//! Constant NIL - No exception
+#define CONST_LRO_OC_FLAG_7_EXCPT_NIL 0x0
+//! Constant EXP - any exception happened
+#define CONST_LRO_OC_FLAG_7_EXCPT_EXP 0x1
+
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_7_EXP_CASE_POS 3
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_7_EXP_CASE_MASK 0x78u
+//! Constant E0 - Flush based on GSWIP indication given
+#define CONST_LRO_OC_FLAG_7_EXP_CASE_E0 0x0
+//! Constant E1 - TCP check sum error
+#define CONST_LRO_OC_FLAG_7_EXP_CASE_E1 0x1
+//! Constant E2 - FID mismatch(not used)
+#define CONST_LRO_OC_FLAG_7_EXP_CASE_E2 0x2
+//! Constant E3 - TCP zero length packet
+#define CONST_LRO_OC_FLAG_7_EXP_CASE_E3 0x3
+//! Constant E4 - TCP Timestamp check error
+#define CONST_LRO_OC_FLAG_7_EXP_CASE_E4 0x4
+//! Constant E5 - Excessive length
+#define CONST_LRO_OC_FLAG_7_EXP_CASE_E5 0x5
+//! Constant E6 - session timeout
+#define CONST_LRO_OC_FLAG_7_EXP_CASE_E6 0x6
+//! Constant E7 - TCP sequence number out of order
+#define CONST_LRO_OC_FLAG_7_EXP_CASE_E7 0x7
+
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_7_SEG_NR_POS 10
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_7_SEG_NR_MASK 0x7C00u
+
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_7_TPL_POS 15
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_7_TPL_MASK 0x7FFF8000u
+
+//! @}
+
+//! \defgroup LRO_OC_OWNER_7 Register LRO_OC_OWNER_7 - Owner bit for the output context
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_OWNER_7 0x27B0
+
+//! Register Reset Value
+#define LRO_OC_OWNER_7_RST 0x00000000u
+
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_7_OWNER_POS 31
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_7_OWNER_MASK 0x80000000u
+//! Constant LRO - SW writes 1 to clear it to 0 .
+#define CONST_LRO_OC_OWNER_7_OWNER_LRO 0x0
+//! Constant SW - LRO HW writes '1' to give ownership to SW
+#define CONST_LRO_OC_OWNER_7_OWNER_SW 0x1
+
+//! @}
+
+//! \defgroup LRO_OC_FLAG_8 Register LRO_OC_FLAG_8 - LRO Output Context Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_FLAG_8 0x28A8
+
+//! Register Reset Value
+#define LRO_OC_FLAG_8_RST 0x00000000u
+
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_8_AGG_POS 0
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_8_AGG_MASK 0x1u
+//! Constant AGG0 - single packet session
+#define CONST_LRO_OC_FLAG_8_AGG_AGG0 0x0
+//! Constant AGG1 - Aggregation is performance; more than one segment
+#define CONST_LRO_OC_FLAG_8_AGG_AGG1 0x1
+
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_8_TCP_TS_POS 1
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_8_TCP_TS_MASK 0x2u
+//! Constant NIL - not done
+#define CONST_LRO_OC_FLAG_8_TCP_TS_NIL 0x0
+//! Constant TS_D - Done TCP Timestamp check
+#define CONST_LRO_OC_FLAG_8_TCP_TS_TS_D 0x1
+
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_8_EXCPT_POS 2
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_8_EXCPT_MASK 0x4u
+//! Constant NIL - No exception
+#define CONST_LRO_OC_FLAG_8_EXCPT_NIL 0x0
+//! Constant EXP - any exception happened
+#define CONST_LRO_OC_FLAG_8_EXCPT_EXP 0x1
+
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_8_EXP_CASE_POS 3
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_8_EXP_CASE_MASK 0x78u
+//! Constant E0 - Flush based on GSWIP indication given
+#define CONST_LRO_OC_FLAG_8_EXP_CASE_E0 0x0
+//! Constant E1 - TCP check sum error
+#define CONST_LRO_OC_FLAG_8_EXP_CASE_E1 0x1
+//! Constant E2 - FID mismatch(not used)
+#define CONST_LRO_OC_FLAG_8_EXP_CASE_E2 0x2
+//! Constant E3 - TCP zero length packet
+#define CONST_LRO_OC_FLAG_8_EXP_CASE_E3 0x3
+//! Constant E4 - TCP Timestamp check error
+#define CONST_LRO_OC_FLAG_8_EXP_CASE_E4 0x4
+//! Constant E5 - Excessive length
+#define CONST_LRO_OC_FLAG_8_EXP_CASE_E5 0x5
+//! Constant E6 - session timeout
+#define CONST_LRO_OC_FLAG_8_EXP_CASE_E6 0x6
+//! Constant E7 - TCP sequence number out of order
+#define CONST_LRO_OC_FLAG_8_EXP_CASE_E7 0x7
+
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_8_SEG_NR_POS 10
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_8_SEG_NR_MASK 0x7C00u
+
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_8_TPL_POS 15
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_8_TPL_MASK 0x7FFF8000u
+
+//! @}
+
+//! \defgroup LRO_OC_OWNER_8 Register LRO_OC_OWNER_8 - Owner bit for the output context
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_OWNER_8 0x28B0
+
+//! Register Reset Value
+#define LRO_OC_OWNER_8_RST 0x00000000u
+
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_8_OWNER_POS 31
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_8_OWNER_MASK 0x80000000u
+//! Constant LRO - SW writes 1 to clear it to 0 .
+#define CONST_LRO_OC_OWNER_8_OWNER_LRO 0x0
+//! Constant SW - LRO HW writes '1' to give ownership to SW
+#define CONST_LRO_OC_OWNER_8_OWNER_SW 0x1
+
+//! @}
+
+//! \defgroup LRO_OC_FLAG_9 Register LRO_OC_FLAG_9 - LRO Output Context Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_FLAG_9 0x29A8
+
+//! Register Reset Value
+#define LRO_OC_FLAG_9_RST 0x00000000u
+
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_9_AGG_POS 0
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_9_AGG_MASK 0x1u
+//! Constant AGG0 - single packet session
+#define CONST_LRO_OC_FLAG_9_AGG_AGG0 0x0
+//! Constant AGG1 - Aggregation is performance; more than one segment
+#define CONST_LRO_OC_FLAG_9_AGG_AGG1 0x1
+
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_9_TCP_TS_POS 1
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_9_TCP_TS_MASK 0x2u
+//! Constant NIL - not done
+#define CONST_LRO_OC_FLAG_9_TCP_TS_NIL 0x0
+//! Constant TS_D - Done TCP Timestamp check
+#define CONST_LRO_OC_FLAG_9_TCP_TS_TS_D 0x1
+
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_9_EXCPT_POS 2
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_9_EXCPT_MASK 0x4u
+//! Constant NIL - No exception
+#define CONST_LRO_OC_FLAG_9_EXCPT_NIL 0x0
+//! Constant EXP - any exception happened
+#define CONST_LRO_OC_FLAG_9_EXCPT_EXP 0x1
+
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_9_EXP_CASE_POS 3
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_9_EXP_CASE_MASK 0x78u
+//! Constant E0 - Flush based on GSWIP indication given
+#define CONST_LRO_OC_FLAG_9_EXP_CASE_E0 0x0
+//! Constant E1 - TCP check sum error
+#define CONST_LRO_OC_FLAG_9_EXP_CASE_E1 0x1
+//! Constant E2 - FID mismatch(not used)
+#define CONST_LRO_OC_FLAG_9_EXP_CASE_E2 0x2
+//! Constant E3 - TCP zero length packet
+#define CONST_LRO_OC_FLAG_9_EXP_CASE_E3 0x3
+//! Constant E4 - TCP Timestamp check error
+#define CONST_LRO_OC_FLAG_9_EXP_CASE_E4 0x4
+//! Constant E5 - Excessive length
+#define CONST_LRO_OC_FLAG_9_EXP_CASE_E5 0x5
+//! Constant E6 - session timeout
+#define CONST_LRO_OC_FLAG_9_EXP_CASE_E6 0x6
+//! Constant E7 - TCP sequence number out of order
+#define CONST_LRO_OC_FLAG_9_EXP_CASE_E7 0x7
+
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_9_SEG_NR_POS 10
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_9_SEG_NR_MASK 0x7C00u
+
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_9_TPL_POS 15
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_9_TPL_MASK 0x7FFF8000u
+
+//! @}
+
+//! \defgroup LRO_OC_OWNER_9 Register LRO_OC_OWNER_9 - Owner bit for the output context
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_OWNER_9 0x29B0
+
+//! Register Reset Value
+#define LRO_OC_OWNER_9_RST 0x00000000u
+
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_9_OWNER_POS 31
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_9_OWNER_MASK 0x80000000u
+//! Constant LRO - SW writes 1 to clear it to 0 .
+#define CONST_LRO_OC_OWNER_9_OWNER_LRO 0x0
+//! Constant SW - LRO HW writes '1' to give ownership to SW
+#define CONST_LRO_OC_OWNER_9_OWNER_SW 0x1
+
+//! @}
+
+//! \defgroup LRO_OC_FLAG_10 Register LRO_OC_FLAG_10 - LRO Output Context Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_FLAG_10 0x2AA8
+
+//! Register Reset Value
+#define LRO_OC_FLAG_10_RST 0x00000000u
+
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_10_AGG_POS 0
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_10_AGG_MASK 0x1u
+//! Constant AGG0 - single packet session
+#define CONST_LRO_OC_FLAG_10_AGG_AGG0 0x0
+//! Constant AGG1 - Aggregation is performance; more than one segment
+#define CONST_LRO_OC_FLAG_10_AGG_AGG1 0x1
+
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_10_TCP_TS_POS 1
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_10_TCP_TS_MASK 0x2u
+//! Constant NIL - not done
+#define CONST_LRO_OC_FLAG_10_TCP_TS_NIL 0x0
+//! Constant TS_D - Done TCP Timestamp check
+#define CONST_LRO_OC_FLAG_10_TCP_TS_TS_D 0x1
+
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_10_EXCPT_POS 2
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_10_EXCPT_MASK 0x4u
+//! Constant NIL - No exception
+#define CONST_LRO_OC_FLAG_10_EXCPT_NIL 0x0
+//! Constant EXP - any exception happened
+#define CONST_LRO_OC_FLAG_10_EXCPT_EXP 0x1
+
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_10_EXP_CASE_POS 3
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_10_EXP_CASE_MASK 0x78u
+//! Constant E0 - Flush based on GSWIP indication given
+#define CONST_LRO_OC_FLAG_10_EXP_CASE_E0 0x0
+//! Constant E1 - TCP check sum error
+#define CONST_LRO_OC_FLAG_10_EXP_CASE_E1 0x1
+//! Constant E2 - FID mismatch(not used)
+#define CONST_LRO_OC_FLAG_10_EXP_CASE_E2 0x2
+//! Constant E3 - TCP zero length packet
+#define CONST_LRO_OC_FLAG_10_EXP_CASE_E3 0x3
+//! Constant E4 - TCP Timestamp check error
+#define CONST_LRO_OC_FLAG_10_EXP_CASE_E4 0x4
+//! Constant E5 - Excessive length
+#define CONST_LRO_OC_FLAG_10_EXP_CASE_E5 0x5
+//! Constant E6 - session timeout
+#define CONST_LRO_OC_FLAG_10_EXP_CASE_E6 0x6
+//! Constant E7 - TCP sequence number out of order
+#define CONST_LRO_OC_FLAG_10_EXP_CASE_E7 0x7
+
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_10_SEG_NR_POS 10
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_10_SEG_NR_MASK 0x7C00u
+
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_10_TPL_POS 15
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_10_TPL_MASK 0x7FFF8000u
+
+//! @}
+
+//! \defgroup LRO_OC_OWNER_10 Register LRO_OC_OWNER_10 - Owner bit for the output context
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_OWNER_10 0x2AB0
+
+//! Register Reset Value
+#define LRO_OC_OWNER_10_RST 0x00000000u
+
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_10_OWNER_POS 31
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_10_OWNER_MASK 0x80000000u
+//! Constant LRO - SW writes 1 to clear it to 0 .
+#define CONST_LRO_OC_OWNER_10_OWNER_LRO 0x0
+//! Constant SW - LRO HW writes '1' to give ownership to SW
+#define CONST_LRO_OC_OWNER_10_OWNER_SW 0x1
+
+//! @}
+
+//! \defgroup LRO_OC_FLAG_11 Register LRO_OC_FLAG_11 - LRO Output Context Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_FLAG_11 0x2BA8
+
+//! Register Reset Value
+#define LRO_OC_FLAG_11_RST 0x00000000u
+
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_11_AGG_POS 0
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_11_AGG_MASK 0x1u
+//! Constant AGG0 - single packet session
+#define CONST_LRO_OC_FLAG_11_AGG_AGG0 0x0
+//! Constant AGG1 - Aggregation is performance; more than one segment
+#define CONST_LRO_OC_FLAG_11_AGG_AGG1 0x1
+
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_11_TCP_TS_POS 1
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_11_TCP_TS_MASK 0x2u
+//! Constant NIL - not done
+#define CONST_LRO_OC_FLAG_11_TCP_TS_NIL 0x0
+//! Constant TS_D - Done TCP Timestamp check
+#define CONST_LRO_OC_FLAG_11_TCP_TS_TS_D 0x1
+
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_11_EXCPT_POS 2
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_11_EXCPT_MASK 0x4u
+//! Constant NIL - No exception
+#define CONST_LRO_OC_FLAG_11_EXCPT_NIL 0x0
+//! Constant EXP - any exception happened
+#define CONST_LRO_OC_FLAG_11_EXCPT_EXP 0x1
+
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_11_EXP_CASE_POS 3
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_11_EXP_CASE_MASK 0x78u
+//! Constant E0 - Flush based on GSWIP indication given
+#define CONST_LRO_OC_FLAG_11_EXP_CASE_E0 0x0
+//! Constant E1 - TCP check sum error
+#define CONST_LRO_OC_FLAG_11_EXP_CASE_E1 0x1
+//! Constant E2 - FID mismatch(not used)
+#define CONST_LRO_OC_FLAG_11_EXP_CASE_E2 0x2
+//! Constant E3 - TCP zero length packet
+#define CONST_LRO_OC_FLAG_11_EXP_CASE_E3 0x3
+//! Constant E4 - TCP Timestamp check error
+#define CONST_LRO_OC_FLAG_11_EXP_CASE_E4 0x4
+//! Constant E5 - Excessive length
+#define CONST_LRO_OC_FLAG_11_EXP_CASE_E5 0x5
+//! Constant E6 - session timeout
+#define CONST_LRO_OC_FLAG_11_EXP_CASE_E6 0x6
+//! Constant E7 - TCP sequence number out of order
+#define CONST_LRO_OC_FLAG_11_EXP_CASE_E7 0x7
+
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_11_SEG_NR_POS 10
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_11_SEG_NR_MASK 0x7C00u
+
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_11_TPL_POS 15
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_11_TPL_MASK 0x7FFF8000u
+
+//! @}
+
+//! \defgroup LRO_OC_OWNER_11 Register LRO_OC_OWNER_11 - Owner bit for the output context
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_OWNER_11 0x2BB0
+
+//! Register Reset Value
+#define LRO_OC_OWNER_11_RST 0x00000000u
+
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_11_OWNER_POS 31
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_11_OWNER_MASK 0x80000000u
+//! Constant LRO - SW writes 1 to clear it to 0 .
+#define CONST_LRO_OC_OWNER_11_OWNER_LRO 0x0
+//! Constant SW - LRO HW writes '1' to give ownership to SW
+#define CONST_LRO_OC_OWNER_11_OWNER_SW 0x1
+
+//! @}
+
+//! \defgroup LRO_OC_FLAG_12 Register LRO_OC_FLAG_12 - LRO Output Context Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_FLAG_12 0x2CA8
+
+//! Register Reset Value
+#define LRO_OC_FLAG_12_RST 0x00000000u
+
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_12_AGG_POS 0
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_12_AGG_MASK 0x1u
+//! Constant AGG0 - single packet session
+#define CONST_LRO_OC_FLAG_12_AGG_AGG0 0x0
+//! Constant AGG1 - Aggregation is performance; more than one segment
+#define CONST_LRO_OC_FLAG_12_AGG_AGG1 0x1
+
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_12_TCP_TS_POS 1
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_12_TCP_TS_MASK 0x2u
+//! Constant NIL - not done
+#define CONST_LRO_OC_FLAG_12_TCP_TS_NIL 0x0
+//! Constant TS_D - Done TCP Timestamp check
+#define CONST_LRO_OC_FLAG_12_TCP_TS_TS_D 0x1
+
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_12_EXCPT_POS 2
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_12_EXCPT_MASK 0x4u
+//! Constant NIL - No exception
+#define CONST_LRO_OC_FLAG_12_EXCPT_NIL 0x0
+//! Constant EXP - any exception happened
+#define CONST_LRO_OC_FLAG_12_EXCPT_EXP 0x1
+
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_12_EXP_CASE_POS 3
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_12_EXP_CASE_MASK 0x78u
+//! Constant E0 - Flush based on GSWIP indication given
+#define CONST_LRO_OC_FLAG_12_EXP_CASE_E0 0x0
+//! Constant E1 - TCP check sum error
+#define CONST_LRO_OC_FLAG_12_EXP_CASE_E1 0x1
+//! Constant E2 - FID mismatch(not used)
+#define CONST_LRO_OC_FLAG_12_EXP_CASE_E2 0x2
+//! Constant E3 - TCP zero length packet
+#define CONST_LRO_OC_FLAG_12_EXP_CASE_E3 0x3
+//! Constant E4 - TCP Timestamp check error
+#define CONST_LRO_OC_FLAG_12_EXP_CASE_E4 0x4
+//! Constant E5 - Excessive length
+#define CONST_LRO_OC_FLAG_12_EXP_CASE_E5 0x5
+//! Constant E6 - session timeout
+#define CONST_LRO_OC_FLAG_12_EXP_CASE_E6 0x6
+//! Constant E7 - TCP sequence number out of order
+#define CONST_LRO_OC_FLAG_12_EXP_CASE_E7 0x7
+
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_12_SEG_NR_POS 10
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_12_SEG_NR_MASK 0x7C00u
+
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_12_TPL_POS 15
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_12_TPL_MASK 0x7FFF8000u
+
+//! @}
+
+//! \defgroup LRO_OC_OWNER_12 Register LRO_OC_OWNER_12 - Owner bit for the output context
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_OWNER_12 0x2CB0
+
+//! Register Reset Value
+#define LRO_OC_OWNER_12_RST 0x00000000u
+
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_12_OWNER_POS 31
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_12_OWNER_MASK 0x80000000u
+//! Constant LRO - SW writes 1 to clear it to 0 .
+#define CONST_LRO_OC_OWNER_12_OWNER_LRO 0x0
+//! Constant SW - LRO HW writes '1' to give ownership to SW
+#define CONST_LRO_OC_OWNER_12_OWNER_SW 0x1
+
+//! @}
+
+//! \defgroup LRO_OC_FLAG_13 Register LRO_OC_FLAG_13 - LRO Output Context Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_FLAG_13 0x2DA8
+
+//! Register Reset Value
+#define LRO_OC_FLAG_13_RST 0x00000000u
+
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_13_AGG_POS 0
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_13_AGG_MASK 0x1u
+//! Constant AGG0 - single packet session
+#define CONST_LRO_OC_FLAG_13_AGG_AGG0 0x0
+//! Constant AGG1 - Aggregation is performance; more than one segment
+#define CONST_LRO_OC_FLAG_13_AGG_AGG1 0x1
+
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_13_TCP_TS_POS 1
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_13_TCP_TS_MASK 0x2u
+//! Constant NIL - not done
+#define CONST_LRO_OC_FLAG_13_TCP_TS_NIL 0x0
+//! Constant TS_D - Done TCP Timestamp check
+#define CONST_LRO_OC_FLAG_13_TCP_TS_TS_D 0x1
+
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_13_EXCPT_POS 2
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_13_EXCPT_MASK 0x4u
+//! Constant NIL - No exception
+#define CONST_LRO_OC_FLAG_13_EXCPT_NIL 0x0
+//! Constant EXP - any exception happened
+#define CONST_LRO_OC_FLAG_13_EXCPT_EXP 0x1
+
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_13_EXP_CASE_POS 3
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_13_EXP_CASE_MASK 0x78u
+//! Constant E0 - Flush based on GSWIP indication given
+#define CONST_LRO_OC_FLAG_13_EXP_CASE_E0 0x0
+//! Constant E1 - TCP check sum error
+#define CONST_LRO_OC_FLAG_13_EXP_CASE_E1 0x1
+//! Constant E2 - FID mismatch(not used)
+#define CONST_LRO_OC_FLAG_13_EXP_CASE_E2 0x2
+//! Constant E3 - TCP zero length packet
+#define CONST_LRO_OC_FLAG_13_EXP_CASE_E3 0x3
+//! Constant E4 - TCP Timestamp check error
+#define CONST_LRO_OC_FLAG_13_EXP_CASE_E4 0x4
+//! Constant E5 - Excessive length
+#define CONST_LRO_OC_FLAG_13_EXP_CASE_E5 0x5
+//! Constant E6 - session timeout
+#define CONST_LRO_OC_FLAG_13_EXP_CASE_E6 0x6
+//! Constant E7 - TCP sequence number out of order
+#define CONST_LRO_OC_FLAG_13_EXP_CASE_E7 0x7
+
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_13_SEG_NR_POS 10
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_13_SEG_NR_MASK 0x7C00u
+
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_13_TPL_POS 15
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_13_TPL_MASK 0x7FFF8000u
+
+//! @}
+
+//! \defgroup LRO_OC_OWNER_13 Register LRO_OC_OWNER_13 - Owner bit for the output context
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_OWNER_13 0x2DB0
+
+//! Register Reset Value
+#define LRO_OC_OWNER_13_RST 0x00000000u
+
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_13_OWNER_POS 31
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_13_OWNER_MASK 0x80000000u
+//! Constant LRO - SW writes 1 to clear it to 0 .
+#define CONST_LRO_OC_OWNER_13_OWNER_LRO 0x0
+//! Constant SW - LRO HW writes '1' to give ownership to SW
+#define CONST_LRO_OC_OWNER_13_OWNER_SW 0x1
+
+//! @}
+
+//! \defgroup LRO_OC_FLAG_14 Register LRO_OC_FLAG_14 - LRO Output Context Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_FLAG_14 0x2EA8
+
+//! Register Reset Value
+#define LRO_OC_FLAG_14_RST 0x00000000u
+
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_14_AGG_POS 0
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_14_AGG_MASK 0x1u
+//! Constant AGG0 - single packet session
+#define CONST_LRO_OC_FLAG_14_AGG_AGG0 0x0
+//! Constant AGG1 - Aggregation is performance; more than one segment
+#define CONST_LRO_OC_FLAG_14_AGG_AGG1 0x1
+
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_14_TCP_TS_POS 1
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_14_TCP_TS_MASK 0x2u
+//! Constant NIL - not done
+#define CONST_LRO_OC_FLAG_14_TCP_TS_NIL 0x0
+//! Constant TS_D - Done TCP Timestamp check
+#define CONST_LRO_OC_FLAG_14_TCP_TS_TS_D 0x1
+
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_14_EXCPT_POS 2
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_14_EXCPT_MASK 0x4u
+//! Constant NIL - No exception
+#define CONST_LRO_OC_FLAG_14_EXCPT_NIL 0x0
+//! Constant EXP - any exception happened
+#define CONST_LRO_OC_FLAG_14_EXCPT_EXP 0x1
+
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_14_EXP_CASE_POS 3
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_14_EXP_CASE_MASK 0x78u
+//! Constant E0 - Flush based on GSWIP indication given
+#define CONST_LRO_OC_FLAG_14_EXP_CASE_E0 0x0
+//! Constant E1 - TCP check sum error
+#define CONST_LRO_OC_FLAG_14_EXP_CASE_E1 0x1
+//! Constant E2 - FID mismatch(not used)
+#define CONST_LRO_OC_FLAG_14_EXP_CASE_E2 0x2
+//! Constant E3 - TCP zero length packet
+#define CONST_LRO_OC_FLAG_14_EXP_CASE_E3 0x3
+//! Constant E4 - TCP Timestamp check error
+#define CONST_LRO_OC_FLAG_14_EXP_CASE_E4 0x4
+//! Constant E5 - Excessive length
+#define CONST_LRO_OC_FLAG_14_EXP_CASE_E5 0x5
+//! Constant E6 - session timeout
+#define CONST_LRO_OC_FLAG_14_EXP_CASE_E6 0x6
+//! Constant E7 - TCP sequence number out of order
+#define CONST_LRO_OC_FLAG_14_EXP_CASE_E7 0x7
+
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_14_SEG_NR_POS 10
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_14_SEG_NR_MASK 0x7C00u
+
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_14_TPL_POS 15
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_14_TPL_MASK 0x7FFF8000u
+
+//! @}
+
+//! \defgroup LRO_OC_OWNER_14 Register LRO_OC_OWNER_14 - Owner bit for the output context
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_OWNER_14 0x2EB0
+
+//! Register Reset Value
+#define LRO_OC_OWNER_14_RST 0x00000000u
+
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_14_OWNER_POS 31
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_14_OWNER_MASK 0x80000000u
+//! Constant LRO - SW writes 1 to clear it to 0 .
+#define CONST_LRO_OC_OWNER_14_OWNER_LRO 0x0
+//! Constant SW - LRO HW writes '1' to give ownership to SW
+#define CONST_LRO_OC_OWNER_14_OWNER_SW 0x1
+
+//! @}
+
+//! \defgroup LRO_OC_FLAG_15 Register LRO_OC_FLAG_15 - LRO Output Context Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_FLAG_15 0x2FA8
+
+//! Register Reset Value
+#define LRO_OC_FLAG_15_RST 0x00000000u
+
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_15_AGG_POS 0
+//! Field AGG - Aggregation flag
+#define LRO_OC_FLAG_15_AGG_MASK 0x1u
+//! Constant AGG0 - single packet session
+#define CONST_LRO_OC_FLAG_15_AGG_AGG0 0x0
+//! Constant AGG1 - Aggregation is performance; more than one segment
+#define CONST_LRO_OC_FLAG_15_AGG_AGG1 0x1
+
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_15_TCP_TS_POS 1
+//! Field TCP_TS - TCP Timestamp Option check performed indication
+#define LRO_OC_FLAG_15_TCP_TS_MASK 0x2u
+//! Constant NIL - not done
+#define CONST_LRO_OC_FLAG_15_TCP_TS_NIL 0x0
+//! Constant TS_D - Done TCP Timestamp check
+#define CONST_LRO_OC_FLAG_15_TCP_TS_TS_D 0x1
+
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_15_EXCPT_POS 2
+//! Field EXCPT - LRO indication of any exception is processed
+#define LRO_OC_FLAG_15_EXCPT_MASK 0x4u
+//! Constant NIL - No exception
+#define CONST_LRO_OC_FLAG_15_EXCPT_NIL 0x0
+//! Constant EXP - any exception happened
+#define CONST_LRO_OC_FLAG_15_EXCPT_EXP 0x1
+
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_15_EXP_CASE_POS 3
+//! Field EXP_CASE - Exception Reason list
+#define LRO_OC_FLAG_15_EXP_CASE_MASK 0x78u
+//! Constant E0 - Flush based on GSWIP indication given
+#define CONST_LRO_OC_FLAG_15_EXP_CASE_E0 0x0
+//! Constant E1 - TCP check sum error
+#define CONST_LRO_OC_FLAG_15_EXP_CASE_E1 0x1
+//! Constant E2 - FID mismatch(not used)
+#define CONST_LRO_OC_FLAG_15_EXP_CASE_E2 0x2
+//! Constant E3 - TCP zero length packet
+#define CONST_LRO_OC_FLAG_15_EXP_CASE_E3 0x3
+//! Constant E4 - TCP Timestamp check error
+#define CONST_LRO_OC_FLAG_15_EXP_CASE_E4 0x4
+//! Constant E5 - Excessive length
+#define CONST_LRO_OC_FLAG_15_EXP_CASE_E5 0x5
+//! Constant E6 - session timeout
+#define CONST_LRO_OC_FLAG_15_EXP_CASE_E6 0x6
+//! Constant E7 - TCP sequence number out of order
+#define CONST_LRO_OC_FLAG_15_EXP_CASE_E7 0x7
+
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_15_SEG_NR_POS 10
+//! Field SEG_NR - Number of segments collected
+#define LRO_OC_FLAG_15_SEG_NR_MASK 0x7C00u
+
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_15_TPL_POS 15
+//! Field TPL - Length of all segments collected
+#define LRO_OC_FLAG_15_TPL_MASK 0x7FFF8000u
+
+//! @}
+
+//! \defgroup LRO_OC_OWNER_15 Register LRO_OC_OWNER_15 - Owner bit for the output context
+//! @{
+
+//! Register Offset (relative)
+#define LRO_OC_OWNER_15 0x2FB0
+
+//! Register Reset Value
+#define LRO_OC_OWNER_15_RST 0x00000000u
+
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_15_OWNER_POS 31
+//! Field OWNER - Owner ship of the context
+#define LRO_OC_OWNER_15_OWNER_MASK 0x80000000u
+//! Constant LRO - SW writes 1 to clear it to 0 .
+#define CONST_LRO_OC_OWNER_15_OWNER_LRO 0x0
+//! Constant SW - LRO HW writes '1' to give ownership to SW
+#define CONST_LRO_OC_OWNER_15_OWNER_SW 0x1
+
+//! @}
+
+//! \defgroup LRO_EXP_EFLAG Register LRO_EXP_EFLAG - LRO Exception Entry Flag
+//! @{
+
+//! Register Offset (relative)
+#define LRO_EXP_EFLAG 0x4100
+
+//! Register Reset Value
+#define LRO_EXP_EFLAG_RST 0x00000000u
+
+//! Field EXP - one entry per LRO command port for exception entry
+#define LRO_EXP_EFLAG_EXP_POS 0
+//! Field EXP - one entry per LRO command port for exception entry
+#define LRO_EXP_EFLAG_EXP_MASK 0xFFFFu
+
+//! Field UNMATCH - unmatched entry flag
+#define LRO_EXP_EFLAG_UNMATCH_POS 16
+//! Field UNMATCH - unmatched entry flag
+#define LRO_EXP_EFLAG_UNMATCH_MASK 0xFF0000u
+
+//! @}
+
+//! @}
+
+#endif
