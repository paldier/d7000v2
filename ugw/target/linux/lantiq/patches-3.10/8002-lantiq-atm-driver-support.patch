# HG changeset patch
# Parent 9a37572c070f73e2a3a088e6a2e3b7193eeaae2c

diff --git a/drivers/atm/Kconfig b/drivers/atm/Kconfig
--- a/drivers/atm/Kconfig
+++ b/drivers/atm/Kconfig
@@ -398,4 +398,6 @@ config ATM_SOLOS
 	help
 	  Support for the Solos multiport ADSL2+ card.
 
+source "drivers/atm/lantiq/Kconfig"
+
 endif # ATM
diff --git a/drivers/atm/Makefile b/drivers/atm/Makefile
--- a/drivers/atm/Makefile
+++ b/drivers/atm/Makefile
@@ -33,3 +33,4 @@ obj-$(CONFIG_ATM_HE)		+= he.o
 ifeq ($(CONFIG_ATM_HE_USE_SUNI),y)
   obj-$(CONFIG_ATM_HE)		+= suni.o
 endif
+obj-$(CONFIG_LTQ_ATM)		+= lantiq/
diff --git a/drivers/atm/lantiq/Kconfig b/drivers/atm/lantiq/Kconfig
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/Kconfig
@@ -0,0 +1,33 @@
+config LTQ_ATM
+	tristate "Lantiq ATM driver"
+	depends on LANTIQ && ATM
+	default n
+	---help---
+	Use this exclusively with PTM mode or Acceleration Package
+
+config LTQ_ATM_TASKLET
+	bool "Support Tasklet"
+	depends on LTQ_ATM
+	default y
+	---help---
+	Use tasklet handle incoming packet. Impact on ATM RX traffic performance.
+
+config LTQ_ATM_RETX
+	bool "Support ReTX"
+	depends on LTQ_ATM && (LTQ_ATM_XRX300 || LTQ_ATM_XRX200)
+	default n
+	---help---
+	Support Retransmission.
+
+choice
+   prompt "ATM Platform Selection"
+   default LTQ_ATM_XRX300
+
+   config LTQ_ATM_XRX200
+   depends on LTQ_ATM
+   bool "xRX200"
+
+   config LTQ_ATM_XRX300
+   depends on LTQ_ATM
+   bool "xRX300"
+endchoice
diff --git a/drivers/atm/lantiq/Makefile b/drivers/atm/lantiq/Makefile
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/Makefile
@@ -0,0 +1,10 @@
+
+obj-$(CONFIG_LTQ_ATM) = ltqmips_atm.o
+
+ltqmips_atm-objs   := ltqmips_atm_core.o
+ifeq ($(CONFIG_LTQ_ATM_XRX200),y)
+  ltqmips_atm-objs += ltqmips_atm_vr9.o
+endif
+ifeq ($(CONFIG_LTQ_ATM_XRX300),y)
+  ltqmips_atm-objs += ltqmips_atm_ar9.o
+endif
diff --git a/drivers/atm/lantiq/ltq_atm.h b/drivers/atm/lantiq/ltq_atm.h
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/ltq_atm.h
@@ -0,0 +1,196 @@
+/******************************************************************************
+**
+** FILE NAME    : ifx_atm.h
+** PROJECT      : UEIP
+** MODULES      : ATM
+**
+** DATE         : 17 Jun 2009
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : Global ATM driver header file
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 07 JUL 2009  Xu Liang        Init Version
+*******************************************************************************/
+
+#ifndef IFX_ATM_H
+#define IFX_ATM_H
+
+
+
+/*!
+  \defgroup IFX_ATM UEIP Project - ATM driver module
+  \brief UEIP Project - ATM driver module, support Danube, Amazon-SE, AR9, VR9.
+ */
+
+/*!
+  \defgroup IFX_ATM_IOCTL IOCTL Commands
+  \ingroup IFX_ATM
+  \brief IOCTL Commands used by user application.
+ */
+
+/*!
+  \defgroup IFX_ATM_STRUCT Structures
+  \ingroup IFX_ATM
+  \brief Structures used by user application.
+ */
+
+/*!
+  \file ifx_atm.h
+  \ingroup IFX_ATM
+  \brief ATM driver header file
+ */
+
+
+
+/*
+ * ####################################
+ *              Definition
+ * ####################################
+ */
+
+/*!
+  \addtogroup IFX_ATM_STRUCT
+ */
+/*@{*/
+
+/*
+ *  ATM MIB
+ */
+
+/*!
+  \struct atm_cell_ifEntry_t
+  \brief Structure used for Cell Level MIB Counters.
+
+  User application use this structure to call IOCTL command "PPE_ATM_MIB_CELL".
+ */
+typedef struct {
+	__u32	ifHCInOctets_h;     /*!< byte counter of ingress cells (upper 32 bits, total 64 bits)   */
+	__u32	ifHCInOctets_l;     /*!< byte counter of ingress cells (lower 32 bits, total 64 bits)   */
+	__u32	ifHCOutOctets_h;    /*!< byte counter of egress cells (upper 32 bits, total 64 bits)    */
+	__u32	ifHCOutOctets_l;    /*!< byte counter of egress cells (lower 32 bits, total 64 bits)    */
+	__u32	ifInErrors;         /*!< counter of error ingress cells     */
+	__u32	ifInUnknownProtos;  /*!< counter of unknown ingress cells   */
+	__u32	ifOutErrors;        /*!< counter of error egress cells      */
+} atm_cell_ifEntry_t;
+
+/*!
+  \struct atm_aal5_ifEntry_t
+  \brief Structure used for AAL5 Frame Level MIB Counters.
+
+  User application use this structure to call IOCTL command "PPE_ATM_MIB_AAL5".
+ */
+typedef struct {
+	__u32	ifHCInOctets_h;     /*!< byte counter of ingress packets (upper 32 bits, total 64 bits) */
+	__u32	ifHCInOctets_l;     /*!< byte counter of ingress packets (lower 32 bits, total 64 bits) */
+	__u32	ifHCOutOctets_h;    /*!< byte counter of egress packets (upper 32 bits, total 64 bits)  */
+	__u32	ifHCOutOctets_l;    /*!< byte counter of egress packets (lower 32 bits, total 64 bits)  */
+	__u32	ifInUcastPkts;      /*!< counter of ingress packets         */
+	__u32	ifOutUcastPkts;     /*!< counter of egress packets          */
+	__u32	ifInErrors;         /*!< counter of error ingress packets   */
+	__u32	ifInDiscards;       /*!< counter of dropped ingress packets */
+	__u32	ifOutErros;         /*!< counter of error egress packets    */
+	__u32	ifOutDiscards;      /*!< counter of dropped egress packets  */
+} atm_aal5_ifEntry_t;
+
+/*!
+  \struct atm_aal5_vcc_t
+  \brief Structure used for per PVC AAL5 Frame Level MIB Counters.
+
+  This structure is a part of structure "atm_aal5_vcc_x_t".
+ */
+typedef struct {
+	__u32	aal5VccCrcErrors;       /*!< counter of ingress packets with CRC error  */
+	__u32	aal5VccSarTimeOuts;     /*!< counter of ingress packets with Re-assemble timeout    */  //no timer support yet
+	__u32	aal5VccOverSizedSDUs;   /*!< counter of oversized ingress packets       */
+} atm_aal5_vcc_t;
+
+/*!
+  \struct atm_aal5_vcc_x_t
+  \brief Structure used for per PVC AAL5 Frame Level MIB Counters.
+
+  User application use this structure to call IOCTL command "PPE_ATM_MIB_VCC".
+ */
+typedef struct {
+	int             vpi;        /*!< VPI of the VCC to get MIB counters */
+	int             vci;        /*!< VCI of the VCC to get MIB counters */
+	atm_aal5_vcc_t  mib_vcc;    /*!< structure to get MIB counters      */
+} atm_aal5_vcc_x_t;
+
+/*@}*/
+
+
+
+/*
+ * ####################################
+ *                IOCTL
+ * ####################################
+ */
+
+/*!
+  \addtogroup IFX_ATM_IOCTL
+ */
+/*@{*/
+
+/*
+ *  ioctl Command
+ */
+/*!
+  \brief ATM IOCTL Magic Number
+ */
+#define PPE_ATM_IOC_MAGIC       'o'
+/*!
+  \brief ATM IOCTL Command - Get Cell Level MIB Counters
+
+   This command is obsolete. User can get cell level MIB from DSL API.
+   This command uses structure "atm_cell_ifEntry_t" as parameter for output of MIB counters.
+ */
+#define PPE_ATM_MIB_CELL        _IOW(PPE_ATM_IOC_MAGIC,  0, atm_cell_ifEntry_t)
+/*!
+  \brief ATM IOCTL Command - Get AAL5 Level MIB Counters
+
+   Get AAL5 packet counters.
+   This command uses structure "atm_aal5_ifEntry_t" as parameter for output of MIB counters.
+ */
+#define PPE_ATM_MIB_AAL5        _IOW(PPE_ATM_IOC_MAGIC,  1, atm_aal5_ifEntry_t)
+/*!
+  \brief ATM IOCTL Command - Get Per PVC MIB Counters
+
+   Get AAL5 packet counters for each PVC.
+   This command uses structure "atm_aal5_vcc_x_t" as parameter for input of VPI/VCI information and output of MIB counters.
+ */
+#define PPE_ATM_MIB_VCC         _IOWR(PPE_ATM_IOC_MAGIC, 2, atm_aal5_vcc_x_t)
+/*!
+  \brief Total Number of ATM IOCTL Commands
+ */
+#define PPE_ATM_IOC_MAXNR       3
+
+/*@}*/
+
+
+
+/*
+ * ####################################
+ *                 API
+ * ####################################
+ */
+
+#ifdef __KERNEL__
+struct port_cell_info {
+    unsigned int    port_num;
+    unsigned int    tx_link_rate[2];
+};
+#endif
+
+
+
+#endif  //  IFX_ATM_H
+
diff --git a/drivers/atm/lantiq/ltqmips_atm_ar9.c b/drivers/atm/lantiq/ltqmips_atm_ar9.c
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/ltqmips_atm_ar9.c
@@ -0,0 +1,336 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_atm_ar9.c
+** PROJECT      : UEIP
+** MODULES      : ATM
+**
+** DATE         : 7 Jul 2009
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : ATM driver common source file (core functions)
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 07 JUL 2009  Xu Liang        Init Version
+*******************************************************************************/
+
+
+
+/*
+ * ####################################
+ *              Head File
+ * ####################################
+ */
+
+/*
+ *  Common Head File
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <asm/delay.h>
+#include <asm/irq.h>
+
+#include <linux/clk.h>
+#include <lantiq_soc.h>
+
+/*
+ *  Chip Specific Head File
+ */
+#include "ltqmips_atm_core.h"
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+  #include "ltqmips_atm_fw_ar9_retx.h"
+#else
+  #include "ltqmips_atm_fw_ar9.h"
+#endif
+
+
+/*
+ * ####################################
+ *              Definition
+ * ####################################
+ */
+
+/*
+ *  EMA Settings
+ */
+#define EMA_CMD_BUF_LEN      0x0040
+#define EMA_CMD_BASE_ADDR    (0x00003B80 << 2)
+#define EMA_DATA_BUF_LEN     0x0100
+#define EMA_DATA_BASE_ADDR   (0x00003C00 << 2)
+#define EMA_WRITE_BURST      0x2
+#define EMA_READ_BURST       0x2
+
+
+/*
+ * ####################################
+ *             Declaration
+ * ####################################
+ */
+
+/*
+ *  Hardware Init/Uninit Functions
+ */
+static inline void init_pmu(void);
+static inline void uninit_pmu(void);
+static inline void reset_ppe(void);
+static inline void init_ema(void);
+static inline void init_mailbox(void);
+static inline void init_atm_tc(void);
+static inline void clear_share_buffer(void);
+
+
+/*
+ * ####################################
+ *            Local Variable
+ * ####################################
+ */
+
+
+
+/*
+ * ####################################
+ *            Local Function
+ * ####################################
+ */
+
+static inline void init_pmu(void)
+{
+/*
+    (unsigned long *)0xBF10201C &= ~((1 << 15) | (1 << 13) | (1 << 9));
+    PPE_TOP_PMU_SETUP(IFX_PMU_ENABLE);
+    PPE_SLL01_PMU_SETUP(IFX_PMU_ENABLE);
+    PPE_TC_PMU_SETUP(IFX_PMU_ENABLE);
+    PPE_EMA_PMU_SETUP(IFX_PMU_ENABLE);
+    PPE_QSB_PMU_SETUP(IFX_PMU_ENABLE);
+    PPE_TPE_PMU_SETUP(IFX_PMU_ENABLE);
+    DSL_DFE_PMU_SETUP(IFX_PMU_ENABLE);
+*/
+}
+
+#ifdef CONFIG_LTQ_ATM_XRX300
+static inline void set_ppe_250(void)
+{
+	unsigned int clk_fsr;
+
+	clk_fsr = ltq_cgu_r32(0x0010);
+	clk_fsr = (clk_fsr & ~(0x70000)) | (0x10000);
+	ltq_cgu_w32(clk_fsr, 0x0010);
+	printk("set CGU CLKFSR: 0x%x\n", ltq_cgu_r32(0x0010));
+}
+#endif
+
+static inline void uninit_pmu(void)
+{
+/*
+    PPE_SLL01_PMU_SETUP(IFX_PMU_DISABLE);
+    PPE_TC_PMU_SETUP(IFX_PMU_DISABLE);
+    PPE_EMA_PMU_SETUP(IFX_PMU_DISABLE);
+    PPE_QSB_PMU_SETUP(IFX_PMU_DISABLE);
+    PPE_TPE_PMU_SETUP(IFX_PMU_DISABLE);
+    DSL_DFE_PMU_SETUP(IFX_PMU_DISABLE);
+    //PPE_TOP_PMU_SETUP(IFX_PMU_DISABLE);
+*/
+}
+
+static inline void reset_ppe(void)
+{
+#ifdef MODULE
+    //  reset PPE
+    ifx_rcu_rst(IFX_RCU_DOMAIN_PPE, IFX_RCU_MODULE_ATM);
+#endif
+}
+
+static inline void init_ema(void)
+{
+    IFX_REG_W32((EMA_CMD_BUF_LEN << 16) | (EMA_CMD_BASE_ADDR >> 2), EMA_CMDCFG);
+    IFX_REG_W32((EMA_DATA_BUF_LEN << 16) | (EMA_DATA_BASE_ADDR >> 2), EMA_DATACFG);
+    IFX_REG_W32(0x000000FF, EMA_IER);
+    IFX_REG_W32(EMA_READ_BURST | (EMA_WRITE_BURST << 2), EMA_CFG);
+}
+
+static inline void init_mailbox(void)
+{
+    IFX_REG_W32(0xFFFFFFFF, MBOX_IGU1_ISRC);
+    IFX_REG_W32(0x00000000, MBOX_IGU1_IER);
+    IFX_REG_W32(0xFFFFFFFF, MBOX_IGU3_ISRC);
+    IFX_REG_W32(0x00000000, MBOX_IGU3_IER);
+}
+
+static inline void init_atm_tc(void)
+{
+}
+
+static inline void clear_share_buffer(void)
+{
+    volatile u32 *p = SB_RAM0_ADDR(0);
+    unsigned int i;
+
+    for ( i = 0; i < SB_RAM0_DWLEN + SB_RAM1_DWLEN + SB_RAM2_DWLEN + SB_RAM3_DWLEN + SB_RAM4_DWLEN; i++ )
+        IFX_REG_W32(0, p++);
+}
+
+/*
+ *  Description:
+ *    Download PPE firmware binary code.
+ *  Input:
+ *    src       --- u32 *, binary code buffer
+ *    dword_len --- unsigned int, binary code length in DWORD (32-bit)
+ *  Output:
+ *    int       --- 0:    Success
+ *                  else:           Error Code
+ */
+static inline int pp32_download_code(u32 *code_src, unsigned int code_dword_len, u32 *data_src, unsigned int data_dword_len)
+{
+    volatile u32 *dest;
+
+    if ( code_src == 0 || ((unsigned long)code_src & 0x03) != 0
+        || data_src == 0 || ((unsigned long)data_src & 0x03) != 0 )
+        return -EINVAL;
+
+    if ( code_dword_len <= CDM_CODE_MEMORYn_DWLEN(0) )
+        IFX_REG_W32(0x00, CDM_CFG);
+    else
+        IFX_REG_W32(0x04, CDM_CFG);
+
+    /*  copy code   */
+    dest = CDM_CODE_MEMORY(0, 0);
+    while ( code_dword_len-- > 0 )
+        IFX_REG_W32(*code_src++, dest++);
+
+    /*  copy data   */
+    dest = CDM_DATA_MEMORY(0, 0);
+    while ( data_dword_len-- > 0 )
+        IFX_REG_W32(*data_src++, dest++);
+
+    return 0;
+}
+
+
+
+/*
+ * ####################################
+ *           Global Function
+ * ####################################
+ */
+
+extern void ifx_atm_get_fw_ver(unsigned int *major, unsigned int *minor)
+{
+    ASSERT(major != NULL, "pointer is NULL");
+    ASSERT(minor != NULL, "pointer is NULL");
+
+#if (defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX) || defined(VER_IN_FIRMWARE)
+    *major = FW_VER_ID->major;
+    *minor = FW_VER_ID->minor;
+#else
+    *major = ATM_FW_VER_MAJOR;
+    *minor = ATM_FW_VER_MINOR;
+#endif
+}
+
+void ifx_atm_init_chip(void)
+{
+    init_pmu();
+
+#ifdef CONFIG_LTQ_ATM_XRX300
+	set_ppe_250();
+#endif
+
+    reset_ppe();
+
+    init_ema();
+
+    init_mailbox();
+
+    init_atm_tc();
+
+    clear_share_buffer();
+}
+
+void ifx_atm_uninit_chip(void)
+{
+    uninit_pmu();
+}
+
+/*
+ *  Description:
+ *    Initialize and start up PP32.
+ *  Input:
+ *    none
+ *  Output:
+ *    int  --- 0: Success
+ *             else:        Error Code
+ */
+int ifx_pp32_start(int pp32)
+{
+    int ret;
+
+    /*  download firmware   */
+    ret = pp32_download_code(firmware_binary_code, sizeof(firmware_binary_code) / sizeof(*firmware_binary_code), firmware_binary_data, sizeof(firmware_binary_data) / sizeof(*firmware_binary_data));
+    if ( ret != 0 )
+        return ret;
+
+    /*  run PP32    */
+    IFX_REG_W32(DBG_CTRL_RESTART, PP32_DBG_CTRL(0));
+
+    /*  idle for a while to let PP32 init itself    */
+    udelay(10);
+
+    return 0;
+}
+
+/*
+ *  Description:
+ *    Halt PP32.
+ *  Input:
+ *    none
+ *  Output:
+ *    none
+ */
+void ifx_pp32_stop(int pp32)
+{
+    /*  halt PP32   */
+    IFX_REG_W32(DBG_CTRL_STOP, PP32_DBG_CTRL(0));
+}
+
+unsigned int ifx_atm_get_qsb_clk(void)
+{
+    unsigned int shift = ((ltq_cgu_r32(0x0010)) >> 28) & 0x03;
+	unsigned int fpi_clk_rate;
+
+	struct clk *fpi_clk = clk_get_fpi();
+	fpi_clk_rate = clk_get_rate(fpi_clk);
+	return (fpi_clk_rate >> shift);
+}
+
+#ifdef CONFIG_LTQ_ATM_XRX300
+uint32_t get_mailbox1_irq_num(void)
+{
+    volatile struct ar10_chipid *chipid;
+    static uint32_t MAILBOX1_IRQ_NUM = 0;
+
+    if(!MAILBOX1_IRQ_NUM){
+        chipid = (volatile struct ar10_chipid *)AR10_MIPS_CHIPID;
+        if(chipid->version > 1){
+            MAILBOX1_IRQ_NUM = INT_NUM_IM0_IRL24;
+        }else{
+            MAILBOX1_IRQ_NUM = INT_NUM_IM1_IRL29;
+        }
+    }
+
+    return MAILBOX1_IRQ_NUM; 
+}
+#endif
+
diff --git a/drivers/atm/lantiq/ltqmips_atm_core.c b/drivers/atm/lantiq/ltqmips_atm_core.c
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/ltqmips_atm_core.c
@@ -0,0 +1,4989 @@
+/******************************************************************************
+**
+** FILE NAME    : ltqmips_atm_core.c
+** PROJECT      : UEIP
+** MODULES      : ATM
+**
+** DATE         : 7 Jul 2009
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : ATM driver common source file (core functions)
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 07 JUL 2009  Xu Liang        Init Version
+*******************************************************************************/
+
+
+
+/*
+ * ####################################
+ *              Version No.
+ * ####################################
+ */
+
+#define IFX_ATM_VER_MAJOR               1
+#define IFX_ATM_VER_MID                 1
+#define IFX_ATM_VER_MINOR               2
+
+
+
+/*
+ * ####################################
+ *              Head File
+ * ####################################
+ */
+
+/*
+ *  Common Head File
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/atmdev.h>
+#include <linux/atm.h>
+#ifdef CONFIG_XFRM
+  #include <net/xfrm.h>
+#endif
+#include <linux/interrupt.h>
+#include <lantiq_soc.h>
+
+/*
+ *  Chip Specific Head File
+ */
+
+#include "ltqmips_atm_core.h"
+
+/*
+ * ####################################
+ *        Kernel Version Adaption
+ * ####################################
+ */
+#define MODULE_PARM_ARRAY(a, b)   module_param_array(a, int, NULL, 0)
+#define MODULE_PARM(a, b)         module_param(a, int, 0)
+
+/*!
+  \addtogroup IFXMIPS_ATM_MODULE_PARAMS
+ */
+/*@{*/
+/*
+ * ####################################
+ *   Parameters to Configure PPE
+ * ####################################
+ */
+/*!
+  \brief QSB cell delay variation due to concurrency
+ */
+static int qsb_tau   = 1;                       /*  QSB cell delay variation due to concurrency     */
+/*!
+  \brief QSB scheduler burst length
+ */
+static int qsb_srvm  = 0x0F;                    /*  QSB scheduler burst length                      */
+/*!
+  \brief QSB time step, all legal values are 1, 2, 4
+ */
+static int qsb_tstep = 4 ;                      /*  QSB time step, all legal values are 1, 2, 4     */
+
+/*!
+  \brief Write descriptor delay
+ */
+static int write_descriptor_delay  = 0x20;      /*  Write descriptor delay                          */
+
+/*!
+  \brief AAL5 padding byte ('~')
+ */
+static int aal5_fill_pattern       = 0x007E;    /*  AAL5 padding byte ('~')                         */
+/*!
+  \brief Max frame size for RX
+ */
+static int aal5r_max_packet_size   = 0x0700;    /*  Max frame size for RX                           */
+/*!
+  \brief Min frame size for RX
+ */
+static int aal5r_min_packet_size   = 0x0000;    /*  Min frame size for RX                           */
+/*!
+  \brief Max frame size for TX
+ */
+static int aal5s_max_packet_size   = 0x0700;    /*  Max frame size for TX                           */
+/*!
+  \brief Min frame size for TX
+ */
+static int aal5s_min_packet_size   = 0x0000;    /*  Min frame size for TX                           */
+/*!
+  \brief Drop error packet in RX path
+ */
+static int aal5r_drop_error_packet = 1;         /*  Drop error packet in RX path                    */
+
+/*!
+  \brief Number of descriptors per DMA RX channel
+ */
+static int dma_rx_descriptor_length = 128;      /*  Number of descriptors per DMA RX channel        */
+/*!
+  \brief Number of descriptors per DMA TX channel
+ */
+static int dma_tx_descriptor_length = 64;       /*  Number of descriptors per DMA TX channel        */
+/*!
+  \brief PPE core clock cycles between descriptor write and effectiveness in external RAM
+ */
+static int dma_rx_clp1_descriptor_threshold = 38;
+/*@}*/
+
+MODULE_PARM(qsb_tau, "i");
+MODULE_PARM_DESC(qsb_tau, "Cell delay variation. Value must be > 0");
+MODULE_PARM(qsb_srvm, "i");
+MODULE_PARM_DESC(qsb_srvm, "Maximum burst size");
+MODULE_PARM(qsb_tstep, "i");
+MODULE_PARM_DESC(qsb_tstep, "n*32 cycles per sbs cycles n=1,2,4");
+
+MODULE_PARM(write_descriptor_delay, "i");
+MODULE_PARM_DESC(write_descriptor_delay, "PPE core clock cycles between descriptor write and effectiveness in external RAM");
+
+MODULE_PARM(aal5_fill_pattern, "i");
+MODULE_PARM_DESC(aal5_fill_pattern, "Filling pattern (PAD) for AAL5 frames");
+MODULE_PARM(aal5r_max_packet_size, "i");
+MODULE_PARM_DESC(aal5r_max_packet_size, "Max packet size in byte for downstream AAL5 frames");
+MODULE_PARM(aal5r_min_packet_size, "i");
+MODULE_PARM_DESC(aal5r_min_packet_size, "Min packet size in byte for downstream AAL5 frames");
+MODULE_PARM(aal5s_max_packet_size, "i");
+MODULE_PARM_DESC(aal5s_max_packet_size, "Max packet size in byte for upstream AAL5 frames");
+MODULE_PARM(aal5s_min_packet_size, "i");
+MODULE_PARM_DESC(aal5s_min_packet_size, "Min packet size in byte for upstream AAL5 frames");
+MODULE_PARM(aal5r_drop_error_packet, "i");
+MODULE_PARM_DESC(aal5r_drop_error_packet, "Non-zero value to drop error packet for downstream");
+
+MODULE_PARM(dma_rx_descriptor_length, "i");
+MODULE_PARM_DESC(dma_rx_descriptor_length, "Number of descriptor assigned to DMA RX channel (>16)");
+MODULE_PARM(dma_tx_descriptor_length, "i");
+MODULE_PARM_DESC(dma_tx_descriptor_length, "Number of descriptor assigned to DMA TX channel (>16)");
+MODULE_PARM(dma_rx_clp1_descriptor_threshold, "i");
+MODULE_PARM_DESC(dma_rx_clp1_descriptor_threshold, "Descriptor threshold for cells with cell loss priority 1");
+
+
+
+/*
+ * ####################################
+ *              Definition
+ * ####################################
+ */
+
+#ifdef CONFIG_AMAZON_SE
+  #define ENABLE_LESS_CACHE_INV                 1
+  #define LESS_CACHE_INV_LEN                    96
+#endif
+
+#define ENABLE_LED_FRAMEWORK                    1
+
+#define DUMP_SKB_LEN                            ~0
+
+
+
+/*
+ * ####################################
+ *             Declaration
+ * ####################################
+ */
+
+/*
+ *  Network Operations
+ */
+static int ppe_ioctl(struct atm_dev *, unsigned int, void *);
+static int ppe_open(struct atm_vcc *);
+static void ppe_close(struct atm_vcc *);
+static int ppe_send(struct atm_vcc *, struct sk_buff *);
+static int ppe_send_oam(struct atm_vcc *, void *, int);
+static int ppe_change_qos(struct atm_vcc *, struct atm_qos *, int);
+
+/*
+ *  ADSL LED
+ */
+static INLINE void adsl_led_flash(void);
+
+/*
+ *  64-bit operation used by MIB calculation
+ */
+static INLINE void u64_add_u32(ppe_u64_t, unsigned int, ppe_u64_t *);
+
+/*
+ *  buffer manage functions
+ */
+static INLINE struct sk_buff* alloc_skb_rx(void);
+static INLINE struct sk_buff* alloc_skb_tx(unsigned int);
+struct sk_buff* atm_alloc_tx(struct atm_vcc *, unsigned int);
+static INLINE void atm_free_tx_skb_vcc(struct sk_buff *, struct atm_vcc *);
+static INLINE struct sk_buff *get_skb_rx_pointer(unsigned int);
+static INLINE int get_tx_desc(unsigned int);
+static struct sk_buff* skb_duplicate(struct sk_buff *);
+static struct sk_buff* skb_break_away_from_protocol(struct sk_buff *);
+
+/*
+ *  mailbox handler and signal function
+ */
+static INLINE void mailbox_oam_rx_handler(void);
+static INLINE void mailbox_aal_rx_handler(void);
+#if defined(ENABLE_TASKLET) && ENABLE_TASKLET
+  static void do_ppe_tasklet(unsigned long);
+#endif
+static irqreturn_t mailbox_irq_handler(int, void *);
+static INLINE void mailbox_signal(unsigned int, int);
+
+/*
+ *  QSB & HTU setting functions
+ */
+static void set_qsb(struct atm_vcc *, struct atm_qos *, unsigned int);
+static void qsb_global_set(void);
+static INLINE void set_htu_entry(unsigned int, unsigned int, unsigned int, int, int);
+static INLINE void clear_htu_entry(unsigned int);
+static void validate_oam_htu_entry(void);
+static void invalidate_oam_htu_entry(void);
+
+/*
+ *  look up for connection ID
+ */
+static INLINE int find_vpi(unsigned int);
+static INLINE int find_vpivci(unsigned int, unsigned int);
+static INLINE int find_vcc(struct atm_vcc *);
+
+/*
+ *  ReTX functions
+ */
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+  static void retx_polling_func(unsigned long);
+  static int init_atm_tc_retrans_param(void);
+  static void clear_atm_tc_retrans_param(void);
+#endif
+
+
+/*
+ *  Debug Functions
+ */
+#if defined(DEBUG_DUMP_SKB) && DEBUG_DUMP_SKB
+  static void dump_skb(struct sk_buff *, unsigned int, char *, int, int, int);
+#else
+  #define dump_skb(skb, len, title, port, ch, is_tx)    do {} while (0)
+#endif
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+  static void skb_swap(struct sk_buff *, unsigned int);
+#else
+  #define skb_swap(skb, byteoff)                        do {} while (0)
+#endif
+
+/*
+ *  Proc File Functions
+ */
+static INLINE void proc_file_create(void);
+static INLINE void proc_file_delete(void);
+static int proc_read_version(char *, char **, off_t, int, int *, void *);
+static int proc_read_mib(char *, char **, off_t, int, int *, void *);
+static int proc_write_mib(struct file *, const char *, unsigned long, void *);
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+  static int proc_read_retx_mib(char *, char **, off_t, int, int *, void *);
+  static int proc_write_retx_mib(struct file *, const char *, unsigned long, void *);
+#endif
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+  static int proc_read_dbg(char *, char **, off_t, int, int *, void *);
+  static int proc_write_dbg(struct file *, const char *, unsigned long, void *);
+  static int proc_write_mem(struct file *, const char *, unsigned long, void *);
+ #if defined(CONFIG_AR9) || defined(CONFIG_LTQ_ATM_XRX200) || defined(CONFIG_DANUBE) || defined(CONFIG_AMAZON_SE) || defined(CONFIG_LTQ_ATM_XRX300)
+  static int proc_read_pp32(char *, char **, off_t, int, int *, void *);
+  static int proc_write_pp32(struct file *, const char *, unsigned long, void *);
+ #endif
+#endif
+#if defined(ENABLE_FW_PROC) && ENABLE_FW_PROC
+  static int proc_read_htu(char *, char **, off_t, int, int *, void *);
+  static int proc_read_txq(char *, char **, off_t, int, int *, void *);
+ #if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+  static int proc_read_retx_fw(char *, char **, off_t, int, int *, void *);
+  static int proc_read_retx_stats(char *, char **, off_t, int, int *, void *);
+  static int proc_write_retx_stats(struct file *, const char *, unsigned long, void *);
+  static int proc_read_retx_cfg(char *, char **, off_t, int, int *, void *);
+  static int proc_write_retx_cfg(struct file *, const char *, unsigned long, void *);
+  static int proc_read_retx_dsl_param(char *, char **, off_t, int, int *, void *);
+ #endif
+#endif
+
+/*
+ *  Proc Help Functions
+ */
+static int stricmp(const char *, const char *);
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+  static int strincmp(const char *, const char *, int);
+  static int get_token(char **, char **, int *, int *);
+  static unsigned int get_number(char **, int *, int);
+  static void ignore_space(char **, int *);
+#endif
+static INLINE int ifx_atm_version(char *);
+
+/*
+ *  Init & clean-up functions
+ */
+static INLINE void check_parameters(void);
+static INLINE int init_priv_data(void);
+static INLINE void clear_priv_data(void);
+static INLINE void init_rx_tables(void);
+static INLINE void init_tx_tables(void);
+
+#if defined(AS_PVC_MODE_ENABLE) && AS_PVC_MODE_ENABLE
+/*
+ *  Auto-Search PVC Mode functions
+ */
+  typedef void (*as_pvc_push_fn_t)(void *);
+
+  void ppe_enable_as_pvc_mode(as_pvc_push_fn_t);
+  static int as_pvc_add_vcc(struct atm_vcc *);
+  static void as_pvc_remove_vcc(struct atm_vcc *);
+  static int as_pvc_find_vpivci(unsigned int, unsigned int);
+  static int as_pvc_find_vcc(struct atm_vcc *);
+  static void as_pvc_set_htu_entry(int);
+#endif
+
+/*
+ *  Exteranl Function
+ */
+#if defined(CONFIG_IFX_OAM) || defined(CONFIG_IFX_OAM_MODULE)
+  extern void ifx_push_oam(unsigned char *);
+#else
+  static inline void ifx_push_oam(unsigned char *dummy) {}
+#endif
+#if defined(CONFIG_IFXMIPS_DSL_CPE_MEI) || defined(CONFIG_IFXMIPS_DSL_CPE_MEI_MODULE)
+ #if !defined(ENABLE_LED_FRAMEWORK) || !ENABLE_LED_FRAMEWORK
+  extern int ifx_mei_atm_led_blink(void);
+ #endif
+  extern int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr);
+#else
+ #if !defined(ENABLE_LED_FRAMEWORK) || !ENABLE_LED_FRAMEWORK
+  static inline int ifx_mei_atm_led_blink(void) { return 0; }
+ #endif
+  static inline int ifx_mei_atm_showtime_check(int *is_showtime, struct port_cell_info *port_cell, void **xdata_addr)
+  {
+    if ( is_showtime != NULL )
+        *is_showtime = 0;
+    return 0;
+  }
+#endif
+
+/*
+ *  External variable
+ */
+static struct sk_buff* (*ifx_atm_alloc_tx)(struct atm_vcc *, unsigned int) = NULL;
+#if defined(CONFIG_IFXMIPS_DSL_CPE_MEI) || defined(CONFIG_IFXMIPS_DSL_CPE_MEI_MODULE)
+  extern int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *);
+  extern int (*ifx_mei_atm_showtime_exit)(void);
+#else
+  int (*ifx_mei_atm_showtime_enter)(struct port_cell_info *, void *) = NULL;
+  EXPORT_SYMBOL(ifx_mei_atm_showtime_enter);
+  int (*ifx_mei_atm_showtime_exit)(void) = NULL;
+  EXPORT_SYMBOL(ifx_mei_atm_showtime_exit);
+#endif
+
+
+
+/*
+ * ####################################
+ *            Local Variable
+ * ####################################
+ */
+
+static struct atm_priv_data g_atm_priv_data;
+
+static struct atmdev_ops g_ifx_atm_ops = {
+    .open       = ppe_open,
+    .close      = ppe_close,
+    .ioctl      = ppe_ioctl,
+    .send       = ppe_send,
+    .send_oam   = ppe_send_oam,
+    .change_qos = ppe_change_qos,
+    .owner      = THIS_MODULE,
+};
+
+#if defined(ENABLE_TASKLET) && ENABLE_TASKLET
+  DECLARE_TASKLET(g_dma_tasklet, do_ppe_tasklet, 0);
+#endif
+
+static int g_showtime = 0;
+static void *g_xdata_addr = NULL;
+
+#if defined(ENABLE_LED_FRAMEWORK) && ENABLE_LED_FRAMEWORK
+ #ifdef CONFIG_IFX_LED
+  static void *g_data_led_trigger = NULL;
+ #endif
+#endif
+
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+  static unsigned long g_retx_playout_buffer = 0;
+
+  static volatile int g_retx_htu = 1;
+  static struct dsl_param g_dsl_param = {0};
+  static int g_retx_polling_cnt = HZ;
+  static struct timeval g_retx_polling_start = {0}, g_retx_polling_end = {0};
+  static struct timer_list g_retx_polling_timer;
+#endif
+
+unsigned int ifx_atm_dbg_enable = 0;
+
+static struct proc_dir_entry* g_atm_dir = NULL;
+
+#if defined(AS_PVC_MODE_ENABLE) && AS_PVC_MODE_ENABLE
+  static as_pvc_push_fn_t g_as_pvc_push = NULL;
+  static struct atm_vcc *g_as_pvc_vcc[64] = {0};
+  static int g_as_pvc_conn = -1;
+#endif
+
+
+
+/*
+ * ####################################
+ *            Local Function
+ * ####################################
+ */
+
+static int ppe_ioctl(struct atm_dev *dev, unsigned int cmd, void *arg)
+{
+    int ret = 0;
+    atm_cell_ifEntry_t mib_cell;
+    atm_aal5_ifEntry_t mib_aal5;
+    atm_aal5_vcc_x_t mib_vcc;
+    unsigned int value;
+    int conn;
+
+    if ( _IOC_TYPE(cmd) != PPE_ATM_IOC_MAGIC
+        || _IOC_NR(cmd) >= PPE_ATM_IOC_MAXNR )
+        return -ENOTTY;
+
+    if ( _IOC_DIR(cmd) & _IOC_READ )
+        ret = !access_ok(VERIFY_WRITE, arg, _IOC_SIZE(cmd));
+    else if ( _IOC_DIR(cmd) & _IOC_WRITE )
+        ret = !access_ok(VERIFY_READ, arg, _IOC_SIZE(cmd));
+    if ( ret )
+        return -EFAULT;
+
+    switch ( cmd )
+    {
+    case PPE_ATM_MIB_CELL:  /*  cell level  MIB */
+        /*  These MIB should be read at ARC side, now put zero only.    */
+        mib_cell.ifHCInOctets_h = 0;
+        mib_cell.ifHCInOctets_l = 0;
+        mib_cell.ifHCOutOctets_h = 0;
+        mib_cell.ifHCOutOctets_l = 0;
+        mib_cell.ifInErrors = 0;
+        mib_cell.ifInUnknownProtos = WAN_MIB_TABLE->wrx_drophtu_cell;
+        mib_cell.ifOutErrors = 0;
+
+        ret = sizeof(mib_cell) - copy_to_user(arg, &mib_cell, sizeof(mib_cell));
+        break;
+
+    case PPE_ATM_MIB_AAL5:  /*  AAL5 MIB    */
+        value = WAN_MIB_TABLE->wrx_total_byte;
+        u64_add_u32(g_atm_priv_data.wrx_total_byte, value - g_atm_priv_data.prev_wrx_total_byte, &g_atm_priv_data.wrx_total_byte);
+        g_atm_priv_data.prev_wrx_total_byte = value;
+        mib_aal5.ifHCInOctets_h = g_atm_priv_data.wrx_total_byte.h;
+        mib_aal5.ifHCInOctets_l = g_atm_priv_data.wrx_total_byte.l;
+
+        value = WAN_MIB_TABLE->wtx_total_byte;
+        u64_add_u32(g_atm_priv_data.wtx_total_byte, value - g_atm_priv_data.prev_wtx_total_byte, &g_atm_priv_data.wtx_total_byte);
+        g_atm_priv_data.prev_wtx_total_byte = value;
+        mib_aal5.ifHCOutOctets_h = g_atm_priv_data.wtx_total_byte.h;
+        mib_aal5.ifHCOutOctets_l = g_atm_priv_data.wtx_total_byte.l;
+
+        mib_aal5.ifInUcastPkts  = g_atm_priv_data.wrx_pdu;
+        mib_aal5.ifOutUcastPkts = WAN_MIB_TABLE->wtx_total_pdu;
+        mib_aal5.ifInErrors     = WAN_MIB_TABLE->wrx_err_pdu;
+        mib_aal5.ifInDiscards   = WAN_MIB_TABLE->wrx_dropdes_pdu + g_atm_priv_data.wrx_drop_pdu;
+        mib_aal5.ifOutErros     = g_atm_priv_data.wtx_err_pdu;
+        mib_aal5.ifOutDiscards  = g_atm_priv_data.wtx_drop_pdu;
+
+        ret = sizeof(mib_aal5) - copy_to_user(arg, &mib_aal5, sizeof(mib_aal5));
+        break;
+
+    case PPE_ATM_MIB_VCC:   /*  VCC related MIB */
+        copy_from_user(&mib_vcc, arg, sizeof(mib_vcc));
+        conn = find_vpivci(mib_vcc.vpi, mib_vcc.vci);
+        if ( conn >= 0 )
+        {
+            mib_vcc.mib_vcc.aal5VccCrcErrors     = g_atm_priv_data.conn[conn].aal5_vcc_crc_err;
+            mib_vcc.mib_vcc.aal5VccOverSizedSDUs = g_atm_priv_data.conn[conn].aal5_vcc_oversize_sdu;
+            mib_vcc.mib_vcc.aal5VccSarTimeOuts   = 0;   /*  no timer support    */
+            ret = sizeof(mib_vcc) - copy_to_user(arg, &mib_vcc, sizeof(mib_vcc));
+        }
+        else
+            ret = -EINVAL;
+        break;
+
+    default:
+        ret = -ENOIOCTLCMD;
+    }
+
+    return ret;
+}
+
+static int ppe_open(struct atm_vcc *vcc)
+{
+    int ret;
+    short vpi = vcc->vpi;
+    int   vci = vcc->vci;
+    struct port *port = &g_atm_priv_data.port[(int)vcc->dev->dev_data];
+    int conn;
+    int f_enable_irq = 0;
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+    unsigned long sys_flag;
+#endif
+
+    if ( vcc->qos.aal != ATM_AAL5 && vcc->qos.aal != ATM_AAL0 )
+        return -EPROTONOSUPPORT;
+
+#if !defined(DISABLE_QOS_WORKAROUND) || !DISABLE_QOS_WORKAROUND
+    /*  check bandwidth */
+    if ( (vcc->qos.txtp.traffic_class == ATM_CBR && vcc->qos.txtp.max_pcr > (port->tx_max_cell_rate - port->tx_current_cell_rate))
+      || (vcc->qos.txtp.traffic_class == ATM_VBR_RT && vcc->qos.txtp.max_pcr > (port->tx_max_cell_rate - port->tx_current_cell_rate))
+      || (vcc->qos.txtp.traffic_class == ATM_VBR_NRT && vcc->qos.txtp.scr > (port->tx_max_cell_rate - port->tx_current_cell_rate))
+      || (vcc->qos.txtp.traffic_class == ATM_UBR_PLUS && vcc->qos.txtp.min_pcr > (port->tx_max_cell_rate - port->tx_current_cell_rate)) )
+    {
+        ret = -EINVAL;
+        goto PPE_OPEN_EXIT;
+    }
+#endif
+
+#if defined(AS_PVC_MODE_ENABLE) && AS_PVC_MODE_ENABLE
+    if ( g_as_pvc_push != NULL )
+    {
+        if ( as_pvc_find_vpivci(vpi, vci) >= 0 )
+        {
+            ret = -EADDRINUSE;
+            goto PPE_OPEN_EXIT;
+        }
+        if ( g_as_pvc_conn >= 0 )
+        {
+            ret = as_pvc_add_vcc(vcc) == 0 ? 0 : -EINVAL;
+            goto PPE_OPEN_EXIT;
+        }
+    }
+#endif
+
+    /*  check existing vpi,vci  */
+    conn = find_vpivci(vpi, vci);
+    if ( conn >= 0 ) {
+        ret = -EADDRINUSE;
+        goto PPE_OPEN_EXIT;
+    }
+
+    /*  check whether it need to enable irq */
+    if ( g_atm_priv_data.conn_table == 0 )
+        f_enable_irq = 1;
+
+    /*  allocate connection */
+    for ( conn = 0; conn < MAX_PVC_NUMBER; conn++ ) {
+        if ( test_and_set_bit(conn, &g_atm_priv_data.conn_table) == 0 ) {
+            g_atm_priv_data.conn[conn].vcc = vcc;
+            break;
+        }
+    }
+    if ( conn == MAX_PVC_NUMBER )
+    {
+        ret = -EINVAL;
+        goto PPE_OPEN_EXIT;
+    }
+
+    /*  reserve bandwidth   */
+    switch ( vcc->qos.txtp.traffic_class ) {
+    case ATM_CBR:
+    case ATM_VBR_RT:
+        port->tx_current_cell_rate += vcc->qos.txtp.max_pcr;
+        break;
+    case ATM_VBR_NRT:
+        port->tx_current_cell_rate += vcc->qos.txtp.scr;
+        break;
+    case ATM_UBR_PLUS:
+        port->tx_current_cell_rate += vcc->qos.txtp.min_pcr;
+        break;
+    }
+
+    /*  set qsb */
+    set_qsb(vcc, &vcc->qos, conn);
+
+    /*  update atm_vcc structure    */
+    vcc->itf = (int)vcc->dev->dev_data;
+    vcc->vpi = vpi;
+    vcc->vci = vci;
+    set_bit(ATM_VF_ADDR, &vcc->flags);
+    set_bit(ATM_VF_READY, &vcc->flags);
+
+    /*  enable irq  */
+    if ( f_enable_irq ) {
+        ifx_atm_alloc_tx = atm_alloc_tx;
+
+        *MBOX_IGU1_ISRC = (1 << RX_DMA_CH_AAL) | (1 << RX_DMA_CH_OAM);
+        *MBOX_IGU1_IER  = (1 << RX_DMA_CH_AAL) | (1 << RX_DMA_CH_OAM);
+
+        enable_irq(PPE_MAILBOX_IGU1_INT);
+    }
+
+    /*  set port    */
+    WTX_QUEUE_CONFIG(conn + FIRST_QSB_QID)->sbid = (int)vcc->dev->dev_data;
+
+    /*  set htu entry   */
+#if defined(AS_PVC_MODE_ENABLE) && AS_PVC_MODE_ENABLE
+    if ( g_as_pvc_push != NULL )
+        as_pvc_set_htu_entry(g_as_pvc_conn = conn);
+    else
+#endif
+        set_htu_entry(vpi, vci, conn, vcc->qos.aal == ATM_AAL5 ? 1 : 0, 0);
+
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+    //  ReTX: occupy second QID
+    local_irq_save(sys_flag);
+    if ( g_retx_htu && vcc->qos.aal == ATM_AAL5 )
+    {
+        int retx_conn = (conn + 8) % 16;    //  ReTX queue
+
+        if ( retx_conn < MAX_PVC_NUMBER && test_and_set_bit(retx_conn, &g_atm_priv_data.conn_table) == 0 ) {
+            g_atm_priv_data.conn[retx_conn].vcc = vcc;
+            set_htu_entry(vpi, vci, retx_conn, vcc->qos.aal == ATM_AAL5 ? 1 : 0, 1);
+        }
+    }
+    local_irq_restore(sys_flag);
+#endif
+
+    ret = 0;
+
+PPE_OPEN_EXIT:
+    return ret;
+}
+
+static void ppe_close(struct atm_vcc *vcc)
+{
+    int conn;
+    struct port *port;
+    struct connection *connection;
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+    unsigned long sys_flag;
+#endif
+
+    if ( vcc == NULL )
+        return;
+
+#if defined(AS_PVC_MODE_ENABLE) && AS_PVC_MODE_ENABLE
+    if ( g_as_pvc_push != NULL )
+    {
+        as_pvc_remove_vcc(vcc);
+        if ( g_as_pvc_conn >= 0 && vcc == g_atm_priv_data.conn[g_as_pvc_conn].vcc )
+            g_as_pvc_conn = -1;
+        else
+            goto PPE_CLOSE_EXIT;
+    }
+#endif
+
+    /*  get connection id   */
+    conn = find_vcc(vcc);
+    if ( conn < 0 ) {
+        err("can't find vcc");
+        goto PPE_CLOSE_EXIT;
+    }
+    connection = &g_atm_priv_data.conn[conn];
+    port = &g_atm_priv_data.port[connection->port];
+
+    clear_bit(ATM_VF_READY, &vcc->flags);
+    clear_bit(ATM_VF_ADDR, &vcc->flags);
+
+    /*  clear htu   */
+    clear_htu_entry(conn);
+
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+    //  ReTX: release second QID
+    local_irq_save(sys_flag);
+    if ( g_retx_htu && vcc->qos.aal == ATM_AAL5 )
+    {
+        int retx_conn = (conn + 8) % 16;    //  ReTX queue
+
+        if ( retx_conn < MAX_PVC_NUMBER && g_atm_priv_data.conn[retx_conn].vcc == vcc ) {
+            clear_htu_entry(retx_conn);
+            g_atm_priv_data.conn[retx_conn].vcc = NULL;
+            g_atm_priv_data.conn[retx_conn].aal5_vcc_crc_err = 0;
+            g_atm_priv_data.conn[retx_conn].aal5_vcc_oversize_sdu = 0;
+            clear_bit(retx_conn, &g_atm_priv_data.conn_table);
+        }
+    }
+    local_irq_restore(sys_flag);
+#endif
+
+    /*  release connection  */
+    connection->vcc = NULL;
+    connection->aal5_vcc_crc_err = 0;
+    connection->aal5_vcc_oversize_sdu = 0;
+    clear_bit(conn, &g_atm_priv_data.conn_table);
+
+    /*  disable irq */
+    if ( g_atm_priv_data.conn_table == 0 ) {
+        disable_irq(PPE_MAILBOX_IGU1_INT);
+        ifx_atm_alloc_tx = NULL;
+    }
+
+    /*  release bandwidth   */
+    switch ( vcc->qos.txtp.traffic_class )
+    {
+    case ATM_CBR:
+    case ATM_VBR_RT:
+        port->tx_current_cell_rate -= vcc->qos.txtp.max_pcr;
+        break;
+    case ATM_VBR_NRT:
+        port->tx_current_cell_rate -= vcc->qos.txtp.scr;
+        break;
+    case ATM_UBR_PLUS:
+        port->tx_current_cell_rate -= vcc->qos.txtp.min_pcr;
+        break;
+    }
+
+PPE_CLOSE_EXIT:
+    return;
+}
+
+static int ppe_send(struct atm_vcc *vcc, struct sk_buff *skb)
+{
+    int ret;
+    int conn;
+    int desc_base;
+    struct tx_descriptor reg_desc = {0};
+    struct sk_buff *new_skb;
+
+    if ( vcc == NULL || skb == NULL )
+        return -EINVAL;
+
+    skb_get(skb);
+    atm_free_tx_skb_vcc(skb, vcc);
+
+#if defined(AS_PVC_MODE_ENABLE) && AS_PVC_MODE_ENABLE
+    if ( g_as_pvc_push != NULL && as_pvc_find_vcc(vcc) >= 0 )
+        conn = g_as_pvc_conn;
+    else
+#endif
+        conn = find_vcc(vcc);
+    if ( conn < 0 ) {
+        ret = -EINVAL;
+        goto FIND_VCC_FAIL;
+    }
+
+    if ( !g_showtime ) {
+        err("not in showtime");
+        ret = -EIO;
+        goto PPE_SEND_FAIL;
+    }
+
+    if ( vcc->qos.aal == ATM_AAL5 ) {
+        int byteoff;
+        int datalen;
+        struct tx_inband_header *header;
+
+        byteoff = (unsigned int)skb->data & (DATA_BUFFER_ALIGNMENT - 1);
+        if ( skb_headroom(skb) < byteoff + TX_INBAND_HEADER_LENGTH )
+            new_skb = skb_duplicate(skb);
+        else
+            new_skb = skb_break_away_from_protocol(skb);
+        if ( new_skb == NULL ) {
+            err("either skb_duplicate or skb_break_away_from_protocol fail");
+            ret = -ENOMEM;
+            goto PPE_SEND_FAIL;
+        }
+        dev_kfree_skb_any(skb);
+        skb = new_skb;
+
+        datalen = skb->len;
+        byteoff = (unsigned int)skb->data & (DATA_BUFFER_ALIGNMENT - 1);
+
+        skb_push(skb, byteoff + TX_INBAND_HEADER_LENGTH);
+
+        header = (struct tx_inband_header *)skb->data;
+
+        /*  setup inband trailer    */
+        header->uu   = 0;
+        header->cpi  = 0;
+        header->pad  = aal5_fill_pattern;
+        header->res1 = 0;
+
+        /*  setup cell header   */
+        header->clp  = (vcc->atm_options & ATM_ATMOPT_CLP) ? 1 : 0;
+        header->pti  = ATM_PTI_US0;
+        header->vci  = vcc->vci;
+        header->vpi  = vcc->vpi;
+        header->gfc  = 0;
+
+        /*  setup descriptor    */
+        reg_desc.dataptr = (unsigned int)skb->data >> 2;
+        reg_desc.datalen = datalen;
+        reg_desc.byteoff = byteoff;
+        reg_desc.iscell  = 0;
+    }
+    else {
+        /*  if data pointer is not aligned, allocate new sk_buff    */
+        if ( ((unsigned int)skb->data & (DATA_BUFFER_ALIGNMENT - 1)) != 0 ) {
+            err("skb->data not aligned");
+            new_skb = skb_duplicate(skb);
+        }
+        else
+            new_skb = skb_break_away_from_protocol(skb);
+        if ( new_skb == NULL ) {
+            err("either skb_duplicate or skb_break_away_from_protocol fail");
+            ret = -ENOMEM;
+            goto PPE_SEND_FAIL;
+        }
+        dev_kfree_skb_any(skb);
+        skb = new_skb;
+
+        reg_desc.dataptr = (unsigned int)skb->data >> 2;
+        reg_desc.datalen = skb->len;
+        reg_desc.byteoff = 0;
+        reg_desc.iscell  = 1;
+    }
+
+    reg_desc.own = 1;
+    reg_desc.c = 1;
+    reg_desc.sop = reg_desc.eop = 1;
+
+    desc_base = get_tx_desc(conn);
+    if ( desc_base < 0 ) {
+        err("ALLOC_TX_CONNECTION_FAIL");
+        ret = -EIO;
+        goto PPE_SEND_FAIL;
+    }
+
+    if ( vcc->stats )
+        atomic_inc(&vcc->stats->tx);
+    if ( vcc->qos.aal == ATM_AAL5 )
+        g_atm_priv_data.wtx_pdu++;
+
+    /*  update descriptor send pointer  */
+    if ( g_atm_priv_data.conn[conn].tx_skb[desc_base] != NULL )
+        dev_kfree_skb_any(g_atm_priv_data.conn[conn].tx_skb[desc_base]);
+    g_atm_priv_data.conn[conn].tx_skb[desc_base] = skb;
+
+    /*  write discriptor to memory and write back cache */
+    g_atm_priv_data.conn[conn].tx_desc[desc_base] = reg_desc;
+    dma_cache_sync(NULL, skb->data, skb->len, DMA_TO_DEVICE);
+
+    dump_skb(skb, DUMP_SKB_LEN, (char *)__func__, 0, conn, 1);
+
+    if ( vcc->qos.aal == ATM_AAL5 && (ifx_atm_dbg_enable & DBG_ENABLE_MASK_MAC_SWAP) ) {
+        skb_swap(skb, reg_desc.byteoff);
+    }
+
+    mailbox_signal(conn, 1);
+
+    adsl_led_flash();
+
+    return 0;
+
+FIND_VCC_FAIL:
+    err("FIND_VCC_FAIL");
+    g_atm_priv_data.wtx_err_pdu++;
+    dev_kfree_skb_any(skb);
+    return ret;
+
+PPE_SEND_FAIL:
+    if ( vcc->qos.aal == ATM_AAL5 )
+        g_atm_priv_data.wtx_drop_pdu++;
+    if ( vcc->stats )
+        atomic_inc(&vcc->stats->tx_err);
+    dev_kfree_skb_any(skb);
+    return ret;
+}
+
+static int ppe_send_oam(struct atm_vcc *vcc, void *cell, int flags)
+{
+    int conn;
+#if !defined(AS_PVC_MODE_ENABLE) || !AS_PVC_MODE_ENABLE
+    struct uni_cell_header *uni_cell_header = (struct uni_cell_header *)cell;
+#endif
+    int desc_base;
+    struct sk_buff *skb;
+    struct tx_descriptor reg_desc = {0};
+
+#if !defined(AS_PVC_MODE_ENABLE) || !AS_PVC_MODE_ENABLE
+    if ( ((uni_cell_header->pti == ATM_PTI_SEGF5 || uni_cell_header->pti == ATM_PTI_E2EF5)
+        && find_vpivci(uni_cell_header->vpi, uni_cell_header->vci) < 0)
+        || ((uni_cell_header->vci == 0x03 || uni_cell_header->vci == 0x04)
+        && find_vpi(uni_cell_header->vpi) < 0) ) {
+        g_atm_priv_data.wtx_err_oam++;
+        return -EINVAL;
+    }
+#endif
+
+    if ( !g_showtime ) {
+        err("not in showtime");
+        g_atm_priv_data.wtx_drop_oam++;
+        return -EIO;
+    }
+
+#if defined(AS_PVC_MODE_ENABLE) && AS_PVC_MODE_ENABLE
+    if ( g_as_pvc_push != NULL && as_pvc_find_vcc(vcc) >= 0 )
+        conn = g_as_pvc_conn;
+    else
+#endif
+        conn = find_vcc(vcc);
+    if ( conn < 0 ) {
+        err("FIND_VCC_FAIL");
+        g_atm_priv_data.wtx_drop_oam++;
+        return -EINVAL;
+    }
+
+    skb = alloc_skb_tx(CELL_SIZE);
+    if ( skb == NULL ) {
+        err("ALLOC_SKB_TX_FAIL");
+        g_atm_priv_data.wtx_drop_oam++;
+        return -ENOMEM;
+    }
+    skb_put(skb, CELL_SIZE);
+    memcpy(skb->data, cell, CELL_SIZE);
+
+    reg_desc.dataptr = (unsigned int)skb->data >> 2;
+    reg_desc.datalen = CELL_SIZE;
+    reg_desc.byteoff = 0;
+    reg_desc.iscell  = 1;
+
+    reg_desc.own = 1;
+    reg_desc.c = 1;
+    reg_desc.sop = reg_desc.eop = 1;
+
+    desc_base = get_tx_desc(conn);
+    if ( desc_base < 0 ) {
+        dev_kfree_skb_any(skb);
+        err("ALLOC_TX_CONNECTION_FAIL");
+        g_atm_priv_data.wtx_drop_oam++;
+        return -EIO;
+    }
+
+    if ( vcc->stats )
+        atomic_inc(&vcc->stats->tx);
+
+    /*  update descriptor send pointer  */
+    if ( g_atm_priv_data.conn[conn].tx_skb[desc_base] != NULL )
+        dev_kfree_skb_any(g_atm_priv_data.conn[conn].tx_skb[desc_base]);
+    g_atm_priv_data.conn[conn].tx_skb[desc_base] = skb;
+
+    /*  write discriptor to memory and write back cache */
+    g_atm_priv_data.conn[conn].tx_desc[desc_base] = reg_desc;
+    dma_cache_sync(NULL, skb->data, CELL_SIZE, DMA_TO_DEVICE);
+
+    dump_skb(skb, DUMP_SKB_LEN, (char *)__func__, 0, conn, 1);
+
+    mailbox_signal(conn, 1);
+
+    g_atm_priv_data.wtx_oam++;
+    adsl_led_flash();
+
+    return 0;
+}
+
+static int ppe_change_qos(struct atm_vcc *vcc, struct atm_qos *qos, int flags)
+{
+    int conn;
+
+    if ( vcc == NULL || qos == NULL )
+        return -EINVAL;
+
+    conn = find_vcc(vcc);
+    if ( conn < 0 )
+        return -EINVAL;
+
+    set_qsb(vcc, qos, conn);
+
+    return 0;
+}
+
+static INLINE void adsl_led_flash(void)
+{
+#if defined(ENABLE_LED_FRAMEWORK) && ENABLE_LED_FRAMEWORK
+  #ifdef CONFIG_IFX_LED
+    if ( g_data_led_trigger != NULL )
+        ifx_led_trigger_activate(g_data_led_trigger);
+  #endif
+#else
+    ifx_mei_atm_led_blink();
+#endif
+}
+
+/*
+ *  Description:
+ *    Add a 32-bit value to 64-bit value, and put result in a 64-bit variable.
+ *  Input:
+ *    opt1 --- ppe_u64_t, first operand, a 64-bit unsigned integer value
+ *    opt2 --- unsigned int, second operand, a 32-bit unsigned integer value
+ *    ret  --- ppe_u64_t, pointer to a variable to hold result
+ *  Output:
+ *    none
+ */
+static INLINE void u64_add_u32(ppe_u64_t opt1, unsigned int opt2, ppe_u64_t *ret)
+{
+    ret->l = opt1.l + opt2;
+    if ( ret->l < opt1.l || ret->l < opt2 )
+        ret->h++;
+}
+
+static INLINE struct sk_buff* alloc_skb_rx(void)
+{
+    struct sk_buff *skb;
+
+    skb = dev_alloc_skb(RX_DMA_CH_AAL_BUF_SIZE + DATA_BUFFER_ALIGNMENT);
+    if ( skb != NULL ) {
+        /*  must be burst length alignment  */
+        if ( ((unsigned int)skb->data & (DATA_BUFFER_ALIGNMENT - 1)) != 0 )
+            skb_reserve(skb, ~((unsigned int)skb->data + (DATA_BUFFER_ALIGNMENT - 1)) & (DATA_BUFFER_ALIGNMENT - 1));
+        /*  pub skb in reserved area "skb->data - 4"    */
+        *((struct sk_buff **)skb->data - 1) = skb;
+        /*  write back and invalidate cache */
+        dma_cache_sync(NULL, skb->data - sizeof(skb), sizeof(skb), DMA_BIDIRECTIONAL);
+        /*  invalidate cache    */
+#if defined(ENABLE_LESS_CACHE_INV) && ENABLE_LESS_CACHE_INV
+        dma_cache_sync(NULL, skb->data, LESS_CACHE_INV_LEN, DMA_FROM_DEVICE);
+#else
+        dma_cache_sync(NULL, skb->data, RX_DMA_CH_AAL_BUF_SIZE, DMA_FROM_DEVICE);
+#endif
+    }
+
+    return skb;
+}
+
+static INLINE struct sk_buff* alloc_skb_tx(unsigned int size)
+{
+    struct sk_buff *skb;
+
+    /*  allocate memory including header and padding    */
+    size += TX_INBAND_HEADER_LENGTH + MAX_TX_PACKET_ALIGN_BYTES + MAX_TX_PACKET_PADDING_BYTES;
+    size &= ~(DATA_BUFFER_ALIGNMENT - 1);
+    skb = dev_alloc_skb(size + DATA_BUFFER_ALIGNMENT);
+    /*  must be burst length alignment  */
+    if ( skb != NULL )
+        skb_reserve(skb, (~((unsigned int)skb->data + (DATA_BUFFER_ALIGNMENT - 1)) & (DATA_BUFFER_ALIGNMENT - 1)) + TX_INBAND_HEADER_LENGTH);
+    return skb;
+}
+
+struct sk_buff* atm_alloc_tx(struct atm_vcc *vcc, unsigned int size)
+{
+    int conn;
+    struct sk_buff *skb;
+
+    /*  oversize packet */
+    if ( size > aal5s_max_packet_size ) {
+        err("atm_alloc_tx: oversize packet");
+        return NULL;
+    }
+    /*  send buffer overflow    */
+    if ( atomic_read(&sk_atm(vcc)->sk_wmem_alloc) && !atm_may_send(vcc, size) ) {
+        err("atm_alloc_tx: send buffer overflow");
+        return NULL;
+    }
+    conn = find_vcc(vcc);
+    if ( conn < 0 ) {
+        err("atm_alloc_tx: unknown VCC");
+        return NULL;
+    }
+
+    skb = dev_alloc_skb(size);
+    if ( skb == NULL ) {
+        err("atm_alloc_tx: sk buffer is used up");
+        return NULL;
+    }
+
+    atomic_add(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc);
+
+    return skb;
+}
+
+static INLINE void atm_free_tx_skb_vcc(struct sk_buff *skb, struct atm_vcc *vcc)
+{
+    if ( vcc->pop != NULL )
+        vcc->pop(vcc, skb);
+    else
+        dev_kfree_skb_any(skb);
+}
+
+static INLINE struct sk_buff *get_skb_rx_pointer(unsigned int dataptr)
+{
+    unsigned int skb_dataptr;
+    struct sk_buff *skb;
+
+    skb_dataptr = ((dataptr - 1) << 2) | KSEG1;
+    skb = *(struct sk_buff **)skb_dataptr;
+
+    ASSERT((unsigned int)skb >= KSEG0, "invalid skb - skb = %#08x, dataptr = %#08x", (unsigned int)skb, dataptr);
+    ASSERT(((unsigned int)skb->data | KSEG1) == ((dataptr << 2) | KSEG1), "invalid skb - skb = %#08x, skb->data = %#08x, dataptr = %#08x", (unsigned int)skb, (unsigned int)skb->data, dataptr);
+
+    return skb;
+}
+
+static INLINE int get_tx_desc(unsigned int conn)
+{
+    int desc_base = -1;
+    struct connection *p_conn = &g_atm_priv_data.conn[conn];
+
+    if ( p_conn->tx_desc[p_conn->tx_desc_pos].own == 0 ) {
+        desc_base = p_conn->tx_desc_pos;
+        if ( ++(p_conn->tx_desc_pos) == dma_tx_descriptor_length )
+            p_conn->tx_desc_pos = 0;
+    }
+
+    return desc_base;
+}
+
+static struct sk_buff* skb_duplicate(struct sk_buff *skb)
+{
+    struct sk_buff *new_skb;
+
+    new_skb = alloc_skb_tx(skb->len);
+    if ( new_skb == NULL )
+        return NULL;
+
+    skb_put(new_skb, skb->len);
+    memcpy(new_skb->data, skb->data, skb->len);
+
+    return new_skb;
+}
+
+static struct sk_buff* skb_break_away_from_protocol(struct sk_buff *skb)
+{
+    struct sk_buff *new_skb;
+
+    if ( skb_shared(skb) ) {
+        new_skb = skb_clone(skb, GFP_ATOMIC);
+        if ( new_skb == NULL )
+            return NULL;
+    }
+    else
+        new_skb = skb_get(skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+    dst_release(new_skb->dst);
+    new_skb->dst = NULL;
+#else
+    skb_dst_drop(new_skb);
+#endif
+#ifdef CONFIG_XFRM
+	secpath_put(new_skb->sp);
+	new_skb->sp = NULL;
+#endif
+#if defined(CONFIG_NETFILTER) || (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32) && defined(CONFIG_NF_CONNTRACK))
+	nf_conntrack_put(new_skb->nfct);
+	new_skb->nfct = NULL;
+  #if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
+	nf_conntrack_put_reasm(new_skb->nfct_reasm);
+	new_skb->nfct_reasm = NULL;
+  #endif
+  #ifdef CONFIG_BRIDGE_NETFILTER
+	nf_bridge_put(new_skb->nf_bridge);
+	new_skb->nf_bridge = NULL;
+  #endif
+#endif
+
+    return new_skb;
+}
+
+static INLINE void mailbox_oam_rx_handler(void)
+{
+    unsigned int vlddes = WRX_DMA_CHANNEL_CONFIG(RX_DMA_CH_OAM)->vlddes;
+    struct rx_descriptor reg_desc;
+    struct uni_cell_header *header;
+    int conn;
+    struct atm_vcc *vcc;
+    unsigned int i;
+
+    for ( i = 0; i < vlddes; i++ ) {
+        unsigned int loop_count = 0;
+
+        do {
+            reg_desc = g_atm_priv_data.oam_desc[g_atm_priv_data.oam_desc_pos];
+            if ( ++loop_count == 1000 )
+                break;
+        } while ( reg_desc.own || !reg_desc.c );    //  keep test OWN and C bit until data is ready
+        ASSERT(loop_count == 1, "loop_count = %u, own = %d, c = %d, oam_desc_pos = %u", loop_count, (int)reg_desc.own, (int)reg_desc.c, g_atm_priv_data.oam_desc_pos);
+
+        header = (struct uni_cell_header *)&g_atm_priv_data.oam_buf[g_atm_priv_data.oam_desc_pos * RX_DMA_CH_OAM_BUF_SIZE];
+
+#if defined(DEBUG_DUMP_SKB) && DEBUG_DUMP_SKB
+        if ( (ifx_atm_dbg_enable & DBG_ENABLE_MASK_DUMP_SKB_RX) ) {
+            unsigned char *p = (unsigned char *)header;
+            int j;
+
+            printk("%s\n", __func__);
+            printk("data = %08X, len = %d\n", (unsigned int)p, CELL_SIZE);
+            for ( j = 1; j <= CELL_SIZE; j++ ) {
+                if ( j % 16 == 1 )
+                    printk("  %4d:", j - 1);
+                printk(" %02X", ((int)(*(p + j - 1))) & 0xFF);
+                if ( j % 16 == 0 )
+                    printk("\n");
+            }
+            if ( (j - 1) % 16 != 0 )
+                printk("\n");
+        }
+#endif
+
+        if ( header->pti == ATM_PTI_SEGF5 || header->pti == ATM_PTI_E2EF5 )
+            conn = find_vpivci(header->vpi, header->vci);
+        else if ( header->vci == 0x03 || header->vci == 0x04 )
+            conn = find_vpi(header->vpi);
+        else
+            conn = -1;
+
+        if ( conn >= 0 && g_atm_priv_data.conn[conn].vcc != NULL ) {
+            vcc = g_atm_priv_data.conn[conn].vcc;
+
+            if ( vcc->push_oam != NULL )
+                vcc->push_oam(vcc, header);
+            else
+                ifx_push_oam((unsigned char *)header);
+
+            g_atm_priv_data.wrx_oam++;
+
+            adsl_led_flash();
+        }
+        else
+            g_atm_priv_data.wrx_drop_oam++;
+
+        reg_desc.byteoff = 0;
+        reg_desc.datalen = RX_DMA_CH_OAM_BUF_SIZE;
+        reg_desc.own = 1;
+        reg_desc.c   = 0;
+
+        g_atm_priv_data.oam_desc[g_atm_priv_data.oam_desc_pos] = reg_desc;
+        if ( ++g_atm_priv_data.oam_desc_pos == RX_DMA_CH_OAM_DESC_LEN )
+            g_atm_priv_data.oam_desc_pos = 0;
+
+        dma_cache_sync(NULL, header, CELL_SIZE, DMA_FROM_DEVICE);
+        mailbox_signal(RX_DMA_CH_OAM, 0);
+    }
+}
+
+static INLINE void mailbox_aal_rx_handler(void)
+{
+    unsigned int vlddes = WRX_DMA_CHANNEL_CONFIG(RX_DMA_CH_AAL)->vlddes;
+    struct rx_descriptor reg_desc;
+    int conn;
+    struct atm_vcc *vcc;
+    struct sk_buff *skb, *new_skb;
+    struct rx_inband_trailer *trailer;
+    unsigned int i;
+
+    for ( i = 0; i < vlddes; i++ ) {
+        unsigned int loop_count = 0;
+
+        do {
+            reg_desc = g_atm_priv_data.aal_desc[g_atm_priv_data.aal_desc_pos];
+            if ( ++loop_count == 1000 )
+                break;
+        } while ( reg_desc.own || !reg_desc.c );    //  keep test OWN and C bit until data is ready
+        ASSERT(loop_count == 1, "loop_count = %u, own = %d, c = %d, aal_desc_pos = %u", loop_count, (int)reg_desc.own, (int)reg_desc.c, g_atm_priv_data.aal_desc_pos);
+
+        conn = reg_desc.id;
+
+        if ( g_atm_priv_data.conn[conn].vcc != NULL ) {
+            vcc = g_atm_priv_data.conn[conn].vcc;
+
+            skb = get_skb_rx_pointer(reg_desc.dataptr);
+
+            if ( reg_desc.err ) {
+                if ( vcc->qos.aal == ATM_AAL5 ) {
+                    trailer = (struct rx_inband_trailer *)((unsigned int)skb->data + ((reg_desc.byteoff + reg_desc.datalen + MAX_RX_PACKET_PADDING_BYTES) & ~MAX_RX_PACKET_PADDING_BYTES));
+                    if ( trailer->stw_crc )
+                        g_atm_priv_data.conn[conn].aal5_vcc_crc_err++;
+                    if ( trailer->stw_ovz )
+                        g_atm_priv_data.conn[conn].aal5_vcc_oversize_sdu++;
+                    g_atm_priv_data.wrx_drop_pdu++;
+                }
+                if ( vcc->stats ) {
+                    atomic_inc(&vcc->stats->rx_drop);
+                    atomic_inc(&vcc->stats->rx_err);
+                }
+                reg_desc.err = 0;
+            }
+            else if ( atm_charge(vcc, skb->truesize) ) {
+                new_skb = alloc_skb_rx();
+                if ( new_skb != NULL ) {
+#if defined(ENABLE_LESS_CACHE_INV) && ENABLE_LESS_CACHE_INV
+                    if ( reg_desc.byteoff + reg_desc.datalen > LESS_CACHE_INV_LEN )
+                        dma_cache_sync(NULL, (void *)((unsigned long)skb->data + LESS_CACHE_INV_LEN), reg_desc.byteoff + reg_desc.datalen - LESS_CACHE_INV_LEN, DMA_FROM_DEVICE);
+#endif
+
+                    skb_reserve(skb, reg_desc.byteoff);
+                    skb_put(skb, reg_desc.datalen);
+                    ATM_SKB(skb)->vcc = vcc;
+
+                    dump_skb(skb, DUMP_SKB_LEN, (char *)__func__, 0, conn, 0);
+
+                    vcc->push(vcc, skb);
+
+                    if ( vcc->qos.aal == ATM_AAL5 )
+                        g_atm_priv_data.wrx_pdu++;
+                    if ( vcc->stats )
+                        atomic_inc(&vcc->stats->rx);
+                    adsl_led_flash();
+
+                    reg_desc.dataptr = (unsigned int)new_skb->data >> 2;
+                }
+                else {
+                    atm_return(vcc, skb->truesize);
+                    if ( vcc->qos.aal == ATM_AAL5 )
+                        g_atm_priv_data.wrx_drop_pdu++;
+                    if ( vcc->stats )
+                        atomic_inc(&vcc->stats->rx_drop);
+                }
+            }
+            else {
+                if ( vcc->qos.aal == ATM_AAL5 )
+                    g_atm_priv_data.wrx_drop_pdu++;
+                if ( vcc->stats )
+                    atomic_inc(&vcc->stats->rx_drop);
+            }
+        }
+        else {
+            g_atm_priv_data.wrx_drop_pdu++;
+        }
+
+        reg_desc.byteoff = 0;
+        reg_desc.datalen = RX_DMA_CH_AAL_BUF_SIZE;
+        reg_desc.own = 1;
+        reg_desc.c   = 0;
+
+        g_atm_priv_data.aal_desc[g_atm_priv_data.aal_desc_pos] = reg_desc;
+        if ( ++g_atm_priv_data.aal_desc_pos == dma_rx_descriptor_length )
+            g_atm_priv_data.aal_desc_pos = 0;
+
+        mailbox_signal(RX_DMA_CH_AAL, 0);
+    }
+}
+
+#if defined(ENABLE_TASKLET) && ENABLE_TASKLET
+static void do_ppe_tasklet(unsigned long arg)
+{
+    *MBOX_IGU1_ISRC = *MBOX_IGU1_ISR;
+    mailbox_oam_rx_handler();
+    mailbox_aal_rx_handler();
+    if ( (*MBOX_IGU1_ISR & ((1 << RX_DMA_CH_AAL) | (1 << RX_DMA_CH_OAM))) != 0 )
+        tasklet_schedule(&g_dma_tasklet);
+    else
+        enable_irq(PPE_MAILBOX_IGU1_INT);
+}
+#endif
+
+static irqreturn_t mailbox_irq_handler(int irq, void *dev_id)
+{
+    if ( !*MBOX_IGU1_ISR )
+        return IRQ_HANDLED;
+
+#if defined(ENABLE_TASKLET) && ENABLE_TASKLET
+    disable_irq_nosync(PPE_MAILBOX_IGU1_INT);
+    tasklet_schedule(&g_dma_tasklet);
+#else
+    *MBOX_IGU1_ISRC = *MBOX_IGU1_ISR;
+    mailbox_oam_rx_handler();
+    mailbox_aal_rx_handler();
+#endif
+
+    return IRQ_HANDLED;
+}
+
+static INLINE void mailbox_signal(unsigned int queue, int is_tx)
+{
+    int count = 1000;
+
+    if ( is_tx ) {
+        while ( MBOX_IGU3_ISR_ISR(queue + FIRST_QSB_QID + 16) && count > 0 )
+            count--;
+        *MBOX_IGU3_ISRS = MBOX_IGU3_ISRS_SET(queue + FIRST_QSB_QID + 16);
+    }
+    else {
+        while ( MBOX_IGU3_ISR_ISR(queue) && count > 0 )
+            count--;
+        *MBOX_IGU3_ISRS = MBOX_IGU3_ISRS_SET(queue);
+    }
+
+    ASSERT(count > 0, "queue = %u, is_tx = %d, MBOX_IGU3_ISR = 0x%08x", queue, is_tx, IFX_REG_R32(MBOX_IGU3_ISR));
+}
+
+static void set_qsb(struct atm_vcc *vcc, struct atm_qos *qos, unsigned int queue)
+{
+    unsigned int qsb_clk = ifx_atm_get_qsb_clk();
+    unsigned int qsb_qid = queue + FIRST_QSB_QID;
+    union qsb_queue_parameter_table qsb_queue_parameter_table = {{0}};
+    union qsb_queue_vbr_parameter_table qsb_queue_vbr_parameter_table = {{0}};
+    unsigned int tmp;
+
+#if defined(DEBUG_QOS) && DEBUG_QOS
+    if ( (ifx_atm_dbg_enable & DBG_ENABLE_MASK_DUMP_QOS) ) {
+        static char *str_traffic_class[9] = {
+            "ATM_NONE",
+            "ATM_UBR",
+            "ATM_CBR",
+            "ATM_VBR",
+            "ATM_ABR",
+            "ATM_ANYCLASS",
+            "ATM_VBR_RT",
+            "ATM_UBR_PLUS",
+            "ATM_MAX_PCR"
+        };
+        printk(KERN_INFO  "QoS Parameters:\n");
+        printk(KERN_INFO  "\tAAL          : %d\n", qos->aal);
+        printk(KERN_INFO  "\tTX Traffic Class: %s\n", str_traffic_class[qos->txtp.traffic_class]);
+        printk(KERN_INFO  "\tTX Max PCR      : %d\n", qos->txtp.max_pcr);
+        printk(KERN_INFO  "\tTX Min PCR      : %d\n", qos->txtp.min_pcr);
+        printk(KERN_INFO  "\tTX PCR          : %d\n", qos->txtp.pcr);
+        printk(KERN_INFO  "\tTX Max CDV      : %d\n", qos->txtp.max_cdv);
+        printk(KERN_INFO  "\tTX Max SDU      : %d\n", qos->txtp.max_sdu);
+        printk(KERN_INFO  "\tTX SCR          : %d\n", qos->txtp.scr);
+        printk(KERN_INFO  "\tTX MBS          : %d\n", qos->txtp.mbs);
+        printk(KERN_INFO  "\tTX CDV          : %d\n", qos->txtp.cdv);
+        printk(KERN_INFO  "\tRX Traffic Class: %s\n", str_traffic_class[qos->rxtp.traffic_class]);
+        printk(KERN_INFO  "\tRX Max PCR      : %d\n", qos->rxtp.max_pcr);
+        printk(KERN_INFO  "\tRX Min PCR      : %d\n", qos->rxtp.min_pcr);
+        printk(KERN_INFO  "\tRX PCR          : %d\n", qos->rxtp.pcr);
+        printk(KERN_INFO  "\tRX Max CDV      : %d\n", qos->rxtp.max_cdv);
+        printk(KERN_INFO  "\tRX Max SDU      : %d\n", qos->rxtp.max_sdu);
+        printk(KERN_INFO  "\tRX SCR          : %d\n", qos->rxtp.scr);
+        printk(KERN_INFO  "\tRX MBS          : %d\n", qos->rxtp.mbs);
+        printk(KERN_INFO  "\tRX CDV          : %d\n", qos->rxtp.cdv);
+    }
+#endif  //  defined(DEBUG_QOS) && DEBUG_QOS
+
+    /*
+     *  Peak Cell Rate (PCR) Limiter
+     */
+    if ( qos->txtp.max_pcr == 0 )
+        qsb_queue_parameter_table.bit.tp = 0;   /*  disable PCR limiter */
+    else {
+        /*  peak cell rate would be slightly lower than requested [maximum_rate / pcr = (qsb_clock / 8) * (time_step / 4) / pcr] */
+        tmp = ((qsb_clk * qsb_tstep) >> 5) / qos->txtp.max_pcr + 1;
+        /*  check if overflow takes place   */
+        qsb_queue_parameter_table.bit.tp = tmp > QSB_TP_TS_MAX ? QSB_TP_TS_MAX : tmp;
+    }
+
+#if !defined(DISABLE_QOS_WORKAROUND) || !DISABLE_QOS_WORKAROUND
+    //  A funny issue. Create two PVCs, one UBR and one UBR with max_pcr.
+    //  Send packets to these two PVCs at same time, it trigger strange behavior.
+    //  In A1, RAM from 0x80000000 to 0x0x8007FFFF was corrupted with fixed pattern 0x00000000 0x40000000.
+    //  In A4, PPE firmware keep emiting unknown cell and do not respond to driver.
+    //  To work around, create UBR always with max_pcr.
+    //  If user want to create UBR without max_pcr, we give a default one larger than line-rate.
+    if ( qos->txtp.traffic_class == ATM_UBR && qsb_queue_parameter_table.bit.tp == 0 ) {
+        int port = g_atm_priv_data.conn[queue].port;
+        unsigned int max_pcr = g_atm_priv_data.port[port].tx_max_cell_rate + 1000;
+
+        tmp = ((qsb_clk * qsb_tstep) >> 5) / max_pcr + 1;
+        if ( tmp > QSB_TP_TS_MAX )
+            tmp = QSB_TP_TS_MAX;
+        else if ( tmp < 1 )
+            tmp = 1;
+        qsb_queue_parameter_table.bit.tp = tmp;
+    }
+#endif
+
+    /*
+     *  Weighted Fair Queueing Factor (WFQF)
+     */
+    switch ( qos->txtp.traffic_class ) {
+    case ATM_CBR:
+    case ATM_VBR_RT:
+        /*  real time queue gets weighted fair queueing bypass  */
+        qsb_queue_parameter_table.bit.wfqf = 0;
+        break;
+    case ATM_VBR_NRT:
+    case ATM_UBR_PLUS:
+        /*  WFQF calculation here is based on virtual cell rates, to reduce granularity for high rates  */
+        /*  WFQF is maximum cell rate / garenteed cell rate                                             */
+        /*  wfqf = qsb_minimum_cell_rate * QSB_WFQ_NONUBR_MAX / requested_minimum_peak_cell_rate        */
+        if ( qos->txtp.min_pcr == 0 )
+            qsb_queue_parameter_table.bit.wfqf = QSB_WFQ_NONUBR_MAX;
+        else
+        {
+            tmp = QSB_GCR_MIN * QSB_WFQ_NONUBR_MAX / qos->txtp.min_pcr;
+            if ( tmp == 0 )
+                qsb_queue_parameter_table.bit.wfqf = 1;
+            else if ( tmp > QSB_WFQ_NONUBR_MAX )
+                qsb_queue_parameter_table.bit.wfqf = QSB_WFQ_NONUBR_MAX;
+            else
+                qsb_queue_parameter_table.bit.wfqf = tmp;
+        }
+        break;
+    default:
+    case ATM_UBR:
+        qsb_queue_parameter_table.bit.wfqf = QSB_WFQ_UBR_BYPASS;
+    }
+
+    /*
+     *  Sustained Cell Rate (SCR) Leaky Bucket Shaper VBR.0/VBR.1
+     */
+    if ( qos->txtp.traffic_class == ATM_VBR_RT || qos->txtp.traffic_class == ATM_VBR_NRT ) {
+        if ( qos->txtp.scr == 0 ) {
+            /*  disable shaper  */
+            qsb_queue_vbr_parameter_table.bit.taus = 0;
+            qsb_queue_vbr_parameter_table.bit.ts = 0;
+        }
+        else {
+            /*  Cell Loss Priority  (CLP)   */
+            if ( (vcc->atm_options & ATM_ATMOPT_CLP) )
+                /*  CLP1    */
+                qsb_queue_parameter_table.bit.vbr = 1;
+            else
+                /*  CLP0    */
+                qsb_queue_parameter_table.bit.vbr = 0;
+            /*  Rate Shaper Parameter (TS) and Burst Tolerance Parameter for SCR (tauS) */
+            tmp = ((qsb_clk * qsb_tstep) >> 5) / qos->txtp.scr + 1;
+            qsb_queue_vbr_parameter_table.bit.ts = tmp > QSB_TP_TS_MAX ? QSB_TP_TS_MAX : tmp;
+            tmp = (qos->txtp.mbs - 1) * (qsb_queue_vbr_parameter_table.bit.ts - qsb_queue_parameter_table.bit.tp) / 64;
+            if ( tmp == 0 )
+                qsb_queue_vbr_parameter_table.bit.taus = 1;
+            else if ( tmp > QSB_TAUS_MAX )
+                qsb_queue_vbr_parameter_table.bit.taus = QSB_TAUS_MAX;
+            else
+                qsb_queue_vbr_parameter_table.bit.taus = tmp;
+        }
+    }
+    else {
+        qsb_queue_vbr_parameter_table.bit.taus = 0;
+        qsb_queue_vbr_parameter_table.bit.ts = 0;
+    }
+
+    /*  Queue Parameter Table (QPT) */
+    *QSB_RTM   = QSB_RTM_DM_SET(QSB_QPT_SET_MASK);
+    *QSB_RTD   = QSB_RTD_TTV_SET(qsb_queue_parameter_table.dword);
+    *QSB_RAMAC = QSB_RAMAC_RW_SET(QSB_RAMAC_RW_WRITE) | QSB_RAMAC_TSEL_SET(QSB_RAMAC_TSEL_QPT) | QSB_RAMAC_LH_SET(QSB_RAMAC_LH_LOW) | QSB_RAMAC_TESEL_SET(qsb_qid);
+#if defined(DEBUG_QOS) && DEBUG_QOS
+    if ( (ifx_atm_dbg_enable & DBG_ENABLE_MASK_DUMP_QOS) )
+        printk("QPT: QSB_RTM (%08X) = 0x%08X, QSB_RTD (%08X) = 0x%08X, QSB_RAMAC (%08X) = 0x%08X\n", (unsigned int)QSB_RTM, *QSB_RTM, (unsigned int)QSB_RTD, *QSB_RTD, (unsigned int)QSB_RAMAC, *QSB_RAMAC);
+#endif
+    /*  Queue VBR Paramter Table (QVPT) */
+    *QSB_RTM   = QSB_RTM_DM_SET(QSB_QVPT_SET_MASK);
+    *QSB_RTD   = QSB_RTD_TTV_SET(qsb_queue_vbr_parameter_table.dword);
+    *QSB_RAMAC = QSB_RAMAC_RW_SET(QSB_RAMAC_RW_WRITE) | QSB_RAMAC_TSEL_SET(QSB_RAMAC_TSEL_VBR) | QSB_RAMAC_LH_SET(QSB_RAMAC_LH_LOW) | QSB_RAMAC_TESEL_SET(qsb_qid);
+#if defined(DEBUG_QOS) && DEBUG_QOS
+    if ( (ifx_atm_dbg_enable & DBG_ENABLE_MASK_DUMP_QOS) )
+        printk("QVPT: QSB_RTM (%08X) = 0x%08X, QSB_RTD (%08X) = 0x%08X, QSB_RAMAC (%08X) = 0x%08X\n", (unsigned int)QSB_RTM, *QSB_RTM, (unsigned int)QSB_RTD, *QSB_RTD, (unsigned int)QSB_RAMAC, *QSB_RAMAC);
+#endif
+
+#if defined(DEBUG_QOS) && DEBUG_QOS
+    if ( (ifx_atm_dbg_enable & DBG_ENABLE_MASK_DUMP_QOS) ) {
+        printk("set_qsb\n");
+        printk("  qsb_clk = %lu\n", (unsigned long)qsb_clk);
+        printk("  qsb_queue_parameter_table.bit.tp       = %d\n", (int)qsb_queue_parameter_table.bit.tp);
+        printk("  qsb_queue_parameter_table.bit.wfqf     = %d (0x%08X)\n", (int)qsb_queue_parameter_table.bit.wfqf, (int)qsb_queue_parameter_table.bit.wfqf);
+        printk("  qsb_queue_parameter_table.bit.vbr      = %d\n", (int)qsb_queue_parameter_table.bit.vbr);
+        printk("  qsb_queue_parameter_table.dword        = 0x%08X\n", (int)qsb_queue_parameter_table.dword);
+        printk("  qsb_queue_vbr_parameter_table.bit.ts   = %d\n", (int)qsb_queue_vbr_parameter_table.bit.ts);
+        printk("  qsb_queue_vbr_parameter_table.bit.taus = %d\n", (int)qsb_queue_vbr_parameter_table.bit.taus);
+        printk("  qsb_queue_vbr_parameter_table.dword    = 0x%08X\n", (int)qsb_queue_vbr_parameter_table.dword);
+    }
+#endif
+}
+
+static void qsb_global_set(void)
+{
+    unsigned int qsb_clk = ifx_atm_get_qsb_clk();
+    int i;
+    unsigned int tmp1, tmp2, tmp3;
+
+    *QSB_ICDV = QSB_ICDV_TAU_SET(qsb_tau);
+    *QSB_SBL  = QSB_SBL_SBL_SET(qsb_srvm);
+    *QSB_CFG  = QSB_CFG_TSTEPC_SET(qsb_tstep >> 1);
+#if defined(DEBUG_QOS) && DEBUG_QOS
+    if ( (ifx_atm_dbg_enable & DBG_ENABLE_MASK_DUMP_QOS) ) {
+        printk("qsb_clk = %u\n", qsb_clk);
+        printk("QSB_ICDV (%08X) = %d (%d), QSB_SBL (%08X) = %d (%d), QSB_CFG (%08X) = %d (%d)\n", (unsigned int)QSB_ICDV, *QSB_ICDV, QSB_ICDV_TAU_SET(qsb_tau), (unsigned int)QSB_SBL, *QSB_SBL, QSB_SBL_SBL_SET(qsb_srvm), (unsigned int)QSB_CFG, *QSB_CFG, QSB_CFG_TSTEPC_SET(qsb_tstep >> 1));
+    }
+#endif
+
+    /*
+     *  set SCT and SPT per port
+     */
+    for ( i = 0; i < ATM_PORT_NUMBER; i++ ) {
+        if ( g_atm_priv_data.port[i].tx_max_cell_rate != 0 ) {
+            tmp1 = ((qsb_clk * qsb_tstep) >> 1) / g_atm_priv_data.port[i].tx_max_cell_rate;
+            tmp2 = tmp1 >> 6;                   /*  integer value of Tsb    */
+            tmp3 = (tmp1 & ((1 << 6) - 1)) + 1; /*  fractional part of Tsb  */
+            /*  carry over to integer part (?)  */
+            if ( tmp3 == (1 << 6) )
+            {
+                tmp3 = 0;
+                tmp2++;
+            }
+            if ( tmp2 == 0 )
+                tmp2 = tmp3 = 1;
+            /*  1. set mask                                 */
+            /*  2. write value to data transfer register    */
+            /*  3. start the tranfer                        */
+            /*  SCT (FracRate)  */
+            *QSB_RTM   = QSB_RTM_DM_SET(QSB_SET_SCT_MASK);
+            *QSB_RTD   = QSB_RTD_TTV_SET(tmp3);
+            *QSB_RAMAC = QSB_RAMAC_RW_SET(QSB_RAMAC_RW_WRITE) | QSB_RAMAC_TSEL_SET(QSB_RAMAC_TSEL_SCT) | QSB_RAMAC_LH_SET(QSB_RAMAC_LH_LOW) | QSB_RAMAC_TESEL_SET(i & 0x01);
+#if defined(DEBUG_QOS) && DEBUG_QOS
+            if ( (ifx_atm_dbg_enable & DBG_ENABLE_MASK_DUMP_QOS) )
+                printk("SCT: QSB_RTM (%08X) = 0x%08X, QSB_RTD (%08X) = 0x%08X, QSB_RAMAC (%08X) = 0x%08X\n", (unsigned int)QSB_RTM, *QSB_RTM, (unsigned int)QSB_RTD, *QSB_RTD, (unsigned int)QSB_RAMAC, *QSB_RAMAC);
+#endif
+            /*  SPT (SBV + PN + IntRage)    */
+            *QSB_RTM   = QSB_RTM_DM_SET(QSB_SET_SPT_MASK);
+            *QSB_RTD   = QSB_RTD_TTV_SET(QSB_SPT_SBV_VALID | QSB_SPT_PN_SET(i & 0x01) | QSB_SPT_INTRATE_SET(tmp2));
+            *QSB_RAMAC = QSB_RAMAC_RW_SET(QSB_RAMAC_RW_WRITE) | QSB_RAMAC_TSEL_SET(QSB_RAMAC_TSEL_SPT) | QSB_RAMAC_LH_SET(QSB_RAMAC_LH_LOW) | QSB_RAMAC_TESEL_SET(i & 0x01);
+#if defined(DEBUG_QOS) && DEBUG_QOS
+            if ( (ifx_atm_dbg_enable & DBG_ENABLE_MASK_DUMP_QOS) )
+                printk("SPT: QSB_RTM (%08X) = 0x%08X, QSB_RTD (%08X) = 0x%08X, QSB_RAMAC (%08X) = 0x%08X\n", (unsigned int)QSB_RTM, *QSB_RTM, (unsigned int)QSB_RTD, *QSB_RTD, (unsigned int)QSB_RAMAC, *QSB_RAMAC);
+#endif
+        }
+    }
+}
+
+static INLINE void set_htu_entry(unsigned int vpi, unsigned int vci, unsigned int queue, int aal5, int is_retx)
+{
+    struct htu_entry htu_entry = {  res1:       0x00,
+                                    clp:        is_retx ? 0x01 : 0x00,
+                                    pid:        g_atm_priv_data.conn[queue].port & 0x01,
+                                    vpi:        vpi,
+                                    vci:        vci,
+                                    pti:        0x00,
+                                    vld:        0x01};
+
+    struct htu_mask htu_mask = {    set:        0x01,
+#if !defined(ENABLE_ATM_RETX) || !ENABLE_ATM_RETX
+                                    clp:        0x01,
+                                    pid_mask:   0x02,
+#else
+                                    clp:        g_retx_htu ? 0x00 : 0x01,
+                                    pid_mask:   RETX_MODE_CFG->retx_en ? 0x03 : 0x02,
+#endif
+                                    vpi_mask:   0x00,
+#if !defined(ENABLE_ATM_RETX) || !ENABLE_ATM_RETX
+                                    vci_mask:   0x0000,
+#else
+                                    vci_mask:   RETX_MODE_CFG->retx_en ? 0xFF00 : 0x0000,
+#endif
+                                    pti_mask:   0x03,   //  0xx, user data
+                                    clear:      0x00};
+
+    struct htu_result htu_result = {res1:       0x00,
+                                    cellid:     queue,
+                                    res2:       0x00,
+                                    type:       aal5 ? 0x00 : 0x01,
+                                    ven:        0x01,
+                                    res3:       0x00,
+                                    qid:        queue};
+
+    *HTU_RESULT(queue + OAM_HTU_ENTRY_NUMBER) = htu_result;
+    *HTU_MASK(queue + OAM_HTU_ENTRY_NUMBER)   = htu_mask;
+    *HTU_ENTRY(queue + OAM_HTU_ENTRY_NUMBER)  = htu_entry;
+}
+
+static INLINE void clear_htu_entry(unsigned int queue)
+{
+    HTU_ENTRY(queue + OAM_HTU_ENTRY_NUMBER)->vld = 0;
+}
+
+static void validate_oam_htu_entry(void)
+{
+    HTU_ENTRY(OAM_F4_SEG_HTU_ENTRY)->vld = 1;
+    HTU_ENTRY(OAM_F4_TOT_HTU_ENTRY)->vld = 1;
+    HTU_ENTRY(OAM_F5_HTU_ENTRY)->vld = 1;
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+    HTU_ENTRY(OAM_ARQ_HTU_ENTRY)->vld = 1;
+#endif
+}
+
+static void invalidate_oam_htu_entry(void)
+{
+    HTU_ENTRY(OAM_F4_SEG_HTU_ENTRY)->vld = 0;
+    HTU_ENTRY(OAM_F4_TOT_HTU_ENTRY)->vld = 0;
+    HTU_ENTRY(OAM_F5_HTU_ENTRY)->vld = 0;
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+    HTU_ENTRY(OAM_ARQ_HTU_ENTRY)->vld = 0;
+#endif
+}
+
+static INLINE int find_vpi(unsigned int vpi)
+{
+    int i;
+    unsigned int bit;
+
+    for ( i = 0, bit = 1; i < MAX_PVC_NUMBER; i++, bit <<= 1 ) {
+        if ( (g_atm_priv_data.conn_table & bit) != 0
+            && g_atm_priv_data.conn[i].vcc != NULL
+            && vpi == g_atm_priv_data.conn[i].vcc->vpi )
+            return i;
+    }
+
+    return -1;
+}
+
+static INLINE int find_vpivci(unsigned int vpi, unsigned int vci)
+{
+    int i;
+    unsigned int bit;
+
+    for ( i = 0, bit = 1; i < MAX_PVC_NUMBER; i++, bit <<= 1 ) {
+        if ( (g_atm_priv_data.conn_table & bit) != 0
+            && g_atm_priv_data.conn[i].vcc != NULL
+            && vpi == g_atm_priv_data.conn[i].vcc->vpi
+            && vci == g_atm_priv_data.conn[i].vcc->vci )
+            return i;
+    }
+
+    return -1;
+}
+
+static INLINE int find_vcc(struct atm_vcc *vcc)
+{
+    int i;
+    unsigned int bit;
+
+    for ( i = 0, bit = 1; i < MAX_PVC_NUMBER; i++, bit <<= 1 ) {
+        if ( (g_atm_priv_data.conn_table & bit) != 0
+            && g_atm_priv_data.conn[i].vcc == vcc )
+            return i;
+    }
+
+    return -1;
+}
+
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+
+static void retx_polling_func(unsigned long arg)
+{
+    unsigned long sys_flag;
+    volatile struct dsl_param *p_dsl_param;
+    int new_retx_htu;
+    int retx_en;
+    int i, max_htu;
+
+    local_irq_save(sys_flag);
+    if ( g_retx_playout_buffer == 0 && g_xdata_addr != NULL && (((volatile struct dsl_param *)g_xdata_addr)->RetxEnable || ((volatile struct dsl_param *)g_xdata_addr)->ServiceSpecificReTx) ) {
+        local_irq_restore(sys_flag);
+        g_retx_playout_buffer = __get_free_pages(GFP_KERNEL, RETX_PLAYOUT_BUFFER_ORDER);
+        if ( g_retx_playout_buffer == 0 )
+            panic("no memory for g_retx_playout_buffer\n");
+        memset((void *)g_retx_playout_buffer, 0, RETX_PLAYOUT_BUFFER_SIZE);
+        dma_cache_sync(NULL, g_retx_playout_buffer, RETX_PLAYOUT_BUFFER_SIZE, DMA_FROM_DEVICE);
+    }
+    else
+        local_irq_restore(sys_flag);
+
+
+    local_irq_save(sys_flag);
+    if ( g_xdata_addr != NULL ) {
+        p_dsl_param = (volatile struct dsl_param *)g_xdata_addr;
+        g_retx_polling_cnt += RETX_POLLING_INTERVAL;
+
+        if ( p_dsl_param->update_flag ) {
+            do_gettimeofday(&g_retx_polling_start);
+
+            g_dsl_param = *p_dsl_param;
+
+            // we always enable retx (just for test purpose)
+            //g_dsl_param.RetxEnable = 1;
+            //RETX_TSYNC_CFG->fw_alpha = 0;
+
+            if ( g_dsl_param.RetxEnable || g_dsl_param.ServiceSpecificReTx ) {
+                //  ReTX enabled
+                // MIB counter updated for each polling
+                p_dsl_param->RxDtuCorruptedCNT          = *RxDTUCorruptedCNT;
+                p_dsl_param->RxRetxDtuUnCorrectedCNT    = *RxRetxDTUUncorrectedCNT;
+                p_dsl_param->RxLastEFB                  = *RxLastEFBCNT;
+                p_dsl_param->RxDtuCorrectedCNT          = *RxDTUCorrectedCNT;
+
+                // for RETX paramters, we check only once for every second
+                if ( g_retx_polling_cnt < HZ )
+                    goto _clear_update_flag;
+
+                g_retx_polling_cnt -= HZ;
+
+                if ( g_dsl_param.ServiceSpecificReTx && g_dsl_param.ReTxPVC == 0 )
+                    new_retx_htu = 1;
+                else
+                    new_retx_htu = 0;
+
+                // default fw_alpha equals to default hardware alpha
+                RETX_TSYNC_CFG->fw_alpha    = 0;
+
+                RETX_TD_CFG->td_max         = g_dsl_param.MaxDelayrt;
+                RETX_TD_CFG->td_min         = g_dsl_param.MinDelayrt;
+
+                //*RETX_PLAYOUT_BUFFER_BASE   = ((((unsigned int)g_retx_playout_buffer | KSEG1) + 15) & 0xFFFFFFF0) >> 2;
+                *RETX_PLAYOUT_BUFFER_BASE   = (((unsigned int)g_retx_playout_buffer + 15) & 0x1FFFFFF0) >> 2;
+
+                if ( g_dsl_param.ServiceSpecificReTx ) {
+                    *RETX_SERVICE_HEADER_CFG= g_dsl_param.ReTxPVC << 4;
+                    if ( g_dsl_param.ReTxPVC == 0 )
+                        *RETX_MASK_HEADER_CFG = 1;
+                    else
+                        *RETX_MASK_HEADER_CFG = 0;
+                }
+                else {
+                    *RETX_SERVICE_HEADER_CFG= 0;
+                    *RETX_MASK_HEADER_CFG   = 0;
+                }
+
+                retx_en = 1;
+            }
+            else {
+                //  ReTX disabled
+
+                new_retx_htu = 0;
+
+                RETX_TSYNC_CFG->fw_alpha    = 7;
+
+                *RETX_SERVICE_HEADER_CFG    = 0;
+                *RETX_MASK_HEADER_CFG       = 0;
+
+                retx_en = 0;
+            }
+
+
+            if ( retx_en != RETX_MODE_CFG->retx_en ) {
+                unsigned int pid_mask, vci_mask;
+
+                if ( retx_en ) {
+                    pid_mask = 0x03;
+                    vci_mask = 0xFF00;
+                }
+                else {
+                    pid_mask = 0x02;
+                    vci_mask = 0x0000;
+                }
+
+                max_htu = *CFG_WRX_HTUTS;
+                for ( i = OAM_HTU_ENTRY_NUMBER; i < max_htu; i++ )
+                    if ( HTU_ENTRY(i)->vld ) {
+                        HTU_MASK(i)->pid_mask = pid_mask;
+                        HTU_MASK(i)->vci_mask = vci_mask;
+                    }
+            }
+
+            if ( new_retx_htu != g_retx_htu ) {
+                int conn, retx_conn;
+
+                g_retx_htu = new_retx_htu;
+
+                if ( g_retx_htu ) {
+                    max_htu = *CFG_WRX_HTUTS;
+                    for ( i = OAM_HTU_ENTRY_NUMBER; i < max_htu; i++ )
+                        if ( HTU_ENTRY(i)->vld )
+                            HTU_MASK(i)->clp = 0;
+
+                    for ( conn = 0; conn < MAX_PVC_NUMBER; conn++ )
+                        if ( g_atm_priv_data.conn[conn].vcc && g_atm_priv_data.conn[conn].vcc->qos.aal == ATM_AAL5 && !HTU_ENTRY(conn + OAM_HTU_ENTRY_NUMBER)->clp ) {
+                            retx_conn = (conn + 8) % 16;    //  ReTX queue
+
+                            if ( retx_conn < MAX_PVC_NUMBER && test_and_set_bit(retx_conn, &g_atm_priv_data.conn_table) == 0 ) {
+                                g_atm_priv_data.conn[retx_conn].vcc = g_atm_priv_data.conn[conn].vcc;
+                                set_htu_entry(g_atm_priv_data.conn[conn].vcc->vpi, g_atm_priv_data.conn[conn].vcc->vci, retx_conn, g_atm_priv_data.conn[conn].vcc->qos.aal == ATM_AAL5 ? 1 : 0, 1);
+                            }
+                            else {
+                                err("Queue number %d for ReTX queue of PVC(%d.%d) is not available!", retx_conn, g_atm_priv_data.conn[conn].vcc->vpi, g_atm_priv_data.conn[conn].vcc->vci);
+                            }
+                        }
+                }
+                else
+                {
+                    for ( retx_conn = 0; retx_conn < MAX_PVC_NUMBER; retx_conn++ )
+                        if ( g_atm_priv_data.conn[retx_conn].vcc && HTU_ENTRY(retx_conn + OAM_HTU_ENTRY_NUMBER)->clp ) {
+                            clear_htu_entry(retx_conn);
+                            g_atm_priv_data.conn[retx_conn].vcc = NULL;
+                            g_atm_priv_data.conn[retx_conn].aal5_vcc_crc_err = 0;
+                            g_atm_priv_data.conn[retx_conn].aal5_vcc_oversize_sdu = 0;
+                            clear_bit(retx_conn, &g_atm_priv_data.conn_table);
+                        }
+
+                    max_htu = *CFG_WRX_HTUTS;
+                    for ( i = OAM_HTU_ENTRY_NUMBER; i < max_htu; i++ )
+                        if ( HTU_ENTRY(i)->vld )
+                            HTU_MASK(i)->clp = 1;
+                }
+            }
+
+            RETX_MODE_CFG->retx_en = retx_en;
+
+_clear_update_flag:
+            p_dsl_param->update_flag = 0;
+
+            do_gettimeofday(&g_retx_polling_end);
+        }
+
+        g_retx_polling_timer.expires = jiffies + RETX_POLLING_INTERVAL;
+        add_timer(&g_retx_polling_timer);
+    }
+    local_irq_restore(sys_flag);
+}
+
+static int init_atm_tc_retrans_param(void)
+{
+    int i = 0;
+    struct DTU_stat_info reset_val;
+
+    RETX_MODE_CFG->invld_range  = 128;
+    RETX_MODE_CFG->buff_size    = RETX_PLAYOUT_FW_BUFF_SIZE > 4096/32 ? 4096/32 : RETX_PLAYOUT_FW_BUFF_SIZE ;
+    RETX_MODE_CFG->retx_en      = 0;    //  disable ReTX by default
+
+    // default fw_alpha equals to default hardware alpha
+    RETX_TSYNC_CFG->fw_alpha    = 7;
+    RETX_TSYNC_CFG->sync_inp    = 0;
+
+    RETX_TD_CFG->td_max         = 0;
+    RETX_TD_CFG->td_min         = 0;
+
+    //*RETX_PLAYOUT_BUFFER_BASE = KSEG1ADDR(g_retx_playout_buffer); //  need " >> 2 " ?
+    //*RETX_PLAYOUT_BUFFER_BASE = ((((unsigned int)g_retx_playout_buffer | KSEG1) + 15) & 0xFFFFFFF0) >> 2;
+    *RETX_PLAYOUT_BUFFER_BASE   = (((unsigned int)g_retx_playout_buffer + 15) & 0x1FFFFFF0) >> 2;
+
+    *RETX_SERVICE_HEADER_CFG    = 0;
+    *RETX_MASK_HEADER_CFG       = 0;
+
+    // 20us
+#define PP32_TICK_INTERVAL      20
+#define PP32_TICK_DIVIDER       (1000000 / 20)
+    RETX_MIB_TIMER_CFG->tick_cycle = (cgu_get_pp32_clock() + PP32_TICK_DIVIDER / 2) / PP32_TICK_DIVIDER;
+    RETX_MIB_TIMER_CFG->ticks_per_sec = 50000;
+
+    *LAST_DTU_SID_IN            = 255;
+    *RFBI_FIRST_CW              = 1;
+    // init DTU_STAT_INFO
+
+    memset(&reset_val, 0, sizeof(reset_val));
+    reset_val.dtu_rd_ptr = reset_val.dtu_wr_ptr = 0xffff;
+
+    for(i = 0 ; i < 256; i ++) {
+        DTU_STAT_INFO[i] = reset_val;
+    }
+    return 0;
+}
+
+static void clear_atm_tc_retrans_param(void)
+{
+    if ( g_retx_playout_buffer ) {
+        free_pages(g_retx_playout_buffer, RETX_PLAYOUT_BUFFER_ORDER);
+        g_retx_playout_buffer = 0;
+    }
+}
+
+#endif
+
+#if defined(DEBUG_DUMP_SKB) && DEBUG_DUMP_SKB
+static void dump_skb(struct sk_buff *skb, unsigned int len, char *title, int port, int ch, int is_tx)
+{
+    int i;
+
+    if ( !(ifx_atm_dbg_enable & (is_tx ? DBG_ENABLE_MASK_DUMP_SKB_TX : DBG_ENABLE_MASK_DUMP_SKB_RX)) )
+        return;
+
+    if ( skb->len < len )
+        len = skb->len;
+
+    if ( len > RX_DMA_CH_AAL_BUF_SIZE ) {
+        printk("too big data length: skb = %08x, skb->data = %08x, skb->len = %d\n", (unsigned int)skb, (unsigned int)skb->data, skb->len);
+        return;
+    }
+
+    if ( ch >= 0 )
+        printk("%s (port %d, ch %d)\n", title, port, ch);
+    else
+        printk("%s\n", title);
+    printk("  skb->data = %08X, skb->tail = %08X, skb->len = %d\n", (unsigned int)skb->data, (unsigned int)skb->tail, (int)skb->len);
+    for ( i = 1; i <= len; i++ ) {
+        if ( i % 16 == 1 )
+            printk("  %4d:", i - 1);
+        printk(" %02X", (int)(*((char*)skb->data + i - 1) & 0xFF));
+        if ( i % 16 == 0 )
+            printk("\n");
+    }
+    if ( (i - 1) % 16 != 0 )
+        printk("\n");
+}
+#endif
+
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+static void skb_swap(struct sk_buff *skb, unsigned int byteoff)
+{
+    unsigned int mac_offset = ~0;
+    unsigned int ip_offset = ~0;
+    unsigned char tmp[8];
+    unsigned char *p = NULL;
+
+    skb_pull(skb, byteoff + TX_INBAND_HEADER_LENGTH);
+
+    if ( skb->data[0] == 0xAA && skb->data[1] == 0xAA && skb->data[2] == 0x03 ) {
+        //  LLC
+        if ( skb->data[3] == 0x00 && skb->data[4] == 0x80 && skb->data[5] == 0xC2 ) {
+            //  EoA
+            if ( skb->data[22] == 0x08 && skb->data[23] == 0x00 ) {
+                //  IPv4
+                mac_offset = 10;
+                ip_offset = 24;
+            }
+            else if ( skb->data[31] == 0x21 ) {
+                //  PPPoE IPv4
+                mac_offset = 10;
+                ip_offset = 32;
+            }
+        }
+        else {
+            //  IPoA
+            if ( skb->data[6] == 0x08 && skb->data[7] == 0x00 ) {
+                //  IPv4
+                ip_offset = 8;
+            }
+        }
+    }
+    else if ( skb->data[0] == 0xFE && skb->data[1] == 0xFE && skb->data[2] == 0x03 ) {
+        //  LLC PPPoA
+        if ( skb->data[4] == 0x00 && skb->data[5] == 0x21 ) {
+            //  IPv4
+            ip_offset = 6;
+        }
+    }
+    else {
+        //  VC-mux
+        if ( skb->data[0] == 0x00 && skb->data[1] == 0x21 ) {
+            //  PPPoA IPv4
+            ip_offset = 2;
+        }
+        else if ( skb->data[0] == 0x00 && skb->data[1] == 0x00 ) {
+            //  EoA
+            if ( skb->data[14] == 0x08 && skb->data[15] ==0x00 ) {
+                //  IPv4
+                mac_offset = 2;
+                ip_offset = 16;
+            }
+            else if ( skb->data[23] == 0x21 ) {
+                //  PPPoE IPv4
+                mac_offset = 2;
+                ip_offset = 26;
+            }
+        }
+        else {
+            //  IPoA
+            ip_offset = 0;
+        }
+    }
+
+    if ( mac_offset != ~0 && !(skb->data[mac_offset] & 0x01) ) {
+        p = skb->data + mac_offset;
+        //  swap MAC
+        memcpy(tmp, p, 6);
+        memcpy(p, p + 6, 6);
+        memcpy(p + 6, tmp, 6);
+        p += 12;
+    }
+
+    if ( ip_offset != ~0 ) {
+        p = skb->data + ip_offset + 12;
+        //  swap IP
+        memcpy(tmp, p, 4);
+        memcpy(p, p + 4, 4);
+        memcpy(p + 4, tmp, 4);
+        p += 8;
+    }
+
+    if ( p != NULL ) {
+        dma_cache_sync(NULL, skb->data, (unsigned long)p - (unsigned long)skb->data, DMA_TO_DEVICE);
+    }
+
+    skb_push(skb, byteoff + TX_INBAND_HEADER_LENGTH);
+}
+#endif
+
+static INLINE void proc_file_create(void)
+{
+    struct proc_dir_entry *res;
+
+    g_atm_dir = proc_mkdir("driver/ifx_atm", NULL);
+
+    create_proc_read_entry("version",
+                           0,
+                           g_atm_dir,
+                           proc_read_version,
+                           NULL);
+
+    res = create_proc_entry("mib",
+                            0,
+                            g_atm_dir);
+    if ( res != NULL ) {
+       res->read_proc  = proc_read_mib;
+       res->write_proc = proc_write_mib;
+    }
+
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+    res = create_proc_entry("retx_mib",
+                            0,
+                            g_atm_dir);
+    if ( res != NULL ) {
+       res->read_proc  = proc_read_retx_mib;
+       res->write_proc = proc_write_retx_mib;
+    }
+#endif
+
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+    res = create_proc_entry("dbg",
+                            0,
+                            g_atm_dir);
+    if ( res != NULL ) {
+       res->read_proc  = proc_read_dbg;
+       res->write_proc = proc_write_dbg;
+    }
+
+    res = create_proc_entry("mem",
+                            0,
+                            g_atm_dir);
+    if ( res != NULL )
+       res->write_proc = proc_write_mem;
+
+ #if defined(CONFIG_AR9) || defined(CONFIG_LTQ_ATM_XRX200) || defined(CONFIG_DANUBE) || defined(CONFIG_AMAZON_SE) || defined(CONFIG_LTQ_ATM_XRX300)
+    res = create_proc_entry("pp32",
+                            0,
+                            g_atm_dir);
+    if ( res != NULL ) {
+       res->read_proc  = proc_read_pp32;
+       res->write_proc = proc_write_pp32;
+    }
+ #endif
+#endif
+
+#if defined(ENABLE_FW_PROC) && ENABLE_FW_PROC
+    create_proc_read_entry("htu",
+                            0,
+                            g_atm_dir,
+                            proc_read_htu,
+                            NULL);
+
+    create_proc_read_entry("txq",
+                           0,
+                           g_atm_dir,
+                           proc_read_txq,
+                           NULL);
+
+ #if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+    create_proc_read_entry("retx_fw",
+                           0,
+                           g_atm_dir,
+                           proc_read_retx_fw,
+                           NULL);
+
+    res = create_proc_entry("retx_stats",
+                            0,
+                            g_atm_dir);
+    if ( res != NULL ) {
+        res->read_proc  = proc_read_retx_stats;
+        res->write_proc = proc_write_retx_stats;
+    }
+
+    res = create_proc_entry("retx_cfg",
+                            0,
+                            g_atm_dir);
+    if ( res != NULL ) {
+        res->read_proc  = proc_read_retx_cfg;
+        res->write_proc = proc_write_retx_cfg;
+    }
+
+    create_proc_read_entry("retx_dsl_param",
+                            0,
+                            g_atm_dir,
+                            proc_read_retx_dsl_param,
+                            NULL);
+ #endif
+#endif
+}
+
+static INLINE void proc_file_delete(void)
+{
+#if defined(ENABLE_FW_PROC) && ENABLE_FW_PROC
+ #if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+    remove_proc_entry("retx_dsl_param", g_atm_dir);
+
+    remove_proc_entry("retx_cfg", g_atm_dir);
+
+    remove_proc_entry("retx_stats", g_atm_dir);
+
+    remove_proc_entry("retx_fw", g_atm_dir);
+ #endif
+
+    remove_proc_entry("txq", g_atm_dir);
+
+    remove_proc_entry("htu", g_atm_dir);
+#endif
+
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+ #if defined(CONFIG_AR9) || defined(CONFIG_LTQ_ATM_XRX200) || defined(CONFIG_DANUBE) || defined(CONFIG_AMAZON_SE) || defined(CONFIG_LTQ_ATM_XRX300)
+    remove_proc_entry("pp32", g_atm_dir);
+ #endif
+
+    remove_proc_entry("mem", g_atm_dir);
+
+    remove_proc_entry("dbg", g_atm_dir);
+#endif
+
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+    remove_proc_entry("retx_mib", g_atm_dir);
+#endif
+
+    remove_proc_entry("mib", g_atm_dir);
+
+    remove_proc_entry("version", g_atm_dir);
+
+    remove_proc_entry("driver/ifx_atm", NULL);
+}
+
+static int proc_read_version(char *buf, char **start, off_t offset, int count, int *eof, void *data)
+{
+    int len = 0;
+
+    len += ifx_atm_version(buf + len);
+
+    if ( offset >= len ) {
+        *start = buf;
+        *eof = 1;
+        return 0;
+    }
+    *start = buf + offset;
+    if ( (len -= offset) > count )
+        return count;
+    *eof = 1;
+    return len;
+}
+
+static int proc_read_mib(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int len = 0;
+
+    len += sprintf(page + off + len,    "Firmware\n");
+    len += sprintf(page + off + len,    "  wrx_drophtu_cell = %u\n", WAN_MIB_TABLE->wrx_drophtu_cell);
+    len += sprintf(page + off + len,    "  wrx_dropdes_pdu  = %u\n", WAN_MIB_TABLE->wrx_dropdes_pdu);
+    len += sprintf(page + off + len,    "  wrx_correct_pdu  = %u\n", WAN_MIB_TABLE->wrx_correct_pdu);
+    len += sprintf(page + off + len,    "  wrx_err_pdu      = %u\n", WAN_MIB_TABLE->wrx_err_pdu);
+    len += sprintf(page + off + len,    "  wrx_dropdes_cell = %u\n", WAN_MIB_TABLE->wrx_dropdes_cell);
+    len += sprintf(page + off + len,    "  wrx_correct_cell = %u\n", WAN_MIB_TABLE->wrx_correct_cell);
+    len += sprintf(page + off + len,    "  wrx_err_cell     = %u\n", WAN_MIB_TABLE->wrx_err_cell);
+    len += sprintf(page + off + len,    "  wrx_total_byte   = %u\n", WAN_MIB_TABLE->wrx_total_byte);
+    len += sprintf(page + off + len,    "  wtx_total_pdu    = %u\n", WAN_MIB_TABLE->wtx_total_pdu);
+    len += sprintf(page + off + len,    "  wtx_total_cell   = %u\n", WAN_MIB_TABLE->wtx_total_cell);
+    len += sprintf(page + off + len,    "  wtx_total_byte   = %u\n", WAN_MIB_TABLE->wtx_total_byte);
+    len += sprintf(page + off + len,    "Driver\n");
+    len += sprintf(page + off + len,    "  wrx_pdu      = %u\n", g_atm_priv_data.wrx_pdu);
+    len += sprintf(page + off + len,    "  wrx_drop_pdu = %u\n", g_atm_priv_data.wrx_drop_pdu);
+    len += sprintf(page + off + len,    "  wtx_pdu      = %u\n", g_atm_priv_data.wtx_pdu);
+    len += sprintf(page + off + len,    "  wtx_err_pdu  = %u\n", g_atm_priv_data.wtx_err_pdu);
+    len += sprintf(page + off + len,    "  wtx_drop_pdu = %u\n", g_atm_priv_data.wtx_drop_pdu);
+    len += sprintf(page + off + len,    "  wrx_oam      = %u\n", g_atm_priv_data.wrx_oam);
+    len += sprintf(page + off + len,    "  wrx_drop_oam = %u\n", g_atm_priv_data.wrx_drop_oam);
+    len += sprintf(page + off + len,    "  wtx_oam      = %u\n", g_atm_priv_data.wtx_oam);
+    len += sprintf(page + off + len,    "  wtx_err_oam  = %u\n", g_atm_priv_data.wtx_err_oam);
+    len += sprintf(page + off + len,    "  wtx_drop_oam = %u\n", g_atm_priv_data.wtx_drop_oam);
+
+    *eof = 1;
+
+    return len;
+}
+
+static int proc_write_mib(struct file *file, const char *buf, unsigned long count, void *data)
+{
+    char str[2048];
+    char *p;
+    int len, rlen;
+
+    len = count < sizeof(str) ? count : sizeof(str) - 1;
+    rlen = len - copy_from_user(str, buf, len);
+    while ( rlen && str[rlen - 1] <= ' ' )
+        rlen--;
+    str[rlen] = 0;
+    for ( p = str; *p && *p <= ' '; p++, rlen-- );
+    if ( !*p )
+        return 0;
+
+    if ( stricmp(p, "clear") == 0 || stricmp(p, "clear all") == 0
+        || stricmp(p, "clean") == 0 || stricmp(p, "clean all") == 0 ) {
+        memset(WAN_MIB_TABLE, 0, sizeof(*WAN_MIB_TABLE));
+        g_atm_priv_data.wrx_pdu      = 0;
+        g_atm_priv_data.wrx_drop_pdu = 0;
+        g_atm_priv_data.wtx_pdu      = 0;
+        g_atm_priv_data.wtx_err_pdu  = 0;
+        g_atm_priv_data.wtx_drop_pdu = 0;
+        g_atm_priv_data.wrx_oam      = 0;
+        g_atm_priv_data.wrx_drop_oam = 0;
+        g_atm_priv_data.wtx_oam      = 0;
+        g_atm_priv_data.wtx_err_oam  = 0;
+        g_atm_priv_data.wtx_drop_oam = 0;
+    }
+
+    return count;
+}
+
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+
+static int proc_read_retx_mib(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int len = 0;
+
+    printk("Retx FW DTU MIB :\n");
+    printk("  rx_total_dtu            = %u\n", *URETX_RX_TOTAL_DTU);
+    printk("  rx_bad_dtu              = %u\n", *URETX_RX_BAD_DTU);
+    printk("  rx_good_dtu             = %u\n", *URETX_RX_GOOD_DTU);
+    printk("  rx_corrected_dtu        = %u\n", *URETX_RX_CORRECTED_DTU);
+    printk("  rx_outofdate_dtu        = %u\n", *URETX_RX_OUTOFDATE_DTU);
+    printk("  rx_duplicate_dtu        = %u\n", *URETX_RX_DUPLICATE_DTU);
+    printk("  rx_timeout_dtu          = %u\n", *URETX_RX_TIMEOUT_DTU);
+    printk("  RxDTURetransmittedCNT   = %u\n", *RxDTURetransmittedCNT);
+    printk("\n");
+
+    printk("Retx Standard DTU MIB:\n");
+    printk("  RxLastEFB               = %u\n", *RxLastEFBCNT);
+    printk("  RxDTUCorrectedCNT       = %u\n", *RxDTUCorrectedCNT);
+    printk("  RxDTUCorruptedCNT       = %u\n", *RxDTUCorruptedCNT);
+    printk("  RxRetxDTUUncorrectedCNT = %u\n", *RxRetxDTUUncorrectedCNT);
+    printk("\n");
+
+    printk("Retx FW Cell MIB :\n");
+    printk("  bc0_total_cell          = %u\n", *WRX_BC0_CELL_NUM);
+    printk("  bc0_drop_cell           = %u\n", *WRX_BC0_DROP_CELL_NUM);
+    printk("  bc0_nonretx_cell        = %u\n", *WRX_BC0_NONRETX_CELL_NUM);
+    printk("  bc0_retx_cell           = %u\n", *WRX_BC0_RETX_CELL_NUM);
+    printk("  bc0_outofdate_cell      = %u\n", *WRX_BC0_OUTOFDATE_CELL_NUM);
+    printk("  bc0_directup_cell       = %u\n", *WRX_BC0_DIRECTUP_NUM);
+    printk("  bc0_to_pb_total_cell    = %u\n", *WRX_BC0_PBW_TOTAL_NUM);
+    printk("  bc0_to_pb_succ_cell     = %u\n", *WRX_BC0_PBW_SUCC_NUM);
+    printk("  bc0_to_pb_fail_cell     = %u\n", *WRX_BC0_PBW_FAIL_NUM);
+    printk("  bc1_total_cell          = %u\n", *WRX_BC1_CELL_NUM);
+
+    printk("\n");
+
+    printk("ATM Rx AAL5/OAM MIB:\n");
+    printk("  wrx_drophtu_cell  = %u\n", WAN_MIB_TABLE->wrx_drophtu_cell);
+    printk("  wrx_dropdes_pdu   = %u\n", WAN_MIB_TABLE->wrx_dropdes_pdu);
+
+    printk("  wrx_correct_pdu   = %-10u  ", WAN_MIB_TABLE->wrx_correct_pdu);
+    if ( WAN_MIB_TABLE->wrx_correct_pdu == 0 )
+        printk("\n");
+    else {
+        int i = 0;
+
+        printk("[ ");
+        for ( i = 0; i < 16; ++i ) {
+            if ( WRX_PER_PVC_CORRECT_PDU_BASE[i] )
+                printk("q%-2d = %-10u , ", i, WRX_PER_PVC_CORRECT_PDU_BASE[i]);
+        }
+        printk("]\n");
+    }
+
+    printk("  wrx_err_pdu       = %-10u  ", WAN_MIB_TABLE->wrx_err_pdu);
+    if ( WAN_MIB_TABLE->wrx_err_pdu == 0 )
+        printk("\n");
+    else {
+        int i = 0;
+
+        printk("[ ");
+        for ( i = 0; i < 16; ++i ) {
+            if ( WRX_PER_PVC_ERROR_PDU_BASE[i] )
+                printk("q%-2d = %-10u , ", i,  WRX_PER_PVC_ERROR_PDU_BASE[i] );
+        }
+        printk("]\n");
+    }
+
+    printk("  wrx_dropdes_cell  = %u\n", WAN_MIB_TABLE->wrx_dropdes_cell);
+    printk("  wrx_correct_cell  = %u\n", WAN_MIB_TABLE->wrx_correct_cell);
+    printk("  wrx_err_cell      = %u\n", WAN_MIB_TABLE->wrx_err_cell);
+    printk("  wrx_total_byte    = %u\n", WAN_MIB_TABLE->wrx_total_byte);
+    printk("\n");
+
+    printk("ATM Tx MIB:\n");
+    printk("  wtx_total_pdu     = %u\n", WAN_MIB_TABLE->wtx_total_pdu);
+    printk("  wtx_total_cell    = %u\n", WAN_MIB_TABLE->wtx_total_cell);
+    printk("  wtx_total_byte    = %u\n", WAN_MIB_TABLE->wtx_total_byte);
+    printk("\n");
+
+    printk("Debugging Info:\n");
+    printk("  Firmware version                 = %d.%d.%d.%d.%d.%d\n",
+            (int)FW_VER_ID->family, (int)FW_VER_ID->fwtype, (int)FW_VER_ID->interface,
+            (int)FW_VER_ID->fwmode, (int)FW_VER_ID->major, (int)FW_VER_ID->minor);
+
+    printk("  retx_alpha_switch_to_hunt_times  = %u\n", *URETX_ALPHA_SWITCH_TO_HUNT_TIMES);
+
+    printk("\n");
+
+    *eof = 1;
+
+    return len;
+}
+
+static int proc_write_retx_mib(struct file *file, const char *buf, unsigned long count, void *data)
+{
+    char str[2048];
+    char *p;
+    int len, rlen;
+    int i;
+
+    len = count < sizeof(str) ? count : sizeof(str) - 1;
+    rlen = len - copy_from_user(str, buf, len);
+    while ( rlen && str[rlen - 1] <= ' ' )
+        rlen--;
+    str[rlen] = 0;
+    for ( p = str; *p && *p <= ' '; p++, rlen-- );
+    if ( !*p )
+        return 0;
+
+    if ( stricmp(p, "clean") == 0 || stricmp(p, "clear") == 0 || stricmp(p, "clear_all") == 0) {
+        *URETX_RX_TOTAL_DTU         = 0;
+        *URETX_RX_BAD_DTU           = 0;
+        *URETX_RX_GOOD_DTU          = 0;
+        *URETX_RX_CORRECTED_DTU     = 0;
+        *URETX_RX_OUTOFDATE_DTU     = 0;
+        *URETX_RX_DUPLICATE_DTU     = 0;
+        *URETX_RX_TIMEOUT_DTU       = 0;
+        *RxDTURetransmittedCNT      = 0;
+
+        *WRX_BC0_CELL_NUM           = 0;
+        *WRX_BC0_DROP_CELL_NUM      = 0;
+        *WRX_BC0_NONRETX_CELL_NUM   = 0;
+        *WRX_BC0_RETX_CELL_NUM      = 0;
+        *WRX_BC0_OUTOFDATE_CELL_NUM = 0;
+        *WRX_BC0_DIRECTUP_NUM       = 0;
+        *WRX_BC0_PBW_TOTAL_NUM      = 0;
+        *WRX_BC0_PBW_SUCC_NUM       = 0;
+        *WRX_BC0_PBW_FAIL_NUM       = 0;
+        *WRX_BC1_CELL_NUM           = 0;
+
+        for ( i = 0; i < 16; ++i ) {
+            WRX_PER_PVC_CORRECT_PDU_BASE[i] = 0;
+            WRX_PER_PVC_ERROR_PDU_BASE[i]   = 0;
+        }
+
+        WAN_MIB_TABLE->wrx_drophtu_cell = 0;
+        WAN_MIB_TABLE->wrx_dropdes_pdu  = 0;
+        WAN_MIB_TABLE->wrx_correct_pdu  = 0;
+        WAN_MIB_TABLE->wrx_err_pdu      = 0;
+        WAN_MIB_TABLE->wrx_dropdes_cell = 0;
+        WAN_MIB_TABLE->wrx_correct_cell = 0;
+        WAN_MIB_TABLE->wrx_err_cell     = 0;
+        WAN_MIB_TABLE->wrx_total_byte   = 0;
+
+        WAN_MIB_TABLE->wtx_total_pdu    = 0;
+        WAN_MIB_TABLE->wtx_total_cell   = 0;
+        WAN_MIB_TABLE->wtx_total_byte   = 0;
+
+        *URETX_ALPHA_SWITCH_TO_HUNT_TIMES   = 0;
+
+        if (stricmp(p, "clear_all") == 0) {
+            *RxLastEFBCNT      = 0;
+            *RxDTUCorrectedCNT = 0;
+            *RxDTUCorruptedCNT = 0;
+            *RxRetxDTUUncorrectedCNT = 0;
+        }
+    }
+
+    return count;
+}
+
+#endif
+
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+
+static int proc_read_dbg(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int len = 0;
+
+    len += sprintf(page + off + len, "error print - %s\n", (ifx_atm_dbg_enable & DBG_ENABLE_MASK_ERR)           ? "enabled" : "disabled");
+    len += sprintf(page + off + len, "debug print - %s\n", (ifx_atm_dbg_enable & DBG_ENABLE_MASK_DEBUG_PRINT)   ? "enabled" : "disabled");
+    len += sprintf(page + off + len, "assert      - %s\n", (ifx_atm_dbg_enable & DBG_ENABLE_MASK_ASSERT)        ? "enabled" : "disabled");
+    len += sprintf(page + off + len, "dump rx skb - %s\n", (ifx_atm_dbg_enable & DBG_ENABLE_MASK_DUMP_SKB_RX)   ? "enabled" : "disabled");
+    len += sprintf(page + off + len, "dump tx skb - %s\n", (ifx_atm_dbg_enable & DBG_ENABLE_MASK_DUMP_SKB_TX)   ? "enabled" : "disabled");
+    len += sprintf(page + off + len, "qos         - %s\n", (ifx_atm_dbg_enable & DBG_ENABLE_MASK_DUMP_QOS)      ? "enabled" : "disabled");
+    len += sprintf(page + off + len, "dump init   - %s\n", (ifx_atm_dbg_enable & DBG_ENABLE_MASK_DUMP_INIT)     ? "enabled" : "disabled");
+    len += sprintf(page + off + len, "mac swap    - %s\n", (ifx_atm_dbg_enable & DBG_ENABLE_MASK_MAC_SWAP)      ? "enabled" : "disabled");
+#if defined(AS_PVC_MODE_ENABLE) && AS_PVC_MODE_ENABLE
+    len += sprintf(page + off + len, "g_as_pvc_push - 0x%08x\n", (unsigned int)g_as_pvc_push);
+#endif
+
+    *eof = 1;
+
+    return len;
+}
+
+static int proc_write_dbg(struct file *file, const char *buf, unsigned long count, void *data)
+{
+    static const char *dbg_enable_mask_str[] = {
+        " error print",
+        " err",
+        " debug print",
+        " dbg",
+        " assert",
+        " assert",
+        " dump rx skb",
+        " rx",
+        " dump tx skb",
+        " tx",
+        " dump qos",
+        " qos",
+        " dump init",
+        " init",
+        " mac swap",
+        " swap",
+        " all"
+    };
+    static const int dbg_enable_mask_str_len[] = {
+        12, 4,
+        12, 4,
+        7,  7,
+        12, 3,
+        12, 3,
+        9,  4,
+        10, 5,
+        9,  5,
+        4
+    };
+    unsigned int dbg_enable_mask[] = {
+        DBG_ENABLE_MASK_ERR,
+        DBG_ENABLE_MASK_DEBUG_PRINT,
+        DBG_ENABLE_MASK_ASSERT,
+        DBG_ENABLE_MASK_DUMP_SKB_RX,
+        DBG_ENABLE_MASK_DUMP_SKB_TX,
+        DBG_ENABLE_MASK_DUMP_QOS,
+        DBG_ENABLE_MASK_DUMP_INIT,
+        DBG_ENABLE_MASK_MAC_SWAP,
+        DBG_ENABLE_MASK_ALL
+    };
+
+    char str[2048];
+    char *p;
+
+    int len, rlen;
+
+    int f_enable = 0;
+    int i;
+
+    len = count < sizeof(str) ? count : sizeof(str) - 1;
+    rlen = len - copy_from_user(str, buf, len);
+    while ( rlen && str[rlen - 1] <= ' ' )
+        rlen--;
+    str[rlen] = 0;
+    for ( p = str; *p && *p <= ' '; p++, rlen-- );
+    if ( !*p )
+        return 0;
+
+#if defined(AS_PVC_MODE_ENABLE) && AS_PVC_MODE_ENABLE
+    if ( stricmp(p, "as_pvc") == 0 ) {
+        g_as_pvc_push = g_as_pvc_push == NULL ? (as_pvc_push_fn_t)ifx_push_oam : NULL;
+        return count;
+    }
+#endif
+
+    if ( strincmp(p, "enable", 6) == 0 ) {
+        p += 6;
+        f_enable = 1;
+    }
+    else if ( strincmp(p, "disable", 7) == 0 ) {
+        p += 7;
+        f_enable = -1;
+    }
+    else if ( strincmp(p, "help", 4) == 0 || *p == '?' ) {
+        printk("echo <enable/disable> [err/dbg/assert/rx/tx/init/all] > /proc/eth/dbg\n");
+    }
+
+    if ( f_enable ) {
+        if ( *p == 0 ) {
+            if ( f_enable > 0 )
+                ifx_atm_dbg_enable |= DBG_ENABLE_MASK_ALL & ~DBG_ENABLE_MASK_MAC_SWAP;
+            else
+                ifx_atm_dbg_enable &= ~DBG_ENABLE_MASK_ALL | DBG_ENABLE_MASK_MAC_SWAP;
+        }
+        else {
+            do {
+                for ( i = 0; i < NUM_ENTITY(dbg_enable_mask_str); i++ )
+                    if ( strincmp(p, dbg_enable_mask_str[i], dbg_enable_mask_str_len[i]) == 0 ) {
+                        if ( f_enable > 0 )
+                            ifx_atm_dbg_enable |= dbg_enable_mask[i >> 1];
+                        else
+                            ifx_atm_dbg_enable &= ~dbg_enable_mask[i >> 1];
+                        p += dbg_enable_mask_str_len[i];
+                        break;
+                    }
+            } while ( i < NUM_ENTITY(dbg_enable_mask_str) );
+        }
+    }
+
+    return count;
+}
+
+static inline unsigned long sb_addr_to_fpi_addr_convert(unsigned long sb_addr)
+{
+ #define PP32_SB_ADDR_END        0xFFFF
+
+    if ( sb_addr < PP32_SB_ADDR_END )
+        return (unsigned long)SB_BUFFER(sb_addr);
+    else
+        return sb_addr;
+}
+
+static int proc_write_mem(struct file *file, const char *buf, unsigned long count, void *data)
+{
+    char *p1, *p2;
+    int len;
+    int colon;
+    unsigned long *p;
+    char local_buf[1024];
+    int i, n, l;
+
+    len = sizeof(local_buf) < count ? sizeof(local_buf) - 1 : count;
+    len = len - copy_from_user(local_buf, buf, len);
+    local_buf[len] = 0;
+
+    p1 = local_buf;
+    colon = 1;
+    while ( get_token(&p1, &p2, &len, &colon) ) {
+        if ( stricmp(p1, "w") == 0 || stricmp(p1, "write") == 0 || stricmp(p1, "r") == 0 || stricmp(p1, "read") == 0 )
+            break;
+
+        p1 = p2;
+        colon = 1;
+    }
+
+    if ( *p1 == 'w' ) {
+        ignore_space(&p2, &len);
+        p = (unsigned long *)get_number(&p2, &len, 1);
+        p = (unsigned long *)sb_addr_to_fpi_addr_convert((unsigned long)p);
+
+        if ( (unsigned int)p >= KSEG0 )
+            while ( 1 ) {
+                ignore_space(&p2, &len);
+                if ( !len || !((*p2 >= '0' && *p2 <= '9') || (*p2 >= 'a' && *p2 <= 'f') || (*p2 >= 'A' && *p2 <= 'F')) )
+                    break;
+
+                *p++ = (unsigned int)get_number(&p2, &len, 1);
+            }
+    }
+    else if ( *p1 == 'r' ) {
+        ignore_space(&p2, &len);
+        p = (unsigned long *)get_number(&p2, &len, 1);
+        p = (unsigned long *)sb_addr_to_fpi_addr_convert((unsigned long)p);
+
+        if ( (unsigned int)p >= KSEG0 ) {
+            ignore_space(&p2, &len);
+            n = (int)get_number(&p2, &len, 0);
+            if ( n ) {
+                char str[32] = {0};
+                char *pch = str;
+                int k;
+                unsigned int data;
+                char c;
+
+                n += (l = ((int)p >> 2) & 0x03);
+                p = (unsigned long *)((unsigned int)p & ~0x0F);
+                for ( i = 0; i < n; i++ ) {
+                    if ( (i & 0x03) == 0 ) {
+                        printk("%08X:", (unsigned int)p);
+                        pch = str;
+                    }
+                    if ( i < l ) {
+                        printk("         ");
+                        sprintf(pch, "    ");
+                    }
+                    else {
+                        data = (unsigned int)*p;
+                        printk(" %08X", data);
+                        for ( k = 0; k < 4; k++ ) {
+                            c = ((char*)&data)[k];
+                            pch[k] = c < ' ' ? '.' : c;
+                        }
+                    }
+                    p++;
+                    pch += 4;
+                    if ( (i & 0x03) == 0x03 ) {
+                        pch[0] = 0;
+                        printk(" ; %s\n", str);
+                    }
+                }
+                if ( (n & 0x03) != 0x00 ) {
+                    for ( k = 4 - (n & 0x03); k > 0; k-- )
+                        printk("         ");
+                    pch[0] = 0;
+                    printk(" ; %s\n", str);
+                }
+            }
+        }
+    }
+
+    return count;
+}
+
+ #if defined(CONFIG_AR9) || defined(CONFIG_LTQ_ATM_XRX200) || defined(CONFIG_LTQ_ATM_XRX300)
+
+static int proc_read_pp32(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    static const char *stron = " on";
+    static const char *stroff = "off";
+
+    int len = 0;
+    int cur_context;
+    int f_stopped;
+    char str[256];
+    char strlength;
+    int i, j;
+
+    int pp32;
+
+    for ( pp32 = 0; pp32 < NUM_OF_PP32; pp32++ ) {
+        f_stopped = 0;
+
+        len += sprintf(page + off + len, "===== pp32 core %d =====\n", pp32);
+
+  #ifdef CONFIG_LTQ_ATM_XRX200
+        if ( (*PP32_FREEZE & (1 << (pp32 << 4))) != 0 ) {
+            sprintf(str, "freezed");
+            f_stopped = 1;
+        }
+  #else
+        if ( 0 ) {
+        }
+  #endif
+        else if ( PP32_CPU_USER_STOPPED(pp32) || PP32_CPU_USER_BREAKIN_RCV(pp32) || PP32_CPU_USER_BREAKPOINT_MET(pp32) ) {
+            strlength = 0;
+            if ( PP32_CPU_USER_STOPPED(pp32) )
+                strlength += sprintf(str + strlength, "stopped");
+            if ( PP32_CPU_USER_BREAKPOINT_MET(pp32) )
+                strlength += sprintf(str + strlength, strlength ? " | breakpoint" : "breakpoint");
+            if ( PP32_CPU_USER_BREAKIN_RCV(pp32) )
+                strlength += sprintf(str + strlength, strlength ? " | breakin" : "breakin");
+            f_stopped = 1;
+        }
+  #if 0
+        else if ( PP32_CPU_CUR_PC(pp32) == PP32_CPU_CUR_PC(pp32) ) {
+            sprintf(str, "hang");
+            f_stopped = 1;
+        }
+  #endif
+        else
+            sprintf(str, "running");
+        cur_context = PP32_BRK_CUR_CONTEXT(pp32);
+        len += sprintf(page + off + len, "Context: %d, PC: 0x%04x, %s\n", cur_context, PP32_CPU_CUR_PC(pp32), str);
+
+        if ( PP32_CPU_USER_BREAKPOINT_MET(pp32) ) {
+            strlength = 0;
+            if ( PP32_BRK_PC_MET(pp32, 0) )
+                strlength += sprintf(str + strlength, "pc0");
+            if ( PP32_BRK_PC_MET(pp32, 1) )
+                strlength += sprintf(str + strlength, strlength ? " | pc1" : "pc1");
+            if ( PP32_BRK_DATA_ADDR_MET(pp32, 0) )
+                strlength += sprintf(str + strlength, strlength ? " | daddr0" : "daddr0");
+            if ( PP32_BRK_DATA_ADDR_MET(pp32, 1) )
+                strlength += sprintf(str + strlength, strlength ? " | daddr1" : "daddr1");
+            if ( PP32_BRK_DATA_VALUE_RD_MET(pp32, 0) ) {
+                strlength += sprintf(str + strlength, strlength ? " | rdval0" : "rdval0");
+                if ( PP32_BRK_DATA_VALUE_RD_LO_EQ(pp32, 0) ) {
+                    if ( PP32_BRK_DATA_VALUE_RD_GT_EQ(pp32, 0) )
+                        strlength += sprintf(str + strlength, " ==");
+                    else
+                        strlength += sprintf(str + strlength, " <=");
+                }
+                else if ( PP32_BRK_DATA_VALUE_RD_GT_EQ(pp32, 0) )
+                    strlength += sprintf(str + strlength, " >=");
+            }
+            if ( PP32_BRK_DATA_VALUE_RD_MET(pp32, 1) ) {
+                strlength += sprintf(str + strlength, strlength ? " | rdval1" : "rdval1");
+                if ( PP32_BRK_DATA_VALUE_RD_LO_EQ(pp32, 1) ) {
+                    if ( PP32_BRK_DATA_VALUE_RD_GT_EQ(pp32, 1) )
+                        strlength += sprintf(str + strlength, " ==");
+                    else
+                        strlength += sprintf(str + strlength, " <=");
+                }
+                else if ( PP32_BRK_DATA_VALUE_RD_GT_EQ(pp32, 1) )
+                    strlength += sprintf(str + strlength, " >=");
+            }
+            if ( PP32_BRK_DATA_VALUE_WR_MET(pp32, 0) ) {
+                strlength += sprintf(str + strlength, strlength ? " | wtval0" : "wtval0");
+                if ( PP32_BRK_DATA_VALUE_WR_LO_EQ(pp32, 0) ) {
+                    if ( PP32_BRK_DATA_VALUE_WR_GT_EQ(pp32, 0) )
+                        strlength += sprintf(str + strlength, " ==");
+                    else
+                        strlength += sprintf(str + strlength, " <=");
+                }
+                else if ( PP32_BRK_DATA_VALUE_WR_GT_EQ(pp32, 0) )
+                    strlength += sprintf(str + strlength, " >=");
+            }
+            if ( PP32_BRK_DATA_VALUE_WR_MET(pp32, 1) ) {
+                strlength += sprintf(str + strlength, strlength ? " | wtval1" : "wtval1");
+                if ( PP32_BRK_DATA_VALUE_WR_LO_EQ(pp32, 1) ) {
+                    if ( PP32_BRK_DATA_VALUE_WR_GT_EQ(pp32, 1) )
+                        strlength += sprintf(str + strlength, " ==");
+                    else
+                        strlength += sprintf(str + strlength, " <=");
+                }
+                else if ( PP32_BRK_DATA_VALUE_WR_GT_EQ(pp32, 1) )
+                    strlength += sprintf(str + strlength, " >=");
+            }
+            len += sprintf(page + off + len, "break reason: %s\n", str);
+        }
+
+        if ( f_stopped )
+        {
+            len += sprintf(page + off + len, "General Purpose Register (Context %d):\n", cur_context);
+            for ( i = 0; i < 4; i++ ) {
+                for ( j = 0; j < 4; j++ )
+                    len += sprintf(page + off + len, "   %2d: %08x", i + j * 4, *PP32_GP_CONTEXTi_REGn(pp32, cur_context, i + j * 4));
+                len += sprintf(page + off + len, "\n");
+            }
+        }
+
+        len += sprintf(page + off + len, "break out on: break in - %s, stop - %s\n",
+                                            PP32_CTRL_OPT_BREAKOUT_ON_BREAKIN(pp32) ? stron : stroff,
+                                            PP32_CTRL_OPT_BREAKOUT_ON_STOP(pp32) ? stron : stroff);
+        len += sprintf(page + off + len, "     stop on: break in - %s, break point - %s\n",
+                                            PP32_CTRL_OPT_STOP_ON_BREAKIN(pp32) ? stron : stroff,
+                                            PP32_CTRL_OPT_STOP_ON_BREAKPOINT(pp32) ? stron : stroff);
+        len += sprintf(page + off + len, "breakpoint:\n");
+        len += sprintf(page + off + len, "     pc0: 0x%08x, %s\n", *PP32_BRK_PC(pp32, 0), PP32_BRK_GRPi_PCn(pp32, 0, 0) ? "group 0" : "off");
+        len += sprintf(page + off + len, "     pc1: 0x%08x, %s\n", *PP32_BRK_PC(pp32, 1), PP32_BRK_GRPi_PCn(pp32, 1, 1) ? "group 1" : "off");
+        len += sprintf(page + off + len, "  daddr0: 0x%08x, %s\n", *PP32_BRK_DATA_ADDR(pp32, 0), PP32_BRK_GRPi_DATA_ADDRn(pp32, 0, 0) ? "group 0" : "off");
+        len += sprintf(page + off + len, "  daddr1: 0x%08x, %s\n", *PP32_BRK_DATA_ADDR(pp32, 1), PP32_BRK_GRPi_DATA_ADDRn(pp32, 1, 1) ? "group 1" : "off");
+        len += sprintf(page + off + len, "  rdval0: 0x%08x\n", *PP32_BRK_DATA_VALUE_RD(pp32, 0));
+        len += sprintf(page + off + len, "  rdval1: 0x%08x\n", *PP32_BRK_DATA_VALUE_RD(pp32, 1));
+        len += sprintf(page + off + len, "  wrval0: 0x%08x\n", *PP32_BRK_DATA_VALUE_WR(pp32, 0));
+        len += sprintf(page + off + len, "  wrval1: 0x%08x\n", *PP32_BRK_DATA_VALUE_WR(pp32, 1));
+    }
+
+    *eof = 1;
+
+    return len;
+}
+
+static int proc_write_pp32(struct file *file, const char *buf, unsigned long count, void *data)
+{
+    char str[2048];
+    char *p;
+    unsigned int addr;
+
+    int len, rlen;
+
+    int pp32 = 0;
+
+    len = count < sizeof(str) ? count : sizeof(str) - 1;
+    rlen = len - copy_from_user(str, buf, len);
+    while ( rlen && str[rlen - 1] <= ' ' )
+        rlen--;
+    str[rlen] = 0;
+    for ( p = str; *p && *p <= ' '; p++, rlen-- );
+    if ( !*p )
+        return 0;
+
+    if ( strincmp(p, "pp32 ", 5) == 0 ) {
+        p += 5;
+        rlen -= 5;
+
+        while ( rlen > 0 && *p >= '0' && *p <= '9' ) {
+            pp32 += *p - '0';
+            p++;
+            rlen--;
+        }
+        while ( rlen > 0 && *p && *p <= ' ' ) {
+            p++;
+            rlen--;
+        }
+
+        if ( pp32 >= NUM_OF_PP32 ) {
+            err("incorrect pp32 index - %d", pp32);
+            return count;
+        }
+    }
+
+    if ( stricmp(p, "start") == 0 )
+        *PP32_CTRL_CMD(pp32) = PP32_CTRL_CMD_RESTART;
+    else if ( stricmp(p, "stop") == 0 )
+        *PP32_CTRL_CMD(pp32) = PP32_CTRL_CMD_STOP;
+    else if ( stricmp(p, "step") == 0 )
+        *PP32_CTRL_CMD(pp32) = PP32_CTRL_CMD_STEP;
+  #ifdef CONFIG_LTQ_ATM_XRX200
+    else if ( stricmp(p, "restart") == 0 )
+        *PP32_FREEZE &= ~(1 << (pp32 << 4));
+    else if ( stricmp(p, "freeze") == 0 )
+        *PP32_FREEZE |= 1 << (pp32 << 4);
+  #endif
+    else if ( strincmp(p, "pc0 ", 4) == 0 ) {
+        p += 4;
+        rlen -= 4;
+        if ( stricmp(p, "off") == 0 ) {
+            *PP32_BRK_TRIG(pp32) = PP32_BRK_GRPi_PCn_OFF(0, 0);
+            *PP32_BRK_PC_MASK(pp32, 0) = PP32_BRK_CONTEXT_MASK_EN;
+            *PP32_BRK_PC(pp32, 0) = 0;
+        }
+        else {
+            addr = get_number(&p, &rlen, 1);
+            *PP32_BRK_PC(pp32, 0) = addr;
+            *PP32_BRK_PC_MASK(pp32, 0) = PP32_BRK_CONTEXT_MASK_EN | PP32_BRK_CONTEXT_MASK(0) | PP32_BRK_CONTEXT_MASK(1) | PP32_BRK_CONTEXT_MASK(2) | PP32_BRK_CONTEXT_MASK(3);
+            *PP32_BRK_TRIG(pp32) = PP32_BRK_GRPi_PCn_ON(0, 0);
+        }
+    }
+    else if ( strincmp(p, "pc1 ", 4) == 0 ) {
+        p += 4;
+        rlen -= 4;
+        if ( stricmp(p, "off") == 0 ) {
+            *PP32_BRK_TRIG(pp32) = PP32_BRK_GRPi_PCn_OFF(1, 1);
+            *PP32_BRK_PC_MASK(pp32, 1) = PP32_BRK_CONTEXT_MASK_EN;
+            *PP32_BRK_PC(pp32, 1) = 0;
+        }
+        else {
+            addr = get_number(&p, &rlen, 1);
+            *PP32_BRK_PC(pp32, 1) = addr;
+            *PP32_BRK_PC_MASK(pp32, 1) = PP32_BRK_CONTEXT_MASK_EN | PP32_BRK_CONTEXT_MASK(0) | PP32_BRK_CONTEXT_MASK(1) | PP32_BRK_CONTEXT_MASK(2) | PP32_BRK_CONTEXT_MASK(3);
+            *PP32_BRK_TRIG(pp32) = PP32_BRK_GRPi_PCn_ON(1, 1);
+        }
+    }
+    else if ( strincmp(p, "daddr0 ", 7) == 0 ) {
+        p += 7;
+        rlen -= 7;
+        if ( stricmp(p, "off") == 0 ) {
+            *PP32_BRK_TRIG(pp32) = PP32_BRK_GRPi_DATA_ADDRn_OFF(0, 0);
+            *PP32_BRK_DATA_ADDR_MASK(pp32, 0) = PP32_BRK_CONTEXT_MASK_EN;
+            *PP32_BRK_DATA_ADDR(pp32, 0) = 0;
+        }
+        else {
+            addr = get_number(&p, &rlen, 1);
+            *PP32_BRK_DATA_ADDR(pp32, 0) = addr;
+            *PP32_BRK_DATA_ADDR_MASK(pp32, 0) = PP32_BRK_CONTEXT_MASK_EN | PP32_BRK_CONTEXT_MASK(0) | PP32_BRK_CONTEXT_MASK(1) | PP32_BRK_CONTEXT_MASK(2) | PP32_BRK_CONTEXT_MASK(3);
+            *PP32_BRK_TRIG(pp32) = PP32_BRK_GRPi_DATA_ADDRn_ON(0, 0);
+        }
+    }
+    else if ( strincmp(p, "daddr1 ", 7) == 0 ) {
+        p += 7;
+        rlen -= 7;
+        if ( stricmp(p, "off") == 0 ) {
+            *PP32_BRK_TRIG(pp32) = PP32_BRK_GRPi_DATA_ADDRn_OFF(1, 1);
+            *PP32_BRK_DATA_ADDR_MASK(pp32, 1) = PP32_BRK_CONTEXT_MASK_EN;
+            *PP32_BRK_DATA_ADDR(pp32, 1) = 0;
+        }
+        else {
+            addr = get_number(&p, &rlen, 1);
+            *PP32_BRK_DATA_ADDR(pp32, 1) = addr;
+            *PP32_BRK_DATA_ADDR_MASK(pp32, 1) = PP32_BRK_CONTEXT_MASK_EN | PP32_BRK_CONTEXT_MASK(0) | PP32_BRK_CONTEXT_MASK(1) | PP32_BRK_CONTEXT_MASK(2) | PP32_BRK_CONTEXT_MASK(3);
+            *PP32_BRK_TRIG(pp32) = PP32_BRK_GRPi_DATA_ADDRn_ON(1, 1);
+        }
+    }
+    else {
+
+        printk("echo \"<command>\" > /proc/driver/ifx_ptm/pp32\n");
+        printk("  command:\n");
+        printk("    start  - run pp32\n");
+        printk("    stop   - stop pp32\n");
+        printk("    step   - run pp32 with one step only\n");
+        printk("    pc0    - pc0 <addr>/off, set break point PC0\n");
+        printk("    pc1    - pc1 <addr>/off, set break point PC1\n");
+        printk("    daddr0 - daddr0 <addr>/off, set break point data address 0\n");
+        printk("    daddr0 - daddr1 <addr>/off, set break point data address 1\n");
+        printk("    help   - print this screen\n");
+    }
+
+    if ( *PP32_BRK_TRIG(pp32) )
+        *PP32_CTRL_OPT(pp32) = PP32_CTRL_OPT_STOP_ON_BREAKPOINT_ON;
+    else
+        *PP32_CTRL_OPT(pp32) = PP32_CTRL_OPT_STOP_ON_BREAKPOINT_OFF;
+
+    return count;
+}
+
+ #elif defined(CONFIG_DANUBE)
+
+static int proc_read_pp32(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    static const char *halt_stat[] = {
+        "reset",
+        "break in line",
+        "stop",
+        "step",
+        "code",
+        "data0",
+        "data1"
+    };
+    static const char *brk_src_data[] = {
+        "off",
+        "read",
+        "write",
+        "read/write",
+        "write_equal",
+        "N/A",
+        "N/A",
+        "N/A"
+    };
+    static const char *brk_src_code[] = {
+        "off",
+        "on"
+    };
+
+    int len = 0;
+    int i;
+    int k;
+    unsigned long bit;
+    int tsk;
+
+    tsk = *PP32_DBG_TASK_NO & 0x03;
+    len += sprintf(page + off + len, "Task No %d, PC %04x\n", tsk, *PP32_DBG_CUR_PC & 0xFFFF);
+
+    if ( !(*PP32_HALT_STAT & 0x01) )
+        len += sprintf(page + off + len, "  Halt State: Running\n");
+    else {
+        len += sprintf(page + off + len, "  Halt State: Stopped");
+        k = 0;
+        for ( bit = 2, i = 0; bit <= (1 << 7); bit <<= 1, i++ )
+            if ( (*PP32_HALT_STAT & bit) ) {
+                if ( !k ) {
+                    len += sprintf(page + off + len, ", ");
+                    k++;
+                }
+                else
+                    len += sprintf(page + off + len, " | ");
+                len += sprintf(page + off + len, halt_stat[i]);
+            }
+
+        len += sprintf(page + off + len, "\n");
+
+        len += sprintf(page + off + len, "  Regs (Task %d):\n", tsk);
+        for ( i = 0; i < 8; i++ )
+            len += sprintf(page + off + len, "    %2d. %08x    %2d. %08x\n", i, *PP32_DBG_REG_BASE(tsk, i), i + 8, *PP32_DBG_REG_BASE(tsk, i + 8));
+    }
+
+    len += sprintf(page + off + len, "  Break Src:  data1 - %s, data0 - %s, pc3 - %s, pc2 - %s, pc1 - %s, pc0 - %s\n",
+                            brk_src_data[(*PP32_BRK_SRC >> 11) & 0x07],
+                            brk_src_data[(*PP32_BRK_SRC >> 8) & 0x07],
+                            brk_src_code[(*PP32_BRK_SRC >> 3) & 0x01],
+                            brk_src_code[(*PP32_BRK_SRC >> 2) & 0x01],
+                            brk_src_code[(*PP32_BRK_SRC >> 1) & 0x01],
+                            brk_src_code[*PP32_BRK_SRC & 0x01]);
+
+    for ( i = 0; i < 4; i++ )
+        len += sprintf(page + off + len, "    pc%d:      %04x - %04x\n", i, *PP32_DBG_PC_MIN(i), *PP32_DBG_PC_MAX(i));
+
+    for ( i = 0; i < 2; i++ )
+        len += sprintf(page + off + len, "    data%d:    %04x - %04x (%08x)\n", i, *PP32_DBG_DATA_MIN(i), *PP32_DBG_DATA_MAX(i), *PP32_DBG_DATA_VAL(i));
+
+    *eof = 1;
+
+    return len;
+}
+
+static int proc_write_pp32(struct file *file, const char *buf, unsigned long count, void *data)
+{
+    char str[2048];
+    char *p;
+
+    int len, rlen;
+
+    len = count < sizeof(str) ? count : sizeof(str) - 1;
+    rlen = len - copy_from_user(str, buf, len);
+    while ( rlen && str[rlen - 1] <= ' ' )
+        rlen--;
+    str[rlen] = 0;
+    for ( p = str; *p && *p <= ' '; p++, rlen-- );
+    if ( !*p )
+        return 0;
+
+    if ( stricmp(p, "start") == 0 )
+        *PP32_DBG_CTRL = DBG_CTRL_START_SET(1);
+    else if ( stricmp(p, "stop") == 0 )
+        *PP32_DBG_CTRL = DBG_CTRL_STOP_SET(1);
+    else if ( stricmp(p, "step") == 0 )
+        *PP32_DBG_CTRL = DBG_CTRL_STEP_SET(1);
+    else if ( strincmp(p, "pc", 2) == 0 && p[2] >= '0' && p[2] <= '3' && p[3] <= ' ' ) {
+        int n = p[2] - '0';
+        int on_off_flag = -1;
+        int addr_min, addr_max;
+
+        p += 4;
+        rlen -= 4;
+        ignore_space(&p, &rlen);
+
+        if ( strincmp(p, "off", 3) == 0 && p[3] <= ' ' ) {
+            p += 3;
+            rlen -= 3;
+            on_off_flag = 0;
+        }
+        else if ( strincmp(p, "on", 2) == 0 && p[2] <= ' ' ) {
+            p += 2;
+            rlen -= 2;
+            on_off_flag = 1;
+        }
+        ignore_space(&p, &rlen);
+
+        if ( rlen ) {
+            addr_min = get_number(&p, &rlen, 1);
+            ignore_space(&p, &rlen);
+            if ( rlen )
+                addr_max = get_number(&p, &rlen, 1);
+            else
+                addr_max = addr_min;
+
+            *PP32_DBG_PC_MIN(n) = addr_min;
+            *PP32_DBG_PC_MAX(n) = addr_max;
+        }
+
+        if ( on_off_flag == 0 )
+            *PP32_BRK_SRC &= ~(1 << n);
+        else if ( on_off_flag > 0 )
+            *PP32_BRK_SRC |= 1 << n;
+    }
+    else if ( strincmp(p, "data", 4) == 0 && p[4] >= '0' && p[4] <= '1' && p[5] <= ' ' ) {
+        const static char *data_cmd_str[] = {"r", "w", "rw", "w=", "off", "min", "min addr", "max", "max addr", "val", "value"};
+        const static int data_cmd_len[] = {1, 1, 2, 2, 3, 3, 8, 3, 8, 3, 5};
+        const static int data_cmd_idx[] = {1, 2, 3, 4, 0, 5, 5, 6, 6, 7, 7};
+        int n = p[4] - '0';
+        int on_off_flag = -1, on_off_mask = 0;
+        int addr_min = -1, addr_max = -1;
+        int value = 0, f_got_value = 0;
+        int stat = 0;
+        int i;
+        int tmp;
+
+        p += 6;
+        rlen -= 6;
+
+        while ( 1 ) {
+            ignore_space(&p, &rlen);
+            if ( rlen <= 0 )
+                break;
+            for ( i = 0; i < NUM_ENTITY(data_cmd_str); i++ )
+                if ( strincmp(p, data_cmd_str[i], data_cmd_len[i]) == 0 && p[data_cmd_len[i]] <= ' ' ) {
+                    p += data_cmd_len[i];
+                    rlen -= data_cmd_len[i];
+                    stat = data_cmd_idx[i];
+                    if ( stat <= 4 ) {
+                        on_off_mask = 7;
+                        on_off_flag = stat;
+                    }
+                    break;
+                }
+            if ( i == NUM_ENTITY(data_cmd_str) ) {
+                if ( (*p >= '0' && *p <= '9') || (*p >= 'a' && *p <= 'f') || (*p >= 'A' && *p <= 'F') ) {
+                    tmp = get_number(&p, &rlen, 1);
+                    if ( stat <= 5 ) {
+                        addr_min = tmp;
+                        stat = 6;
+                    }
+                    else if ( stat >= 7 ) {
+                        value = tmp;
+                        f_got_value = 1;
+                    }
+                    else {
+                        addr_max = tmp;
+                        stat = 7;
+                    }
+                }
+                else
+                    for ( ; rlen && *p > ' '; rlen--, p++ );
+            }
+        }
+
+        if ( addr_min >= 0 )
+            *PP32_DBG_DATA_MIN(n) = *PP32_DBG_DATA_MAX(n) = addr_min;
+        if ( addr_max >= 0 )
+            *PP32_DBG_DATA_MAX(n) = addr_max;
+        if ( f_got_value )
+            *PP32_DBG_DATA_VAL(n) = value;
+        if ( on_off_mask && on_off_flag >= 0 ) {
+            on_off_flag <<= n ? 11 : 8;
+            on_off_mask <<= n ? 11 : 8;
+            *PP32_BRK_SRC = (*PP32_BRK_SRC & ~on_off_mask) | on_off_flag;
+        }
+    }
+    else {
+        printk("echo \"<command>\" > /proc/eth/etop\n");
+        printk("  command:\n");
+        printk("    start - run pp32\n");
+        printk("    stop  - stop pp32\n");
+        printk("    step  - run pp32 with one step only\n");
+        printk("    pc    - pc? [on/off] [min addr] [max addr], set PC break point\n");
+        printk("    data  - data? [r/w/rw/w=/off] [min <addr>] [max <addr>] [val <value>], set data break point\n");
+        printk("    help  - print this screen\n");
+    }
+
+    return count;
+}
+
+ #elif defined(CONFIG_AMAZON_SE)
+
+static int proc_read_pp32(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    static const char *halt_stat[] = {
+        "reset",
+        "break in line",
+        "stop",
+        "step",
+        "code",
+        "data0",
+        "data1"
+    };
+    static const char *brk_src_data[] = {
+        "off",
+        "read",
+        "write",
+        "read/write",
+        "write_equal",
+        "N/A",
+        "N/A",
+        "N/A"
+    };
+    static const char *brk_src_code[] = {
+        "off",
+        "on"
+    };
+
+    int len = 0;
+    int i;
+    int k;
+    unsigned long bit;
+
+    len += sprintf(page + off + len, "Task No %d, PC %04x\n", *PP32_DBG_TASK_NO & 0x03, *PP32_DBG_CUR_PC & 0xFFFF);
+
+    if ( !(*PP32_HALT_STAT & 0x01) )
+        len += sprintf(page + off + len, "  Halt State: Running\n");
+    else
+    {
+        len += sprintf(page + off + len, "  Halt State: Stopped");
+        k = 0;
+        for ( bit = 2, i = 0; bit <= (1 << 7); bit <<= 1, i++ )
+            if ( (*PP32_HALT_STAT & bit) )
+            {
+                if ( !k )
+                {
+                    len += sprintf(page + off + len, ", ");
+                    k++;
+                }
+                else
+                    len += sprintf(page + off + len, " | ");
+                len += sprintf(page + off + len, halt_stat[i]);
+            }
+
+        len += sprintf(page + off + len, "\n");
+    }
+
+    len += sprintf(page + off + len, "  Break Src:  data1 - %s, data0 - %s, pc3 - %s, pc2 - %s, pc1 - %s, pc0 - %s\n",
+                                                    brk_src_data[(*PP32_BRK_SRC >> 11) & 0x07], brk_src_data[(*PP32_BRK_SRC >> 8) & 0x07], brk_src_code[(*PP32_BRK_SRC >> 3) & 0x01], brk_src_code[(*PP32_BRK_SRC >> 2) & 0x01], brk_src_code[(*PP32_BRK_SRC >> 1) & 0x01], brk_src_code[*PP32_BRK_SRC & 0x01]);
+
+//    for ( i = 0; i < 4; i++ )
+//        len += sprintf(page + off + len, "    pc%d:      %04x - %04x\n", i, *PP32_DBG_PC_MIN(i), *PP32_DBG_PC_MAX(i));
+
+//    for ( i = 0; i < 2; i++ )
+//        len += sprintf(page + off + len, "    data%d:    %04x - %04x (%08x)\n", i, *PP32_DBG_DATA_MIN(i), *PP32_DBG_DATA_MAX(i), *PP32_DBG_DATA_VAL(i));
+
+    *eof = 1;
+
+    return len;
+}
+
+static int proc_write_pp32(struct file *file, const char *buf, unsigned long count, void *data)
+{
+    char str[2048];
+    char *p;
+
+    int len, rlen;
+
+    len = count < sizeof(str) ? count : sizeof(str) - 1;
+    rlen = len - copy_from_user(str, buf, len);
+    while ( rlen && str[rlen - 1] <= ' ' )
+        rlen--;
+    str[rlen] = 0;
+    for ( p = str; *p && *p <= ' '; p++, rlen-- );
+    if ( !*p )
+        return 0;
+
+    if ( stricmp(str, "start") == 0 )
+        *PP32_DBG_CTRL = DBG_CTRL_RESTART;
+    else if ( stricmp(str, "stop") == 0 )
+        *PP32_DBG_CTRL = DBG_CTRL_STOP;
+//    else if ( stricmp(str, "step") == 0 )
+//        *PP32_DBG_CTRL = DBG_CTRL_STEP_SET(1);
+    else
+    {
+        printk("echo \"<command>\" > /proc/eth/etop\n");
+        printk("  command:\n");
+        printk("    start - run pp32\n");
+        printk("    stop  - stop pp32\n");
+//        printk("    step  - run pp32 with one step only\n");
+        printk("    help  - print this screen\n");
+    }
+
+    return count;
+}
+
+ #endif
+
+#endif
+
+#if defined(ENABLE_FW_PROC) && ENABLE_FW_PROC
+
+static INLINE int print_htu(char *buf, int i)
+{
+    int len = 0;
+
+    if ( HTU_ENTRY(i)->vld ) {
+        len += sprintf(buf + len, "%2d. valid\n", i);
+        len += sprintf(buf + len, "    entry  0x%08x - pid %01x vpi %02x vci %04x pti %01x\n", *(unsigned int*)HTU_ENTRY(i), HTU_ENTRY(i)->pid, HTU_ENTRY(i)->vpi, HTU_ENTRY(i)->vci, HTU_ENTRY(i)->pti);
+        len += sprintf(buf + len, "    mask   0x%08x - pid %01x vpi %02x vci %04x pti %01x\n", *(unsigned int*)HTU_MASK(i), HTU_MASK(i)->pid_mask, HTU_MASK(i)->vpi_mask, HTU_MASK(i)->vci_mask, HTU_MASK(i)->pti_mask);
+        len += sprintf(buf + len, "    result 0x%08x - type: %s, qid: %d", *(unsigned int*)HTU_RESULT(i), HTU_RESULT(i)->type ? "cell" : "AAL5", HTU_RESULT(i)->qid);
+        if ( HTU_RESULT(i)->type )
+            len += sprintf(buf + len, ", cell id: %d, verification: %s", HTU_RESULT(i)->cellid, HTU_RESULT(i)->ven ? "on" : "off");
+        len += sprintf(buf + len, "\n");
+    }
+    else
+        len += sprintf(buf + len, "%2d. invalid\n", i);
+
+    return len;
+}
+
+static int proc_read_htu(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int len = 0;
+    int len_max = off + count;
+    char *pstr;
+    char str[1024];
+    int llen;
+
+    int htuts = *CFG_WRX_HTUTS;
+    int i;
+
+    pstr = *start = page;
+
+    llen = sprintf(pstr, "HTU Table (Max %d):\n", htuts);
+    pstr += llen;
+    len += llen;
+
+    for ( i = 0; i < htuts; i++ ) {
+        llen = print_htu(str, i);
+        if ( len <= off && len + llen > off ) {
+            memcpy(pstr, str + off - len, len + llen - off);
+            pstr += len + llen - off;
+        }
+        else if ( len > off ) {
+            memcpy(pstr, str, llen);
+            pstr += llen;
+        }
+        len += llen;
+        if ( len >= len_max )
+            goto PROC_READ_HTU_OVERRUN_END;
+    }
+
+    *eof = 1;
+
+    return len - off;
+
+PROC_READ_HTU_OVERRUN_END:
+
+    return len - llen - off;
+}
+
+static INLINE int print_tx_queue(char *buf, int i)
+{
+    int len = 0;
+
+    if ( (*WTX_DMACH_ON & (1 << i)) ) {
+        len += sprintf(buf + len, "%2d. valid\n", i);
+        len += sprintf(buf + len, "    queue 0x%08x - sbid %u, qsb vcid %u, qsb %s\n", (unsigned int)WTX_QUEUE_CONFIG(i), (unsigned int)WTX_QUEUE_CONFIG(i)->sbid, (unsigned int)WTX_QUEUE_CONFIG(i)->qsb_vcid, WTX_QUEUE_CONFIG(i)->qsben ? "enable" : "disable");
+        len += sprintf(buf + len, "    dma   0x%08x - base %08x, len %u, vlddes %u\n", (unsigned int)WTX_DMA_CHANNEL_CONFIG(i), WTX_DMA_CHANNEL_CONFIG(i)->desba, WTX_DMA_CHANNEL_CONFIG(i)->deslen, WTX_DMA_CHANNEL_CONFIG(i)->vlddes);
+    }
+    else
+        len += sprintf(buf + len, "%2d. invalid\n", i);
+
+    return len;
+}
+
+static int proc_read_txq(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int len = 0;
+    int len_max = off + count;
+    char *pstr;
+    char str[1024];
+    int llen;
+
+    int i;
+
+    pstr = *start = page;
+
+    llen = sprintf(pstr, "TX Queue Config (Max %d):\n", *CFG_WTX_DCHNUM);
+    pstr += llen;
+    len += llen;
+
+    for ( i = 0; i < 16; i++ ) {
+        llen = print_tx_queue(str, i);
+        if ( len <= off && len + llen > off ) {
+            memcpy(pstr, str + off - len, len + llen - off);
+            pstr += len + llen - off;
+        }
+        else if ( len > off ) {
+            memcpy(pstr, str, llen);
+            pstr += llen;
+        }
+        len += llen;
+        if ( len >= len_max )
+            goto PROC_READ_HTU_OVERRUN_END;
+    }
+
+    *eof = 1;
+
+    return len - off;
+
+PROC_READ_HTU_OVERRUN_END:
+
+    return len - llen - off;
+}
+
+ #if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+
+static int proc_read_retx_fw(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int len = 0;
+
+    unsigned int next_dtu_sid_out, last_dtu_sid_in, next_cell_sid_out, isr_cell_id;
+    unsigned int curr_time, sec_counter, curr_efb;
+    struct Retx_adsl_ppe_intf adsl_ppe_intf;
+
+    adsl_ppe_intf       = *RETX_ADSL_PPE_INTF;
+    next_dtu_sid_out    = *NEXT_DTU_SID_OUT;
+    last_dtu_sid_in     = *LAST_DTU_SID_IN;
+    next_cell_sid_out   = *NEXT_CELL_SID_OUT;
+    isr_cell_id         = *ISR_CELL_ID;
+
+    curr_time   = *URetx_curr_time;
+    sec_counter = *URetx_sec_counter;
+    curr_efb    = *RxCURR_EFB;
+
+
+    len += sprintf(page + off + len, "Adsl-PPE Interface:\n");
+    len += sprintf(page + off + len, "  dtu_sid                = 0x%02x [%3u]\n", adsl_ppe_intf.dtu_sid, adsl_ppe_intf.dtu_sid);
+    len += sprintf(page + off + len, "  dtu_timestamp          = 0x%02x\n", adsl_ppe_intf.dtu_timestamp);
+    len += sprintf(page + off + len, "  local_time             = 0x%02x\n", adsl_ppe_intf.local_time);
+    len += sprintf(page + off + len, "  is_last_cw             = %u\n", adsl_ppe_intf.is_last_cw);
+    len += sprintf(page + off + len, "  reinit_flag            = %u\n", adsl_ppe_intf.reinit_flag);
+    len += sprintf(page + off + len, "  is_bad_cw              = %u\n", adsl_ppe_intf.is_bad_cw);
+    len += sprintf(page + off + len, "\n");
+
+
+    len += sprintf(page + off + len, "Retx Firmware Context:\n");
+    len += sprintf(page + off + len, "  next_dtu_sid_out       (0x%08x)  = 0x%02x [%3u]\n", (unsigned int )NEXT_DTU_SID_OUT,   next_dtu_sid_out, next_dtu_sid_out);
+    len += sprintf(page + off + len, "  last_dtu_sid_in        (0x%08x)  = 0x%02x [%3u]\n", (unsigned int )LAST_DTU_SID_IN,    last_dtu_sid_in,  last_dtu_sid_in);
+    len += sprintf(page + off + len, "  next_cell_sid_out      (0x%08x)  = %u\n", (unsigned int )NEXT_CELL_SID_OUT,  next_cell_sid_out);
+    len += sprintf(page + off + len, "  isr_cell_id            (0x%08x)  = %u\n", (unsigned int )ISR_CELL_ID,        isr_cell_id);
+    len += sprintf(page + off + len, "  pb_cell_search_idx     (0x%08x)  = %u\n", (unsigned int )PB_CELL_SEARCH_IDX, *PB_CELL_SEARCH_IDX);
+    len += sprintf(page + off + len, "  pb_read_pend_flag      (0x%08x)  = %u\n", (unsigned int )PB_READ_PEND_FLAG,  *PB_READ_PEND_FLAG);
+    len += sprintf(page + off + len, "  rfbi_first_cw          (0x%08x)  = %u\n", (unsigned int )RFBI_FIRST_CW,      *RFBI_FIRST_CW);
+    len += sprintf(page + off + len, "  rfbi_bad_cw            (0x%08x)  = %u\n", (unsigned int )RFBI_BAD_CW,        *RFBI_BAD_CW);
+    len += sprintf(page + off + len, "  rfbi_invalid_cw        (0x%08x)  = %u\n", (unsigned int )RFBI_INVALID_CW,    *RFBI_INVALID_CW);
+    len += sprintf(page + off + len, "  rfbi_retx_cw           (0x%08x)  = %u\n", (unsigned int )RFBI_RETX_CW,       *RFBI_RETX_CW);
+    len += sprintf(page + off + len, "  rfbi_chk_dtu_status    (0x%08x)  = %u\n", (unsigned int )RFBI_CHK_DTU_STATUS,*RFBI_CHK_DTU_STATUS);
+    len += sprintf(page + off + len, "\n");
+
+
+    len += sprintf(page + off + len, "SFSM Status:  bc0                      bc1  \n\n");
+    len += sprintf(page + off + len, "  state     = %-22s , %s\n",
+          (*__WRXCTXT_PortState(0) & 3) == 0 ? "Hunt" :
+          (*__WRXCTXT_PortState(0) & 3) == 1 ? "Pre_sync" :
+          (*__WRXCTXT_PortState(0) & 3) == 2 ? "Sync" :
+                                               "Unknown(error)",
+          (*__WRXCTXT_PortState(1) & 3) == 0 ? "Hunt" :
+          (*__WRXCTXT_PortState(1) & 3) == 1 ? "Pre_sync" :
+          (*__WRXCTXT_PortState(1) & 3) == 2 ? "Sync" :
+                                               "Unknown(error)"  );
+    len += sprintf(page + off + len, "  dbase     = 0x%04x  ( 0x%08x ) , 0x%04x  ( 0x%08x )\n",
+            SFSM_DBA(0)->dbase, (unsigned int)PPM_INT_UNIT_ADDR(SFSM_DBA(0)->dbase + 0x2000),
+            SFSM_DBA(1)->dbase, (unsigned int)PPM_INT_UNIT_ADDR(SFSM_DBA(1)->dbase + 0x2000));
+    len += sprintf(page + off + len, "  cbase     = 0x%04x  ( 0x%08x ) , 0x%04x  ( 0x%08x )\n",
+            SFSM_CBA(0)->cbase, (unsigned int)PPM_INT_UNIT_ADDR(SFSM_CBA(0)->cbase + 0x2000),
+            SFSM_CBA(1)->cbase, (unsigned int)PPM_INT_UNIT_ADDR(SFSM_CBA(1)->cbase + 0x2000));
+    len += sprintf(page + off + len, "  sen       = %-22d , %d\n", SFSM_CFG(0)->sen,        SFSM_CFG(1)->sen );
+    len += sprintf(page + off + len, "  idlekeep  = %-22d , %d\n", SFSM_CFG(0)->idlekeep,   SFSM_CFG(1)->idlekeep );
+    len += sprintf(page + off + len, "  pnum      = %-22d , %d\n", SFSM_CFG(0)->pnum,       SFSM_CFG(1)->pnum );
+    len += sprintf(page + off + len, "  pptr      = %-22d , %d\n", SFSM_PGCNT(0)->pptr,     SFSM_PGCNT(1)->pptr);
+    len += sprintf(page + off + len, "  upage     = %-22d , %d\n", SFSM_PGCNT(0)->upage,    SFSM_PGCNT(1)->upage);
+    len += sprintf(page + off + len, "  l2_rdptr  = %-22d , %d\n", *__WRXCTXT_L2_RdPtr(0),  *__WRXCTXT_L2_RdPtr(1) );
+    len += sprintf(page + off + len, "  l2_page   = %-22d , %d\n", *__WRXCTXT_L2Pages(0),   *__WRXCTXT_L2Pages(1) );
+    len += sprintf(page + off + len, "\n");
+
+
+    len += sprintf(page + off + len, "FFSM Status:  bc0                      bc1  \n\n");
+    len += sprintf(page + off + len, "  dbase     = 0x%04x  ( 0x%08x ) , 0x%04x  ( 0x%08x )\n",
+            FFSM_DBA(0)->dbase, (unsigned int)PPM_INT_UNIT_ADDR(FFSM_DBA(0)->dbase + 0x2000),
+            FFSM_DBA(1)->dbase, (unsigned int)PPM_INT_UNIT_ADDR(FFSM_DBA(1)->dbase + 0x2000));
+    len += sprintf(page + off + len, "  pnum      = %-22d , %d\n", FFSM_CFG(0)->pnum,       FFSM_CFG(1)->pnum);
+    len += sprintf(page + off + len, "  vpage     = %-22d , %d\n", FFSM_PGCNT(0)->vpage,    FFSM_PGCNT(1)->vpage);
+    len += sprintf(page + off + len, "  ival      = %-22d , %d\n", FFSM_PGCNT(0)->ival,     FFSM_PGCNT(1)->ival);
+    len += sprintf(page + off + len, "  tc_wrptr  = %-22d , %d\n", *__WTXCTXT_TC_WRPTR(0),  *__WTXCTXT_TC_WRPTR(1));
+    len += sprintf(page + off + len, "\n");
+
+
+    len += sprintf(page + off + len, "Misc:  \n\n");
+    len += sprintf(page + off + len, "  curr_time   = %08x\n", curr_time );
+    len += sprintf(page + off + len, "  sec_counter = %d\n", sec_counter );
+    len += sprintf(page + off + len, "  curr_efb    = %d\n", curr_efb );
+    len += sprintf(page + off + len, "\n");
+
+    *eof = 1;
+
+    return len;
+}
+
+static inline int is_valid(unsigned int * dtu_vld_stat, int dtu_sid)
+{
+    int dw_idx = (dtu_sid / 32) & 7;
+    int bit_pos = dtu_sid % 32;
+
+    return dtu_vld_stat[dw_idx] & (0x80000000 >> bit_pos);
+}
+
+static int proc_read_retx_stats(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int i;
+    int len = 0;
+    int len_max = off + count;
+    char *pstr;
+    char str[2048];
+    int llen = 0;
+
+    unsigned int next_dtu_sid_out, last_dtu_sid_in, next_cell_sid_out;
+    unsigned int dtu_vld_stat[8];
+    struct DTU_stat_info dtu_stat_info[256];
+    struct Retx_adsl_ppe_intf adsl_ppe_intf;
+
+    pstr = *start = page;
+
+    __sync();
+
+    // capture a snapshot of internal status
+    next_dtu_sid_out    = *NEXT_DTU_SID_OUT;
+    last_dtu_sid_in     = *LAST_DTU_SID_IN;
+    next_cell_sid_out   = *NEXT_CELL_SID_OUT;
+    adsl_ppe_intf       = *RETX_ADSL_PPE_INTF;
+
+    memcpy(&dtu_vld_stat, (void *)DTU_VLD_STAT, sizeof(dtu_vld_stat));
+    memcpy(&dtu_stat_info, (void *)DTU_STAT_INFO, sizeof(dtu_stat_info));
+
+
+    llen += sprintf(str + llen, "Adsl-PPE Interface:\n");
+    llen += sprintf(str + llen, "  dtu_sid                = 0x%02x [%3u]\n", adsl_ppe_intf.dtu_sid, adsl_ppe_intf.dtu_sid);
+    llen += sprintf(str + llen, "  dtu_timestamp          = 0x%02x\n", adsl_ppe_intf.dtu_timestamp);
+    llen += sprintf(str + llen, "  local_time             = 0x%02x\n", adsl_ppe_intf.local_time);
+    llen += sprintf(str + llen, "  is_last_cw             = %u\n", adsl_ppe_intf.is_last_cw);
+    llen += sprintf(str + llen, "  reinit_flag            = %u\n", adsl_ppe_intf.reinit_flag);
+    llen += sprintf(str + llen, "  is_bad_cw              = %u\n", adsl_ppe_intf.is_bad_cw);
+    llen += sprintf(str + llen, "\n");
+
+    llen += sprintf(str + llen, "Retx Internal State:\n");
+    llen += sprintf(str + llen, "  next_dtu_sid_out       (0x%08x)  = 0x%02x [%3u]\n", (unsigned int )NEXT_DTU_SID_OUT,   next_dtu_sid_out, next_dtu_sid_out);
+    llen += sprintf(str + llen, "  last_dtu_sid_in        (0x%08x)  = 0x%02x [%3u]\n", (unsigned int )LAST_DTU_SID_IN,    last_dtu_sid_in, last_dtu_sid_in);
+    llen += sprintf(str + llen, "  next_cell_sid_out      (0x%08x)  = %u\n", (unsigned int )NEXT_CELL_SID_OUT,  next_cell_sid_out);
+    llen += sprintf(str + llen, "  dtu_valid_stat         (0x%08x)\n", (unsigned int )DTU_VLD_STAT);
+    llen += sprintf(str + llen, "  dtu_stat_info          (0x%08x)\n", (unsigned int )DTU_STAT_INFO);
+    llen += sprintf(str + llen, "  pb_buffer_usage        (0x%08x)\n", (unsigned int )PB_BUFFER_USAGE);
+
+    if ( len <= off && len + llen > off ) {
+        memcpy(pstr, str + off - len, len + llen - off);
+        pstr += len + llen - off;
+    }
+    else if ( len > off ) {
+        memcpy(pstr, str, llen);
+        pstr += llen;
+    }
+    len += llen;
+    if ( len >= len_max )
+        goto PROC_READ_RETX_STATS_OVERRUN_END;
+    llen = 0;
+
+
+    llen += sprintf(str + llen, "\n");
+    llen += sprintf(str + llen, "DTU_VALID_STAT: [0x%08x]:\n", (unsigned int)DTU_VLD_STAT);
+    llen += sprintf(str + llen, "%08X: %08X %08X %08X %08X    %08X %08X %08X %08X\n",
+                    (unsigned int)DTU_VLD_STAT,
+                    dtu_vld_stat[0], dtu_vld_stat[1], dtu_vld_stat[2], dtu_vld_stat[3],
+                    dtu_vld_stat[4], dtu_vld_stat[5], dtu_vld_stat[6], dtu_vld_stat[7]);
+
+    if ( len <= off && len + llen > off ) {
+        memcpy(pstr, str + off - len, len + llen - off);
+        pstr += len + llen - off;
+    }
+    else if ( len > off ) {
+        memcpy(pstr, str, llen);
+        pstr += llen;
+    }
+    len += llen;
+    if ( len >= len_max )
+        goto PROC_READ_RETX_STATS_OVERRUN_END;
+    llen = 0;
+
+
+    llen += sprintf(str + llen, "\n");
+    llen += sprintf(str + llen, "DTU_STAT_INFO: [0x%08x]:\n", (unsigned int)DTU_STAT_INFO);
+    llen += sprintf(str + llen, "dtu_id        ts   complete   bad  cell_cnt  dtu_rd_ptr  dtu_wr_ptr\n");
+    llen += sprintf(str + llen, "---------------------------------------------------------------------\n");
+    for ( i = 0; i < 256; i++ ) {
+        if ( !is_valid(dtu_vld_stat, i) )
+            continue;
+
+        llen += sprintf(str + llen, "0x%02x [%3u]   0x%02x      %d       %d     %3d        %5d      %5d\n",
+                        i, i,
+                        DTU_STAT_INFO[i].time_stamp,
+                        DTU_STAT_INFO[i].complete,
+                        DTU_STAT_INFO[i].bad,
+                        DTU_STAT_INFO[i].cell_cnt,
+                        DTU_STAT_INFO[i].dtu_rd_ptr,
+                        DTU_STAT_INFO[i].dtu_wr_ptr );
+
+        if ( len <= off && len + llen > off ) {
+            memcpy(pstr, str + off - len, len + llen - off);
+            pstr += len + llen - off;
+        }
+        else if ( len > off )
+        {
+            memcpy(pstr, str, llen);
+            pstr += llen;
+        }
+        len += llen;
+        if ( len >= len_max )
+            goto PROC_READ_RETX_STATS_OVERRUN_END;
+        llen = 0;
+    }
+
+
+    llen += sprintf(str + llen, "\n");
+    llen += sprintf(str + llen, "Playout buffer status --- valid status [0x%08x]:\n", (unsigned int)PB_BUFFER_USAGE);
+    for( i = 0; i <  RETX_MODE_CFG->buff_size; i += 8 ) {
+        llen += sprintf(str + llen, "%08X: %08X %08X %08X %08X    %08X %08X %08X %08X\n",
+                        (unsigned int)PB_BUFFER_USAGE + i * sizeof(unsigned int),
+                        PB_BUFFER_USAGE[i],   PB_BUFFER_USAGE[i+1], PB_BUFFER_USAGE[i+2], PB_BUFFER_USAGE[i+3],
+                        PB_BUFFER_USAGE[i+4], PB_BUFFER_USAGE[i+5], PB_BUFFER_USAGE[i+6], PB_BUFFER_USAGE[i+7]);
+    }
+
+    if ( len <= off && len + llen > off ) {
+        memcpy(pstr, str + off - len, len + llen - off);
+        pstr += len + llen - off;
+    }
+    else if ( len > off ) {
+        memcpy(pstr, str, llen);
+        pstr += llen;
+    }
+    len += llen;
+    if ( len >= len_max )
+        goto PROC_READ_RETX_STATS_OVERRUN_END;
+    llen = 0;
+
+
+    *eof = 1;
+
+    return len - off;
+
+PROC_READ_RETX_STATS_OVERRUN_END:
+    return len - llen - off;
+}
+
+static int proc_write_retx_stats(struct file *file, const char *buf, unsigned long count, void *data)
+{
+    char str[2048];
+    char *p;
+
+    int len, rlen;
+
+    len = count < sizeof(str) ? count : sizeof(str) - 1;
+    rlen = len - copy_from_user(str, buf, len);
+    while ( rlen && str[rlen - 1] <= ' ' )
+        rlen--;
+    str[rlen] = 0;
+    for ( p = str; *p && *p <= ' '; p++, rlen-- );
+    if ( !*p )
+        return 0;
+
+    if ( stricmp(p, "help") == 0 ) {
+        printk("echo clear_pb > /proc/driver/ifx_atm/retx_stats \n");
+        printk("   :clear context in playout buffer\n\n");
+        printk("echo read_pb <pb_index> <cell_num> > /proc/driver/ifx_atm/retx_stats\n");
+        printk("   : read playout buffer contents\n\n");
+        printk("echo read_[r|t]x_cb > /proc/driver/ifx_atm/retx_stats\n");
+        printk("   : read cell buffer\n\n");
+        printk("echo clear_[r|t]x_cb > /proc/driver/ifx_atm/retx_stats\n");
+        printk("   : clear cell buffer\n\n");
+        printk("echo read_bad_dtu_intf_rec > /proc/driver/ifx_atm/retx_stats\n");
+        printk("   : read bad dtu intrface information record\n\n");
+        printk("echo clear_bad_dtu_intf_rec > /proc/driver/ifx_atm/retx_stats\n");
+        printk("   : clear bad dtu interface information record\n\n");
+        printk("echo read_wrx_context [i] > /proc/driver/ifx_atm/retx_stats\n");
+        printk("   : clear bad dtu interface information record\n\n");
+        printk("echo read_intf_rec > /proc/driver/ifx_atm/retx_stats\n");
+        printk("   : read interface info record buffer\n\n");
+        printk("echo reinit_intf_rec > /proc/driver/ifx_atm/retx_stats\n");
+        printk("   : reinit intf record, must be called before showtime\n\n");
+    }
+    else if ( stricmp(p, "reinit_intf_rec") == 0 ) {
+        int i = 0;
+        struct Retx_adsl_ppe_intf_rec rec[16];
+
+        *DBG_DTU_INTF_WRPTR             = 0;
+        *DBG_INTF_FCW_DUP_CNT           = 0;
+        *DBG_INTF_SID_CHANGE_IN_DTU_CNT = 0;
+        *DBG_INTF_LCW_DUP_CNT           = 0;
+
+        *DBG_RFBI_DONE_INT_CNT          = 0;
+        *DBG_RFBI_INTV0                 = 0;
+        *DBG_RFBI_INTV1                 = 0;
+        *DBG_RFBI_BC0_INVALID_CNT       = 0;
+        *DBG_RFBI_LAST_T                = 0;
+        *DBG_DREG_BEG_END               = 0;
+
+        memset((void *) DBG_INTF_INFO(0), 0, sizeof(rec));
+        for( i = 0; i < 16; i++ )
+            DBG_INTF_INFO(i)->res1_1 = 1;
+        DBG_INTF_INFO(15)->dtu_sid = 255;
+    }
+    else if ( stricmp(p, "read_intf_rec") == 0 ) {
+        int i, cnt;
+        unsigned int dtu_intf_wrptr, fcw_dup_cnt, sid_change_in_dtu_cnt, lcw_dup_cnt ;
+        unsigned int rfbi_done_int_cnt, rfbi_intv0, rfbi_intv1, rfbi_bc0_invalid_cnt, dreg_beg_end;
+        struct Retx_adsl_ppe_intf_rec rec[16];
+
+        memcpy((void *) rec, (void *) DBG_INTF_INFO(0), sizeof(rec));
+
+        dtu_intf_wrptr          = *DBG_DTU_INTF_WRPTR;
+        fcw_dup_cnt             = *DBG_INTF_FCW_DUP_CNT;
+        sid_change_in_dtu_cnt   = *DBG_INTF_SID_CHANGE_IN_DTU_CNT;
+        lcw_dup_cnt             = *DBG_INTF_LCW_DUP_CNT;
+
+        rfbi_done_int_cnt       = *DBG_RFBI_DONE_INT_CNT;
+        rfbi_intv0              = *DBG_RFBI_INTV0;
+        rfbi_intv1              = *DBG_RFBI_INTV1;
+        rfbi_bc0_invalid_cnt    = *DBG_RFBI_BC0_INVALID_CNT;
+        dreg_beg_end            = *DBG_DREG_BEG_END;
+
+        printk("PPE-Adsl Interface recrod [addr 0x23F0]:\n\n");
+
+        printk("    rfbi_done_int_cnt   = %d [0x%x] \n", rfbi_done_int_cnt, rfbi_done_int_cnt);
+        printk("    rfbi_intv           = 0x%08x  0x%08x [%d, %d, %d, %d, %d, %d, %d, %d]\n",
+                    rfbi_intv0, rfbi_intv1,
+                    rfbi_intv0 >> 24, (rfbi_intv0>>16) & 0xff, (rfbi_intv0>>8) & 0xff, rfbi_intv0 & 0xff,
+                    rfbi_intv1 >> 24, (rfbi_intv1>>16) & 0xff, (rfbi_intv1>>8) & 0xff, rfbi_intv1 & 0xff
+                    );
+        printk("    rfbi_bc0_invld_cnt  = %d\n", rfbi_bc0_invalid_cnt);
+        printk("    dreg_beg_end        = %d, %d\n\n", dreg_beg_end >> 16, dreg_beg_end & 0xffff);
+
+        printk("    wrptr       = %d [0x%x] \n", dtu_intf_wrptr, dtu_intf_wrptr);
+        printk("    fcw_dup_cnt = %d\n", fcw_dup_cnt);
+        printk("    sid_chg_cnt = %d\n", sid_change_in_dtu_cnt);
+        printk("    lcw_dup_cnt = %d\n\n", lcw_dup_cnt);
+
+
+        printk("    idx  itf_dw0  itf_dw1  dtu_sid  timestamp  local_time   res1  last_cw  bad_flag  reinit\n");
+        printk("    -------------------------------------------------------------------------------------\n");
+        for ( i = (dtu_intf_wrptr + 1) % 16, cnt = 0; cnt < 16; cnt ++, i = (i + 1) % 16 ) {
+            if(cnt < 15)
+                printk("    ");
+            else
+                printk("   *");
+            printk("%3d    %04x    %04x    %3d[%02x]   %3d[%02x]     %3d[%02x]    0x%02x       %d       %d       %d\n",
+                i,
+                (*(unsigned int *)&rec[i]) & 0xffff,
+                (*(unsigned int *)&rec[i]) >> 16,
+                rec[i].dtu_sid, rec[i].dtu_sid,
+                rec[i].dtu_timestamp, rec[i].dtu_timestamp,
+                rec[i].local_time, rec[i].local_time,
+                rec[i].res1_1,
+                rec[i].is_last_cw,
+                rec[i].is_bad_cw,
+                rec[i].reinit_flag );
+        }
+    }
+    else if ( stricmp(p, "read_wrx_context") == 0 ) {
+        int i = 0;
+        int flag = 0;
+        for( i = 0; i < 8; ++i ) {
+            if ( !WRX_QUEUE_CONTEXT(i)->curr_des0 || !WRX_QUEUE_CONTEXT(i)->curr_des1 )
+                continue;
+
+            flag = 1;
+            printk("WRX queue context [ %d ]: \n", i);
+            printk("    curr_len = %4d, mfs = %d, ec = %d, clp1 = %d, aal5dp = %d\n",
+                    WRX_QUEUE_CONTEXT(i)->curr_len, WRX_QUEUE_CONTEXT(i)->mfs,
+                    WRX_QUEUE_CONTEXT(i)->ec, WRX_QUEUE_CONTEXT(i)->clp1,
+                    WRX_QUEUE_CONTEXT(i)->aal5dp);
+            printk("    initcrc  = %08x\n", WRX_QUEUE_CONTEXT(i)->intcrc);
+            printk("    currdes  = %08x %08x\n",
+                    WRX_QUEUE_CONTEXT(i)->curr_des0, WRX_QUEUE_CONTEXT(i)->curr_des1);
+            printk("    last_dw  = %08x\n\n", WRX_QUEUE_CONTEXT(i)->last_dword);
+            if( WRX_QUEUE_CONTEXT(i)->curr_len ) {
+                int j = 0;
+                unsigned char *p_char;
+                struct rx_descriptor *desc = (struct rx_descriptor *)&(WRX_QUEUE_CONTEXT(i)->curr_des0);
+                p_char = (unsigned char *)(((unsigned int)desc->dataptr << 2) | KSEG1);
+                printk("    Data in SDRAM:\n        ");
+
+                for ( j = 0 ; j < WRX_QUEUE_CONTEXT(i)->curr_len; ++j ) {
+                    printk ("%02x", p_char[j]);
+                    if ( j % 16 == 15 )
+                        printk("\n        ");
+                    else if ( j % 4 == 3 )
+                        printk (" ");
+                }
+                printk("\n\n");
+            }
+        }
+        if ( !flag ) {
+            printk("No active wrx queue context\n");
+        }
+    }
+    else if ( stricmp(p, "clear_pb") == 0 ) {
+        if ( g_retx_playout_buffer )
+            memset((void *)g_retx_playout_buffer, 0,  RETX_PLAYOUT_BUFFER_SIZE);
+    }
+    else if ( stricmp(p, "read_bad_dtu_intf_rec") == 0 ) {
+        struct Retx_adsl_ppe_intf first_dtu_intf, last_dtu_intf;
+        first_dtu_intf = *FIRST_BAD_REC_RETX_ADSL_PPE_INTF;
+        last_dtu_intf = *BAD_REC_RETX_ADSL_PPE_INTF;
+
+        printk("\nAdsl-PPE Interface for first and last DTU of recent noise:\n\n");
+        printk("  dtu_sid                = 0x%02x [%3u], 0x%02x [%3u]\n",
+                first_dtu_intf.dtu_sid, first_dtu_intf.dtu_sid,
+                last_dtu_intf.dtu_sid, last_dtu_intf.dtu_sid);
+        printk("  dtu_timestamp          = 0x%02x      , 0x%02x\n",
+                first_dtu_intf.dtu_timestamp, last_dtu_intf.dtu_timestamp);
+        printk("  local_time             = 0x%02x      , 0x%02x\n",
+                first_dtu_intf.local_time, last_dtu_intf.local_time);
+        printk("  is_last_cw             = %u          , %u\n",
+                first_dtu_intf.is_last_cw, last_dtu_intf.is_last_cw);
+        printk("  reinit_flag            = %u          , %u\n",
+                first_dtu_intf.reinit_flag, last_dtu_intf.reinit_flag);
+        printk("  is_bad_cw              = %u          , %u\n\n",
+                first_dtu_intf.is_bad_cw, last_dtu_intf.is_bad_cw);
+    }
+    else if ( stricmp(p, "clear_bad_dtu_intf_rec") == 0 ) {
+        memset((void *)BAD_REC_RETX_ADSL_PPE_INTF, 0, sizeof(struct Retx_adsl_ppe_intf));
+        memset((void *)FIRST_BAD_REC_RETX_ADSL_PPE_INTF, 0, sizeof(struct Retx_adsl_ppe_intf));
+    }
+    else if ( stricmp(p, "clear_tx_cb") == 0 ) {
+        unsigned int *dbase0;
+        unsigned int pnum0;
+
+        dbase0 = (unsigned int *)PPM_INT_UNIT_ADDR( FFSM_DBA(0)->dbase + 0x2000);
+        pnum0 = FFSM_CFG(0)->pnum;
+        memset(dbase0, 0,  14 * sizeof(unsigned int ) * pnum0);
+    }
+    else if ( stricmp(p, "clear_rx_cb") == 0 ) {
+        unsigned int *dbase0, *cbase0, *dbase1, *cbase1;
+        unsigned int pnum0;
+
+        dbase0 = (unsigned int *)PPM_INT_UNIT_ADDR( SFSM_DBA(0)->dbase + 0x2000);
+        cbase0 = (unsigned int *)PPM_INT_UNIT_ADDR( SFSM_CBA(0)->cbase + 0x2000);
+
+        dbase1 = (unsigned int *)PPM_INT_UNIT_ADDR( SFSM_DBA(1)->dbase + 0x2000);
+        cbase1 = (unsigned int *)PPM_INT_UNIT_ADDR( SFSM_CBA(1)->cbase + 0x2000);
+
+        pnum0 = SFSM_CFG(0)->pnum;
+
+        memset(dbase0, 0,  14 * sizeof(unsigned int ) * pnum0);
+        memset(cbase0, 0,  sizeof(unsigned int ) * pnum0);
+
+        memset(dbase1, 0,  14 * sizeof(unsigned int ));
+        memset(cbase1, 0,  sizeof(unsigned int ));
+    }
+    else if ( strnicmp(p, "read_tx_cb", 10) == 0 ) {
+        unsigned int *dbase0;
+        unsigned int pnum0, i;
+        unsigned int * cell;
+
+        dbase0 = (unsigned int *)PPM_INT_UNIT_ADDR( FFSM_DBA(0)->dbase + 0x2000);
+        pnum0 = FFSM_CFG(0)->pnum;
+
+        printk("ATM TX BC 0 CELL data/ctrl buffer:\n\n");
+        for(i = 0; i < pnum0 ; ++ i) {
+            cell = dbase0 + i * 14;
+            printk("cell %2d:                   %08x %08x\n", i, cell[0], cell[1]);
+            printk("         %08x %08x %08x %08x\n",  cell[2], cell[3], cell[4], cell[5]);
+            printk("         %08x %08x %08x %08x\n",  cell[6], cell[7], cell[8], cell[9]);
+            printk("         %08x %08x %08x %08x\n",  cell[10], cell[11], cell[12], cell[13]);
+        }
+    }
+    else if ( strnicmp(p, "read_rx_cb", 10) == 0 ) {
+        unsigned int *dbase0, *cbase0, *dbase1, *cbase1;
+        unsigned int pnum0, i;
+        unsigned int * cell;
+
+        dbase0 = (unsigned int *)PPM_INT_UNIT_ADDR( SFSM_DBA(0)->dbase + 0x2000);
+        cbase0 = (unsigned int *)PPM_INT_UNIT_ADDR( SFSM_CBA(0)->cbase + 0x2000);
+
+        dbase1 = (unsigned int *)PPM_INT_UNIT_ADDR( SFSM_DBA(1)->dbase + 0x2000);
+        cbase1 = (unsigned int *)PPM_INT_UNIT_ADDR( SFSM_CBA(1)->cbase + 0x2000);
+
+        pnum0 = SFSM_CFG(0)->pnum;
+
+        printk("ATM RX BC 0 CELL data/ctrl buffer:\n\n");
+        for(i = 0; i < pnum0 ; ++ i) {
+            struct Retx_ctrl_field * p_ctrl;
+
+            cell = dbase0 + i * 14;
+            p_ctrl = (struct Retx_ctrl_field *) ( &cbase0[i]);
+            printk("cell %2d:                   %08x %08x  -- [%08x]:", i, cell[0], cell[1], cbase0[i]);
+
+            printk("l2_drop: %d, retx: %d", p_ctrl->l2_drop, p_ctrl->retx);
+            if ( p_ctrl->retx ) {
+                printk(", dtu_sid = %u, cell_sid = %u", p_ctrl->dtu_sid, p_ctrl->cell_sid);
+            }
+
+            printk("\n");
+
+            printk("         %08x %08x %08x %08x\n",  cell[2], cell[3], cell[4], cell[5]);
+            printk("         %08x %08x %08x %08x\n",  cell[6], cell[7], cell[8], cell[9]);
+            printk("         %08x %08x %08x %08x\n",  cell[10], cell[11], cell[12], cell[13]);
+        }
+
+        printk("\n");
+        printk("ATM RX BC 1 CELL data/ctrl buffer:\n\n");
+        cell = dbase1;
+        printk("cell %2d:                   %08x %08x  -- [%08x]: dtu_sid:%3d, cell_sid:%3d, next_ptr: %4d\n",
+                0, cell[0], cell[1], cbase0[i], ( cell[1] >> 16) & 0xff, (cell[1] >> 24) & 0xff,    cell[1] & 0xffff );
+        printk("         %08x %08x %08x %08x\n",  cell[2], cell[3], cell[4], cell[5]);
+        printk("         %08x %08x %08x %08x\n",  cell[6], cell[7], cell[8], cell[9]);
+        printk("         %08x %08x %08x %08x\n",  cell[10], cell[11], cell[12], cell[13]);
+    }
+    else if ( strnicmp(p, "read_pb ", 8) == 0 )
+    {
+        int start_cell_idx = 0;
+        int cell_num = 0;
+        unsigned int *cell;
+        unsigned int pb_buff_size = RETX_MODE_CFG->buff_size * 32;
+
+        p += 8;
+        rlen -= 8;
+        ignore_space(&p, &rlen);
+
+        start_cell_idx = get_number(&p, &rlen, 0);
+        ignore_space(&p, &rlen);
+        cell_num = get_number(&p, &rlen, 0);
+
+        if ( start_cell_idx >= pb_buff_size ) {
+            printk(" Invalid cell index\n");
+        }
+        else {
+            int i;
+            if ( cell_num < 0 )
+                cell_num = 1;
+
+            if ( cell_num + start_cell_idx > pb_buff_size )
+                cell_num = pb_buff_size - start_cell_idx;
+
+            for ( i = 0; i < cell_num ; ++i ) {
+                cell = (unsigned int *)((unsigned int *)g_retx_playout_buffer + (14 * (start_cell_idx + i)));
+                printk("cell %4d:          %08x %08x [next_ptr = %4u, dtu_sid = %3u, cell_sid = %3u]\n",
+                        start_cell_idx + i, cell[0], cell[1], cell[1] & 0xffff, (cell[1] >> 16) & 0xff, (cell[1] >> 24) & 0xff);
+                printk("  %08x %08x %08x %08x\n",  cell[2], cell[3], cell[4], cell[5]);
+                printk("  %08x %08x %08x %08x\n",  cell[6], cell[7], cell[8], cell[9]);
+                printk("  %08x %08x %08x %08x\n",  cell[10], cell[11], cell[12], cell[13]);
+            }
+        }
+    }
+
+    return count;
+}
+
+static int proc_read_retx_cfg(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int len = 0;
+
+    len += sprintf(page + off + len, "ReTX FW Config:\n");
+    len += sprintf(page + off + len, "  RETX_MODE_CFG            = 0x%08x, invld_range=%u, buff_size=%u, retx=%u\n", *(volatile unsigned int *)RETX_MODE_CFG, (unsigned int)RETX_MODE_CFG->invld_range, (unsigned int)RETX_MODE_CFG->buff_size * 32, (unsigned int)RETX_MODE_CFG->retx_en);
+    len += sprintf(page + off + len, "  RETX_TSYNC_CFG           = 0x%08x, fw_alpha=%u, sync_inp=%u\n", *(volatile unsigned int *)RETX_TSYNC_CFG, (unsigned int)RETX_TSYNC_CFG->fw_alpha, (unsigned int)RETX_TSYNC_CFG->sync_inp);
+    len += sprintf(page + off + len, "  RETX_TD_CFG              = 0x%08x, td_max=%u, td_min=%u\n", *(volatile unsigned int *)RETX_TD_CFG, (unsigned int)RETX_TD_CFG->td_max, (unsigned int)RETX_TD_CFG->td_min);
+    len += sprintf(page + off + len, "  RETX_PLAYOUT_BUFFER_BASE = 0x%08x\n", *RETX_PLAYOUT_BUFFER_BASE);
+    len += sprintf(page + off + len, "  RETX_SERVICE_HEADER_CFG  = 0x%08x\n", *RETX_SERVICE_HEADER_CFG);
+    len += sprintf(page + off + len, "  RETX_MASK_HEADER_CFG     = 0x%08x\n", *RETX_MASK_HEADER_CFG);
+    len += sprintf(page + off + len, "  RETX_MIB_TIMER_CFG       = 0x%08x, tick_cycle = %d, ticks_per_sec = %d\n",
+                    *(unsigned int *)RETX_MIB_TIMER_CFG, RETX_MIB_TIMER_CFG->tick_cycle, RETX_MIB_TIMER_CFG->ticks_per_sec);
+
+    *eof = 1;
+
+    return len;
+}
+
+static int proc_write_retx_cfg(struct file *file, const char *buf, unsigned long count, void *data)
+{
+    char *p1, *p2;
+    int len;
+    int colon;
+    char local_buf[1024];
+    char *tokens[4] = {0};
+    unsigned int token_num = 0;
+
+    len = sizeof(local_buf) < count ? sizeof(local_buf) - 1 : count;
+    len = len - copy_from_user(local_buf, buf, len);
+    local_buf[len] = 0;
+
+    p1 = local_buf;
+    colon = 0;
+    while ( token_num < NUM_ENTITY(tokens) && get_token(&p1, &p2, &len, &colon) ) {
+        tokens[token_num++] = p1;
+
+        p1 = p2;
+    }
+
+    if ( token_num > 0 ) {
+        if ( stricmp(tokens[0], "help") == 0 ) {
+            printk("echo help > /proc/driver/ifx_atm/retx_cfg ==> \n\tprint this help message\n\n");
+
+            printk("echo set retx <enable|disable|0|1|on|off> > /proc/driver/ifx_atm/retx_cfg\n");
+            printk("\t:enable or disable retx feature\n\n");
+
+            printk("echo set <td_max|td_min|fw_alpha|sync_inp|invld_range|buff_size> <number> > /proc/driver/ifx_atm/retx_cfg\n");
+            printk("\t: set td_max, td_min, fw_alpha, sync_inp, invalid_range, buff_size\n\n");
+
+            printk("echo set <service_header|service_mask> <hex_number> /proc/driver/ifx_atm/retx_cfg \n");
+            printk("\t: set service_header, service_mask\n\n");
+        }
+        else if ( stricmp(tokens[0], "set") == 0 && token_num >= 3 ) {
+
+            if ( stricmp(tokens[1], "retx") == 0 ) {
+                if ( stricmp(tokens[2], "enable") == 0 ||
+                     stricmp(tokens[2], "on") == 0 ||
+                     stricmp(tokens[2], "1") == 0 )
+                    RETX_MODE_CFG->retx_en = 1;
+                else if ( stricmp(tokens[2], "disable") == 0 ||
+                     stricmp(tokens[2], "off") == 0 ||
+                     stricmp(tokens[2], "0") == 0 )
+                    RETX_MODE_CFG->retx_en = 0;
+                printk("RETX_MODE_CFG->retx_en - %d\n", RETX_MODE_CFG->retx_en);
+            }
+            else {
+                unsigned int dec_val, hex_val;
+
+                p1 = tokens[2];
+                dec_val = (unsigned int)get_number(&p1, NULL, 0);
+                p2 = tokens[2];
+                hex_val = (unsigned int)get_number(&p2, NULL, 1);
+
+                if ( *p2 == 0 ) {
+                    if ( stricmp(tokens[1], "service_header") == 0 ) {
+                        *RETX_SERVICE_HEADER_CFG = hex_val;
+                        printk("RETX_SERVICE_HEADER_CFG - 0x%08x\n", *RETX_SERVICE_HEADER_CFG);
+                    }
+                    else if ( stricmp(tokens[1], "service_mask") == 0 ) {
+                        *RETX_MASK_HEADER_CFG = hex_val;
+                        printk("RETX_MASK_HEADER_CFG - 0x%08x\n", *RETX_MASK_HEADER_CFG);
+                    }
+                }
+                if ( *p1 == 0 ) {
+                    if ( stricmp(tokens[1], "td_max") == 0 ) {
+                        RETX_TD_CFG->td_max = (unsigned int)(dec_val >= 0xff ? 0xff : dec_val);
+                        printk("RETX_TD_CFG->td_max - %d\n", RETX_TD_CFG->td_max);
+                    }
+                    else if ( stricmp(tokens[1], "td_min") == 0 ) {
+                        RETX_TD_CFG->td_min = (unsigned int)(dec_val >= 0xff ? 0xff : dec_val);
+                        printk("RETX_TD_CFG->td_min - %d\n", RETX_TD_CFG->td_min);
+                    }
+                    else if ( stricmp(tokens[1], "fw_alpha") == 0 ) {
+                        RETX_TSYNC_CFG->fw_alpha = dec_val >= 0x7FFE ? 0X7EEE : dec_val;
+                        printk("RETX_TSYNC_CFG->fw_alpha - %d\n", RETX_TSYNC_CFG->fw_alpha);
+                    }
+                    else if ( stricmp(tokens[1], "sync_inp") == 0 ) {
+                        RETX_TSYNC_CFG->sync_inp = dec_val >= 0x7FFE ? 0X7EEE : dec_val;
+                        printk("RETX_TSYNC_CFG->sync_inp - %d\n", RETX_TSYNC_CFG->sync_inp);
+                    }
+                    else if ( stricmp(tokens[1], "invld_range") == 0 ) {
+                        RETX_MODE_CFG->invld_range = dec_val >= 250 ? 250 : dec_val;
+                        printk("RETX_MODE_CFG->invld_range - %d\n", RETX_MODE_CFG->invld_range);
+                    }
+                    else if ( stricmp(tokens[1], "buff_size") == 0 ) {
+                        dec_val = (dec_val + 31) / 32;
+                        RETX_MODE_CFG->buff_size = dec_val >= 4096 / 32 ? 4096 / 32 : dec_val;
+                        printk("RETX_MODE_CFG->buff_size - %d\n", RETX_MODE_CFG->buff_size);
+                    }
+                }
+            }
+
+        }
+    }
+
+    return count;
+}
+
+static int proc_read_retx_dsl_param(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int len = 0;
+
+    len += sprintf(page + off + len, "DSL Param [timestamp %ld.%ld]:\n", g_retx_polling_start.tv_sec, g_retx_polling_start.tv_usec);
+
+    if ( g_xdata_addr == NULL )
+        len += sprintf(page + off + len, "  DSL parameters not available !\n");
+    else {
+        volatile struct dsl_param *p_dsl_param = (volatile struct dsl_param *)g_xdata_addr;
+
+        len += sprintf(page + off + len, "  update_flag             = %u\n",     p_dsl_param->update_flag);
+        len += sprintf(page + off + len, "  MinDelayrt              = %u\n",     p_dsl_param->MinDelayrt);
+        len += sprintf(page + off + len, "  MaxDelayrt              = %u\n",     p_dsl_param->MaxDelayrt);
+        len += sprintf(page + off + len, "  RetxEnable              = %u\n",     p_dsl_param->RetxEnable);
+        len += sprintf(page + off + len, "  ServiceSpecificReTx     = %u\n",     p_dsl_param->ServiceSpecificReTx);
+        len += sprintf(page + off + len, "  ReTxPVC                 = 0x%08x\n", p_dsl_param->ReTxPVC);
+        len += sprintf(page + off + len, "  RxDtuCorruptedCNT       = %u\n",     p_dsl_param->RxDtuCorruptedCNT);
+        len += sprintf(page + off + len, "  RxRetxDtuUnCorrectedCNT = %u\n",     p_dsl_param->RxRetxDtuUnCorrectedCNT);
+        len += sprintf(page + off + len, "  RxLastEFB               = %u\n",     p_dsl_param->RxLastEFB);
+        len += sprintf(page + off + len, "  RxDtuCorrectedCNT       = %u\n",     p_dsl_param->RxDtuCorrectedCNT);
+    }
+    if ( g_retx_polling_end.tv_sec != 0 || g_retx_polling_end.tv_usec != 0 ) {
+        unsigned long polling_time_usec;
+
+        polling_time_usec = (g_retx_polling_end.tv_sec - g_retx_polling_start.tv_sec) * 1000000 + (g_retx_polling_end.tv_usec - g_retx_polling_start.tv_usec);
+        len += sprintf(page + off + len, "DSL Param Update Time: %lu.%03lums\n", polling_time_usec / 1000, polling_time_usec % 1000);
+    }
+
+    return len;
+}
+
+ #endif
+
+#endif
+
+static int stricmp(const char *p1, const char *p2)
+{
+    int c1, c2;
+
+    while ( *p1 && *p2 ) {
+        c1 = *p1 >= 'A' && *p1 <= 'Z' ? *p1 + 'a' - 'A' : *p1;
+        c2 = *p2 >= 'A' && *p2 <= 'Z' ? *p2 + 'a' - 'A' : *p2;
+        if ( (c1 -= c2) )
+            return c1;
+        p1++;
+        p2++;
+    }
+
+    return *p1 - *p2;
+}
+
+#if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
+
+static int strincmp(const char *p1, const char *p2, int n)
+{
+    int c1 = 0, c2;
+
+    while ( n && *p1 && *p2 ) {
+        c1 = *p1 >= 'A' && *p1 <= 'Z' ? *p1 + 'a' - 'A' : *p1;
+        c2 = *p2 >= 'A' && *p2 <= 'Z' ? *p2 + 'a' - 'A' : *p2;
+        if ( (c1 -= c2) )
+            return c1;
+        p1++;
+        p2++;
+        n--;
+    }
+
+    return n ? *p1 - *p2 : c1;
+}
+
+static int get_token(char **p1, char **p2, int *len, int *colon)
+{
+    int tlen = 0;
+
+    while ( *len && !((**p1 >= 'A' && **p1 <= 'Z') || (**p1 >= 'a' && **p1<= 'z') || (**p1 >= '0' && **p1<= '9')) )
+    {
+        (*p1)++;
+        (*len)--;
+    }
+    if ( !*len )
+        return 0;
+
+    if ( *colon )
+    {
+        *colon = 0;
+        *p2 = *p1;
+        while ( *len && **p2 > ' ' && **p2 != ',' )
+        {
+            if ( **p2 == ':' )
+            {
+                *colon = 1;
+                break;
+            }
+            (*p2)++;
+            (*len)--;
+            tlen++;
+        }
+        **p2 = 0;
+    }
+    else
+    {
+        *p2 = *p1;
+        while ( *len && **p2 > ' ' && **p2 != ',' )
+        {
+            (*p2)++;
+            (*len)--;
+            tlen++;
+        }
+        **p2 = 0;
+    }
+
+    return tlen;
+}
+
+static unsigned int get_number(char **p, int *len, int is_hex)
+{
+    unsigned int ret = 0;
+    unsigned int n = 0;
+
+    if ( (*p)[0] == '0' && (*p)[1] == 'x' )
+    {
+        is_hex = 1;
+        (*p) += 2;
+        if ( len )
+            (*len) -= 2;
+    }
+
+    if ( is_hex )
+    {
+        while ( (!len || *len) && ((**p >= '0' && **p <= '9') || (**p >= 'a' && **p <= 'f') || (**p >= 'A' && **p <= 'F')) )
+        {
+            if ( **p >= '0' && **p <= '9' )
+                n = **p - '0';
+            else if ( **p >= 'a' && **p <= 'f' )
+               n = **p - 'a' + 10;
+            else if ( **p >= 'A' && **p <= 'F' )
+                n = **p - 'A' + 10;
+            ret = (ret << 4) | n;
+            (*p)++;
+            if ( len )
+                (*len)--;
+        }
+    }
+    else
+    {
+        while ( (!len || *len) && **p >= '0' && **p <= '9' )
+        {
+            n = **p - '0';
+            ret = ret * 10 + n;
+            (*p)++;
+            if ( len )
+                (*len)--;
+        }
+    }
+
+    return ret;
+}
+
+static void ignore_space(char **p, int *len)
+{
+    while ( *len && (**p <= ' ' || **p == ':' || **p == '.' || **p == ',') )
+    {
+        (*p)++;
+        (*len)--;
+    }
+}
+
+#endif
+
+static INLINE int ifx_atm_version(char *buf)
+{
+    int len = 0;
+    unsigned int major, minor;
+
+    ifx_atm_get_fw_ver(&major, &minor);
+
+    len += ifx_drv_ver(buf + len, "ATM", IFX_ATM_VER_MAJOR, IFX_ATM_VER_MID, IFX_ATM_VER_MINOR);
+    len += sprintf(buf + len, "    ATM (A1) firmware version %d.%d\n", major, minor);
+
+    return len;
+}
+
+static INLINE void check_parameters(void)
+{
+    /*  Please refer to Amazon spec 15.4 for setting these values.  */
+    if ( qsb_tau < 1 )
+        qsb_tau = 1;
+    if ( qsb_tstep < 1 )
+        qsb_tstep = 1;
+    else if ( qsb_tstep > 4 )
+        qsb_tstep = 4;
+    else if ( qsb_tstep == 3 )
+        qsb_tstep = 2;
+
+    /*  There is a delay between PPE write descriptor and descriptor is       */
+    /*  really stored in memory. Host also has this delay when writing        */
+    /*  descriptor. So PPE will use this value to determine if the write      */
+    /*  operation makes effect.                                               */
+    if ( write_descriptor_delay < 0 )
+        write_descriptor_delay = 0;
+
+    if ( aal5_fill_pattern < 0 )
+        aal5_fill_pattern = 0;
+    else
+        aal5_fill_pattern &= 0xFF;
+
+    /*  Because of the limitation of length field in descriptors, the packet  */
+    /*  size could not be larger than 64K minus overhead size.                */
+    if ( aal5r_max_packet_size < 0 )
+        aal5r_max_packet_size = 0;
+    else if ( aal5r_max_packet_size >= 65535 - MAX_RX_FRAME_EXTRA_BYTES )
+        aal5r_max_packet_size = 65535 - MAX_RX_FRAME_EXTRA_BYTES;
+    if ( aal5r_min_packet_size < 0 )
+        aal5r_min_packet_size = 0;
+    else if ( aal5r_min_packet_size > aal5r_max_packet_size )
+        aal5r_min_packet_size = aal5r_max_packet_size;
+    if ( aal5s_max_packet_size < 0 )
+        aal5s_max_packet_size = 0;
+    else if ( aal5s_max_packet_size >= 65535 - MAX_TX_FRAME_EXTRA_BYTES )
+        aal5s_max_packet_size = 65535 - MAX_TX_FRAME_EXTRA_BYTES;
+    if ( aal5s_min_packet_size < 0 )
+        aal5s_min_packet_size = 0;
+    else if ( aal5s_min_packet_size > aal5s_max_packet_size )
+        aal5s_min_packet_size = aal5s_max_packet_size;
+
+    if ( dma_rx_descriptor_length < 2 )
+        dma_rx_descriptor_length = 2;
+    if ( dma_tx_descriptor_length < 2 )
+        dma_tx_descriptor_length = 2;
+    if ( dma_rx_clp1_descriptor_threshold < 0 )
+        dma_rx_clp1_descriptor_threshold = 0;
+    else if ( dma_rx_clp1_descriptor_threshold > dma_rx_descriptor_length )
+        dma_rx_clp1_descriptor_threshold = dma_rx_descriptor_length;
+
+    if ( dma_tx_descriptor_length < 2 )
+        dma_tx_descriptor_length = 2;
+}
+
+static INLINE int init_priv_data(void)
+{
+    void *p;
+    int i;
+    struct rx_descriptor rx_desc = {0};
+    struct sk_buff *skb;
+    volatile struct tx_descriptor *p_tx_desc;
+    struct sk_buff **ppskb;
+
+    //  clear atm private data structure
+    memset(&g_atm_priv_data, 0, sizeof(g_atm_priv_data));
+
+    //  allocate memory for RX (AAL) descriptors
+    p = kzalloc(dma_rx_descriptor_length * sizeof(struct rx_descriptor) + DESC_ALIGNMENT, GFP_KERNEL);
+    if ( p == NULL )
+        return -ENOMEM;
+    dma_cache_sync(NULL, p, dma_rx_descriptor_length * sizeof(struct rx_descriptor) + DESC_ALIGNMENT, DMA_BIDIRECTIONAL);
+    g_atm_priv_data.aal_desc_base = p;
+    p = (void *)((((unsigned int)p + DESC_ALIGNMENT - 1) & ~(DESC_ALIGNMENT - 1)) | KSEG1);
+    g_atm_priv_data.aal_desc = (volatile struct rx_descriptor *)p;
+
+    //  allocate memory for RX (OAM) descriptors
+    p = kzalloc(RX_DMA_CH_OAM_DESC_LEN * sizeof(struct rx_descriptor) + DESC_ALIGNMENT, GFP_KERNEL);
+    if ( p == NULL )
+        return -ENOMEM;
+    dma_cache_sync(NULL, p, RX_DMA_CH_OAM_DESC_LEN * sizeof(struct rx_descriptor) + DESC_ALIGNMENT, DMA_BIDIRECTIONAL);
+    g_atm_priv_data.oam_desc_base = p;
+    p = (void *)((((unsigned int)p + DESC_ALIGNMENT - 1) & ~(DESC_ALIGNMENT - 1)) | KSEG1);
+    g_atm_priv_data.oam_desc = (volatile struct rx_descriptor *)p;
+
+    //  allocate memory for RX (OAM) buffer
+    p = kzalloc(RX_DMA_CH_OAM_DESC_LEN * RX_DMA_CH_OAM_BUF_SIZE + DATA_BUFFER_ALIGNMENT, GFP_KERNEL);
+    if ( p == NULL )
+        return -ENOMEM;
+    dma_cache_sync(NULL, p, RX_DMA_CH_OAM_DESC_LEN * RX_DMA_CH_OAM_BUF_SIZE + DATA_BUFFER_ALIGNMENT, DMA_BIDIRECTIONAL);
+    g_atm_priv_data.oam_buf_base = p;
+    p = (void *)(((unsigned int)p + DATA_BUFFER_ALIGNMENT - 1) & ~(DATA_BUFFER_ALIGNMENT - 1));
+    g_atm_priv_data.oam_buf = p;
+
+    //  allocate memory for TX descriptors
+    p = kzalloc(MAX_PVC_NUMBER * dma_tx_descriptor_length * sizeof(struct tx_descriptor) + DESC_ALIGNMENT, GFP_KERNEL);
+    if ( p == NULL )
+        return -ENOMEM;
+    dma_cache_sync(NULL, p, MAX_PVC_NUMBER * dma_tx_descriptor_length * sizeof(struct tx_descriptor) + DESC_ALIGNMENT, DMA_BIDIRECTIONAL);
+    g_atm_priv_data.tx_desc_base = p;
+
+    //  allocate memory for TX skb pointers
+    p = kzalloc(MAX_PVC_NUMBER * dma_tx_descriptor_length * sizeof(struct sk_buff *) + 4, GFP_KERNEL);
+    if ( p == NULL )
+        return -ENOMEM;
+    dma_cache_sync(NULL, p, MAX_PVC_NUMBER * dma_tx_descriptor_length * sizeof(struct sk_buff *) + 4, DMA_BIDIRECTIONAL);
+    g_atm_priv_data.tx_skb_base = p;
+
+    //  setup RX (AAL) descriptors
+    rx_desc.own     = 1;
+    rx_desc.c       = 0;
+    rx_desc.sop     = 1;
+    rx_desc.eop     = 1;
+    rx_desc.byteoff = 0;
+    rx_desc.id      = 0;
+    rx_desc.err     = 0;
+    rx_desc.datalen = RX_DMA_CH_AAL_BUF_SIZE;
+    for ( i = 0; i < dma_rx_descriptor_length; i++ ) {
+        skb = alloc_skb_rx();
+        if ( skb == NULL )
+            return -ENOMEM;
+        rx_desc.dataptr = ((unsigned int)skb->data & 0x1FFFFFFC ) >> 2;
+        g_atm_priv_data.aal_desc[i] = rx_desc;
+    }
+
+    //  setup RX (OAM) descriptors
+    p = (void *)((unsigned int)g_atm_priv_data.oam_buf | KSEG1);
+    rx_desc.own     = 1;
+    rx_desc.c       = 0;
+    rx_desc.sop     = 1;
+    rx_desc.eop     = 1;
+    rx_desc.byteoff = 0;
+    rx_desc.id      = 0;
+    rx_desc.err     = 0;
+    rx_desc.datalen = RX_DMA_CH_OAM_BUF_SIZE;
+    for ( i = 0; i < RX_DMA_CH_OAM_DESC_LEN; i++ ) {
+        rx_desc.dataptr = ((unsigned int)p & 0x1FFFFFFC ) >> 2;
+        g_atm_priv_data.oam_desc[i] = rx_desc;
+        p = (void *)((unsigned int)p + RX_DMA_CH_OAM_BUF_SIZE);
+    }
+
+    //  setup TX descriptors and skb pointers
+    p_tx_desc = (volatile struct tx_descriptor *)((((unsigned int)g_atm_priv_data.tx_desc_base + DESC_ALIGNMENT - 1) & ~(DESC_ALIGNMENT - 1)) | KSEG1);
+    ppskb = (struct sk_buff **)(((unsigned int)g_atm_priv_data.tx_skb_base + 3) & ~3);
+    for ( i = 0; i < MAX_PVC_NUMBER; i++ ) {
+        g_atm_priv_data.conn[i].tx_desc = &p_tx_desc[i * dma_tx_descriptor_length];
+        g_atm_priv_data.conn[i].tx_skb  = &ppskb[i * dma_tx_descriptor_length];
+    }
+
+    for ( i = 0; i < ATM_PORT_NUMBER; i++ )
+        g_atm_priv_data.port[i].tx_max_cell_rate = DEFAULT_TX_LINK_RATE;
+
+    return 0;
+}
+
+static INLINE void clear_priv_data(void)
+{
+    int i, j;
+    struct sk_buff *skb;
+
+    for ( i = 0; i < MAX_PVC_NUMBER; i++ ) {
+        if ( g_atm_priv_data.conn[i].tx_skb != NULL ) {
+            for ( j = 0; j < dma_tx_descriptor_length; j++ )
+                if ( g_atm_priv_data.conn[i].tx_skb[j] != NULL )
+                    dev_kfree_skb_any(g_atm_priv_data.conn[i].tx_skb[j]);
+        }
+    }
+
+    if ( g_atm_priv_data.tx_skb_base != NULL )
+        kfree(g_atm_priv_data.tx_skb_base);
+
+    if ( g_atm_priv_data.tx_desc_base != NULL )
+        kfree(g_atm_priv_data.tx_desc_base);
+
+    if ( g_atm_priv_data.oam_buf_base != NULL )
+        kfree(g_atm_priv_data.oam_buf_base);
+
+    if ( g_atm_priv_data.oam_desc_base != NULL )
+        kfree(g_atm_priv_data.oam_desc_base);
+
+    if ( g_atm_priv_data.aal_desc_base != NULL ) {
+        for ( i = 0; i < dma_rx_descriptor_length; i++ ) {
+            if ( g_atm_priv_data.aal_desc[i].sop || g_atm_priv_data.aal_desc[i].eop ) { //  descriptor initialized
+                skb = get_skb_rx_pointer(g_atm_priv_data.aal_desc[i].dataptr);
+                dev_kfree_skb_any(skb);
+            }
+        }
+        kfree(g_atm_priv_data.aal_desc_base);
+    }
+}
+
+static INLINE void init_rx_tables(void)
+{
+    int i;
+    struct wrx_queue_config wrx_queue_config = {0};
+    struct wrx_dma_channel_config wrx_dma_channel_config = {0};
+    struct htu_entry htu_entry = {0};
+    struct htu_result htu_result = {0};
+    struct htu_mask htu_mask = {    set:        0x01,
+                                    clp:        0x01,
+                                    pid_mask:   0x00,
+                                    vpi_mask:   0x00,
+                                    vci_mask:   0x00,
+                                    pti_mask:   0x00,
+                                    clear:      0x00};
+
+    /*
+     *  General Registers
+     */
+    *CFG_WRX_HTUTS  = MAX_PVC_NUMBER + OAM_HTU_ENTRY_NUMBER;
+#ifndef CONFIG_AMAZON_SE
+    *CFG_WRX_QNUM   = MAX_QUEUE_NUMBER;
+#endif
+    *CFG_WRX_DCHNUM = RX_DMA_CH_TOTAL;
+    *WRX_DMACH_ON   = (1 << RX_DMA_CH_TOTAL) - 1;
+    *WRX_HUNT_BITTH = DEFAULT_RX_HUNT_BITTH;
+
+    /*
+     *  WRX Queue Configuration Table
+     */
+    wrx_queue_config.uumask    = 0xFF;
+    wrx_queue_config.cpimask   = 0xFF;
+    wrx_queue_config.uuexp     = 0;
+    wrx_queue_config.cpiexp    = 0;
+    wrx_queue_config.mfs       = aal5r_max_packet_size;
+    wrx_queue_config.oversize  = aal5r_max_packet_size;
+    wrx_queue_config.undersize = aal5r_min_packet_size;
+    wrx_queue_config.errdp     = aal5r_drop_error_packet;
+    wrx_queue_config.dmach     = RX_DMA_CH_AAL;
+    for ( i = 0; i < MAX_QUEUE_NUMBER; i++ )
+        *WRX_QUEUE_CONFIG(i) = wrx_queue_config;
+    WRX_QUEUE_CONFIG(OAM_RX_QUEUE)->dmach = RX_DMA_CH_OAM;
+
+    /*
+     *  WRX DMA Channel Configuration Table
+     */
+    wrx_dma_channel_config.chrl   = 0;
+    wrx_dma_channel_config.clp1th = dma_rx_clp1_descriptor_threshold;
+    wrx_dma_channel_config.mode   = 0;
+    wrx_dma_channel_config.rlcfg  = 0;
+
+    wrx_dma_channel_config.deslen = RX_DMA_CH_OAM_DESC_LEN;
+    wrx_dma_channel_config.desba  = CPHYSADDR((unsigned int)g_atm_priv_data.oam_desc) >> 2;
+    *WRX_DMA_CHANNEL_CONFIG(RX_DMA_CH_OAM) = wrx_dma_channel_config;
+
+    wrx_dma_channel_config.deslen = dma_rx_descriptor_length;
+    wrx_dma_channel_config.desba  = CPHYSADDR((unsigned int)g_atm_priv_data.aal_desc) >> 2;
+    *WRX_DMA_CHANNEL_CONFIG(RX_DMA_CH_AAL) = wrx_dma_channel_config;
+
+    /*
+     *  HTU Tables
+     */
+    for ( i = 0; i < MAX_PVC_NUMBER; i++ )
+    {
+        htu_result.qid = (unsigned int)i;
+
+        *HTU_ENTRY(i + OAM_HTU_ENTRY_NUMBER)  = htu_entry;
+        *HTU_MASK(i + OAM_HTU_ENTRY_NUMBER)   = htu_mask;
+        *HTU_RESULT(i + OAM_HTU_ENTRY_NUMBER) = htu_result;
+    }
+    /*  OAM HTU Entry   */
+    htu_entry.vci     = 0x03;
+    htu_mask.pid_mask = 0x03;
+    htu_mask.vpi_mask = 0xFF;
+    htu_mask.vci_mask = 0x0000;
+    htu_mask.pti_mask = 0x07;
+    htu_result.cellid = OAM_RX_QUEUE;
+    htu_result.type   = 1;
+    htu_result.ven    = 1;
+    htu_result.qid    = OAM_RX_QUEUE;
+    *HTU_RESULT(OAM_F4_SEG_HTU_ENTRY) = htu_result;
+    *HTU_MASK(OAM_F4_SEG_HTU_ENTRY)   = htu_mask;
+    *HTU_ENTRY(OAM_F4_SEG_HTU_ENTRY)  = htu_entry;
+    htu_entry.vci     = 0x04;
+    htu_result.cellid = OAM_RX_QUEUE;
+    htu_result.type   = 1;
+    htu_result.ven    = 1;
+    htu_result.qid    = OAM_RX_QUEUE;
+    *HTU_RESULT(OAM_F4_TOT_HTU_ENTRY) = htu_result;
+    *HTU_MASK(OAM_F4_TOT_HTU_ENTRY)   = htu_mask;
+    *HTU_ENTRY(OAM_F4_TOT_HTU_ENTRY)  = htu_entry;
+    htu_entry.vci     = 0x00;
+    htu_entry.pti     = 0x04;
+    htu_mask.vci_mask = 0xFFFF;
+    htu_mask.pti_mask = 0x01;
+    htu_result.cellid = OAM_RX_QUEUE;
+    htu_result.type   = 1;
+    htu_result.ven    = 1;
+    htu_result.qid    = OAM_RX_QUEUE;
+    *HTU_RESULT(OAM_F5_HTU_ENTRY) = htu_result;
+    *HTU_MASK(OAM_F5_HTU_ENTRY)   = htu_mask;
+    *HTU_ENTRY(OAM_F5_HTU_ENTRY)  = htu_entry;
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+    htu_entry.pid     = 0x0;
+    htu_entry.vpi     = 0x01;
+    htu_entry.vci     = 0x0001;
+    htu_entry.pti     = 0x00;
+    htu_mask.pid_mask = 0x0;
+    htu_mask.vpi_mask = 0x00;
+    htu_mask.vci_mask = 0x0000;
+    htu_mask.pti_mask = 0x3;
+    htu_result.cellid = OAM_RX_QUEUE;
+    htu_result.type   = 1;
+    htu_result.ven    = 1;
+    htu_result.qid    = OAM_RX_QUEUE;
+    *HTU_RESULT(OAM_ARQ_HTU_ENTRY) = htu_result;
+    *HTU_MASK(OAM_ARQ_HTU_ENTRY)   = htu_mask;
+    *HTU_ENTRY(OAM_ARQ_HTU_ENTRY)  = htu_entry;
+#endif
+}
+
+static INLINE void init_tx_tables(void)
+{
+    int i;
+    struct wtx_queue_config wtx_queue_config = {0};
+    struct wtx_dma_channel_config wtx_dma_channel_config = {0};
+    struct wtx_port_config wtx_port_config = {  res1:   0,
+                                                qid:    0,
+                                                qsben:  1};
+
+    /*
+     *  General Registers
+     */
+    *CFG_WTX_DCHNUM     = MAX_TX_DMA_CHANNEL_NUMBER;
+    *WTX_DMACH_ON       = ((1 << MAX_TX_DMA_CHANNEL_NUMBER) - 1) ^ ((1 << FIRST_QSB_QID) - 1);
+    *CFG_WRDES_DELAY    = write_descriptor_delay;
+
+    /*
+     *  WTX Port Configuration Table
+     */
+    for ( i = 0; i < ATM_PORT_NUMBER; i++ )
+        *WTX_PORT_CONFIG(i) = wtx_port_config;
+
+    /*
+     *  WTX Queue Configuration Table
+     */
+    wtx_queue_config.qsben = 1;
+    wtx_queue_config.sbid  = 0;
+    for ( i = 0; i < MAX_TX_DMA_CHANNEL_NUMBER; i++ ) {
+        wtx_queue_config.qsb_vcid = i;
+        *WTX_QUEUE_CONFIG(i) = wtx_queue_config;
+    }
+
+    /*
+     *  WTX DMA Channel Configuration Table
+     */
+    wtx_dma_channel_config.mode   = 0;
+    wtx_dma_channel_config.deslen = 0;
+    wtx_dma_channel_config.desba  = 0;
+    for ( i = 0; i < FIRST_QSB_QID; i++ )
+        *WTX_DMA_CHANNEL_CONFIG(i) = wtx_dma_channel_config;
+    /*  normal connection   */
+    wtx_dma_channel_config.deslen = dma_tx_descriptor_length;
+    for ( ; i < MAX_TX_DMA_CHANNEL_NUMBER ; i++ ) {
+        wtx_dma_channel_config.desba = CPHYSADDR((unsigned int)g_atm_priv_data.conn[i - FIRST_QSB_QID].tx_desc) >> 2;
+        *WTX_DMA_CHANNEL_CONFIG(i) = wtx_dma_channel_config;
+    }
+}
+
+#if defined(AS_PVC_MODE_ENABLE) && AS_PVC_MODE_ENABLE
+/*
+ *  Auto Search PVC Mode
+ */
+
+void ppe_enable_as_pvc_mode(as_pvc_push_fn_t as_pvc_push)
+{
+    int i;
+
+    if ( as_pvc_push != NULL )
+        g_as_pvc_push = as_pvc_push;
+    else if ( g_as_pvc_push != NULL )
+    {
+        //  Cleanup in case PVCs are not closed by application
+        if ( g_as_pvc_conn >= 0 )
+        {
+            if ( g_atm_priv_data.conn[g_as_pvc_conn].vcc != NULL )
+                ppe_close(g_atm_priv_data.conn[g_as_pvc_conn].vcc);
+            g_as_pvc_conn = -1;
+        }
+        for ( i = 0; i < NUM_ENTITY(g_as_pvc_vcc); i++ )
+            g_as_pvc_vcc[i] = NULL;
+
+        g_as_pvc_push = NULL;
+    }
+}
+
+static int as_pvc_add_vcc(struct atm_vcc *vcc)
+{
+    int i;
+
+    for ( i = 0; i < NUM_ENTITY(g_as_pvc_vcc); i++ )
+        if ( g_as_pvc_vcc[i] == NULL )
+        {
+            g_as_pvc_vcc[i] = vcc;
+            return 0;
+        }
+
+    return -1;
+}
+
+static void as_pvc_remove_vcc(struct atm_vcc *vcc)
+{
+    int i;
+
+    for ( i = 0; i < NUM_ENTITY(g_as_pvc_vcc); i++ )
+        if ( g_as_pvc_vcc[i] == vcc )
+        {
+            g_as_pvc_vcc[i] = NULL;
+            return;
+        }
+}
+
+static int as_pvc_find_vpivci(unsigned int vpi, unsigned int vci)
+{
+    int i;
+
+    for ( i = 0; i < NUM_ENTITY(g_as_pvc_vcc); i++ )
+        if ( g_as_pvc_vcc[i] != NULL && vpi == g_as_pvc_vcc[i]->vpi && vci == g_as_pvc_vcc[i]->vci )
+            return i;
+    return -1;
+}
+
+static int as_pvc_find_vcc(struct atm_vcc *vcc)
+{
+    int i;
+
+    for ( i = 0; i < NUM_ENTITY(g_as_pvc_vcc); i++ )
+        if ( g_as_pvc_vcc[i] != NULL && g_as_pvc_vcc[i] == vcc )
+            return i;
+    return -1;
+}
+
+static void as_pvc_set_htu_entry(int queue)
+{
+    struct htu_entry htu_entry = {  res1:       0x00,
+                                    pid:        g_atm_priv_data.conn[queue].port & 0x01,
+                                    vpi:        0x00,
+                                    vci:        0x0000,
+                                    pti:        0x00,
+                                    vld:        0x01};
+
+    struct htu_mask htu_mask = {    set:        0x03,
+                                    pid_mask:   0x02,
+                                    vpi_mask:   0xFF,   //  not compare VPI
+                                    vci_mask:   0xFFFF, //  not compare VCI
+                                    pti_mask:   0x03,   //  0xx, user data
+                                    clear:      0x00};
+
+    struct htu_result htu_result = {res1:       0x00,
+                                    cellid:     queue,
+                                    res2:       0x00,
+                                    type:       0x01,   //  cell
+                                    ven:        0x00,   //  not verify OAM checksum
+                                    res3:       0x00,
+                                    qid:        OAM_RX_QUEUE};
+
+    *HTU_RESULT(queue + OAM_HTU_ENTRY_NUMBER) = htu_result;
+    *HTU_MASK(queue + OAM_HTU_ENTRY_NUMBER)   = htu_mask;
+    *HTU_ENTRY(queue + OAM_HTU_ENTRY_NUMBER)  = htu_entry;
+}
+#endif
+
+
+
+/*
+ * ####################################
+ *           Global Function
+ * ####################################
+ */
+
+static int atm_showtime_enter(struct port_cell_info *port_cell, void *xdata_addr)
+{
+    int i, j;
+
+    ASSERT(port_cell != NULL, "port_cell is NULL");
+    ASSERT(xdata_addr != NULL, "xdata_addr is NULL");
+
+    for ( j = 0; j < ATM_PORT_NUMBER && j < port_cell->port_num; j++ )
+        if ( port_cell->tx_link_rate[j] > 0 )
+            break;
+    for ( i = 0; i < ATM_PORT_NUMBER && i < port_cell->port_num; i++ )
+        g_atm_priv_data.port[i].tx_max_cell_rate = port_cell->tx_link_rate[i] > 0 ? port_cell->tx_link_rate[i] : port_cell->tx_link_rate[j];
+
+    qsb_global_set();
+
+    for ( i = 0; i < MAX_PVC_NUMBER; i++ )
+        if ( g_atm_priv_data.conn[i].vcc != NULL )
+            set_qsb(g_atm_priv_data.conn[i].vcc, &g_atm_priv_data.conn[i].vcc->qos, i);
+
+    //  TODO: ReTX set xdata_addr
+    g_xdata_addr = xdata_addr;
+
+    g_showtime = 1;
+
+#if defined(CONFIG_LTQ_ATM_XRX200)
+    IFX_REG_W32(0x0F, UTP_CFG);
+#endif
+
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+    if ( !timer_pending(&g_retx_polling_timer) ) {
+        g_retx_polling_cnt = HZ;
+        g_retx_polling_timer.expires = jiffies + RETX_POLLING_INTERVAL;
+        add_timer(&g_retx_polling_timer);
+    }
+#endif
+
+    printk("enter showtime, cell rate: 0 - %d, 1 - %d, xdata addr: 0x%08x\n", g_atm_priv_data.port[0].tx_max_cell_rate, g_atm_priv_data.port[1].tx_max_cell_rate, (unsigned int)g_xdata_addr);
+
+    return 0;
+}
+
+static int atm_showtime_exit(void)
+{
+    if ( !g_showtime )
+        return -EIO;
+
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+    RETX_MODE_CFG->retx_en = 0; //  disable ReTX
+    del_timer(&g_retx_polling_timer);
+#endif
+
+#if defined(CONFIG_LTQ_ATM_XRX200)
+    IFX_REG_W32(0x00, UTP_CFG);
+#endif
+
+    g_showtime = 0;
+
+    //  TODO: ReTX clean state
+    g_xdata_addr = NULL;
+
+    printk("leave showtime\n");
+
+    return 0;
+}
+
+
+
+/*
+ * ####################################
+ *           Init/Cleanup API
+ * ####################################
+ */
+
+/*
+ *  Description:
+ *    Initialize global variables, PP32, comunication structures, register IRQ
+ *    and register device.
+ *  Input:
+ *    none
+ *  Output:
+ *    0    --- successful
+ *    else --- failure, usually it is negative value of error code
+ */
+static int __init ifx_atm_init(void)
+{
+    int ret;
+    int port_num;
+    struct port_cell_info port_cell = {0};
+    int i, j;
+    char ver_str[256];
+
+    check_parameters();
+
+    ret = init_priv_data();
+    if ( ret != 0 ) {
+        err("INIT_PRIV_DATA_FAIL");
+        goto INIT_PRIV_DATA_FAIL;
+    }
+
+    ifx_atm_init_chip();
+    init_rx_tables();
+    init_tx_tables();
+
+    /*  create devices  */
+    for ( port_num = 0; port_num < ATM_PORT_NUMBER; port_num++ ) {
+        g_atm_priv_data.port[port_num].dev = atm_dev_register("ltqmips_atm", NULL, &g_ifx_atm_ops, -1, NULL);
+        if ( !g_atm_priv_data.port[port_num].dev ) {
+            err("failed to register atm device %d!", port_num);
+            ret = -EIO;
+            goto ATM_DEV_REGISTER_FAIL;
+        }
+        else {
+            g_atm_priv_data.port[port_num].dev->ci_range.vpi_bits = 8;
+            g_atm_priv_data.port[port_num].dev->ci_range.vci_bits = 16;
+            g_atm_priv_data.port[port_num].dev->link_rate = g_atm_priv_data.port[port_num].tx_max_cell_rate;
+            g_atm_priv_data.port[port_num].dev->dev_data = (void*)port_num;
+        }
+    }
+
+    /*  register interrupt handler  */
+    ret = request_irq(PPE_MAILBOX_IGU1_INT, mailbox_irq_handler, IRQF_DISABLED, "atm_mailbox_isr", &g_atm_priv_data);
+    if ( ret ) {
+        if ( ret == -EBUSY ) {
+            err("IRQ may be occupied by other driver, please reconfig to disable it.");
+        }
+        else {
+            err("request_irq fail");
+        }
+        goto REQUEST_IRQ_PPE_MAILBOX_IGU1_INT_FAIL;
+    }
+    disable_irq(PPE_MAILBOX_IGU1_INT);
+
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+    init_atm_tc_retrans_param();
+
+    init_timer(&g_retx_polling_timer);
+    g_retx_polling_timer.function = retx_polling_func;
+#endif
+
+    ret = ifx_pp32_start(0);
+    if ( ret ) {
+        err("ifx_pp32_start fail!");
+        goto PP32_START_FAIL;
+    }
+
+    port_cell.port_num = ATM_PORT_NUMBER;
+
+    ifx_mei_atm_showtime_check(&g_showtime, &port_cell, &g_xdata_addr);
+
+    if ( g_showtime ) {
+        for ( i = 0; i < ATM_PORT_NUMBER; i++ )
+            if ( port_cell.tx_link_rate[i] != 0 )
+                break;
+        for ( j = 0; j < ATM_PORT_NUMBER; j++ )
+            g_atm_priv_data.port[j].tx_max_cell_rate = port_cell.tx_link_rate[j] != 0 ? port_cell.tx_link_rate[j] : port_cell.tx_link_rate[i];
+    }
+
+    qsb_global_set();
+    validate_oam_htu_entry();
+
+#if defined(ENABLE_LED_FRAMEWORK) && ENABLE_LED_FRAMEWORK
+  #ifdef CONFIG_IFX_LED
+    ifx_led_trigger_register("dsl_data", &g_data_led_trigger);
+  #endif
+#endif
+
+    /*  create proc file    */
+    proc_file_create();
+
+    ifx_mei_atm_showtime_enter = atm_showtime_enter;
+    ifx_mei_atm_showtime_exit  = atm_showtime_exit;
+
+    ifx_atm_version(ver_str);
+    printk(KERN_INFO "%s", ver_str);
+
+    printk("ltqmips_atm: ATM init succeed\n");
+
+    return 0;
+
+PP32_START_FAIL:
+    free_irq(PPE_MAILBOX_IGU1_INT, &g_atm_priv_data);
+REQUEST_IRQ_PPE_MAILBOX_IGU1_INT_FAIL:
+ATM_DEV_REGISTER_FAIL:
+    while ( port_num-- > 0 )
+        atm_dev_deregister(g_atm_priv_data.port[port_num].dev);
+INIT_PRIV_DATA_FAIL:
+    clear_priv_data();
+    printk("ltqmips_atm: ATM init failed\n");
+    return ret;
+}
+
+/*
+ *  Description:
+ *    Release memory, free IRQ, and deregister device.
+ *  Input:
+ *    none
+ *  Output:
+ *   none
+ */
+static void __exit ifx_atm_exit(void)
+{
+    int port_num;
+
+    ifx_mei_atm_showtime_enter = NULL;
+    ifx_mei_atm_showtime_exit  = NULL;
+
+    proc_file_delete();
+
+#if defined(ENABLE_LED_FRAMEWORK) && ENABLE_LED_FRAMEWORK
+  #ifdef CONFIG_IFX_LED
+    ifx_led_trigger_deregister(g_data_led_trigger);
+    g_data_led_trigger = NULL;
+  #endif
+#endif
+
+    invalidate_oam_htu_entry();
+
+    ifx_pp32_stop(0);
+
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+    del_timer(&g_retx_polling_timer);
+    clear_atm_tc_retrans_param();
+#endif
+
+    free_irq(PPE_MAILBOX_IGU1_INT, &g_atm_priv_data);
+
+    for ( port_num = 0; port_num < ATM_PORT_NUMBER; port_num++ )
+        atm_dev_deregister(g_atm_priv_data.port[port_num].dev);
+
+    ifx_atm_uninit_chip();
+
+    clear_priv_data();
+}
+
+module_init(ifx_atm_init);
+module_exit(ifx_atm_exit);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/atm/lantiq/ltqmips_atm_core.h b/drivers/atm/lantiq/ltqmips_atm_core.h
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/ltqmips_atm_core.h
@@ -0,0 +1,303 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_atm_core.h
+** PROJECT      : UEIP
+** MODULES      : ATM
+**
+** DATE         : 7 Jul 2009
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : ATM driver header file (core functions)
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 17 JUN 2009  Xu Liang        Init Version
+*******************************************************************************/
+
+#ifndef IFXMIPS_ATM_CORE_H
+#define IFXMIPS_ATM_CORE_H
+
+
+
+#include <lantiq_atm.h>
+
+
+
+/*
+ * ####################################
+ *              Definition
+ * ####################################
+ */
+
+/*
+ *  Compile Options
+ */
+
+#define AS_PVC_MODE_ENABLE              0 //  disable auto search by default
+
+#define ENABLE_DEBUG                    1
+
+#define ENABLE_ASSERT                   1
+
+#define INLINE
+
+#define DEBUG_DUMP_SKB                  1
+
+#define DEBUG_QOS                       1
+
+#define DISABLE_QOS_WORKAROUND          0
+
+#define ENABLE_DBG_PROC                 1
+
+#define ENABLE_FW_PROC                  1
+
+#ifdef CONFIG_LTQ_ATM_TASKLET
+  #define ENABLE_TASKLET                1
+#endif
+
+#ifdef CONFIG_LTQ_ATM_RETX
+  #define ENABLE_ATM_RETX               1
+#endif
+
+#if defined(CONFIG_DSL_MEI_CPE_DRV) && !defined(CONFIG_IFXMIPS_DSL_CPE_MEI)
+  #define CONFIG_IFXMIPS_DSL_CPE_MEI    1
+#endif
+
+/*
+ *  Debug/Assert/Error Message
+ */
+
+#define DBG_ENABLE_MASK_ERR             (1 << 0)
+#define DBG_ENABLE_MASK_DEBUG_PRINT     (1 << 1)
+#define DBG_ENABLE_MASK_ASSERT          (1 << 2)
+#define DBG_ENABLE_MASK_DUMP_SKB_RX     (1 << 8)
+#define DBG_ENABLE_MASK_DUMP_SKB_TX     (1 << 9)
+#define DBG_ENABLE_MASK_DUMP_QOS        (1 << 10)
+#define DBG_ENABLE_MASK_DUMP_INIT       (1 << 11)
+#define DBG_ENABLE_MASK_MAC_SWAP        (1 << 12)
+#define DBG_ENABLE_MASK_ALL             (DBG_ENABLE_MASK_ERR | DBG_ENABLE_MASK_DEBUG_PRINT | DBG_ENABLE_MASK_ASSERT | DBG_ENABLE_MASK_DUMP_SKB_RX | DBG_ENABLE_MASK_DUMP_SKB_TX | DBG_ENABLE_MASK_DUMP_QOS | DBG_ENABLE_MASK_DUMP_INIT | DBG_ENABLE_MASK_MAC_SWAP)
+
+#define err(format, arg...)             do { if ( (ifx_atm_dbg_enable & DBG_ENABLE_MASK_ERR) ) printk(KERN_ERR __FILE__ ":%d:%s: " format "\n", __LINE__, __FUNCTION__, ##arg); } while ( 0 )
+
+#if defined(ENABLE_DEBUG) && ENABLE_DEBUG
+  #undef  dbg
+  #define dbg(format, arg...)           do { if ( (ifx_atm_dbg_enable & DBG_ENABLE_MASK_DEBUG_PRINT) ) printk(KERN_WARNING __FILE__ ":%d:%s: " format "\n", __LINE__, __FUNCTION__, ##arg); } while ( 0 )
+#else
+  #if !defined(dbg)
+    #define dbg(format, arg...)
+  #endif
+#endif
+
+#if defined(ENABLE_ASSERT) && ENABLE_ASSERT
+  #define ASSERT(cond, format, arg...)  do { if ( (ifx_atm_dbg_enable & DBG_ENABLE_MASK_ASSERT) && !(cond) ) printk(KERN_ERR __FILE__ ":%d:%s: " format "\n", __LINE__, __FUNCTION__, ##arg); } while ( 0 )
+#else
+  #define ASSERT(cond, format, arg...)
+#endif
+
+
+/*
+ *  Constants
+ */
+#define DEFAULT_TX_LINK_RATE            3200    //  in cells
+
+/*
+ *  ATM Port, QSB Queue, DMA RX/TX Channel Parameters
+ */
+#define ATM_PORT_NUMBER                 2
+#define MAX_QUEUE_NUMBER                16
+#define OAM_RX_QUEUE                    15
+#define QSB_RESERVE_TX_QUEUE            0
+#define FIRST_QSB_QID                   1
+#define MAX_PVC_NUMBER                  (MAX_QUEUE_NUMBER - FIRST_QSB_QID)
+#define MAX_RX_DMA_CHANNEL_NUMBER       8
+#define MAX_TX_DMA_CHANNEL_NUMBER       16
+#define DATA_BUFFER_ALIGNMENT           EMA_ALIGNMENT
+#define DESC_ALIGNMENT                  8
+#define DEFAULT_RX_HUNT_BITTH           4
+
+/*
+ *  RX DMA Channel Allocation
+ */
+#define RX_DMA_CH_OAM                   0
+#define RX_DMA_CH_AAL                   1
+#define RX_DMA_CH_TOTAL                 2
+#define RX_DMA_CH_OAM_DESC_LEN          32
+#define RX_DMA_CH_OAM_BUF_SIZE          ((CELL_SIZE + 14) & ~15)
+#define RX_DMA_CH_AAL_BUF_SIZE          (2048 - 48)
+
+/*
+ *  OAM Constants
+ */
+#define OAM_HTU_ENTRY_NUMBER            3
+#define OAM_F4_SEG_HTU_ENTRY            0
+#define OAM_F4_TOT_HTU_ENTRY            1
+#define OAM_F5_HTU_ENTRY                2
+#define OAM_F4_CELL_ID                  0
+#define OAM_F5_CELL_ID                  15
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+  #undef  OAM_HTU_ENTRY_NUMBER
+  #define OAM_HTU_ENTRY_NUMBER          4
+  #define OAM_ARQ_HTU_ENTRY             3
+#endif
+
+/*
+ *  RX Frame Definitions
+ */
+#define MAX_RX_PACKET_ALIGN_BYTES       3
+#define MAX_RX_PACKET_PADDING_BYTES     3
+#define RX_INBAND_TRAILER_LENGTH        8
+#define MAX_RX_FRAME_EXTRA_BYTES        (RX_INBAND_TRAILER_LENGTH + MAX_RX_PACKET_ALIGN_BYTES + MAX_RX_PACKET_PADDING_BYTES)
+
+/*
+ *  TX Frame Definitions
+ */
+#define MAX_TX_HEADER_ALIGN_BYTES       12
+#define MAX_TX_PACKET_ALIGN_BYTES       3
+#define MAX_TX_PACKET_PADDING_BYTES     3
+#define TX_INBAND_HEADER_LENGTH         8
+#define MAX_TX_FRAME_EXTRA_BYTES        (TX_INBAND_HEADER_LENGTH + MAX_TX_HEADER_ALIGN_BYTES + MAX_TX_PACKET_ALIGN_BYTES + MAX_TX_PACKET_PADDING_BYTES)
+
+/*
+ *  Cell Constant
+ */
+#define CELL_SIZE                       ATM_AAL0_SDU
+
+/*
+ *  ReTX Constant
+ */
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+  #define RETX_PLAYOUT_BUFFER_ORDER     6
+  #define RETX_PLAYOUT_BUFFER_SIZE      (PAGE_SIZE * (1 << RETX_PLAYOUT_BUFFER_ORDER))
+  #define RETX_PLAYOUT_FW_BUFF_SIZE     (RETX_PLAYOUT_BUFFER_SIZE / (32 * 56 /* cell size */))
+  #define RETX_POLLING_INTERVAL         (HZ / 100 > 0 ? HZ / 100 : 1)
+#endif
+
+
+
+/*
+ * ####################################
+ *              Data Type
+ * ####################################
+ */
+
+typedef struct {
+    unsigned int            h;
+    unsigned int            l;
+} ppe_u64_t;
+
+struct port {
+    unsigned int            tx_max_cell_rate;
+    unsigned int            tx_current_cell_rate;
+
+    struct atm_dev         *dev;
+};
+
+struct connection {
+    struct atm_vcc         *vcc;
+
+    volatile struct tx_descriptor
+                           *tx_desc;
+    unsigned int            tx_desc_pos;
+    struct sk_buff        **tx_skb;
+
+    unsigned int            aal5_vcc_crc_err;       /*  number of packets with CRC error        */
+    unsigned int            aal5_vcc_oversize_sdu;  /*  number of packets with oversize error   */
+
+    unsigned int            port;
+};
+
+struct atm_priv_data {
+    unsigned long           conn_table;
+    struct connection       conn[MAX_PVC_NUMBER];
+
+    volatile struct rx_descriptor
+                           *aal_desc;
+    unsigned int            aal_desc_pos;
+
+    volatile struct rx_descriptor
+                           *oam_desc;
+    unsigned char          *oam_buf;
+    unsigned int            oam_desc_pos;
+
+    struct port             port[ATM_PORT_NUMBER];
+
+    unsigned int            wrx_pdu;        /*  successfully received AAL5 packet       */
+    unsigned int            wrx_drop_pdu;   /*  AAL5 packet dropped by driver on RX     */
+    unsigned int            wtx_pdu;        /*  successfully transmitted AAL5 packet    */
+    unsigned int            wtx_err_pdu;    /*  error AAL5 packet                       */
+    unsigned int            wtx_drop_pdu;   /*  AAL5 packet dropped by driver on TX     */
+
+    unsigned int            wrx_oam;        /*  successfully received OAM cell          */
+    unsigned int            wrx_drop_oam;   /*  OAM cell dropped by driver on RX        */
+    unsigned int            wtx_oam;        /*  successfully transmitted OAM cell       */
+    unsigned int            wtx_err_oam;    /*  error during transmiting OAM cell       */
+    unsigned int            wtx_drop_oam;   /*  OAM cell dropped by driver on TX        */
+
+    ppe_u64_t               wrx_total_byte;
+    ppe_u64_t               wtx_total_byte;
+    unsigned int            prev_wrx_total_byte;
+    unsigned int            prev_wtx_total_byte;
+
+    void                   *aal_desc_base;
+    void                   *oam_desc_base;
+    void                   *oam_buf_base;
+    void                   *tx_desc_base;
+    void                   *tx_skb_base;
+};
+
+
+
+/*
+ * ####################################
+ *             Declaration
+ * ####################################
+ */
+
+extern unsigned int ifx_atm_dbg_enable;
+
+extern void ifx_atm_get_fw_ver(unsigned int *major, unsigned int *minor);
+
+extern void ifx_atm_init_chip(void);
+extern void ifx_atm_uninit_chip(void);
+
+extern int ifx_pp32_start(int pp32);
+extern void ifx_pp32_stop(int pp32);
+
+extern unsigned int ifx_atm_get_qsb_clk(void);
+
+#define IFX_REG_R32(_r)                    __raw_readl((volatile unsigned int *)(_r))
+#define IFX_REG_W32(_v, _r)               __raw_writel((_v), (volatile unsigned int *)(_r))
+
+#define INT_NUM_IM0_IRL24 (INT_NUM_IM0_IRL0 + 24)
+#define INT_NUM_IM1_IRL29 (INT_NUM_IM1_IRL0 + 29)
+
+/*
+ *  Bits Operation
+  */
+#define GET_BITS(x, msb, lsb)               \
+      (((x) >> (lsb)) & ((1 << ((msb) + 1 - (lsb))) - 1))
+#define SET_BITS(x, msb, lsb, value)        \
+	  (((x) & ~(((1 << ((msb) + 1)) - 1) ^ ((1 << (lsb)) - 1))) | (((value) & ((1 << (1 + (msb) - (lsb))) - 1)) << (lsb)))
+
+#define NUM_ENTITY(x)                           (sizeof(x) / sizeof(*(x)))
+
+static inline int
+ifx_drv_ver(char *buf, char *module, int major, int mid, int minor)
+{
+    return sprintf(buf, "Lantiq %s driver, version %d.%d.%d, (c) 2001-2013 Lantiq Deutschland GmbH\n",
+	            module, major, mid, minor);
+}
+
+#include "ltqmips_atm_ppe_common.h"
+#include "ltqmips_atm_fw_regs_common.h"
+
+
+
+#endif  //  IFXMIPS_ATM_CORE_H
diff --git a/drivers/atm/lantiq/ltqmips_atm_fw_ar9.h b/drivers/atm/lantiq/ltqmips_atm_fw_ar9.h
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/ltqmips_atm_fw_ar9.h
@@ -0,0 +1,439 @@
+#ifndef IFXMIPS_ATM_FW_AR9_H
+#define IFXMIPS_ATM_FW_AR9_H
+
+
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_atm_fw_ar9.h
+** PROJECT      : UEIP
+** MODULES     	: ATM (ADSL)
+**
+** DATE         : 22 OCT 2007
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : ATM Driver (PP32 Firmware)
+** COPYRIGHT    : 	Copyright (c) 2006
+**			Infineon Technologies AG
+**			Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 22 OCT 2007  Xu Liang        Initiate Version, v00.01
+*******************************************************************************/
+
+
+#define VER_IN_FIRMWARE         1
+
+#define ATM_FW_VER_MAJOR        0
+#define ATM_FW_VER_MINOR        16
+
+
+static unsigned int firmware_binary_code[] = {
+ 0x800004b8, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x8000ffe0, 0x00000000, 0x00000000, 0x00000000,
+ 0xc1000002, 0xd90c00f8, 0xc2000002, 0xda0800f9, 0x80004980, 0xc2000000, 0xda0800f9, 0x80003fe8,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x80003fa0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x80005178, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x80003ea0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0xc0400000, 0xc0004840, 0xc88400f8, 0x80004640, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0xc0400002, 0xc0004840, 0xc88400f8, 0x800045c0, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0xc3c00004, 0xdbc800f9, 0xc10c0002, 0xd90c00f8, 0x8000fee0, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0xc10e0002, 0xd90c00f8, 0xc0004808, 0xc84000f8, 0x800045f0, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0xc3e1fffe, 0x597dfffe, 0x593dfe14, 0x900004d9, 0x00000000, 0x00000000, 0x00000000, 0x90cc0481,
+ 0x00000000, 0x00000000, 0x00000000, 0xc3c00000, 0xdbc800f9, 0xc1400008, 0xc1900000, 0x71588000,
+ 0x14100100, 0xc140000a, 0xc1900002, 0x71588000, 0x14100100, 0xc140000c, 0xc1900004, 0x71588000,
+ 0x14100100, 0xc1400004, 0xc1900006, 0x71588000, 0x14100100, 0xc1400006, 0xc1900008, 0x71588000,
+ 0x14100100, 0xc140000e, 0xc190000a, 0x71588000, 0x14100100, 0xc1400000, 0xc190000c, 0x71588000,
+ 0x14100100, 0xc1400002, 0xc190000e, 0x71588000, 0x14100100, 0xc0400000, 0xc11c0000, 0xc000082c,
+ 0xcd05ce00, 0xc11c0002, 0xc000082c, 0xcd05ce00, 0xc0400002, 0xc11c0000, 0xc000082c, 0xcd05ce00,
+ 0xc11c0002, 0xc000082c, 0xcd05ce00, 0xc0000824, 0x00000000, 0xcbc000f9, 0xcb8000f9, 0xcb4000f9,
+ 0xcb0000f8, 0xc0004878, 0x5bfc4000, 0xcfc000f9, 0x5bb84000, 0xcf8000f9, 0x5b744000, 0xcf4000f9,
+ 0x5b304000, 0xcf0000f8, 0xc0000a10, 0x00000000, 0xcbc000f9, 0xcb8000f8, 0xc0004874, 0x5bfc4000,
+ 0xcfc000f9, 0x5bb84000, 0xcf8000f8, 0xc30001fe, 0xc000140a, 0xcf0000f8, 0xc3000000, 0x7f018000,
+ 0xc000042e, 0xcf0000f8, 0xc000040e, 0xcf0000f8, 0xc3c1fffe, 0xc000490e, 0xcfc00078, 0xc000492c,
+ 0xcfc00078, 0xc0004924, 0xcfc00038, 0xc0004912, 0xcfc00038, 0xc0004966, 0xcfc00038, 0xc0004968,
+ 0xcfc00078, 0xc000496a, 0xcfc00078, 0xc3c1fffe, 0xc00049a0, 0xcfc000f8, 0xc3c00000, 0xc2800020,
+ 0xc3000000, 0x7f018000, 0x6ff88000, 0x6fd44000, 0x4395c000, 0x5bb84a00, 0x5838000a, 0xcf0000f8,
+ 0x5bfc0002, 0xb7e8ffc8, 0x00000000, 0xc3c00000, 0xc2800010, 0x6ff86000, 0x47bdc000, 0x5bb84c80,
+ 0xc3400000, 0x58380004, 0xcb420078, 0x00000000, 0x58380008, 0xcf400078, 0x5bfc0002, 0xb7e8ffb0,
+ 0x00000000, 0xc3c00000, 0xc2800020, 0xc348001e, 0xc3000000, 0x7f018000, 0x6ff8a000, 0x6fd44000,
+ 0x4795c000, 0x47bdc000, 0x5bb87000, 0x58380008, 0xcf408418, 0x5838000a, 0xcf0000f8, 0x5bfc0002,
+ 0xb7e8ffb0, 0x00000000, 0x00000000, 0xc3e0a242, 0x5bfc0020, 0xc0004002, 0xcfc000f8, 0x00000000,
+ 0xc121fffe, 0x5911fe14, 0x14100000, 0x80000530, 0x00000000, 0x80002130, 0x00000000, 0x8000ffe0,
+ 0xc0004958, 0xc84000f8, 0x00000000, 0xc3c00002, 0x787c2000, 0xcc4000f8, 0xc0004848, 0xcb8400f8,
+ 0xc000495c, 0xcac400f8, 0xc0004844, 0xc88400f8, 0x47ad0000, 0x8400ff82, 0xc000487c, 0xc80400f8,
+ 0x00000000, 0x00000000, 0x40080000, 0xca0000f8, 0xc0001624, 0xcb0400f8, 0xa63c007a, 0x00000000,
+ 0x00000000, 0xa71eff22, 0x00000000, 0xc0000824, 0xca8400f8, 0x6ca08000, 0x6ca42000, 0x46250000,
+ 0x42290000, 0xc35e0002, 0xc6340060, 0xc0001624, 0xcf440078, 0xc2000000, 0xc161fffe, 0x5955fffe,
+ 0x14140000, 0x00000000, 0xc0004844, 0xc88400f8, 0xc000082c, 0xca040038, 0x00000000, 0x00000000,
+ 0x58880002, 0xb6080018, 0x00000000, 0xc0800000, 0xc0004844, 0xcc840038, 0x5aec0002, 0xc000495c,
+ 0xcec400f8, 0x5e6c0006, 0x84000060, 0xc0004848, 0xcb8400f8, 0xc0000838, 0xc2500002, 0xce450800,
+ 0x5fb80002, 0xc0004848, 0xcf8400f8, 0x5eec0002, 0xc000495c, 0xcec400f8, 0x00000000, 0xc121fffe,
+ 0x5911fe14, 0x14100000, 0x8000fd98, 0xc000495a, 0xc84000f8, 0x00000000, 0xc3c00002, 0x787c2000,
+ 0xcc4000f8, 0xc0004960, 0xcac400f8, 0x00000000, 0x00000000, 0x5eec0000, 0x8400010a, 0x00000000,
+ 0xb6fc0050, 0xc0001600, 0xca0400f8, 0x00000000, 0x00000000, 0xa61e00d2, 0x6fe90000, 0xc0000a28,
+ 0xce850800, 0xc2c00000, 0xc2800004, 0xb6e800a0, 0xc0001604, 0xca8400f8, 0xc0004960, 0xcec400f8,
+ 0xa69efcc2, 0x00000000, 0x6fe90000, 0xc0000a28, 0xce850800, 0xc2c00002, 0xc0001600, 0xca0400f8,
+ 0x00000000, 0x00000000, 0xa61e002a, 0x6fe90000, 0xc0000a28, 0xce850800, 0xc2c00000, 0xc0001604,
+ 0xca8400f8, 0xc0004960, 0xcec400f8, 0xa69efc2a, 0xc2400000, 0xc0000a14, 0xca440028, 0x00000000,
+ 0x00000000, 0x466d2000, 0xa4400020, 0xc2800000, 0xdfeb0029, 0x80000010, 0xdfea0029, 0xb668fba2,
+ 0x00000000, 0xc00048a0, 0xcb0400f8, 0xc0000a10, 0xca8400f8, 0x6f208000, 0x6f242000, 0x46250000,
+ 0x42a10000, 0xc2400000, 0xc0000a14, 0xca440028, 0xc35e0002, 0xc6340060, 0xc0001604, 0xcf440078,
+ 0x5b300002, 0xb6700018, 0x5aec0002, 0xc3000000, 0xc00048a0, 0xcf0400f8, 0xc0004960, 0xcec400f8,
+ 0x8000fad8, 0xc0004918, 0xd28000f8, 0xc2000000, 0xdf600038, 0x5e600080, 0x84000272, 0x00000000,
+ 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000, 0xc000480a, 0xca0000f8, 0xc0004912, 0xca4000f8,
+ 0xc0004924, 0xca8000f8, 0xc0004966, 0xcac000f8, 0x00000000, 0xc121fffe, 0x5911fe14, 0x14100000,
+ 0x76250000, 0x76290000, 0x762d0000, 0x840001ca, 0xc0004918, 0xca4000f8, 0xc28001fe, 0x76290000,
+ 0x5a640002, 0x6a254010, 0x5ee80000, 0x8400001a, 0x6aa54000, 0x80000010, 0xc62800f8, 0x62818008,
+ 0xc0004918, 0xcf0000f8, 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000, 0xc0004966, 0xca4000f8,
+ 0xc2000002, 0x6a310000, 0x7e010000, 0x76612000, 0xce4000f8, 0x00000000, 0xc121fffe, 0x5911fe14,
+ 0x14100000, 0x6f346000, 0x4771a000, 0x5b744c80, 0xc2800000, 0x58340006, 0xca800078, 0xc2c00000,
+ 0x58340000, 0xcac000d8, 0xc2400000, 0x5834000a, 0xca420078, 0x6ea82000, 0x42e9e000, 0x6f2ca000,
+ 0x42e56000, 0x5aec2e00, 0xc3990040, 0xc7381c18, 0xc6f80060, 0x99005b78, 0xdb9800f8, 0xdbd800f9,
+ 0x00000000, 0xdea000f8, 0x46310000, 0x8400fd80, 0xc0004958, 0xc84000f8, 0x00000000, 0xc3c00002,
+ 0x787c2000, 0xcc4000f8, 0xc0004848, 0xcb8400f8, 0xc0004844, 0xc88400f8, 0x5fb80000, 0x8400f7f2,
+ 0xc0001a1c, 0xca0000f8, 0xc2400002, 0x6a452000, 0x76250000, 0x8400f7c2, 0xc000487c, 0xc80400f8,
+ 0x00000000, 0x00000000, 0x40080000, 0xca0000f8, 0xc42400f8, 0x00000000, 0xa63c17da, 0x00000000,
+ 0xc0004878, 0xc80400f8, 0x6c908000, 0x45088000, 0x45088000, 0x40100000, 0xca0000f8, 0xc42400f8,
+ 0x00000000, 0xc0004934, 0xce0000f8, 0xc2800002, 0xc4681c08, 0xc62821d0, 0xc2600010, 0x5a650060,
+ 0xc0004800, 0xcb4000f8, 0xc2200400, 0x5a200020, 0xc7601040, 0xc0001220, 0xce8000f8, 0xc0001200,
+ 0xce4000f8, 0xc0001202, 0xce0000f8, 0xc0001240, 0xcb4000f8, 0x00000000, 0x00000000, 0xa754ffe0,
+ 0xc2000000, 0xc7600040, 0xa7520042, 0x00000000, 0x00000000, 0x990062f0, 0xc0004822, 0xc94000f8,
+ 0xc1800002, 0x80001680, 0x582040a0, 0xc2000000, 0xca000018, 0xc2400000, 0xca414000, 0xc2800000,
+ 0xca812000, 0xc2c00000, 0xcac20018, 0xc0004938, 0xce0000f8, 0xc0004920, 0xce4000f8, 0xc0004916,
+ 0xce8000f8, 0xc0004922, 0xcec000f8, 0xa6400540, 0x00000000, 0xc0004938, 0xcbc000f8, 0x00000000,
+ 0xc3800000, 0x6ff48000, 0x6fd44000, 0x4355a000, 0x5b744a00, 0x58340000, 0xcb802010, 0x00000000,
+ 0xc2000000, 0x6fb46000, 0x4779a000, 0x5b744c80, 0x5834000c, 0xca000020, 0xc000491a, 0xcf8000f8,
+ 0x5e200000, 0x8400046a, 0xc2000000, 0xdf610048, 0x5e6001e8, 0x8800ffe8, 0xc2000002, 0xc2400466,
+ 0xc2a00000, 0x5aa80000, 0xc0001006, 0xce0000f8, 0xc0001008, 0xce4000f8, 0xc000100a, 0xce8000f8,
+ 0x990055b8, 0xc1a0fffe, 0xc0000824, 0xc9840060, 0xc0004934, 0xca4000f8, 0xc2000000, 0xc2800002,
+ 0x990055f8, 0xda9800f8, 0xc61400f8, 0xc65800f8, 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000,
+ 0x990056e0, 0xc000491a, 0xc94000f8, 0x00000000, 0x00000000, 0xc121fffe, 0x5911fe14, 0x14100000,
+ 0xc0004922, 0xca001118, 0xc3c00000, 0xc3800000, 0xc0004930, 0xce023118, 0xc0004932, 0xcbc000d8,
+ 0xc2800000, 0xc000491e, 0xcfc000f8, 0xc0004862, 0xca800060, 0xc3a0001a, 0x5bb94000, 0xc6b80060,
+ 0xc000491c, 0xcf8000f8, 0x99005950, 0xc000491c, 0xc1400000, 0xc9420048, 0x00000000, 0x00000000,
+ 0x00000000, 0xa8e2ffe8, 0xc2000000, 0xc1220002, 0xd90c00f8, 0xdf600038, 0x5e600080, 0x8400fff2,
+ 0xc000491c, 0xca0000f8, 0xc000491e, 0xca4000f8, 0x00000000, 0x00000000, 0x99005b78, 0xda1800f8,
+ 0xda5800f9, 0x00000000, 0xc2000000, 0xdf610048, 0x5e6001fe, 0x8800ffe8, 0xc0004916, 0xca8000f8,
+ 0xc2c00000, 0xdfec0048, 0xc2400000, 0x466d2000, 0x8400004a, 0x5ea80000, 0x8400003a, 0xc2600002,
+ 0x990062f0, 0xc000482e, 0xc94000f8, 0xc1800002, 0x80000030, 0xc2600000, 0x990062f0, 0xc000482c,
+ 0xc94000f8, 0xc1800002, 0xc2000068, 0xc6240078, 0xc0004930, 0xce400080, 0xc000491a, 0xc98000f8,
+ 0xc0004862, 0xc94000f8, 0x6d9c6000, 0x45d8e000, 0x59dc4c80, 0x990059d8, 0xd95800f8, 0xd99800f9,
+ 0xd9d400f8, 0x99005950, 0xc000491c, 0xc1400000, 0xc9420048, 0xc2000000, 0xdf600038, 0x5e600080,
+ 0x8400ffea, 0x00000000, 0xc000491c, 0xca0000f8, 0xc000491e, 0xca4000f8, 0x00000000, 0x00000000,
+ 0x99005b78, 0xda1800f8, 0xda5800f9, 0x00000000, 0x800010e8, 0x00000000, 0x990062f0, 0xc000482a,
+ 0xc94000f8, 0xc1800002, 0x800010b8, 0xc0004938, 0xcbc000f8, 0x00000000, 0x00000000, 0x6ff88000,
+ 0x6fd44000, 0x4395c000, 0x5bb84a00, 0x58380008, 0xca0000f8, 0x00000000, 0x00000000, 0xa6000382,
+ 0x00000000, 0xc0004938, 0xcbc000f8, 0xc3000000, 0x00000000, 0x6ff88000, 0x6fd44000, 0x4395c000,
+ 0x5bb84a00, 0x58380000, 0xcb002010, 0xc2000000, 0x58380008, 0xca020078, 0x5838000c, 0xcac000f8,
+ 0x5838000e, 0xca4000f8, 0xc000491a, 0xcf0000f8, 0xc0004930, 0xcec000f8, 0xc000493c, 0xce0000f8,
+ 0xc0004932, 0xce4000f8, 0x5e200000, 0x84000120, 0xc2800000, 0xa6fe00ba, 0x6f206000, 0x46310000,
+ 0x5a204c80, 0x5820000c, 0xca800020, 0x00000000, 0x00000000, 0x5ea80000, 0x840001f2, 0x00000000,
+ 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000, 0x990056e0, 0xc000491a, 0xc94000f8, 0x00000000,
+ 0x00000000, 0xc121fffe, 0x5911fe14, 0x14100000, 0xc0004930, 0xcac000f8, 0xc0004932, 0xca4000f8,
+ 0xc7ec1118, 0xc0004930, 0xcec000f8, 0x5838000c, 0xcec000f8, 0x58000002, 0xce4000f8, 0xc0004934,
+ 0xca0000f8, 0xc2400002, 0x6e642000, 0x6e642000, 0x76612000, 0x8400002a, 0xc2400002, 0x6e684000,
+ 0x58380008, 0xce804200, 0xa6000020, 0x6e682000, 0x58380008, 0xce802100, 0xc2400002, 0x6e642000,
+ 0x76612000, 0x840000ea, 0x58380008, 0xca0000f8, 0xc2800000, 0xc2400000, 0xa60200c0, 0xdba800f8,
+ 0x6f386000, 0x47b1c000, 0x5bb84c80, 0x58380004, 0xca400078, 0x58380002, 0xca800078, 0x00000000,
+ 0xdeb800f8, 0x46a54000, 0x88000060, 0x00000000, 0xc0004824, 0xca0000f8, 0xc2400002, 0x6e640000,
+ 0x5a200002, 0xce0000f8, 0x58380008, 0xce400000, 0x80000018, 0x00000000, 0x80000048, 0xc0004934,
+ 0xca0000f8, 0x00000000, 0x00000000, 0xa6020c6a, 0x00000000, 0x00000000, 0x80000c98, 0xc2800000,
+ 0xc2000200, 0xc240001a, 0xdf690048, 0x46294000, 0x46a54000, 0x8800ffd2, 0xc2000006, 0xc2600982,
+ 0x5a643b6e, 0x5838000a, 0xca8000f8, 0xc0001006, 0xce0000f8, 0xc0001008, 0xce4000f8, 0xc000100a,
+ 0xce8000f8, 0x990055b8, 0xc1a0fffe, 0xc0000824, 0xc9840060, 0xc2000000, 0xc0004930, 0xca02e008,
+ 0x58380026, 0xca4000f8, 0x00000000, 0xc2800000, 0x990055f8, 0xda9800f8, 0xc61400f8, 0xc65800f8,
+ 0xc0004934, 0xca0000f8, 0x00000000, 0x00000000, 0xa6020022, 0x00000000, 0x00000000, 0x80000318,
+ 0xc0004938, 0xcbc000f8, 0xc0004878, 0xc80400f8, 0x6c908000, 0x45088000, 0x45088000, 0x40100000,
+ 0xca0000f8, 0xc42400f8, 0x00000000, 0x58240018, 0xca0000f8, 0x6ff88000, 0x6fd44000, 0x4395c000,
+ 0x5bb84a00, 0xc3000000, 0xc3400002, 0xc2c00000, 0xc62c0078, 0xc6270038, 0xc0004940, 0xce400038,
+ 0xc6260038, 0xc0004942, 0xce400038, 0xc000493c, 0xca0000f8, 0x5eec0000, 0x8400018a, 0x5a6c0010,
+ 0x46254000, 0x88000190, 0x5a600052, 0x46e54000, 0x88000178, 0x58380006, 0xca8000f8, 0xc0004940,
+ 0xca0000f8, 0xc2400000, 0xc6a70038, 0x7e412000, 0x76612000, 0xc2000000, 0xc6a10038, 0x46250000,
+ 0x84000138, 0xc0004942, 0xca0000f8, 0xc2400000, 0xc6a60038, 0x7e412000, 0x76612000, 0xc2000000,
+ 0xc6a00038, 0x58380002, 0xca8000f8, 0x46250000, 0x840000e8, 0xc2400000, 0xc6a60078, 0x466d0000,
+ 0x880000da, 0xc2400000, 0xc6a40078, 0x58380008, 0xca8000f8, 0x46e50000, 0x880000ba, 0x00000000,
+ 0xa6820018, 0x00000000, 0xc7700b00, 0xa6840098, 0x00000000, 0xc7700a00, 0x80000080, 0xc7700200,
+ 0xc000493c, 0xcac000f8, 0x80000060, 0xc7700300, 0xc000493c, 0xcac000f8, 0x80000040, 0xc7700900,
+ 0x80000030, 0xc7700800, 0x80000020, 0xc7700700, 0x80000010, 0xc7700500, 0xc0004944, 0xcf0000f8,
+ 0xc000493e, 0xcec000f8, 0xc0004938, 0xca4000f8, 0xc000493c, 0xcb8000f8, 0xc000493e, 0xcb4000f8,
+ 0xc3000000, 0x6e608000, 0x6e544000, 0x42150000, 0x5a204a00, 0x5aa00008, 0x58200004, 0xcb000078,
+ 0xc0004934, 0xca0000f8, 0xc2400000, 0xc0004930, 0xca42e008, 0xc3c00018, 0xa6020098, 0x00000000,
+ 0x43656000, 0x47ad0000, 0x88000050, 0x46f96000, 0x6ee04010, 0x5be00004, 0xc2000000, 0xc6e00008,
+ 0x5e200000, 0x84000042, 0x5bfc0002, 0x80000030, 0xc3c00004, 0x5a2c0008, 0x47a10000, 0x88000012,
+ 0x5fb80008, 0x6fe04000, 0x42390000, 0x47212000, 0x88000068, 0xc2400000, 0xc0004930, 0xca42e008,
+ 0xc2060002, 0xc68000f8, 0xce006300, 0x6fe04000, 0x4721c000, 0x5f700010, 0x4765a000, 0xc2000000,
+ 0xc6340008, 0xc25a000a, 0xc000491a, 0xca401c18, 0xc2800000, 0xc0004932, 0xca8000d8, 0xc0004862,
+ 0xca400060, 0x6fa04010, 0x42290000, 0xc000491e, 0xce0000f8, 0xc7e41048, 0xc000491c, 0xce4000f8,
+ 0x6fe04000, 0x43a1c000, 0xc000493c, 0xcf8000f8, 0xc000493e, 0xcf4000f8, 0xc000493a, 0xcfc000f8,
+ 0x80000008, 0x00000000, 0x00000000, 0x00000000, 0xc2000000, 0xdce000f8, 0xa622ffd8, 0xc1220002,
+ 0xd90c00f8, 0xc0004938, 0xcbc000f8, 0xc0004944, 0xcb4000f8, 0xc0004862, 0xcb0000f8, 0xc0004934,
+ 0xca0000f8, 0x6ff88000, 0x6fd44000, 0x4395c000, 0x5bb84a00, 0xa6020268, 0xc2400000, 0x58380008,
+ 0xca406000, 0xdfe800f8, 0xc2218e08, 0x5a21baf6, 0x46a14000, 0x84000022, 0xc2080002, 0x7361a000,
+ 0x80000058, 0x5e640000, 0x84000022, 0xc20c0002, 0x7361a000, 0x80000030, 0xc2000000, 0xc760e710,
+ 0xc7604218, 0x5e200000, 0x84000272, 0xc2200002, 0xc0004930, 0xce021000, 0x990062f0, 0xc0004828,
+ 0xc94000f8, 0xc1800002, 0x58380000, 0xca0000f8, 0x00000000, 0x00000000, 0xa6000132, 0xc0004940,
+ 0xca8000f8, 0xc0004942, 0xca4000f8, 0xc7600078, 0xc6a01838, 0xc6601038, 0xc000493a, 0xca4000f8,
+ 0xc0004934, 0xca8000f8, 0xc0007800, 0x40300000, 0x40240000, 0x5c000004, 0x5ec07a00, 0x88000012,
+ 0x5c000200, 0xce0000f8, 0x58000002, 0x5ec07a00, 0x88000012, 0x5c000200, 0xce8000f8, 0xc000493e,
+ 0xca0000f8, 0xc2400000, 0x5838000c, 0xce4000f8, 0x990062f0, 0xc0004830, 0xc94000f8, 0xc61800f8,
+ 0xc0004930, 0xc6100078, 0xcd000078, 0x800000a8, 0xc2400002, 0x58380008, 0xce400000, 0xc0004944,
+ 0xcf4000f8, 0x80000278, 0xc000493c, 0xca4000f8, 0xdfe800f8, 0x5a300018, 0xc0007800, 0x40200000,
+ 0xca0000f8, 0x58380008, 0xc6501078, 0xcd021078, 0x5838000a, 0xce8000f8, 0x58380026, 0xce0000f8,
+ 0xc0004944, 0xcf4000f8, 0x99005950, 0xc000491c, 0xc1400000, 0xc9420048, 0x80000038, 0x00000000,
+ 0x990062f0, 0xc0004826, 0xc94000f8, 0xc1800002, 0x8000fdd8, 0xc2000000, 0xc2400080, 0xdf600038,
+ 0xb624ffea, 0xc000491c, 0xca4000f8, 0xc000491e, 0xca8000f8, 0x99005b78, 0xda5800f8, 0xda9800f9,
+ 0x00000000, 0xc0004934, 0xca0000f8, 0x00000000, 0xc2800000, 0xa6020160, 0xc2400004, 0xc2000200,
+ 0xdf690048, 0x46294000, 0x46a54000, 0x8800ffda, 0x00000000, 0xc000491a, 0xc98000f8, 0xc0004862,
+ 0xc94000f8, 0x6d9c6000, 0x45d8e000, 0x59dc4c80, 0x990059d8, 0xd95800f8, 0xd99800f9, 0xd9d400f8,
+ 0x99005950, 0xc000491c, 0xc1400000, 0xc9420048, 0xc2000000, 0xc2400080, 0xdf600038, 0xb624ffea,
+ 0xc000491c, 0xca4000f8, 0xc000491e, 0xca8000f8, 0x99005b78, 0xda5800f8, 0xda9800f9, 0x00000000,
+ 0x58380008, 0xca4000f8, 0xc2000000, 0xce000018, 0xc2a1fffe, 0x5aa9fffe, 0xce021078, 0x5838000a,
+ 0xce8000f8, 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000, 0xc0000838, 0xc2500002, 0xce450800,
+ 0xc0004848, 0xcb8400f8, 0xc2000000, 0xc000082c, 0xca040028, 0x5fb80002, 0xc0004848, 0xcf8400f8,
+ 0x58880002, 0xb6080018, 0x00000000, 0xc0800000, 0xc0004844, 0xcc8400f8, 0x00000000, 0xc121fffe,
+ 0x5911fe14, 0x14100000, 0x8000ded8, 0xc2000000, 0xdf600038, 0x5e200080, 0x8400026a, 0x00000000,
+ 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000, 0xc000480c, 0xca0000f8, 0xc0004910, 0xca4000f8,
+ 0xc000492c, 0xca8000f8, 0xc0004968, 0xcac000f8, 0x00000000, 0xc121fffe, 0x5911fe14, 0x14100000,
+ 0x76250000, 0x76290000, 0x76e16000, 0x840001c2, 0xc0004926, 0xca4000f8, 0xc201fffe, 0x76e16000,
+ 0x5a640002, 0x6ae50010, 0x5f200000, 0x8400001a, 0x6a250000, 0x80000010, 0xc6e000f8, 0x62014008,
+ 0xc0004926, 0xce8000f8, 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000, 0xc0004968, 0xca4000f8,
+ 0xc2000002, 0x6a290000, 0x7e010000, 0x76612000, 0xce4000f8, 0x00000000, 0xc121fffe, 0x5911fe14,
+ 0x14100000, 0x6eb4a000, 0x6e944000, 0x4755a000, 0x4769a000, 0x5b747000, 0x58340002, 0xc2000000,
+ 0xca0000d8, 0x5834002e, 0xc2400000, 0xca400078, 0x6eb0a000, 0x6ebc4000, 0x473d8000, 0x47298000,
+ 0x5b30302e, 0x5b300004, 0x6e642000, 0x4225e000, 0xc39a8024, 0xc7380060, 0xc6b81c18, 0x99005b78,
+ 0xdb9800f8, 0xdbd800f9, 0x00000000, 0xc2000000, 0xdf600038, 0x5e200080, 0x84000352, 0x00000000,
+ 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000, 0xc000490e, 0xca0000f8, 0xc00049a0, 0xca8000f8,
+ 0xc000492a, 0xca4000f8, 0xc000496a, 0xcb0000f8, 0xc0004956, 0xcac000f8, 0x00000000, 0xc121fffe,
+ 0x5911fe14, 0x14100000, 0x77218000, 0x77258000, 0x77298000, 0x8400029a, 0xc201fffe, 0x77218000,
+ 0x5aec0002, 0x6b2d0010, 0x5ea00000, 0x8400001a, 0x6a2d0000, 0x80000010, 0xc72000f8, 0x62016008,
+ 0xc0004956, 0xcec000f8, 0x6ef4a000, 0x6ed44000, 0x4755a000, 0x476da000, 0x5b747000, 0x58340000,
+ 0xc9c000f8, 0xc00049a0, 0xca0000f8, 0xc3000000, 0xc5f04018, 0xc2400000, 0xc5e50038, 0x7e412000,
+ 0x76250000, 0xce0000f8, 0xc0004980, 0x40300000, 0xcec000f8, 0xc161fffe, 0x5955fffe, 0x14140000,
+ 0x00000000, 0xc000496a, 0xca4000f8, 0xc2000002, 0x6a2d0000, 0x7e010000, 0x76612000, 0xce4000f8,
+ 0x00000000, 0xc121fffe, 0x5911fe14, 0x14100000, 0x6ef4a000, 0x6ed44000, 0x4755a000, 0x476da000,
+ 0x5b747000, 0x5834000e, 0xc2000000, 0xca0000d8, 0x58340008, 0xc2400000, 0xca420078, 0x5834000c,
+ 0xc2800000, 0xca832010, 0x6e644010, 0x42250000, 0x4229e000, 0xc39a8008, 0x58340008, 0xcb809018,
+ 0x58340008, 0xc2800000, 0xca810010, 0x6ee0a000, 0x6ee44000, 0x46250000, 0x462d0000, 0x5a200008,
+ 0x5a203008, 0x42290000, 0xc6380060, 0xc6f81c18, 0x99005b78, 0xdb9800f8, 0xdbd800f9, 0x00000000,
+ 0xc000495a, 0xc84000f8, 0x00000000, 0xc3c00002, 0x787c2000, 0xcc4000f8, 0xc0001a1c, 0xca0000f8,
+ 0xc2400008, 0x6a452000, 0x76250000, 0x84000ec2, 0xc0000a28, 0xc3800000, 0xcb840028, 0xc0000a14,
+ 0xc3400000, 0xcb440028, 0xc0004880, 0xcb0400f8, 0xb7b40072, 0x58041802, 0xcac000f8, 0xa7000078,
+ 0x00000000, 0x00000000, 0xa6c8d808, 0xc1000000, 0xc6d00018, 0xc0004980, 0x40100000, 0xca8000f8,
+ 0x80000070, 0x00000000, 0x00000000, 0x00000000, 0x8000d7b8, 0x00000000, 0xc2800000, 0xc7282018,
+ 0xc000490e, 0xca4000f8, 0x6be9e000, 0x00000000, 0x767d2000, 0x8400d770, 0x6ea0a000, 0x6e944000,
+ 0x46150000, 0x46290000, 0x5a207000, 0x5820000c, 0xca0000f8, 0xc0004946, 0xce8000f8, 0xa62203a8,
+ 0x00000000, 0xc2200060, 0xc0004948, 0xce000008, 0xce021038, 0xc240000a, 0xc000494a, 0xce4000f8,
+ 0xc2b60002, 0xc0004964, 0xce837b00, 0x99005e48, 0xc00048a0, 0xc88400f8, 0x00000000, 0xc0004946,
+ 0xcbc000f8, 0x00000000, 0x00000000, 0x6ff8a000, 0x6fd44000, 0x4795c000, 0x47bdc000, 0x5bb87000,
+ 0x99005c08, 0xdbd800f8, 0xdb9800f9, 0x00000000, 0x99005950, 0xc000491c, 0xc1400000, 0xc9420048,
+ 0xc000491c, 0x99005e00, 0xc94000f9, 0xc98000f8, 0x00000000, 0x99005b78, 0xd95800f8, 0xd99800f9,
+ 0x00000000, 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000, 0x99005840, 0xdbd800f8, 0xdb9800f9,
+ 0xc7d800f8, 0x00000000, 0xc121fffe, 0x5911fe14, 0x14100000, 0x6ff8a000, 0x6fd44000, 0x4795c000,
+ 0x47bdc000, 0x5bb87000, 0x58380010, 0xca0000f8, 0xc0004874, 0xc80400f8, 0x6c908000, 0x45088000,
+ 0x45088000, 0x40100000, 0xca4000f8, 0xc43400f8, 0x00000000, 0xc74000f8, 0xce0000f8, 0xc161fffe,
+ 0x5955fffe, 0x14140000, 0x00000000, 0xc000490e, 0xca4000f8, 0xc2800002, 0x6abd4000, 0x72692000,
+ 0xce4000f8, 0x00000000, 0xc121fffe, 0x5911fe14, 0x14100000, 0x990062f0, 0xc0004836, 0xc94000f8,
+ 0xc1800002, 0x00000000, 0x00000000, 0x00000000, 0xa8e2ffe8, 0x00000000, 0x58380000, 0xc90000f8,
+ 0xc00049a0, 0xca0000f8, 0xc2800000, 0xc5290038, 0x72290000, 0xce0000f8, 0xc1220002, 0xd90c00f8,
+ 0xc2000000, 0xc0000a14, 0xca040028, 0xc0000a28, 0xc2500002, 0xce450800, 0x58880002, 0xb6080018,
+ 0xc00048a0, 0xc0800000, 0xcc8400f8, 0x8000d380, 0xc0004946, 0xcbc000f8, 0xc161fffe, 0x5955fffe,
+ 0x14140000, 0x00000000, 0xc000490e, 0xca4000f8, 0xc2800002, 0x6abd4000, 0x72692000, 0xce4000f8,
+ 0x00000000, 0xc121fffe, 0x5911fe14, 0x14100000, 0x6ff8a000, 0x6fd44000, 0x4795c000, 0x47bdc000,
+ 0x5bb87000, 0x58380008, 0xca0000f8, 0x5838000c, 0xca4000f8, 0xc3400000, 0xc6340000, 0xc000494e,
+ 0xcf4000f8, 0xc2800000, 0xc62a0078, 0xc3000000, 0xc6308018, 0x6f304000, 0x43298000, 0xc000493c,
+ 0xcf0000f8, 0xc2c00000, 0xc66c0078, 0xc0004950, 0xcec000f8, 0xc2800000, 0xc66ae020, 0xc0004954,
+ 0xce8000f8, 0x5f740000, 0x840001a0, 0x5e300028, 0x46e12000, 0x8400016a, 0x46e12000, 0x88000132,
+ 0x5e300018, 0x46e12000, 0x8800002a, 0x46e12000, 0x84000042, 0x00000000, 0x800000c0, 0x00000000,
+ 0x99005f88, 0xdbd800f8, 0xdb9800f9, 0xc78000f8, 0xc3400002, 0xc000494e, 0xcf4000f8, 0xc161fffe,
+ 0x5955fffe, 0x14140000, 0x00000000, 0xc000490e, 0xca4000f8, 0xc2800002, 0x6abd4000, 0x7e814000,
+ 0x76692000, 0xce4000f8, 0x00000000, 0xc121fffe, 0x5911fe14, 0x14100000, 0xc2200060, 0xc0004948,
+ 0xce021038, 0xc2000000, 0xc000494c, 0xce0000f8, 0x80000080, 0x00000000, 0x99005f88, 0xdbd800f8,
+ 0xdb9800f9, 0xc78000f8, 0x99006188, 0xdbd800f8, 0xdb9800f9, 0xc78000f8, 0xc2200058, 0xc0004948,
+ 0xce021038, 0xc2000002, 0xc000494c, 0xce0000f8, 0xc2000006, 0xc0001006, 0xce0000f8, 0x5838000a,
+ 0xca4000f8, 0xc2200982, 0x5a203b6e, 0xc0001008, 0xce0000f8, 0xc000100a, 0xce4000f8, 0xc0004954,
+ 0xca8000f8, 0xc200000c, 0xc000494a, 0xce0000f8, 0xc0004948, 0xce800008, 0xc2b60000, 0xc0004964,
+ 0xce8000f8, 0x99005e48, 0xc00048a0, 0xc88400f8, 0x00000000, 0xc0004946, 0xcbc000f8, 0xc000494c,
+ 0xca0000f8, 0x6ff8a000, 0x6fd44000, 0x4795c000, 0x47bdc000, 0x5bb87000, 0x5e200000, 0x840000fa,
+ 0x00000000, 0x99005c08, 0xdbd800f8, 0xdb9800f9, 0x00000000, 0x99005950, 0xc000491c, 0xc1400000,
+ 0xc9420048, 0xc000491c, 0x99005e00, 0xc94000f9, 0xc98000f8, 0x00000000, 0x99005b78, 0xd95800f8,
+ 0xd99800f9, 0x00000000, 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000, 0x99005840, 0xdbd800f8,
+ 0xdb9800f9, 0xc7d800f8, 0x00000000, 0xc121fffe, 0x5911fe14, 0x14100000, 0xc000493c, 0xca8000f8,
+ 0xc000494e, 0xcac000f8, 0xc3000018, 0xc3400006, 0x5e200000, 0x8400002a, 0xc2800000, 0xc2c00000,
+ 0xc300001e, 0xc3400000, 0xc6ac1078, 0xc72c0418, 0xc76c0810, 0x58380010, 0xca8000f8, 0x58380008,
+ 0xcec000f8, 0xc6280100, 0xc0004874, 0xc80400f8, 0x6c908000, 0x45088000, 0x45088000, 0x40100000,
+ 0xcb0000f8, 0xc43400f8, 0x00000000, 0xc74000f8, 0xce8000f8, 0xc0004952, 0xce8000f8, 0x00000000,
+ 0x00000000, 0x00000000, 0xa8e2ffe8, 0x00000000, 0xc000494c, 0xca0000f8, 0xc0004950, 0xcac000f8,
+ 0x5e200000, 0x8400006a, 0xdfe800f8, 0x7e814000, 0x5834001a, 0xce8000f8, 0x990062f0, 0xc0004834,
+ 0xc94000f8, 0xc1800002, 0x990062f0, 0xc0004838, 0xc94000f8, 0xc6d800f8, 0xc1220002, 0xd90c00f8,
+ 0x5e200000, 0x84000040, 0x5838002c, 0xcb0000f8, 0xdfe800f8, 0x00000000, 0x58380014, 0xcf0000f8,
+ 0x80000058, 0xc2a1fffe, 0x5aa9fffe, 0x58380000, 0xc90000f8, 0xc00049a0, 0xcb0000f8, 0xc2c00000,
+ 0xc52d0038, 0x732d8000, 0xcf0000f8, 0x5838000a, 0xce8000f8, 0xc3000000, 0xc0000a14, 0xcb040028,
+ 0xc2d00002, 0xc0000a28, 0xcec50800, 0xc000494e, 0xca8000f8, 0x58880002, 0xb4b00018, 0xc00048a0,
+ 0xc0800000, 0xcc8400f8, 0x5ea80000, 0x8400017a, 0x5e200000, 0x84000168, 0xc000493c, 0xca8000f8,
+ 0x00000000, 0x00000000, 0x5aa80060, 0xce8000f8, 0x99005f88, 0xdbd800f8, 0xdb9800f9, 0xc78000f8,
+ 0x99006188, 0xdbd800f8, 0xdb9800f9, 0xc78000f8, 0x58380000, 0xcac000f8, 0x00000000, 0xc2000000,
+ 0xc6e04018, 0xc0004952, 0xcac000f8, 0x58380000, 0xca8000f8, 0xc30c0002, 0xc6300018, 0xa6800098,
+ 0x00000000, 0x00000000, 0xc161fffe, 0x5955fffe, 0x14140000, 0x00000000, 0xc0001800, 0xca0000f8,
+ 0x00000000, 0x00000000, 0xa60cffea, 0xc6f00500, 0xc6b0c400, 0xcf0000f8, 0x00000000, 0xc121fffe,
+ 0x5911fe14, 0x14100000, 0x8000c9c8, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x8000c960,
+ 0xdcbc00f9, 0x5ffc0000, 0x84000052, 0xc3800002, 0xdb8800f9, 0x5ffc0004, 0x8400c292, 0xc3800000,
+ 0xdb8800f9, 0xc3ce0002, 0xc0000800, 0xcfc0e700, 0xc3e1fffe, 0x597dfffe, 0x593dfe14, 0x94000001,
+ 0x00000000, 0x00000000, 0x00000000, 0xc000487c, 0xc80400f8, 0x00000000, 0x00000000, 0x40080000,
+ 0xcbc000f8, 0xc43800f8, 0x00000000, 0xc000480e, 0xca0000f8, 0xc0004858, 0xcb4400f8, 0x00000000,
+ 0x00000000, 0x47610000, 0x880000b0, 0x00000000, 0xa7c00048, 0xc0004854, 0xc1000002, 0xcd0400f8,
+ 0xc11c0000, 0xc000082c, 0xcd05ce00, 0x800000d8, 0x00000000, 0xa7d20138, 0x00000000, 0xc7e14040,
+ 0xc2400000, 0xc6246028, 0xc200006a, 0x46250000, 0xc6240030, 0xc0000810, 0xce440030, 0x8000ff70,
+ 0xc2000000, 0xc0000808, 0xca040010, 0xc11c0000, 0xc000082c, 0xcd05ce00, 0x5a200002, 0x5e600010,
+ 0x84000010, 0xc2000000, 0xc0000808, 0xce040010, 0xc3400000, 0x80000028, 0xc1200002, 0xc0000818,
+ 0xcd061000, 0x5b740002, 0xc0004858, 0xcf4400f8, 0x99005590, 0xc0004848, 0xc94400f8, 0xc1800000,
+ 0xc11c0002, 0xc000082c, 0xcd05ce00, 0x80000600, 0x5b740002, 0xc0004858, 0xcf4400f8, 0xc78000f8,
+ 0xc13c0002, 0xcd03de00, 0xc0004848, 0xc94400f8, 0xc1800000, 0xc000082c, 0xc9840028, 0x59540002,
+ 0xc0004848, 0xcd4400f8, 0x58880002, 0xb4980580, 0x00000000, 0xc0800000, 0x80000568, 0xc000487c,
+ 0xc80400f8, 0x00000000, 0x00000000, 0x40080000, 0xcbc000f8, 0xc42800f8, 0x00000000, 0xa7c00130,
+ 0xc000484c, 0xca0400f8, 0xc2400000, 0xc0001aec, 0xca440018, 0x5a200002, 0xc000484c, 0xce0400f8,
+ 0xb624008a, 0xc68000f8, 0xc13c0002, 0xcd03de00, 0xc0004848, 0xc94400f8, 0xc1800000, 0xc000082c,
+ 0xc9840028, 0x59540002, 0xc0004848, 0xcd4400f8, 0x58880002, 0xb4980470, 0x00000000, 0xc0800000,
+ 0x80000458, 0xc0004854, 0xc1000004, 0xcd0400f8, 0xc0000820, 0xc2000002, 0xce0400f8, 0xc2000000,
+ 0xc000484c, 0xce0400f8, 0xc0004858, 0xce0400f8, 0x8000ff28, 0xc0004854, 0xc1000000, 0xcd0400f8,
+ 0xc11c0000, 0xc000082c, 0xcd05ce00, 0x99005590, 0xc0004848, 0xc94400f8, 0xc1800000, 0xc1200000,
+ 0xc0000818, 0xcd061000, 0xc11c0002, 0xc000082c, 0xcd05ce00, 0xc2000000, 0xc000484c, 0xce0400f8,
+ 0x80000358, 0xc0001ac0, 0xcb8400f8, 0xc000487c, 0xc80400f8, 0x00000000, 0x00000000, 0x40080000,
+ 0xcbc000f8, 0xc42800f8, 0x00000000, 0x00000000, 0xc68000f8, 0xc13c0000, 0xcd03de00, 0xa780024a,
+ 0x00000000, 0x00000000, 0xa7c0020a, 0x00000000, 0xc0001b00, 0xc2060006, 0xce046308, 0xa7e801c2,
+ 0x00000000, 0xc0004850, 0xca0400f8, 0xc2400000, 0xc0001aec, 0xca448018, 0x5a200002, 0xc0004850,
+ 0xce0400f8, 0xb62400aa, 0x00000000, 0xc68000f8, 0xc13c0002, 0xcd03de00, 0xc0001acc, 0xc2000002,
+ 0xce040000, 0xc0004848, 0xc94400f8, 0xc1800000, 0xc000082c, 0xc9840028, 0x59540002, 0xc0004848,
+ 0xcd4400f8, 0x58880002, 0xb49801c8, 0x00000000, 0xc0800000, 0x800001b0, 0xc0004854, 0xc1000000,
+ 0xcd0400f8, 0xc11c0000, 0xc000082c, 0xcd05ce00, 0x99005590, 0xc0004848, 0xc94400f8, 0xc1800000,
+ 0xc2000000, 0xc0000820, 0xce0400f8, 0xc1200000, 0xc0000818, 0xcd061000, 0xc11c0002, 0xc000082c,
+ 0xcd05ce00, 0xc0004850, 0xce0400f8, 0xc2000002, 0xc0001acc, 0xce040008, 0x800000e8, 0xc2000002,
+ 0xc0004850, 0xce0400f8, 0x8000fe88, 0xc2000000, 0xc0004850, 0xce0400f8, 0xa7e60032, 0x00000000,
+ 0xc2000002, 0xc0001b00, 0xce040000, 0x8000fe70, 0x00000000, 0xa7860052, 0x00000000, 0xc68000f8,
+ 0xc13c0002, 0xcd03de00, 0xc2020002, 0xc7e2a540, 0xc0001b00, 0xce0400f8, 0x8000fe18, 0xc2040002,
+ 0xc0001b00, 0xce044200, 0x8000fdf8, 0xc2c80002, 0x6ac56000, 0xdacc00f8, 0xc0004854, 0xcb4400f8,
+ 0xc0004848, 0xcb8400f8, 0xc0000838, 0xc3c00000, 0xcbc40028, 0x5ef40004, 0x84000022, 0xc3000000,
+ 0xc0001acc, 0xcf042100, 0x47f98000, 0x8400002a, 0x47f98000, 0x88000030, 0xc1006e8c, 0x8000b6c8,
+ 0xc0004840, 0xcc8400f8, 0x8000f6b0, 0xc0001ac0, 0xcac400f8, 0xc0004854, 0xcb4400f8, 0xa6c0fbd2,
+ 0x00000000, 0x5ef40000, 0x8400f70a, 0x5ef40002, 0x8400f99a, 0x5ef40004, 0x8400fb9a, 0xc1006ce8,
+ 0x8000b640, 0x00000000, 0xc0800000, 0xdf4b0038, 0xc0004900, 0xcb8000f8, 0xc2000000, 0xc000490a,
+ 0xa78000d0, 0xcbc000f8, 0xc1000000, 0xd90000f9, 0xc1000002, 0xd90c00f8, 0x6ff46000, 0x477da000,
+ 0x5b744c80, 0xc2400000, 0x58340004, 0xca400078, 0xc0004900, 0xce000000, 0x5a640002, 0x58340004,
+ 0xc6500078, 0xcd000078, 0xc0004914, 0xca4000f8, 0xc2000002, 0x6a3d0000, 0x72612000, 0xce4000f8,
+ 0xc0000408, 0xce0000f8, 0xa78200d8, 0xc0004908, 0xcbc000f8, 0xc1000000, 0xd90000f9, 0xc1000002,
+ 0xd90c00f8, 0x6ff4a000, 0x6fd44000, 0x4755a000, 0x477da000, 0x5b747000, 0xc2800000, 0x58340006,
+ 0xca800078, 0xc2000000, 0xc0004900, 0xce002100, 0x5ea80002, 0x58340006, 0xc6900078, 0xcd000078,
+ 0x5a7c0020, 0xc2000002, 0x6a250000, 0xc0000408, 0xce0000f8, 0xdca800f9, 0x5ea80000, 0x8400b4b0,
+ 0x00000000, 0xa4800230, 0x00000000, 0xc3c00000, 0xc000140e, 0xcbc00018, 0xc3400000, 0xc2400000,
+ 0x6ff86000, 0x47bdc000, 0x5bb84c80, 0x58380008, 0xcb400078, 0x58380006, 0xca400078, 0x5f740002,
+ 0x58380008, 0xc7500078, 0xcd000078, 0xc2000000, 0x58380004, 0xca020078, 0xc3000000, 0x5838000c,
+ 0xcb000020, 0x5a640002, 0x46610000, 0x84000010, 0xc2400000, 0x58380006, 0xc6500078, 0xcd000078,
+ 0xc2000000, 0x5838000a, 0xca020078, 0x5b300002, 0x5838000c, 0xc7100020, 0xcd000020, 0xc2420020,
+ 0x5a200004, 0x46252000, 0x84000010, 0xc2000000, 0x5838000a, 0xc6101078, 0xcd021078, 0xc0004966,
+ 0xca4000f8, 0xc2000002, 0x6a3d0000, 0x72612000, 0xce4000f8, 0x5f740000, 0x84000040, 0xc0004912,
+ 0xca0000f8, 0xc2c00002, 0x6afd6000, 0x7ec16000, 0x762d0000, 0xce0000f8, 0x5f300020, 0x84000040,
+ 0xc0004924, 0xca0000f8, 0xc2c00002, 0x6afd6000, 0x7ec16000, 0x762d0000, 0xce0000f8, 0xa4820070,
+ 0xc2400000, 0xc000140e, 0xca408018, 0xc2000002, 0xc0004900, 0xce000000, 0xc000490a, 0xce4000f8,
+ 0xc1000000, 0xd90000f9, 0xd8400078, 0xc1000004, 0xd90000f9, 0xa4840270, 0x00000000, 0xc3c00000,
+ 0xc000140e, 0xcbc10018, 0xc2800000, 0xc2000000, 0x6ff8a000, 0x6fd44000, 0x4795c000, 0x47bdc000,
+ 0x5bb87000, 0x5838002e, 0xca800078, 0x58380006, 0xca020078, 0xc3400000, 0x5838002e, 0xcb420078,
+ 0x5aa80002, 0x46a10000, 0x84000010, 0xc2800000, 0x5838002e, 0xc6900078, 0xcd000078, 0x5f740002,
+ 0x5838002e, 0xc7501078, 0xcd021078, 0xc0004968, 0xca4000f8, 0xc2000002, 0x6a3d0000, 0x72612000,
+ 0xce4000f8, 0xc000492a, 0xca8000f8, 0x5e740000, 0x84000040, 0xc0004910, 0xca0000f8, 0xc2c00002,
+ 0x6afd6000, 0x7ec16000, 0x762d0000, 0xce0000f8, 0x6abd4010, 0xa68000ba, 0x00000000, 0x58380032,
+ 0xca0000f8, 0x58000002, 0xca4000f8, 0x5838000c, 0x00000000, 0xce0000f9, 0xce4000f8, 0xc000492a,
+ 0xca0000f8, 0xc2c00002, 0x6afd6000, 0x722d0000, 0xce0000f8, 0xc000492c, 0xca0000f8, 0xc2c00002,
+ 0x6afd6000, 0x722d0000, 0xce0000f8, 0x80000040, 0xc000492c, 0xca0000f8, 0xc2c00002, 0x6afd6000,
+ 0x7ec16000, 0x762d0000, 0xce0000f8, 0xa4880148, 0xc2c00000, 0xc000140e, 0xcac20018, 0xc000490e,
+ 0xca4000f8, 0xc2000002, 0x6a2d0000, 0x7e010000, 0x76612000, 0xce4000f8, 0xc000496a, 0xca4000f8,
+ 0xc2000002, 0x6a2d0000, 0x72612000, 0xce4000f8, 0x6ef0a000, 0x6ed44000, 0x47158000, 0x472d8000,
+ 0x5b307000, 0x58300000, 0xca0000f8, 0x00000000, 0xc2400002, 0x76612000, 0x84000072, 0x58300000,
+ 0xca4000f8, 0xc2800000, 0x00000000, 0xc6684018, 0xc24c0002, 0xc6a40018, 0xc624c400, 0x58300010,
+ 0xca400500, 0x00000000, 0xc0001800, 0xce4000f8, 0xa4860070, 0xc2400000, 0xc000140e, 0xca418018,
+ 0xc2020002, 0xc0004900, 0xce002100, 0xc0004908, 0xce4000f8, 0xc1000000, 0xd90000f9, 0xd8400078,
+ 0xc1000004, 0xd90000f9, 0xc0001408, 0xcc8000f8, 0xc10e0002, 0xd90c00f8, 0x8000edb0, 0xdfbc00f9,
+ 0xc000496e, 0x99006298, 0xc94000f8, 0xc7d800f8, 0x00000000, 0xc57000f8, 0x5ef00020, 0x88000148,
+ 0x6f346000, 0x4771a000, 0x5b744c80, 0x58340008, 0xc2400000, 0xca400078, 0x00000000, 0xc2000000,
+ 0x5a640002, 0xce400078, 0x58340004, 0xca000078, 0x00000000, 0x00000000, 0x5e200002, 0xce000078,
+ 0xc0004912, 0xca8000f8, 0xc2400002, 0x6a712000, 0x72a54000, 0xce8000f8, 0x5e200000, 0x84000052,
+ 0xc000480a, 0xca0000f8, 0xc0000408, 0xca8000f8, 0x76250000, 0x00000000, 0x72a14000, 0xce8000f8,
+ 0x80000038, 0xc0004914, 0xca0000f8, 0x7e412000, 0x00000000, 0x76250000, 0xce0000f8, 0x800000d0,
+ 0x6ef4a000, 0x6ed44000, 0x4755a000, 0x476da000, 0x5b747000, 0x5834002e, 0xc2400000, 0xca420078,
+ 0x00000000, 0xc2000000, 0x5a640002, 0xc6501078, 0xcd021078, 0x58340006, 0xca000078, 0x00000000,
+ 0x00000000, 0x5a200002, 0xce000078, 0xc0004910, 0xca4000f8, 0xc2000002, 0x6a2d0000, 0x72612000,
+ 0xce4000f8, 0xc2000002, 0x6a310000, 0xc000042a, 0xce0000f8, 0xc1040002, 0xd90c00f8, 0x00000000,
+ 0x8000eb20, 0x00000000, 0xc4980928, 0x9d000000, 0xc5580028, 0xc0000838, 0xcd8400f8, 0xc1440200,
+ 0xc1c03800, 0xc55c1070, 0xc000100e, 0x9d000000, 0xcd8000f8, 0xc000100c, 0xcdc000f8, 0xc0004862,
+ 0xc9c000f8, 0x00000000, 0x00000000, 0xd9d800f9, 0xc0007800, 0x401c0000, 0x5dc07a00, 0x88000012,
+ 0x5c000200, 0xcd8000f8, 0xc1f0000a, 0x715ca000, 0xdd9800f8, 0xdd9c00f9, 0x41d8e000, 0xc5d40260,
+ 0xc0001010, 0xcd4000f8, 0x6c9c8000, 0x45c8e000, 0x45c8e000, 0x59dc0004, 0xc1601260, 0xc5d40260,
+ 0x9d000000, 0xc0001012, 0xcd4000f8, 0x00000000, 0x00000000, 0xd95800f8, 0x6d586000, 0x4594c000,
+ 0x59984c80, 0xd99800f9, 0x5818000a, 0xc1800000, 0xc9800078, 0xc0006e00, 0x6d5ca000, 0x401c0000,
+ 0x40180000, 0xc94000f8, 0x58000002, 0x00000000, 0xc9c000f8, 0xc0004930, 0xcd4000f8, 0xc0004932,
+ 0xcdc000f8, 0x59980004, 0xc1c20020, 0xb59c0018, 0x00000000, 0xc1800000, 0xdd9c00f9, 0x581c000a,
+ 0xcd800078, 0x581c000c, 0xc1800000, 0xc9800020, 0xc1c00002, 0xdd9400f8, 0x69d4e000, 0x5d980002,
+ 0xcd800020, 0xc0004924, 0xc98000f8, 0x00000000, 0x9d000000, 0x00000000, 0x719cc000, 0xcd8000f8,
+ 0xc000492a, 0xc94000f8, 0xc1c00002, 0x69d8e000, 0x7dc0c000, 0x7558a000, 0xcd4000f8, 0xc000492c,
+ 0xc94000f8, 0xdd8000f9, 0x58000032, 0x755ca000, 0x84000090, 0xc94000f9, 0xc98000f8, 0xdd8000f9,
+ 0x5800000c, 0x00000000, 0xcd4000f9, 0xcd8000f8, 0xc000492c, 0xc94000f8, 0xc000492a, 0xc98000f8,
+ 0x715ca000, 0xc000492c, 0xcd4000f8, 0x719cc000, 0xc000492a, 0xcd8000f8, 0x9d000000, 0x00000000,
+ 0x00000000, 0x00000000, 0xc0004862, 0xc98000f8, 0x00000000, 0xc1c00200, 0x4194c000, 0x459ce000,
+ 0x88000012, 0xc5d800f8, 0xc0004862, 0xcd8000f8, 0xc0001406, 0xc98000f8, 0xc1c00002, 0x9d000000,
+ 0xc5d80a00, 0xc5581048, 0xcd8000f8, 0xc0004930, 0xc98000f8, 0xc0004932, 0xc9c000f8, 0xc140000e,
+ 0xc5581c18, 0xdd9400f8, 0xc0007800, 0x40140000, 0x5d407a00, 0x88000012, 0x5c000200, 0xcd8000f8,
+ 0x58000002, 0x5d407a00, 0x88000012, 0x5c000200, 0xcdc000f8, 0xdd5400f8, 0xc1c00000, 0x58140006,
+ 0xc9c20078, 0xc1800000, 0x58140000, 0xc98000d8, 0x6ddc2000, 0xc000491e, 0x41d8e000, 0xcdc000f8,
+ 0xdd9800f8, 0xc1c00022, 0xc5d80d70, 0xdd9400f9, 0xc5581c18, 0xc000491c, 0xcd8000f8, 0xdd5400f8,
+ 0xc1c00000, 0x58140006, 0xc9c20078, 0xc1800000, 0x58140004, 0xc9820078, 0x00000000, 0x59dc0002,
+ 0x45d8c000, 0x84000010, 0xc1c00000, 0x9d000000, 0x58140006, 0xc5d81078, 0xcd821078, 0xc0004860,
+ 0xc94000f8, 0xc1820080, 0xc1d00002, 0x58147700, 0xd58000f8, 0x58000002, 0xd58000f9, 0x59540004,
+ 0xb5580018, 0xc0004860, 0xc1400000, 0xcd4000f8, 0xdd9800f9, 0x9d000000, 0xdd9400f8, 0xc0001404,
+ 0xcdc10800, 0xc1c00000, 0xc1800200, 0x5d980004, 0xdf5d0048, 0x459ca000, 0x8800fff2, 0xdd8000f9,
+ 0x5800000c, 0x00000000, 0xc94000f9, 0xc98000f8, 0xc1c00002, 0xc5d43f00, 0xc5d81e00, 0xc0004862,
+ 0xc9c000f8, 0x00000000, 0x00000000, 0x581c7800, 0x5dc07a00, 0x88000012, 0x5c000200, 0xcd4000f8,
+ 0x58000002, 0x5dc07a00, 0x88000012, 0x5c000200, 0xcd8000f8, 0xc0004862, 0xc9c000f8, 0x00000000,
+ 0xc15004c0, 0xc5d40060, 0xdd9c00f8, 0xc5d41c18, 0xc1c00000, 0xdd8000f9, 0x58000030, 0xc9c00078,
+ 0xdd8000f9, 0x58000002, 0xc98000f8, 0x6ddc2000, 0xc000491c, 0x41d8e000, 0xcd4000f9, 0xcdc000f8,
+ 0xdd9400f9, 0xc1c00000, 0x58140030, 0xc9c00078, 0xc1800000, 0x58140006, 0xc9820078, 0x00000000,
+ 0x59dc0002, 0x45d8c000, 0x84000010, 0xc1c00000, 0x9d000000, 0x58140030, 0xc5d80078, 0xcd800078,
+ 0xc1c00000, 0xdf5c0038, 0x5ddc0080, 0x8400ffea, 0x00000000, 0x9d000000, 0x00000000, 0x00000000,
+ 0x00000000, 0xc160fffe, 0xc0000a10, 0xc9440060, 0xc1a0fffe, 0x59983008, 0xc000100c, 0xcd4000f8,
+ 0xc000100e, 0xcd8000f8, 0xc0004964, 0xc98000f8, 0x00000000, 0xc170000a, 0x7158a000, 0x6c988000,
+ 0x4588c000, 0x4588c000, 0x59980004, 0xc5940270, 0xc0001010, 0xcd4000f8, 0xc0004946, 0xc94000f8,
+ 0x00000000, 0x00000000, 0x6d58a000, 0x6d5c4000, 0x459cc000, 0x4594c000, 0xc000494a, 0xc94000f8,
+ 0xc0004948, 0xc9c000f8, 0x4194c000, 0xc1400012, 0xc55c1818, 0x9d000000, 0xc59c0268, 0xc0001012,
+ 0xcdc000f8, 0xc1400000, 0x58000012, 0xc9410038, 0xc0004950, 0xc9c000f8, 0xc55800f8, 0xc5940838,
+ 0xc5581078, 0xd99400f8, 0xc000493c, 0xc94000f8, 0xc0004954, 0xc98000f8, 0x59dc00a8, 0x45d4e000,
+ 0x41d8e000, 0x5d5c0030, 0x88000010, 0xc1c00030, 0xc1800000, 0xc5d84028, 0xc1400000, 0xc5d40008,
+ 0x5dd40002, 0x84000072, 0x5dd40004, 0x8400009a, 0x5dd40006, 0x840000c2, 0x5dd80026, 0x840000ea,
+ 0xdd5400f8, 0xdd8000f9, 0x58000008, 0x40180000, 0xcd4000f8, 0x59980002, 0x8000ffc0, 0xdd5400f8,
+ 0xdd8000f9, 0x58000008, 0x40180000, 0xcd4000b8, 0x59980002, 0x8000ff88, 0xdd5400f8, 0xdd8000f9,
+ 0x58000008, 0x40180000, 0xcd400078, 0x59980002, 0x8000ff50, 0xdd5400f8, 0xdd8000f9, 0x58000008,
+ 0x40180000, 0xcd400038, 0x59980002, 0x8000ff18, 0x00000000, 0x9d000000, 0x00000000, 0x00000000,
+ 0x00000000, 0x58000012, 0xc94000f8, 0xc0004954, 0xc9c000f8, 0xc0004950, 0xc9400078, 0xdd8000f9,
+ 0x58000028, 0x5d9c0000, 0x84000052, 0x5d9c0002, 0x84000052, 0x5d9c0004, 0x8400006a, 0xc55b0038,
+ 0xc55c08b8, 0xcd800039, 0xcdc108b8, 0x80000060, 0xcd4000f8, 0x80000050, 0xc55900b8, 0xc55c1838,
+ 0xcd8000b9, 0xcdc31838, 0x80000028, 0xc55a0078, 0xc55c1078, 0xcd800079, 0xcdc21078, 0x9d000000,
+ 0x00000000, 0x00000000, 0x00000000, 0x59540002, 0x6994e018, 0x61c0c008, 0x4194a000, 0x5d940040,
+ 0x88000012, 0xc59400f8, 0x9d000000, 0xcd4000f8, 0x00000000, 0x00000000, 0x9d000000, 0x4158a000,
+ 0xcd4000f8, 0x00000000,
+};
+
+static unsigned int firmware_binary_data[] = {
+};
+
+
+#endif  //  IFXMIPS_ATM_FW_AR9_H
diff --git a/drivers/atm/lantiq/ltqmips_atm_fw_ar9_retx.h b/drivers/atm/lantiq/ltqmips_atm_fw_ar9_retx.h
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/ltqmips_atm_fw_ar9_retx.h
@@ -0,0 +1,611 @@
+#ifndef IFXMIPS_ATM_FW_AR9_H
+#define IFXMIPS_ATM_FW_AR9_H
+
+
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_atm_fw_ar9.h
+** PROJECT      : UEIP
+** MODULES     	: ATM (ADSL)
+**
+** DATE         : 22 OCT 2007
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : ATM Driver (PP32 Firmware)
+** COPYRIGHT    : 	Copyright (c) 2006
+**			Infineon Technologies AG
+**			Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 22 OCT 2007  Xu Liang        Initiate Version, v00.01
+*******************************************************************************/
+
+
+#define VER_IN_FIRMWARE         1
+
+#define ATM_FW_VER_MAJOR        0
+#define ATM_FW_VER_MINOR        15
+
+
+static unsigned int firmware_binary_code[] = {
+    0x800004B8, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x8000FFE0, 0x00000000, 0x00000000, 0x00000000,
+    0xC1000002, 0xD90C00F8, 0xC2000002, 0xDA0800F9, 0xC0001B50, 0x8C100000, 0x00000000, 0x00000000,
+    0x00000000, 0xC2000000, 0xDA0800F9, 0x80006030, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x80006008, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0xC1001DA6, 0x8D3C0000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x80005F08, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0xC0400000, 0xC0004840, 0xC88400F8, 0xC2001AEE, 0x8E100000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0xC0400002, 0xC0004840, 0xC88400F8, 0xC2001AEE, 0x8E100000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0xC3C00004, 0xDBC800F9, 0xC10C0002, 0xD90C00F8, 0x8000FEE0, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0xC10E0002, 0xD90C00F8, 0xC0004808, 0xC84000F8, 0xC2001B4C, 0x8E100000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0xC3E1FFFE, 0x597DFFFE, 0x593DFE14, 0x900004D9, 0x00000000, 0x00000000, 0x00000000, 0x90CC0481,
+    0x00000000, 0x00000000, 0x00000000, 0xC3E0A252, 0x5BFC001E, 0xC0004002, 0xCFC000F8, 0xC3C00000,
+    0xDBC800F9, 0xC1400008, 0xC1900000, 0x71588000, 0x14100100, 0xC140000A, 0xC1900002, 0x71588000,
+    0x14100100, 0xC140000C, 0xC1900004, 0x71588000, 0x14100100, 0xC1400004, 0xC1900006, 0x71588000,
+    0x14100100, 0xC1400006, 0xC1900008, 0x71588000, 0x14100100, 0xC140000E, 0xC190000A, 0x71588000,
+    0x14100100, 0xC1400000, 0xC190000C, 0x71588000, 0x14100100, 0xC1400002, 0xC190000E, 0x71588000,
+    0x14100100, 0xC0400000, 0xC11C0000, 0xC000082C, 0xCD05CE00, 0xC11C0002, 0xC000082C, 0xCD05CE00,
+    0xC0400002, 0xC11C0000, 0xC000082C, 0xCD05CE00, 0xC0000824, 0x00000000, 0xCBC000F9, 0xCB8000F9,
+    0xCB4000F9, 0xCB0000F8, 0xC0004878, 0x5BFC4000, 0xCFC000F9, 0x5BB84000, 0xCF8000F9, 0x5B744000,
+    0xCF4000F9, 0x5B304000, 0xCF0000F8, 0xC0000A10, 0x00000000, 0xCBC000F9, 0xCB8000F8, 0xC0004874,
+    0x5BFC4000, 0xCFC000F9, 0x5BB84000, 0xCF8000F8, 0xC30001FE, 0xC000140A, 0xCF0000F8, 0xC3000000,
+    0x7F018000, 0xC000042E, 0xCF0000F8, 0xC000040E, 0xCF0000F8, 0xC3C1FFFE, 0xC000490E, 0xCFC00078,
+    0xC000492C, 0xCFC00078, 0xC0004924, 0xCFC00038, 0xC0004912, 0xCFC00038, 0xC0004966, 0xCFC00038,
+    0xC0004968, 0xCFC00078, 0xC000496A, 0xCFC00078, 0xC3C00000, 0xC2800020, 0xC3000000, 0x7F018000,
+    0x6FF88000, 0x6FD44000, 0x4395C000, 0x5BB84A00, 0x5838000A, 0xCF0000F8, 0x5BFC0002, 0xB7E8FFC8,
+    0x00000000, 0xC3C00000, 0xC2800010, 0x6FF86000, 0x47BDC000, 0x5BB84C80, 0xC3400000, 0x58380004,
+    0xCB420078, 0x00000000, 0x58380008, 0xCF400078, 0x5BFC0002, 0xB7E8FFB0, 0x00000000, 0xC3C00000,
+    0xC2800020, 0xC348001E, 0xC3000000, 0x7F018000, 0x6FF8A000, 0x6FD44000, 0x4795C000, 0x47BDC000,
+    0x5BB87000, 0x58380008, 0xCF408418, 0x5838000A, 0xCF0000F8, 0x5BFC0002, 0xB7E8FFB0, 0x00000000,
+    0x00000000, 0xC0004816, 0xC3C00000, 0xCBC00078, 0x00000000, 0x00000000, 0xC1000000, 0xD90400F9,
+    0xDBC40078, 0xC1000006, 0xD90400F9, 0x00000000, 0xC121FFFE, 0x5911FE54, 0x14100000, 0xC3C00000,
+    0xDCFC2000, 0x5FFC0002, 0x00000000, 0x98C08D62, 0xC0004730, 0xC94000F8, 0xC0004732, 0xC0001AF2,
+    0xCBC000F8, 0x00000000, 0x00000000, 0xA7C20470, 0xC000474A, 0xCA8000F8, 0x00000000, 0x00000000,
+    0x5D280000, 0x8400FFE0, 0x00000000, 0xC121FFFE, 0x5911FEF4, 0x14100000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0xC2802000, 0x6EA8E010, 0xC0004200, 0xC2400000, 0x7E410000, 0xC1000000, 0xCE4000F9, 0xCE4000F9,
+    0xCE4000F9, 0xCE4000F9, 0x5EA80002, 0x8400FFD8, 0xC0004300, 0xC2800200, 0x6EA84010, 0xCE4000F9,
+    0xCE0000F9, 0xCE4000F9, 0xCE0000F9, 0xCE4000F9, 0xCE0000F9, 0xCE4000F9, 0xCE0000F9, 0x5EA80002,
+    0x8400FFB8, 0xC0004700, 0xC2800200, 0x6EA8E010, 0xCE4000F9, 0xCE4000F9, 0xCE4000F9, 0xCE4000F9,
+    0x5EA80002, 0x8400FFD8, 0xC0004740, 0xCE4000F8, 0xC0004742, 0xC1000200, 0x5D100002, 0xCD0000F8,
+    0xC0004744, 0xCE4000F8, 0xC0004746, 0xCE4000F8, 0xC0004748, 0xCE4000F8, 0xC000474A, 0xCE4000F8,
+    0xC000474C, 0xC1000002, 0xCD0000F8, 0xC000474E, 0xCE4000F8, 0xC0004750, 0xCE4000F8, 0xC0004752,
+    0xCE4000F8, 0xC0004754, 0xCE4000F8, 0xC0400000, 0xC11C0000, 0xC000082C, 0xCD05CE00, 0xC0000838,
+    0xCE4000F8, 0xC0000818, 0xCE4000F8, 0xC0000820, 0xCE4000F8, 0xC2804840, 0xC240485A, 0x98C086B0,
+    0xC68000F8, 0xC65400F8, 0xC1800000, 0xC11C0002, 0xC000082C, 0xCD05CE00, 0x00000000, 0xC121FFFE,
+    0x5911FE54, 0x14100000, 0xC0000A10, 0xCB8000F8, 0xC0000A12, 0xCB4000F8, 0xC0000A14, 0xCB0000F8,
+    0xC0000A16, 0xCAC000F8, 0xC0000040, 0xC2800000, 0xCE800000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xC2800002,
+    0xCE800000, 0xC0000A10, 0xCF8000F8, 0xC0000A12, 0xCF4000F8, 0xC0000A14, 0xCF0000F8, 0xC0000A16,
+    0xCEC000F8, 0xC1000000, 0xC00048A0, 0xCD0000F8, 0xC00048A2, 0xCD0000F8, 0xC0001AF2, 0xC1000000,
+    0xCD002100, 0x80001038, 0x00000000, 0xC3C00000, 0xDCFC2000, 0x5FFC0002, 0x00000000, 0x98C08D62,
+    0xC0004730, 0xC94000F8, 0xC0004732, 0x800033D8, 0x00000000, 0xC3C00000, 0xDCFC2000, 0x5FFC0002,
+    0x00000000, 0x98C08D62, 0xC0004730, 0xC94000F8, 0xC0004732, 0xC0004810, 0xC90000F8, 0xC000474A,
+    0xC94000F8, 0xA50007E8, 0x00000000, 0x5D140002, 0x840007D2, 0xC1000000, 0xC000484A, 0xC90000F8,
+    0xC0004740, 0xC84000F8, 0x5D100000, 0x84000798, 0x00000000, 0x00000000, 0xC121FFFE, 0x5911FEF4,
+    0x14100000, 0xC0004744, 0xC88000F8, 0xC0001AF0, 0xC3000000, 0x58000002, 0xCB010038, 0x6C7C2000,
+    0x5BFC4300, 0x98C08A88, 0xC1400000, 0xC4540020, 0x6C40A010, 0x5D240002, 0x8400021A, 0x00000000,
+    0xC0004742, 0xCA8000F8, 0x00000000, 0x00000000, 0x59280002, 0x6D130000, 0x6D130010, 0x45048000,
+    0x84000692, 0x00000000, 0x98C08870, 0xC45400F8, 0xC69800F8, 0xC241FFFE, 0xC67400F8, 0x5D35FFFE,
+    0x84000652, 0x47448000, 0x84000642, 0xC1000000, 0x6F502000, 0xC0004300, 0x40100000, 0xC1400000,
+    0x58000000, 0xC9410038, 0xC1800000, 0xC0004814, 0xC9820038, 0x4714A000, 0xC10001FE, 0x4150A004,
+    0x45588000, 0x880005CA, 0x4744C000, 0xC1000200, 0x4190C004, 0xC000473E, 0xC90000F8, 0x00000000,
+    0x00000000, 0x41188000, 0xCD0000F8, 0xC000471C, 0xC90000F8, 0x00000000, 0x00000000, 0x41188000,
+    0xCD0000F8, 0x98C087E8, 0xC45400F8, 0x6C58A010, 0xC0004700, 0x58440002, 0x6C470000, 0x6C470010,
+    0x44748000, 0x8400FFC0, 0xC74400F8, 0xC0004740, 0xCC4000F8, 0xC0800000, 0xC0004744, 0xCC8000F8,
+    0x800004D0, 0xC1000000, 0x583C0000, 0xC9000038, 0x00000000, 0x00000000, 0x44908000, 0x88000280,
+    0xC1400000, 0x583C0000, 0xC9410038, 0xC1800000, 0xC0004814, 0xC9800038, 0x4714A000, 0xC10001FE,
+    0x4150A004, 0x45588000, 0x88000442, 0xC3800000, 0x583C0002, 0xCB820078, 0xC1000000, 0x583C0002,
+    0xC9000078, 0x00000000, 0x00000000, 0x47908000, 0x8400024A, 0xC0400002, 0xC0800000, 0xC3C00000,
+    0xC000481A, 0xC80000F8, 0x6F908000, 0x45388000, 0x45388000, 0x4011E000, 0xC000491E, 0xCFC000F8,
+    0xC3400000, 0xC0004878, 0xC80400F8, 0x6C908000, 0x45088000, 0x45088000, 0x40100000, 0xCAC000F8,
+    0xC43000F8, 0x00000000, 0xC7340060, 0xC1000002, 0xC5341B00, 0xC100001C, 0xC5341048, 0xC100000C,
+    0xC5340D10, 0xC000491C, 0xCF4000F8, 0xC3000000, 0xDF700038, 0x5D300080, 0x8800FFE8, 0xC000474A,
+    0xC1000002, 0xCD0000F8, 0xC000491C, 0xCB4000F8, 0xC000491E, 0xCBC000F8, 0x99007F18, 0xDB5800F8,
+    0xDBD800F9, 0x00000000, 0xC1400000, 0xC794A030, 0xC1800000, 0xC7980020, 0x58144200, 0xC9C000F8,
+    0xC1210000, 0x69188010, 0x7D008000, 0x75D0E000, 0xCDC000F8, 0x80000228, 0x00000000, 0xC1000000,
+    0x583C0000, 0xC903E000, 0x00000000, 0x00000000, 0x5D100000, 0x84000042, 0xC0004734, 0xC90000F8,
+    0x00000000, 0x00000000, 0x59100002, 0xCD0000F8, 0x800000C0, 0xC1400000, 0x583C0000, 0xC9410038,
+    0xC1800000, 0xC0004814, 0xC9820038, 0x4714A000, 0xC10001FE, 0x4150A004, 0x45588000, 0x8800015A,
+    0xC000473E, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8, 0xC000471C, 0xC90000F8,
+    0x00000000, 0x00000000, 0x59100002, 0xCD0000F8, 0xC3800000, 0x583C0002, 0xCB820078, 0x00000000,
+    0x00000000, 0x5D39FFFE, 0x84000062, 0xC1400000, 0xC794A030, 0xC1800000, 0xC7980020, 0x58144200,
+    0xC9C000F8, 0xC1210000, 0x69188010, 0x7D008000, 0x75D0E000, 0xCDC000F8, 0x98C087E8, 0xC45400F8,
+    0x6C58A010, 0xC0004700, 0x58440002, 0x6C470000, 0x6C470010, 0xC0004740, 0xCC4000F8, 0xC0800000,
+    0xC0004744, 0xCC8000F8, 0x00000000, 0xC121FFFE, 0x5911FE54, 0x14100000, 0x8000F288, 0x00000000,
+    0x00000000, 0x98C086F0, 0xC0004748, 0xC98000F8, 0xC2000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0xC1400000, 0xC7D4A030, 0xC1800000, 0xC7D80020, 0x58144200,
+    0xC9C000F8, 0xC1210000, 0x69188010, 0x7D008000, 0x75D0E000, 0xCDC000F8, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x98C087E8, 0xC7D400F8, 0x6FD8A010, 0xC0004700, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x98C08870, 0xC7D400F8, 0xC79800F8, 0xC241FFFE, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x98C08A88, 0xC1400000, 0xC7D40020, 0x6FC0A010,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x98C08AB8, 0xC1400000, 0xC7D40020, 0x6FC0A010,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x98C08AF0, 0xC7D400F8, 0xC0004740, 0xC9C000F8,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x98C08BE0, 0xC7D400F8, 0xC0004742, 0xC98000F8,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xC0004958, 0xC84000F8, 0x00000000, 0xC3C00002,
+    0x787C2000, 0xCC4000F8, 0xC0004848, 0xCB8400F8, 0xC000495C, 0xCAC400F8, 0xC0004844, 0xC88400F8,
+    0x47AD0000, 0x8400F492, 0xC000487C, 0xC80400F8, 0x00000000, 0x00000000, 0x40080000, 0xCA0000F8,
+    0xC0001624, 0xCB0400F8, 0xA63C007A, 0x00000000, 0x00000000, 0xA71EF432, 0x00000000, 0xC0000824,
+    0xCA8400F8, 0x6CA08000, 0x6CA42000, 0x46250000, 0x42290000, 0xC35E0002, 0xC6340060, 0xC0001624,
+    0xCF440078, 0xC2000000, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0xC0004844, 0xC88400F8, 0xC000082C, 0xCA040038, 0x00000000, 0x00000000, 0x58880002,
+    0xB6080018, 0x00000000, 0xC0800000, 0xC0004844, 0xCC840038, 0x5AEC0002, 0xC000495C, 0xCEC400F8,
+    0x5E6C0006, 0x84000060, 0xC0004848, 0xCB8400F8, 0xC0000838, 0xC2500002, 0xCE450800, 0x5FB80002,
+    0xC0004848, 0xCF8400F8, 0x5EEC0002, 0xC000495C, 0xCEC400F8, 0x00000000, 0xC121FFFE, 0x5911FE54,
+    0x14100000, 0x8000F290, 0xC000495A, 0xC84000F8, 0x00000000, 0xC3C00002, 0x787C2000, 0xCC4000F8,
+    0xC0004960, 0xCAC400F8, 0x00000000, 0x00000000, 0x5EEC0000, 0x8400010A, 0x00000000, 0xB6FC0050,
+    0xC0001600, 0xCA0400F8, 0x00000000, 0x00000000, 0xA61E00D2, 0x6FE90000, 0xC0000A28, 0xCE850800,
+    0xC2C00000, 0xC2800004, 0xB6E800A0, 0xC0001604, 0xCA8400F8, 0xC0004960, 0xCEC400F8, 0xA69EFCAA,
+    0x00000000, 0x6FE90000, 0xC0000A28, 0xCE850800, 0xC2C00002, 0xC0001600, 0xCA0400F8, 0x00000000,
+    0x00000000, 0xA61E002A, 0x6FE90000, 0xC0000A28, 0xCE850800, 0xC2C00000, 0xC0001604, 0xCA8400F8,
+    0xC0004960, 0xCEC400F8, 0xA69EFC12, 0xC2400000, 0xC0000A14, 0xCA440028, 0x00000000, 0x00000000,
+    0x466D2000, 0xA4400020, 0xC2800000, 0xDFEB0029, 0x80000010, 0xDFEA0029, 0xB668EC0A, 0x00000000,
+    0xC00048A0, 0xCB0400F8, 0xC0000A10, 0xCA8400F8, 0x6F208000, 0x6F242000, 0x46250000, 0x42A10000,
+    0xC2400000, 0xC0000A14, 0xCA440028, 0xC35E0002, 0xC6340060, 0xC0001604, 0xCF440078, 0x5B300002,
+    0xB6700018, 0x5AEC0002, 0xC3000000, 0xC00048A0, 0xCF0400F8, 0xC0004960, 0xCEC400F8, 0x8000F030,
+    0xC0004918, 0xD28000F8, 0xC2000000, 0xDF600038, 0x5E600080, 0x840002A2, 0x00000000, 0xC161FFFE,
+    0x5955FFFE, 0x14140000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xC000480A, 0xCA0000F8,
+    0xC0004912, 0xCA4000F8, 0xC0004924, 0xCA8000F8, 0xC0004966, 0xCAC000F8, 0x00000000, 0xC121FFFE,
+    0x5911FE54, 0x14100000, 0x76250000, 0x76290000, 0x762D0000, 0x840001E2, 0xC0004918, 0xCA4000F8,
+    0xC28001FE, 0x76290000, 0x5A640002, 0x6A254010, 0x5EE80000, 0x8400001A, 0x6AA54000, 0x80000010,
+    0xC62800F8, 0x62818008, 0xC0004918, 0xCF0000F8, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0xC0004966, 0xCA4000F8, 0xC2000002, 0x6A310000, 0x7E010000,
+    0x76612000, 0xCE4000F8, 0x00000000, 0xC121FFFE, 0x5911FE54, 0x14100000, 0x6F346000, 0x4771A000,
+    0x5B744C80, 0xC2800000, 0x58340006, 0xCA800078, 0xC2C00000, 0x58340000, 0xCAC000D8, 0xC2400000,
+    0x5834000A, 0xCA420078, 0x6EA82000, 0x42E9E000, 0x6F2CA000, 0x42E56000, 0x5AEC2E00, 0xC3990040,
+    0xC7381C18, 0xC6F80060, 0x99007F18, 0xDB9800F8, 0xDBD800F9, 0x00000000, 0xDEA000F8, 0x46310000,
+    0x8400FD50, 0xC0004958, 0xC84000F8, 0x00000000, 0xC1000002, 0x78502000, 0xCC4000F8, 0xC0004848,
+    0xCBC400F8, 0xC0004844, 0xC88400F8, 0x5FFC0000, 0x8400ECBA, 0xC0004740, 0xCB0000F8, 0xC0004744,
+    0xCAC000F8, 0x6F282000, 0x5AA84300, 0xC000487C, 0xC80400F8, 0x00000000, 0x00000000, 0x40080000,
+    0xCA4000F8, 0xC40000F8, 0x00000000, 0xC0004878, 0xC80400F8, 0x6C908000, 0x45088000, 0x45088000,
+    0x40100000, 0xC90000F8, 0xC43400F8, 0x00000000, 0x5C440000, 0x840000A2, 0x00000000, 0xC00047D2,
+    0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8, 0x58340002, 0xC9000078, 0x00000000,
+    0x00000000, 0x58280002, 0x6D120000, 0xCD021078, 0x5AEC0002, 0xC0004744, 0xCEC000F8, 0x80000630,
+    0x00000000, 0xC00047C0, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8, 0xA67C0048,
+    0xC00047C2, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8, 0x80001E18, 0x00000000,
+    0xA6600042, 0xC00047C4, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8, 0x80000570,
+    0xC00047C6, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8, 0xC3C00000, 0xC67D0038,
+    0xC3800000, 0xC6780038, 0x47F08000, 0x840000A8, 0x47AC8000, 0x84000098, 0xC1000000, 0xC0004814,
+    0xC9000038, 0x00000000, 0x00000000, 0x5D100000, 0x840000F0, 0x5AEC0002, 0xC0004744, 0xCEC000F8,
+    0xC00047CA, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8, 0x80000478, 0x00000000,
+    0x98C08AF0, 0xC7D400F8, 0xC0004740, 0xC9C000F8, 0x5D240000, 0x8400006A, 0x00000000, 0x98C087E8,
+    0xC7D400F8, 0x6FD8A010, 0xC0004700, 0xC00047C8, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002,
+    0xCD0000F8, 0x80001C40, 0xC00047CC, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8,
+    0x6FE82000, 0x5AA84300, 0x5D380000, 0x840000A0, 0x00000000, 0x98C086F0, 0xC0004748, 0xC98000F8,
+    0xC2000000, 0x58280002, 0x6E520000, 0xCD021078, 0x58280002, 0xCE400078, 0x5D25FFFE, 0x84000040,
+    0xC00047D0, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8, 0x800002D0, 0xC3000000,
+    0x58280002, 0xCB000078, 0x00000000, 0x00000000, 0x5D31FFFE, 0x84000048, 0xC00047D0, 0xC90000F8,
+    0x00000000, 0x00000000, 0x59100002, 0xCD0000F8, 0x80000260, 0x00000000, 0x98C086F0, 0xC0004748,
+    0xC98000F8, 0xC2000000, 0x58340002, 0xC6500078, 0xC7D01038, 0xC7901838, 0xCD0000F8, 0x58280002,
+    0xCE400078, 0xC3C00200, 0x5FFC001C, 0xC3800000, 0xDF790048, 0x00000000, 0x00000000, 0x47F88000,
+    0x8800FFDA, 0xC0004862, 0xCBC000F8, 0xC0000000, 0xC76C00F8, 0x5BBC7800, 0xC280001C, 0xCA6C00F9,
+    0x00000000, 0x00000000, 0xCE7800F9, 0xC1007A00, 0x45388000, 0xC1007800, 0xC53800FE, 0x5EA80002,
+    0x8400FFB8, 0xC3800000, 0xC000481A, 0xC80000F8, 0x6F108000, 0x45308000, 0x45308000, 0x4011C000,
+    0xC000491E, 0xCF8000F8, 0xC2C00000, 0xC7EC0060, 0xC100001C, 0xC52C1048, 0xC100000A, 0xC52C0D10,
+    0xC000491C, 0xCEC000F8, 0x99007CF0, 0xC000491C, 0xC1400000, 0xC9420048, 0xC2800000, 0xDF680038,
+    0x5D280080, 0x8800FFE8, 0xC000491C, 0xCAC000F8, 0xC000491E, 0xCB8000F8, 0x99007F18, 0xDAD800F8,
+    0xDB9800F9, 0x00000000, 0xC00047CE, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8,
+    0x00000000, 0x80001880, 0x00000000, 0x00000000, 0x00000000, 0xC0004878, 0xC80400F8, 0x6C908000,
+    0x45088000, 0x45088000, 0x40100000, 0xCA0000F8, 0xC42400F8, 0x00000000, 0xC0004934, 0xCE0000F8,
+    0xC2800002, 0xC4681C08, 0xC62821D0, 0xC6281E00, 0xC2600010, 0x5A650060, 0xC0004800, 0xCB4000F8,
+    0xC2200400, 0x5A200020, 0xC7601040, 0xC0001220, 0xCE8000F8, 0xC0001200, 0xCE4000F8, 0xC0001202,
+    0xCE0000F8, 0xC0001240, 0xCB4000F8, 0x00000000, 0x00000000, 0xA754FFE0, 0xC2000000, 0xC7600040,
+    0xA7520042, 0x00000000, 0x00000000, 0x99008690, 0xC0004822, 0xC94000F8, 0xC1800002, 0x80001710,
+    0x582040A0, 0xC2000000, 0xCA000018, 0xC2400000, 0xCA414000, 0xC2800000, 0xCA812000, 0xC2C00000,
+    0xCAC20018, 0xC0004938, 0xCE0000F8, 0xC0004920, 0xCE4000F8, 0xC0004916, 0xCE8000F8, 0xC0004922,
+    0xCEC000F8, 0xA6400558, 0x00000000, 0xC0004938, 0xCBC000F8, 0x00000000, 0xC3800000, 0x6FF48000,
+    0x6FD44000, 0x4355A000, 0x5B744A00, 0x58340000, 0xCB802010, 0x00000000, 0xC2000000, 0x6FB46000,
+    0x4779A000, 0x5B744C80, 0x5834000C, 0xCA000020, 0xC000491A, 0xCF8000F8, 0x5E200000, 0x84000482,
+    0xC2000000, 0xDF610048, 0x5E6001E8, 0x8800FFE8, 0xC2000002, 0xC2400466, 0xC2A00000, 0x5AA80000,
+    0xC0001006, 0xCE0000F8, 0xC0001008, 0xCE4000F8, 0xC000100A, 0xCE8000F8, 0x99007958, 0xC1A0FFFE,
+    0xC0000824, 0xC9840060, 0xC0004934, 0xCA4000F8, 0xC2000000, 0xC2800002, 0x99007998, 0xDA9800F8,
+    0xC61400F8, 0xC65800F8, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x99007A80, 0xC000491A, 0xC94000F8, 0x00000000, 0x00000000, 0xC121FFFE, 0x5911FE54,
+    0x14100000, 0xC0004922, 0xCA001118, 0xC3C00000, 0xC3800000, 0xC0004930, 0xCE023118, 0xC0004932,
+    0xCBC000D8, 0xC2800000, 0xC000491E, 0xCFC000F8, 0xC0004862, 0xCA800060, 0xC3A0001A, 0x5BB94000,
+    0xC6B80060, 0xC000491C, 0xCF8000F8, 0x99007CF0, 0xC000491C, 0xC1400000, 0xC9420048, 0x00000000,
+    0x00000000, 0x00000000, 0xA8E2FFE8, 0xC2000000, 0xC1220002, 0xD90C00F8, 0xDF600038, 0x5E600080,
+    0x8400FFF2, 0xC000491C, 0xCA0000F8, 0xC000491E, 0xCA4000F8, 0x00000000, 0x00000000, 0x99007F18,
+    0xDA1800F8, 0xDA5800F9, 0x00000000, 0xC2000000, 0xDF610048, 0x5E6001FE, 0x8800FFE8, 0xC0004916,
+    0xCA8000F8, 0xC2C00000, 0xDFEC0048, 0xC2400000, 0x466D2000, 0x8400004A, 0x5EA80000, 0x8400003A,
+    0xC2600002, 0x99008690, 0xC000482E, 0xC94000F8, 0xC1800002, 0x80000030, 0xC2600000, 0x99008690,
+    0xC000482C, 0xC94000F8, 0xC1800002, 0xC2000068, 0xC6240078, 0xC0004930, 0xCE400080, 0xC000491A,
+    0xC98000F8, 0xC0004862, 0xC94000F8, 0x6D9C6000, 0x45D8E000, 0x59DC4C80, 0x99007D78, 0xD95800F8,
+    0xD99800F9, 0xD9D400F8, 0x99007CF0, 0xC000491C, 0xC1400000, 0xC9420048, 0xC2000000, 0xDF600038,
+    0x5E600080, 0x8400FFEA, 0x00000000, 0xC000491C, 0xCA0000F8, 0xC000491E, 0xCA4000F8, 0x00000000,
+    0x00000000, 0x99007F18, 0xDA1800F8, 0xDA5800F9, 0x00000000, 0x80001160, 0x00000000, 0x99008690,
+    0xC000482A, 0xC94000F8, 0xC1800002, 0x80001130, 0xC0004938, 0xCBC000F8, 0x00000000, 0x00000000,
+    0x6FF88000, 0x6FD44000, 0x4395C000, 0x5BB84A00, 0x58380008, 0xCA0000F8, 0x00000000, 0x00000000,
+    0xA600039A, 0x00000000, 0xC0004938, 0xCBC000F8, 0xC3000000, 0x00000000, 0x6FF88000, 0x6FD44000,
+    0x4395C000, 0x5BB84A00, 0x58380000, 0xCB002010, 0xC2000000, 0x58380008, 0xCA020078, 0x5838000C,
+    0xCAC000F8, 0x5838000E, 0xCA4000F8, 0xC000491A, 0xCF0000F8, 0xC0004930, 0xCEC000F8, 0xC000493C,
+    0xCE0000F8, 0xC0004932, 0xCE4000F8, 0x5E200000, 0x84000138, 0xC2800000, 0xA6FE00D2, 0x6F206000,
+    0x46310000, 0x5A204C80, 0x5820000C, 0xCA800020, 0x00000000, 0x00000000, 0x5EA80000, 0x8400020A,
+    0x00000000, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x99007A80, 0xC000491A, 0xC94000F8, 0x00000000, 0x00000000, 0xC121FFFE, 0x5911FE54, 0x14100000,
+    0xC0004930, 0xCAC000F8, 0xC0004932, 0xCA4000F8, 0xC7EC1118, 0xC0004930, 0xCEC000F8, 0x5838000C,
+    0xCEC000F8, 0x58000002, 0xCE4000F8, 0xC0004934, 0xCA0000F8, 0xC2400002, 0x6E642000, 0x6E642000,
+    0x76612000, 0x8400002A, 0xC2400002, 0x6E684000, 0x58380008, 0xCE804200, 0xA6000020, 0x6E682000,
+    0x58380008, 0xCE802100, 0xC2400002, 0x6E642000, 0x76612000, 0x840000EA, 0x58380008, 0xCA0000F8,
+    0xC2800000, 0xC2400000, 0xA60200C0, 0xDBA800F8, 0x6F386000, 0x47B1C000, 0x5BB84C80, 0x58380004,
+    0xCA400078, 0x58380002, 0xCA800078, 0x00000000, 0xDEB800F8, 0x46A54000, 0x88000060, 0x00000000,
+    0xC0004824, 0xCA0000F8, 0xC2400002, 0x6E640000, 0x5A200002, 0xCE0000F8, 0x58380008, 0xCE400000,
+    0x80000018, 0x00000000, 0x80000048, 0xC0004934, 0xCA0000F8, 0x00000000, 0x00000000, 0xA6020CCA,
+    0x00000000, 0x00000000, 0x80000CF8, 0xC2800000, 0xC2000200, 0xC240001A, 0xDF690048, 0x46294000,
+    0x46A54000, 0x8800FFD2, 0xC2000006, 0xC2600982, 0x5A643B6E, 0x5838000A, 0xCA8000F8, 0xC0001006,
+    0xCE0000F8, 0xC0001008, 0xCE4000F8, 0xC000100A, 0xCE8000F8, 0x99007958, 0xC1A0FFFE, 0xC0000824,
+    0xC9840060, 0xC2000000, 0xC0004930, 0xCA02E008, 0x58380026, 0xCA4000F8, 0x00000000, 0xC2800000,
+    0x99007998, 0xDA9800F8, 0xC61400F8, 0xC65800F8, 0xC0004934, 0xCA0000F8, 0x00000000, 0x00000000,
+    0xA6020022, 0x00000000, 0x00000000, 0x80000318, 0xC0004938, 0xCBC000F8, 0xC0004878, 0xC80400F8,
+    0x6C908000, 0x45088000, 0x45088000, 0x40100000, 0xCA0000F8, 0xC42400F8, 0x00000000, 0x58240018,
+    0xCA0000F8, 0x6FF88000, 0x6FD44000, 0x4395C000, 0x5BB84A00, 0xC3000000, 0xC3400002, 0xC2C00000,
+    0xC62C0078, 0xC6270038, 0xC0004940, 0xCE400038, 0xC6260038, 0xC0004942, 0xCE400038, 0xC000493C,
+    0xCA0000F8, 0x5EEC0000, 0x8400018A, 0x5A6C0010, 0x46254000, 0x88000190, 0x5A600052, 0x46E54000,
+    0x88000178, 0x58380006, 0xCA8000F8, 0xC0004940, 0xCA0000F8, 0xC2400000, 0xC6A70038, 0x7E412000,
+    0x76612000, 0xC2000000, 0xC6A10038, 0x46250000, 0x84000138, 0xC0004942, 0xCA0000F8, 0xC2400000,
+    0xC6A60038, 0x7E412000, 0x76612000, 0xC2000000, 0xC6A00038, 0x58380002, 0xCA8000F8, 0x46250000,
+    0x840000E8, 0xC2400000, 0xC6A60078, 0x466D0000, 0x880000DA, 0xC2400000, 0xC6A40078, 0x58380008,
+    0xCA8000F8, 0x46E50000, 0x880000BA, 0x00000000, 0xA6820018, 0x00000000, 0xC7700B00, 0xA6840098,
+    0x00000000, 0xC7700A00, 0x80000080, 0xC7700200, 0xC000493C, 0xCAC000F8, 0x80000060, 0xC7700300,
+    0xC000493C, 0xCAC000F8, 0x80000040, 0xC7700900, 0x80000030, 0xC7700800, 0x80000020, 0xC7700700,
+    0x80000010, 0xC7700500, 0xC0004944, 0xCF0000F8, 0xC000493E, 0xCEC000F8, 0xC0004938, 0xCA4000F8,
+    0xC000493C, 0xCB8000F8, 0xC000493E, 0xCB4000F8, 0xC3000000, 0x6E608000, 0x6E544000, 0x42150000,
+    0x5A204A00, 0x5AA00008, 0x58200004, 0xCB000078, 0xC0004934, 0xCA0000F8, 0xC2400000, 0xC0004930,
+    0xCA42E008, 0xC3C00018, 0xA6020098, 0x00000000, 0x43656000, 0x47AD0000, 0x88000050, 0x46F96000,
+    0x6EE04010, 0x5BE00004, 0xC2000000, 0xC6E00008, 0x5E200000, 0x84000042, 0x5BFC0002, 0x80000030,
+    0xC3C00004, 0x5A2C0008, 0x47A10000, 0x88000012, 0x5FB80008, 0x6FE04000, 0x42390000, 0x47212000,
+    0x88000068, 0xC2400000, 0xC0004930, 0xCA42E008, 0xC2060002, 0xC68000F8, 0xCE006300, 0x6FE04000,
+    0x4721C000, 0x5F700010, 0x4765A000, 0xC2000000, 0xC6340008, 0xC25A000A, 0xC000491A, 0xCA401C18,
+    0xC2800000, 0xC0004932, 0xCA8000D8, 0xC0004862, 0xCA400060, 0x6FA04010, 0x42290000, 0xC000491E,
+    0xCE0000F8, 0xC7E41048, 0xC000491C, 0xCE4000F8, 0x6FE04000, 0x43A1C000, 0xC000493C, 0xCF8000F8,
+    0xC000493E, 0xCF4000F8, 0xC000493A, 0xCFC000F8, 0x80000008, 0x00000000, 0x00000000, 0x00000000,
+    0xC2000000, 0xDCE000F8, 0xA622FFD8, 0xC1220002, 0xD90C00F8, 0xC0004938, 0xCBC000F8, 0xC0004944,
+    0xCB4000F8, 0xC0004862, 0xCB0000F8, 0xC0004934, 0xCA0000F8, 0x6FF88000, 0x6FD44000, 0x4395C000,
+    0x5BB84A00, 0xA6020298, 0xC2400000, 0x58380008, 0xCA406000, 0xDFE800F8, 0xC2218E08, 0x5A21BAF6,
+    0x46A14000, 0x84000022, 0xC2080002, 0x7361A000, 0x80000058, 0x5E640000, 0x84000022, 0xC20C0002,
+    0x7361A000, 0x80000030, 0xC2000000, 0xC760E710, 0xC7604218, 0x5E200000, 0x840002A2, 0xC2200002,
+    0xC0004930, 0xCE021000, 0x99008690, 0xC0004828, 0xC94000F8, 0xC1800002, 0xC0004780, 0xC93C00F8,
+    0x00000000, 0x00000000, 0x59100002, 0xCD3C00F8, 0x58380000, 0xCA0000F8, 0x00000000, 0x00000000,
+    0xA6000132, 0xC0004940, 0xCA8000F8, 0xC0004942, 0xCA4000F8, 0xC7600078, 0xC6A01838, 0xC6601038,
+    0xC000493A, 0xCA4000F8, 0xC0004934, 0xCA8000F8, 0xC0007800, 0x40300000, 0x40240000, 0x5C000004,
+    0x5EC07A00, 0x88000012, 0x5C000200, 0xCE0000F8, 0x58000002, 0x5EC07A00, 0x88000012, 0x5C000200,
+    0xCE8000F8, 0xC000493E, 0xCA0000F8, 0xC2400000, 0x5838000C, 0xCE4000F8, 0x99008690, 0xC0004830,
+    0xC94000F8, 0xC61800F8, 0xC0004930, 0xC6100078, 0xCD000078, 0x800000A8, 0xC2400002, 0x58380008,
+    0xCE400000, 0xC0004944, 0xCF4000F8, 0x800002A8, 0xC000493C, 0xCA4000F8, 0xDFE800F8, 0x5A300018,
+    0xC0007800, 0x40200000, 0xCA0000F8, 0x58380008, 0xC6501078, 0xCD021078, 0x5838000A, 0xCE8000F8,
+    0x58380026, 0xCE0000F8, 0xC0004944, 0xCF4000F8, 0x99007CF0, 0xC000491C, 0xC1400000, 0xC9420048,
+    0x80000068, 0x00000000, 0x99008690, 0xC0004826, 0xC94000F8, 0xC1800002, 0xC0004760, 0xC93C00F8,
+    0x00000000, 0x00000000, 0x59100002, 0xCD3C00F8, 0x8000FDA8, 0xC2000000, 0xC2400080, 0xDF600038,
+    0xB624FFEA, 0xC000491C, 0xCA4000F8, 0xC000491E, 0xCA8000F8, 0x99007F18, 0xDA5800F8, 0xDA9800F9,
+    0x00000000, 0xC0004934, 0xCA0000F8, 0x00000000, 0xC2800000, 0xA6020160, 0xC2400004, 0xC2000200,
+    0xDF690048, 0x46294000, 0x46A54000, 0x8800FFDA, 0x00000000, 0xC000491A, 0xC98000F8, 0xC0004862,
+    0xC94000F8, 0x6D9C6000, 0x45D8E000, 0x59DC4C80, 0x99007D78, 0xD95800F8, 0xD99800F9, 0xD9D400F8,
+    0x99007CF0, 0xC000491C, 0xC1400000, 0xC9420048, 0xC2000000, 0xC2400080, 0xDF600038, 0xB624FFEA,
+    0xC000491C, 0xCA4000F8, 0xC000491E, 0xCA8000F8, 0x99007F18, 0xDA5800F8, 0xDA9800F9, 0x00000000,
+    0x58380008, 0xCA4000F8, 0xC2000000, 0xCE000018, 0xC2A1FFFE, 0x5AA9FFFE, 0xCE021078, 0x5838000A,
+    0xCE8000F8, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0xC0000838, 0xC2500002, 0xCE450800, 0xC0004848, 0xCBC400F8, 0xC3800000, 0xC000082C, 0xCB840028,
+    0x5FFC0002, 0xC0004848, 0xCFC400F8, 0x58880002, 0x47888000, 0xC1000000, 0xC50800FE, 0xC0004844,
+    0xCC8400F8, 0x00000000, 0xC121FFFE, 0x5911FE54, 0x14100000, 0x8000CBF0, 0xC2000000, 0xDF600038,
+    0x5E200080, 0x8400029A, 0x00000000, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0xC000480C, 0xCA0000F8, 0xC0004910, 0xCA4000F8, 0xC000492C, 0xCA8000F8,
+    0xC0004968, 0xCAC000F8, 0x00000000, 0xC121FFFE, 0x5911FE54, 0x14100000, 0x76250000, 0x76290000,
+    0x76E16000, 0x840001DA, 0xC0004926, 0xCA4000F8, 0xC201FFFE, 0x76E16000, 0x5A640002, 0x6AE50010,
+    0x5F200000, 0x8400001A, 0x6A250000, 0x80000010, 0xC6E000F8, 0x62014008, 0xC0004926, 0xCE8000F8,
+    0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xC0004968,
+    0xCA4000F8, 0xC2000002, 0x6A290000, 0x7E010000, 0x76612000, 0xCE4000F8, 0x00000000, 0xC121FFFE,
+    0x5911FE54, 0x14100000, 0x6EB4A000, 0x6E944000, 0x4755A000, 0x4769A000, 0x5B747000, 0x58340002,
+    0xC2000000, 0xCA0000D8, 0x5834002E, 0xC2400000, 0xCA400078, 0x6EB0A000, 0x6EBC4000, 0x473D8000,
+    0x47298000, 0x5B30302E, 0x5B300004, 0x6E642000, 0x4225E000, 0xC39A8024, 0xC7380060, 0xC6B81C18,
+    0x99007F18, 0xDB9800F8, 0xDBD800F9, 0x00000000, 0xC2000000, 0xDF600038, 0x5E200080, 0x840002D2,
+    0x00000000, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0xC000490E, 0xCA0000F8, 0xC000492A, 0xCA4000F8, 0xC000496A, 0xCB0000F8, 0xC0004956, 0xCAC000F8,
+    0x00000000, 0xC121FFFE, 0x5911FE54, 0x14100000, 0x77218000, 0x77258000, 0x8400021A, 0xC201FFFE,
+    0x77218000, 0x5AEC0002, 0x6B2D0010, 0x5EA00000, 0x8400001A, 0x6A2D0000, 0x80000010, 0xC72000F8,
+    0x62016008, 0xC0004956, 0xCEC000F8, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0xC000496A, 0xCA4000F8, 0xC2000002, 0x6A2D0000, 0x7E010000, 0x76612000,
+    0xCE4000F8, 0x00000000, 0xC121FFFE, 0x5911FE54, 0x14100000, 0x6EF4A000, 0x6ED44000, 0x4755A000,
+    0x476DA000, 0x5B747000, 0x5834000E, 0xC2000000, 0xCA0000D8, 0x58340008, 0xC2400000, 0xCA420078,
+    0x5834000C, 0xC2800000, 0xCA832010, 0x6E644010, 0x42250000, 0x4229E000, 0xC39A8008, 0x58340008,
+    0xCB809018, 0x58340008, 0xC2800000, 0xCA810010, 0x6EE0A000, 0x6EE44000, 0x46250000, 0x462D0000,
+    0x5A200008, 0x5A203008, 0x42290000, 0xC6380060, 0xC6F81C18, 0x99007F18, 0xDB9800F8, 0xDBD800F9,
+    0x00000000, 0xC000495A, 0xC84000F8, 0x00000000, 0xC3C00002, 0x787C2000, 0xCC4000F8, 0xC0001A1C,
+    0xCA0000F8, 0xC2400008, 0x6A452000, 0x76250000, 0x84000E9A, 0xC0000A28, 0xC3800000, 0xCB840028,
+    0xC0000A14, 0xC3400000, 0xCB440028, 0xC0004880, 0xCB0400F8, 0x47B48000, 0x88000E48, 0x58041802,
+    0xCAC000F8, 0xA7000060, 0x00000000, 0x00000000, 0xA6C8C5C8, 0xC2800000, 0xC6E80018, 0x80000070,
+    0x00000000, 0x00000000, 0x00000000, 0x8000C590, 0x00000000, 0xC2800000, 0xC7282018, 0xC000490E,
+    0xCA4000F8, 0x6BE9E000, 0x00000000, 0x767D2000, 0x8400C548, 0x6EA0A000, 0x6E944000, 0x46150000,
+    0x46290000, 0x5A207000, 0x5820000C, 0xCA0000F8, 0xC0004946, 0xCE8000F8, 0xA6220398, 0x00000000,
+    0xC2200060, 0xC0004948, 0xCE000008, 0xCE021038, 0xC240000A, 0xC000494A, 0xCE4000F8, 0xC2B60002,
+    0xC0004964, 0xCE837B00, 0x990081E8, 0xC00048A0, 0xC88400F8, 0x00000000, 0xC0004946, 0xCBC000F8,
+    0x00000000, 0x00000000, 0x6FF8A000, 0x6FD44000, 0x4795C000, 0x47BDC000, 0x5BB87000, 0x99007FA8,
+    0xDBD800F8, 0xDB9800F9, 0x00000000, 0x99007CF0, 0xC000491C, 0xC1400000, 0xC9420048, 0xC000491C,
+    0x990081A0, 0xC94000F9, 0xC98000F8, 0x00000000, 0x99007F18, 0xD95800F8, 0xD99800F9, 0x00000000,
+    0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x99007BE0,
+    0xDBD800F8, 0xDB9800F9, 0xC7D800F8, 0x00000000, 0xC121FFFE, 0x5911FE54, 0x14100000, 0x6FF8A000,
+    0x6FD44000, 0x4795C000, 0x47BDC000, 0x5BB87000, 0x58380010, 0xCA0000F8, 0xC0004874, 0xC80400F8,
+    0x6C908000, 0x45088000, 0x45088000, 0x40100000, 0xCA4000F8, 0xC43400F8, 0x00000000, 0xC74000F8,
+    0xCE0000F8, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0xC000490E, 0xCA4000F8, 0xC2800002, 0x6ABD4000, 0x72692000, 0xCE4000F8, 0x00000000, 0xC121FFFE,
+    0x5911FE54, 0x14100000, 0x99008690, 0xC0004836, 0xC94000F8, 0xC1800002, 0x00000000, 0x00000000,
+    0x00000000, 0xA8E2FFE8, 0x00000000, 0xC1220002, 0xD90C00F8, 0xC2000000, 0xC0000A14, 0xCA040028,
+    0xC0000A28, 0xC2500002, 0xCE450800, 0x58880002, 0xB6080018, 0xC00048A0, 0xC0800000, 0xCC8400F8,
+    0x8000C168, 0xC0004946, 0xCBC000F8, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0xC000490E, 0xCA4000F8, 0xC2800002, 0x6ABD4000, 0x72692000, 0xCE4000F8,
+    0x00000000, 0xC121FFFE, 0x5911FE54, 0x14100000, 0x6FF8A000, 0x6FD44000, 0x4795C000, 0x47BDC000,
+    0x5BB87000, 0x58380008, 0xCA0000F8, 0x5838000C, 0xCA4000F8, 0xC3400000, 0xC6340000, 0xC000494E,
+    0xCF4000F8, 0xC2800000, 0xC62A0078, 0xC3000000, 0xC6308018, 0x6F304000, 0x43298000, 0xC000493C,
+    0xCF0000F8, 0xC2C00000, 0xC66C0078, 0xC0004950, 0xCEC000F8, 0xC2800000, 0xC66AE020, 0xC0004954,
+    0xCE8000F8, 0x5F740000, 0x840001B8, 0x5E300028, 0x46E12000, 0x84000182, 0x46E12000, 0x8800014A,
+    0x5E300018, 0x46E12000, 0x8800002A, 0x46E12000, 0x84000042, 0x00000000, 0x800000D8, 0x00000000,
+    0x99008328, 0xDBD800F8, 0xDB9800F9, 0xC78000F8, 0xC3400002, 0xC000494E, 0xCF4000F8, 0xC161FFFE,
+    0x5955FFFE, 0x14140000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xC000490E, 0xCA4000F8,
+    0xC2800002, 0x6ABD4000, 0x7E814000, 0x76692000, 0xCE4000F8, 0x00000000, 0xC121FFFE, 0x5911FE54,
+    0x14100000, 0xC2200060, 0xC0004948, 0xCE021038, 0xC2000000, 0xC000494C, 0xCE0000F8, 0x80000080,
+    0x00000000, 0x99008328, 0xDBD800F8, 0xDB9800F9, 0xC78000F8, 0x99008528, 0xDBD800F8, 0xDB9800F9,
+    0xC78000F8, 0xC2200058, 0xC0004948, 0xCE021038, 0xC2000002, 0xC000494C, 0xCE0000F8, 0xC2000006,
+    0xC0001006, 0xCE0000F8, 0x5838000A, 0xCA4000F8, 0xC2200982, 0x5A203B6E, 0xC0001008, 0xCE0000F8,
+    0xC000100A, 0xCE4000F8, 0xC0004954, 0xCA8000F8, 0xC200000C, 0xC000494A, 0xCE0000F8, 0xC0004948,
+    0xCE800008, 0xC2B60000, 0xC0004964, 0xCE8000F8, 0x990081E8, 0xC00048A0, 0xC88400F8, 0x00000000,
+    0xC0004946, 0xCBC000F8, 0xC000494C, 0xCA0000F8, 0x6FF8A000, 0x6FD44000, 0x4795C000, 0x47BDC000,
+    0x5BB87000, 0x5E200000, 0x84000112, 0x00000000, 0x99007FA8, 0xDBD800F8, 0xDB9800F9, 0x00000000,
+    0x99007CF0, 0xC000491C, 0xC1400000, 0xC9420048, 0xC000491C, 0x990081A0, 0xC94000F9, 0xC98000F8,
+    0x00000000, 0x99007F18, 0xD95800F8, 0xD99800F9, 0x00000000, 0xC161FFFE, 0x5955FFFE, 0x14140000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x99007BE0, 0xDBD800F8, 0xDB9800F9, 0xC7D800F8,
+    0x00000000, 0xC121FFFE, 0x5911FE54, 0x14100000, 0xC000493C, 0xCA8000F8, 0xC000494E, 0xCAC000F8,
+    0xC3000018, 0xC3400006, 0x5E200000, 0x8400002A, 0xC2800000, 0xC2C00000, 0xC300001E, 0xC3400000,
+    0xC6AC1078, 0xC72C0418, 0xC76C0810, 0x58380010, 0xCA8000F8, 0x58380008, 0xCEC000F8, 0xC6280100,
+    0xC0004874, 0xC80400F8, 0x6C908000, 0x45088000, 0x45088000, 0x40100000, 0xCB0000F8, 0xC43400F8,
+    0x00000000, 0xC74000F8, 0xCE8000F8, 0xC0004952, 0xCE8000F8, 0x00000000, 0x00000000, 0x00000000,
+    0xA8E2FFE8, 0x00000000, 0xC000494C, 0xCA0000F8, 0xC0004950, 0xCAC000F8, 0x5E200000, 0x8400006A,
+    0xDFE800F8, 0x7E814000, 0x5834001A, 0xCE8000F8, 0x99008690, 0xC0004834, 0xC94000F8, 0xC1800002,
+    0x99008690, 0xC0004838, 0xC94000F8, 0xC6D800F8, 0xC1220002, 0xD90C00F8, 0x5E200000, 0x84000040,
+    0x5838002C, 0xCB0000F8, 0xDFE800F8, 0x00000000, 0x58380014, 0xCF0000F8, 0x80000018, 0xC2A1FFFE,
+    0x5AA9FFFE, 0x5838000A, 0xCE8000F8, 0xC3000000, 0xC0000A14, 0xCB040028, 0xC2D00002, 0xC0000A28,
+    0xCEC50800, 0xC000494E, 0xCA8000F8, 0x58880002, 0xB4B00018, 0xC00048A0, 0xC0800000, 0xCC8400F8,
+    0x5EA80000, 0x8400016A, 0x5E200000, 0x84000158, 0xC000493C, 0xCA8000F8, 0x00000000, 0x00000000,
+    0x5AA80060, 0xCE8000F8, 0x99008328, 0xDBD800F8, 0xDB9800F9, 0xC78000F8, 0x99008528, 0xDBD800F8,
+    0xDB9800F9, 0xC78000F8, 0xC0004952, 0xCAC000F8, 0x58380000, 0xCA8000F8, 0xC30C0002, 0xC7F00018,
+    0xA68000B0, 0x00000000, 0x00000000, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0xC0001800, 0xCA0000F8, 0x00000000, 0x00000000, 0xA60CFFEA, 0xC6F00500,
+    0xC6B0C400, 0xCF0000F8, 0x00000000, 0xC121FFFE, 0x5911FE54, 0x14100000, 0x8000B7B8, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x8000B750, 0xDCBC00F9, 0x5FFC0000, 0x8400095A, 0xC3800002,
+    0xDB8800F9, 0xC3800000, 0xDB8800F9, 0xC0004728, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002,
+    0xCD0000F8, 0xC0004730, 0xC98000F8, 0xC000472E, 0xC94000F8, 0xC00047DC, 0xC90000F8, 0xC00047DE,
+    0xC9C000F8, 0xC000472E, 0xCD8000F8, 0x6D110000, 0xC5D30038, 0xC00047DC, 0xCD0000F8, 0x4594A000,
+    0x6DDD0000, 0xC55C0038, 0xC00047DE, 0xCDC000F8, 0xC0001AC4, 0xC94000F8, 0xC0001AC8, 0xC98000F8,
+    0xC000472C, 0xC9C000F8, 0x45948000, 0xC1000002, 0x41D0E004, 0xCDC000F8, 0xC5501078, 0xC5900078,
+    0xC000472A, 0xCD0000F8, 0xC0001AF0, 0xCBC000F8, 0x58000002, 0xCB8000F8, 0xC3400000, 0xC7F50038,
+    0x6F702000, 0x5B304300, 0xC000474C, 0xCAC000F8, 0xC0004720, 0xC94000F8, 0x00000000, 0x00000000,
+    0x5D940002, 0x6D9B8000, 0x6D9B8010, 0x581847E0, 0xC98000F8, 0x581447E0, 0xC9C000F8, 0x5D2C0000,
+    0x8400007A, 0xC7901078, 0xC7D00078, 0xCD0000F8, 0xC1000000, 0xC5910038, 0x45348000, 0x84000090,
+    0xC0004722, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8, 0x80000058, 0xC1000000,
+    0xC5D10038, 0x45348000, 0x8400003A, 0xC0004724, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002,
+    0xCD0000F8, 0xA7840080, 0x59540002, 0x6D578000, 0x6D578010, 0xC0004720, 0xCD4000F8, 0xC1000000,
+    0xC5910038, 0x45348000, 0x84000038, 0xC0004726, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002,
+    0xCD0000F8, 0xA78000B8, 0xC2800002, 0xC000474E, 0xCE8000F8, 0xC2C00000, 0xC000474C, 0xCEC000F8,
+    0xC0004758, 0xCFC000F8, 0x58000002, 0xCF8000F8, 0xC000475C, 0xC90000F8, 0x00000000, 0x00000000,
+    0xA53E003A, 0x00000000, 0xC13E0002, 0xCFC000F8, 0xCD03DE08, 0x58000002, 0xCF8000F8, 0x800001A0,
+    0xC000475C, 0xC13C0002, 0xCD03DE08, 0x5D2C0000, 0x8400017A, 0xC2C00000, 0xC000474C, 0xCEC000F8,
+    0x98C08AF0, 0xC75400F8, 0xC0004740, 0xC9C000F8, 0x5D240000, 0x84000042, 0xC1000002, 0xC0004750,
+    0xCD0000F8, 0xC0004752, 0xCD0000F8, 0x80000100, 0x00000000, 0x98C08BE0, 0xC75400F8, 0xC0004742,
+    0xC98000F8, 0x5D240000, 0x8400002A, 0xC1000002, 0xC0004752, 0xCD0000F8, 0x80000060, 0xC0004742,
+    0xC94000F8, 0xC0004754, 0xC1000002, 0xCD0000F8, 0x98C08CF0, 0xC55400F8, 0xC75800F8, 0x00000000,
+    0xC0004742, 0xCF4000F8, 0x98C08AB8, 0xC1400000, 0xC7540020, 0x6F40A010, 0xC1000000, 0xC7D00038,
+    0x58300000, 0x6D110000, 0xCD010838, 0xA7840398, 0xC000474C, 0xCAC000F8, 0xC000474E, 0xCA8000F8,
+    0xC0004750, 0xCBC000F8, 0xC0004752, 0xCB8000F8, 0xC0004710, 0xC90000F8, 0x00000000, 0x00000000,
+    0x59100002, 0xCD0000F8, 0x5D280002, 0x840000B8, 0xC000473C, 0xC90000F8, 0x00000000, 0x00000000,
+    0x59100002, 0xCD0000F8, 0xC0004712, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8,
+    0xC0004754, 0xC90000F8, 0x00000000, 0x00000000, 0x5D100000, 0x8400021A, 0x58300000, 0xC13C0002,
+    0xCD03DE00, 0x800001F8, 0xC0004714, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8,
+    0x5D380000, 0x8400003A, 0xC0004736, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8,
+    0x5D3C0000, 0x84000042, 0xC0004718, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8,
+    0x80000140, 0xC1000000, 0x58300000, 0xC903E000, 0x00000000, 0x00000000, 0x5D100000, 0x84000042,
+    0xC000471A, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8, 0x800000D0, 0x58300000,
+    0xC13E0002, 0xCD03FF00, 0xC1000000, 0x58300000, 0xC903C000, 0x00000000, 0x00000000, 0x5D100000,
+    0x84000082, 0xC0004716, 0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8, 0xC000473A,
+    0xC90000F8, 0x00000000, 0x00000000, 0x59100002, 0xCD0000F8, 0x58300000, 0xC13C0000, 0xCD03DE00,
+    0xC1000000, 0xC0004746, 0xCD0000F8, 0xC0004750, 0xCD0000F8, 0xC0004752, 0xCD0000F8, 0xC000474E,
+    0xCD0000F8, 0xC2C00002, 0xC000474C, 0xCEC000F8, 0xC0004754, 0xCD0000F8, 0xC3CE0002, 0xC0000800,
+    0xCFC0E700, 0xC3E1FFFE, 0x597DFFFE, 0x593DFE14, 0x94000001, 0x00000000, 0x00000000, 0x00000000,
+    0xC000487C, 0xC80400F8, 0x00000000, 0x00000000, 0x40080000, 0xCBC000F8, 0xC43800F8, 0x00000000,
+    0xC000480E, 0xCA0000F8, 0xC0004858, 0xCB4400F8, 0x00000000, 0x00000000, 0x47610000, 0x880000B0,
+    0x00000000, 0xA7C00048, 0xC0004854, 0xC1000002, 0xCD0400F8, 0xC11C0000, 0xC000082C, 0xCD05CE00,
+    0x800000D8, 0x00000000, 0xA7D20138, 0x00000000, 0xC7E14040, 0xC2400000, 0xC6246028, 0xC200006A,
+    0x46250000, 0xC6240030, 0xC0000810, 0xCE440030, 0x8000FF70, 0xC2000000, 0xC0000808, 0xCA040010,
+    0xC11C0000, 0xC000082C, 0xCD05CE00, 0x5A200002, 0x5E600010, 0x84000010, 0xC2000000, 0xC0000808,
+    0xCE040010, 0xC3400000, 0x80000028, 0xC1200002, 0xC0000818, 0xCD061000, 0x5B740002, 0xC0004858,
+    0xCF4400F8, 0x99007930, 0xC0004848, 0xC94400F8, 0xC1800000, 0xC11C0002, 0xC000082C, 0xCD05CE00,
+    0x80000878, 0x5B740002, 0xC0004858, 0xCF4400F8, 0xC78000F8, 0xC13C0002, 0xCD03DE00, 0xC0004848,
+    0xC94400F8, 0xC1800000, 0xC000082C, 0xC9840028, 0x59540002, 0xC0004848, 0xCD4400F8, 0x58880002,
+    0xB49807F8, 0x00000000, 0xC0800000, 0x800007E0, 0xC000487C, 0xC80400F8, 0x00000000, 0x00000000,
+    0x40080000, 0xCBC000F8, 0xC42800F8, 0x00000000, 0xA7C00130, 0xC000484C, 0xCA0400F8, 0xC2400000,
+    0xC0001AEC, 0xCA440018, 0x5A200002, 0xC000484C, 0xCE0400F8, 0xB624008A, 0xC68000F8, 0xC13C0002,
+    0xCD03DE00, 0xC0004848, 0xC94400F8, 0xC1800000, 0xC000082C, 0xC9840028, 0x59540002, 0xC0004848,
+    0xCD4400F8, 0x58880002, 0xB49806E8, 0x00000000, 0xC0800000, 0x800006D0, 0xC0004854, 0xC1000004,
+    0xCD0400F8, 0xC0000820, 0xC2000002, 0xCE0400F8, 0xC2000000, 0xC000484C, 0xCE0400F8, 0xC0004858,
+    0xCE0400F8, 0x8000FF28, 0xC0004854, 0xC1000000, 0xCD0400F8, 0xC11C0000, 0xC000082C, 0xCD05CE00,
+    0x99007930, 0xC0004848, 0xC94400F8, 0xC1800000, 0xC1200000, 0xC0000818, 0xCD061000, 0xC11C0002,
+    0xC000082C, 0xCD05CE00, 0xC2000000, 0xC000484C, 0xCE0400F8, 0x800005D0, 0xC0001AC0, 0xCB8400F8,
+    0xC000487C, 0xC80400F8, 0x00000000, 0x00000000, 0x40080000, 0xCBC000F8, 0xC42800F8, 0x00000000,
+    0xA78004E2, 0x00000000, 0x00000000, 0xA7C004A2, 0x00000000, 0xC0001B00, 0xC2060006, 0xCE046308,
+    0xA7E8045A, 0x00000000, 0xC0004850, 0xCA0400F8, 0xC2400000, 0xC0004812, 0xCA420078, 0x5A200002,
+    0xC0004850, 0xCE0400F8, 0x5E640000, 0x8400001A, 0x46250000, 0x880002F8, 0xC68000F8, 0xC13C0002,
+    0xCD03DE00, 0xC0001ACC, 0xC2000002, 0xCE040000, 0x5C440000, 0x84000250, 0xC0004810, 0xC94000F8,
+    0xC68000F8, 0xCBC000F8, 0x00000000, 0xC1000000, 0xA5400208, 0xC53C1000, 0x00000000, 0xA7FC01F2,
+    0xC0001AF0, 0xC1000000, 0x58000002, 0xC9000000, 0xC000474E, 0xC98000F8, 0x5D100000, 0x84000022,
+    0xC1000002, 0xC53C1E00, 0x80000198, 0x5D180000, 0x84000022, 0xC1000002, 0xC53C1E00, 0x80000170,
+    0xC0004878, 0xC80400F8, 0x6C908000, 0x45088000, 0x45088000, 0x40100000, 0xC98000F8, 0xC43800F8,
+    0x00000000, 0xC000481E, 0xC9C000F8, 0xC000481C, 0xCA0000F8, 0x00000000, 0x759CC000, 0x45A08000,
+    0x840000E8, 0xC0001AF0, 0xC3400000, 0x58000000, 0xCB410038, 0xC0004746, 0xC94000F8, 0x6F702000,
+    0x5B304300, 0xC2C00000, 0x58300000, 0xCAC00038, 0x00000000, 0x00000000, 0x456C8000, 0x88000020,
+    0xC1000002, 0xC53C1E00, 0x80000040, 0x5AEC0002, 0x58300000, 0xCEC00038, 0xC1000002, 0xC53C1000,
+    0xC77C0838, 0xC57C0038, 0x59540002, 0xC0004746, 0xCD4000F8, 0xC68000F8, 0xCFC000F8, 0xC0004848,
+    0xC94400F8, 0xC1800000, 0xC000082C, 0xC9840028, 0x59540002, 0xC0004848, 0xCD4400F8, 0x58880002,
+    0xB49801F8, 0x00000000, 0xC0800000, 0x800001E0, 0xC000471E, 0xC90000F8, 0x00000000, 0x00000000,
+    0x59100002, 0xCD0000F8, 0xC0004854, 0xC1000000, 0xCD0400F8, 0xC11C0000, 0xC000082C, 0xCD05CE00,
+    0x99007930, 0xC0004848, 0xC94400F8, 0xC1800000, 0xC2000000, 0xC0000820, 0xCE0400F8, 0xC1200000,
+    0xC0000818, 0xCD061000, 0xC11C0002, 0xC000082C, 0xCD05CE00, 0xC0004850, 0xCE0400F8, 0xC2000002,
+    0xC0001ACC, 0xCE040008, 0x800000E8, 0xC2000002, 0xC0004850, 0xCE0400F8, 0x8000FC00, 0xC2000000,
+    0xC0004850, 0xCE0400F8, 0xA7E60032, 0x00000000, 0xC2000002, 0xC0001B00, 0xCE040000, 0x8000FBE8,
+    0x00000000, 0xA7860052, 0x00000000, 0xC68000F8, 0xC13C0002, 0xCD03DE00, 0xC2020002, 0xC7E2A540,
+    0xC0001B00, 0xCE0400F8, 0x8000FB90, 0xC2040002, 0xC0001B00, 0xCE044200, 0x8000FB70, 0xC2C80002,
+    0x6AC56000, 0xDACC00F8, 0xC0004854, 0xCB4400F8, 0xC0004848, 0xCB8400F8, 0xC0000838, 0xC3C00000,
+    0xCBC40028, 0x5EF40004, 0x84000022, 0xC3000000, 0xC0001ACC, 0xCF042100, 0x47F98000, 0x8400004A,
+    0x47F98000, 0x88000050, 0xC1006E8C, 0xC1400010, 0x8D580000, 0x00000000, 0x00000000, 0x00000000,
+    0xC0004840, 0xCC8400F8, 0x8000EB10, 0xC0001AC0, 0xCAC400F8, 0xC0004854, 0xCB4400F8, 0xA6C0F93A,
+    0x00000000, 0x5EF40000, 0x8400F472, 0x5EF40002, 0x8400F702, 0x5EF40004, 0x8400F902, 0xC1006CE8,
+    0xC1400010, 0x8D580000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xC0800000, 0xDF4B0038,
+    0xC0004900, 0xCB8000F8, 0xC2000000, 0xC000490A, 0xA78000D0, 0xCBC000F8, 0xC1000000, 0xD90000F9,
+    0xC1000002, 0xD90C00F8, 0x6FF46000, 0x477DA000, 0x5B744C80, 0xC2400000, 0x58340004, 0xCA400078,
+    0xC0004900, 0xCE000000, 0x5A640002, 0x58340004, 0xC6500078, 0xCD000078, 0xC0004914, 0xCA4000F8,
+    0xC2000002, 0x6A3D0000, 0x72612000, 0xCE4000F8, 0xC0000408, 0xCE0000F8, 0xA78200D8, 0xC0004908,
+    0xCBC000F8, 0xC1000000, 0xD90000F9, 0xC1000002, 0xD90C00F8, 0x6FF4A000, 0x6FD44000, 0x4755A000,
+    0x477DA000, 0x5B747000, 0xC2800000, 0x58340006, 0xCA800078, 0xC2000000, 0xC0004900, 0xCE002100,
+    0x5EA80002, 0x58340006, 0xC6900078, 0xCD000078, 0x5A7C0020, 0xC2000002, 0x6A250000, 0xC0000408,
+    0xCE0000F8, 0xC0000032, 0xDCA800F9, 0xC1000002, 0x45294000, 0x00000000, 0x8C100006, 0x00000000,
+    0x00000000, 0x00000000, 0xA4800230, 0x00000000, 0xC3C00000, 0xC000140E, 0xCBC00018, 0xC3400000,
+    0xC2400000, 0x6FF86000, 0x47BDC000, 0x5BB84C80, 0x58380008, 0xCB400078, 0x58380006, 0xCA400078,
+    0x5F740002, 0x58380008, 0xC7500078, 0xCD000078, 0xC2000000, 0x58380004, 0xCA020078, 0xC3000000,
+    0x5838000C, 0xCB000020, 0x5A640002, 0x46610000, 0x84000010, 0xC2400000, 0x58380006, 0xC6500078,
+    0xCD000078, 0xC2000000, 0x5838000A, 0xCA020078, 0x5B300002, 0x5838000C, 0xC7100020, 0xCD000020,
+    0xC2420020, 0x5A200004, 0x46252000, 0x84000010, 0xC2000000, 0x5838000A, 0xC6101078, 0xCD021078,
+    0xC0004966, 0xCA4000F8, 0xC2000002, 0x6A3D0000, 0x72612000, 0xCE4000F8, 0x5F740000, 0x84000040,
+    0xC0004912, 0xCA0000F8, 0xC2C00002, 0x6AFD6000, 0x7EC16000, 0x762D0000, 0xCE0000F8, 0x5F300020,
+    0x84000040, 0xC0004924, 0xCA0000F8, 0xC2C00002, 0x6AFD6000, 0x7EC16000, 0x762D0000, 0xCE0000F8,
+    0xA4820070, 0xC2400000, 0xC000140E, 0xCA408018, 0xC2000002, 0xC0004900, 0xCE000000, 0xC000490A,
+    0xCE4000F8, 0xC1000000, 0xD90000F9, 0xD8400078, 0xC1000004, 0xD90000F9, 0xA48402A8, 0x00000000,
+    0xC3C00000, 0xC000140E, 0xCBC10018, 0xC2800000, 0xC2000000, 0x6FF8A000, 0x6FD44000, 0x4795C000,
+    0x47BDC000, 0x5BB87000, 0x5838002E, 0xCA800078, 0x58380006, 0xCA020078, 0xC3400000, 0x5838002E,
+    0xCB420078, 0x5AA80002, 0x46A10000, 0x84000010, 0xC2800000, 0x5838002E, 0xC6900078, 0xCD000078,
+    0x5F740002, 0x5838002E, 0xC7501078, 0xCD021078, 0xC0004968, 0xCA4000F8, 0xC2000002, 0x6A3D0000,
+    0x72612000, 0xCE4000F8, 0xC000492A, 0xCA8000F8, 0x5E740000, 0x84000040, 0xC0004910, 0xCA0000F8,
+    0xC2C00002, 0x6AFD6000, 0x7EC16000, 0x762D0000, 0xCE0000F8, 0x6ABD4010, 0xA68000F2, 0x00000000,
+    0xC0004910, 0xCA0000F8, 0xC2C00002, 0x6AFD6000, 0x7EC16000, 0x762D0000, 0xCE0000F8, 0x58380032,
+    0xCA0000F8, 0x58000002, 0xCA4000F8, 0x5838000C, 0x00000000, 0xCE0000F9, 0xCE4000F8, 0xC000492A,
+    0xCA0000F8, 0xC2C00002, 0x6AFD6000, 0x722D0000, 0xCE0000F8, 0xC000492C, 0xCA0000F8, 0xC2C00002,
+    0x6AFD6000, 0x722D0000, 0xCE0000F8, 0x80000040, 0xC000492C, 0xCA0000F8, 0xC2C00002, 0x6AFD6000,
+    0x7EC16000, 0x762D0000, 0xCE0000F8, 0xA4880120, 0xC2C00000, 0xC000140E, 0xCAC20018, 0xC000490E,
+    0xCA4000F8, 0xC2000002, 0x6A2D0000, 0x7E010000, 0x76612000, 0xCE4000F8, 0xC000496A, 0xCA4000F8,
+    0xC2000002, 0x6A2D0000, 0x72612000, 0xCE4000F8, 0x6EF0A000, 0x6ED44000, 0x47158000, 0x472D8000,
+    0x5B307000, 0x58300000, 0xCA0000F8, 0x00000000, 0xC2400002, 0x76612000, 0x8400004A, 0xC24C0002,
+    0xC6E40018, 0xC624C400, 0x58300010, 0xCA400500, 0x00000000, 0xC0001800, 0xCE4000F8, 0xA4860070,
+    0xC2400000, 0xC000140E, 0xCA418018, 0xC2020002, 0xC0004900, 0xCE002100, 0xC0004908, 0xCE4000F8,
+    0xC1000000, 0xD90000F9, 0xD8400078, 0xC1000004, 0xD90000F9, 0xA48C0048, 0xC2800002, 0xC000484A,
+    0xCE8000F8, 0xC2800000, 0xC000474A, 0xCE8000F8, 0xC0004846, 0xCE8000F8, 0xC0001408, 0xCC8000F8,
+    0xC10E0002, 0xD90C00F8, 0x8000EA78, 0xDFBC00F9, 0xC000496E, 0x99008638, 0xC94000F8, 0xC7D800F8,
+    0x00000000, 0xC57000F8, 0x5EF00020, 0x88000148, 0x6F346000, 0x4771A000, 0x5B744C80, 0x58340008,
+    0xC2400000, 0xCA400078, 0x00000000, 0xC2000000, 0x5A640002, 0xCE400078, 0x58340004, 0xCA000078,
+    0x00000000, 0x00000000, 0x5E200002, 0xCE000078, 0xC0004912, 0xCA8000F8, 0xC2400002, 0x6A712000,
+    0x72A54000, 0xCE8000F8, 0x5E200000, 0x84000052, 0xC000480A, 0xCA0000F8, 0xC0000408, 0xCA8000F8,
+    0x76250000, 0x00000000, 0x72A14000, 0xCE8000F8, 0x80000038, 0xC0004914, 0xCA0000F8, 0x7E412000,
+    0x00000000, 0x76250000, 0xCE0000F8, 0x800000D0, 0x6EF4A000, 0x6ED44000, 0x4755A000, 0x476DA000,
+    0x5B747000, 0x5834002E, 0xC2400000, 0xCA420078, 0x00000000, 0xC2000000, 0x5A640002, 0xC6501078,
+    0xCD021078, 0x58340006, 0xCA000078, 0x00000000, 0x00000000, 0x5A200002, 0xCE000078, 0xC0004910,
+    0xCA4000F8, 0xC2000002, 0x6A2D0000, 0x72612000, 0xCE4000F8, 0xC2000002, 0x6A310000, 0xC000042A,
+    0xCE0000F8, 0xC1040002, 0xD90C00F8, 0x00000000, 0x8000E7E8, 0x00000000, 0xC4980928, 0x9D000000,
+    0xC5580028, 0xC0000838, 0xCD8400F8, 0xC1440200, 0xC1C03800, 0xC55C1070, 0xC000100E, 0x9D000000,
+    0xCD8000F8, 0xC000100C, 0xCDC000F8, 0xC0004862, 0xC9C000F8, 0x00000000, 0x00000000, 0xD9D800F9,
+    0xC0007800, 0x401C0000, 0x5DC07A00, 0x88000012, 0x5C000200, 0xCD8000F8, 0xC1F0000A, 0x715CA000,
+    0xDD9800F8, 0xDD9C00F9, 0x41D8E000, 0xC5D40260, 0xC0001010, 0xCD4000F8, 0x6C9C8000, 0x45C8E000,
+    0x45C8E000, 0x59DC0004, 0xC1601260, 0xC5D40260, 0x9D000000, 0xC0001012, 0xCD4000F8, 0x00000000,
+    0x00000000, 0xD95800F8, 0x6D586000, 0x4594C000, 0x59984C80, 0xD99800F9, 0x5818000A, 0xC1800000,
+    0xC9800078, 0xC0006E00, 0x6D5CA000, 0x401C0000, 0x40180000, 0xC94000F8, 0x58000002, 0x00000000,
+    0xC9C000F8, 0xC0004930, 0xCD4000F8, 0xC0004932, 0xCDC000F8, 0x59980004, 0xC1C20020, 0xB59C0018,
+    0x00000000, 0xC1800000, 0xDD9C00F9, 0x581C000A, 0xCD800078, 0x581C000C, 0xC1800000, 0xC9800020,
+    0xC1C00002, 0xDD9400F8, 0x69D4E000, 0x5D980002, 0xCD800020, 0xC0004924, 0xC98000F8, 0x00000000,
+    0x9D000000, 0x00000000, 0x719CC000, 0xCD8000F8, 0xC000492A, 0xC94000F8, 0xC1C00002, 0x69D8E000,
+    0x7DC0C000, 0x7558A000, 0xCD4000F8, 0xC000492C, 0xC94000F8, 0xDD8000F9, 0x58000032, 0x755CA000,
+    0x84000090, 0xC94000F9, 0xC98000F8, 0xDD8000F9, 0x5800000C, 0x00000000, 0xCD4000F9, 0xCD8000F8,
+    0xC000492C, 0xC94000F8, 0xC000492A, 0xC98000F8, 0x715CA000, 0xC000492C, 0xCD4000F8, 0x719CC000,
+    0xC000492A, 0xCD8000F8, 0x9D000000, 0x00000000, 0x00000000, 0x00000000, 0xC0004862, 0xC98000F8,
+    0x00000000, 0xC1C00200, 0x4194C000, 0x459CE000, 0x88000012, 0xC5D800F8, 0xC0004862, 0xCD8000F8,
+    0xC0001406, 0xC98000F8, 0xC1C00002, 0x9D000000, 0xC5D80A00, 0xC5581048, 0xCD8000F8, 0xC0004930,
+    0xC98000F8, 0xC0004932, 0xC9C000F8, 0xC140000E, 0xC5581C18, 0xDD9400F8, 0xC0007800, 0x40140000,
+    0x5D407A00, 0x88000012, 0x5C000200, 0xCD8000F8, 0x58000002, 0x5D407A00, 0x88000012, 0x5C000200,
+    0xCDC000F8, 0xDD5400F8, 0xC1C00000, 0x58140006, 0xC9C20078, 0xC1800000, 0x58140000, 0xC98000D8,
+    0x6DDC2000, 0xC000491E, 0x41D8E000, 0xCDC000F8, 0xDD9800F8, 0xC1C00022, 0xC5D80D70, 0xDD9400F9,
+    0xC5581C18, 0xC000491C, 0xCD8000F8, 0xDD5400F8, 0xC1C00000, 0x58140006, 0xC9C20078, 0xC1800000,
+    0x58140004, 0xC9820078, 0x00000000, 0x59DC0002, 0x45D8C000, 0x84000010, 0xC1C00000, 0x9D000000,
+    0x58140006, 0xC5D81078, 0xCD821078, 0xC0004860, 0xC94000F8, 0xC1820080, 0xC1D00002, 0x58147700,
+    0xD58000F8, 0x58000002, 0xD58000F9, 0x59540004, 0xB5580018, 0xC0004860, 0xC1400000, 0xCD4000F8,
+    0xDD9800F9, 0x9D000000, 0xDD9400F8, 0xC0001404, 0xCDC10800, 0xC1C00000, 0xC1800200, 0x5D980004,
+    0xDF5D0048, 0x459CA000, 0x8800FFF2, 0xDD8000F9, 0x5800000C, 0x00000000, 0xC94000F9, 0xC98000F8,
+    0xC1C00002, 0xC5D43F00, 0xC5D81E00, 0xC0004862, 0xC9C000F8, 0x00000000, 0x00000000, 0x581C7800,
+    0x5DC07A00, 0x88000012, 0x5C000200, 0xCD4000F8, 0x58000002, 0x5DC07A00, 0x88000012, 0x5C000200,
+    0xCD8000F8, 0xC0004862, 0xC9C000F8, 0x00000000, 0xC15004C0, 0xC5D40060, 0xDD9C00F8, 0xC5D41C18,
+    0xC1C00000, 0xDD8000F9, 0x58000030, 0xC9C00078, 0xDD8000F9, 0x58000002, 0xC98000F8, 0x6DDC2000,
+    0xC000491C, 0x41D8E000, 0xCD4000F9, 0xCDC000F8, 0xDD9400F9, 0xC1C00000, 0x58140030, 0xC9C00078,
+    0xC1800000, 0x58140006, 0xC9820078, 0x00000000, 0x59DC0002, 0x45D8C000, 0x84000010, 0xC1C00000,
+    0x9D000000, 0x58140030, 0xC5D80078, 0xCD800078, 0xC1C00000, 0xDF5C0038, 0x5DDC0080, 0x8400FFEA,
+    0x00000000, 0x9D000000, 0x00000000, 0x00000000, 0x00000000, 0xC160FFFE, 0xC0000A10, 0xC9440060,
+    0xC1A0FFFE, 0x59983008, 0xC000100C, 0xCD4000F8, 0xC000100E, 0xCD8000F8, 0xC0004964, 0xC98000F8,
+    0x00000000, 0xC170000A, 0x7158A000, 0x6C988000, 0x4588C000, 0x4588C000, 0x59980004, 0xC5940270,
+    0xC0001010, 0xCD4000F8, 0xC0004946, 0xC94000F8, 0x00000000, 0x00000000, 0x6D58A000, 0x6D5C4000,
+    0x459CC000, 0x4594C000, 0xC000494A, 0xC94000F8, 0xC0004948, 0xC9C000F8, 0x4194C000, 0xC1400012,
+    0xC55C1818, 0x9D000000, 0xC59C0268, 0xC0001012, 0xCDC000F8, 0xC1400000, 0x58000012, 0xC9410038,
+    0xC0004950, 0xC9C000F8, 0xC55800F8, 0xC5940838, 0xC5581078, 0xD99400F8, 0xC000493C, 0xC94000F8,
+    0xC0004954, 0xC98000F8, 0x59DC00A8, 0x45D4E000, 0x41D8E000, 0x5D5C0030, 0x88000010, 0xC1C00030,
+    0xC1800000, 0xC5D84028, 0xC1400000, 0xC5D40008, 0x5DD40002, 0x84000072, 0x5DD40004, 0x8400009A,
+    0x5DD40006, 0x840000C2, 0x5DD80026, 0x840000EA, 0xDD5400F8, 0xDD8000F9, 0x58000008, 0x40180000,
+    0xCD4000F8, 0x59980002, 0x8000FFC0, 0xDD5400F8, 0xDD8000F9, 0x58000008, 0x40180000, 0xCD4000B8,
+    0x59980002, 0x8000FF88, 0xDD5400F8, 0xDD8000F9, 0x58000008, 0x40180000, 0xCD400078, 0x59980002,
+    0x8000FF50, 0xDD5400F8, 0xDD8000F9, 0x58000008, 0x40180000, 0xCD400038, 0x59980002, 0x8000FF18,
+    0x00000000, 0x9D000000, 0x00000000, 0x00000000, 0x00000000, 0x58000012, 0xC94000F8, 0xC0004954,
+    0xC9C000F8, 0xC0004950, 0xC9400078, 0xDD8000F9, 0x58000028, 0x5D9C0000, 0x84000052, 0x5D9C0002,
+    0x84000052, 0x5D9C0004, 0x8400006A, 0xC55B0038, 0xC55C08B8, 0xCD800039, 0xCDC108B8, 0x80000060,
+    0xCD4000F8, 0x80000050, 0xC55900B8, 0xC55C1838, 0xCD8000B9, 0xCDC31838, 0x80000028, 0xC55A0078,
+    0xC55C1078, 0xCD800079, 0xCDC21078, 0x9D000000, 0x00000000, 0x00000000, 0x00000000, 0x59540002,
+    0x6994E018, 0x61C0C008, 0x4194A000, 0x5D940040, 0x88000012, 0xC59400F8, 0x9D000000, 0xCD4000F8,
+    0x00000000, 0x00000000, 0x9D000000, 0x4158A000, 0xCD4000F8, 0x00000000, 0xCD8000F9, 0x45408000,
+    0x8800FFF0, 0x00000000, 0x9CC00000, 0x00000000, 0x00000000, 0x00000000, 0xC0004810, 0xCA010038,
+    0xC241FFFE, 0xC1400000, 0x46148000, 0x00000000, 0x9CC00006, 0xC0004200, 0x40180000, 0xC9C000F8,
+    0x00000000, 0x00000000, 0x61C08010, 0x8400005A, 0xC2400002, 0x6A512000, 0x71E4E000, 0xCDC000F8,
+    0xC0004748, 0xCD8000F8, 0x9CC00000, 0x6D98A000, 0x5998003E, 0x45912000, 0x59540002, 0x59980002,
+    0x46188000, 0xC1000000, 0xC51800FE, 0x8000FF38, 0x00000000, 0x40180000, 0xC9C000F8, 0xC2000000,
+    0xC5600020, 0xC1210000, 0x69208010, 0x7D008000, 0x75D0E000, 0xCDC000F8, 0x6D542000, 0x58144300,
+    0xC1000000, 0xCD0000F9, 0x9CC00000, 0xC121FFFE, 0x5911FFFE, 0xCD0000F9, 0x79588000, 0x6D10A010,
+    0x5D100000, 0x840000C0, 0x45948000, 0x880000B0, 0x6D536000, 0x6D136010, 0x6D54A010, 0xC0004700,
+    0x40140000, 0xCA0000F8, 0x00000000, 0x00000000, 0x6A110000, 0x6A110010, 0x62008018, 0x84000032,
+    0x00000000, 0x9CC00000, 0x6D54A000, 0x5954003E, 0x45512000, 0x59540002, 0x6D57A000, 0x6D57A010,
+    0x6D54A000, 0x6D936000, 0x6D136010, 0xC1E10000, 0x69D0E010, 0x5DDC0002, 0x7DC0E000, 0x6D98A010,
+    0x6D536000, 0x6D136010, 0x6D54A010, 0xC0004700, 0x40140000, 0xCA0000F8, 0x00000000, 0x00000000,
+    0x6A110000, 0x6A110010, 0x45588000, 0x00000000, 0x761D0002, 0x62008018, 0x84000032, 0x00000000,
+    0x9CC00000, 0x6D54A000, 0x5954003E, 0x45512000, 0x45588000, 0x00000000, 0x9CC00002, 0x59540002,
+    0x6D57A000, 0x6D57A010, 0xC0004700, 0x40140000, 0xCA0000F8, 0x8000FF68, 0x00000000, 0x00000000,
+    0x00000000, 0x58004700, 0xC98000F8, 0x9CC00000, 0x00000000, 0x6994C000, 0x6DA7E010, 0x58004700,
+    0xC98000F8, 0xC1210000, 0x9CC00000, 0x69148010, 0x7190C000, 0xCD8000F8, 0xC1000000, 0xC0004810,
+    0xC9020038, 0x00000000, 0x00000000, 0x45D0C000, 0x88000062, 0xC2400002, 0x45588000, 0xC1000000,
+    0xC52400FC, 0x45D48000, 0xC1000000, 0xC52400FE, 0x9CC00000, 0x00000000, 0x00000000, 0x00000000,
+    0x59980200, 0xC2400000, 0x455C8000, 0xC1000002, 0xC52400FC, 0x45948000, 0xC1000002, 0xC52400FE,
+    0x9CC00000, 0x00000000, 0x00000000, 0x00000000, 0xC0004740, 0xC9C000F8, 0x59180002, 0x6D130000,
+    0x6D130010, 0x451C8000, 0xC2400000, 0x9CC00002, 0x00000000, 0x00000000, 0x459C8000, 0x88000062,
+    0xC2400002, 0x455C8000, 0xC1000000, 0xC52400FC, 0x45948000, 0xC1000000, 0xC52400FC, 0x9CC00000,
+    0x00000000, 0x00000000, 0x00000000, 0xC2400000, 0x45588000, 0xC1000002, 0xC52400FE, 0x45D48000,
+    0xC1000002, 0xC52400FE, 0x9CC00000, 0x00000000, 0x00000000, 0x00000000, 0x59540002, 0x6D570000,
+    0x6D570010, 0x45588000, 0x6D402000, 0x9CC00002, 0x58004300, 0x58000000, 0xC13C0002, 0xCD03DE00,
+    0x8000FFB0, 0x00000000, 0x00000000, 0x00000000, 0xC1020002, 0xD90C00F8, 0xC98000F8, 0x59540002,
+    0xC0004730, 0xCD4000F8, 0x5D980002, 0x00000000, 0x80000036, 0x00000000, 0x9CC00000, 0xC0004732,
+    0xCD8000F8, 0x00000000, 0xC0004734, 0xC9C000F8, 0xC1800000, 0xC0004816, 0xC9820078, 0xC0004738,
+    0xCDC000F8, 0xC1C00000, 0xC0004734, 0x9CC00000, 0xCDC000F8, 0xC0004732, 0xCD8000F8,
+};
+
+static unsigned int firmware_binary_data[] = {
+};
+
+
+#endif  //  IFXMIPS_ATM_FW_AR9_H
diff --git a/drivers/atm/lantiq/ltqmips_atm_fw_regs_ar9.h b/drivers/atm/lantiq/ltqmips_atm_fw_regs_ar9.h
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/ltqmips_atm_fw_regs_ar9.h
@@ -0,0 +1,172 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_atm_fw_regs_ar9.h
+** PROJECT      : UEIP
+** MODULES     	: ATM (ADSL)
+**
+** DATE         : 1 AUG 2005
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : ATM Driver (Firmware Registers)
+** COPYRIGHT    : 	Copyright (c) 2006
+**			Infineon Technologies AG
+**			Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+**  4 AUG 2005  Xu Liang        Initiate Version
+** 23 OCT 2006  Xu Liang        Add GPL header.
+**  9 JAN 2007  Xu Liang        First version got from Anand (IC designer)
+*******************************************************************************/
+
+
+
+#ifndef IFXMIPS_ATM_FW_REGS_AR9_H
+#define IFXMIPS_ATM_FW_REGS_AR9_H
+
+
+
+/*
+ *  Host-PPE Communication Data Address Mapping
+ */
+#define FW_VER_ID                       ((volatile struct fw_ver_id *)      SB_BUFFER(0x2001))
+#define CFG_WRX_HTUTS                   SB_BUFFER(0x2400)   /*  WAN RX HTU Table Size, must be configured before enable PPE firmware.   */
+#define CFG_WRX_QNUM                    SB_BUFFER(0x2401)   /*  WAN RX Queue Number */
+#define CFG_WRX_DCHNUM                  SB_BUFFER(0x2402)   /*  WAN RX DMA Channel Number, no more than 8, must be configured before enable PPE firmware.   */
+#define CFG_WTX_DCHNUM                  SB_BUFFER(0x2403)   /*  WAN TX DMA Channel Number, no more than 16, must be configured before enable PPE firmware.  */
+#define CFG_WRDES_DELAY                 SB_BUFFER(0x2404)   /*  WAN Descriptor Write Delay, must be configured before enable PPE firmware.  */
+#define WRX_DMACH_ON                    SB_BUFFER(0x2405)   /*  WAN RX DMA Channel Enable, must be configured before enable PPE firmware.   */
+#define WTX_DMACH_ON                    SB_BUFFER(0x2406)   /*  WAN TX DMA Channel Enable, must be configured before enable PPE firmware.   */
+#define WRX_HUNT_BITTH                  SB_BUFFER(0x2407)   /*  WAN RX HUNT Threshold, must be between 2 to 8.  */
+#define WRX_QUEUE_CONFIG(i)             ((struct wrx_queue_config*)         SB_BUFFER(0x2500 + (i) * 20))
+#define WRX_QUEUE_CONTEXT(i)            ((struct wrx_queue_context*)        SB_BUFFER(0x2504 + (i) * 20))
+#define WRX_DMA_CHANNEL_CONFIG(i)       ((struct wrx_dma_channel_config*)   SB_BUFFER(0x2640 + (i) * 7))
+#define WRX_DESC_CONTEXT(i)             ((struct wrx_desc_context*)         SB_BUFFER(0x2643 + (i) * 7))
+#define WTX_PORT_CONFIG(i)              ((struct wtx_port_config*)          SB_BUFFER(0x2440 + (i)))
+#define WTX_QUEUE_CONFIG(i)             ((struct wtx_queue_config*)         SB_BUFFER(0x3800 + (i) * 27))
+#define WTX_DMA_CHANNEL_CONFIG(i)       ((struct wtx_dma_channel_config*)   SB_BUFFER(0x3801 + (i) * 27))
+#define WAN_MIB_TABLE                   ((struct wan_mib_table*)            SB_BUFFER(0x2410))
+#define HTU_ENTRY(i)                    ((struct htu_entry*)                SB_BUFFER(0x2010 + (i)))
+#define HTU_MASK(i)                     ((struct htu_mask*)                 SB_BUFFER(0x2030 + (i)))
+#define HTU_RESULT(i)                   ((struct htu_result*)               SB_BUFFER(0x2050 + (i)))
+
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+
+  #define RETX_MODE_CFG                     ((volatile struct Retx_mode_cfg *)      SB_BUFFER(0x2408))
+  #define RETX_TSYNC_CFG                    ((volatile struct Retx_Tsync_cfg *)     SB_BUFFER(0x2409))
+  #define RETX_TD_CFG                       ((volatile struct Retx_Td_cfg *)        SB_BUFFER(0x240A))
+  #define RETX_MIB_TIMER_CFG                ((volatile struct Retx_MIB_Timer_cfg *) SB_BUFFER(0x240B))
+  #define RETX_PLAYOUT_BUFFER_BASE          SB_BUFFER(0x240D)
+  #define RETX_SERVICE_HEADER_CFG           SB_BUFFER(0x240E)
+  #define RETX_MASK_HEADER_CFG              SB_BUFFER(0x240F)
+
+  #define RETX_ADSL_PPE_INTF                ((volatile struct Retx_adsl_ppe_intf *) PPE_REG_ADDR(0x0D78))
+  #define BAD_REC_RETX_ADSL_PPE_INTF        ((volatile struct Retx_adsl_ppe_intf *) SB_BUFFER(0x23AC))
+  #define FIRST_BAD_REC_RETX_ADSL_PPE_INTF  ((volatile struct Retx_adsl_ppe_intf *) SB_BUFFER(0x23AE))
+
+  #define PB_BUFFER_USAGE                   SB_BUFFER(0x2100)
+  #define DTU_STAT_INFO                     ((volatile struct DTU_stat_info *)      SB_BUFFER(0x2180))
+  #define DTU_VLD_STAT                      SB_BUFFER(0x2380)
+
+
+  //=====================================================================
+  // retx firmware mib, for debug purpose
+  //      address : 0x2388 - 0x238F
+  //      size    : 8
+  //=====================================================================
+  #define URETX_RX_TOTAL_DTU                    SB_BUFFER(0x2388)
+  #define URETX_RX_BAD_DTU                      SB_BUFFER(0x2389)
+  #define URETX_RX_GOOD_DTU                     SB_BUFFER(0x238A)
+  #define URETX_RX_CORRECTED_DTU                SB_BUFFER(0x238B)
+  #define URETX_RX_OUTOFDATE_DTU                SB_BUFFER(0x238C)
+  #define URETX_RX_DUPLICATE_DTU                SB_BUFFER(0x238D)
+  #define URETX_RX_TIMEOUT_DTU                  SB_BUFFER(0x238E)
+
+  #define URETX_ALPHA_SWITCH_TO_HUNT_TIMES      SB_BUFFER(0x238F)
+
+  // cell counter for debug purpose
+  #define WRX_BC0_CELL_NUM                      SB_BUFFER(0x23E0)
+  #define WRX_BC0_DROP_CELL_NUM                 SB_BUFFER(0x23E1)
+  #define WRX_BC0_NONRETX_CELL_NUM              SB_BUFFER(0x23E2)
+  #define WRX_BC0_RETX_CELL_NUM                 SB_BUFFER(0x23E3)
+  #define WRX_BC0_OUTOFDATE_CELL_NUM            SB_BUFFER(0x23E4)
+  #define WRX_BC0_DIRECTUP_NUM                  SB_BUFFER(0x23E5)
+  #define WRX_BC0_PBW_TOTAL_NUM                 SB_BUFFER(0x23E6)
+  #define WRX_BC0_PBW_SUCC_NUM                  SB_BUFFER(0x23E7)
+  #define WRX_BC0_PBW_FAIL_NUM                  SB_BUFFER(0x23E8)
+  #define WRX_BC1_CELL_NUM                      SB_BUFFER(0x23E9)
+
+  // debug info (interface)
+
+  #define DBG_DTU_INTF_WRPTR                    SB_BUFFER(0x2390)
+  #define DBG_INTF_FCW_DUP_CNT                  SB_BUFFER(0x2391)
+  #define DBG_INTF_SID_CHANGE_IN_DTU_CNT        SB_BUFFER(0x2392)
+  #define DBG_INTF_LCW_DUP_CNT                  SB_BUFFER(0x2393)
+
+  #define DBG_RFBI_DONE_INT_CNT                 SB_BUFFER(0x2394)
+  #define DBG_DREG_BEG_END                      SB_BUFFER(0x2395)
+  #define DBG_RFBI_BC0_INVALID_CNT              SB_BUFFER(0x2396)
+  #define DBG_RFBI_LAST_T                       SB_BUFFER(0x2397)
+
+  #define DBG_RFBI_INTV0                        SB_BUFFER(0x23EE)
+  #define DBG_RFBI_INTV1                        SB_BUFFER(0x23EF)
+
+  #define DBG_INTF_INFO(i)                      ((volatile struct Retx_adsl_ppe_intf_rec *) SB_BUFFER(0x23F0 + i))
+
+  // Internal status
+  #define URetx_curr_time                       SB_BUFFER(0x2398)
+  #define URetx_sec_counter                     SB_BUFFER(0x2399)
+  #define RxCURR_EFB                            SB_BUFFER(0x239A)
+  #define RxDTURetransmittedCNT                 SB_BUFFER(0x239B)
+
+  //=====================================================================
+  // standardized MIB counter
+  //      address : 0x239C - 0x239F
+  //      size    : 4
+  //=====================================================================
+  #define RxLastEFBCNT                          SB_BUFFER(0x239C)
+  #define RxDTUCorrectedCNT                     SB_BUFFER(0x239D)
+  #define RxDTUCorruptedCNT                     SB_BUFFER(0x239E)
+  #define RxRetxDTUUncorrectedCNT               SB_BUFFER(0x239F)
+
+
+  //=====================================================================
+  // General URetx Context
+  //      address : 0x23A0 - 0x23AF
+  //      size    : 16
+  //=====================================================================
+  #define NEXT_DTU_SID_OUT                      SB_BUFFER(0x23A0)
+  #define LAST_DTU_SID_IN                       SB_BUFFER(0x23A1)
+  #define NEXT_CELL_SID_OUT                     SB_BUFFER(0x23A2)
+  #define ISR_CELL_ID                           SB_BUFFER(0x23A3)
+  #define PB_CELL_SEARCH_IDX                    SB_BUFFER(0x23A4)
+  #define PB_READ_PEND_FLAG                     SB_BUFFER(0x23A5)
+  #define RFBI_FIRST_CW                         SB_BUFFER(0x23A6)
+  #define RFBI_BAD_CW                           SB_BUFFER(0x23A7)
+  #define RFBI_INVALID_CW                       SB_BUFFER(0x23A8)
+  #define RFBI_RETX_CW                          SB_BUFFER(0x23A9)
+  #define RFBI_CHK_DTU_STATUS                   SB_BUFFER(0x23AA)
+
+  //=====================================================================
+  // per PVC counter for RX error_pdu and correct_pdu
+  //      address : 0x23B0 - 0x23CF
+  //      size    : 32
+  //=====================================================================
+  #define WRX_PER_PVC_CORRECT_PDU_BASE          SB_BUFFER(0x23B0)
+  #define WRX_PER_PVC_ERROR_PDU_BASE            SB_BUFFER(0x23C0)
+
+  #define __WRXCTXT_L2_RdPtr(i)                 SB_BUFFER(0x2422 + (i))
+  #define __WRXCTXT_L2Pages(i)                  SB_BUFFER(0x2424 + (i))
+
+  #define __WTXCTXT_TC_WRPTR(i)                 SB_BUFFER(0x2450 + (i))
+  #define __WRXCTXT_PortState(i)                SB_BUFFER(0x242A + (i))
+
+#endif
+
+
+
+#endif  //  IFXMIPS_ATM_FW_REGS_AR9_H
diff --git a/drivers/atm/lantiq/ltqmips_atm_fw_regs_common.h b/drivers/atm/lantiq/ltqmips_atm_fw_regs_common.h
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/ltqmips_atm_fw_regs_common.h
@@ -0,0 +1,546 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_atm_fw_regs_common.h
+** PROJECT      : UEIP
+** MODULES     	: ATM (ADSL)
+**
+** DATE         : 1 AUG 2005
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : ATM Driver (Firmware Register Structures)
+** COPYRIGHT    : 	Copyright (c) 2006
+**			Infineon Technologies AG
+**			Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+**  4 AUG 2005  Xu Liang        Initiate Version
+** 23 OCT 2006  Xu Liang        Add GPL header.
+**  9 JAN 2007  Xu Liang        First version got from Anand (IC designer)
+*******************************************************************************/
+
+
+
+#ifndef IFXMIPS_ATM_FW_REGS_COMMON_H
+#define IFXMIPS_ATM_FW_REGS_COMMON_H
+
+
+
+#if defined(CONFIG_LTQ_ATM_XRX300)
+  #include "ltqmips_atm_fw_regs_ar9.h"
+#elif defined(CONFIG_LTQ_ATM_XRX200)
+  #include "ltqmips_atm_fw_regs_vr9.h"
+#else
+  #error Platform is not specified!
+#endif
+
+
+
+/*
+ *  PPE ATM Cell Header
+ */
+#if defined(__BIG_ENDIAN)
+    struct uni_cell_header {
+        unsigned int        gfc     :4;
+        unsigned int        vpi     :8;
+        unsigned int        vci     :16;
+        unsigned int        pti     :3;
+        unsigned int        clp     :1;
+    };
+#else
+    struct uni_cell_header {
+        unsigned int        clp     :1;
+        unsigned int        pti     :3;
+        unsigned int        vci     :16;
+        unsigned int        vpi     :8;
+        unsigned int        gfc     :4;
+    };
+#endif  //  defined(__BIG_ENDIAN)
+
+/*
+ *  Inband Header and Trailer
+ */
+#if defined(__BIG_ENDIAN)
+    struct rx_inband_trailer {
+        /*  0 - 3h  */
+        unsigned int        uu      :8;
+        unsigned int        cpi     :8;
+        unsigned int        stw_res1:4;
+        unsigned int        stw_clp :1;
+        unsigned int        stw_ec  :1;
+        unsigned int        stw_uu  :1;
+        unsigned int        stw_cpi :1;
+        unsigned int        stw_ovz :1;
+        unsigned int        stw_mfl :1;
+        unsigned int        stw_usz :1;
+        unsigned int        stw_crc :1;
+        unsigned int        stw_il  :1;
+        unsigned int        stw_ra  :1;
+        unsigned int        stw_res2:2;
+        /*  4 - 7h  */
+        unsigned int        gfc     :4;
+        unsigned int        vpi     :8;
+        unsigned int        vci     :16;
+        unsigned int        pti     :3;
+        unsigned int        clp     :1;
+    };
+
+    struct tx_inband_header {
+        /*  0 - 3h  */
+        unsigned int        gfc     :4;
+        unsigned int        vpi     :8;
+        unsigned int        vci     :16;
+        unsigned int        pti     :3;
+        unsigned int        clp     :1;
+        /*  4 - 7h  */
+        unsigned int        uu      :8;
+        unsigned int        cpi     :8;
+        unsigned int        pad     :8;
+        unsigned int        res1    :8;
+    };
+#else
+    struct rx_inband_trailer {
+        /*  0 - 3h  */
+        unsigned int        stw_res2:2;
+        unsigned int        stw_ra  :1;
+        unsigned int        stw_il  :1;
+        unsigned int        stw_crc :1;
+        unsigned int        stw_usz :1;
+        unsigned int        stw_mfl :1;
+        unsigned int        stw_ovz :1;
+        unsigned int        stw_cpi :1;
+        unsigned int        stw_uu  :1;
+        unsigned int        stw_ec  :1;
+        unsigned int        stw_clp :1;
+        unsigned int        stw_res1:4;
+        unsigned int        cpi     :8;
+        unsigned int        uu      :8;
+        /*  4 - 7h  */
+        unsigned int        clp     :1;
+        unsigned int        pti     :3;
+        unsigned int        vci     :16;
+        unsigned int        vpi     :8;
+        unsigned int        gfc     :4;
+    };
+
+    struct tx_inband_header {
+        /*  0 - 3h  */
+        unsigned int        clp     :1;
+        unsigned int        pti     :3;
+        unsigned int        vci     :16;
+        unsigned int        vpi     :8;
+        unsigned int        gfc     :4;
+        /*  4 - 7h  */
+        unsigned int        res1    :8;
+        unsigned int        pad     :8;
+        unsigned int        cpi     :8;
+        unsigned int        uu      :8;
+    };
+#endif  //  defined(__BIG_ENDIAN)
+
+/*
+ *  MIB Table Maintained by Firmware
+ */
+struct wan_mib_table {
+    u32                     res1;
+    u32                     wrx_drophtu_cell;
+    u32                     wrx_dropdes_pdu;
+    u32                     wrx_correct_pdu;
+    u32                     wrx_err_pdu;
+    u32                     wrx_dropdes_cell;
+    u32                     wrx_correct_cell;
+    u32                     wrx_err_cell;
+    u32                     wrx_total_byte;
+    u32                     res2;
+    u32                     wtx_total_pdu;
+    u32                     wtx_total_cell;
+    u32                     wtx_total_byte;
+};
+
+/*
+ *  Host-PPE Communication Data Structure
+ */
+
+#if defined(__BIG_ENDIAN)
+    struct fw_ver_id {
+        unsigned int    family      :4;
+        unsigned int    fwtype      :4;
+        unsigned int    interface   :4;
+        unsigned int    fwmode      :4;
+        unsigned int    major       :8;
+        unsigned int    minor       :8;
+    };
+
+    struct wrx_queue_config {
+        /*  0h  */
+        unsigned int    res2        :27;
+        unsigned int    dmach       :4;
+        unsigned int    errdp       :1;
+        /*  1h  */
+        unsigned int    oversize    :16;
+        unsigned int    undersize   :16;
+        /*  2h  */
+        unsigned int    res1        :16;
+        unsigned int    mfs         :16;
+        /*  3h  */
+        unsigned int    uumask      :8;
+        unsigned int    cpimask     :8;
+        unsigned int    uuexp       :8;
+        unsigned int    cpiexp      :8;
+    };
+
+    struct wrx_queue_context {
+        /*  0h  */
+        unsigned int    curr_len    :16;
+        unsigned int    res0        :12;
+        unsigned int    mfs         :1;
+        unsigned int    ec          :1;
+        unsigned int    clp1        :1;
+        unsigned int    aal5dp      :1;
+
+        /*  1h  */
+        unsigned int    intcrc;
+
+        /*  2h, 3h  */
+        unsigned int    curr_des0;
+        unsigned int    curr_des1;
+
+        /*  4h - 0xE    */
+        unsigned int    res1[11];
+
+        unsigned int    last_dword;
+    };
+
+    struct wtx_port_config {
+        unsigned int    res1        :27;
+        unsigned int    qid         :4;
+        unsigned int    qsben       :1;
+    };
+
+    struct wtx_queue_config {
+        unsigned int    res1        :16;
+        unsigned int    same_vc_qmap:8;
+        unsigned int    res2        :1;
+        unsigned int    sbid        :1;
+        unsigned int    qsb_vcid    :4; //  Which QSB queue (VCID) does this TX queue map to.
+        unsigned int    res3        :1;
+        unsigned int    qsben       :1;
+    };
+
+    struct wrx_desc_context {
+        unsigned int dmach_wrptr    : 16;
+        unsigned int dmach_rdptr    : 16;
+
+        unsigned int res0           : 16;
+        unsigned int dmach_fcnt     : 16;
+
+        unsigned int res1           : 11;
+        unsigned int desbuf_wrptr   : 5;
+        unsigned int res2           : 11;
+        unsigned int desbuf_rdptr   : 5;
+
+        unsigned int res3           : 27;
+        unsigned int desbuf_vcnt    : 5;
+    };
+
+    struct wrx_dma_channel_config {
+        /*  0h  */
+        unsigned int    res1        :1;
+        unsigned int    mode        :2;
+        unsigned int    rlcfg       :1;
+        unsigned int    desba       :28;
+        /*  1h  */
+        unsigned int    chrl        :16;
+        unsigned int    clp1th      :16;
+        /*  2h  */
+        unsigned int    deslen      :16;
+        unsigned int    vlddes      :16;
+    };
+
+    struct wtx_dma_channel_config {
+        /*  0h  */
+        unsigned int    res2        :1;
+        unsigned int    mode        :2;
+        unsigned int    res3        :1;
+        unsigned int    desba       :28;
+        /*  1h  */
+        unsigned int    res1        :32;
+        /*  2h  */
+        unsigned int    deslen      :16;
+        unsigned int    vlddes      :16;
+    };
+
+    struct htu_entry {
+        unsigned int    res1        :1;
+        unsigned int    clp         :1;
+        unsigned int    pid         :2;
+        unsigned int    vpi         :8;
+        unsigned int    vci         :16;
+        unsigned int    pti         :3;
+        unsigned int    vld         :1;
+    };
+
+    struct htu_mask {
+        unsigned int    set         :1;
+        unsigned int    clp         :1;
+        unsigned int    pid_mask    :2;
+        unsigned int    vpi_mask    :8;
+        unsigned int    vci_mask    :16;
+        unsigned int    pti_mask    :3;
+        unsigned int    clear       :1;
+    };
+
+   struct htu_result {
+        unsigned int    res1        :12;
+        unsigned int    cellid      :4;
+        unsigned int    res2        :5;
+        unsigned int    type        :1;
+        unsigned int    ven         :1;
+        unsigned int    res3        :5;
+        unsigned int    qid         :4;
+    };
+
+    struct rx_descriptor {
+        /*  0 - 3h  */
+        unsigned int    own         :1;
+        unsigned int    c           :1;
+        unsigned int    sop         :1;
+        unsigned int    eop         :1;
+        unsigned int    res1        :3;
+        unsigned int    byteoff     :2;
+        unsigned int    res2        :2;
+        unsigned int    id          :4;
+        unsigned int    err         :1;
+        unsigned int    datalen     :16;
+        /*  4 - 7h  */
+        unsigned int    res3        :4;
+        unsigned int    dataptr     :28;
+    };
+
+    struct tx_descriptor {
+        /*  0 - 3h  */
+        unsigned int    own         :1;
+        unsigned int    c           :1;
+        unsigned int    sop         :1;
+        unsigned int    eop         :1;
+        unsigned int    byteoff     :5;
+        unsigned int    res1        :5;
+        unsigned int    iscell      :1;
+        unsigned int    clp         :1;
+        unsigned int    datalen     :16;
+        /*  4 - 7h  */
+        unsigned int    res2        :4;
+        unsigned int    dataptr     :28;
+    };
+#else
+    struct wrx_queue_config {
+        /*  0h  */
+        unsigned int    errdp       :1;
+        unsigned int    dmach       :4;
+        unsigned int    res2        :27;
+        /*  1h  */
+        unsigned int    undersize   :16;
+        unsigned int    oversize    :16;
+        /*  2h  */
+        unsigned int    mfs         :16;
+        unsigned int    res1        :16;
+        /*  3h  */
+        unsigned int    cpiexp      :8;
+        unsigned int    uuexp       :8;
+        unsigned int    cpimask     :8;
+        unsigned int    uumask      :8;
+    };
+
+    struct wtx_port_config {
+        unsigned int    qsben       :1;
+        unsigned int    qid         :4;
+        unsigned int    res1        :27;
+    };
+
+    struct wtx_queue_config {
+        unsigned int    qsben       :1;
+        unsigned int    res3        :1;
+        unsigned int    qsb_vcid    :4; //  Which QSB queue (VCID) does this TX queue map to.
+        unsigned int    sbid        :1;
+        unsigned int    res2        :1;
+        unsigned int    same_vc_qmap:8;
+        unsigned int    res1        :16;
+    };
+
+    struct wrx_dma_channel_config
+    {
+        /*  0h  */
+        unsigned int    desba       :28;
+        unsigned int    rlcfg       :1;
+        unsigned int    mode        :2;
+        unsigned int    res1        :1;
+        /*  1h  */
+        unsigned int    clp1th      :16;
+        unsigned int    chrl        :16;
+        /*  2h  */
+        unsigned int    vlddes      :16;
+        unsigned int    deslen      :16;
+    };
+
+    struct wtx_dma_channel_config {
+        /*  0h  */
+        unsigned int    desba       :28;
+        unsigned int    res3        :1;
+        unsigned int    mode        :2;
+        unsigned int    res2        :1;
+        /*  1h  */
+        unsigned int    res1        :32;
+        /*  2h  */
+        unsigned int    vlddes      :16;
+        unsigned int    deslen      :16;
+    };
+
+    struct rx_descriptor {
+        /*  4 - 7h  */
+        unsigned int    dataptr     :28;
+        unsigned int    res3        :4;
+        /*  0 - 3h  */
+        unsigned int    datalen     :16;
+        unsigned int    err         :1;
+        unsigned int    id          :4;
+        unsigned int    res2        :2;
+        unsigned int    byteoff     :2;
+        unsigned int    res1        :3;
+        unsigned int    eop         :1;
+        unsigned int    sop         :1;
+        unsigned int    c           :1;
+        unsigned int    own         :1;
+    };
+
+    struct tx_descriptor {
+        /*  4 - 7h  */
+        unsigned int    dataptr     :28;
+        unsigned int    res2        :4;
+        /*  0 - 3h  */
+        unsigned int    datalen     :16;
+        unsigned int    clp         :1;
+        unsigned int    iscell      :1;
+        unsigned int    res1        :5;
+        unsigned int    byteoff     :5;
+        unsigned int    eop         :1;
+        unsigned int    sop         :1;
+        unsigned int    c           :1;
+        unsigned int    own         :1;
+    };
+#endif  //  defined(__BIG_ENDIAN)
+
+#if defined(ENABLE_ATM_RETX) && ENABLE_ATM_RETX
+  #if defined(__BIG_ENDIAN)
+
+    struct Retx_adsl_ppe_intf {
+        unsigned int res0_0             : 16;
+        unsigned int dtu_sid            : 8;
+        unsigned int dtu_timestamp      : 8;
+
+        unsigned int res1_0             : 16;
+        unsigned int local_time         : 8;
+        unsigned int res1_1             : 5;
+        unsigned int is_last_cw         : 1;
+        unsigned int reinit_flag        : 1;
+        unsigned int is_bad_cw          : 1;
+    };
+
+    struct Retx_adsl_ppe_intf_rec {
+
+        unsigned int local_time         : 8;
+        unsigned int res1_1             : 5;
+        unsigned int is_last_cw         : 1;
+        unsigned int reinit_flag        : 1;
+        unsigned int is_bad_cw          : 1;
+
+        unsigned int dtu_sid            : 8;
+        unsigned int dtu_timestamp      : 8;
+
+    };
+
+    struct Retx_mode_cfg {
+        unsigned int    res0            :8;
+        unsigned int    invld_range     :8;     //  used for rejecting the too late arrival of the retransmitted DTU
+        unsigned int    buff_size       :8;     //  the total number of cells in playout buffer is 32 * buff_size
+        unsigned int    res1            :7;
+        unsigned int    retx_en         :1;
+      };
+
+    struct Retx_Tsync_cfg {
+        unsigned int    fw_alpha        :16;    //  number of consecutive HEC error cell causes that the cell delineation state machine transit from SYNC to HUNT (0 means never)
+        unsigned int    sync_inp        :16;    //  reserved
+    };
+
+    struct Retx_Td_cfg {
+        unsigned int    res0            :8;
+        unsigned int    td_max          :8;    //  maximum delay between the time a DTU is first created at transmitter and the time the DTU is sent out of ReTX layer at receiver
+        unsigned int    res1            :8;
+        unsigned int    td_min          :8;     //  minimum delay between the time a DTU is first created at transmitter and the time the DTU is sent out of ReTX layer at receiver
+    };
+
+    struct Retx_MIB_Timer_cfg {
+        unsigned int    ticks_per_sec   : 16;
+        unsigned int    tick_cycle      : 16;
+    };
+
+    struct DTU_stat_info {
+        unsigned int complete           : 1;
+        unsigned int bad                : 1;
+        unsigned int res0_0             : 14;
+        unsigned int time_stamp         : 8;
+        unsigned int cell_cnt           : 8;
+
+        unsigned int dtu_rd_ptr         : 16;
+        unsigned int dtu_wr_ptr         : 16;
+    };
+
+    struct Retx_ctrl_field {
+        unsigned int res0               : 1;
+
+        unsigned int l2_drop            : 1;
+        unsigned int res1               : 13;
+        unsigned int retx               : 1;
+
+        unsigned int dtu_sid            : 8;
+        unsigned int cell_sid           : 8;
+    };
+
+  #else
+    #error Little Endian is not supported yet.
+  #endif
+
+  struct dsl_param {
+    unsigned int    update_flag;            //  00
+    unsigned int    res0;                   //  04
+    unsigned int    MinDelayrt;             //  08
+    unsigned int    MaxDelayrt;             //  0C
+    unsigned int    res1;                   //  10
+    unsigned int    res2;                   //  14
+    unsigned int    RetxEnable;             //  18
+    unsigned int    ServiceSpecificReTx;    //  1C
+    unsigned int    res3;                   //  20
+    unsigned int    ReTxPVC;                //  24
+    unsigned int    res4;                   //  28
+    unsigned int    res5;                   //  2C
+    unsigned int    res6;                   //  30
+    unsigned int    res7;                   //  34
+    unsigned int    res8;                   //  38
+    unsigned int    res9;                   //  3C
+    unsigned int    res10;                  //  40
+    unsigned int    res11;                  //  44
+    unsigned int    res12;                  //  48
+    unsigned int    res13;                  //  4C
+    unsigned int    RxDtuCorruptedCNT;      //  50
+    unsigned int    RxRetxDtuUnCorrectedCNT;//  54
+    unsigned int    RxLastEFB;              //  58
+    unsigned int    RxDtuCorrectedCNT;      //  5C
+  };
+#endif
+
+
+
+#endif  //  IFXMIPS_ATM_FW_REGS_COMMON_H
diff --git a/drivers/atm/lantiq/ltqmips_atm_fw_regs_vr9.h b/drivers/atm/lantiq/ltqmips_atm_fw_regs_vr9.h
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/ltqmips_atm_fw_regs_vr9.h
@@ -0,0 +1,59 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_atm_fw_regs_vr9.h
+** PROJECT      : UEIP
+** MODULES     	: ATM (ADSL)
+**
+** DATE         : 1 AUG 2005
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : ATM Driver (Firmware Registers)
+** COPYRIGHT    : 	Copyright (c) 2006
+**			Infineon Technologies AG
+**			Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+**  4 AUG 2005  Xu Liang        Initiate Version
+** 23 OCT 2006  Xu Liang        Add GPL header.
+**  9 JAN 2007  Xu Liang        First version got from Anand (IC designer)
+*******************************************************************************/
+
+
+
+#ifndef IFXMIPS_ATM_FW_REGS_VR9_H
+#define IFXMIPS_ATM_FW_REGS_VR9_H
+
+
+
+/*
+ *  Host-PPE Communication Data Address Mapping
+ */
+#define FW_VER_ID                               ((volatile struct fw_ver_id *)      SB_BUFFER(0x2001))
+#define CFG_WRX_HTUTS                           SB_BUFFER(0x2010)   /*  WAN RX HTU Table Size, must be configured before enable PPE firmware.   */
+#define CFG_WRX_QNUM                            SB_BUFFER(0x2011)   /*  WAN RX Queue Number */
+#define CFG_WRX_DCHNUM                          SB_BUFFER(0x2012)   /*  WAN RX DMA Channel Number, no more than 8, must be configured before enable PPE firmware.   */
+#define CFG_WTX_DCHNUM                          SB_BUFFER(0x2013)   /*  WAN TX DMA Channel Number, no more than 16, must be configured before enable PPE firmware.  */
+#define CFG_WRDES_DELAY                         SB_BUFFER(0x2014)   /*  WAN Descriptor Write Delay, must be configured before enable PPE firmware.  */
+#define WRX_DMACH_ON                            SB_BUFFER(0x2015)   /*  WAN RX DMA Channel Enable, must be configured before enable PPE firmware.   */
+#define WTX_DMACH_ON                            SB_BUFFER(0x2016)   /*  WAN TX DMA Channel Enable, must be configured before enable PPE firmware.   */
+#define WRX_HUNT_BITTH                          SB_BUFFER(0x2017)   /*  WAN RX HUNT Threshold, must be between 2 to 8.  */
+#define WRX_QUEUE_CONFIG(i)                     ((struct wrx_queue_config*)         SB_BUFFER(0x4C00 + (i) * 20))   /*  i < 16  */
+#define WRX_DMA_CHANNEL_CONFIG(i)               ((struct wrx_dma_channel_config*)   SB_BUFFER(0x4F80 + (i) * 7))    /*  i < 8   */
+#define WTX_PORT_CONFIG(i)                      ((struct wtx_port_config*)          SB_BUFFER(0x4FB8 + (i)))        /*  i < 2   */
+#define WTX_QUEUE_CONFIG(i)                     ((struct wtx_queue_config*)         SB_BUFFER(0x3A00 + (i) * 27))   /*  i < 16  */
+#define WTX_DMA_CHANNEL_CONFIG(i)               ((struct wtx_dma_channel_config*)   SB_BUFFER(0x3A01 + (i) * 27))   /*  i < 16  */
+#define WAN_MIB_TABLE                           ((struct wan_mib_table*)            SB_BUFFER(0x4EF0))
+#define HTU_ENTRY(i)                            ((struct htu_entry*)                SB_BUFFER(0x26A0 + (i)))        /*  i < 32  */
+#define HTU_MASK(i)                             ((struct htu_mask*)                 SB_BUFFER(0x26C0 + (i)))        /*  i < 32  */
+#define HTU_RESULT(i)                           ((struct htu_result*)               SB_BUFFER(0x26E0 + (i)))        /*  i < 32  */
+
+#define UTP_CFG                                 SB_BUFFER(0x2018)   //  bit 0~3 - 0x0F: in showtime, 0x00: not in showtime
+
+
+
+#endif  //  IFXMIPS_ATM_FW_REGS_VR9_H
diff --git a/drivers/atm/lantiq/ltqmips_atm_fw_vr9.h b/drivers/atm/lantiq/ltqmips_atm_fw_vr9.h
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/ltqmips_atm_fw_vr9.h
@@ -0,0 +1,427 @@
+#ifndef IFXMIPS_ATM_FW_VR9_H
+#define IFXMIPS_ATM_FW_VR9_H
+
+
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_atm_fw_vr9.h
+** PROJECT      : UEIP
+** MODULES     	: ATM (ADSL)
+**
+** DATE         : 22 OCT 2007
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : ATM Driver (PP32 Firmware)
+** COPYRIGHT    : 	Copyright (c) 2006
+**			Infineon Technologies AG
+**			Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 22 OCT 2007  Xu Liang        Initial Version, v00.01
+*******************************************************************************/
+
+
+#define VER_IN_FIRMWARE         1
+
+#define ATM_FW_VER_MAJOR        0
+#define ATM_FW_VER_MINOR        24
+
+
+static u32 firmware_binary_code[] = {
+    0x800004B8, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x8000FFE0, 0x00000000, 0x00000000, 0x00000000,
+    0xC1000002, 0xD90C00F8, 0xC2000002, 0xDA0800F9, 0x80004390, 0xC2000000, 0xDA0800F9, 0x80003A10,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x800039C8, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x80004B60, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x800038C8, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0xC0400000, 0xC000ABC0, 0xC88400F8, 0x80004050, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0xC0400002, 0xC000ABC0, 0xC88400F8, 0x80003FD0, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0xC3C00004, 0xDBC800F9, 0xC10C0002, 0xD90C00F8, 0x8000FEE0, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0xC10E0002, 0xD90C00F8, 0xC0004028, 0xC84000F8, 0x80004000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0xC3E1FFFE, 0x597DFFFE, 0x593DFE14, 0x900004D9, 0x00000000, 0x00000000, 0x00000000, 0x90CC0481,
+    0x00000000, 0x00000000, 0x00000000, 0xC3C00000, 0xDBC800F9, 0xC1400008, 0xC1900000, 0x71588000,
+    0x14100100, 0xC140000A, 0xC1900002, 0x71588000, 0x14100100, 0xC140000C, 0xC1900004, 0x71588000,
+    0x14100100, 0xC1400004, 0xC1900006, 0x71588000, 0x14100100, 0xC1400006, 0xC1900008, 0x71588000,
+    0x14100100, 0xC140000E, 0xC190000A, 0x71588000, 0x14100100, 0xC1400000, 0xC190000C, 0x71588000,
+    0x14100100, 0xC1400002, 0xC190000E, 0x71588000, 0x14100100, 0xC0400000, 0xC11C0000, 0xC000E82C,
+    0xCD05CE00, 0xC11C0002, 0xC000E82C, 0xCD05CE00, 0xC0400002, 0xC11C0000, 0xC000E82C, 0xCD05CE00,
+    0xC11C0002, 0xC000E82C, 0xCD05CE00, 0xC000E824, 0x00000000, 0xCBC000F9, 0xCB8000F9, 0xCB4000F9,
+    0xCB0000F8, 0xC000ABE4, 0x5BFC4000, 0xCFC000F9, 0x5BB84000, 0xCF8000F9, 0x5B744000, 0xCF4000F9,
+    0x5B304000, 0xCF0000F8, 0xC000EA10, 0x00000000, 0xCBC000F9, 0xCB8000F8, 0xC000ABE0, 0x5BFC4000,
+    0xCFC000F9, 0x5BB84000, 0xCF8000F8, 0xC30001FE, 0xC000F416, 0xCF0000F8, 0xC3000000, 0x7F018000,
+    0xC000E42E, 0xCF0000F8, 0xC000E40E, 0xCF0000F8, 0xC3C1FFFE, 0xC000690E, 0xCFC00078, 0xC000692C,
+    0xCFC00078, 0xC0006924, 0xCFC00038, 0xC0006912, 0xCFC00038, 0xC0006966, 0xCFC00038, 0xC0006968,
+    0xCFC00078, 0xC000696A, 0xCFC00078, 0xC3C00000, 0xC2800020, 0xC3000000, 0x7F018000, 0x6FF88000,
+    0x6FD44000, 0x4395C000, 0x5BB89800, 0x5838000A, 0xCF0000F8, 0x5BFC0002, 0xB7E8FFC8, 0x00000000,
+    0xC3C00000, 0xC2800010, 0x6FF86000, 0x47BDC000, 0x5BB89F00, 0xC3400000, 0x58380004, 0xCB420078,
+    0x00000000, 0x58380008, 0xCF400078, 0x5BFC0002, 0xB7E8FFB0, 0x00000000, 0xC3C00000, 0xC2800020,
+    0xC348001E, 0xC3000000, 0x7F018000, 0x6FF8A000, 0x6FD44000, 0x4795C000, 0x47BDC000, 0x5BB87400,
+    0x58380008, 0xCF408418, 0x5838000A, 0xCF0000F8, 0x5BFC0002, 0xB7E8FFB0, 0x00000000, 0x00000000,
+    0xC3E0E282, 0x5BFC0030, 0xC0004002, 0xCFC000F8, 0xC000E82C, 0xC11E0002, 0xCD01EF00, 0xC000E82E,
+    0xCD01EF00, 0x00000000, 0xC121FFFE, 0x5911FE94, 0x14100000, 0x80000028, 0x00000000, 0x80001CB8,
+    0x00000000, 0x8000FFE0, 0xC0006918, 0xD28000F8, 0xC2000000, 0xDF600038, 0x5E600020, 0x84000272,
+    0x00000000, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0xC000402A, 0xCA0000F8, 0xC0006912,
+    0xCA4000F8, 0xC0006924, 0xCA8000F8, 0xC0006966, 0xCAC000F8, 0x00000000, 0xC121FFFE, 0x5911FE94,
+    0x14100000, 0x76250000, 0x76290000, 0x762D0000, 0x840001CA, 0xC0006918, 0xCA4000F8, 0xC28001FE,
+    0x76290000, 0x5A640002, 0x6A254010, 0x5EE80000, 0x8400001A, 0x6AA54000, 0x80000010, 0xC62800F8,
+    0x62818008, 0xC0006918, 0xCF0000F8, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0xC0006966,
+    0xCA4000F8, 0xC2000002, 0x6A310000, 0x7E010000, 0x76612000, 0xCE4000F8, 0x00000000, 0xC121FFFE,
+    0x5911FE94, 0x14100000, 0x6F346000, 0x4771A000, 0x5B749F00, 0xC2800000, 0x58340006, 0xCA800078,
+    0xC2C00000, 0x58340000, 0xCAC000D8, 0xC2400000, 0x5834000A, 0xCA420078, 0x6EA82000, 0x42E9E000,
+    0x6F2CA000, 0x42E56000, 0x5AEC3200, 0xC3990040, 0xC7381C18, 0xC6F80060, 0x99005560, 0xDB9800F8,
+    0xDBD800F9, 0x00000000, 0xDEA000F8, 0x46310000, 0x8400FD80, 0xC0006958, 0xC84000F8, 0x00000000,
+    0xC3C00002, 0x787C2000, 0xCC4000F8, 0xC000ABC8, 0xCB8400F8, 0xC000ABC4, 0xC88400F8, 0x5FB80000,
+    0x8400FCFA, 0xC000FAC0, 0xCA0400F8, 0x00000000, 0x00000000, 0xA6040070, 0xC000ABE4, 0xC80400F8,
+    0x6C908000, 0x45088000, 0x45088000, 0x40100000, 0xCA0000F8, 0xC42400F8, 0x00000000, 0x98C05CD8,
+    0xC000697C, 0xCA0000F8, 0x59640004, 0xC0004030, 0xCA0000F8, 0xC2400002, 0x6A452000, 0x76250000,
+    0x8400FC3A, 0xC000ABE8, 0xC80400F8, 0x00000000, 0x00000000, 0x40080000, 0xCA0000F8, 0xC42400F8,
+    0x00000000, 0xA63C17DA, 0x00000000, 0xC000ABE4, 0xC80400F8, 0x6C908000, 0x45088000, 0x45088000,
+    0x40100000, 0xCA0000F8, 0xC42400F8, 0x00000000, 0xC0006934, 0xCE0000F8, 0xC2800002, 0xC4681C08,
+    0xC62821D0, 0xC2600010, 0x5A650D80, 0xC0004020, 0xCB4000F8, 0xC2200400, 0x5A200D40, 0xC7601040,
+    0xC000F220, 0xCE8000F8, 0xC000F200, 0xCE4000F8, 0xC000F202, 0xCE0000F8, 0xC000F240, 0xCB4000F8,
+    0x00000000, 0x00000000, 0xA754FFE0, 0xC2000000, 0xC7600040, 0xA7520042, 0x00000000, 0x00000000,
+    0x99005FD8, 0xC0009DE2, 0xC94000F8, 0xC1800002, 0x80001680, 0x58204DC0, 0xC2000000, 0xCA000018,
+    0xC2400000, 0xCA414000, 0xC2800000, 0xCA812000, 0xC2C00000, 0xCAC20018, 0xC0006938, 0xCE0000F8,
+    0xC0006920, 0xCE4000F8, 0xC0006916, 0xCE8000F8, 0xC0006922, 0xCEC000F8, 0xA6400540, 0x00000000,
+    0xC0006938, 0xCBC000F8, 0x00000000, 0xC3800000, 0x6FF48000, 0x6FD44000, 0x4355A000, 0x5B749800,
+    0x58340000, 0xCB802010, 0x00000000, 0xC2000000, 0x6FB46000, 0x4779A000, 0x5B749F00, 0x5834000C,
+    0xCA000020, 0xC000691A, 0xCF8000F8, 0x5E200000, 0x8400046A, 0xC2000000, 0xDF610048, 0x5E6001E8,
+    0x8800FFE8, 0xC2000002, 0xC2400466, 0xC2A00000, 0x5AA80000, 0xC000F006, 0xCE0000F8, 0xC000F008,
+    0xCE4000F8, 0xC000F00A, 0xCE8000F8, 0x99004FA0, 0xC1A0FFFE, 0xC000E824, 0xC9840070, 0xC0006934,
+    0xCA4000F8, 0xC2000000, 0xC2800002, 0x99004FE0, 0xDA9800F8, 0xC61400F8, 0xC65800F8, 0xC161FFFE,
+    0x5955FFFE, 0x14140000, 0x00000000, 0x990050C8, 0xC000691A, 0xC94000F8, 0x00000000, 0x00000000,
+    0xC121FFFE, 0x5911FE94, 0x14100000, 0xC0006922, 0xCA001118, 0xC3C00000, 0xC3800000, 0xC0006930,
+    0xCE023118, 0xC0006932, 0xCBC000D8, 0xC2800000, 0xC000691E, 0xCFC000F8, 0xC000ABDE, 0xCA800060,
+    0xC3A0001A, 0x5BB94000, 0xC6B80060, 0xC000691C, 0xCF8000F8, 0x99005338, 0xC000691C, 0xC1400000,
+    0xC9420048, 0x00000000, 0x00000000, 0x00000000, 0xA8E2FFE8, 0xC2000000, 0xC1220002, 0xD90C00F8,
+    0xDF600038, 0x5E600020, 0x8400FFF2, 0xC000691C, 0xCA0000F8, 0xC000691E, 0xCA4000F8, 0x00000000,
+    0x00000000, 0x99005560, 0xDA1800F8, 0xDA5800F9, 0x00000000, 0xC2000000, 0xDF610048, 0x5E6001FE,
+    0x8800FFE8, 0xC0006916, 0xCA8000F8, 0xC2C00000, 0xDFEC0048, 0xC2400000, 0x466D2000, 0x8400004A,
+    0x5EA80000, 0x8400003A, 0xC2600002, 0x99005FD8, 0xC0009DEE, 0xC94000F8, 0xC1800002, 0x80000030,
+    0xC2600000, 0x99005FD8, 0xC0009DEC, 0xC94000F8, 0xC1800002, 0xC2000068, 0xC6240078, 0xC0006930,
+    0xCE400080, 0xC000691A, 0xC98000F8, 0xC000ABDE, 0xC94000F8, 0x6D9C6000, 0x45D8E000, 0x59DC9F00,
+    0x990053C0, 0xD95800F8, 0xD99800F9, 0xD9D400F8, 0x99005338, 0xC000691C, 0xC1400000, 0xC9420048,
+    0xC2000000, 0xDF600038, 0x5E600020, 0x8400FFEA, 0x00000000, 0xC000691C, 0xCA0000F8, 0xC000691E,
+    0xCA4000F8, 0x00000000, 0x00000000, 0x99005560, 0xDA1800F8, 0xDA5800F9, 0x00000000, 0x800010E8,
+    0x00000000, 0x99005FD8, 0xC0009DEA, 0xC94000F8, 0xC1800002, 0x800010B8, 0xC0006938, 0xCBC000F8,
+    0x00000000, 0x00000000, 0x6FF88000, 0x6FD44000, 0x4395C000, 0x5BB89800, 0x58380008, 0xCA0000F8,
+    0x00000000, 0x00000000, 0xA6000382, 0x00000000, 0xC0006938, 0xCBC000F8, 0xC3000000, 0x00000000,
+    0x6FF88000, 0x6FD44000, 0x4395C000, 0x5BB89800, 0x58380000, 0xCB002010, 0xC2000000, 0x58380008,
+    0xCA020078, 0x5838000C, 0xCAC000F8, 0x5838000E, 0xCA4000F8, 0xC000691A, 0xCF0000F8, 0xC0006930,
+    0xCEC000F8, 0xC000693C, 0xCE0000F8, 0xC0006932, 0xCE4000F8, 0x5E200000, 0x84000120, 0xC2800000,
+    0xA6FE00BA, 0x6F206000, 0x46310000, 0x5A209F00, 0x5820000C, 0xCA800020, 0x00000000, 0x00000000,
+    0x5EA80000, 0x840001F2, 0x00000000, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0x990050C8,
+    0xC000691A, 0xC94000F8, 0x00000000, 0x00000000, 0xC121FFFE, 0x5911FE94, 0x14100000, 0xC0006930,
+    0xCAC000F8, 0xC0006932, 0xCA4000F8, 0xC7EC1118, 0xC0006930, 0xCEC000F8, 0x5838000C, 0xCEC000F8,
+    0x58000002, 0xCE4000F8, 0xC0006934, 0xCA0000F8, 0xC2400002, 0x6E642000, 0x6E642000, 0x76612000,
+    0x8400002A, 0xC2400002, 0x6E684000, 0x58380008, 0xCE804200, 0xA6000020, 0x6E682000, 0x58380008,
+    0xCE802100, 0xC2400002, 0x6E642000, 0x76612000, 0x840000EA, 0x58380008, 0xCA0000F8, 0xC2800000,
+    0xC2400000, 0xA60200C0, 0xDBA800F8, 0x6F386000, 0x47B1C000, 0x5BB89F00, 0x58380004, 0xCA400078,
+    0x58380002, 0xCA800078, 0x00000000, 0xDEB800F8, 0x46A54000, 0x88000060, 0x00000000, 0xC0009DE4,
+    0xCA0000F8, 0xC2400002, 0x6E640000, 0x5A200002, 0xCE0000F8, 0x58380008, 0xCE400000, 0x80000018,
+    0x00000000, 0x80000048, 0xC0006934, 0xCA0000F8, 0x00000000, 0x00000000, 0xA6020C6A, 0x00000000,
+    0x00000000, 0x80000C98, 0xC2800000, 0xC2000080, 0xC240001A, 0xDF690048, 0x46294000, 0x46A54000,
+    0x8800FFD2, 0xC2000006, 0xC2600982, 0x5A643B6E, 0x5838000A, 0xCA8000F8, 0xC000F006, 0xCE0000F8,
+    0xC000F008, 0xCE4000F8, 0xC000F00A, 0xCE8000F8, 0x99004FA0, 0xC1A0FFFE, 0xC000E824, 0xC9840070,
+    0xC2000000, 0xC0006930, 0xCA02E008, 0x58380026, 0xCA4000F8, 0x00000000, 0xC2800000, 0x99004FE0,
+    0xDA9800F8, 0xC61400F8, 0xC65800F8, 0xC0006934, 0xCA0000F8, 0x00000000, 0x00000000, 0xA6020022,
+    0x00000000, 0x00000000, 0x80000318, 0xC0006938, 0xCBC000F8, 0xC000ABE4, 0xC80400F8, 0x6C908000,
+    0x45088000, 0x45088000, 0x40100000, 0xCA0000F8, 0xC42400F8, 0x00000000, 0x58240018, 0xCA0000F8,
+    0x6FF88000, 0x6FD44000, 0x4395C000, 0x5BB89800, 0xC3000000, 0xC3400002, 0xC2C00000, 0xC62C0078,
+    0xC6270038, 0xC0006940, 0xCE400038, 0xC6260038, 0xC0006942, 0xCE400038, 0xC000693C, 0xCA0000F8,
+    0x5EEC0000, 0x8400018A, 0x5A6C0010, 0x46254000, 0x88000190, 0x5A600052, 0x46E54000, 0x88000178,
+    0x58380006, 0xCA8000F8, 0xC0006940, 0xCA0000F8, 0xC2400000, 0xC6A70038, 0x7E412000, 0x76612000,
+    0xC2000000, 0xC6A10038, 0x46250000, 0x84000138, 0xC0006942, 0xCA0000F8, 0xC2400000, 0xC6A60038,
+    0x7E412000, 0x76612000, 0xC2000000, 0xC6A00038, 0x58380002, 0xCA8000F8, 0x46250000, 0x840000E8,
+    0xC2400000, 0xC6A60078, 0x466D0000, 0x880000DA, 0xC2400000, 0xC6A40078, 0x58380008, 0xCA8000F8,
+    0x46E50000, 0x880000BA, 0x00000000, 0xA6820018, 0x00000000, 0xC7700B00, 0xA6840098, 0x00000000,
+    0xC7700A00, 0x80000080, 0xC7700200, 0xC000693C, 0xCAC000F8, 0x80000060, 0xC7700300, 0xC000693C,
+    0xCAC000F8, 0x80000040, 0xC7700900, 0x80000030, 0xC7700800, 0x80000020, 0xC7700700, 0x80000010,
+    0xC7700500, 0xC0006944, 0xCF0000F8, 0xC000693E, 0xCEC000F8, 0xC0006938, 0xCA4000F8, 0xC000693C,
+    0xCB8000F8, 0xC000693E, 0xCB4000F8, 0xC3000000, 0x6E608000, 0x6E544000, 0x42150000, 0x5A209800,
+    0x5AA00008, 0x58200004, 0xCB000078, 0xC0006934, 0xCA0000F8, 0xC2400000, 0xC0006930, 0xCA42E008,
+    0xC3C00018, 0xA6020098, 0x00000000, 0x43656000, 0x47AD0000, 0x88000050, 0x46F96000, 0x6EE04010,
+    0x5BE00004, 0xC2000000, 0xC6E00008, 0x5E200000, 0x84000042, 0x5BFC0002, 0x80000030, 0xC3C00004,
+    0x5A2C0008, 0x47A10000, 0x88000012, 0x5FB80008, 0x6FE04000, 0x42390000, 0x47212000, 0x88000068,
+    0xC2400000, 0xC0006930, 0xCA42E008, 0xC2060002, 0xC68000F8, 0xCE006300, 0x6FE04000, 0x4721C000,
+    0x5F700010, 0x4765A000, 0xC2000000, 0xC6340008, 0xC25A000A, 0xC000691A, 0xCA401C18, 0xC2800000,
+    0xC0006932, 0xCA8000D8, 0xC000ABDE, 0xCA400060, 0x6FA04010, 0x42290000, 0xC000691E, 0xCE0000F8,
+    0xC7E41048, 0xC000691C, 0xCE4000F8, 0x6FE04000, 0x43A1C000, 0xC000693C, 0xCF8000F8, 0xC000693E,
+    0xCF4000F8, 0xC000693A, 0xCFC000F8, 0x80000008, 0x00000000, 0x00000000, 0x00000000, 0xC2000000,
+    0xDCE000F8, 0xA622FFD8, 0xC1220002, 0xD90C00F8, 0xC0006938, 0xCBC000F8, 0xC0006944, 0xCB4000F8,
+    0xC000ABDE, 0xCB0000F8, 0xC0006934, 0xCA0000F8, 0x6FF88000, 0x6FD44000, 0x4395C000, 0x5BB89800,
+    0xA6020268, 0xC2400000, 0x58380008, 0xCA406000, 0xDFE800F8, 0xC2218E08, 0x5A21BAF6, 0x46A14000,
+    0x84000022, 0xC2080002, 0x7361A000, 0x80000058, 0x5E640000, 0x84000022, 0xC20C0002, 0x7361A000,
+    0x80000030, 0xC2000000, 0xC760E710, 0xC7604218, 0x5E200000, 0x84000272, 0xC2200002, 0xC0006930,
+    0xCE021000, 0x99005FD8, 0xC0009DE8, 0xC94000F8, 0xC1800002, 0x58380000, 0xCA0000F8, 0x00000000,
+    0x00000000, 0xA6000132, 0xC0006940, 0xCA8000F8, 0xC0006942, 0xCA4000F8, 0xC7600078, 0xC6A01838,
+    0xC6601038, 0xC000693A, 0xCA4000F8, 0xC0006934, 0xCA8000F8, 0xC000AB40, 0x40300000, 0x40240000,
+    0x5C000004, 0x5EC0ABC0, 0x88000012, 0x5C000080, 0xCE0000F8, 0x58000002, 0x5EC0ABC0, 0x88000012,
+    0x5C000080, 0xCE8000F8, 0xC000693E, 0xCA0000F8, 0xC2400000, 0x5838000C, 0xCE4000F8, 0x99005FD8,
+    0xC0009DF0, 0xC94000F8, 0xC61800F8, 0xC0006930, 0xC6100078, 0xCD000078, 0x800000A8, 0xC2400002,
+    0x58380008, 0xCE400000, 0xC0006944, 0xCF4000F8, 0x80000278, 0xC000693C, 0xCA4000F8, 0xDFE800F8,
+    0x5A300018, 0xC000AB40, 0x40200000, 0xCA0000F8, 0x58380008, 0xC6501078, 0xCD021078, 0x5838000A,
+    0xCE8000F8, 0x58380026, 0xCE0000F8, 0xC0006944, 0xCF4000F8, 0x99005338, 0xC000691C, 0xC1400000,
+    0xC9420048, 0x80000038, 0x00000000, 0x99005FD8, 0xC0009DE6, 0xC94000F8, 0xC1800002, 0x8000FDD8,
+    0xC2000000, 0xC2400020, 0xDF600038, 0xB624FFEA, 0xC000691C, 0xCA4000F8, 0xC000691E, 0xCA8000F8,
+    0x99005560, 0xDA5800F8, 0xDA9800F9, 0x00000000, 0xC0006934, 0xCA0000F8, 0x00000000, 0xC2800000,
+    0xA6020160, 0xC2400004, 0xC2000080, 0xDF690048, 0x46294000, 0x46A54000, 0x8800FFDA, 0x00000000,
+    0xC000691A, 0xC98000F8, 0xC000ABDE, 0xC94000F8, 0x6D9C6000, 0x45D8E000, 0x59DC9F00, 0x990053C0,
+    0xD95800F8, 0xD99800F9, 0xD9D400F8, 0x99005338, 0xC000691C, 0xC1400000, 0xC9420048, 0xC2000000,
+    0xC2400020, 0xDF600038, 0xB624FFEA, 0xC000691C, 0xCA4000F8, 0xC000691E, 0xCA8000F8, 0x99005560,
+    0xDA5800F8, 0xDA9800F9, 0x00000000, 0x58380008, 0xCA4000F8, 0xC2000000, 0xCE000018, 0xC2A1FFFE,
+    0x5AA9FFFE, 0xCE021078, 0x5838000A, 0xCE8000F8, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000,
+    0xC000E838, 0xC2500002, 0xCE450800, 0xC000ABC8, 0xCB8400F8, 0xC2000000, 0xC000E82C, 0xCA040038,
+    0x5FB80002, 0xC000ABC8, 0xCF8400F8, 0x58880002, 0xB6080018, 0x00000000, 0xC0800000, 0xC000ABC4,
+    0xCC8400F8, 0x00000000, 0xC121FFFE, 0x5911FE94, 0x14100000, 0x8000E350, 0xC2000000, 0xDF600038,
+    0x5E200020, 0x8400026A, 0x00000000, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0xC000402C,
+    0xCA0000F8, 0xC0006910, 0xCA4000F8, 0xC000692C, 0xCA8000F8, 0xC0006968, 0xCAC000F8, 0x00000000,
+    0xC121FFFE, 0x5911FE94, 0x14100000, 0x76250000, 0x76290000, 0x76E16000, 0x840001C2, 0xC0006926,
+    0xCA4000F8, 0xC201FFFE, 0x76E16000, 0x5A640002, 0x6AE50010, 0x5F200000, 0x8400001A, 0x6A250000,
+    0x80000010, 0xC6E000F8, 0x62014008, 0xC0006926, 0xCE8000F8, 0xC161FFFE, 0x5955FFFE, 0x14140000,
+    0x00000000, 0xC0006968, 0xCA4000F8, 0xC2000002, 0x6A290000, 0x7E010000, 0x76612000, 0xCE4000F8,
+    0x00000000, 0xC121FFFE, 0x5911FE94, 0x14100000, 0x6EB4A000, 0x6E944000, 0x4755A000, 0x4769A000,
+    0x5B747400, 0x58340002, 0xC2000000, 0xCA0000D8, 0x5834002E, 0xC2400000, 0xCA400078, 0x6EB0A000,
+    0x6EBC4000, 0x473D8000, 0x47298000, 0x5B30342E, 0x5B300004, 0x6E642000, 0x4225E000, 0xC39A8024,
+    0xC7380060, 0xC6B81C18, 0x99005560, 0xDB9800F8, 0xDBD800F9, 0x00000000, 0xC2000000, 0xDF600038,
+    0x5E200020, 0x840002A2, 0x00000000, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0xC000690E,
+    0xCA0000F8, 0xC000692A, 0xCA4000F8, 0xC000696A, 0xCB0000F8, 0xC0006956, 0xCAC000F8, 0x00000000,
+    0xC121FFFE, 0x5911FE94, 0x14100000, 0x77218000, 0x77258000, 0x84000202, 0xC201FFFE, 0x77218000,
+    0x5AEC0002, 0x6B2D0010, 0x5EA00000, 0x8400001A, 0x6A2D0000, 0x80000010, 0xC72000F8, 0x62016008,
+    0xC0006956, 0xCEC000F8, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0xC000696A, 0xCA4000F8,
+    0xC2000002, 0x6A2D0000, 0x7E010000, 0x76612000, 0xCE4000F8, 0x00000000, 0xC121FFFE, 0x5911FE94,
+    0x14100000, 0x6EF4A000, 0x6ED44000, 0x4755A000, 0x476DA000, 0x5B747400, 0x5834000E, 0xC2000000,
+    0xCA0000D8, 0x58340008, 0xC2400000, 0xCA420078, 0x5834000C, 0xC2800000, 0xCA832010, 0x6E644010,
+    0x42250000, 0x4229E000, 0xC39A8008, 0x58340008, 0xCB809018, 0x58340008, 0xC2800000, 0xCA810010,
+    0x6EE0A000, 0x6EE44000, 0x46250000, 0x462D0000, 0x5A200008, 0x5A203408, 0x42290000, 0xC6380060,
+    0xC6F81C18, 0x99005560, 0xDB9800F8, 0xDBD800F9, 0x00000000, 0xC000695A, 0xC84000F8, 0x00000000,
+    0xC3C00002, 0x787C2000, 0xCC4000F8, 0xC0004030, 0xCA0000F8, 0xC2400008, 0x6A452000, 0x76250000,
+    0x84000E02, 0xC000EA28, 0xC3800000, 0xCB840038, 0xC000EA14, 0xC3400000, 0xCB440038, 0xC0009F70,
+    0xCB0400F8, 0xB7B4005A, 0x5804F802, 0xCAC000F8, 0xA7000060, 0x00000000, 0x00000000, 0xA6C8DD30,
+    0xC2800000, 0xC6E80018, 0x80000070, 0x00000000, 0x00000000, 0x00000000, 0x8000DCF8, 0x00000000,
+    0xC2800000, 0xC7282018, 0xC000690E, 0xCA4000F8, 0x6BE9E000, 0x00000000, 0x767D2000, 0x8400DCB0,
+    0x6EA0A000, 0x6E944000, 0x46150000, 0x46290000, 0x5A207400, 0x5820000C, 0xCA0000F8, 0xC0006946,
+    0xCE8000F8, 0xA6220368, 0x00000000, 0xC2200060, 0xC0006948, 0xCE000008, 0xCE021038, 0xC240000A,
+    0xC000694A, 0xCE4000F8, 0xC2B60002, 0xC0006964, 0xCE837B00, 0x99005830, 0xC0009F74, 0xC88400F8,
+    0x00000000, 0xC0006946, 0xCBC000F8, 0x00000000, 0x00000000, 0x6FF8A000, 0x6FD44000, 0x4795C000,
+    0x47BDC000, 0x5BB87400, 0x990055F0, 0xDBD800F8, 0xDB9800F9, 0x00000000, 0x99005338, 0xC000691C,
+    0xC1400000, 0xC9420048, 0xC000691C, 0x990057E8, 0xC94000F9, 0xC98000F8, 0x00000000, 0x99005560,
+    0xD95800F8, 0xD99800F9, 0x00000000, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0x99005228,
+    0xDBD800F8, 0xDB9800F9, 0xC7D800F8, 0x00000000, 0xC121FFFE, 0x5911FE94, 0x14100000, 0x6FF8A000,
+    0x6FD44000, 0x4795C000, 0x47BDC000, 0x5BB87400, 0x58380010, 0xCA0000F8, 0xC000ABE0, 0xC80400F8,
+    0x6C908000, 0x45088000, 0x45088000, 0x40100000, 0xCA4000F8, 0xC43400F8, 0x00000000, 0xC74000F8,
+    0xCE0000F8, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0xC000690E, 0xCA4000F8, 0xC2800002,
+    0x6ABD4000, 0x72692000, 0xCE4000F8, 0x00000000, 0xC121FFFE, 0x5911FE94, 0x14100000, 0x99005FD8,
+    0xC0009DF6, 0xC94000F8, 0xC1800002, 0x00000000, 0x00000000, 0x00000000, 0xA8E2FFE8, 0x00000000,
+    0xC1220002, 0xD90C00F8, 0xC2000000, 0xC000EA14, 0xCA040038, 0xC000EA28, 0xC2500002, 0xCE450800,
+    0x58880002, 0xB6080018, 0xC0009F74, 0xC0800000, 0xCC8400F8, 0x8000D900, 0xC0006946, 0xCBC000F8,
+    0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0xC000690E, 0xCA4000F8, 0xC2800002, 0x6ABD4000,
+    0x72692000, 0xCE4000F8, 0x00000000, 0xC121FFFE, 0x5911FE94, 0x14100000, 0x6FF8A000, 0x6FD44000,
+    0x4795C000, 0x47BDC000, 0x5BB87400, 0x58380008, 0xCA0000F8, 0x5838000C, 0xCA4000F8, 0xC3400000,
+    0xC6340000, 0xC000694E, 0xCF4000F8, 0xC2800000, 0xC62A0078, 0xC3000000, 0xC6308018, 0x6F304000,
+    0x43298000, 0xC000693C, 0xCF0000F8, 0xC2C00000, 0xC66C0078, 0xC0006950, 0xCEC000F8, 0xC2800000,
+    0xC66AE020, 0xC0006954, 0xCE8000F8, 0x5F740000, 0x840001A0, 0x5E300028, 0x46E12000, 0x8400016A,
+    0x46E12000, 0x88000132, 0x5E300018, 0x46E12000, 0x8800002A, 0x46E12000, 0x84000042, 0x00000000,
+    0x800000C0, 0x00000000, 0x99005970, 0xDBD800F8, 0xDB9800F9, 0xC78000F8, 0xC3400002, 0xC000694E,
+    0xCF4000F8, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000, 0xC000690E, 0xCA4000F8, 0xC2800002,
+    0x6ABD4000, 0x7E814000, 0x76692000, 0xCE4000F8, 0x00000000, 0xC121FFFE, 0x5911FE94, 0x14100000,
+    0xC2200060, 0xC0006948, 0xCE021038, 0xC2000000, 0xC000694C, 0xCE0000F8, 0x80000080, 0x00000000,
+    0x99005970, 0xDBD800F8, 0xDB9800F9, 0xC78000F8, 0x99005B70, 0xDBD800F8, 0xDB9800F9, 0xC78000F8,
+    0xC2200058, 0xC0006948, 0xCE021038, 0xC2000002, 0xC000694C, 0xCE0000F8, 0xC2000006, 0xC000F006,
+    0xCE0000F8, 0x5838000A, 0xCA4000F8, 0xC2200982, 0x5A203B6E, 0xC000F008, 0xCE0000F8, 0xC000F00A,
+    0xCE4000F8, 0xC0006954, 0xCA8000F8, 0xC200000C, 0xC000694A, 0xCE0000F8, 0xC0006948, 0xCE800008,
+    0xC2B60000, 0xC0006964, 0xCE8000F8, 0x99005830, 0xC0009F74, 0xC88400F8, 0x00000000, 0xC0006946,
+    0xCBC000F8, 0xC000694C, 0xCA0000F8, 0x6FF8A000, 0x6FD44000, 0x4795C000, 0x47BDC000, 0x5BB87400,
+    0x5E200000, 0x840000FA, 0x00000000, 0x990055F0, 0xDBD800F8, 0xDB9800F9, 0x00000000, 0x99005338,
+    0xC000691C, 0xC1400000, 0xC9420048, 0xC000691C, 0x990057E8, 0xC94000F9, 0xC98000F8, 0x00000000,
+    0x99005560, 0xD95800F8, 0xD99800F9, 0x00000000, 0xC161FFFE, 0x5955FFFE, 0x14140000, 0x00000000,
+    0x99005228, 0xDBD800F8, 0xDB9800F9, 0xC7D800F8, 0x00000000, 0xC121FFFE, 0x5911FE94, 0x14100000,
+    0xC000693C, 0xCA8000F8, 0xC000694E, 0xCAC000F8, 0xC3000018, 0xC3400006, 0x5E200000, 0x8400002A,
+    0xC2800000, 0xC2C00000, 0xC300001E, 0xC3400000, 0xC6AC1078, 0xC72C0418, 0xC76C0810, 0x58380010,
+    0xCA8000F8, 0x58380008, 0xCEC000F8, 0xC6280100, 0xC000ABE0, 0xC80400F8, 0x6C908000, 0x45088000,
+    0x45088000, 0x40100000, 0xCB0000F8, 0xC43400F8, 0x00000000, 0xC74000F8, 0xCE8000F8, 0xC0006952,
+    0xCE8000F8, 0x00000000, 0x00000000, 0x00000000, 0xA8E2FFE8, 0x00000000, 0xC000694C, 0xCA0000F8,
+    0xC0006950, 0xCAC000F8, 0x5E200000, 0x8400006A, 0xDFE800F8, 0x7E814000, 0x5834001A, 0xCE8000F8,
+    0x99005FD8, 0xC0009DF4, 0xC94000F8, 0xC1800002, 0x99005FD8, 0xC0009DF8, 0xC94000F8, 0xC6D800F8,
+    0xC1220002, 0xD90C00F8, 0x5E200000, 0x84000040, 0x5838002C, 0xCB0000F8, 0xDFE800F8, 0x00000000,
+    0x58380014, 0xCF0000F8, 0x80000018, 0xC2A1FFFE, 0x5AA9FFFE, 0x5838000A, 0xCE8000F8, 0xC3000000,
+    0xC000EA14, 0xCB040038, 0xC2D00002, 0xC000EA28, 0xCEC50800, 0xC000694E, 0xCA8000F8, 0x58880002,
+    0xB4B00018, 0xC0009F74, 0xC0800000, 0xCC8400F8, 0x5EA80000, 0x84000152, 0x5E200000, 0x84000140,
+    0xC000693C, 0xCA8000F8, 0x00000000, 0x00000000, 0x5AA80060, 0xCE8000F8, 0x99005970, 0xDBD800F8,
+    0xDB9800F9, 0xC78000F8, 0x99005B70, 0xDBD800F8, 0xDB9800F9, 0xC78000F8, 0xC0006952, 0xCAC000F8,
+    0x58380000, 0xCA8000F8, 0xC30C0002, 0xC7F00018, 0xA6800098, 0x00000000, 0x00000000, 0xC161FFFE,
+    0x5955FFFE, 0x14140000, 0x00000000, 0xC000F800, 0xCA0000F8, 0x00000000, 0x00000000, 0xA60CFFEA,
+    0xC6F00500, 0xC6B0C400, 0xCF0000F8, 0x00000000, 0xC121FFFE, 0x5911FE94, 0x14100000, 0x8000CFB0,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x8000CF48, 0xDCBC00F9, 0x5FFC0000, 0x84000052,
+    0xC3800002, 0xDB8800F9, 0x5FFC0004, 0x8400C86A, 0xC3800000, 0xDB8800F9, 0xC3CE0002, 0xC000E800,
+    0xCFC0E700, 0xC3E1FFFE, 0x597DFFFE, 0x593DFE14, 0x94000001, 0x00000000, 0x00000000, 0x00000000,
+    0xC000ABE8, 0xC80400F8, 0x00000000, 0x00000000, 0x40080000, 0xCBC000F8, 0xC43800F8, 0x00000000,
+    0xC000402E, 0xCA0000F8, 0xC000ABD8, 0xCB4400F8, 0x00000000, 0x00000000, 0x47610000, 0x880000B0,
+    0x00000000, 0xA7C00048, 0xC000ABD4, 0xC1000002, 0xCD0400F8, 0xC11C0000, 0xC000E82C, 0xCD05CE00,
+    0x800000D8, 0x00000000, 0xA7D20120, 0x00000000, 0xC7E14040, 0xC2400000, 0xC6246028, 0xC200006A,
+    0x46250000, 0xC6240030, 0xC000E810, 0xCE440030, 0x8000FF70, 0xC2000000, 0xC000E808, 0xCA040010,
+    0xC11C0000, 0xC000E82C, 0xCD05CE00, 0x5A200002, 0x5E600010, 0x84000010, 0xC2000000, 0xC000E808,
+    0xCE040010, 0xC3400000, 0x80000010, 0x5B740002, 0xC000ABD8, 0xCF4400F8, 0x99004F78, 0xC000ABC8,
+    0xC94400F8, 0xC1800000, 0xC11C0002, 0xC000E82C, 0xCD05CE00, 0x80000600, 0x5B740002, 0xC000ABD8,
+    0xCF4400F8, 0xC78000F8, 0xC13C0002, 0xCD03DE00, 0xC000ABC8, 0xC94400F8, 0xC1800000, 0xC000E82C,
+    0xC9840038, 0x59540002, 0xC000ABC8, 0xCD4400F8, 0x58880002, 0xB4980580, 0x00000000, 0xC0800000,
+    0x80000568, 0xC000ABE8, 0xC80400F8, 0x00000000, 0x00000000, 0x40080000, 0xCBC000F8, 0xC42800F8,
+    0x00000000, 0xA7C00130, 0xC000ABCC, 0xCA0400F8, 0xC2400000, 0xC000FAEC, 0xCA440018, 0x5A200002,
+    0xC000ABCC, 0xCE0400F8, 0xB624008A, 0xC68000F8, 0xC13C0002, 0xCD03DE00, 0xC000ABC8, 0xC94400F8,
+    0xC1800000, 0xC000E82C, 0xC9840038, 0x59540002, 0xC000ABC8, 0xCD4400F8, 0x58880002, 0xB4980470,
+    0x00000000, 0xC0800000, 0x80000458, 0xC000ABD4, 0xC1000004, 0xCD0400F8, 0xC000E820, 0xC2000002,
+    0xCE0400F8, 0xC2000000, 0xC000ABCC, 0xCE0400F8, 0xC000ABD8, 0xCE0400F8, 0x8000FF28, 0xC000ABD4,
+    0xC1000000, 0xCD0400F8, 0xC11C0000, 0xC000E82C, 0xCD05CE00, 0x99004F78, 0xC000ABC8, 0xC94400F8,
+    0xC1800000, 0xC1200000, 0xC000E818, 0xCD061000, 0xC11C0002, 0xC000E82C, 0xCD05CE00, 0xC2000000,
+    0xC000ABCC, 0xCE0400F8, 0x80000358, 0xC000FAC0, 0xCB8400F8, 0xC000ABE8, 0xC80400F8, 0x00000000,
+    0x00000000, 0x40080000, 0xCBC000F8, 0xC42800F8, 0x00000000, 0x00000000, 0xC68000F8, 0xC13C0000,
+    0xCD03DE00, 0xA780024A, 0x00000000, 0x00000000, 0xA7C0020A, 0x00000000, 0xC000FB60, 0xC2060006,
+    0xCE046308, 0xA7E801C2, 0x00000000, 0xC000ABD0, 0xCA0400F8, 0xC2400000, 0xC000FAEC, 0xCA448018,
+    0x5A200002, 0xC000ABD0, 0xCE0400F8, 0xB62400AA, 0x00000000, 0xC68000F8, 0xC13C0002, 0xCD03DE00,
+    0xC000FACC, 0xC2000002, 0xCE040000, 0xC000ABC8, 0xC94400F8, 0xC1800000, 0xC000E82C, 0xC9840038,
+    0x59540002, 0xC000ABC8, 0xCD4400F8, 0x58880002, 0xB49801C8, 0x00000000, 0xC0800000, 0x800001B0,
+    0xC000ABD4, 0xC1000000, 0xCD0400F8, 0xC11C0000, 0xC000E82C, 0xCD05CE00, 0x99004F78, 0xC000ABC8,
+    0xC94400F8, 0xC1800000, 0xC2000000, 0xC000E820, 0xCE0400F8, 0xC1200000, 0xC000E818, 0xCD061000,
+    0xC11C0002, 0xC000E82C, 0xCD05CE00, 0xC000ABD0, 0xCE0400F8, 0xC2000002, 0xC000FACC, 0xCE040008,
+    0x800000E8, 0xC2000002, 0xC000ABD0, 0xCE0400F8, 0x8000FE88, 0xC2000000, 0xC000ABD0, 0xCE0400F8,
+    0xA7E60032, 0x00000000, 0xC2000002, 0xC000FB60, 0xCE040000, 0x8000FE70, 0x00000000, 0xA7860052,
+    0x00000000, 0xC68000F8, 0xC13C0002, 0xCD03DE00, 0xC2020002, 0xC7E2A540, 0xC000FB60, 0xCE0400F8,
+    0x8000FE18, 0xC2040002, 0xC000FB60, 0xCE044200, 0x8000FDF8, 0xC2C80002, 0x6AC56000, 0xDACC00F8,
+    0xC000ABD4, 0xCB4400F8, 0xC000ABC8, 0xCB8400F8, 0xC000E838, 0xC3C00000, 0xCBC40038, 0x5EF40004,
+    0x84000022, 0xC3000000, 0xC000FACC, 0xCF042100, 0x47F98000, 0x8400002A, 0x47F98000, 0x88000030,
+    0xC1006E8C, 0x8000BCB8, 0xC000ABC0, 0xCC8400F8, 0x8000F6C8, 0xC000FAC0, 0xCAC400F8, 0xC000ABD4,
+    0xCB4400F8, 0xA6C0FBD2, 0x00000000, 0x5EF40000, 0x8400F722, 0x5EF40002, 0x8400F99A, 0x5EF40004,
+    0x8400FB9A, 0xC1006CE8, 0x8000BC30, 0x00000000, 0xC0800000, 0xDF4B0038, 0xC0006900, 0xCB8000F8,
+    0xC2000000, 0xC000690A, 0xA78000D0, 0xCBC000F8, 0xC1000000, 0xD90000F9, 0xC1000002, 0xD90C00F8,
+    0x6FF46000, 0x477DA000, 0x5B749F00, 0xC2400000, 0x58340004, 0xCA400078, 0xC0006900, 0xCE000000,
+    0x5A640002, 0x58340004, 0xC6500078, 0xCD000078, 0xC0006914, 0xCA4000F8, 0xC2000002, 0x6A3D0000,
+    0x72612000, 0xCE4000F8, 0xC000E408, 0xCE0000F8, 0xA78200D8, 0xC0006908, 0xCBC000F8, 0xC1000000,
+    0xD90000F9, 0xC1000002, 0xD90C00F8, 0x6FF4A000, 0x6FD44000, 0x4755A000, 0x477DA000, 0x5B747400,
+    0xC2800000, 0x58340006, 0xCA800078, 0xC2000000, 0xC0006900, 0xCE002100, 0x5EA80002, 0x58340006,
+    0xC6900078, 0xCD000078, 0x5A7C0020, 0xC2000002, 0x6A250000, 0xC000E408, 0xCE0000F8, 0xDCA800F9,
+    0x5EA80000, 0x8400BAA0, 0x00000000, 0xA4800230, 0x00000000, 0xC3C00000, 0xC000F418, 0xCBC00018,
+    0xC3400000, 0xC2400000, 0x6FF86000, 0x47BDC000, 0x5BB89F00, 0x58380008, 0xCB400078, 0x58380006,
+    0xCA400078, 0x5F740002, 0x58380008, 0xC7500078, 0xCD000078, 0xC2000000, 0x58380004, 0xCA020078,
+    0xC3000000, 0x5838000C, 0xCB000020, 0x5A640002, 0x46610000, 0x84000010, 0xC2400000, 0x58380006,
+    0xC6500078, 0xCD000078, 0xC2000000, 0x5838000A, 0xCA020078, 0x5B300002, 0x5838000C, 0xC7100020,
+    0xCD000020, 0xC2420020, 0x5A200004, 0x46252000, 0x84000010, 0xC2000000, 0x5838000A, 0xC6101078,
+    0xCD021078, 0xC0006966, 0xCA4000F8, 0xC2000002, 0x6A3D0000, 0x72612000, 0xCE4000F8, 0x5F740000,
+    0x84000040, 0xC0006912, 0xCA0000F8, 0xC2C00002, 0x6AFD6000, 0x7EC16000, 0x762D0000, 0xCE0000F8,
+    0x5F300020, 0x84000040, 0xC0006924, 0xCA0000F8, 0xC2C00002, 0x6AFD6000, 0x7EC16000, 0x762D0000,
+    0xCE0000F8, 0xA4820070, 0xC2400000, 0xC000F418, 0xCA408018, 0xC2000002, 0xC0006900, 0xCE000000,
+    0xC000690A, 0xCE4000F8, 0xC1000000, 0xD90000F9, 0xD8400078, 0xC1000004, 0xD90000F9, 0xA4840270,
+    0x00000000, 0xC3C00000, 0xC000F418, 0xCBC10018, 0xC2800000, 0xC2000000, 0x6FF8A000, 0x6FD44000,
+    0x4795C000, 0x47BDC000, 0x5BB87400, 0x5838002E, 0xCA800078, 0x58380006, 0xCA020078, 0xC3400000,
+    0x5838002E, 0xCB420078, 0x5AA80002, 0x46A10000, 0x84000010, 0xC2800000, 0x5838002E, 0xC6900078,
+    0xCD000078, 0x5F740002, 0x5838002E, 0xC7501078, 0xCD021078, 0xC0006968, 0xCA4000F8, 0xC2000002,
+    0x6A3D0000, 0x72612000, 0xCE4000F8, 0xC000692A, 0xCA8000F8, 0x5E740000, 0x84000040, 0xC0006910,
+    0xCA0000F8, 0xC2C00002, 0x6AFD6000, 0x7EC16000, 0x762D0000, 0xCE0000F8, 0x6ABD4010, 0xA68000BA,
+    0x00000000, 0x58380032, 0xCA0000F8, 0x58000002, 0xCA4000F8, 0x5838000C, 0x00000000, 0xCE0000F9,
+    0xCE4000F8, 0xC000692A, 0xCA0000F8, 0xC2C00002, 0x6AFD6000, 0x722D0000, 0xCE0000F8, 0xC000692C,
+    0xCA0000F8, 0xC2C00002, 0x6AFD6000, 0x722D0000, 0xCE0000F8, 0x80000040, 0xC000692C, 0xCA0000F8,
+    0xC2C00002, 0x6AFD6000, 0x7EC16000, 0x762D0000, 0xCE0000F8, 0xA4880120, 0xC2C00000, 0xC000F418,
+    0xCAC20018, 0xC000690E, 0xCA4000F8, 0xC2000002, 0x6A2D0000, 0x7E010000, 0x76612000, 0xCE4000F8,
+    0xC000696A, 0xCA4000F8, 0xC2000002, 0x6A2D0000, 0x72612000, 0xCE4000F8, 0x6EF0A000, 0x6ED44000,
+    0x47158000, 0x472D8000, 0x5B307400, 0x58300000, 0xCA0000F8, 0x00000000, 0xC2400002, 0x76612000,
+    0x8400004A, 0xC24C0002, 0xC6E40018, 0xC624C400, 0x58300010, 0xCA400500, 0x00000000, 0xC000F800,
+    0xCE4000F8, 0xA4860070, 0xC2400000, 0xC000F418, 0xCA418018, 0xC2020002, 0xC0006900, 0xCE002100,
+    0xC0006908, 0xCE4000F8, 0xC1000000, 0xD90000F9, 0xD8400078, 0xC1000004, 0xD90000F9, 0xC000F414,
+    0xCC8000F8, 0xC10E0002, 0xD90C00F8, 0x8000EDF0, 0xDFBC00F9, 0xC000696E, 0x99005C80, 0xC94000F8,
+    0xC7D800F8, 0x00000000, 0xC57000F8, 0x5EF00020, 0x88000148, 0x6F346000, 0x4771A000, 0x5B749F00,
+    0x58340008, 0xC2400000, 0xCA400078, 0x00000000, 0xC2000000, 0x5A640002, 0xCE400078, 0x58340004,
+    0xCA000078, 0x00000000, 0x00000000, 0x5E200002, 0xCE000078, 0xC0006912, 0xCA8000F8, 0xC2400002,
+    0x6A712000, 0x72A54000, 0xCE8000F8, 0x5E200000, 0x84000052, 0xC000402A, 0xCA0000F8, 0xC000E408,
+    0xCA8000F8, 0x76250000, 0x00000000, 0x72A14000, 0xCE8000F8, 0x80000038, 0xC0006914, 0xCA0000F8,
+    0x7E412000, 0x00000000, 0x76250000, 0xCE0000F8, 0x800000D0, 0x6EF4A000, 0x6ED44000, 0x4755A000,
+    0x476DA000, 0x5B747400, 0x5834002E, 0xC2400000, 0xCA420078, 0x00000000, 0xC2000000, 0x5A640002,
+    0xC6501078, 0xCD021078, 0x58340006, 0xCA000078, 0x00000000, 0x00000000, 0x5A200002, 0xCE000078,
+    0xC0006910, 0xCA4000F8, 0xC2000002, 0x6A2D0000, 0x72612000, 0xCE4000F8, 0xC2000002, 0x6A310000,
+    0xC000E42A, 0xCE0000F8, 0xC1040002, 0xD90C00F8, 0x00000000, 0x8000EB60, 0x00000000, 0xC4980928,
+    0x9D000000, 0xC5580038, 0xC000E838, 0xCD8400F8, 0xC1440080, 0xC1C06B40, 0xC55C0F80, 0xC000F00E,
+    0x9D000000, 0xCD8000F8, 0xC000F00C, 0xCDC000F8, 0xC000ABDE, 0xC9C000F8, 0x00000000, 0x00000000,
+    0xD9D800F9, 0xC000AB40, 0x401C0000, 0x5DC0ABC0, 0x88000012, 0x5C000080, 0xCD8000F8, 0xC1F0000A,
+    0x715CA000, 0xDD9800F8, 0xDD9C00F9, 0x41D8E000, 0xC5D40260, 0xC000F010, 0xCD4000F8, 0x6C9C8000,
+    0x45C8E000, 0x45C8E000, 0x59DC0004, 0xC1601260, 0xC5D40260, 0x9D000000, 0xC000F012, 0xCD4000F8,
+    0x00000000, 0x00000000, 0xD95800F8, 0x6D586000, 0x4594C000, 0x59989F00, 0xD99800F9, 0x5818000A,
+    0xC1800000, 0xC9800078, 0xC0007200, 0x6D5CA000, 0x401C0000, 0x40180000, 0xC94000F8, 0x58000002,
+    0x00000000, 0xC9C000F8, 0xC0006930, 0xCD4000F8, 0xC0006932, 0xCDC000F8, 0x59980004, 0xC1C20020,
+    0xB59C0018, 0x00000000, 0xC1800000, 0xDD9C00F9, 0x581C000A, 0xCD800078, 0x581C000C, 0xC1800000,
+    0xC9800020, 0xC1C00002, 0xDD9400F8, 0x69D4E000, 0x5D980002, 0xCD800020, 0xC0006924, 0xC98000F8,
+    0x00000000, 0x9D000000, 0x00000000, 0x719CC000, 0xCD8000F8, 0xC000692A, 0xC94000F8, 0xC1C00002,
+    0x69D8E000, 0x7DC0C000, 0x7558A000, 0xCD4000F8, 0xC000692C, 0xC94000F8, 0xDD8000F9, 0x58000032,
+    0x755CA000, 0x84000090, 0xC94000F9, 0xC98000F8, 0xDD8000F9, 0x5800000C, 0x00000000, 0xCD4000F9,
+    0xCD8000F8, 0xC000692C, 0xC94000F8, 0xC000692A, 0xC98000F8, 0x715CA000, 0xC000692C, 0xCD4000F8,
+    0x719CC000, 0xC000692A, 0xCD8000F8, 0x9D000000, 0x00000000, 0x00000000, 0x00000000, 0xC000ABDE,
+    0xC98000F8, 0x00000000, 0xC1C00080, 0x4194C000, 0x459CE000, 0x88000012, 0xC5D800F8, 0xC000ABDE,
+    0xCD8000F8, 0xC000F406, 0xC98000F8, 0xC1C00002, 0x9D000000, 0xC5D80A00, 0xC5581048, 0xCD8000F8,
+    0xC0006930, 0xC98000F8, 0xC0006932, 0xC9C000F8, 0xC140000E, 0xC5581C18, 0xDD9400F8, 0xC000AB40,
+    0x40140000, 0x5D40ABC0, 0x88000012, 0x5C000080, 0xCD8000F8, 0x58000002, 0x5D40ABC0, 0x88000012,
+    0x5C000080, 0xCDC000F8, 0xDD5400F8, 0xC1C00000, 0x58140006, 0xC9C20078, 0xC1800000, 0x58140000,
+    0xC98000D8, 0x6DDC2000, 0xC000691E, 0x41D8E000, 0xCDC000F8, 0xDD9800F8, 0xC1C00022, 0xC5D80D70,
+    0xDD9400F9, 0xC5581C18, 0xC000691C, 0xCD8000F8, 0xDD5400F8, 0xC1C00000, 0x58140006, 0xC9C20078,
+    0xC1800000, 0x58140004, 0xC9820078, 0x00000000, 0x59DC0002, 0x45D8C000, 0x84000010, 0xC1C00000,
+    0x9D000000, 0x58140006, 0xC5D81078, 0xCD821078, 0xC000ABDC, 0xC94000F8, 0xC1820020, 0xC1D00002,
+    0x5814AB00, 0xD58000F8, 0x58000002, 0xD58000F9, 0x59540004, 0xB5580018, 0xC000ABDC, 0xC1400000,
+    0xCD4000F8, 0xDD9800F9, 0x9D000000, 0xDD9400F8, 0xC000F402, 0xCDC10800, 0xC1C00000, 0xC1800080,
+    0x5D980004, 0xDF5D0048, 0x459CA000, 0x8800FFF2, 0xDD8000F9, 0x5800000C, 0x00000000, 0xC94000F9,
+    0xC98000F8, 0xC1C00002, 0xC5D43F00, 0xC5D81E00, 0xC000ABDE, 0xC9C000F8, 0x00000000, 0x00000000,
+    0x581CAB40, 0x5DC0ABC0, 0x88000012, 0x5C000080, 0xCD4000F8, 0x58000002, 0x5DC0ABC0, 0x88000012,
+    0x5C000080, 0xCD8000F8, 0xC000ABDE, 0xC9C000F8, 0x00000000, 0xC15004C0, 0xC5D40060, 0xDD9C00F8,
+    0xC5D41C18, 0xC1C00000, 0xDD8000F9, 0x58000030, 0xC9C00078, 0xDD8000F9, 0x58000002, 0xC98000F8,
+    0x6DDC2000, 0xC000691C, 0x41D8E000, 0xCD4000F9, 0xCDC000F8, 0xDD9400F9, 0xC1C00000, 0x58140030,
+    0xC9C00078, 0xC1800000, 0x58140006, 0xC9820078, 0x00000000, 0x59DC0002, 0x45D8C000, 0x84000010,
+    0xC1C00000, 0x9D000000, 0x58140030, 0xC5D80078, 0xCD800078, 0xC1C00000, 0xDF5C0038, 0x5DDC0020,
+    0x8400FFEA, 0x00000000, 0x9D000000, 0x00000000, 0x00000000, 0x00000000, 0xC160FFFE, 0xC000EA10,
+    0xC9440070, 0xC1A0FFFE, 0x59983408, 0xC000F00C, 0xCD4000F8, 0xC000F00E, 0xCD8000F8, 0xC0006964,
+    0xC98000F8, 0x00000000, 0xC170000A, 0x7158A000, 0x6C988000, 0x4588C000, 0x4588C000, 0x59980004,
+    0xC5940270, 0xC000F010, 0xCD4000F8, 0xC0006946, 0xC94000F8, 0x00000000, 0x00000000, 0x6D58A000,
+    0x6D5C4000, 0x459CC000, 0x4594C000, 0xC000694A, 0xC94000F8, 0xC0006948, 0xC9C000F8, 0x4194C000,
+    0xC1400012, 0xC55C1818, 0x9D000000, 0xC59C0268, 0xC000F012, 0xCDC000F8, 0xC1400000, 0x58000012,
+    0xC9410038, 0xC0006950, 0xC9C000F8, 0xC55800F8, 0xC5940838, 0xC5581078, 0xD99400F8, 0xC000693C,
+    0xC94000F8, 0xC0006954, 0xC98000F8, 0x59DC00A8, 0x45D4E000, 0x41D8E000, 0x5D5C0030, 0x88000010,
+    0xC1C00030, 0xC1800000, 0xC5D84028, 0xC1400000, 0xC5D40008, 0x5DD40002, 0x84000072, 0x5DD40004,
+    0x8400009A, 0x5DD40006, 0x840000C2, 0x5DD80026, 0x840000EA, 0xDD5400F8, 0xDD8000F9, 0x58000008,
+    0x40180000, 0xCD4000F8, 0x59980002, 0x8000FFC0, 0xDD5400F8, 0xDD8000F9, 0x58000008, 0x40180000,
+    0xCD4000B8, 0x59980002, 0x8000FF88, 0xDD5400F8, 0xDD8000F9, 0x58000008, 0x40180000, 0xCD400078,
+    0x59980002, 0x8000FF50, 0xDD5400F8, 0xDD8000F9, 0x58000008, 0x40180000, 0xCD400038, 0x59980002,
+    0x8000FF18, 0x00000000, 0x9D000000, 0x00000000, 0x00000000, 0x00000000, 0x58000012, 0xC94000F8,
+    0xC0006954, 0xC9C000F8, 0xC0006950, 0xC9400078, 0xDD8000F9, 0x58000028, 0x5D9C0000, 0x84000052,
+    0x5D9C0002, 0x84000052, 0x5D9C0004, 0x8400006A, 0xC55B0038, 0xC55C08B8, 0xCD800039, 0xCDC108B8,
+    0x80000060, 0xCD4000F8, 0x80000050, 0xC55900B8, 0xC55C1838, 0xCD8000B9, 0xCDC31838, 0x80000028,
+    0xC55A0078, 0xC55C1078, 0xCD800079, 0xCDC21078, 0x9D000000, 0x00000000, 0x00000000, 0x00000000,
+    0x59540002, 0x6994E018, 0x61C0C008, 0x4194A000, 0x5D940040, 0x88000012, 0xC59400F8, 0x9D000000,
+    0xCD4000F8, 0x00000000, 0x00000000, 0xC000697E, 0xCA4000F8, 0xC0000000, 0xC55800F8, 0xC9D400F9,
+    0x00000000, 0x00000000, 0x79E08000, 0xCD1800F9, 0xC5D000F8, 0xC9D400F9, 0xC66000F8, 0xC52160A0,
+    0xC5241550, 0x79E08000, 0xCD1800F9, 0xC5D000F8, 0xC9D400F9, 0xC66000F8, 0xC52160A0, 0xC5241550,
+    0x79E08000, 0xCD1800F9, 0xC5D000F8, 0xC9D400F9, 0xC66000F8, 0xC52160A0, 0xC5241550, 0x79E08000,
+    0xCD1800F9, 0xC5D000F8, 0xC9D400F9, 0xC66000F8, 0xC52160A0, 0xC5241550, 0x79E08000, 0xCD1800F9,
+    0xC5D000F8, 0xC9D400F9, 0xC66000F8, 0xC52160A0, 0xC5241550, 0x79E08000, 0xCD1800F9, 0xC5D000F8,
+    0xC9D400F9, 0xC66000F8, 0xC52160A0, 0xC5241550, 0x79E08000, 0xCD1800F9, 0xC5D000F8, 0xC9D400F9,
+    0xC66000F8, 0xC52160A0, 0xC5241550, 0x79E08000, 0xCD1800F9, 0xC5D000F8, 0xC9D400F9, 0xC66000F8,
+    0xC52160A0, 0xC5241550, 0x79E08000, 0xCD1800F9, 0xC5D000F8, 0xC9D400F9, 0xC66000F8, 0xC52160A0,
+    0xC5241550, 0x79E08000, 0xCD1800F9, 0xC5D000F8, 0xC9D400F9, 0xC66000F8, 0xC52160A0, 0xC5241550,
+    0x79E08000, 0xCD1800F9, 0xC5D000F8, 0xC9D400F9, 0xC66000F8, 0xC52160A0, 0xC5241550, 0x79E08000,
+    0xCD1800F9, 0xC5D000F8, 0xC9D400F9, 0xC66000F8, 0xC52160A0, 0xC5241550, 0xC000697C, 0x9CC00000,
+    0xCE0000F8, 0xC000697E, 0xCE4000F8, 0x9D000000, 0x4158A000, 0xCD4000F8, 0x00000000,
+};
+
+static u32 firmware_binary_data[] = {
+};
+
+
+#endif  //  IFXMIPS_ATM_FW_VR9_H
+
diff --git a/drivers/atm/lantiq/ltqmips_atm_ppe_ar9.h b/drivers/atm/lantiq/ltqmips_atm_ppe_ar9.h
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/ltqmips_atm_ppe_ar9.h
@@ -0,0 +1,212 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_atm_ppe_ar9.h
+** PROJECT      : UEIP
+** MODULES     	: ATM (ADSL)
+**
+** DATE         : 1 AUG 2005
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : ATM Driver (PPE Registers)
+** COPYRIGHT    : 	Copyright (c) 2006
+**			Infineon Technologies AG
+**			Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+**  4 AUG 2005  Xu Liang        Initiate Version
+** 23 OCT 2006  Xu Liang        Add GPL header.
+**  9 JAN 2007  Xu Liang        First version got from Anand (IC designer)
+*******************************************************************************/
+
+
+
+#ifndef IFXMIPS_ATM_PPE_AR9_H
+#define IFXMIPS_ATM_PPE_AR9_H
+
+
+
+/*
+ *  FPI Configuration Bus Register and Memory Address Mapping
+ */
+#define IFX_PPE                         (KSEG1 | 0x1E180000)
+#define PP32_DEBUG_REG_ADDR(i, x)       ((volatile unsigned int*)(IFX_PPE + (((x) + 0x0000) << 2)))
+#define PPM_INT_REG_ADDR(i, x)          ((volatile unsigned int*)(IFX_PPE + (((x) + 0x0030) << 2)))
+#define PP32_INTERNAL_RES_ADDR(i, x)    ((volatile unsigned int*)(IFX_PPE + (((x) + 0x0040) << 2)))
+#define CDM_CODE_MEMORY(i, x)           ((volatile unsigned int*)(IFX_PPE + (((x) + 0x1000) << 2)))
+#define PPE_REG_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x4000) << 2)))
+#define CDM_DATA_MEMORY(i, x)           ((volatile unsigned int*)(IFX_PPE + (((x) + 0x5000) << 2)))
+#define PPM_INT_UNIT_ADDR(x)            ((volatile unsigned int*)(IFX_PPE + (((x) + 0x6000) << 2)))
+#define PPM_TIMER0_ADDR(x)              ((volatile unsigned int*)(IFX_PPE + (((x) + 0x6100) << 2)))
+#define PPM_TASK_IND_REG_ADDR(x)        ((volatile unsigned int*)(IFX_PPE + (((x) + 0x6200) << 2)))
+#define PPS_BRK_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x6300) << 2)))
+#define PPM_TIMER1_ADDR(x)              ((volatile unsigned int*)(IFX_PPE + (((x) + 0x6400) << 2)))
+#define SB_RAM0_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x8000) << 2)))
+#define SB_RAM1_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x8800) << 2)))
+#define SB_RAM2_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x9000) << 2)))
+#define SB_RAM3_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x9800) << 2)))
+#define SB_RAM4_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0xA000) << 2)))
+#define QSB_CONF_REG_ADDR(x)            ((volatile unsigned int*)(IFX_PPE + (((x) + 0xC000) << 2)))
+
+/*
+ *  DWORD-Length of Memory Blocks
+ */
+#define PP32_DEBUG_REG_DWLEN            0x0030
+#define PPM_INT_REG_DWLEN               0x0010
+#define PP32_INTERNAL_RES_DWLEN         0x00C0
+#define CDM_CODE_MEMORYn_DWLEN(n)       0x1000
+#define PPE_REG_DWLEN                   0x1000
+#define CDM_DATA_MEMORY_DWLEN           CDM_CODE_MEMORYn_DWLEN(1)
+#define PPM_INT_UNIT_DWLEN              0x0100
+#define PPM_TIMER0_DWLEN                0x0100
+#define PPM_TASK_IND_REG_DWLEN          0x0100
+#define PPS_BRK_DWLEN                   0x0100
+#define PPM_TIMER1_DWLEN                0x0100
+#define SB_RAM0_DWLEN                   0x0800
+#define SB_RAM1_DWLEN                   0x0800
+#define SB_RAM2_DWLEN                   0x0800
+#define SB_RAM3_DWLEN                   0x0800
+#define SB_RAM4_DWLEN                   0x0C00
+#define QSB_CONF_REG_DWLEN              0x0100
+
+/*
+ *  PP32 to FPI Address Mapping
+ */
+#define SB_BUFFER(__sb_addr)            ((volatile unsigned int *)((((__sb_addr) >= 0x0000) && ((__sb_addr) <= 0x0FFF)) ? PPE_REG_ADDR((__sb_addr)):            \
+                                                                   (((__sb_addr) >= 0x2000) && ((__sb_addr) <= 0x27FF)) ? SB_RAM0_ADDR((__sb_addr) - 0x2000) :  \
+                                                                   (((__sb_addr) >= 0x2800) && ((__sb_addr) <= 0x2FFF)) ? SB_RAM1_ADDR((__sb_addr) - 0x2800) :  \
+                                                                   (((__sb_addr) >= 0x3000) && ((__sb_addr) <= 0x37FF)) ? SB_RAM2_ADDR((__sb_addr) - 0x3000) :  \
+                                                                   (((__sb_addr) >= 0x3800) && ((__sb_addr) <= 0x3FFF)) ? SB_RAM3_ADDR((__sb_addr) - 0x3800) :  \
+                                                                   (((__sb_addr) >= 0x4000) && ((__sb_addr) <= 0x4BFF)) ? SB_RAM4_ADDR((__sb_addr) - 0x4000) :  \
+                                                                0))
+
+/*
+ *  PP32 Debug Control Register
+ */
+#define NUM_OF_PP32                             1
+
+#define PP32_DBG_CTRL(n)                        PP32_DEBUG_REG_ADDR(n, 0x0000)
+
+#define DBG_CTRL_RESTART                        0
+#define DBG_CTRL_STOP                           1
+
+#define PP32_CTRL_CMD(n)                        PP32_DEBUG_REG_ADDR(n, 0x0B00)
+  #define PP32_CTRL_CMD_RESTART                 (1 << 0)
+  #define PP32_CTRL_CMD_STOP                    (1 << 1)
+  #define PP32_CTRL_CMD_STEP                    (1 << 2)
+  #define PP32_CTRL_CMD_BREAKOUT                (1 << 3)
+
+#define PP32_CTRL_OPT(n)                        PP32_DEBUG_REG_ADDR(n, 0x0C00)
+  #define PP32_CTRL_OPT_BREAKOUT_ON_STOP_ON     (3 << 0)
+  #define PP32_CTRL_OPT_BREAKOUT_ON_STOP_OFF    (2 << 0)
+  #define PP32_CTRL_OPT_BREAKOUT_ON_BREAKIN_ON  (3 << 2)
+  #define PP32_CTRL_OPT_BREAKOUT_ON_BREAKIN_OFF (2 << 2)
+  #define PP32_CTRL_OPT_STOP_ON_BREAKIN_ON      (3 << 4)
+  #define PP32_CTRL_OPT_STOP_ON_BREAKIN_OFF     (2 << 4)
+  #define PP32_CTRL_OPT_STOP_ON_BREAKPOINT_ON   (3 << 6)
+  #define PP32_CTRL_OPT_STOP_ON_BREAKPOINT_OFF  (2 << 6)
+  #define PP32_CTRL_OPT_BREAKOUT_ON_STOP(n)     (*PP32_CTRL_OPT(n) & (1 << 0))
+  #define PP32_CTRL_OPT_BREAKOUT_ON_BREAKIN(n)  (*PP32_CTRL_OPT(n) & (1 << 2))
+  #define PP32_CTRL_OPT_STOP_ON_BREAKIN(n)      (*PP32_CTRL_OPT(n) & (1 << 4))
+  #define PP32_CTRL_OPT_STOP_ON_BREAKPOINT(n)   (*PP32_CTRL_OPT(n) & (1 << 6))
+
+#define PP32_BRK_PC(n, i)                       PP32_DEBUG_REG_ADDR(n, 0x0900 + (i) * 2)
+#define PP32_BRK_PC_MASK(n, i)                  PP32_DEBUG_REG_ADDR(n, 0x0901 + (i) * 2)
+#define PP32_BRK_DATA_ADDR(n, i)                PP32_DEBUG_REG_ADDR(n, 0x0904 + (i) * 2)
+#define PP32_BRK_DATA_ADDR_MASK(n, i)           PP32_DEBUG_REG_ADDR(n, 0x0905 + (i) * 2)
+#define PP32_BRK_DATA_VALUE_RD(n, i)            PP32_DEBUG_REG_ADDR(n, 0x0908 + (i) * 2)
+#define PP32_BRK_DATA_VALUE_RD_MASK(n, i)       PP32_DEBUG_REG_ADDR(n, 0x0909 + (i) * 2)
+#define PP32_BRK_DATA_VALUE_WR(n, i)            PP32_DEBUG_REG_ADDR(n, 0x090C + (i) * 2)
+#define PP32_BRK_DATA_VALUE_WR_MASK(n, i)       PP32_DEBUG_REG_ADDR(n, 0x090D + (i) * 2)
+  #define PP32_BRK_CONTEXT_MASK(i)              (1 << (i))
+  #define PP32_BRK_CONTEXT_MASK_EN              (1 << 4)
+  #define PP32_BRK_COMPARE_GREATER_EQUAL        (1 << 5)    //  valid for break data value rd/wr only
+  #define PP32_BRK_COMPARE_LOWER_EQUAL          (1 << 6)
+  #define PP32_BRK_COMPARE_EN                   (1 << 7)
+
+#define PP32_BRK_TRIG(n)                        PP32_DEBUG_REG_ADDR(n, 0x0F00)
+  #define PP32_BRK_GRPi_PCn_ON(i, n)            ((3 << ((n) * 2)) << ((i) * 16))
+  #define PP32_BRK_GRPi_PCn_OFF(i, n)           ((2 << ((n) * 2)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_ADDRn_ON(i, n)     ((3 << ((n) * 2 + 4)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_ADDRn_OFF(i, n)    ((2 << ((n) * 2 + 4)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_VALUE_RDn_ON(i, n) ((3 << ((n) * 2 + 8)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_VALUE_RDn_OFF(i, n)((2 << ((n) * 2 + 8)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_VALUE_WRn_ON(i, n) ((3 << ((n) * 2 + 12)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_VALUE_WRn_OFF(i, n)((2 << ((n) * 2 + 12)) << ((i) * 16))
+  #define PP32_BRK_GRPi_PCn(k, i, n)            (*PP32_BRK_TRIG(k) & ((1 << ((n))) << ((i) * 8)))
+  #define PP32_BRK_GRPi_DATA_ADDRn(k, i, n)     (*PP32_BRK_TRIG(k) & ((1 << ((n) + 2)) << ((i) * 8)))
+  #define PP32_BRK_GRPi_DATA_VALUE_RDn(k, i, n) (*PP32_BRK_TRIG(k) & ((1 << ((n) + 4)) << ((i) * 8)))
+  #define PP32_BRK_GRPi_DATA_VALUE_WRn(k, i, n) (*PP32_BRK_TRIG(k) & ((1 << ((n) + 6)) << ((i) * 8)))
+
+#define PP32_CPU_STATUS(n)                      PP32_DEBUG_REG_ADDR(n, 0x0D00)
+#define PP32_HALT_STAT(n)                       PP32_CPU_STATUS(n)
+#define PP32_DBG_CUR_PC(n)                      PP32_CPU_STATUS(n)
+  #define PP32_CPU_USER_STOPPED(n)              (*PP32_CPU_STATUS(n) & (1 << 0))
+  #define PP32_CPU_USER_BREAKIN_RCV(n)          (*PP32_CPU_STATUS(n) & (1 << 1))
+  #define PP32_CPU_USER_BREAKPOINT_MET(n)       (*PP32_CPU_STATUS(n) & (1 << 2))
+  #define PP32_CPU_CUR_PC(n)                    (*PP32_CPU_STATUS(n) >> 16)
+
+#define PP32_BREAKPOINT_REASONS(n)              PP32_DEBUG_REG_ADDR(n, 0x0A00)
+  #define PP32_BRK_PC_MET(n, i)                 (*PP32_BREAKPOINT_REASONS(n) & (1 << (i)))
+  #define PP32_BRK_DATA_ADDR_MET(n, i)          (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) + 2)))
+  #define PP32_BRK_DATA_VALUE_RD_MET(n, i)      (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) + 4)))
+  #define PP32_BRK_DATA_VALUE_WR_MET(n, i)      (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) + 6)))
+  #define PP32_BRK_DATA_VALUE_RD_LO_EQ(n, i)    (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) * 2 + 8)))
+  #define PP32_BRK_DATA_VALUE_RD_GT_EQ(n, i)    (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) * 2 + 9)))
+  #define PP32_BRK_DATA_VALUE_WR_LO_EQ(n, i)    (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) * 2 + 12)))
+  #define PP32_BRK_DATA_VALUE_WR_GT_EQ(n, i)    (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) * 2 + 13)))
+  #define PP32_BRK_CUR_CONTEXT(n)               ((*PP32_BREAKPOINT_REASONS(n) >> 16) & 0x03)
+
+#define PP32_GP_REG_BASE(n)                     PP32_DEBUG_REG_ADDR(n, 0x0E00)
+#define PP32_GP_CONTEXTi_REGn(n, i, j)          PP32_DEBUG_REG_ADDR(n, 0x0E00 + (i) * 16 + (j))
+
+/*
+ *  EMA Registers
+ */
+#define EMA_CMDCFG                      PPE_REG_ADDR(0x0A00)
+#define EMA_DATACFG                     PPE_REG_ADDR(0x0A01)
+#define EMA_CMDCNT                      PPE_REG_ADDR(0x0A02)
+#define EMA_DATACNT                     PPE_REG_ADDR(0x0A03)
+#define EMA_ISR                         PPE_REG_ADDR(0x0A04)
+#define EMA_IER                         PPE_REG_ADDR(0x0A05)
+#define EMA_CFG                         PPE_REG_ADDR(0x0A06)
+#define EMA_SUBID                       PPE_REG_ADDR(0x0A07)
+
+#define EMA_ALIGNMENT                   4
+
+/*
+ *  Mailbox IGU1 Interrupt
+ */
+#ifdef CONFIG_LTQ_ATM_XRX300
+  #define PPE_MAILBOX_IGU1_INT          get_mailbox1_irq_num()
+#else
+  #define PPE_MAILBOX_IGU1_INT          INT_NUM_IM2_IRL24
+#endif
+
+#ifdef CONFIG_LTQ_ATM_XRX300
+/*
+ *CHIP ID 
+ */
+struct ar10_chipid{
+    unsigned int   res0     :1;
+    unsigned int   version  :3;
+    unsigned int   pnum     :16;
+    unsigned int   manid    :11;
+    unsigned int   res1     :1;
+};
+
+/*
+  * Chip ID Registers 
+*/
+#define AR10_MIPS_CHIPID_BASE                   (KSEG1 | 0x1F107340)
+#define AR10_MIPS_CHIPID                        (volatile u32*)(AR10_MIPS_CHIPID_BASE + 0x4)
+
+extern uint32_t get_mailbox1_irq_num(void);
+
+#endif
+
+#endif  //  IFXMIPS_ATM_PPE_AR9_H
diff --git a/drivers/atm/lantiq/ltqmips_atm_ppe_common.h b/drivers/atm/lantiq/ltqmips_atm_ppe_common.h
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/ltqmips_atm_ppe_common.h
@@ -0,0 +1,362 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_atm_ppe_common.h
+** PROJECT      : UEIP
+** MODULES     	: ATM (ADSL)
+**
+** DATE         : 1 AUG 2005
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : ATM Driver (PPE Registers)
+** COPYRIGHT    : 	Copyright (c) 2006
+**			Infineon Technologies AG
+**			Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+**  4 AUG 2005  Xu Liang        Initiate Version
+** 23 OCT 2006  Xu Liang        Add GPL header.
+**  9 JAN 2007  Xu Liang        First version got from Anand (IC designer)
+*******************************************************************************/
+
+
+
+#ifndef IFXMIPS_ATM_PPE_COMMON_H
+#define IFXMIPS_ATM_PPE_COMMON_H
+
+
+
+#if defined(CONFIG_LTQ_ATM_XRX300)
+  #include "ltqmips_atm_ppe_ar9.h"
+#elif defined(CONFIG_LTQ_ATM_XRX200)
+  #include "ltqmips_atm_ppe_vr9.h"
+#else
+  #error Platform is not specified!
+#endif
+
+/*
+ *  Code/Data Memory (CDM) Interface Configuration Register
+ */
+#define CDM_CFG                         PPE_REG_ADDR(0x0100)
+
+#define CDM_CFG_RAM1                    GET_BITS(*CDM_CFG, 3, 2)
+#define CDM_CFG_RAM0                    (*CDM_CFG & (1 << 1))
+
+#define CDM_CFG_RAM1_SET(value)         SET_BITS(0, 3, 2, value)
+#define CDM_CFG_RAM0_SET(value)         ((value) ? (1 << 1) : 0)
+
+/*
+ *  QSB Internal Cell Delay Variation Register
+ */
+#define QSB_ICDV                        QSB_CONF_REG_ADDR(0x0007)
+
+#define QSB_ICDV_TAU                    GET_BITS(*QSB_ICDV, 5, 0)
+
+#define QSB_ICDV_TAU_SET(value)         SET_BITS(0, 5, 0, value)
+
+/*
+ *  QSB Scheduler Burst Limit Register
+ */
+#define QSB_SBL                         QSB_CONF_REG_ADDR(0x0009)
+
+#define QSB_SBL_SBL                     GET_BITS(*QSB_SBL, 3, 0)
+
+#define QSB_SBL_SBL_SET(value)          SET_BITS(0, 3, 0, value)
+
+/*
+ *  QSB Configuration Register
+ */
+#define QSB_CFG                         QSB_CONF_REG_ADDR(0x000A)
+
+#define QSB_CFG_TSTEPC                  GET_BITS(*QSB_CFG, 1, 0)
+
+#define QSB_CFG_TSTEPC_SET(value)       SET_BITS(0, 1, 0, value)
+
+/*
+ *  QSB RAM Transfer Table Register
+ */
+#define QSB_RTM                         QSB_CONF_REG_ADDR(0x000B)
+
+#define QSB_RTM_DM                      (*QSB_RTM)
+
+#define QSB_RTM_DM_SET(value)           ((value) & 0xFFFFFFFF)
+
+/*
+ *  QSB RAM Transfer Data Register
+ */
+#define QSB_RTD                         QSB_CONF_REG_ADDR(0x000C)
+
+#define QSB_RTD_TTV                     (*QSB_RTD)
+
+#define QSB_RTD_TTV_SET(value)          ((value) & 0xFFFFFFFF)
+
+/*
+ *  QSB RAM Access Register
+ */
+#define QSB_RAMAC                       QSB_CONF_REG_ADDR(0x000D)
+
+#define QSB_RAMAC_RW                    (*QSB_RAMAC & (1 << 31))
+#define QSB_RAMAC_TSEL                  GET_BITS(*QSB_RAMAC, 27, 24)
+#define QSB_RAMAC_LH                    (*QSB_RAMAC & (1 << 16))
+#define QSB_RAMAC_TESEL                 GET_BITS(*QSB_RAMAC, 9, 0)
+
+#define QSB_RAMAC_RW_SET(value)         ((value) ? (1 << 31) : 0)
+#define QSB_RAMAC_TSEL_SET(value)       SET_BITS(0, 27, 24, value)
+#define QSB_RAMAC_LH_SET(value)         ((value) ? (1 << 16) : 0)
+#define QSB_RAMAC_TESEL_SET(value)      SET_BITS(0, 9, 0, value)
+
+/*
+ *  QSB Queue Scheduling and Shaping Definitions
+ */
+#define QSB_WFQ_NONUBR_MAX              0x3f00
+#define QSB_WFQ_UBR_BYPASS              0x3fff
+#define QSB_TP_TS_MAX                   65472
+#define QSB_TAUS_MAX                    64512
+#define QSB_GCR_MIN                     18
+
+/*
+ *  QSB Constant
+ */
+#define QSB_RAMAC_RW_READ               0
+#define QSB_RAMAC_RW_WRITE              1
+
+#define QSB_RAMAC_TSEL_QPT              0x01
+#define QSB_RAMAC_TSEL_SCT              0x02
+#define QSB_RAMAC_TSEL_SPT              0x03
+#define QSB_RAMAC_TSEL_VBR              0x08
+
+#define QSB_RAMAC_LH_LOW                0
+#define QSB_RAMAC_LH_HIGH               1
+
+#define QSB_QPT_SET_MASK                0x0
+#define QSB_QVPT_SET_MASK               0x0
+#define QSB_SET_SCT_MASK                0x0
+#define QSB_SET_SPT_MASK                0x0
+#define QSB_SET_SPT_SBVALID_MASK        0x7FFFFFFF
+
+#define QSB_SPT_SBV_VALID               (1 << 31)
+#define QSB_SPT_PN_SET(value)           (((value) & 0x01) ? (1 << 16) : 0)
+#define QSB_SPT_INTRATE_SET(value)      SET_BITS(0, 13, 0, value)
+
+/*
+ *  QSB Queue Parameter Table Entry and Queue VBR Parameter Table Entry
+ */
+#if defined(__BIG_ENDIAN)
+    union qsb_queue_parameter_table {
+        struct {
+            unsigned int    res1    :1;
+            unsigned int    vbr     :1;
+            unsigned int    wfqf    :14;
+            unsigned int    tp      :16;
+        }               bit;
+        u32             dword;
+    };
+
+    union qsb_queue_vbr_parameter_table {
+        struct {
+            unsigned int    taus    :16;
+            unsigned int    ts      :16;
+        }               bit;
+        u32             dword;
+    };
+#else
+    union qsb_queue_parameter_table {
+        struct {
+            unsigned int    tp      :16;
+            unsigned int    wfqf    :14;
+            unsigned int    vbr     :1;
+            unsigned int    res1    :1;
+        }               bit;
+        u32             dword;
+    };
+
+    union qsb_queue_vbr_parameter_table {
+        struct {
+            unsigned int    ts      :16;
+            unsigned int    taus    :16;
+        }               bit;
+        u32             dword;
+    };
+#endif  //  defined(__BIG_ENDIAN)
+
+/*
+ *  Mailbox IGU0 Registers
+ */
+#define MBOX_IGU0_ISRS                  PPE_REG_ADDR(0x0200)
+#define MBOX_IGU0_ISRC                  PPE_REG_ADDR(0x0201)
+#define MBOX_IGU0_ISR                   PPE_REG_ADDR(0x0202)
+#define MBOX_IGU0_IER                   PPE_REG_ADDR(0x0203)
+
+#define MBOX_IGU0_ISRS_SET(n)           (1 << (n))
+#define MBOX_IGU0_ISRC_CLEAR(n)         (1 << (n))
+#define MBOX_IGU0_ISR_ISR(n)            (*MBOX_IGU0_ISR & (1 << (n)))
+#define MBOX_IGU0_IER_EN(n)             (*MBOX_IGU0_IER & (1 << (n)))
+#define MBOX_IGU0_IER_EN_SET(n)         (1 << (n))
+
+/*
+ *  Mailbox IGU1 Registers
+ */
+#define MBOX_IGU1_ISRS                  PPE_REG_ADDR(0x0204)
+#define MBOX_IGU1_ISRC                  PPE_REG_ADDR(0x0205)
+#define MBOX_IGU1_ISR                   PPE_REG_ADDR(0x0206)
+#define MBOX_IGU1_IER                   PPE_REG_ADDR(0x0207)
+
+#define MBOX_IGU1_ISRS_SET(n)           (1 << (n))
+#define MBOX_IGU1_ISRC_CLEAR(n)         (1 << (n))
+#define MBOX_IGU1_ISR_ISR(n)            (*MBOX_IGU1_ISR & (1 << (n)))
+#define MBOX_IGU1_IER_EN(n)             (*MBOX_IGU1_IER & (1 << (n)))
+#define MBOX_IGU1_IER_EN_SET(n)         (1 << (n))
+
+/*
+ *  Mailbox IGU3 Registers
+ */
+#define MBOX_IGU3_ISRS                  PPE_REG_ADDR(0x0214)
+#define MBOX_IGU3_ISRC                  PPE_REG_ADDR(0x0215)
+#define MBOX_IGU3_ISR                   PPE_REG_ADDR(0x0216)
+#define MBOX_IGU3_IER                   PPE_REG_ADDR(0x0217)
+
+#define MBOX_IGU3_ISRS_SET(n)           (1 << (n))
+#define MBOX_IGU3_ISRC_CLEAR(n)         (1 << (n))
+#define MBOX_IGU3_ISR_ISR(n)            (*MBOX_IGU3_ISR & (1 << (n)))
+#define MBOX_IGU3_IER_EN(n)             (*MBOX_IGU3_IER & (1 << (n)))
+#define MBOX_IGU3_IER_EN_SET(n)         (1 << (n))
+
+/*
+ *  RTHA/TTHA Registers
+ */
+#define RFBI_CFG                        PPE_REG_ADDR(0x0400)
+#define RBA_CFG0                        PPE_REG_ADDR(0x0404)
+#define RBA_CFG1                        PPE_REG_ADDR(0x0405)
+#define RCA_CFG0                        PPE_REG_ADDR(0x0408)
+#define RCA_CFG1                        PPE_REG_ADDR(0x0409)
+#define RDES_CFG0                       PPE_REG_ADDR(0x040C)
+#define RDES_CFG1                       PPE_REG_ADDR(0x040D)
+#define SFSM_STATE0                     PPE_REG_ADDR(0x0410)
+#define SFSM_STATE1                     PPE_REG_ADDR(0x0411)
+#define SFSM_DBA0                       PPE_REG_ADDR(0x0412)
+#define SFSM_DBA1                       PPE_REG_ADDR(0x0413)
+#define SFSM_CBA0                       PPE_REG_ADDR(0x0414)
+#define SFSM_CBA1                       PPE_REG_ADDR(0x0415)
+#define SFSM_CFG0                       PPE_REG_ADDR(0x0416)
+#define SFSM_CFG1                       PPE_REG_ADDR(0x0417)
+#define SFSM_PGCNT0                     PPE_REG_ADDR(0x041C)
+#define SFSM_PGCNT1                     PPE_REG_ADDR(0x041D)
+#define FFSM_DBA0                       PPE_REG_ADDR(0x0508)
+#define FFSM_DBA1                       PPE_REG_ADDR(0x0509)
+#define FFSM_CFG0                       PPE_REG_ADDR(0x050A)
+#define FFSM_CFG1                       PPE_REG_ADDR(0x050B)
+#define FFSM_IDLE_HEAD_BC0              PPE_REG_ADDR(0x050E)
+#define FFSM_IDLE_HEAD_BC1              PPE_REG_ADDR(0x050F)
+#define FFSM_PGCNT0                     PPE_REG_ADDR(0x0514)
+#define FFSM_PGCNT1                     PPE_REG_ADDR(0x0515)
+
+/*
+ *  PPE TC Logic Registers (partial)
+ */
+#define DREG_A_VERSION                  PPE_REG_ADDR(0x0D00)
+#define DREG_A_CFG                      PPE_REG_ADDR(0x0D01)
+#define DREG_AT_CTRL                    PPE_REG_ADDR(0x0D02)
+#define DREG_AT_CB_CFG0                 PPE_REG_ADDR(0x0D03)
+#define DREG_AT_CB_CFG1                 PPE_REG_ADDR(0x0D04)
+#define DREG_AR_CTRL                    PPE_REG_ADDR(0x0D08)
+#define DREG_AR_CB_CFG0                 PPE_REG_ADDR(0x0D09)
+#define DREG_AR_CB_CFG1                 PPE_REG_ADDR(0x0D0A)
+#define DREG_A_UTPCFG                   PPE_REG_ADDR(0x0D0E)
+#define DREG_A_STATUS                   PPE_REG_ADDR(0x0D0F)
+#define DREG_AT_CFG0                    PPE_REG_ADDR(0x0D20)
+#define DREG_AT_CFG1                    PPE_REG_ADDR(0x0D21)
+#define DREG_AT_FB_SIZE0                PPE_REG_ADDR(0x0D22)
+#define DREG_AT_FB_SIZE1                PPE_REG_ADDR(0x0D23)
+#define DREG_AT_CELL0                   PPE_REG_ADDR(0x0D24)
+#define DREG_AT_CELL1                   PPE_REG_ADDR(0x0D25)
+#define DREG_AT_IDLE_CNT0               PPE_REG_ADDR(0x0D26)
+#define DREG_AT_IDLE_CNT1               PPE_REG_ADDR(0x0D27)
+#define DREG_AT_IDLE0                   PPE_REG_ADDR(0x0D28)
+#define DREG_AT_IDLE1                   PPE_REG_ADDR(0x0D29)
+#define DREG_AR_CFG0                    PPE_REG_ADDR(0x0D60)
+#define DREG_AR_CFG1                    PPE_REG_ADDR(0x0D61)
+#define DREG_AR_CELL0                   PPE_REG_ADDR(0x0D68)
+#define DREG_AR_CELL1                   PPE_REG_ADDR(0x0D69)
+#define DREG_AR_IDLE_CNT0               PPE_REG_ADDR(0x0D6A)
+#define DREG_AR_IDLE_CNT1               PPE_REG_ADDR(0x0D6B)
+#define DREG_AR_AIIDLE_CNT0             PPE_REG_ADDR(0x0D6C)
+#define DREG_AR_AIIDLE_CNT1             PPE_REG_ADDR(0x0D6D)
+#define DREG_AR_BE_CNT0                 PPE_REG_ADDR(0x0D6E)
+#define DREG_AR_BE_CNT1                 PPE_REG_ADDR(0x0D6F)
+#define DREG_AR_HEC_CNT0                PPE_REG_ADDR(0x0D70)
+#define DREG_AR_HEC_CNT1                PPE_REG_ADDR(0x0D71)
+#define DREG_AR_IDLE0                   PPE_REG_ADDR(0x0D74)
+#define DREG_AR_IDLE1                   PPE_REG_ADDR(0x0D75)
+#define DREG_AR_CVN_CNT0                PPE_REG_ADDR(0x0DA4)
+#define DREG_AR_CVN_CNT1                PPE_REG_ADDR(0x0DA5)
+#define DREG_AR_CVNP_CNT0               PPE_REG_ADDR(0x0DA6)
+#define DREG_AR_CVNP_CNT1               PPE_REG_ADDR(0x0DA7)
+#define DREG_B0_LADR                    PPE_REG_ADDR(0x0DA8)
+#define DREG_B1_LADR                    PPE_REG_ADDR(0x0DA9)
+
+#define SFSM_DBA(i)                     ( (SFSM_dba * )   PPE_REG_ADDR(0x0412 + (i)))
+#define SFSM_CBA(i)                     ( (SFSM_cba * )   PPE_REG_ADDR(0x0414 + (i)))
+#define SFSM_CFG(i)                     ( (SFSM_cfg * )   PPE_REG_ADDR(0x0416 + (i)))
+#define SFSM_PGCNT(i)                   ( (SFSM_pgcnt * ) PPE_REG_ADDR(0x041C + (i)))
+
+#define FFSM_DBA(i)                     ( (FFSM_dba * )   PPE_REG_ADDR(0x0508 + (i)))
+#define FFSM_CFG(i)                     ( (FFSM_cfg * )   PPE_REG_ADDR(0x050A + (i)))
+#define FFSM_PGCNT(i)                   ( (FFSM_pgcnt * ) PPE_REG_ADDR(0x0514 + (i)))
+
+typedef struct  {
+    unsigned int    res     : 19;
+    unsigned int    dbase   : 13;
+} SFSM_dba;
+
+typedef struct  {
+    unsigned int    res     : 19;
+    unsigned int    cbase   : 13;
+} SFSM_cba;
+
+typedef struct  {
+    unsigned int    res     : 15;
+    unsigned int    endian  : 1;
+    unsigned int    idlekeep: 1;
+    unsigned int    sen     : 1;
+    unsigned int    res1    : 8;
+    unsigned int    pnum    : 6;
+} SFSM_cfg;
+
+typedef struct  {
+    unsigned int    res     : 17;
+    unsigned int    pptr    : 6;
+    unsigned int    dcmd    : 1;
+    unsigned int    res1    : 2;
+    unsigned int    upage   : 6;
+} SFSM_pgcnt;
+
+typedef struct  {
+    unsigned int    res     : 19;
+    unsigned int    dbase   : 13;
+} FFSM_dba;
+
+typedef struct  {
+    unsigned int    res     : 12;
+    unsigned int    rstptr  : 1;
+    unsigned int    clvpage : 1;
+    unsigned int    fidle   : 1;
+    unsigned int    endian  : 1;
+    unsigned int    res1    : 10;
+    unsigned int    pnum    : 6;
+} FFSM_cfg;
+
+typedef struct  {
+    unsigned int    res     : 17;
+    unsigned int    ival    : 6;
+    unsigned int    icmd    : 1;
+    unsigned int    res1    : 2;
+    unsigned int    vpage   : 6;
+} FFSM_pgcnt;
+
+
+
+#endif  //  IFXMIPS_ATM_PPE_COMMON_H
diff --git a/drivers/atm/lantiq/ltqmips_atm_ppe_danube.h b/drivers/atm/lantiq/ltqmips_atm_ppe_danube.h
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/ltqmips_atm_ppe_danube.h
@@ -0,0 +1,129 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_atm_ppe_danube.h
+** PROJECT      : UEIP
+** MODULES     	: ATM (ADSL)
+**
+** DATE         : 1 AUG 2005
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : ATM Driver (PPE Registers)
+** COPYRIGHT    : 	Copyright (c) 2006
+**			Infineon Technologies AG
+**			Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+**  4 AUG 2005  Xu Liang        Initiate Version
+** 23 OCT 2006  Xu Liang        Add GPL header.
+**  9 JAN 2007  Xu Liang        First version got from Anand (IC designer)
+*******************************************************************************/
+
+
+
+#ifndef IFXMIPS_ATM_PPE_DANUBE_H
+#define IFXMIPS_ATM_PPE_DANUBE_H
+
+
+
+/*
+ *  FPI Configuration Bus Register and Memory Address Mapping
+ */
+#define IFX_PPE                      	(KSEG1 | 0x1E180000)
+#define PP32_DEBUG_REG_ADDR(i, x)       ((volatile unsigned int*)(IFX_PPE + (((x) + 0x0000) << 2)))
+#define PPM_INT_REG_ADDR(i, x)          ((volatile unsigned int*)(IFX_PPE + (((x) + 0x0030) << 2)))
+#define PP32_INTERNAL_RES_ADDR(i, x)    ((volatile unsigned int*)(IFX_PPE + (((x) + 0x0040) << 2)))
+#define CDM_CODE_MEMORY(i, x)           ((volatile unsigned int*)(IFX_PPE + (((x) + 0x1000) << 2)))
+#define PPE_REG_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x4000) << 2)))
+#define CDM_DATA_MEMORY(i, x)           ((volatile unsigned int*)(IFX_PPE + (((x) + 0x5000) << 2)))
+#define PPM_INT_UNIT_ADDR(x)            ((volatile unsigned int*)(IFX_PPE + (((x) + 0x6000) << 2)))
+#define PPM_TIMER0_ADDR(x)              ((volatile unsigned int*)(IFX_PPE + (((x) + 0x6100) << 2)))
+#define PPM_TASK_IND_REG_ADDR(x)        ((volatile unsigned int*)(IFX_PPE + (((x) + 0x6200) << 2)))
+#define PPS_BRK_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x6300) << 2)))
+#define PPM_TIMER1_ADDR(x)              ((volatile unsigned int*)(IFX_PPE + (((x) + 0x6400) << 2)))
+#define SB_RAM0_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x8000) << 2)))
+#define SB_RAM1_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x8400) << 2)))
+#define SB_RAM2_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x8C00) << 2)))
+#define SB_RAM3_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x9600) << 2)))
+#define QSB_CONF_REG_ADDR(x)            ((volatile unsigned int*)(IFX_PPE + (((x) + 0xC000) << 2)))
+
+/*
+ *  DWORD-Length of Memory Blocks
+ */
+#define PP32_DEBUG_REG_DWLEN            0x0030
+#define PPM_INT_REG_DWLEN               0x0010
+#define PP32_INTERNAL_RES_DWLEN         0x00C0
+#define CDM_CODE_MEMORYn_DWLEN(n)       ((n) == 0 ? 0x1000 : 0x0800)
+#define PPE_REG_DWLEN                   0x1000
+#define CDM_DATA_MEMORY_DWLEN           CDM_CODE_MEMORYn_DWLEN(1)
+#define PPM_INT_UNIT_DWLEN              0x0100
+#define PPM_TIMER0_DWLEN                0x0100
+#define PPM_TASK_IND_REG_DWLEN          0x0100
+#define PPS_BRK_DWLEN                   0x0100
+#define PPM_TIMER1_DWLEN                0x0100
+#define SB_RAM0_DWLEN                   0x0400
+#define SB_RAM1_DWLEN                   0x0800
+#define SB_RAM2_DWLEN                   0x0A00
+#define SB_RAM3_DWLEN                   0x0400
+#define QSB_CONF_REG_DWLEN              0x0100
+
+/*
+ *  PP32 to FPI Address Mapping
+ */
+#define SB_BUFFER(__sb_addr)            ((volatile unsigned int *)((((__sb_addr) >= 0x2000) && ((__sb_addr) <= 0x23FF)) ? SB_RAM0_ADDR((__sb_addr) - 0x2000) :   \
+                                                                   (((__sb_addr) >= 0x2400) && ((__sb_addr) <= 0x2BFF)) ? SB_RAM1_ADDR((__sb_addr) - 0x2400) :   \
+                                                                   (((__sb_addr) >= 0x2C00) && ((__sb_addr) <= 0x35FF)) ? SB_RAM2_ADDR((__sb_addr) - 0x2C00) :   \
+                                                                   (((__sb_addr) >= 0x3600) && ((__sb_addr) <= 0x39FF)) ? SB_RAM3_ADDR((__sb_addr) - 0x3600) :   \
+                                                                0))
+
+/*
+ *  PP32 Debug Control Register
+ */
+#define PP32_DBG_CTRL                   PP32_DEBUG_REG_ADDR(0, 0x0000)
+
+#define DBG_CTRL_START_SET(value)       ((value) ? (1 << 0) : 0)
+#define DBG_CTRL_STOP_SET(value)        ((value) ? (1 << 1) : 0)
+#define DBG_CTRL_STEP_SET(value)        ((value) ? (1 << 2) : 0)
+
+#define PP32_HALT_STAT                  PP32_DEBUG_REG_ADDR(0, 0x0001)
+
+#define PP32_BRK_SRC                    PP32_DEBUG_REG_ADDR(0, 0x0002)
+
+#define PP32_DBG_PC_MIN(i)              PP32_DEBUG_REG_ADDR(0, 0x0010 + (i))
+#define PP32_DBG_PC_MAX(i)              PP32_DEBUG_REG_ADDR(0, 0x0014 + (i))
+#define PP32_DBG_DATA_MIN(i)            PP32_DEBUG_REG_ADDR(0, 0x0018 + (i))
+#define PP32_DBG_DATA_MAX(i)            PP32_DEBUG_REG_ADDR(0, 0x001A + (i))
+#define PP32_DBG_DATA_VAL(i)            PP32_DEBUG_REG_ADDR(0, 0x001C + (i))
+
+#define PP32_DBG_CUR_PC                 PP32_DEBUG_REG_ADDR(0, 0x0080)
+
+#define PP32_DBG_TASK_NO                PP32_DEBUG_REG_ADDR(0, 0x0081)
+
+#define PP32_DBG_REG_BASE(tsk, i)       PP32_DEBUG_REG_ADDR(0, 0x0100 + (tsk) * 16 + (i))
+
+/*
+ *  EMA Registers
+ */
+#define EMA_CMDCFG                      PPE_REG_ADDR(0x0A00)
+#define EMA_DATACFG                     PPE_REG_ADDR(0x0A01)
+#define EMA_CMDCNT                      PPE_REG_ADDR(0x0A02)
+#define EMA_DATACNT                     PPE_REG_ADDR(0x0A03)
+#define EMA_ISR                         PPE_REG_ADDR(0x0A04)
+#define EMA_IER                         PPE_REG_ADDR(0x0A05)
+#define EMA_CFG                         PPE_REG_ADDR(0x0A06)
+#define EMA_SUBID                       PPE_REG_ADDR(0x0A07)
+
+#define EMA_ALIGNMENT                   4
+
+/*
+ *  Mailbox IGU1 Interrupt
+ */
+#define PPE_MAILBOX_IGU1_INT            INT_NUM_IM2_IRL24
+
+
+
+#endif  //  IFXMIPS_ATM_PPE_DANUBE_H
diff --git a/drivers/atm/lantiq/ltqmips_atm_ppe_vr9.h b/drivers/atm/lantiq/ltqmips_atm_ppe_vr9.h
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/ltqmips_atm_ppe_vr9.h
@@ -0,0 +1,192 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_atm_ppe_vr9.h
+** PROJECT      : UEIP
+** MODULES     	: ATM (ADSL)
+**
+** DATE         : 1 AUG 2005
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : ATM Driver (PPE Registers)
+** COPYRIGHT    : 	Copyright (c) 2006
+**			Infineon Technologies AG
+**			Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+**  4 AUG 2005  Xu Liang        Initiate Version
+** 23 OCT 2006  Xu Liang        Add GPL header.
+**  9 JAN 2007  Xu Liang        First version got from Anand (IC designer)
+*******************************************************************************/
+
+
+
+#ifndef IFXMIPS_ATM_PPE_VR9_H
+#define IFXMIPS_ATM_PPE_VR9_H
+
+
+
+/*
+ *  FPI Configuration Bus Register and Memory Address Mapping
+ */
+#define IFX_PPE                         (KSEG1 | 0x1E200000)
+#define PP32_DEBUG_REG_ADDR(i, x)       ((volatile unsigned int*)(IFX_PPE + (((x) + 0x000000 + (i) * 0x00010000) << 2)))
+#define CDM_CODE_MEMORY(i, x)           ((volatile unsigned int*)(IFX_PPE + (((x) + 0x001000 + (i) * 0x00010000) << 2)))
+#define CDM_DATA_MEMORY(i, x)           ((volatile unsigned int*)(IFX_PPE + (((x) + 0x004000 + (i) * 0x00010000) << 2)))
+#define SB_RAM0_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x008000) << 2)))
+#define SB_RAM1_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x009000) << 2)))
+#define SB_RAM2_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x00A000) << 2)))
+#define SB_RAM3_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x00B000) << 2)))
+#define PPE_REG_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x00D000) << 2)))
+#define QSB_CONF_REG_ADDR(x)            ((volatile unsigned int*)(IFX_PPE + (((x) + 0x00E000) << 2)))
+#define SB_RAM6_ADDR(x)                 ((volatile unsigned int*)(IFX_PPE + (((x) + 0x018000) << 2)))
+
+/*
+ *  DWORD-Length of Memory Blocks
+ */
+#define PP32_DEBUG_REG_DWLEN            0x0030
+#define CDM_CODE_MEMORYn_DWLEN(n)       ((n) == 0 ? 0x1000 : 0x0800)
+#define CDM_DATA_MEMORY_DWLEN           CDM_CODE_MEMORYn_DWLEN(1)
+#define SB_RAM0_DWLEN                   0x1000
+#define SB_RAM1_DWLEN                   0x1000
+#define SB_RAM2_DWLEN                   0x1000
+#define SB_RAM3_DWLEN                   0x1000
+#define SB_RAM6_DWLEN                   0x8000
+#define QSB_CONF_REG_DWLEN              0x0100
+
+/*
+ *  PP32 to FPI Address Mapping
+ */
+#define SB_BUFFER(__sb_addr)            ((volatile unsigned int *)((((__sb_addr) >= 0x0000) && ((__sb_addr) <= 0x1FFF)) ? PPE_REG_ADDR((__sb_addr)) :           \
+                                                                   (((__sb_addr) >= 0x2000) && ((__sb_addr) <= 0x2FFF)) ? SB_RAM0_ADDR((__sb_addr) - 0x2000) :  \
+                                                                   (((__sb_addr) >= 0x3000) && ((__sb_addr) <= 0x3FFF)) ? SB_RAM1_ADDR((__sb_addr) - 0x3000) :  \
+                                                                   (((__sb_addr) >= 0x4000) && ((__sb_addr) <= 0x4FFF)) ? SB_RAM2_ADDR((__sb_addr) - 0x4000) :  \
+                                                                   (((__sb_addr) >= 0x5000) && ((__sb_addr) <= 0x5FFF)) ? SB_RAM3_ADDR((__sb_addr) - 0x5000) :  \
+                                                                   (((__sb_addr) >= 0x7000) && ((__sb_addr) <= 0x7FFF)) ? PPE_REG_ADDR((__sb_addr) - 0x7000) :  \
+                                                                   (((__sb_addr) >= 0x8000) && ((__sb_addr) <= 0xFFFF)) ? SB_RAM6_ADDR((__sb_addr) - 0x8000) :  \
+                                                                0))
+
+/*
+ *  PP32 Debug Control Register
+ */
+#define NUM_OF_PP32                             2
+
+#define PP32_FREEZE                             PPE_REG_ADDR(0x0000)
+#define PP32_SRST                               PPE_REG_ADDR(0x0020)
+
+#define PP32_DBG_CTRL(n)                        PP32_DEBUG_REG_ADDR(n, 0x0000)
+
+#define DBG_CTRL_RESTART                        0
+#define DBG_CTRL_STOP                           1
+
+#define PP32_CTRL_CMD(n)                        PP32_DEBUG_REG_ADDR(n, 0x0B00)
+  #define PP32_CTRL_CMD_RESTART                 (1 << 0)
+  #define PP32_CTRL_CMD_STOP                    (1 << 1)
+  #define PP32_CTRL_CMD_STEP                    (1 << 2)
+  #define PP32_CTRL_CMD_BREAKOUT                (1 << 3)
+
+#define PP32_CTRL_OPT(n)                        PP32_DEBUG_REG_ADDR(n, 0x0C00)
+  #define PP32_CTRL_OPT_BREAKOUT_ON_STOP_ON     (3 << 0)
+  #define PP32_CTRL_OPT_BREAKOUT_ON_STOP_OFF    (2 << 0)
+  #define PP32_CTRL_OPT_BREAKOUT_ON_BREAKIN_ON  (3 << 2)
+  #define PP32_CTRL_OPT_BREAKOUT_ON_BREAKIN_OFF (2 << 2)
+  #define PP32_CTRL_OPT_STOP_ON_BREAKIN_ON      (3 << 4)
+  #define PP32_CTRL_OPT_STOP_ON_BREAKIN_OFF     (2 << 4)
+  #define PP32_CTRL_OPT_STOP_ON_BREAKPOINT_ON   (3 << 6)
+  #define PP32_CTRL_OPT_STOP_ON_BREAKPOINT_OFF  (2 << 6)
+  #define PP32_CTRL_OPT_BREAKOUT_ON_STOP(n)     (*PP32_CTRL_OPT(n) & (1 << 0))
+  #define PP32_CTRL_OPT_BREAKOUT_ON_BREAKIN(n)  (*PP32_CTRL_OPT(n) & (1 << 2))
+  #define PP32_CTRL_OPT_STOP_ON_BREAKIN(n)      (*PP32_CTRL_OPT(n) & (1 << 4))
+  #define PP32_CTRL_OPT_STOP_ON_BREAKPOINT(n)   (*PP32_CTRL_OPT(n) & (1 << 6))
+
+#define PP32_BRK_PC(n, i)                       PP32_DEBUG_REG_ADDR(n, 0x0900 + (i) * 2)
+#define PP32_BRK_PC_MASK(n, i)                  PP32_DEBUG_REG_ADDR(n, 0x0901 + (i) * 2)
+#define PP32_BRK_DATA_ADDR(n, i)                PP32_DEBUG_REG_ADDR(n, 0x0904 + (i) * 2)
+#define PP32_BRK_DATA_ADDR_MASK(n, i)           PP32_DEBUG_REG_ADDR(n, 0x0905 + (i) * 2)
+#define PP32_BRK_DATA_VALUE_RD(n, i)            PP32_DEBUG_REG_ADDR(n, 0x0908 + (i) * 2)
+#define PP32_BRK_DATA_VALUE_RD_MASK(n, i)       PP32_DEBUG_REG_ADDR(n, 0x0909 + (i) * 2)
+#define PP32_BRK_DATA_VALUE_WR(n, i)            PP32_DEBUG_REG_ADDR(n, 0x090C + (i) * 2)
+#define PP32_BRK_DATA_VALUE_WR_MASK(n, i)       PP32_DEBUG_REG_ADDR(n, 0x090D + (i) * 2)
+  #define PP32_BRK_CONTEXT_MASK(i)              (1 << (i))
+  #define PP32_BRK_CONTEXT_MASK_EN              (1 << 4)
+  #define PP32_BRK_COMPARE_GREATER_EQUAL        (1 << 5)    //  valid for break data value rd/wr only
+  #define PP32_BRK_COMPARE_LOWER_EQUAL          (1 << 6)
+  #define PP32_BRK_COMPARE_EN                   (1 << 7)
+
+#define PP32_BRK_TRIG(n)                        PP32_DEBUG_REG_ADDR(n, 0x0F00)
+  #define PP32_BRK_GRPi_PCn_ON(i, n)            ((3 << ((n) * 2)) << ((i) * 16))
+  #define PP32_BRK_GRPi_PCn_OFF(i, n)           ((2 << ((n) * 2)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_ADDRn_ON(i, n)     ((3 << ((n) * 2 + 4)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_ADDRn_OFF(i, n)    ((2 << ((n) * 2 + 4)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_VALUE_RDn_ON(i, n) ((3 << ((n) * 2 + 8)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_VALUE_RDn_OFF(i, n)((2 << ((n) * 2 + 8)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_VALUE_WRn_ON(i, n) ((3 << ((n) * 2 + 12)) << ((i) * 16))
+  #define PP32_BRK_GRPi_DATA_VALUE_WRn_OFF(i, n)((2 << ((n) * 2 + 12)) << ((i) * 16))
+  #define PP32_BRK_GRPi_PCn(k, i, n)            (*PP32_BRK_TRIG(k) & ((1 << ((n))) << ((i) * 8)))
+  #define PP32_BRK_GRPi_DATA_ADDRn(k, i, n)     (*PP32_BRK_TRIG(k) & ((1 << ((n) + 2)) << ((i) * 8)))
+  #define PP32_BRK_GRPi_DATA_VALUE_RDn(k, i, n) (*PP32_BRK_TRIG(k) & ((1 << ((n) + 4)) << ((i) * 8)))
+  #define PP32_BRK_GRPi_DATA_VALUE_WRn(k, i, n) (*PP32_BRK_TRIG(k) & ((1 << ((n) + 6)) << ((i) * 8)))
+
+#define PP32_CPU_STATUS(n)                      PP32_DEBUG_REG_ADDR(n, 0x0D00)
+#define PP32_HALT_STAT(n)                       PP32_CPU_STATUS(n)
+#define PP32_DBG_CUR_PC(n)                      PP32_CPU_STATUS(n)
+  #define PP32_CPU_USER_STOPPED(n)              (*PP32_CPU_STATUS(n) & (1 << 0))
+  #define PP32_CPU_USER_BREAKIN_RCV(n)          (*PP32_CPU_STATUS(n) & (1 << 1))
+  #define PP32_CPU_USER_BREAKPOINT_MET(n)       (*PP32_CPU_STATUS(n) & (1 << 2))
+  #define PP32_CPU_CUR_PC(n)                    (*PP32_CPU_STATUS(n) >> 16)
+
+#define PP32_BREAKPOINT_REASONS(n)              PP32_DEBUG_REG_ADDR(n, 0x0A00)
+  #define PP32_BRK_PC_MET(n, i)                 (*PP32_BREAKPOINT_REASONS(n) & (1 << (i)))
+  #define PP32_BRK_DATA_ADDR_MET(n, i)          (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) + 2)))
+  #define PP32_BRK_DATA_VALUE_RD_MET(n, i)      (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) + 4)))
+  #define PP32_BRK_DATA_VALUE_WR_MET(n, i)      (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) + 6)))
+  #define PP32_BRK_DATA_VALUE_RD_LO_EQ(n, i)    (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) * 2 + 8)))
+  #define PP32_BRK_DATA_VALUE_RD_GT_EQ(n, i)    (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) * 2 + 9)))
+  #define PP32_BRK_DATA_VALUE_WR_LO_EQ(n, i)    (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) * 2 + 12)))
+  #define PP32_BRK_DATA_VALUE_WR_GT_EQ(n, i)    (*PP32_BREAKPOINT_REASONS(n) & (1 << ((i) * 2 + 13)))
+  #define PP32_BRK_CUR_CONTEXT(n)               ((*PP32_BREAKPOINT_REASONS(n) >> 16) & 0x03)
+
+#define PP32_GP_REG_BASE(n)                     PP32_DEBUG_REG_ADDR(n, 0x0E00)
+#define PP32_GP_CONTEXTi_REGn(n, i, j)          PP32_DEBUG_REG_ADDR(n, 0x0E00 + (i) * 16 + (j))
+
+/*
+ *  PDMA/EMA Registers
+ */
+#define PDMA_CFG                        PPE_REG_ADDR(0x0A00)
+#define PDMA_RX_CMDCNT                  PPE_REG_ADDR(0x0A01)
+#define PDMA_TX_CMDCNT                  PPE_REG_ADDR(0x0A02)
+#define PDMA_RX_FWDATACNT               PPE_REG_ADDR(0x0A03)
+#define PDMA_TX_FWDATACNT               PPE_REG_ADDR(0x0A04)
+#define PDMA_RX_CTX_CFG                 PPE_REG_ADDR(0x0A05)
+#define PDMA_TX_CTX_CFG                 PPE_REG_ADDR(0x0A06)
+#define PDMA_RX_MAX_LEN_REG             PPE_REG_ADDR(0x0A07)
+#define PDMA_RX_DELAY_CFG               PPE_REG_ADDR(0x0A08)
+#define PDMA_INT_FIFO_RD                PPE_REG_ADDR(0x0A09)
+#define PDMA_ISR                        PPE_REG_ADDR(0x0A0A)
+#define PDMA_IER                        PPE_REG_ADDR(0x0A0B)
+#define PDMA_SUBID                      PPE_REG_ADDR(0x0A0C)
+#define PDMA_BAR0                       PPE_REG_ADDR(0x0A0D)
+#define PDMA_BAR1                       PPE_REG_ADDR(0x0A0E)
+
+#define SAR_PDMA_RX_CMDBUF_CFG          PPE_REG_ADDR(0x0F00)
+#define SAR_PDMA_TX_CMDBUF_CFG          PPE_REG_ADDR(0x0F01)
+#define SAR_PDMA_RX_FW_CMDBUF_CFG       PPE_REG_ADDR(0x0F02)
+#define SAR_PDMA_TX_FW_CMDBUF_CFG       PPE_REG_ADDR(0x0F03)
+#define SAR_PDMA_RX_CMDBUF_STATUS       PPE_REG_ADDR(0x0F04)
+#define SAR_PDMA_TX_CMDBUF_STATUS       PPE_REG_ADDR(0x0F05)
+
+#define PDMA_ALIGNMENT                  4
+#define EMA_ALIGNMENT                   PDMA_ALIGNMENT
+
+/*
+ *  Mailbox IGU1 Interrupt
+ */
+#define PPE_MAILBOX_IGU1_INT            INT_NUM_IM2_IRL24
+
+
+
+#endif  //  IFXMIPS_ATM_PPE_VR9_H
diff --git a/drivers/atm/lantiq/ltqmips_atm_vr9.c b/drivers/atm/lantiq/ltqmips_atm_vr9.c
new file mode 100644
--- /dev/null
+++ b/drivers/atm/lantiq/ltqmips_atm_vr9.c
@@ -0,0 +1,309 @@
+/******************************************************************************
+**
+** FILE NAME    : ifxmips_atm_vr9.c
+** PROJECT      : UEIP
+** MODULES      : ATM
+**
+** DATE         : 7 Jul 2009
+** AUTHOR       : Xu Liang
+** DESCRIPTION  : ATM driver common source file (core functions)
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 07 JUL 2009  Xu Liang        Init Version
+*******************************************************************************/
+
+
+
+/*
+ * ####################################
+ *              Head File
+ * ####################################
+ */
+
+/*
+ *  Common Head File
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <asm/delay.h>
+
+/*
+ *  Chip Specific Head File
+ */
+#include <common_routines.h>
+#include <ltq_regs.h>
+#include <ltq_pmu.h>
+#include <ltq_rcu.h>
+#include "ltqmips_atm_core.h"
+#include "ltqmips_atm_fw_vr9.h"
+
+
+
+/*
+ * ####################################
+ *              Definition
+ * ####################################
+ */
+
+
+
+/*
+ * ####################################
+ *             Declaration
+ * ####################################
+ */
+
+/*
+ *  Hardware Init/Uninit Functions
+ */
+static inline void init_pmu(void);
+static inline void uninit_pmu(void);
+static inline void reset_ppe(void);
+static inline void init_pdma(void);
+static inline void init_mailbox(void);
+static inline void init_atm_tc(void);
+static inline void clear_share_buffer(void);
+
+
+
+/*
+ * ####################################
+ *            Local Variable
+ * ####################################
+ */
+
+
+
+/*
+ * ####################################
+ *            Local Function
+ * ####################################
+ */
+
+static inline void init_pmu(void)
+{
+    //*PMU_PWDCR &= ~((1 << 29) | (1 << 22) | (1 << 21) | (1 << 19) | (1 << 18));
+    PPE_TOP_PMU_SETUP(IFX_PMU_ENABLE);
+    PPE_SLL01_PMU_SETUP(IFX_PMU_ENABLE);
+    PPE_TC_PMU_SETUP(IFX_PMU_ENABLE);
+    PPE_EMA_PMU_SETUP(IFX_PMU_ENABLE);
+    PPE_QSB_PMU_SETUP(IFX_PMU_ENABLE);
+    PPE_TPE_PMU_SETUP(IFX_PMU_ENABLE);
+    DSL_DFE_PMU_SETUP(IFX_PMU_ENABLE);
+}
+
+static inline void uninit_pmu(void)
+{
+    PPE_SLL01_PMU_SETUP(IFX_PMU_DISABLE);
+    PPE_TC_PMU_SETUP(IFX_PMU_DISABLE);
+    PPE_EMA_PMU_SETUP(IFX_PMU_DISABLE);
+    PPE_QSB_PMU_SETUP(IFX_PMU_DISABLE);
+    PPE_TPE_PMU_SETUP(IFX_PMU_DISABLE);
+    DSL_DFE_PMU_SETUP(IFX_PMU_DISABLE);
+    PPE_TOP_PMU_SETUP(IFX_PMU_DISABLE);
+}
+
+static inline void reset_ppe(void)
+{
+#ifdef MODULE
+    //  reset PPE
+    ifx_rcu_rst(IFX_RCU_DOMAIN_DSLDFE, IFX_RCU_MODULE_ATM);
+    udelay(1000);
+    ifx_rcu_rst(IFX_RCU_DOMAIN_DSLTC, IFX_RCU_MODULE_ATM);
+    udelay(1000);
+    ifx_rcu_rst(IFX_RCU_DOMAIN_PPE, IFX_RCU_MODULE_ATM);
+    udelay(1000);
+    *PP32_SRST &= ~0x000303CF;
+    udelay(1000);
+    *PP32_SRST |= 0x000303CF;
+    udelay(1000);
+#endif
+}
+
+static inline void init_pdma(void)
+{
+    IFX_REG_W32(0x08,       PDMA_CFG);
+    IFX_REG_W32(0x00203580, SAR_PDMA_RX_CMDBUF_CFG);
+    IFX_REG_W32(0x004035A0, SAR_PDMA_RX_FW_CMDBUF_CFG);
+}
+
+static inline void init_mailbox(void)
+{
+    IFX_REG_W32(0xFFFFFFFF, MBOX_IGU1_ISRC);
+    IFX_REG_W32(0x00000000, MBOX_IGU1_IER);
+    IFX_REG_W32(0xFFFFFFFF, MBOX_IGU3_ISRC);
+    IFX_REG_W32(0x00000000, MBOX_IGU3_IER);
+}
+
+static inline void init_atm_tc(void)
+{
+    /*  clear sync state    */
+    *SFSM_STATE0    = 0;
+    *SFSM_STATE1    = 0;
+
+    /*  enable keep IDLE    */
+//    *SFSM_CFG0     |= 1 << 15;
+//    *SFSM_CFG1     |= 1 << 15;
+}
+
+static inline void clear_share_buffer(void)
+{
+    volatile u32 *p;
+    unsigned int i;
+
+    p = SB_RAM0_ADDR(0);
+    for ( i = 0; i < SB_RAM0_DWLEN + SB_RAM1_DWLEN + SB_RAM2_DWLEN + SB_RAM3_DWLEN; i++ )
+        IFX_REG_W32(0, p++);
+
+    p = SB_RAM6_ADDR(0);
+    for ( i = 0; i < SB_RAM6_DWLEN; i++ )
+        IFX_REG_W32(0, p++);
+}
+
+/*
+ *  Description:
+ *    Download PPE firmware binary code.
+ *  Input:
+ *    pp32      --- int, which pp32 core
+ *    src       --- u32 *, binary code buffer
+ *    dword_len --- unsigned int, binary code length in DWORD (32-bit)
+ *  Output:
+ *    int       --- 0:    Success
+ *                  else:           Error Code
+ */
+static inline int pp32_download_code(int pp32, u32 *code_src, unsigned int code_dword_len, u32 *data_src, unsigned int data_dword_len)
+{
+    unsigned int clr, set;
+    volatile u32 *dest;
+
+    if ( code_src == 0 || ((unsigned long)code_src & 0x03) != 0
+        || data_src == 0 || ((unsigned long)data_src & 0x03) != 0 )
+        return -EINVAL;
+
+    clr = pp32 ? 0xF0 : 0x0F;
+    if ( code_dword_len <= CDM_CODE_MEMORYn_DWLEN(0) )
+        set = pp32 ? (3 << 6): (2 << 2);
+    else
+        set = 0x00;
+    IFX_REG_W32_MASK(clr, set, CDM_CFG);
+
+    /*  copy code   */
+    dest = CDM_CODE_MEMORY(pp32, 0);
+    while ( code_dword_len-- > 0 )
+        IFX_REG_W32(*code_src++, dest++);
+
+    /*  copy data   */
+    dest = CDM_DATA_MEMORY(pp32, 0);
+    while ( data_dword_len-- > 0 )
+        IFX_REG_W32(*data_src++, dest++);
+
+    return 0;
+}
+
+
+
+/*
+ * ####################################
+ *           Global Function
+ * ####################################
+ */
+
+extern void ifx_atm_get_fw_ver(unsigned int *major, unsigned int *minor)
+{
+    ASSERT(major != NULL, "pointer is NULL");
+    ASSERT(minor != NULL, "pointer is NULL");
+
+#ifdef VER_IN_FIRMWARE
+    *major = FW_VER_ID->major;
+    *minor = FW_VER_ID->minor;
+#else
+    *major = ATM_FW_VER_MAJOR;
+    *minor = ATM_FW_VER_MINOR;
+#endif
+}
+
+void ifx_atm_init_chip(void)
+{
+    init_pmu();
+
+    reset_ppe();
+
+    init_pdma();
+
+    init_mailbox();
+
+    init_atm_tc();
+
+    clear_share_buffer();
+}
+
+void ifx_atm_uninit_chip(void)
+{
+    uninit_pmu();
+}
+
+/*
+ *  Description:
+ *    Initialize and start up PP32.
+ *  Input:
+ *    none
+ *  Output:
+ *    int  --- 0: Success
+ *             else:        Error Code
+ */
+int ifx_pp32_start(int pp32)
+{
+    unsigned int mask = 1 << (pp32 << 4);
+    int ret;
+
+    /*  download firmware   */
+    ret = pp32_download_code(pp32, firmware_binary_code, sizeof(firmware_binary_code) / sizeof(*firmware_binary_code), firmware_binary_data, sizeof(firmware_binary_data) / sizeof(*firmware_binary_data));
+    if ( ret != 0 )
+        return ret;
+
+    /*  run PP32    */
+    IFX_REG_W32_MASK(mask, 0, PP32_FREEZE);
+
+    /*  idle for a while to let PP32 init itself    */
+    udelay(10);
+
+    return 0;
+}
+
+/*
+ *  Description:
+ *    Halt PP32.
+ *  Input:
+ *    none
+ *  Output:
+ *    none
+ */
+void ifx_pp32_stop(int pp32)
+{
+    unsigned int mask = 1 << (pp32 << 4);
+
+    /*  halt PP32   */
+    IFX_REG_W32_MASK(0, mask, PP32_FREEZE);
+}
+
+unsigned int ifx_atm_get_qsb_clk(void)
+{
+    unsigned int shift = (IFX_REG_R32(IFX_CGU_CLKFSR) >> 28) & 0x03;
+
+    return ifx_get_fpi_hz() >> shift;
+}
