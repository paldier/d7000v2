From 6bd8ac216cefc84059a2e849c7a545e3be959023 Mon Sep 17 00:00:00 2001
From: Daniel Drubin <daniel.drubin@intel.com>
Date: Sun, 9 Nov 2014 02:08:21 +0200
Subject: [PATCH] Add ISH support

Change-Id: I73e86c9653f4d0c180a56096cbfed96ea67b757f

Signed-off-by: Fabien Marotte <fabien.marotte@intel.com>
(cherry picked from commit f2597c5002ef33ce44837da2fcf29c7f0587a239)

Conflicts:
	include/linux/hid-sensor-ids.h
---
 drivers/hid/hid-sensor-hub.c         |  572 ++++++++++++++++-
 drivers/misc/Kconfig                 |    1 +
 drivers/misc/Makefile                |    1 +
 drivers/misc/heci/Kconfig            |   13 +
 drivers/misc/heci/Makefile           |   23 +
 drivers/misc/heci/bus.c              |  627 +++++++++++++++++++
 drivers/misc/heci/bus.h              |  105 ++++
 drivers/misc/heci/client.c           | 1142 ++++++++++++++++++++++++++++++++++
 drivers/misc/heci/client.h           |  166 +++++
 drivers/misc/heci/debugfs.c          |  136 ++++
 drivers/misc/heci/hbm.c              |  741 ++++++++++++++++++++++
 drivers/misc/heci/hbm.h              |  325 ++++++++++
 drivers/misc/heci/heci-api.c         |  655 +++++++++++++++++++
 drivers/misc/heci/heci-api.h         |  113 ++++
 drivers/misc/heci/heci-hid-client.c  |  582 +++++++++++++++++
 drivers/misc/heci/heci-hid.c         |  227 +++++++
 drivers/misc/heci/heci-hid.h         |   87 +++
 drivers/misc/heci/heci_dev.h         |  304 +++++++++
 drivers/misc/heci/hid-ids.h          |  891 ++++++++++++++++++++++++++
 drivers/misc/heci/hid-strings-def.h  |  517 +++++++++++++++
 drivers/misc/heci/hw-ish-regs.h      |  116 ++++
 drivers/misc/heci/hw-ish.c           |  699 +++++++++++++++++++++
 drivers/misc/heci/hw-ish.h           |   46 ++
 drivers/misc/heci/init.c             |  227 +++++++
 drivers/misc/heci/pci-ish.c          |  699 +++++++++++++++++++++
 drivers/misc/heci/platform-config.h  |  119 ++++
 drivers/misc/heci/senscol-core.c     |  867 ++++++++++++++++++++++++++
 drivers/misc/heci/utils.h            |   50 ++
 include/linux/hid-sensor-ids.h       |  442 +++++++++++++
 include/linux/senscol/senscol-core.h |  121 ++++
 30 files changed, 10585 insertions(+), 29 deletions(-)
 create mode 100644 drivers/misc/heci/Kconfig
 create mode 100644 drivers/misc/heci/Makefile
 create mode 100644 drivers/misc/heci/bus.c
 create mode 100644 drivers/misc/heci/bus.h
 create mode 100644 drivers/misc/heci/client.c
 create mode 100644 drivers/misc/heci/client.h
 create mode 100644 drivers/misc/heci/debugfs.c
 create mode 100644 drivers/misc/heci/hbm.c
 create mode 100644 drivers/misc/heci/hbm.h
 create mode 100644 drivers/misc/heci/heci-api.c
 create mode 100644 drivers/misc/heci/heci-api.h
 create mode 100644 drivers/misc/heci/heci-hid-client.c
 create mode 100644 drivers/misc/heci/heci-hid.c
 create mode 100644 drivers/misc/heci/heci-hid.h
 create mode 100644 drivers/misc/heci/heci_dev.h
 create mode 100644 drivers/misc/heci/hid-ids.h
 create mode 100644 drivers/misc/heci/hid-strings-def.h
 create mode 100644 drivers/misc/heci/hw-ish-regs.h
 create mode 100644 drivers/misc/heci/hw-ish.c
 create mode 100644 drivers/misc/heci/hw-ish.h
 create mode 100644 drivers/misc/heci/init.c
 create mode 100644 drivers/misc/heci/pci-ish.c
 create mode 100644 drivers/misc/heci/platform-config.h
 create mode 100644 drivers/misc/heci/senscol-core.c
 create mode 100644 drivers/misc/heci/utils.h
 create mode 100644 include/linux/senscol/senscol-core.h

diff --git a/drivers/hid/hid-sensor-hub.c b/drivers/hid/hid-sensor-hub.c
index 9903c46..b11f8967 100644
--- a/drivers/hid/hid-sensor-hub.c
+++ b/drivers/hid/hid-sensor-hub.c
@@ -16,16 +16,48 @@
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  *
  */
+
+/*#define CONFIG_ISH_PATH_SENSCOL*/
+
+/***************************************/
+#if 1
+
+#ifdef CONFIG_ISH_PATH_SENSCOL
+#define SENSCOL		1
+#else
+#define SENSCOL		0	
+#endif
+
+#ifdef CONFIG_ISH_PATH_IIO
+#define IIO 		1
+#else
+#define IIO 		0	
+#endif
+
+#else
+
+#define SENSCOL		1
+#define IIO 		0	
+
+#endif
+/***************************************/
+
+
 #include <linux/device.h>
 #include <linux/hid.h>
 #include <linux/module.h>
 #include <linux/slab.h>
-#include <linux/mfd/core.h>
 #include <linux/list.h>
 #include <linux/hid-sensor-ids.h>
 #include <linux/hid-sensor-hub.h>
+#include <linux/sched.h>
 #include "hid-ids.h"
 
+/*SENSCOL*/
+#include <linux/senscol/senscol-core.h>
+/*IIO*/
+#include <linux/mfd/core.h>
+
 #define HID_SENSOR_HUB_ENUM_QUIRK	0x01
 
 /**
@@ -67,8 +99,13 @@ struct sensor_hub_data {
 	struct mfd_cell *hid_sensor_hub_client_devs;
 	int hid_sensor_client_cnt;
 	unsigned long quirks;
+	int sensor_hub_index;	/* Needed to identify sensor in a collection */
 };
 
+#define	MAX_HID_SENSOR_HUBS 32
+static struct hid_device *hid_sensor_hubs[MAX_HID_SENSOR_HUBS];
+static int	sensor_hub_count;
+
 /**
  * struct hid_sensor_hub_callbacks_list - Stores callback list
  * @list:		list head.
@@ -354,6 +391,9 @@ int sensor_hub_input_get_attribute_info(struct hid_sensor_hub_device *hsdev,
 		}
 	}
 
+ 	if (info->units == 0)
+ 		info->units = HID_USAGE_SENSOR_UNITS_MILLISECOND;
+ 
 err_ret:
 	return ret;
 }
@@ -400,6 +440,262 @@ static int sensor_hub_reset_resume(struct hid_device *hdev)
 }
 #endif
 
+static bool is_supported(int physical)
+{
+	if (physical == 0x200073)
+		return true;
+	if (physical == 0x200041)
+		return true;
+	if (physical == 0x200076)
+		return true;
+	if (physical == 0x200083)
+		return true;
+
+	return false;
+}
+
+/****************************** SENSCOL block: START ******************************/
+
+static int	senscol_impl_added;
+static int	is_sens_data_field(unsigned usage);
+static int get_field_index(struct hid_device *hdev, unsigned report_id, unsigned usage, int report_idx);	//???
+
+/* Get sensor's property by name */
+static struct sens_property	*get_prop_by_name(struct sensor_def *sensor, char *name)
+{
+	int	i;
+
+	for (i = 0; i < sensor->num_properties; ++i)
+		if (!strcmp(sensor->properties[i].name, name))
+			return	&sensor->properties[i];
+
+	return	NULL;
+}
+
+/* Get sensor's data field by name */
+static struct data_field	*get_data_field_by_name(struct sensor_def *sensor, char *name)
+{
+	int	i;
+
+	for (i = 0; i < sensor->num_data_fields; ++i)
+		if (!strcmp(sensor->data_fields[i].name, name))
+			return	&sensor->data_fields[i];
+
+	return	NULL;
+}
+
+static int get_field_index(struct hid_device *hdev, unsigned report_id, unsigned usage, int report_type)	//???
+{
+	int i = 0;
+	struct hid_report *report;
+
+	report = sensor_hub_report(report_id, hdev, report_type /*HID_FEATURE_REPORT or HID_INPUT_REPORT*/);
+	if (!report) {
+		return -1;
+	}
+
+	for (i = 0; i < report->maxfield; ++i)
+		if (report->field[i]->usage->hid == usage)
+			return i;
+
+	return -1;
+}
+
+/*
+ * The reason for this _ex() function is broken semantics and existing usage of sensor_hub_get_feature() that
+ * doesn't allow anything with ->report_count > 1 to be delivered.
+ * If that was fixed, existing callers would immediately buffer-overflow if such feature was delivered
+ * NOTES:
+ *   - if ret != 0, contents of pvalue and count are undefined.
+ *   - upon success, count is in s32 values (not in bytes)
+ */
+static int sensor_hub_get_feature_ex(struct hid_sensor_hub_device *hsdev, u32 report_id, u32 field_index, u32 *usage_id, s32 **pvalue, size_t *count)
+{
+	struct hid_report *report;
+	struct sensor_hub_data *data =  hid_get_drvdata(hsdev->hdev);
+	int ret = 0;
+
+	mutex_lock(&data->mutex);
+	report = sensor_hub_report(report_id, hsdev->hdev, HID_FEATURE_REPORT);
+	if (!report || (field_index >=  report->maxfield) ||
+	    report->field[field_index]->report_count < 1) {
+		ret = -EINVAL;
+		goto done_proc;
+	}
+	hid_hw_request(hsdev->hdev, report, HID_REQ_GET_REPORT);
+	hid_hw_wait(hsdev->hdev);
+	*pvalue = report->field[field_index]->value;
+	*count = report->field[field_index]->report_count;
+	*usage_id = report->field[field_index]->usage->hid;
+
+done_proc:
+	mutex_unlock(&data->mutex);
+
+	return ret;
+}
+
+static bool hid_is_string_property(uint32_t usage_id)
+{
+	return ((usage_id == HID_USAGE_SENSOR_PROPERTY_SENSOR_DESCRIPTION) || (usage_id == HID_USAGE_SENSOR_PROPERTY_FRIENDLY_NAME));
+}
+
+/* Get sensor hub device by index */
+static struct sensor_hub_data	*get_sensor_hub_by_index(unsigned idx)						//???
+{
+	int	i;
+	struct sensor_hub_data	*sd;
+	struct	hid_device	*hdev;
+
+	for (i = 0; i < sensor_hub_count; ++i) {
+		if (!hid_sensor_hubs[i])
+			continue;
+		sd = hid_get_drvdata(hid_sensor_hubs[i]);
+		if (!sd)
+			continue;
+		if (sd->sensor_hub_index == idx)
+			return	sd;
+	}
+
+	return	NULL;
+}
+
+static int     hid_get_sens_property(struct sensor_def *sensor, const struct sens_property* prop, char *value, size_t val_buf_size)
+{
+	unsigned	idx;
+	struct sensor_hub_data	*sd;
+	char	buf[1024];		/* Enough for single property (?) */
+	unsigned	report_id;
+	int	field;
+	uint32_t	usage_id;
+	int32_t	*pval;
+	size_t	count;
+	int	rv;
+
+	if (!sensor || !prop)
+		return	-EINVAL;	/* input is invalid */
+
+	/* sensor hub device */
+	idx = sensor->id >> 16 & 0xFFFF;
+	sd = get_sensor_hub_by_index(idx);
+	if (!sd)
+		return	-EINVAL;	/* sensor->id is bad */
+
+	/* Report ID */
+	report_id = sensor->id & 0xFFFF;
+
+	/* Field index */
+	field = get_field_index(sd->hsdev->hdev, report_id, prop->usage_id, HID_FEATURE_REPORT);
+	if (field == -1)
+		return	-EINVAL;	/* Something is still wrong */
+
+	/* Get value */
+	rv = sensor_hub_get_feature_ex(sd->hsdev, report_id, field, &usage_id, &pval, &count);
+	if (rv)
+		return	rv;
+
+	if  (hid_is_string_property(usage_id)) {
+		int	i;
+
+		for (i = 0; i < count; ++i)
+			buf[i] = (char)pval[i];
+		buf[i] = '\0';
+	} else {
+		/* Verify output length */
+		sprintf(buf, "%d", *pval);
+	}
+
+	if (strlen(buf) >= val_buf_size)
+		return	-EMSGSIZE;
+	strcpy(value, buf);
+	return	0;
+}
+
+static int     hid_set_sens_property(struct sensor_def *sensor, const struct sens_property *prop, const char *value)
+{
+	unsigned	idx;
+	struct sensor_hub_data	*sd;
+	unsigned	report_id;
+	int	field;
+	int32_t	val;
+	int	rv;
+
+	if (!sensor || !prop)
+		return	-EINVAL;	/* input is invalid */
+
+	/* Value */
+	rv = sscanf(value, " %d ", &val);
+	if (rv != 1)
+		return	-EINVAL;	/* Bad value */
+
+	/* sensor hub device */
+	idx = sensor->id >> 16 & 0xFFFF;
+	sd = get_sensor_hub_by_index(idx);
+	if (!sd)
+		return	-EINVAL;	/* sensor->id is bad */
+
+	/* Report ID */
+	report_id = sensor->id & 0xFFFF;
+
+	/* Field index */
+	field = get_field_index(sd->hsdev->hdev, report_id, prop->usage_id, HID_FEATURE_REPORT);
+	if (field == -1)
+		return	-EINVAL;	/* Something is still wrong */
+
+	/* Get value */
+	rv = sensor_hub_set_feature(sd->hsdev, report_id, field, val);
+	return	rv;
+}
+
+static int     hid_get_sample(struct sensor_def *sensor, void *sample_buf, size_t sample_buf_size)
+{
+	unsigned	idx;
+	struct sensor_hub_data	*sd;
+	unsigned	report_id;
+	int	field;
+	struct data_field *data_field;
+	int32_t	val;
+	int	rv;
+
+	/* sensor hub device */
+	idx = sensor->id >> 16 & 0xFFFF;
+	sd = get_sensor_hub_by_index(idx);
+	if (!sd)
+		return	-EINVAL;	/* sensor->id is bad */
+
+	/* Report ID */
+	report_id = sensor->id & 0xFFFF;
+
+	/* Request an input report with the first data field, regardless of what it is */
+	data_field = &sensor->data_fields[0];
+	val = sensor_hub_input_attr_get_raw_value(sd->hsdev, sensor->usage_id, data_field->usage_id, HID_INPUT_REPORT);
+	if (!sd->pending.status)
+		return	-EIO;
+
+	/*
+	 * Actual sample will be pushed by sensor_hub_raw_event().
+	 * Invoke a short sleep in order to remove threads race condition and ensure that the sample is in senscol buffer
+	 */
+	schedule_timeout(2);
+
+	return	0;
+}
+
+struct senscol_impl	hid_senscol_impl = {
+	.get_sens_property = hid_get_sens_property,
+	.set_sens_property = hid_set_sens_property,
+	.get_sample = hid_get_sample
+};
+
+static int	is_sens_data_field(unsigned usage)
+{
+	if (usage >= 0x400 && usage <= 0x49F || usage >= 0x4B0 && usage <= 0x4DF || usage >= 0x4F0 && usage <= 0x4F7 ||
+	  usage >= 0x500 && usage <= 0x52F || usage >= 0x540 && usage <= 0x57F || usage >= 590 && usage <= 0x7FF)
+		return	1;
+	return	0;
+}
+
+/******************************* SENSCOL block: END *******************************/
+
 /*
  * Handle raw report as sent by device
  */
@@ -411,21 +707,36 @@ static int sensor_hub_raw_event(struct hid_device *hdev,
 	int sz;
 	struct sensor_hub_data *pdata = hid_get_drvdata(hdev);
 	unsigned long flags;
-	struct hid_sensor_hub_callbacks *callback = NULL;
 	struct hid_collection *collection = NULL;
 	void *priv = NULL;
+/*#if SENSCOL*/
+	uint32_t	sensor_id;
+	unsigned char	data_buf[1024];
+	unsigned	sample_size;
+/*#endif*/
+
+/*#if IIO*/
+	struct hid_sensor_hub_callbacks *callback = NULL;
+/*#endif*/
+
 
 	hid_dbg(hdev, "sensor_hub_raw_event report id:0x%x size:%d type:%d\n",
 			 report->id, size, report->type);
 	hid_dbg(hdev, "maxfield:%d\n", report->maxfield);
 	if (report->type != HID_INPUT_REPORT)
-		return 1;
+		return 0;
 
 	ptr = raw_data;
 	ptr++; /* Skip report id */
 
 	spin_lock_irqsave(&pdata->lock, flags);
 
+/*#if SENSCOL*/
+	/* make up senscol id */
+	sensor_id = pdata->sensor_hub_index << 16 | report->id & 0xFFFF;
+	sample_size = 0;
+/*#endif*/
+
 	for (i = 0; i < report->maxfield; ++i) {
 		hid_dbg(hdev, "%d collection_index:%x hid:%x sz:%x\n",
 				i, report->field[i]->usage->collection_index,
@@ -434,6 +745,7 @@ static int sensor_hub_raw_event(struct hid_device *hdev,
 					report->field[i]->report_count)/8);
 		sz = (report->field[i]->report_size *
 					report->field[i]->report_count)/8;
+/*#if IIO*/
 		if (pdata->pending.status && pdata->pending.attr_usage_id ==
 				report->field[i]->usage->hid) {
 			hid_dbg(hdev, "data was pending ...\n");
@@ -461,13 +773,32 @@ static int sensor_hub_raw_event(struct hid_device *hdev,
 					report->field[i]->usage->hid, sz, ptr,
 					callback->pdev);
 		}
+/*#endif*/
+
+/*#if SENSCOL*/
+		/* Prepare data for senscol sample */
+		if (is_sens_data_field(report->field[i]->usage->hid & 0xFFFF)) {
+			dev_dbg(&hdev->dev, "%s(): aggregating, sz=%u \n", __func__, sample_size);
+			memcpy(data_buf + sample_size, ptr, sz);
+			sample_size += sz;
+		}
+/*#endif*/
+		/* If we want to add indication into raw stream that the last sample was synchronous, it's here: check for complete() condition above */
+
 		ptr += sz;
 	}
+/*#if IIO*/
 	if (callback && collection && callback->send_event)
 		callback->send_event(pdata->hsdev, collection->usage,
 				callback->pdev);
+/*endif*/
 	spin_unlock_irqrestore(&pdata->lock, flags);
 
+/*#if SENSCOL*/
+	/* Upstream sample to sensor collection framework */
+	dev_dbg(&hdev->dev, "%s(): calling push_sample, aggregated sample size is %u\n", __func__, sample_size);
+	push_sample(sensor_id, data_buf);
+/*#endif*/
 	return 1;
 }
 
@@ -545,10 +876,11 @@ static int sensor_hub_probe(struct hid_device *hdev,
 	struct sensor_hub_data *sd;
 	int i;
 	char *name;
-	struct hid_report *report;
-	struct hid_report_enum *report_enum;
-	struct hid_field *field;
+	struct hid_report *report, *freport;
+	struct hid_report_enum *inp_report_enum, *feat_report_enum;
+	struct hid_field *field, *feat_field;
 	int dev_cnt;
+	int	rv;
 
 	sd = devm_kzalloc(&hdev->dev, sizeof(*sd), GFP_KERNEL);
 	if (!sd) {
@@ -558,9 +890,12 @@ static int sensor_hub_probe(struct hid_device *hdev,
 	sd->hsdev = devm_kzalloc(&hdev->dev, sizeof(*sd->hsdev), GFP_KERNEL);
 	if (!sd->hsdev) {
 		hid_err(hdev, "cannot allocate hid_sensor_hub_device\n");
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto err_free_hub;
 	}
 	hid_set_drvdata(hdev, sd);
+	hid_sensor_hubs[sensor_hub_count] = hdev;	/* Keep array of HID sensor hubs for senscol_impl usage */
+	sd->sensor_hub_index = sensor_hub_count++;	/* Need to count sensor hub devices for senscol ids */
 	sd->quirks = id->driver_data;
 	sd->hsdev->hdev = hdev;
 	sd->hsdev->vendor_id = hdev->vendor;
@@ -571,25 +906,49 @@ static int sensor_hub_probe(struct hid_device *hdev,
 	ret = hid_parse(hdev);
 	if (ret) {
 		hid_err(hdev, "parse failed\n");
-		return ret;
+		goto err_free;
 	}
 	INIT_LIST_HEAD(&hdev->inputs);
 
 	ret = hid_hw_start(hdev, 0);
 	if (ret) {
 		hid_err(hdev, "hw start failed\n");
-		return ret;
+		goto err_free;
 	}
 	INIT_LIST_HEAD(&sd->dyn_callback_list);
 	sd->hid_sensor_client_cnt = 0;
-	report_enum = &hdev->report_enum[HID_INPUT_REPORT];
+	inp_report_enum = &hdev->report_enum[HID_INPUT_REPORT];
+	feat_report_enum = &hdev->report_enum[HID_FEATURE_REPORT];
 
-	dev_cnt = sensor_hub_get_physical_device_count(report_enum);
+	dev_cnt = sensor_hub_get_physical_device_count(inp_report_enum);
 	if (dev_cnt > HID_MAX_PHY_DEVICES) {
 		hid_err(hdev, "Invalid Physical device count\n");
 		ret = -EINVAL;
 		goto err_stop_hw;
 	}
+
+#if IIO													//???
+	/* filter the unknown sensors */
+	list_for_each_entry(report, &inp_report_enum->report_list, list) {
+		dev_dbg(&hdev->dev, "Checking Report id:%x\n", report->id);
+		field = report->field[0];
+		if (report->maxfield && field && field->physical) {
+			if (!is_supported(field->physical))
+				dev_cnt--;
+		}
+	}
+	dev_dbg(&hdev->dev, "%s(): Dev Count after  is %d\n", __func__, dev_cnt);
+#endif
+
+#if SENSCOL
+	/* Register senscol impl */
+	if (!senscol_impl_added) {
+		rv = add_senscol_impl(&hid_senscol_impl);
+		dev_dbg(&hdev->dev, "%s(): add_senscol_impl() returned %d\n", __func__, rv);
+		if (!rv)
+			senscol_impl_added = 1;
+	}
+#endif
 	sd->hid_sensor_hub_client_devs = kzalloc(dev_cnt *
 						sizeof(struct mfd_cell),
 						GFP_KERNEL);
@@ -598,37 +957,188 @@ static int sensor_hub_probe(struct hid_device *hdev,
 			ret = -ENOMEM;
 			goto err_stop_hw;
 	}
-	list_for_each_entry(report, &report_enum->report_list, list) {
+	list_for_each_entry(report, &inp_report_enum->report_list, list) {
 		hid_dbg(hdev, "Report id:%x\n", report->id);
 		field = report->field[0];
 		if (report->maxfield && field &&
 					field->physical) {
-			name = kasprintf(GFP_KERNEL, "HID-SENSOR-%x",
+			if (is_supported(field->physical)) {						//???
+				name = kasprintf(GFP_KERNEL, "HID-SENSOR-%x",
 						field->physical);
-			if (name == NULL) {
-				hid_err(hdev, "Failed MFD device name\n");
-					ret = -ENOMEM;
-					goto err_free_names;
-			}
-			sd->hid_sensor_hub_client_devs[
-				sd->hid_sensor_client_cnt].id = PLATFORM_DEVID_AUTO;
-			sd->hid_sensor_hub_client_devs[
-				sd->hid_sensor_client_cnt].name = name;
-			sd->hid_sensor_hub_client_devs[
-				sd->hid_sensor_client_cnt].platform_data =
+				if (name == NULL) {
+					hid_err(hdev, "Failed MFD device name\n");
+						ret = -ENOMEM;
+						goto err_free_names;
+				}
+				sd->hid_sensor_hub_client_devs[
+					sd->hid_sensor_client_cnt].id = PLATFORM_DEVID_AUTO;
+				sd->hid_sensor_hub_client_devs[
+					sd->hid_sensor_client_cnt].name = name;
+				sd->hid_sensor_hub_client_devs[
+					sd->hid_sensor_client_cnt].platform_data =
 						sd->hsdev;
-			sd->hid_sensor_hub_client_devs[
-				sd->hid_sensor_client_cnt].pdata_size =
+				sd->hid_sensor_hub_client_devs[
+					sd->hid_sensor_client_cnt].pdata_size =
 						sizeof(*sd->hsdev);
-			hid_dbg(hdev, "Adding %s:%p\n", name, sd);
-			sd->hid_sensor_client_cnt++;
+				hid_dbg(hdev, "Adding %s:%p\n", name, sd);
+				sd->hid_sensor_client_cnt++;
+			}
 		}
+#if SENSCOL
+			/* Create senscol sensor from each report, regardles of is_supported() */
+			do {
+				struct sensor_def	*senscol_sensor;
+				int	j;
+				const char	*usage_name;
+
+				senscol_sensor = alloc_senscol_sensor();
+				if (!senscol_sensor) {
+					printk(KERN_ERR "%s(): failed to allocate senscol_sensor\n", __func__);
+					break;
+				}
+				init_senscol_sensor(senscol_sensor);
+				/* TODO: for known sensors from HID usages should appear known name */
+				usage_name = senscol_usage_to_name(field->physical & 0xFFFF);
+				if (usage_name)
+					senscol_sensor->name = kasprintf(GFP_KERNEL, "%s", usage_name);
+				else
+					senscol_sensor->name = kasprintf(GFP_KERNEL, "custom-%X", field->physical);
+				if (!senscol_sensor->name) {
+					printk(KERN_ERR "%s(): failed to allocate memory for senscol_sensor->name\n", __func__);
+					kfree(senscol_sensor);
+					break;
+				}
+				senscol_sensor->usage_id = field->physical;
+				senscol_sensor->id = sd->sensor_hub_index << 16 | report->id & 0xFFFF;
+				senscol_sensor->impl = &hid_senscol_impl;
+				senscol_sensor->sample_size = 0;
+
+				/* Add properties */
+				/* 1 find matching feature report */
+				list_for_each_entry(freport, &feat_report_enum->report_list, list) {
+					feat_field = freport->field[0];
+					if (freport->maxfield && feat_field && feat_field->physical && (feat_field->physical == senscol_sensor->usage_id))
+						break;
+				}
+
+				/*2 . dump each prop field */
+				for (i = 0; i < freport->maxfield; ++i) {
+					struct sens_property	prop_field;
+
+					dev_dbg(&hdev->dev, "ZZZ %d collection_index:%x hid:%x sz:%x order: %x\n",
+							i, freport->field[i]->usage->collection_index,
+							freport->field[i]->usage->hid,
+							freport->field[i]->report_size/8,
+							freport->field[i]->report_count);
+
+					memset(&prop_field, 0, sizeof(struct sens_property));
+					prop_field.usage_id = freport->field[i]->usage->hid;
+					usage_name = senscol_usage_to_name(prop_field.usage_id  & 0xFFFF);
+					if (usage_name)
+						prop_field.name = kasprintf(GFP_KERNEL, "%s", usage_name);
+					else /* there is  a special case when the property is related to specific data field/ set of fields */ {
+						uint32_t modifier = prop_field.usage_id & 0xF000;
+						uint32_t data_hid  = prop_field.usage_id & 0x0FFF;
+						usage_name = senscol_usage_to_name(data_hid);
+						dev_dbg(&hdev->dev, "%s(): DATANAME %s \n", __func__, usage_name);
+						if (!usage_name)
+							prop_field.name = kasprintf(GFP_KERNEL, "unknown-%X", prop_field.usage_id);
+						else {
+							const char *modif_name = senscol_get_modifier(modifier);
+							dev_dbg(&hdev->dev, "%s(): MODIFNAME %s \n", __func__, modif_name);
+							prop_field.name = kasprintf(GFP_KERNEL, "%s_%s", usage_name, modif_name);
+						}
+					}
+					prop_field.is_numeric = (freport->field[i]->flags  & HID_MAIN_ITEM_VARIABLE) && (!hid_is_string_property(prop_field.usage_id));
+
+					rv = add_sens_property(senscol_sensor, &prop_field);
+					dev_dbg(&hdev->dev, "%s(): add_prop_field() for prop %s returned %d\n", __func__, prop_field.name, rv);
+
+
+				}
+
+				/* Add data fields; Dump fields in this report. `maxfield' is upper-bound NON-INCLUSIVE */
+				for (j = 0; j < report->maxfield; ++j) {
+					int	k;
+					bool need_internal_index = false;
+
+					dev_dbg(&hdev->dev, "%s(): field:%d physical=%08X logical=%08X maxusage=%u report_type=%u "
+						"report_size=%u (bytes) logic_min=%d logic_max=%d phys_min=%d phys_max=%d exp=%d unit=%u rep cnt=%d\n",
+						__func__, j, report->field[j]->physical, report->field[j]->logical,
+						report->field[j]->maxusage, report->field[j]->report_type,
+						report->field[j]->report_size >> 3,
+						report->field[j]->logical_minimum, report->field[j]->logical_maximum,
+						report->field[j]->physical_minimum, report->field[j]->physical_maximum,
+						report->field[j]->unit_exponent, report->field[j]->unit,
+						report->field[j]->report_count);
+					dev_dbg(&hdev->dev, "%s(): usages --\n", __func__);
+
+					if (report->field[j]->report_count > 1) {
+						int instancesCnt = 0;
+						for (k = 0; k < report->field[j]->maxusage; ++k)
+							if (is_sens_data_field(report->field[j]->usage[k].hid & 0xFFFF))
+								instancesCnt++;
+
+						if (instancesCnt > 1)
+							need_internal_index = true;
+					}
+
+					for (k = 0; k < report->field[j]->maxusage; ++k) {
+						dev_dbg(&hdev->dev, "	%s(): usage:%d hid=%08X\n", __func__,
+							k, report->field[j]->usage[k].hid);
+
+						/* Add data fields */
+						if (is_sens_data_field(report->field[j]->usage[k].hid & 0xFFFF)) {
+							struct data_field	data_field;
+
+							memset(&data_field, 0, sizeof(struct data_field));
+
+							usage_name = senscol_usage_to_name(report->field[j]->usage[k].hid & 0xFFFF);
+							if (usage_name)
+								data_field.name = need_internal_index	? kasprintf(GFP_KERNEL, "%s_%d", usage_name, k)
+																		: kasprintf(GFP_KERNEL, "%s", usage_name);
+							else {
+								printk(KERN_ERR "%s():got problematic name for usage  %08X\n", __func__, report->field[j]->usage[k].hid);
+								data_field.name = need_internal_index	? kasprintf(GFP_KERNEL, "data-%X_%d", report->field[j]->usage[k].hid, k)
+																		: kasprintf(GFP_KERNEL, "data-%X", report->field[j]->usage[k].hid);
+							}
+							if (!data_field.name) {
+								printk(KERN_ERR "%s(): Failed to allocated data field for usage %08X\n", __func__, report->field[j]->usage[k].hid);
+								continue;
+							}
+
+							data_field.usage_id = report->field[j]->usage[k].hid;
+							data_field.is_numeric = (report->field[j]->flags  & HID_MAIN_ITEM_VARIABLE);
+							if (data_field.is_numeric) {
+								if (report->field[j]->unit_exponent > 7 || report->field[j]->unit_exponent < -8)
+									data_field.exp = 0xFF;
+								else if (report->field[j]->unit_exponent >= 0)
+									data_field.exp = report->field[j]->unit_exponent;
+								else
+									data_field.exp = 0x10 - report->field[j]->unit_exponent;
+								data_field.unit = report->field[j]->unit;
+							}
+							
+							data_field.len = (report->field[j]->report_size >> 3) * report->field[j]->report_count;
+							rv = add_data_field(senscol_sensor, &data_field);
+							dev_dbg(&hdev->dev, "%s(): add_data_field() returned %d\n", __func__, rv);
+							senscol_sensor->sample_size += report->field[j]->report_size >> 3;
+						}
+					}
+				}
+
+				/* Add senscol_sensor */
+				rv = add_senscol_sensor(senscol_sensor);
+				dev_dbg(&hdev->dev, "%s(): add_senscol_sensor() returned %d\n", __func__, rv);
+			} while (0);
+#endif
 	}
+#if IIO
 	ret = mfd_add_devices(&hdev->dev, 0, sd->hid_sensor_hub_client_devs,
 		sd->hid_sensor_client_cnt, NULL, 0, NULL);
 	if (ret < 0)
 		goto err_free_names;
-
+#endif
 	return ret;
 
 err_free_names:
@@ -637,6 +1147,10 @@ err_free_names:
 	kfree(sd->hid_sensor_hub_client_devs);
 err_stop_hw:
 	hid_hw_stop(hdev);
+err_free:
+	kfree(sd->hsdev);
+err_free_hub:
+	kfree(sd);
 
 	return ret;
 }
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 8dacd4c..73ef724 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -536,5 +536,6 @@ source "drivers/misc/lis3lv02d/Kconfig"
 source "drivers/misc/carma/Kconfig"
 source "drivers/misc/altera-stapl/Kconfig"
 source "drivers/misc/mei/Kconfig"
+source "drivers/misc/heci/Kconfig"
 source "drivers/misc/vmw_vmci/Kconfig"
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index c235d5b..5b9c058 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -50,6 +50,7 @@ obj-y				+= carma/
 obj-$(CONFIG_USB_SWITCH_FSA9480) += fsa9480.o
 obj-$(CONFIG_ALTERA_STAPL)	+=altera-stapl/
 obj-$(CONFIG_INTEL_MEI)		+= mei/
+obj-$(CONFIG_INTEL_ISH)		+= heci/
 obj-$(CONFIG_VMWARE_VMCI)	+= vmw_vmci/
 obj-$(CONFIG_LATTICE_ECP3_CONFIG)	+= lattice-ecp3-config.o
 obj-$(CONFIG_SRAM)		+= sram.o
diff --git a/drivers/misc/heci/Kconfig b/drivers/misc/heci/Kconfig
new file mode 100644
index 0000000..42f7f66
--- /dev/null
+++ b/drivers/misc/heci/Kconfig
@@ -0,0 +1,13 @@
+config INTEL_ISH
+	tristate "Intel Integrated Sensors Hub"
+	depends on X86 && PCI
+	help
+	  ISH enabled sensors hub functionality on SoC/chipset level.
+
+config ISH_PATH_SENSCOL
+	tristate "ISH path through sensor-collection"
+	depends on INTEL_ISH
+
+config ISH_PATH_IIO
+	tristate "ISH path through IIO"
+	depends on INTEL_ISH
diff --git a/drivers/misc/heci/Makefile b/drivers/misc/heci/Makefile
new file mode 100644
index 0000000..93721ff
--- /dev/null
+++ b/drivers/misc/heci/Makefile
@@ -0,0 +1,23 @@
+#
+# Makefile - Intel HECI (ISH implementation)
+# Copyright (c) 2010-2014, Intel Corporation.
+#
+obj-m += heci.o
+heci-objs := init.o
+heci-objs += hbm.o
+heci-objs += client.o
+heci-objs += heci-api.o
+heci-objs += bus.o
+heci-$(CONFIG_DEBUG_FS) += debugfs.o
+
+obj-m += heci-ish.o
+heci-ish-objs := hw-ish.o
+heci-ish-objs += pci-ish.o
+
+obj-m += hid-heci-ish.o
+hid-heci-ish-objs := heci-hid.o
+hid-heci-ish-objs += heci-hid-client.o
+
+obj-m += sens-col-core.o
+sens-col-core-objs := senscol-core.o
+
diff --git a/drivers/misc/heci/bus.c b/drivers/misc/heci/bus.c
new file mode 100644
index 0000000..314ca52
--- /dev/null
+++ b/drivers/misc/heci/bus.c
@@ -0,0 +1,627 @@
+/*
+ * HECI bus driver
+ *
+ * Copyright (c) 2012-2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include "bus.h"
+#include "heci_dev.h"
+#include "client.h"
+#include <asm/page.h>
+#include "hbm.h"
+#include "utils.h"
+
+#define to_heci_cl_driver(d) container_of(d, struct heci_cl_driver, driver)
+#define to_heci_cl_device(d) container_of(d, struct heci_cl_device, dev)
+
+/**
+ * heci_me_cl_by_uuid - locate index of me client
+ *
+ * @dev: heci device
+ * returns me client index or -ENOENT if not found
+ */
+int heci_me_cl_by_uuid(const struct heci_device *dev, const uuid_le *uuid)
+{
+	int i, res = -ENOENT;
+
+	for (i = 0; i < dev->me_clients_num; ++i) {
+		if (uuid_le_cmp(*uuid, dev->me_clients[i].props.protocol_name) == 0) {
+			res = i;
+			break;
+		}
+	}
+	return res;
+}
+EXPORT_SYMBOL(heci_me_cl_by_uuid);
+
+
+/**
+ * heci_me_cl_by_id return index to me_clients for client_id
+ *
+ * @dev: the device structure
+ * @client_id: me client id
+ *
+ * returns index on success, -ENOENT on failure.
+ */
+
+int heci_me_cl_by_id(struct heci_device *dev, u8 client_id)
+{
+	int i;
+	for (i = 0; i < dev->me_clients_num; i++)
+		if (dev->me_clients[i].client_id == client_id)
+			break;
+	if (WARN_ON(dev->me_clients[i].client_id != client_id))
+		return -ENOENT;
+
+	if (i == dev->me_clients_num)
+		return -ENOENT;
+
+	return i;
+}
+
+static int heci_cl_device_match(struct device *dev, struct device_driver *drv)
+{
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++ returns 1\n", __func__);
+
+	/*
+	 * DD -- return true and let driver's probe() routine decide.
+	 * If this solution lives up, we can rearrange it by simply removing match() routine at all
+	 */
+	return	1;
+}
+
+static int heci_cl_device_probe(struct device *dev)
+{
+	struct heci_cl_device *device = to_heci_cl_device(dev);
+	struct heci_cl_driver *driver;
+	struct heci_cl_device_id id;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	if (!device)
+		return 0;
+
+	/* in many cases here will be NULL */
+	driver = to_heci_cl_driver(dev->driver);
+	if (!driver || !driver->probe)
+		return -ENODEV;
+
+	dev_dbg(dev, "Device probe\n");
+
+	strncpy(id.name, dev_name(dev), HECI_CL_NAME_SIZE);
+
+	return driver->probe(device, &id);
+}
+
+static int heci_cl_device_remove(struct device *dev)
+{
+	struct heci_cl_device *device = to_heci_cl_device(dev);
+	struct heci_cl_driver *driver;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	if (!device || !dev->driver)
+		return 0;
+
+	if (device->event_cb) {
+		device->event_cb = NULL;
+		cancel_work_sync(&device->event_work);
+	}
+
+	driver = to_heci_cl_driver(dev->driver);
+	if (!driver->remove) {
+		dev->driver = NULL;
+
+		return 0;
+	}
+
+	return driver->remove(device);
+}
+
+static ssize_t modalias_show(struct device *dev, struct device_attribute *a, char *buf)
+{
+	int len;
+
+	len = snprintf(buf, PAGE_SIZE, "heci:%s\n", dev_name(dev));
+	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+}
+
+static struct device_attribute heci_cl_dev_attrs[] = {
+	__ATTR_RO(modalias),
+	__ATTR_NULL,
+};
+
+static int heci_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	if (add_uevent_var(env, "MODALIAS=heci:%s", dev_name(dev)))
+		return -ENOMEM;
+
+	return 0;
+}
+
+static struct bus_type heci_cl_bus_type = {
+	.name		= "heci",
+	.dev_attrs	= heci_cl_dev_attrs,
+	.match		= heci_cl_device_match,
+	.probe		= heci_cl_device_probe,
+	.remove		= heci_cl_device_remove,
+	.uevent		= heci_cl_uevent,
+};
+
+static void heci_cl_dev_release(struct device *dev)
+{
+	ISH_DBG_PRINT(KERN_ALERT "%s():+++\n", __func__);
+	kfree(to_heci_cl_device(dev));
+	ISH_DBG_PRINT(KERN_ALERT "%s():---\n", __func__);
+}
+
+static struct device_type heci_cl_device_type = {
+	.release	= heci_cl_dev_release,
+};
+
+/*
+ * Allocate HECI bus client device, attach it to uuid and register with HECI bus
+ */
+struct heci_cl_device *heci_bus_add_device(struct heci_device *dev, uuid_le uuid, char *name, struct heci_cl_dev_ops *ops)
+{
+	struct heci_cl_device *device;
+	int status;
+
+	device = kzalloc(sizeof(struct heci_cl_device), GFP_KERNEL);
+	if (!device)
+		return NULL;
+
+	device->ops = ops;
+
+	device->dev.parent = &dev->pdev->dev;
+	device->dev.bus = &heci_cl_bus_type;
+	device->dev.type = &heci_cl_device_type;
+	device->heci_dev = dev;
+	device->fw_client = &dev->me_clients[dev->me_client_presentation_num - 1];
+
+	dev_set_name(&device->dev, "%s", name);
+
+	status = device_register(&device->dev);
+	if (status) {
+		dev_err(&dev->pdev->dev, "Failed to register HECI device\n");
+		kfree(device);
+		return NULL;
+	}
+
+	dev_dbg(&device->dev, "client %s registered\n", name);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): Registered HECI device\n", __func__);
+
+	return device;
+}
+EXPORT_SYMBOL_GPL(heci_bus_add_device);
+
+
+/*
+ * This is a counterpart of heci_bus_add_device. Device is unregistered and its structure is also freed
+ */
+void heci_bus_remove_device(struct heci_cl_device *device)
+{
+	device_unregister(&device->dev);
+	/*kfree(device);*/
+}
+EXPORT_SYMBOL_GPL(heci_bus_remove_device);
+
+
+/*
+ * Part of reset flow
+ */
+void	heci_bus_remove_all_clients(struct heci_device *heci_dev)
+{
+	struct heci_cl_device *heci_cl_dev;
+	struct heci_cl	*cl, *next;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&heci_dev->device_lock, flags);
+	list_for_each_entry_safe(cl, next, &heci_dev->cl_list, link) {
+		list_del(&cl->link);
+		spin_unlock_irqrestore(&heci_dev->device_lock, flags);
+		heci_cl_dev = cl->device;
+
+		/*
+		 * Wake any pending process. The waiter would check dev->state and determine that it's not enabled already, and will return error to its caller
+		 */
+		if (waitqueue_active(&cl->rx_wait))
+			wake_up_interruptible(&cl->rx_wait);
+		if (waitqueue_active(&cl->wait_ctrl_res))
+			wake_up(&cl->wait_ctrl_res);
+
+		/* Disband any pending read/write requests */
+		heci_cl_flush_queues(cl);
+
+		if (cl->read_rb) {
+			struct heci_cl_rb *rb = NULL;
+
+			rb = heci_cl_find_read_rb(cl);
+			/* Remove entry from read list */
+			if (rb)
+				list_del(&rb->list);
+
+			rb = cl->read_rb;
+			cl->read_rb = NULL;
+
+			if (rb) {
+				heci_io_rb_free(rb);
+				rb = NULL;
+			}
+		}
+
+		/* Unregister HECI bus client device */
+		heci_bus_remove_device(heci_cl_dev);
+
+		/* Free client and HECI bus client device structures */
+		kfree(cl);
+		spin_lock_irqsave(&heci_dev->device_lock, flags);
+	}
+	spin_unlock_irqrestore(&heci_dev->device_lock, flags);
+#if 0
+	if (waitqueue_active(&heci_dev->wait_recvd_msg))
+		wake_up(&heci_dev->wait_recvd_msg);
+#endif
+
+	/* Free all client structures */
+	kfree(heci_dev->me_clients);
+	heci_dev->me_clients = NULL;
+	heci_dev->me_clients_num = 0;
+	heci_dev->me_client_presentation_num  = 0;
+	heci_dev->me_client_index = 0;
+	bitmap_zero(heci_dev->me_clients_map, HECI_CLIENTS_MAX);
+	bitmap_zero(heci_dev->host_clients_map, HECI_CLIENTS_MAX);
+	bitmap_set(heci_dev->host_clients_map, 0, 3);
+}
+EXPORT_SYMBOL_GPL(heci_bus_remove_all_clients);
+
+
+int __heci_cl_driver_register(struct heci_cl_driver *driver, struct module *owner)
+{
+	int err;
+
+	driver->driver.name = driver->name;
+	driver->driver.owner = owner;
+	driver->driver.bus = &heci_cl_bus_type;
+
+	err = driver_register(&driver->driver);
+	if (err)
+		return err;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): heci: driver [%s] registered\n", __func__, driver->driver.name);
+	pr_debug("heci: driver [%s] registered\n", driver->driver.name);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(__heci_cl_driver_register);
+
+void heci_cl_driver_unregister(struct heci_cl_driver *driver)
+{
+	driver_unregister(&driver->driver);
+
+	pr_debug("heci: driver [%s] unregistered\n", driver->driver.name);
+}
+EXPORT_SYMBOL_GPL(heci_cl_driver_unregister);
+
+
+static void heci_bus_event_work(struct work_struct *work)
+{
+	struct heci_cl_device *device;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	device = container_of(work, struct heci_cl_device, event_work);
+
+	if (device->event_cb)
+		device->event_cb(device, device->events, device->event_context);
+
+	/*device->events = 0;*/
+}
+
+int heci_register_event_cb(struct heci_cl_device *device, void (*event_cb)(struct heci_cl_device *, u32, void *), void *context)
+{
+	if (device->event_cb)
+		return -EALREADY;
+
+	/*device->events = 0;*/
+	device->event_cb = event_cb;
+	device->event_context = context;
+	INIT_WORK(&device->event_work, heci_bus_event_work);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(heci_register_event_cb);
+
+void *heci_cl_get_drvdata(const struct heci_cl_device *device)
+{
+	return dev_get_drvdata(&device->dev);
+}
+EXPORT_SYMBOL_GPL(heci_cl_get_drvdata);
+
+void heci_cl_set_drvdata(struct heci_cl_device *device, void *data)
+{
+	dev_set_drvdata(&device->dev, data);
+}
+EXPORT_SYMBOL_GPL(heci_cl_set_drvdata);
+
+/* What's this? */
+int heci_cl_enable_device(struct heci_cl_device *device)
+{
+	if (!device->ops || !device->ops->enable)
+		return 0;
+
+	return device->ops->enable(device);
+}
+EXPORT_SYMBOL_GPL(heci_cl_enable_device);
+
+int heci_cl_disable_device(struct heci_cl_device *device)
+{
+	if (!device->ops || !device->ops->disable)
+		return 0;
+
+	return device->ops->disable(device);
+}
+EXPORT_SYMBOL_GPL(heci_cl_disable_device);
+/************************/
+
+void heci_cl_bus_rx_event(struct heci_cl_device *device)
+{
+	static int	rx_count;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++ [%d]\n", __func__, rx_count++);
+	if (!device || !device->event_cb)
+		return;
+
+	set_bit(HECI_CL_EVENT_RX, &device->events);
+
+	if (device->event_cb)
+		schedule_work(&device->event_work);
+}
+
+int __init heci_cl_bus_init(void)
+{
+	int	rv;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): Registering HECI bus\n", __func__);
+	rv = bus_register(&heci_cl_bus_type);
+	if (!rv)
+		heci_cl_alloc_dma_buf();
+	return	rv;
+}
+
+void __exit heci_cl_bus_exit(void)
+{
+ISH_DBG_PRINT(KERN_ALERT "%s(): Unregistering HECI bus\n", __func__);
+	bus_unregister(&heci_cl_bus_type);
+}
+
+
+ssize_t cl_prop_read(struct device *dev, struct device_attribute *dev_attr, char *buf)
+{
+	ssize_t	rv = -EINVAL;
+	struct heci_cl_device	*cl_device = to_heci_cl_device(dev);
+	unsigned long	flags;
+
+	if (!strcmp(dev_attr->attr.name, "max_msg_length")) {
+		sprintf(buf, "%u\n", (unsigned)cl_device->fw_client->props.max_msg_length);
+		rv = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name, "protocol_version")) {
+		sprintf(buf, "%u\n", (unsigned)cl_device->fw_client->props.protocol_version);
+		rv = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name,  "max_number_of_connections")) {
+		sprintf(buf, "%u\n", (unsigned)cl_device->fw_client->props.max_number_of_connections);
+		rv = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name,  "fixed_address")) {
+		sprintf(buf, "%u\n", (unsigned)cl_device->fw_client->props.fixed_address);
+		rv = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name,  "single_recv_buf")) {
+		sprintf(buf, "%u\n", (unsigned)cl_device->fw_client->props.single_recv_buf);
+		rv = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name,  "dma_hdr_len")) {
+		sprintf(buf, "%u\n", (unsigned)cl_device->fw_client->props.dma_hdr_len);
+		rv = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name,  "num_active_connections")) {
+		struct heci_cl	*cl, *next;
+		unsigned	count = 0;
+
+		spin_lock_irqsave(&cl_device->heci_dev->device_lock, flags);
+		list_for_each_entry_safe(cl, next, &cl_device->heci_dev->cl_list, link) {
+			if (cl->state == HECI_CL_CONNECTED && cl->device == cl_device)
+				++count;
+		}
+		spin_unlock_irqrestore(&cl_device->heci_dev->device_lock, flags);
+
+		sprintf(buf, "%u\n", count);
+		rv = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name,  "client_id")) {
+		sprintf(buf, "%u\n", (unsigned)cl_device->fw_client->client_id);
+		rv = strlen(buf);
+	}
+	
+	return	rv;
+}
+
+ssize_t	cl_prop_write(struct device *dev, struct device_attribute *dev_attr, const char *buf, size_t count)
+{
+        return	-EINVAL;
+}
+
+static struct device_attribute	max_msg_length = {
+	.attr = {
+		.name = "max_msg_length",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = cl_prop_read,
+	.store = cl_prop_write
+};
+
+static struct device_attribute	protocol_version = {
+	.attr = {
+		.name = "protocol_version",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = cl_prop_read,
+	.store = cl_prop_write
+};
+
+static struct device_attribute	max_number_of_connections = {
+	.attr = {
+		.name = "max_number_of_connections",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = cl_prop_read,
+	.store = cl_prop_write
+};
+
+static struct device_attribute	fixed_address = {
+	.attr = {
+		.name = "fixed_address",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = cl_prop_read,
+	.store = cl_prop_write
+};
+
+static struct device_attribute	single_recv_buf = {
+	.attr = {
+		.name = "single_recv_buf",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = cl_prop_read,
+	.store = cl_prop_write
+};
+
+static struct device_attribute	dma_hdr_len = {
+	.attr = {
+		.name = "dma_hdr_len",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = cl_prop_read,
+	.store = cl_prop_write
+};
+
+static struct device_attribute	num_active_connections = {
+	.attr = {
+		.name = "num_active_connections",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = cl_prop_read,
+	.store = cl_prop_write
+};
+
+static struct device_attribute	client_id = {
+	.attr = {
+		.name = "client_id",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = cl_prop_read,
+	.store = cl_prop_write
+};
+
+/*
+ * Enum-completion callback for HECI bus - heci_device has reported its clients
+ */
+int	heci_bus_new_client(struct heci_device *dev)
+{
+	int	i;
+	char	*dev_name;
+	struct heci_cl_device	*cl_device;
+	uuid_le	device_uuid;
+
+	/*
+	 * For all reported clients, create an unconnected client and add its device to HECI bus.
+	 * If appropriate driver has loaded, this will trigger its probe(). Otherwise, probe() will be called when driver is loaded
+	 */
+	i = dev->me_client_presentation_num - 1;
+	device_uuid = dev->me_clients[i].props.protocol_name;
+	dev_name = kasprintf(GFP_ATOMIC, "{%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
+		device_uuid.b[3], device_uuid.b[2], device_uuid.b[1], device_uuid.b[0],
+		device_uuid.b[5], device_uuid.b[4],
+		device_uuid.b[7], device_uuid.b[6],
+		device_uuid.b[8], device_uuid.b[9],
+		device_uuid.b[10], device_uuid.b[11], device_uuid.b[12], device_uuid.b[13], device_uuid.b[14], device_uuid.b[15]);
+	if (!dev_name)
+		return	-ENOMEM;
+
+	cl_device = heci_bus_add_device(dev, device_uuid, dev_name, NULL);
+	if (!cl_device) {
+		kfree(dev_name);
+		return	-ENOENT;
+	}
+
+	list_add_tail(&cl_device->device_link, &dev->device_list);
+
+	/* Export several properties per client device */
+	device_create_file(&cl_device->dev, &max_msg_length);
+	device_create_file(&cl_device->dev, &protocol_version);
+	device_create_file(&cl_device->dev, &max_number_of_connections);
+	device_create_file(&cl_device->dev, &fixed_address);
+	device_create_file(&cl_device->dev, &single_recv_buf);
+	device_create_file(&cl_device->dev, &dma_hdr_len);
+	device_create_file(&cl_device->dev, &num_active_connections);
+	device_create_file(&cl_device->dev, &client_id);
+
+	return	0;
+}
+
+
+static int	does_driver_bind_uuid(struct device *dev, void *id)
+{
+	uuid_le	*uuid = id;
+	struct heci_cl_device	*device;
+
+	if (!dev->driver)
+		return	0;
+
+	device = to_heci_cl_device(dev);
+	if (!uuid_le_cmp(device->fw_client->props.protocol_name, *uuid))
+		return	1;
+
+	return	0;
+}
+
+
+int	heci_can_client_connect(struct heci_device *heci_dev, uuid_le *uuid)
+{
+	int	rv;
+
+	rv = bus_for_each_dev(&heci_cl_bus_type, NULL, uuid, does_driver_bind_uuid);
+	return	!rv;
+}
+
+
+/* Binds connected heci_cl to HECI bus device */
+int	heci_cl_device_bind(struct heci_cl *cl)
+{
+	int	rv;
+	struct heci_cl_device	*cl_device, *next;
+
+	if (!cl->me_client_id || cl->state != HECI_CL_CONNECTED)
+		return	-EFAULT;
+
+	rv = -ENOENT;
+	list_for_each_entry_safe(cl_device, next, &cl->dev->device_list, device_link) {
+		if (cl_device->fw_client->client_id == cl->me_client_id) {
+			cl->device = cl_device;
+			rv = 0;
+			break;
+		}
+	}
+
+	return	rv;
+}
+
diff --git a/drivers/misc/heci/bus.h b/drivers/misc/heci/bus.h
new file mode 100644
index 0000000..30966bc
--- /dev/null
+++ b/drivers/misc/heci/bus.h
@@ -0,0 +1,105 @@
+#ifndef _LINUX_HECI_CL_BUS_H
+#define _LINUX_HECI_CL_BUS_H
+
+#include <linux/device.h>
+#include <linux/uuid.h>
+
+/*typedef void (*heci_cl_event_cb_t)(struct heci_cl_device *device, u32 events, void *context);*/
+
+struct heci_cl;
+struct heci_cl_device;
+struct heci_device;
+
+#define	HECI_CL_NAME_SIZE	32
+
+struct heci_cl_device_id {
+	char name[MEI_CL_NAME_SIZE];
+	kernel_ulong_t driver_info;
+};
+
+/**
+ * struct heci_cl_dev_ops - HECI CL device ops
+ * This structure allows ME host clients to implement technology
+ * specific operations.
+ *
+ * @enable: Enable an HECI CL device. Some devices require specific
+ *	HECI commands to initialize completely.
+ * @disable: Disable an HECI CL device.
+ * @send: Tx hook for the device. This allows ME host clients to trap
+ *	the device driver buffers before actually physically
+ *	pushing it to the ME.
+ * @recv: Rx hook for the device. This allows ME host clients to trap the
+ *	ME buffers before forwarding them to the device driver.
+ */
+struct heci_cl_dev_ops {
+	int (*enable)(struct heci_cl_device *device);
+	int (*disable)(struct heci_cl_device *device);
+	int (*send)(struct heci_cl_device *device, u8 *buf, size_t length);
+	int (*recv)(struct heci_cl_device *device, u8 *buf, size_t length);
+};
+
+struct heci_cl_device *heci_bus_add_device(struct heci_device *dev, uuid_le uuid, char *name, struct heci_cl_dev_ops *ops);
+void heci_bus_remove_device(struct heci_cl_device *device);
+
+/**
+ * struct heci_cl_device - HECI device handle
+ * An heci_cl_device pointer is returned from heci_add_device()
+ * and links HECI bus clients to their actual ME host client pointer.
+ * Drivers for HECI devices will get an heci_cl_device pointer
+ * when being probed and shall use it for doing ME bus I/O.
+ *
+ * @dev: linux driver model device pointer
+ * @uuid: me client uuid
+ * @cl: heci client
+ * @ops: ME transport ops
+ * @event_cb: Drivers register this callback to get asynchronous ME
+ *	events (e.g. Rx buffer pending) notifications.
+ * @events: Events bitmask sent to the driver.
+ * @priv_data: client private data
+ */
+struct heci_cl_device {
+	struct device dev;
+	/*struct heci_cl *cl;*/
+	struct heci_device	*heci_dev;
+	struct heci_me_client	*fw_client;	/* For easy reference */
+	struct list_head	device_link;
+	const struct heci_cl_dev_ops *ops;
+	struct work_struct event_work;
+	void (*event_cb)(struct heci_cl_device *device, u32 events, void *context);
+	void *event_context;
+	unsigned long events;
+	void *priv_data;
+};
+
+struct heci_cl_driver {
+	struct device_driver driver;
+	const char *name;
+	const struct heci_cl_device_id *id_table;
+	int (*probe)(struct heci_cl_device *dev, const struct heci_cl_device_id *id);
+	int (*remove)(struct heci_cl_device *dev);
+};
+
+int __heci_cl_driver_register(struct heci_cl_driver *driver, struct module *owner);
+#define heci_cl_driver_register(driver)             \
+	__heci_cl_driver_register(driver, THIS_MODULE)
+
+void heci_cl_driver_unregister(struct heci_cl_driver *driver);
+int heci_register_event_cb(struct heci_cl_device *device, void (*read_cb)(struct heci_cl_device *, u32, void *), void *context);
+
+#define HECI_CL_EVENT_RX 0
+#define HECI_CL_EVENT_TX 1
+
+void *heci_cl_get_drvdata(const struct heci_cl_device *device);
+void heci_cl_set_drvdata(struct heci_cl_device *device, void *data);
+
+int heci_cl_enable_device(struct heci_cl_device *device);
+int heci_cl_disable_device(struct heci_cl_device *device);
+
+void heci_cl_bus_rx_event(struct heci_cl_device *device);
+int heci_cl_bus_init(void);
+void heci_cl_bus_exit(void);
+int	heci_bus_new_client(struct heci_device *dev);
+void	heci_remove_all_clients(struct heci_device *dev);
+int	heci_cl_device_bind(struct heci_cl *cl);
+
+#endif /* _LINUX_HECI_CL_BUS_H */
diff --git a/drivers/misc/heci/client.c b/drivers/misc/heci/client.c
new file mode 100644
index 0000000..908f4c3
--- /dev/null
+++ b/drivers/misc/heci/client.c
@@ -0,0 +1,1142 @@
+/*
+ * HECI client logic (for both HECI bus driver and user-mode API)
+ *
+ * Copyright (c) 2003-2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/export.h>
+#include <linux/pci.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+#include "heci_dev.h"
+#include "hbm.h"
+#include "client.h"
+#include "utils.h"
+
+#ifdef dev_dbg
+#undef dev_dbg
+#endif
+static void no_dev_dbg(void *v, char *s, ...)
+{
+}
+#define dev_dbg no_dev_dbg
+/*#define dev_dbg dev_err*/
+
+int	host_dma_enabled;
+void	*host_dma_buf;
+unsigned	host_dma_buf_size = (1024*1024);
+uint64_t	host_dma_buf_phys;
+int	dma_ready = 1;
+
+
+void	heci_cl_alloc_dma_buf(void)
+{
+	int	order;
+	unsigned	temp;
+
+	/* Try to allocate 256 contiguous pages (1 M) for DMA and enabled host DMA */
+	for (order = 0, temp = host_dma_buf_size / PAGE_SIZE + 1; temp; temp >>= 1)
+		++order;
+	host_dma_buf = (void *)__get_free_pages(GFP_KERNEL, order);
+	if (host_dma_buf) {
+		host_dma_buf_phys = __pa(host_dma_buf);
+		host_dma_enabled = 1;
+	}
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): host_dma_enabled=%d host_dma_buf=%p host_dma_buf_phys=%llX host_dma_buf_size=%u order=%d\n", __func__, host_dma_enabled, host_dma_buf, host_dma_buf_phys, host_dma_buf_size, order);
+}
+
+
+/**
+ * heci_io_list_flush - removes list entry belonging to cl.
+ *
+ * @list:  An instance of our list structure
+ * @cl: host client
+ */
+void heci_io_list_flush(struct heci_cl_rb *list, struct heci_cl *cl)
+{
+	struct heci_cl_rb *rb;
+	struct heci_cl_rb *next;
+
+	list_for_each_entry_safe(rb, next, &list->list, list) {
+		if (rb->cl && heci_cl_cmp_id(cl, rb->cl)) {
+			list_del(&rb->list);
+			heci_io_rb_free(rb);
+		}
+	}
+}
+
+/**
+ * heci_io_rb_free - free heci_rb_private related memory
+ *
+ * @rb: heci callback struct
+ */
+void heci_io_rb_free(struct heci_cl_rb *rb)
+{
+	if (rb == NULL)
+		return;
+
+	kfree(rb->buffer.data);
+	kfree(rb);
+}
+EXPORT_SYMBOL(heci_io_rb_free);
+
+/**
+ * heci_io_rb_init - allocate and initialize io callback
+ *
+ * @cl - heci client
+ * @file: pointer to file structure
+ *
+ * returns heci_cl_rb pointer or NULL;
+ */
+struct heci_cl_rb *heci_io_rb_init(struct heci_cl *cl)
+{
+	struct heci_cl_rb *rb;
+
+	rb = kzalloc(sizeof(struct heci_cl_rb), GFP_KERNEL);
+	if (!rb)
+		return NULL;
+
+	heci_io_list_init(rb);
+
+	rb->cl = cl;
+	rb->buf_idx = 0;
+	return rb;
+}
+
+
+/**
+ * heci_io_rb_alloc_buf - allocate respose buffer
+ *
+ * @rb -  io callback structure
+ * @size: size of the buffer
+ *
+ * returns 0 on success
+ *         -EINVAL if rb is NULL
+ *         -ENOMEM if allocation failed
+ */
+int heci_io_rb_alloc_buf(struct heci_cl_rb *rb, size_t length)
+{
+	if (!rb)
+		return -EINVAL;
+
+	if (length == 0)
+		return 0;
+
+	rb->buffer.data = kmalloc(length, GFP_KERNEL);
+	if (!rb->buffer.data)
+		return -ENOMEM;
+	rb->buffer.size = length;
+	return 0;
+}
+
+
+/*
+ * heci_io_rb_recycle - re-append rb to its client's free list and send flow control if needed
+ */
+int heci_io_rb_recycle(struct heci_cl_rb *rb)
+{
+	struct heci_cl *cl;
+	int	rets = 0;
+	unsigned long	flags;
+
+	if (!rb || !rb->cl)
+		return	-EFAULT;
+
+	cl = rb->cl;
+
+	spin_lock_irqsave(&cl->free_list_spinlock, flags);
+	list_add_tail(&rb->list, &cl->free_rb_list.list);
+	spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
+
+	/* If we returned the first buffer to empty 'free' list, send flow control */
+	if (!cl->out_flow_ctrl_creds) {
+		rets = heci_cl_read_start(cl);
+	}
+
+	return	rets;
+}
+EXPORT_SYMBOL(heci_io_rb_recycle);
+
+
+/**
+ * heci_cl_flush_queues - flushes queue lists belonging to cl.
+ *
+ * @dev: the device structure
+ * @cl: host client
+ */
+int heci_cl_flush_queues(struct heci_cl *cl)
+{
+	if (WARN_ON(!cl || !cl->dev))
+		return -EINVAL;
+
+	dev_dbg(&cl->dev->pdev->dev, "remove list entry belonging to cl\n");
+	heci_io_list_flush(&cl->dev->read_list, cl);
+
+	return 0;
+}
+EXPORT_SYMBOL(heci_cl_flush_queues);
+
+
+/**
+ * heci_cl_init - initializes intialize cl.
+ *
+ * @cl: host client to be initialized
+ * @dev: heci device
+ */
+void heci_cl_init(struct heci_cl *cl, struct heci_device *dev)
+{
+	memset(cl, 0, sizeof(struct heci_cl));
+	init_waitqueue_head(&cl->wait);
+	init_waitqueue_head(&cl->rx_wait);
+	init_waitqueue_head(&cl->wait_ctrl_res);
+	spin_lock_init(&cl->free_list_spinlock);
+	spin_lock_init(&cl->in_process_spinlock);
+	INIT_LIST_HEAD(&cl->link);
+	cl->dev = dev;
+
+	INIT_LIST_HEAD(&cl->free_rb_list.list);
+	INIT_LIST_HEAD(&cl->tx_list.list);
+	INIT_LIST_HEAD(&cl->tx_free_list.list);
+	INIT_LIST_HEAD(&cl->in_process_list.list);
+
+	cl->rx_ring_size = CL_DEF_RX_RING_SIZE;
+	cl->tx_ring_size = CL_DEF_TX_RING_SIZE;
+}
+
+int	heci_cl_free_rx_ring(struct heci_cl *cl)
+{
+	struct heci_cl_rb * rb;
+
+	/* relese allocated mem- pass over free_rb_list */
+	while (!list_empty(&cl->free_rb_list.list)) {
+		rb = list_entry(cl->free_rb_list.list.next, struct heci_cl_rb, list);
+		list_del(&rb->list);
+		kfree(rb->buffer.data);
+		kfree(rb);
+	}
+
+	/* relese allocated mem- pass over in_process_list */
+	while (!list_empty(&cl->in_process_list.list)) {
+		rb = list_entry(cl->in_process_list.list.next, struct heci_cl_rb, list);
+		list_del(&rb->list);
+		kfree(rb->buffer.data);
+		kfree(rb);
+	}
+
+	return	0;
+}
+
+int	heci_cl_free_tx_ring(struct heci_cl *cl)
+{
+	struct heci_cl_tx_ring  *tx_buf;
+
+	/* relese allocated mem- pass over tx_free_list */
+	while (!list_empty(&cl->tx_free_list.list)) {
+		tx_buf = list_entry(cl->tx_free_list.list.next, struct heci_cl_tx_ring, list);
+		list_del(&tx_buf->list);
+		kfree(tx_buf->send_buf.data);
+		kfree(tx_buf);
+	}
+
+	/* relese allocated mem- pass over tx_list */
+	while (!list_empty(&cl->tx_list.list)) {
+		tx_buf = list_entry(cl->tx_list.list.next, struct heci_cl_tx_ring, list);
+		list_del(&tx_buf->list);
+		kfree(tx_buf->send_buf.data);
+		kfree(tx_buf);
+	}
+
+	return	0;
+}
+
+int	heci_cl_alloc_rx_ring(struct heci_cl *cl)
+{
+	size_t	len = cl->device->fw_client->props.max_msg_length;
+	int	j;
+	struct heci_cl_rb *rb;
+	int	ret;
+	struct heci_device *dev = cl->dev;
+
+	for (j = 0; j < cl->rx_ring_size; ++j) {
+		rb = heci_io_rb_init(cl);
+		if (!rb)
+			goto out;
+		ret = heci_io_rb_alloc_buf(rb, len);
+		if (ret)
+			goto out;
+		list_add_tail(&rb->list, &cl->free_rb_list.list);
+	}
+
+	ISH_DBG_PRINT(KERN_ALERT "%s() allocated rb pool successfully\n", __func__);
+	return	0;
+
+out:
+	dev_err(&dev->pdev->dev, "%s() error in allocating rb pool\n", __func__);
+	heci_cl_free_rx_ring(cl);
+	return	ret;
+}
+
+
+int	heci_cl_alloc_tx_ring(struct heci_cl *cl)
+{
+	size_t	len = cl->device->fw_client->props.max_msg_length;
+	int	j;
+	struct heci_device *dev = cl->dev;
+
+	/*cl->send_fc_flag = 0;*/
+	ISH_DBG_PRINT(KERN_ALERT "%s() allocated rb pool successfully\n", __func__);
+
+	/* Allocate pool to free Tx bufs */
+	for (j = 0; j < cl->tx_ring_size; ++j) {
+		struct heci_cl_tx_ring	*tx_buf;
+
+		tx_buf = kmalloc(sizeof(struct heci_cl_tx_ring), GFP_KERNEL);
+		if (!tx_buf) {
+			dev_err(&dev->pdev->dev, "%s(): error allocating Tx buffers\n", __func__);
+			goto	out;
+		}
+		memset(tx_buf, 0, sizeof(struct heci_cl_tx_ring));
+		tx_buf->send_buf.data = kmalloc(len, GFP_KERNEL);
+		if (!tx_buf->send_buf.data) {
+			dev_err(&dev->pdev->dev, "%s(): error allocating Tx buffers\n", __func__);
+			kfree(tx_buf);
+			goto	out;
+		}
+		list_add_tail(&tx_buf->list, &cl->tx_free_list.list);
+	}
+	ISH_DBG_PRINT(KERN_ALERT "%s() allocated Tx  pool successfully\n", __func__);
+
+	spin_lock_init(&cl->tx_spinlock);	
+	return	0;
+
+out:
+	dev_err(&dev->pdev->dev, "%s() error in allocating rb pool\n", __func__);
+	heci_cl_free_rx_ring(cl);
+	return	-ENOMEM;
+}
+
+
+/**
+ * heci_cl_allocate - allocates cl  structure and sets it up.
+ *
+ * @dev: heci device
+ * returns  The allocated file or NULL on failure
+ */
+struct heci_cl *heci_cl_allocate(struct heci_device *dev)
+{
+	struct heci_cl *cl;
+
+	cl = kmalloc(sizeof(struct heci_cl), GFP_ATOMIC);
+	if (!cl)
+		return NULL;
+
+	heci_cl_init(cl, dev);
+	return cl;
+}
+EXPORT_SYMBOL(heci_cl_allocate);
+
+
+void	heci_cl_free(struct heci_cl *cl)
+{
+	if (!cl)
+		return;
+
+	heci_cl_free_rx_ring(cl);
+	heci_cl_free_tx_ring(cl);
+	kfree(cl);
+}
+
+
+/**
+ * heci_cl_find_read_rb - find this cl's callback in the read list
+ *
+ * @dev: device structure
+ * returns rb on success, NULL on error
+ */
+struct heci_cl_rb *heci_cl_find_read_rb(struct heci_cl *cl)
+{
+	struct heci_device *dev = cl->dev;
+	struct heci_cl_rb *rb = NULL;
+	struct heci_cl_rb *next = NULL;
+	unsigned long     dev_flags;
+
+	spin_lock_irqsave(&dev->read_list_spinlock, dev_flags);
+	list_for_each_entry_safe(rb, next, &dev->read_list.list, list)
+		if (heci_cl_cmp_id(cl, rb->cl)) {
+			spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
+			return rb;
+		}
+	spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
+	return NULL;
+}
+EXPORT_SYMBOL(heci_cl_find_read_rb);
+
+/** heci_cl_link: allocte host id in the host map
+ *
+ * @cl - host client
+ * @id - fixed host id or -1 for genereting one
+ * returns 0 on success
+ *	-EINVAL on incorrect values
+ *	-ENONET if client not found
+ */
+int heci_cl_link(struct heci_cl *cl, int id)
+{
+	struct heci_device *dev;
+	unsigned long	flags;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -EINVAL;
+
+	dev = cl->dev;
+
+	spin_lock_irqsave(&dev->device_lock, flags);
+
+	if (dev->open_handle_count >= HECI_MAX_OPEN_HANDLE_COUNT) {
+		spin_unlock_irqrestore(&dev->device_lock, flags);
+		return	-EMFILE;
+	}
+
+	/* If Id is not asigned get one*/
+	if (id == HECI_HOST_CLIENT_ID_ANY)
+		id = find_first_zero_bit(dev->host_clients_map, HECI_CLIENTS_MAX);
+
+	if (id >= HECI_CLIENTS_MAX) {
+		spin_unlock_irqrestore(&dev->device_lock, flags);
+		dev_err(&dev->pdev->dev, "id exceded %d", HECI_CLIENTS_MAX);
+		return -ENOENT;
+	}
+
+	dev->open_handle_count++;
+	cl->host_client_id = id;
+	list_add_tail(&cl->link, &dev->cl_list);
+	set_bit(id, dev->host_clients_map);
+	cl->state = HECI_CL_INITIALIZING;
+	spin_unlock_irqrestore(&dev->device_lock, flags);
+
+	dev_dbg(&dev->pdev->dev, "link cl host id = %d\n", cl->host_client_id);
+
+	return 0;
+}
+EXPORT_SYMBOL(heci_cl_link);
+
+/**
+ * heci_cl_unlink - remove me_cl from the list
+ *
+ * @dev: the device structure
+ */
+int heci_cl_unlink(struct heci_cl *cl)
+{
+	struct heci_device *dev;
+	struct heci_cl *pos, *next;
+	unsigned long	flags;
+
+	/* don't shout on error exit path */
+	if (!cl || !cl->dev)
+		return 0;
+
+	dev = cl->dev;
+
+	spin_lock_irqsave(&dev->device_lock, flags);
+		
+	if (dev->open_handle_count > 0) {
+		clear_bit(cl->host_client_id, dev->host_clients_map);
+		dev->open_handle_count--;
+	}
+
+	/* This checks that 'cl' is actually linked into device's structure, before attempting 'list_del' */
+	list_for_each_entry_safe(pos, next, &dev->cl_list, link) {
+		if (cl->host_client_id == pos->host_client_id) {
+			list_del_init(&pos->link);
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&dev->device_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(heci_cl_unlink);
+
+
+/**
+ * heci_cl_disconnect - disconnect host clinet form the me one
+ *
+ * @cl: host client
+ *
+ * Locking: called under "dev->device_lock" lock
+ *
+ * returns 0 on success, <0 on failure.
+ */
+int heci_cl_disconnect(struct heci_cl *cl)
+{
+	struct heci_device *dev;
+	int rets, err;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	if (cl->state != HECI_CL_DISCONNECTING)
+		return 0;
+
+	rets = pm_runtime_get_sync(&dev->pdev->dev);
+	dev_dbg(&dev->pdev->dev, "rpm: get sync %d\n", rets);
+	if (IS_ERR_VALUE(rets)) {
+		dev_err(&dev->pdev->dev, "rpm: get sync failed %d\n", rets);
+		return rets;
+	}
+
+	if (heci_hbm_cl_disconnect_req(dev, cl)) {
+		rets = -ENODEV;
+		dev_err(&dev->pdev->dev, "failed to disconnect.\n");
+		goto free;
+	}
+
+	err = wait_event_timeout(cl->wait_ctrl_res,
+			(dev->dev_state == HECI_DEV_ENABLED && HECI_CL_DISCONNECTED == cl->state),
+			heci_secs_to_jiffies(HECI_CL_CONNECT_TIMEOUT));
+
+	/* If FW reset arrived, this will happen. Don't check cl->, as 'cl' may be freed already */
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto	free;
+	}
+
+	if (HECI_CL_DISCONNECTED == cl->state) {
+		rets = 0;
+		dev_dbg(&dev->pdev->dev, "successfully disconnected from FW client.\n");
+	} else {
+		rets = -ENODEV;
+		if (HECI_CL_DISCONNECTED != cl->state)
+			dev_dbg(&dev->pdev->dev, "wrong status client disconnect.\n");
+
+		if (err)
+			dev_dbg(&dev->pdev->dev,
+				"wait failed disconnect err=%08x\n", err);
+
+		dev_dbg(&dev->pdev->dev, "failed to disconnect from FW client.\n");
+	}
+
+free:
+	dev_dbg(&dev->pdev->dev, "rpm: autosuspend\n");
+	pm_runtime_mark_last_busy(&dev->pdev->dev);
+	pm_runtime_put_autosuspend(&dev->pdev->dev);
+
+	return rets;
+}
+EXPORT_SYMBOL(heci_cl_disconnect);
+
+
+/**
+ * heci_cl_is_other_connecting - checks if other
+ *    client with the same me client id is connecting
+ *
+ * @cl: private data of the file object
+ *
+ * returns ture if other client is connected, 0 - otherwise.
+ */
+bool heci_cl_is_other_connecting(struct heci_cl *cl)
+{
+	struct heci_device *dev;
+	struct heci_cl *pos;
+	struct heci_cl *next;
+	unsigned long	flags;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return false;
+
+	dev = cl->dev;
+
+	spin_lock_irqsave(&dev->device_lock, flags);
+	list_for_each_entry_safe(pos, next, &dev->cl_list, link) {
+		if ((pos->state == HECI_CL_CONNECTING) && (pos != cl) && cl->me_client_id == pos->me_client_id) {
+			spin_unlock_irqrestore(&dev->device_lock, flags);
+			return true;
+		}
+
+	}
+	spin_unlock_irqrestore(&dev->device_lock, flags);
+
+	return false;
+}
+
+/**
+ * heci_cl_connect - connect host clinet to the me one
+ *
+ * @cl: host client
+ *
+ * Locking: called under "dev->device_lock" lock
+ *
+ * returns 0 on success, <0 on failure.
+ */
+int heci_cl_connect(struct heci_cl *cl)
+{
+	struct heci_device *dev;
+	long timeout = heci_secs_to_jiffies(HECI_CL_CONNECT_TIMEOUT);
+	int rets;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	if (heci_cl_is_other_connecting(cl))
+		return	-EBUSY;
+
+	dev = cl->dev;
+
+	rets = pm_runtime_get_sync(&dev->pdev->dev);
+	dev_dbg(&dev->pdev->dev, "rpm: get sync %d\n", rets);
+	if (IS_ERR_VALUE(rets)) {
+		dev_err(&dev->pdev->dev, "rpm: get sync failed %d\n", rets);
+		return rets;
+	}
+
+	if (heci_hbm_cl_connect_req(dev, cl)) {
+		rets = -ENODEV;
+		goto out;
+	}
+
+	rets = wait_event_timeout(cl->wait_ctrl_res,
+				(dev->dev_state == HECI_DEV_ENABLED &&
+				 (cl->state == HECI_CL_CONNECTED ||
+				  cl->state == HECI_CL_DISCONNECTED)),
+				 timeout * HZ);
+
+	/* If FW reset arrived, this will happen. Don't check cl->, as 'cl' may be freed already */
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		rets = -EFAULT;
+		goto	out;
+	}
+
+	if (cl->state != HECI_CL_CONNECTED) {
+		rets = -EFAULT;
+		goto out;
+	}
+
+	rets = cl->status;
+	if (rets)
+		goto	out;
+
+	heci_cl_device_bind(cl);
+
+	rets = heci_cl_alloc_rx_ring(cl);
+	if (rets) {
+		/* if failed allocation, disconnect */
+		heci_cl_disconnect(cl);
+		goto	out;
+	}
+
+	rets = heci_cl_alloc_tx_ring(cl);
+	if (rets) {
+		/* if failed allocation, disconnect */
+		heci_cl_free_rx_ring(cl);
+		heci_cl_disconnect(cl);
+		goto	out;
+	}
+
+	/* Upon successful connection and allocation, emit flow-control */
+dev->print_log(dev, "%s(): call heci_cl_read_start, out_flow_ctrl_creds is 0\n", __func__);
+	rets = heci_cl_read_start(cl);
+out:
+	dev_dbg(&dev->pdev->dev, "rpm: autosuspend\n");
+	pm_runtime_mark_last_busy(&dev->pdev->dev);
+	pm_runtime_put_autosuspend(&dev->pdev->dev);
+
+	return rets;
+}
+EXPORT_SYMBOL(heci_cl_connect);
+
+/**
+ * heci_cl_flow_ctrl_creds - checks flow_control credits for cl.
+ *
+ * @dev: the device structure
+ * @cl: private data of the file object
+ *
+ * returns 1 if heci_flow_ctrl_creds >0, 0 - otherwise.
+ *	-ENOENT if heci_cl is not present
+ *	-EINVAL if single_recv_buf == 0
+ */
+int heci_cl_flow_ctrl_creds(struct heci_cl *cl)
+{
+	struct heci_device *dev;
+	struct heci_me_client  *me_cl = cl->device->fw_client;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -EINVAL;
+
+	dev = cl->dev;
+
+	if (!dev->me_clients_num)
+		return 0;
+
+	if (cl->heci_flow_ctrl_creds > 0)
+		return 1;
+
+	if (me_cl->heci_flow_ctrl_creds) {
+		if (WARN_ON(me_cl->props.single_recv_buf == 0)) /* fixed client: single_recv_buf != 0*/
+			return -EINVAL;
+		return 1;
+	} else {
+		return 0;
+	}
+	return -ENOENT;
+}
+
+/**
+ * heci_cl_flow_ctrl_reduce - reduces flow_control.
+ *
+ * @dev: the device structure
+ * @cl: private data of the file object
+ * @returns
+ *	0 on success
+ *	-ENOENT when me client is not found
+ *	-EINVAL when ctrl credits are <= 0
+ */
+int heci_cl_flow_ctrl_reduce(struct heci_cl *cl)
+{
+	struct heci_device *dev;
+	struct heci_me_client  *me_cl = cl->device->fw_client;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -EINVAL;
+
+	dev = cl->dev;
+
+	if (!dev->me_clients_num)
+		return -ENOENT;
+
+	if (me_cl->props.single_recv_buf != 0) { /* fixed client: single_recv_buf != 0*/
+		if (WARN_ON(me_cl->heci_flow_ctrl_creds <= 0))
+			return -EINVAL;
+		me_cl->heci_flow_ctrl_creds--;
+	} else {
+		if (WARN_ON(cl->heci_flow_ctrl_creds <= 0))
+			return -EINVAL;
+		cl->heci_flow_ctrl_creds--;
+	}
+	return 0;
+}
+
+/**
+ * heci_cl_read_start - the start read client message function.
+ *
+ * @cl: host client
+ *
+ * returns 0 on success, <0 on failure.
+ */
+int heci_cl_read_start(struct heci_cl *cl)
+{
+	struct heci_device *dev;
+	struct heci_cl_rb *rb;
+	int rets;
+	int i;
+	unsigned long	flags;
+	unsigned long	dev_flags;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	if (cl->state != HECI_CL_CONNECTED)
+		return -ENODEV;
+
+	if (dev->dev_state != HECI_DEV_ENABLED)
+		return -ENODEV;
+
+/*
+	if (cl->read_rb) {
+		dev_dbg(&dev->pdev->dev, "read is pending.\n");
+		return -EBUSY;
+	}
+*/
+	i = heci_me_cl_by_id(dev, cl->me_client_id);
+	if (i < 0) {
+		dev_err(&dev->pdev->dev, "no such me client %d\n",
+			cl->me_client_id);
+		return  -ENODEV;
+	}
+
+	rets = pm_runtime_get_sync(&dev->pdev->dev);
+	dev_dbg(&dev->pdev->dev, "rpm: get sync %d\n", rets);
+	if (IS_ERR_VALUE(rets)) {
+		dev_err(&dev->pdev->dev, "rpm: get sync failed %d\n", rets);
+		return rets;
+	}
+
+	/* The current rb is the head of the free rb list */
+	spin_lock_irqsave(&cl->free_list_spinlock, flags);
+	if (list_empty(&cl->free_rb_list.list)) {
+		printk(KERN_ERR "[heci-ish] error: rb pool is empty\n");
+		rets = -1;
+		rb = NULL;
+		spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
+		goto out;
+	}
+	rb = list_entry(cl->free_rb_list.list.next, struct heci_cl_rb, list);
+	list_del_init(&rb->list);
+	spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
+	/***************/
+	rb->cl = cl;
+	rb->buf_idx = 0;
+	/***************/
+
+	heci_io_list_init(rb);
+	rets = 0;
+
+	/*cl->read_rb = rb;*/
+
+	/* This must be BEFORE sending flow control - response in ISR may come too fast... */
+	spin_lock_irqsave(&dev->read_list_spinlock, dev_flags);
+	list_add_tail(&rb->list, &dev->read_list.list);
+	spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
+	if (heci_hbm_cl_flow_control_req(dev, cl)) {
+		rets = -ENODEV;
+		goto out;
+	}
+
+out:
+	dev_dbg(&dev->pdev->dev, "rpm: autosuspend\n");
+	pm_runtime_mark_last_busy(&dev->pdev->dev);
+	pm_runtime_put_autosuspend(&dev->pdev->dev);
+
+	if (rets)
+		heci_io_rb_free(rb);
+
+	return rets;
+}
+EXPORT_SYMBOL(heci_cl_read_start);
+
+
+int heci_cl_send(struct heci_cl *cl, u8 *buf, size_t length)
+{
+	struct heci_device *dev;
+	int id;
+	struct heci_cl_tx_ring  *cl_msg;
+	int	have_msg_to_send = 0;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	dev->print_log(dev, KERN_ALERT "%s(): cl && cl->dev OK\n", __func__);
+
+	if (cl->state != HECI_CL_CONNECTED)
+		return -EPIPE;
+	dev->print_log(dev, KERN_ALERT "%s(): cl->state is HECI_CL_CONNECTED\n", __func__);
+
+	if (dev->dev_state != HECI_DEV_ENABLED)
+		return -ENODEV;
+	dev->print_log(dev, KERN_ALERT "%s(): dev->dev_state is HECI_DEV_ENABLED\n", __func__);
+
+	/* Check if we have an ME client device */
+	id = heci_me_cl_by_id(dev, cl->me_client_id);
+	if (id < 0)
+		return -ENOENT;
+	dev->print_log(dev, KERN_ALERT "%s(): have ME client device, id=%d\n", __func__, id);
+
+	if (length > dev->me_clients[id].props.max_msg_length) {
+		/* If the client supports DMA, try to use it */
+		if (host_dma_enabled && dev->me_clients[id].props.dma_hdr_len & HECI_CLIENT_DMA_ENABLED) {
+			struct heci_msg_hdr	hdr;
+			struct hbm_client_dma_request	heci_dma_request_msg;
+			unsigned	len = sizeof(struct hbm_client_dma_request);
+			int	preview_len = dev->me_clients[id].props.dma_hdr_len & 0x7F;
+
+			/* DMA max msg size is 1M */
+			if (length > host_dma_buf_size)
+				return	-EMSGSIZE;
+
+			/* Client for some reason specified props.dma_hdr_len > 12, mistake? */
+			if (preview_len > 12)
+				return	-EINVAL;
+
+			/* If previous DMA transfer is in progress, go to sleep */
+			wait_event(dev->wait_dma_ready, dma_ready);
+			dma_ready = 0;
+			memcpy(host_dma_buf, buf + preview_len, length - preview_len);	/* First 'preview_len' bytes of buffer are preview bytes, omitted from DMA message */
+			heci_hbm_hdr(&hdr, len);
+			heci_dma_request_msg.hbm_cmd = CLIENT_DMA_REQ_CMD;
+			heci_dma_request_msg.me_addr = cl->me_client_id;
+			heci_dma_request_msg.host_addr = cl->host_client_id;
+			heci_dma_request_msg.reserved = 0;
+			heci_dma_request_msg.msg_addr = host_dma_buf_phys;
+			heci_dma_request_msg.msg_len = length - preview_len;
+			heci_dma_request_msg.reserved2 = 0;
+			memcpy(heci_dma_request_msg.msg_preview, buf, preview_len);
+			heci_write_message(dev, &hdr, (uint8_t *)&heci_dma_request_msg);
+		} else
+			return -EINVAL;		/* -EMSGSIZE? */
+	}
+
+	if (list_empty(&cl->tx_free_list.list)) {
+		return	-ENOMEM;
+	}
+	dev->print_log(dev, KERN_ALERT "%s(): have client TX free bufs\n", __func__);
+
+	cl_msg = list_first_entry(&cl->tx_free_list.list, struct heci_cl_tx_ring, list);
+	if (!cl_msg->send_buf.data) {
+		return	-EIO;		/* Should not happen, as free list is pre-allocated */
+	}
+	dev->print_log(dev, KERN_ALERT "%s(): have send_buf.data OK\n", __func__);
+
+	/* This is safe, as 'length' is already checked for not exceeding max. HECI message size per client */
+	list_del_init(&cl_msg->list);
+	memcpy(cl_msg->send_buf.data, buf, length);
+	cl_msg->send_buf.size = length;
+	have_msg_to_send = !list_empty(&cl->tx_list.list);
+	list_add_tail(&cl_msg->list, &cl->tx_list.list);
+	dev->print_log(dev, KERN_ALERT "%s(): have send_buf.data OK. have_msg_to_send=%d FC creds=%d\n", __func__, have_msg_to_send, (int)heci_cl_flow_ctrl_creds(cl));
+
+	if (!have_msg_to_send &&  heci_cl_flow_ctrl_creds(cl) > 0)
+		heci_cl_send_msg(dev, cl);	
+
+	return	0;
+}
+EXPORT_SYMBOL(heci_cl_send);
+
+
+/**
+ * heci_cl_read_complete - processes completed operation for a client
+ *
+ * @cl: private data of the file object.
+ * @rb: callback block.
+ */
+void heci_cl_read_complete(struct heci_cl_rb *rb)
+{
+	unsigned long	flags;
+	int	schedule_work_flag = 0;
+	struct heci_cl	*cl = rb->cl;
+
+	if (waitqueue_active(&cl->rx_wait)) {
+		cl->read_rb = rb;
+		wake_up_interruptible(&cl->rx_wait);
+	} else {
+		spin_lock_irqsave(&cl->in_process_spinlock, flags);
+		schedule_work_flag = list_empty(&cl->in_process_list.list);/*if in-process list is empty, then need to schedule the processing thread*/
+		list_add_tail(&rb->list, &cl->in_process_list.list);
+		spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
+
+		if (schedule_work_flag)
+			heci_cl_bus_rx_event(cl->device);
+	}
+}
+EXPORT_SYMBOL(heci_cl_read_complete);
+
+
+/**
+ * heci_cl_all_disconnect - disconnect forcefully all connected clients
+ *
+ * @dev - heci device
+ */
+void heci_cl_all_disconnect(struct heci_device *dev)
+{
+	struct heci_cl *cl, *next;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&dev->device_lock, flags);
+	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
+		cl->state = HECI_CL_DISCONNECTED;
+		cl->heci_flow_ctrl_creds = 0;
+		cl->read_rb = NULL;
+	}
+	spin_unlock_irqrestore(&dev->device_lock, flags);
+}
+
+
+/**
+ * heci_cl_all_read_wakeup  - wake up all readings so they can be interrupted
+ *
+ * @dev  - heci device
+ */
+void heci_cl_all_read_wakeup(struct heci_device *dev)
+{
+	struct heci_cl *cl, *next;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&dev->device_lock, flags);
+	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
+		if (waitqueue_active(&cl->rx_wait)) {
+			dev_dbg(&dev->pdev->dev, "Waking up client!\n");
+			wake_up_interruptible(&cl->rx_wait);
+		}
+	}
+	spin_unlock_irqrestore(&dev->device_lock, flags);
+}
+
+/*##################################*/
+
+static void	ipc_tx_callback(void *prm)
+{
+	struct heci_cl	*cl = prm;
+	struct heci_cl_tx_ring	*cl_msg;
+	size_t	rem;
+	struct heci_device	*dev = (cl ? cl->dev : NULL);
+	struct heci_msg_hdr	heci_hdr;
+
+	dev->print_log(dev, KERN_ALERT "%s() +++\n", __func__);
+	if (!dev)
+		return;
+	dev->print_log(dev, KERN_ALERT "%s() dev OK\n", __func__);
+
+	/* FIXME: there may be other conditions if some critical error has ocurred before this callback is called */
+	if (list_empty(&cl->tx_list.list))
+		return;
+	dev->print_log(dev, KERN_ALERT "%s() TX list is not empty, sending\n", __func__);
+
+	cl_msg = list_entry(cl->tx_list.list.next, struct heci_cl_tx_ring, list);
+	rem = cl_msg->send_buf.size - cl->tx_offs;
+
+	heci_hdr.host_addr = cl->host_client_id;
+	heci_hdr.me_addr = cl->me_client_id;
+	heci_hdr.reserved = 0;
+
+	if (rem <= dev->mtu) {
+		dev->print_log(dev, KERN_ALERT "%s() message complete\n", __func__);
+		heci_hdr.length = rem;
+		heci_hdr.msg_complete = 1;
+		heci_write_message(dev, &heci_hdr, cl_msg->send_buf.data);	/* Submit to IPC queue with no callback */
+		--cl->heci_flow_ctrl_creds;
+		list_del_init(&cl_msg->list);
+		list_add_tail(&cl_msg->list, &cl->tx_free_list.list);
+	} else {
+		/* Send IPC fragment */
+		dev->print_log(dev, KERN_ALERT "%s() message fragmented, sending fragment\n", __func__);
+		cl->tx_offs += dev->mtu;
+		heci_hdr.length = dev->mtu;
+		heci_hdr.msg_complete = 0;
+		dev->ops->write_ex(dev, &heci_hdr, cl_msg->send_buf.data, ipc_tx_callback, cl);
+	}
+}
+
+
+void heci_cl_send_msg(struct heci_device *dev, struct heci_cl *cl)
+{
+	cl->tx_offs = 0;
+	ipc_tx_callback(cl);	
+}
+EXPORT_SYMBOL(heci_cl_send_msg);
+/*##################################*/
+
+
+/*
+ *	Receive and dispatch HECI client messages
+ *
+ *	(!) ISR context
+ */
+void	recv_heci_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
+{
+	struct heci_cl *cl;
+	struct heci_cl_rb *rb, *next;
+	unsigned char *buffer = NULL;
+	struct heci_cl_rb *complete_rb = NULL;
+	unsigned long	dev_flags;
+	unsigned long	flags;
+
+dev->print_log(dev, "%s(): +++\n", __func__);
+
+	if (heci_hdr->reserved) {
+		dev_err(&dev->pdev->dev, "corrupted message header.\n");
+		goto	eoi;
+	}
+dev->print_log(dev, "%s(): msg header OK\n", __func__);
+
+	if (heci_hdr->length > IPC_PAYLOAD_SIZE) {
+		dev_err(&dev->pdev->dev, "HECI message length in hdr is too big for IPC MTU. Broken message\n");
+		goto	eoi;
+	}
+dev->print_log(dev, "%s(): msg length OK\n", __func__);
+
+	spin_lock_irqsave(&dev->read_list_spinlock, dev_flags);
+	list_for_each_entry_safe(rb, next, &dev->read_list.list, list) {
+		cl = rb->cl;
+		if (!cl || !(cl->host_client_id == heci_hdr->host_addr && cl->me_client_id == heci_hdr->me_addr) ||
+				!(cl->state == HECI_CL_CONNECTED))
+			continue;
+
+		/* FIXME: in both if() closes rb must return to free pool and/or disband and/or disconnect client */
+		if (rb->buffer.size == 0 || rb->buffer.data == NULL) {
+			spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
+			dev_err(&dev->pdev->dev, "response buffer is not allocated.\n");
+			list_del(&rb->list);
+			goto	eoi;
+		}
+
+		if (rb->buffer.size < heci_hdr->length + rb->buf_idx) {
+			spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
+			dev_err(&dev->pdev->dev, "message overflow. size %d len %d idx %ld\n", rb->buffer.size, heci_hdr->length, rb->buf_idx);
+			list_del(&rb->list);
+			goto	eoi;
+		}
+
+		buffer = rb->buffer.data + rb->buf_idx;
+		dev->ops->read(dev, buffer, heci_hdr->length);
+
+		rb->buf_idx += heci_hdr->length;
+		if (heci_hdr->msg_complete) {
+			cl->status = 0;
+			list_del(&rb->list);
+			complete_rb = rb;
+
+			--cl->out_flow_ctrl_creds;
+dev->print_log(dev,"%s(): rb[%p] content %02X %02X %02X %02X\n", __func__, rb, rb->buffer.data[0], rb->buffer.data[1], rb->buffer.data[2], rb->buffer.data[3]);
+			/* the whole msg arrived, send a new FC, and add a new rb buffer for the next coming msg */
+			spin_lock_irqsave(&cl->free_list_spinlock, flags);
+
+			if (!list_empty(&cl->free_rb_list.list)) {
+				rb = list_entry(cl->free_rb_list.list.next, struct heci_cl_rb, list);
+				list_del_init(&rb->list);
+				spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
+				rb->cl = cl;
+				rb->buf_idx = 0;
+				INIT_LIST_HEAD(&rb->list);
+dev->print_log(dev, "%s(): add cd = %p to read_list\n", __func__, rb);
+				list_add_tail(&rb->list, &dev->read_list.list);
+dev->print_log(dev, "%s(): call heci_hbm_cl_flow_control_req\n", __func__);
+
+				/* will work properly just after the transmit path fixes (which sends hbm command without sleeping) */
+				heci_hbm_cl_flow_control_req(dev, cl); 
+			} else {
+				/*cl->send_fc_flag = 1;*/
+				spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
+			}
+		}
+
+		/* We can safely break here (and in BH too), a single input message can go only to a single request! */
+		break;
+	}
+dev->print_log(dev, "%s(): buffer=%p complete_rb=%p\n", __func__, buffer, complete_rb);
+
+	spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
+	/* If it's nobody's message, just read and discard it */
+	if (!buffer) {
+		uint8_t	rd_msg_buf[HECI_RD_MSG_BUF_SIZE];
+
+		dev->ops->read(dev, rd_msg_buf, heci_hdr->length);
+		goto	eoi;
+	}
+
+	/* Looks like this is interrupt-safe */
+	if (complete_rb)
+		heci_cl_read_complete(complete_rb);
+
+eoi:
+dev->print_log(dev, "%s(): ---\n", __func__);
+	return;
+}
+EXPORT_SYMBOL(recv_heci_cl_msg);
+
diff --git a/drivers/misc/heci/client.h b/drivers/misc/heci/client.h
new file mode 100644
index 0000000..70f6530
--- /dev/null
+++ b/drivers/misc/heci/client.h
@@ -0,0 +1,166 @@
+/*
+ * HECI client logic
+ *
+ * Copyright (c) 2003-2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _HECI_CLIENT_H_
+#define _HECI_CLIENT_H_
+
+#include <linux/types.h>
+#include <linux/watchdog.h>
+#include <linux/poll.h>
+#include "heci_dev.h"
+
+/* Client state */
+enum cl_state {
+	HECI_CL_INITIALIZING = 0,
+	HECI_CL_CONNECTING,
+	HECI_CL_CONNECTED,
+	HECI_CL_DISCONNECTING,
+	HECI_CL_DISCONNECTED
+};
+
+#define	CL_DEF_RX_RING_SIZE	2
+#define	CL_DEF_TX_RING_SIZE	2
+#define	CL_MAX_RX_RING_SIZE	32
+#define	CL_MAX_TX_RING_SIZE	32
+
+/* Client Tx  buffer list entry */
+struct heci_cl_tx_ring {
+	struct list_head list;
+	struct heci_msg_data	send_buf;
+};
+
+/* HECI client instance carried as file->pirvate_data*/
+struct heci_cl {
+	struct list_head link;
+	struct heci_device *dev;
+	enum cl_state state;
+	wait_queue_head_t rx_wait;
+	wait_queue_head_t wait;
+	int status;
+	/* ID of client connected */
+	u8 host_client_id;
+	u8 me_client_id;
+	u8 heci_flow_ctrl_creds;
+	u8 out_flow_ctrl_creds;
+	struct heci_cl_rb *read_rb;
+
+	/* Link to HECI bus device */
+	struct heci_cl_device *device;
+
+	/* Rx ring buffer pool */
+	unsigned	rx_ring_size;
+	struct heci_cl_rb	free_rb_list;
+	/*int     send_fc_flag;*/
+	spinlock_t      free_list_spinlock;
+	/* Rx in-process list */
+	struct heci_cl_rb       in_process_list;
+	spinlock_t      in_process_spinlock;
+
+	/* Client Tx buffers list */
+	unsigned	tx_ring_size;
+	struct heci_cl_tx_ring	tx_list, tx_free_list;
+	size_t	tx_offs;			/* Offset in buffer at head of 'tx_list' */
+	/*#############################*/
+	/* if we get a FC, and the list is not empty, we must know whether we are at the middle of sending.
+	 * if so - need to increase FC counter, otherwise, need to start sending the first msg in list
+	 * (!) This is for counting-FC implementation only. Within single-FC the other party may NOT send FC until it receives complete message
+	 */
+	int sending;
+	/*#############################*/
+	spinlock_t	tx_spinlock;
+
+	/* wait queue for connect and disconnect response from FW */
+	wait_queue_head_t wait_ctrl_res;
+};
+
+int heci_me_cl_by_uuid(const struct heci_device *dev, const uuid_le *cuuid);
+int heci_me_cl_by_id(struct heci_device *dev, u8 client_id);
+
+/*
+ * HECI IO Functions
+ */
+struct heci_cl_rb *heci_io_rb_init(struct heci_cl *cl);
+void heci_io_rb_free(struct heci_cl_rb *priv_rb);
+int heci_io_rb_alloc_buf(struct heci_cl_rb *rb, size_t length);
+int heci_io_rb_recycle(struct heci_cl_rb *rb);
+
+
+/**
+ * heci_io_list_init - Sets up a queue list.
+ *
+ * @list: An instance cl callback structure
+ */
+static inline void heci_io_list_init(struct heci_cl_rb *list)
+{
+	INIT_LIST_HEAD(&list->list);
+}
+void heci_io_list_flush(struct heci_cl_rb *list, struct heci_cl *cl);
+
+/*
+ * HECI Host Client Functions
+ */
+
+struct heci_cl *heci_cl_allocate(struct heci_device *dev);
+void heci_cl_init(struct heci_cl *cl, struct heci_device *dev);
+void	heci_cl_free(struct heci_cl *cl);
+
+int	heci_cl_alloc_rx_ring(struct heci_cl *cl);
+int	heci_cl_alloc_tx_ring(struct heci_cl *cl);
+int	heci_cl_free_rx_ring(struct heci_cl *cl);
+int	heci_cl_free_tx_ring(struct heci_cl *cl);
+
+int heci_cl_link(struct heci_cl *cl, int id);
+int heci_cl_unlink(struct heci_cl *cl);
+
+int heci_cl_flush_queues(struct heci_cl *cl);
+struct heci_cl_rb *heci_cl_find_read_rb(struct heci_cl *cl);
+
+/**
+ * heci_cl_cmp_id - tells if file private data have same id
+ *
+ * @fe1: private data of 1. file object
+ * @fe2: private data of 2. file object
+ *
+ * returns true  - if ids are the same and not NULL
+ */
+static inline bool heci_cl_cmp_id(const struct heci_cl *cl1,
+				const struct heci_cl *cl2)
+{
+	return cl1 && cl2 &&
+		(cl1->host_client_id == cl2->host_client_id) &&
+		(cl1->me_client_id == cl2->me_client_id);
+}
+
+
+int heci_cl_flow_ctrl_creds(struct heci_cl *cl);
+
+int heci_cl_flow_ctrl_reduce(struct heci_cl *cl);
+/*
+ *  HECI input output function prototype
+ */
+bool heci_cl_is_other_connecting(struct heci_cl *cl);
+int heci_cl_disconnect(struct heci_cl *cl);
+int heci_cl_connect(struct heci_cl *cl);
+int heci_cl_read_start(struct heci_cl *cl);
+int heci_cl_send(struct heci_cl *cl, u8 *buf, size_t length);
+void heci_cl_read_complete(struct heci_cl_rb *rb);
+void heci_cl_all_disconnect(struct heci_device *dev);
+void heci_cl_all_read_wakeup(struct heci_device *dev);
+void heci_cl_send_msg(struct heci_device *dev, struct heci_cl *cl);
+void	heci_cl_alloc_dma_buf(void);
+void	recv_heci_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr);
+
+#endif /* _HECI_CLIENT_H_ */
+
diff --git a/drivers/misc/heci/debugfs.c b/drivers/misc/heci/debugfs.c
new file mode 100644
index 0000000..6ab12d2
--- /dev/null
+++ b/drivers/misc/heci/debugfs.c
@@ -0,0 +1,136 @@
+/*
+ * DebugFS for HECI driver
+ *
+ * Copyright (c) 2012-2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/debugfs.h>
+#include <linux/pci.h>
+#include "heci_dev.h"
+
+static ssize_t heci_dbgfs_read_meclients(struct file *fp, char __user *ubuf,
+					size_t cnt, loff_t *ppos)
+{
+	struct heci_device *dev = fp->private_data;
+	struct heci_me_client *cl;
+	const size_t bufsz = 1024;
+	char *buf = kzalloc(bufsz, GFP_KERNEL);
+	int i;
+	int pos = 0;
+	int ret;
+
+	if  (!buf)
+		return -ENOMEM;
+
+	pos += scnprintf(buf + pos, bufsz - pos,
+			"  |id|addr|         UUID                       |con|msg len|\n");
+
+	/*  if the driver is not enabled the list won't b consitent */
+	if (dev->dev_state != HECI_DEV_ENABLED)
+		goto out;
+
+	for (i = 0; i < dev->me_clients_num; i++) {
+		cl = &dev->me_clients[i];
+
+		/* skip me clients that cannot be connected */
+		if (cl->props.max_number_of_connections == 0)
+			continue;
+
+		pos += scnprintf(buf + pos, bufsz - pos,
+			"%2d|%2d|%4d|%pUl|%3d|%7d|\n",
+			i, cl->client_id,
+			cl->props.fixed_address,
+			&cl->props.protocol_name,
+			cl->props.max_number_of_connections,
+			cl->props.max_msg_length);
+	}
+out:
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, pos);
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations heci_dbgfs_fops_meclients = {
+	.open = simple_open,
+	.read = heci_dbgfs_read_meclients,
+	.llseek = generic_file_llseek,
+};
+
+static ssize_t heci_dbgfs_read_devstate(struct file *fp, char __user *ubuf,
+					size_t cnt, loff_t *ppos)
+{
+	struct heci_device *dev = fp->private_data;
+	const size_t bufsz = 1024;
+	char *buf = kzalloc(bufsz, GFP_KERNEL);
+	int pos = 0;
+	int ret;
+
+	if  (!buf)
+		return -ENOMEM;
+
+	pos += scnprintf(buf + pos, bufsz - pos, "%s\n",
+			heci_dev_state_str(dev->dev_state));
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, pos);
+	kfree(buf);
+	return ret;
+}
+static const struct file_operations heci_dbgfs_fops_devstate = {
+	.open = simple_open,
+	.read = heci_dbgfs_read_devstate,
+	.llseek = generic_file_llseek,
+};
+
+/**
+ * heci_dbgfs_deregister - Remove the debugfs files and directories
+ * @heci - pointer to heci device private dat
+ */
+void heci_dbgfs_deregister(struct heci_device *dev)
+{
+	if (!dev->dbgfs_dir)
+		return;
+	debugfs_remove_recursive(dev->dbgfs_dir);
+	dev->dbgfs_dir = NULL;
+}
+
+/**
+ * Add the debugfs files
+ *
+ */
+int heci_dbgfs_register(struct heci_device *dev, const char *name)
+{
+	struct dentry *dir, *f;
+	dir = debugfs_create_dir(name, NULL);
+	if (!dir)
+		return -ENOMEM;
+
+	f = debugfs_create_file("meclients", S_IRUSR, dir,
+				dev, &heci_dbgfs_fops_meclients);
+	if (!f) {
+		dev_err(&dev->pdev->dev, "meclients: registration failed\n");
+		goto err;
+	}
+	f = debugfs_create_file("devstate", S_IRUSR, dir,
+				dev, &heci_dbgfs_fops_devstate);
+	if (!f) {
+		dev_err(&dev->pdev->dev, "devstate: registration failed\n");
+		goto err;
+	}
+	dev->dbgfs_dir = dir;
+	return 0;
+err:
+	heci_dbgfs_deregister(dev);
+	return -ENODEV;
+}
+
diff --git a/drivers/misc/heci/hbm.c b/drivers/misc/heci/hbm.c
new file mode 100644
index 0000000..2a479e3
--- /dev/null
+++ b/drivers/misc/heci/hbm.c
@@ -0,0 +1,741 @@
+/*
+ * HECI bus layer messages handling
+ *
+ * Copyright (c) 2003-2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/export.h>
+#include <linux/pci.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include "heci_dev.h"
+#include "hbm.h"
+#include "client.h"
+#include <linux/spinlock.h>
+
+#ifdef dev_dbg
+#undef dev_dbg
+#endif
+static  void no_dev_dbg(void *v, char *s, ...)
+{
+}
+#define dev_dbg no_dev_dbg
+/*#define dev_dbg dev_err*/
+
+extern int	dma_ready;
+
+/**
+ * heci_hbm_me_cl_allocate - allocates storage for me clients
+ *
+ * @dev: the device structure
+ *
+	 * returns none.
+ */
+static void heci_hbm_me_cl_allocate(struct heci_device *dev)
+{
+	struct heci_me_client *clients;
+	int b;
+
+	/* count how many ME clients we have */
+	for_each_set_bit(b, dev->me_clients_map, HECI_CLIENTS_MAX)
+		dev->me_clients_num++;
+
+	if (dev->me_clients_num <= 0)
+		return;
+
+	kfree(dev->me_clients);
+	dev->me_clients = NULL;
+
+	dev_dbg(&dev->pdev->dev, "memory allocation for ME clients size=%zd.\n",
+		dev->me_clients_num * sizeof(struct heci_me_client));
+
+	/* allocate storage for ME clients representation */
+	clients = kcalloc(dev->me_clients_num, sizeof(struct heci_me_client), GFP_ATOMIC);
+	if (!clients) {
+		dev_err(&dev->pdev->dev, "memory allocation for ME clients failed.\n");
+		dev->dev_state = HECI_DEV_RESETTING;
+		heci_reset(dev, 1);
+		return;
+	}
+	dev->me_clients = clients;
+	return;
+}
+
+/**
+ * heci_hbm_cl_hdr - construct client hbm header
+ * @cl: - client
+ * @hbm_cmd: host bus message command
+ * @buf: buffer for cl header
+ * @len: buffer length
+ */
+static inline void heci_hbm_cl_hdr(struct heci_cl *cl, u8 hbm_cmd, void *buf, size_t len)
+{
+	struct heci_hbm_cl_cmd *cmd = buf;
+
+	memset(cmd, 0, len);
+
+	cmd->hbm_cmd = hbm_cmd;
+	cmd->host_addr = cl->host_client_id;
+	cmd->me_addr = cl->me_client_id;
+}
+
+/**
+ * same_disconn_addr - tells if they have the same address
+ *
+ * @file: private data of the file object.
+ * @disconn: disconnection request.
+ *
+ * returns true if addres are same
+ */
+static inline bool heci_hbm_cl_addr_equal(struct heci_cl *cl, void *buf)
+{
+	struct heci_hbm_cl_cmd *cmd = buf;
+	return cl->host_client_id == cmd->host_addr &&
+		cl->me_client_id == cmd->me_addr;
+}
+
+
+int heci_hbm_start_wait(struct heci_device *dev)
+{
+	int ret;
+	if (dev->hbm_state > HECI_HBM_START)
+		return 0;
+
+	dev_err(&dev->pdev->dev, "Going to wait for heci start hbm_state=%08X\n", dev->hbm_state);
+	ret = wait_event_timeout(dev->wait_hbm_recvd_msg,
+			dev->hbm_state >= HECI_HBM_STARTED,
+			(HECI_INTEROP_TIMEOUT * HZ));
+
+	dev_err(&dev->pdev->dev, "Woke up from waiting for heci start ret=%d hbm_state=%08X\n", ret, dev->hbm_state);
+
+	if (ret <= 0 && (dev->hbm_state <= HECI_HBM_START)) {
+		dev->hbm_state = HECI_HBM_IDLE;
+		dev_err(&dev->pdev->dev, "wating for heci start failed ret=%d hbm_state=%08X\n", ret, dev->hbm_state);
+		return -ETIMEDOUT;
+	}
+	return 0;
+}
+
+/**
+ * heci_hbm_start_req - sends start request message.
+ *
+ * @dev: the device structure
+ */
+int heci_hbm_start_req(struct heci_device *dev)
+{
+	struct heci_msg_hdr hdr;
+	unsigned char data[128];
+	struct heci_msg_hdr *heci_hdr = &hdr;
+	struct hbm_host_version_request *start_req;
+	const size_t len = sizeof(struct hbm_host_version_request);
+
+	heci_hbm_hdr(heci_hdr, len);
+
+	/* host start message */
+	start_req = (struct hbm_host_version_request *)data;
+	memset(start_req, 0, len);
+	start_req->hbm_cmd = HOST_START_REQ_CMD;
+	start_req->host_version.major_version = HBM_MAJOR_VERSION;
+	start_req->host_version.minor_version = HBM_MINOR_VERSION;
+
+	/*
+	 * (!) Response to HBM start may be so quick that this thread would get preempted BEFORE managing to set hbm_state = HECI_HBM_START.
+	 * So set it at first, change back to HECI_HBM_IDLE upon failure
+	 */
+	dev->hbm_state = HECI_HBM_START;
+	if (heci_write_message(dev, heci_hdr, data)) {
+		dev_err(&dev->pdev->dev, "version message write failed\n");
+		dev->dev_state = HECI_DEV_RESETTING;
+		dev->hbm_state = HECI_HBM_IDLE;
+		heci_reset(dev, 1);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(heci_hbm_start_req);
+
+/*
+ * heci_hbm_enum_clients_req - sends enumeration client request message.
+ *
+ * @dev: the device structure
+ *
+ * returns none.
+ */
+void heci_hbm_enum_clients_req(struct heci_device *dev)
+{
+	struct heci_msg_hdr hdr;
+	unsigned char data[128];
+	struct heci_msg_hdr *heci_hdr = &hdr;
+	struct hbm_host_enum_request *enum_req;
+	const size_t len = sizeof(struct hbm_host_enum_request);
+	/* enumerate clients */
+	heci_hbm_hdr(heci_hdr, len);
+
+	enum_req = (struct hbm_host_enum_request *)data;
+	memset(enum_req, 0, len);
+	enum_req->hbm_cmd = HOST_ENUM_REQ_CMD;
+
+	if (heci_write_message(dev, heci_hdr, data)) {
+		dev->dev_state = HECI_DEV_RESETTING;
+		dev_err(&dev->pdev->dev, "enumeration request write failed.\n");
+		heci_reset(dev, 1);
+	}
+	dev->hbm_state = HECI_HBM_ENUM_CLIENTS;
+	return;
+}
+
+/**
+ * heci_hbm_prop_requsest - request property for a single client
+ *
+ * @dev: the device structure
+ *
+ * returns none.
+ */
+
+static int heci_hbm_prop_req(struct heci_device *dev)
+{
+
+	struct heci_msg_hdr hdr;
+	unsigned char data[128];
+	struct heci_msg_hdr *heci_hdr = &hdr;
+	struct hbm_props_request *prop_req;
+	const size_t len = sizeof(struct hbm_props_request);
+	unsigned long next_client_index;
+	u8 client_num;
+
+	client_num = dev->me_client_presentation_num;
+
+	next_client_index = find_next_bit(dev->me_clients_map, HECI_CLIENTS_MAX, dev->me_client_index);
+
+	/* We got all client properties */
+	if (next_client_index == HECI_CLIENTS_MAX) {
+		dev->hbm_state = HECI_HBM_WORKING;
+		dev->dev_state = HECI_DEV_ENABLED;
+		return 0;
+	}
+
+	dev->me_clients[client_num].client_id = next_client_index;
+	dev->me_clients[client_num].heci_flow_ctrl_creds = 0;
+
+	heci_hbm_hdr(heci_hdr, len);
+	prop_req = (struct hbm_props_request *)data;
+
+	memset(prop_req, 0, sizeof(struct hbm_props_request));
+
+	prop_req->hbm_cmd = HOST_CLIENT_PROPERTIES_REQ_CMD;
+	prop_req->address = next_client_index;
+
+	if (heci_write_message(dev, heci_hdr, data)) {
+		dev->dev_state = HECI_DEV_RESETTING;
+		dev_err(&dev->pdev->dev, "properties request write failed\n");
+		heci_reset(dev, 1);
+		return -EIO;
+	}
+
+	dev->me_client_index = next_client_index;
+	return 0;
+}
+
+/**
+ * heci_hbm_stop_req_prepare - perpare stop request message
+ *
+ * @dev - heci device
+ * @heci_hdr - heci message header
+ * @data - hbm message body buffer
+ */
+static void heci_hbm_stop_req_prepare(struct heci_device *dev, struct heci_msg_hdr *heci_hdr, unsigned char *data)
+{
+	struct hbm_host_stop_request *req = (struct hbm_host_stop_request *)data;
+	const size_t len = sizeof(struct hbm_host_stop_request);
+
+	heci_hbm_hdr(heci_hdr, len);
+
+	memset(req, 0, len);
+	req->hbm_cmd = HOST_STOP_REQ_CMD;
+	req->reason = DRIVER_STOP_REQUEST;
+}
+
+/**
+ * heci_hbm_cl_flow_control_req - sends flow control requst.
+ *
+ * @dev: the device structure
+ * @cl: client info
+ *
+ * This function returns -EIO on write failure
+ */
+int heci_hbm_cl_flow_control_req(struct heci_device *dev, struct heci_cl *cl)
+{
+	struct heci_msg_hdr hdr;
+	unsigned char data[128];
+	struct heci_msg_hdr *heci_hdr = &hdr;
+	const size_t len = sizeof(struct hbm_flow_control);
+	int	rv;
+
+	heci_hbm_hdr(heci_hdr, len);
+	heci_hbm_cl_hdr(cl, HECI_FLOW_CONTROL_CMD, data, len);
+
+	dev_dbg(&dev->pdev->dev, "sending flow control host client = %d, ME client = %d\n",
+		cl->host_client_id, cl->me_client_id);
+
+dev->print_log(dev, "%s(): send flow_control: %02X %02X %02X %02X: %02X %02X %02X\n", __func__, ((char *)heci_hdr)[0]&0xFF, ((char *)heci_hdr)[1]&0xFF, ((char *)heci_hdr)[2]&0xFF, ((char *)heci_hdr)[3]&0xFF, data[0]&0xFF, data[1]&0xFF, data[2]&0xFF);
+
+	rv = heci_write_message(dev, heci_hdr, data);
+	if (!rv) {
+dev->print_log(dev, "%s(): ++cl->out_flow_ctrl_creds\n", __func__);
+		++cl->out_flow_ctrl_creds;
+	}
+	return	rv;
+}
+EXPORT_SYMBOL(heci_hbm_cl_flow_control_req);
+
+#if 0
+/**
+ * add_single_flow_creds - adds single buffer credentials.
+ *
+ * @file: private data ot the file object.
+ * @flow: flow control.
+ */
+static void heci_hbm_add_single_flow_creds(struct heci_device *dev,
+				  struct hbm_flow_control *flow)
+{
+	struct heci_me_client *client;
+	int i;
+
+	for (i = 0; i < dev->me_clients_num; i++) {
+		client = &dev->me_clients[i];
+		if (client && flow->me_addr == client->client_id) {
+			if (client->props.single_recv_buf) {
+				client->heci_flow_ctrl_creds++;
+				dev_dbg(&dev->pdev->dev, "recv flow ctrl msg ME %d (single).\n",
+				    flow->me_addr);
+				dev_dbg(&dev->pdev->dev, "flow control credentials =%d.\n",
+				    client->heci_flow_ctrl_creds);
+			} else {
+				BUG();	/* error in flow control */
+			}
+		}
+	}
+}
+#endif
+
+/**
+ * heci_hbm_cl_flow_control_res - flow control response from me
+ *
+ * @dev: the device structure
+ * @flow_control: flow control response bus message
+ */
+static void heci_hbm_cl_flow_control_res(struct heci_device *dev,
+		struct hbm_flow_control *flow_control)
+{
+	struct heci_cl *cl = NULL;
+	struct heci_cl *next = NULL;
+	unsigned long	flags;
+
+	/* normal connection */
+	spin_lock_irqsave(&dev->device_lock, flags);
+	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
+		if (heci_hbm_cl_addr_equal(cl, flow_control)) {
+			cl->heci_flow_ctrl_creds++;
+				break;
+		}
+	}
+	spin_unlock_irqrestore(&dev->device_lock, flags);
+}
+
+
+/**
+ * heci_hbm_cl_disconnect_req - sends disconnect message to fw.
+ *
+ * @dev: the device structure
+ * @cl: a client to disconnect from
+ *
+ * This function returns -EIO on write failure
+ */
+int heci_hbm_cl_disconnect_req(struct heci_device *dev, struct heci_cl *cl)
+{
+	struct heci_msg_hdr hdr;
+	unsigned char data[128];
+	struct heci_msg_hdr *heci_hdr = &hdr;
+	const size_t len = sizeof(struct hbm_client_connect_request);
+
+	heci_hbm_hdr(heci_hdr, len);
+	heci_hbm_cl_hdr(cl, CLIENT_DISCONNECT_REQ_CMD, data, len);
+
+	return heci_write_message(dev, heci_hdr, data);
+}
+
+/**
+ * heci_hbm_cl_disconnect_res - disconnect response from ME
+ *
+ * @dev: the device structure
+ * @rs: disconnect response bus message
+ */
+static void heci_hbm_cl_disconnect_res(struct heci_device *dev, struct hbm_client_connect_response *rs)
+{
+	struct heci_cl *cl = NULL, *next = NULL;
+	unsigned long	flags;
+
+	dev_dbg(&dev->pdev->dev,
+			"disconnect_response:\n"
+			"ME Client = %d\n"
+			"Host Client = %d\n"
+			"Status = %d\n",
+			rs->me_addr,
+			rs->host_addr,
+			rs->status);
+
+	spin_lock_irqsave(&dev->device_lock, flags);
+	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
+		if (!rs->status && heci_hbm_cl_addr_equal(cl, rs)) {
+			cl->state = HECI_CL_DISCONNECTED;
+			break;
+		}
+	}
+	if (cl)
+		wake_up(&cl->wait_ctrl_res);
+	spin_unlock_irqrestore(&dev->device_lock, flags);
+}
+
+/**
+ * heci_hbm_cl_connect_req - send connection request to specific me client
+ *
+ * @dev: the device structure
+ * @cl: a client to connect to
+ *
+ * returns -EIO on write failure
+ */
+int heci_hbm_cl_connect_req(struct heci_device *dev, struct heci_cl *cl)
+{
+	struct heci_msg_hdr hdr;
+	unsigned char data[128];
+	struct heci_msg_hdr *heci_hdr = &hdr;
+	const size_t len = sizeof(struct hbm_client_connect_request);
+
+	heci_hbm_hdr(heci_hdr, len);
+	heci_hbm_cl_hdr(cl, CLIENT_CONNECT_REQ_CMD, data, len);
+
+	return heci_write_message(dev, heci_hdr,  data);
+}
+EXPORT_SYMBOL(heci_hbm_cl_connect_req);
+
+/**
+ * heci_hbm_cl_connect_res - connect resposne from the ME
+ *
+ * @dev: the device structure
+ * @rs: connect response bus message
+ */
+static void heci_hbm_cl_connect_res(struct heci_device *dev, struct hbm_client_connect_response *rs)
+{
+	struct heci_cl *cl = NULL, *next = NULL;
+	unsigned long	flags;
+
+	dev_dbg(&dev->pdev->dev,
+			"connect_response:\n"
+			"ME Client = %d\n"
+			"Host Client = %d\n"
+			"Status = %d\n",
+			rs->me_addr,
+			rs->host_addr,
+			rs->status);
+
+	spin_lock_irqsave(&dev->device_lock, flags);
+	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
+		if (heci_hbm_cl_addr_equal(cl, rs)) {
+			if (!rs->status) {
+				cl->state = HECI_CL_CONNECTED;
+				cl->status = 0;
+			} else {
+				cl->state = HECI_CL_DISCONNECTED;
+				cl->status = -ENODEV;
+			}
+			break;
+		}
+	}
+	if (cl)
+		wake_up(&cl->wait_ctrl_res);
+	spin_unlock_irqrestore(&dev->device_lock, flags);
+}
+
+
+/**
+ * heci_client_disconnect_request - disconnect request initiated by me
+ *  host sends disoconnect response
+ *
+ * @dev: the device structure.
+ * @disconnect_req: disconnect request bus message from the me
+ */
+static void heci_hbm_fw_disconnect_req(struct heci_device *dev, struct hbm_client_connect_request *disconnect_req)
+{
+	struct heci_cl *cl, *next;
+	const size_t len = sizeof(struct hbm_client_connect_response);
+	unsigned long	flags;
+	struct heci_msg_hdr hdr;
+	unsigned char data[4];	/* All HBM messages are 4 bytes */
+
+	spin_lock_irqsave(&dev->device_lock, flags);
+	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
+		if (heci_hbm_cl_addr_equal(cl, disconnect_req)) {
+			cl->state = HECI_CL_DISCONNECTED;
+
+			/* prepare disconnect response */
+			heci_hbm_hdr(&hdr, len);
+			heci_hbm_cl_hdr(cl, CLIENT_DISCONNECT_RES_CMD, data, len);
+			heci_write_message(dev, &hdr, data);
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&dev->device_lock, flags);
+}
+
+
+/**
+ * heci_hbm_dispatch - bottom half read routine after ISR to
+ * handle the read bus message cmd processing.
+ *
+ * @dev: the device structure
+ * @hdr: header of bus message
+ */
+void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr)
+{
+	struct heci_bus_message *heci_msg;
+	struct heci_me_client *me_client;
+	struct hbm_host_version_response *version_res;
+	struct hbm_client_connect_response *connect_res;
+	struct hbm_client_connect_response *disconnect_res;
+	struct hbm_client_connect_request *disconnect_req;
+	struct hbm_flow_control *flow_control;
+	struct hbm_props_response *props_res;
+	struct hbm_host_enum_response *enum_res;
+	struct heci_msg_hdr heci_hdr;
+	unsigned char data[4];	/* All HBM messages are 4 bytes */
+
+	heci_msg = hdr;
+	dev_dbg(&dev->pdev->dev, "bus cmd = %lu\n", heci_msg->hbm_cmd);
+
+	switch (heci_msg->hbm_cmd) {
+	case HOST_START_RES_CMD:
+		version_res = (struct hbm_host_version_response *)heci_msg;
+		if (!version_res->host_version_supported) {
+			dev->version = version_res->me_max_version;
+			dev_dbg(&dev->pdev->dev, "version mismatch.\n");
+
+			dev->hbm_state = HECI_HBM_STOPPED;
+			heci_hbm_stop_req_prepare(dev, &heci_hdr, data);
+			heci_write_message(dev, &heci_hdr, data);
+			return;
+		}
+
+		dev->version.major_version = HBM_MAJOR_VERSION;
+		dev->version.minor_version = HBM_MINOR_VERSION;
+		if (dev->dev_state == HECI_DEV_INIT_CLIENTS &&
+		    dev->hbm_state == HECI_HBM_START) {
+			dev->hbm_state = HECI_HBM_STARTED;
+			heci_hbm_enum_clients_req(dev);
+		} else {
+			dev_err(&dev->pdev->dev, "reset: wrong host start response\n");
+			/* BUG: why do we arrive here? */
+			heci_reset(dev, 1);
+			return;
+		}
+
+		wake_up(&dev->wait_hbm_recvd_msg);
+		dev_dbg(&dev->pdev->dev, "host start response message received.\n");
+		break;
+
+	case CLIENT_CONNECT_RES_CMD:
+		connect_res = (struct hbm_client_connect_response *)heci_msg;
+		heci_hbm_cl_connect_res(dev, connect_res);
+		dev_dbg(&dev->pdev->dev, "client connect response message received.\n");
+		break;
+
+	case CLIENT_DISCONNECT_RES_CMD:
+		disconnect_res = (struct hbm_client_connect_response *)heci_msg;
+		heci_hbm_cl_disconnect_res(dev, disconnect_res);
+		dev_dbg(&dev->pdev->dev, "client disconnect response message received.\n");
+		break;
+
+	case HECI_FLOW_CONTROL_CMD:
+		flow_control = (struct hbm_flow_control *) heci_msg;
+		heci_hbm_cl_flow_control_res(dev, flow_control);
+		dev_dbg(&dev->pdev->dev, "client flow control response message received.\n");
+		break;
+
+	case HOST_CLIENT_PROPERTIES_RES_CMD:
+		props_res = (struct hbm_props_response *)heci_msg;
+		me_client = &dev->me_clients[dev->me_client_presentation_num];
+
+		if (props_res->status || !dev->me_clients) {
+			dev_err(&dev->pdev->dev, "reset: properties response hbm wrong status.\n");
+			heci_reset(dev, 1);
+			return;
+		}
+
+		if (me_client->client_id != props_res->address) {
+			dev_err(&dev->pdev->dev, "reset: host properties response address mismatch\n");
+			heci_reset(dev, 1);
+			return;
+		}
+
+		if (dev->dev_state != HECI_DEV_INIT_CLIENTS ||
+		    dev->hbm_state != HECI_HBM_CLIENT_PROPERTIES) {
+			dev_err(&dev->pdev->dev, "reset: unexpected properties response\n");
+			heci_reset(dev, 1);
+
+			return;
+		}
+
+		me_client->props = props_res->client_properties;
+		dev->me_client_index++;
+		dev->me_client_presentation_num++;
+
+#if 0
+		/* DEBUG -- dump received client's GUID */
+		do {
+			int	i;
+
+			ISH_DBG_PRINT(KERN_ALERT "%s(): idx=%d protocol_name = ", __func__, dev->me_client_presentation_num - 1);
+			for (i = 0; i <  16; ++i) {
+				ISH_DBG_PRINT(KERN_ALERT "%02X ", (unsigned)me_client->props.protocol_name.b[i]);
+			}
+			ISH_DBG_PRINT(KERN_ALERT "\n");
+		} while (0);
+#endif
+
+		/* Add new client device */
+		heci_bus_new_client(dev);
+
+		/* request property for the next client */
+		heci_hbm_prop_req(dev);
+
+		break;
+
+	case HOST_ENUM_RES_CMD:
+		enum_res = (struct hbm_host_enum_response *) heci_msg;
+		memcpy(dev->me_clients_map, enum_res->valid_addresses, 32);
+		if (dev->dev_state == HECI_DEV_INIT_CLIENTS &&
+		    dev->hbm_state == HECI_HBM_ENUM_CLIENTS) {
+				dev->me_client_presentation_num = 0;
+				dev->me_client_index = 0;
+				heci_hbm_me_cl_allocate(dev);
+				dev->hbm_state = HECI_HBM_CLIENT_PROPERTIES;
+
+				/* first property request */
+				heci_hbm_prop_req(dev);
+		} else {
+			dev_err(&dev->pdev->dev, "reset: unexpected enumeration response hbm.\n");
+			heci_reset(dev, 1);
+			return;
+		}
+		break;
+
+	case HOST_STOP_RES_CMD:
+		if (dev->hbm_state != HECI_HBM_STOPPED)
+			dev_err(&dev->pdev->dev, "unexpected stop response.\n");
+
+		dev->dev_state = HECI_DEV_DISABLED;
+		dev_info(&dev->pdev->dev, "reset: FW stop response.\n");
+		heci_reset(dev, 1);
+		break;
+
+	case CLIENT_DISCONNECT_REQ_CMD:
+		/* search for client */
+		disconnect_req = (struct hbm_client_connect_request *)heci_msg;
+		heci_hbm_fw_disconnect_req(dev, disconnect_req);
+		break;
+
+	case ME_STOP_REQ_CMD:
+		dev->hbm_state = HECI_HBM_STOPPED;
+		break;
+
+	case CLIENT_DMA_RES_CMD:
+		/* TODO: wake up anybody who could be waiting for DMA completion */
+		dma_ready = 1;
+		if (waitqueue_active(&dev->wait_dma_ready))
+			wake_up(&dev->wait_dma_ready);
+		break;
+
+	default:
+		/*BUG();*/
+		dev_err(&dev->pdev->dev, "unknown HBM: %u\n", (unsigned)heci_msg->hbm_cmd);
+		break;
+
+	}
+}
+EXPORT_SYMBOL(heci_hbm_dispatch);
+
+
+/*
+ *	Receive and process HECI bus messages
+ *
+ *	(!) ISR context
+ */
+void	recv_hbm(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
+{
+	uint8_t	rd_msg_buf[HECI_RD_MSG_BUF_SIZE];
+	struct heci_bus_message	*heci_msg = (struct heci_bus_message *)rd_msg_buf;
+	unsigned long	flags;
+
+	dev->ops->read(dev, rd_msg_buf, heci_hdr->length);
+
+	/* Flow control - handle in place */
+	if (heci_msg->hbm_cmd == HECI_FLOW_CONTROL_CMD) {
+		struct hbm_flow_control *flow_control = (struct hbm_flow_control *)heci_msg;
+		struct heci_cl *cl = NULL;
+		struct heci_cl *next = NULL;
+		unsigned long	flags;
+
+		ISH_DBG_PRINT(KERN_ALERT "%s(): HECI_FLOW_CONTROL_CMD, checking to whom (host_addr=%d me_addr=%d\n", __func__, flow_control->host_addr, flow_control->me_addr);
+		dev->print_log(dev, "%s(): HECI_FLOW_CONTROL_CMD, checking to whom (host_addr=%d me_addr=%d\n", __func__, flow_control->host_addr, flow_control->me_addr);
+		spin_lock_irqsave(&dev->device_lock, flags);
+		list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
+			if (cl->host_client_id == flow_control->host_addr && cl->me_client_id == flow_control->me_addr) {
+			/*#############################################*/
+				/* FIXME: It's valid only for counting flow-control implementation to receive an FC in the middle of sending */
+				++cl->heci_flow_ctrl_creds;
+				if (!list_empty(&cl->tx_list.list))
+					/*call function to start sending the first msg = the callback function*/
+					heci_cl_send_msg(dev, cl);
+				break;
+			/*#############################################*/
+			}
+		}
+		spin_unlock_irqrestore(&dev->device_lock, flags);
+		goto	eoi;
+	}
+
+	/* Some messages that are safe for ISR processing and important to be done "quickly" and in-order, go here */
+	if (heci_msg->hbm_cmd == CLIENT_CONNECT_RES_CMD || heci_msg->hbm_cmd == CLIENT_DISCONNECT_RES_CMD ||
+	   heci_msg->hbm_cmd == CLIENT_DISCONNECT_REQ_CMD) {
+		heci_hbm_dispatch(dev, heci_msg);
+		goto	eoi;
+	}
+
+	/* All other HBMs go here. TODO: revise, may be some don't need BH as well */
+	/* We schedule HBMs for processing serially, possibly there will be multiplpe HBMs scheduled at the same time. */
+	/* System wq itself is a serializing means */
+	spin_lock_irqsave(&dev->rd_msg_spinlock, flags);
+	if ((dev->rd_msg_fifo_tail + IPC_PAYLOAD_SIZE) % (RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE) == dev->rd_msg_fifo_head) {
+		spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
+		dev_err(&dev->pdev->dev, "BH buffer overflow, dropping HBM %u\n", (unsigned)heci_msg->hbm_cmd);
+		goto	eoi;
+	} 
+	memcpy(dev->rd_msg_fifo + dev->rd_msg_fifo_tail, heci_msg, heci_hdr->length);
+	dev->rd_msg_fifo_tail = (dev->rd_msg_fifo_tail + IPC_PAYLOAD_SIZE) % (RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE);
+	spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
+	schedule_work(&dev->bh_hbm_work);
+eoi:
+	return;
+}
+EXPORT_SYMBOL(recv_hbm);
+
diff --git a/drivers/misc/heci/hbm.h b/drivers/misc/heci/hbm.h
new file mode 100644
index 0000000..e4702a1
--- /dev/null
+++ b/drivers/misc/heci/hbm.h
@@ -0,0 +1,325 @@
+/*
+ * HECI bus layer messages handling
+ *
+ * Copyright (c) 2003-2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _HECI_HBM_H_
+#define _HECI_HBM_H_
+
+#include <linux/uuid.h>
+
+struct heci_device;
+struct heci_msg_hdr;
+struct heci_cl;
+
+/*
+ * Timeouts in Seconds
+ */
+#define HECI_INTEROP_TIMEOUT         7  /* Timeout on ready message */
+#define HECI_CONNECT_TIMEOUT         3  /* HPS: at least 2 seconds */
+
+#define HECI_CL_CONNECT_TIMEOUT     15  /* HPS: Client Connect Timeout */
+#define HECI_CLIENTS_INIT_TIMEOUT   15  /* HPS: Clients Enumeration Timeout */
+
+#if 0
+#define HECI_IAMTHIF_STALL_TIMER    12  /* HPS */
+#define HECI_IAMTHIF_READ_TIMER     10  /* HPS */
+#endif
+
+
+/*
+ * HECI Version
+ */
+#define HBM_MINOR_VERSION                   0
+#define HBM_MAJOR_VERSION                   1
+#define HBM_TIMEOUT                         1	/* 1 second */
+
+/* Host bus message command opcode */
+#define HECI_HBM_CMD_OP_MSK                  0x7f
+/* Host bus message command RESPONSE */
+#define HECI_HBM_CMD_RES_MSK                 0x80
+
+/*
+ * HECI Bus Message Command IDs
+ */
+#define HOST_START_REQ_CMD                  0x01
+#define HOST_START_RES_CMD                  0x81
+
+#define HOST_STOP_REQ_CMD                   0x02
+#define HOST_STOP_RES_CMD                   0x82
+
+#define ME_STOP_REQ_CMD                     0x03
+
+#define HOST_ENUM_REQ_CMD                   0x04
+#define HOST_ENUM_RES_CMD                   0x84
+
+#define HOST_CLIENT_PROPERTIES_REQ_CMD      0x05
+#define HOST_CLIENT_PROPERTIES_RES_CMD      0x85
+
+#define CLIENT_CONNECT_REQ_CMD              0x06
+#define CLIENT_CONNECT_RES_CMD              0x86
+
+#define CLIENT_DISCONNECT_REQ_CMD           0x07
+#define CLIENT_DISCONNECT_RES_CMD           0x87
+
+#define HECI_FLOW_CONTROL_CMD                0x08
+
+#define CLIENT_DMA_REQ_CMD		0x10
+#define CLIENT_DMA_RES_CMD		0x90
+
+/*
+ * HECI Stop Reason
+ * used by hbm_host_stop_request.reason
+ */
+enum heci_stop_reason_types {
+	DRIVER_STOP_REQUEST = 0x00,
+	DEVICE_D1_ENTRY = 0x01,
+	DEVICE_D2_ENTRY = 0x02,
+	DEVICE_D3_ENTRY = 0x03,
+	SYSTEM_S1_ENTRY = 0x04,
+	SYSTEM_S2_ENTRY = 0x05,
+	SYSTEM_S3_ENTRY = 0x06,
+	SYSTEM_S4_ENTRY = 0x07,
+	SYSTEM_S5_ENTRY = 0x08
+};
+
+/*
+ * Client Connect Status
+ * used by hbm_client_connect_response.status
+ */
+enum client_connect_status_types {
+	CCS_SUCCESS = 0x00,
+	CCS_NOT_FOUND = 0x01,
+	CCS_ALREADY_STARTED = 0x02,
+	CCS_OUT_OF_RESOURCES = 0x03,
+	CCS_MESSAGE_SMALL = 0x04
+};
+
+/*
+ * Client Disconnect Status
+ */
+enum client_disconnect_status_types {
+	CDS_SUCCESS = 0x00
+};
+
+/*
+ *  HECI BUS Interface Section
+ */
+struct heci_msg_hdr {
+	u32 me_addr:8;
+	u32 host_addr:8;
+	u32 length:9;
+	u32 reserved:6;
+	u32 msg_complete:1;
+} __packed;
+
+
+struct heci_bus_message {
+	u8 hbm_cmd;
+	u8 data[0];
+} __packed;
+
+/**
+ * struct hbm_cl_cmd - client specific host bus command
+ *	CONNECT, DISCONNECT, and FlOW CONTROL
+ *
+ * @hbm_cmd - bus message command header
+ * @me_addr - address of the client in ME
+ * @host_addr - address of the client in the driver
+ * @data
+ */
+struct heci_hbm_cl_cmd {
+	u8 hbm_cmd;
+	u8 me_addr;
+	u8 host_addr;
+	u8 data;
+};
+
+struct hbm_version {
+	u8 minor_version;
+	u8 major_version;
+} __packed;
+
+struct hbm_host_version_request {
+	u8 hbm_cmd;
+	u8 reserved;
+	struct hbm_version host_version;
+} __packed;
+
+struct hbm_host_version_response {
+	u8 hbm_cmd;
+	u8 host_version_supported;
+	struct hbm_version me_max_version;
+} __packed;
+
+struct hbm_host_stop_request {
+	u8 hbm_cmd;
+	u8 reason;
+	u8 reserved[2];
+} __packed;
+
+struct hbm_host_stop_response {
+	u8 hbm_cmd;
+	u8 reserved[3];
+} __packed;
+
+struct hbm_me_stop_request {
+	u8 hbm_cmd;
+	u8 reason;
+	u8 reserved[2];
+} __packed;
+
+struct hbm_host_enum_request {
+	u8 hbm_cmd;
+	u8 reserved[3];
+} __packed;
+
+struct hbm_host_enum_response {
+	u8 hbm_cmd;
+	u8 reserved[3];
+	u8 valid_addresses[32];
+} __packed;
+
+struct heci_client_properties {
+	uuid_le protocol_name;
+	u8 protocol_version;
+	u8 max_number_of_connections;
+	u8 fixed_address;
+	u8 single_recv_buf;
+	u32 max_msg_length;
+	u8 dma_hdr_len;
+#define	HECI_CLIENT_DMA_ENABLED	0x80
+	u8 reserved4;
+	u8 reserved5;
+	u8 reserved6;
+} __packed;
+
+struct hbm_props_request {
+	u8 hbm_cmd;
+	u8 address;
+	u8 reserved[2];
+} __packed;
+
+
+struct hbm_props_response {
+	u8 hbm_cmd;
+	u8 address;
+	u8 status;
+	u8 reserved[1];
+	struct heci_client_properties client_properties;
+} __packed;
+
+/**
+ * struct hbm_client_connect_request - connect/disconnect request
+ *
+ * @hbm_cmd - bus message command header
+ * @me_addr - address of the client in ME
+ * @host_addr - address of the client in the driver
+ * @reserved
+ */
+struct hbm_client_connect_request {
+	u8 hbm_cmd;
+	u8 me_addr;
+	u8 host_addr;
+	u8 reserved;
+} __packed;
+
+/**
+ * struct hbm_client_connect_response - connect/disconnect response
+ *
+ * @hbm_cmd - bus message command header
+ * @me_addr - address of the client in ME
+ * @host_addr - address of the client in the driver
+ * @status - status of the request
+ */
+struct hbm_client_connect_response {
+	u8 hbm_cmd;
+	u8 me_addr;
+	u8 host_addr;
+	u8 status;
+} __packed;
+
+
+#define HECI_FC_MESSAGE_RESERVED_LENGTH           5
+
+struct hbm_flow_control {
+	u8 hbm_cmd;
+	u8 me_addr;
+	u8 host_addr;
+	u8 reserved[HECI_FC_MESSAGE_RESERVED_LENGTH];
+} __packed;
+
+struct hbm_client_dma_request {
+	u8 hbm_cmd;
+	u8 me_addr;
+	u8 host_addr;
+	u8 reserved;
+	u64 msg_addr;
+	u32 msg_len;
+	u16 reserved2;
+	u16 msg_preview_len;
+	u8 msg_preview[12];
+} __packed;
+
+struct hbm_client_dma_response {
+	u8 hbm_cmd;
+	u8 me_addr;
+	u8 host_addr;
+	u8 status;
+	u64 msg_addr;
+	u32 msg_len;
+} __packed;
+
+/**
+ * enum heci_hbm_state - host bus message protocol state
+ *
+ * @HECI_HBM_IDLE : protocol not started
+ * @HECI_HBM_START : start request message was sent
+ * @HECI_HBM_ENUM_CLIENTS : enumeration request was sent
+ * @HECI_HBM_CLIENT_PROPERTIES : acquiring clients properties
+ */
+enum heci_hbm_state {
+	HECI_HBM_IDLE = 0,
+	HECI_HBM_START,
+	HECI_HBM_STARTED,
+	HECI_HBM_ENUM_CLIENTS,
+	HECI_HBM_CLIENT_PROPERTIES,
+	HECI_HBM_WORKING,
+	HECI_HBM_STOPPED,
+};
+
+#if 0
+void heci_hbm_dispatch(struct heci_device *dev, struct heci_msg_hdr *hdr);
+#else
+void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr);
+#endif
+
+static inline void heci_hbm_hdr(struct heci_msg_hdr *hdr, size_t length)
+{
+	hdr->host_addr = 0;
+	hdr->me_addr = 0;
+	hdr->length = length;
+	hdr->msg_complete = 1;
+	hdr->reserved = 0;
+}
+
+int heci_hbm_start_req(struct heci_device *dev);
+int heci_hbm_start_wait(struct heci_device *dev);
+int heci_hbm_cl_flow_control_req(struct heci_device *dev, struct heci_cl *cl);
+int heci_hbm_cl_disconnect_req(struct heci_device *dev, struct heci_cl *cl);
+int heci_hbm_cl_connect_req(struct heci_device *dev, struct heci_cl *cl);
+void heci_hbm_enum_clients_req(struct heci_device *dev);
+void	recv_hbm(struct heci_device *dev, struct heci_msg_hdr *heci_hdr);
+
+#endif /* _HECI_HBM_H_ */
+
diff --git a/drivers/misc/heci/heci-api.c b/drivers/misc/heci/heci-api.c
new file mode 100644
index 0000000..58a6431
--- /dev/null
+++ b/drivers/misc/heci/heci-api.c
@@ -0,0 +1,655 @@
+/*
+ * User-mode HECI API
+ *
+ * Copyright (c) 2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/aio.h>
+#include <linux/pci.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/cdev.h>
+#include <linux/sched.h>
+#include <linux/uuid.h>
+#include <linux/compat.h>
+#include <linux/jiffies.h>
+#include <linux/interrupt.h>
+#include <linux/miscdevice.h>
+#include "heci-api.h"
+#include "heci_dev.h"
+#include "client.h"
+#include "platform-config.h"
+
+#ifdef dev_dbg
+#undef dev_dbg
+#endif
+static  void no_dev_dbg(void *v, char *s, ...)
+{
+}
+#define dev_dbg no_dev_dbg
+/*#define dev_dbg dev_err*/
+
+extern int	host_dma_enabled;
+
+/**
+ * heci_open - the open function
+ *
+ * @inode: pointer to inode structure
+ * @file: pointer to file structure
+ e
+ * returns 0 on success, <0 on error
+ */
+static int heci_open(struct inode *inode, struct file *file)
+{
+	struct miscdevice *misc = file->private_data;
+	struct pci_dev *pdev;
+	struct heci_cl *cl;
+	struct heci_device *dev;
+	int err;
+
+	/* Non-blocking semantics are not supported */
+	if (file->f_flags & O_NONBLOCK)
+		return	-EINVAL;
+
+	err = -ENODEV;
+	if (!misc->parent)
+		goto out;
+
+	pdev = container_of(misc->parent, struct pci_dev, dev);
+
+	dev = pci_get_drvdata(pdev);
+	if (!dev)
+		goto out;
+
+	err = -ENOMEM;
+	cl = heci_cl_allocate(dev);
+	if (!cl)
+		goto out_free;
+
+	/* We may have a case of issued open() with dev->dev_state == HECI_DEV_DISABLED, as part of re-enabling path */
+#if 0
+	err = -ENODEV;
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		dev_dbg(&dev->pdev->dev, "dev_state != HECI_ENABLED  dev_state = %s\n",
+		    heci_dev_state_str(dev->dev_state));
+		goto out_free;
+	}
+#endif
+
+	err = heci_cl_link(cl, HECI_HOST_CLIENT_ID_ANY);
+	if (err)
+		goto out_free;
+
+	file->private_data = cl;
+
+	return nonseekable_open(inode, file);
+
+out_free:
+	kfree(cl);
+out:
+	return err;
+}
+
+/**
+ * heci_release - the release function
+ *
+ * @inode: pointer to inode structure
+ * @file: pointer to file structure
+ *
+ * returns 0 on success, <0 on error
+ */
+static int heci_release(struct inode *inode, struct file *file)
+{
+	struct heci_cl *cl = file->private_data;
+	struct heci_device *dev;
+	int rets = 0;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	/* May happen if device sent FW reset or was intentionally halted by host SW. The client is then invalid */
+	if (dev->dev_state != HECI_DEV_ENABLED)
+		return	0;
+
+	if (cl->state == HECI_CL_CONNECTED) {
+		cl->state = HECI_CL_DISCONNECTING;
+		dev_dbg(&dev->pdev->dev,
+			"disconnecting client host client = %d, "
+		    "ME client = %d\n",
+		    cl->host_client_id,
+		    cl->me_client_id);
+		rets = heci_cl_disconnect(cl);
+	}
+	heci_cl_flush_queues(cl);
+	dev_dbg(&dev->pdev->dev, "remove client host client = %d, ME client = %d\n",
+	    cl->host_client_id,
+	    cl->me_client_id);
+
+	heci_cl_unlink(cl);
+
+	file->private_data = NULL;
+
+	/* disband and free all Tx and Rx client-level rings */
+	heci_cl_free(cl);
+	return rets;
+}
+
+
+/**
+ * heci_read - the read function.
+ *
+ * @file: pointer to file structure
+ * @ubuf: pointer to user buffer
+ * @length: buffer length
+ * @offset: data offset in buffer
+ *
+ * returns >=0 data length on success , <0 on error
+ */
+static ssize_t heci_read(struct file *file, char __user *ubuf,
+			size_t length, loff_t *offset)
+{
+	struct heci_cl *cl = file->private_data;
+	struct heci_cl_rb *rb = NULL;
+	struct heci_device *dev;
+	int rets;
+	unsigned long flags;
+
+	/* Non-blocking semantics are not supported */
+	if (file->f_flags & O_NONBLOCK)
+		return	-EINVAL;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+dev->print_log(dev, "%s() +++, *offset=%d\n", __func__, *offset);
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+dev->print_log(dev, "%s() dev_state is not HECI_DEV_ENABLED\n");
+		rets = -ENODEV;
+		goto out;
+	}
+
+/* EXPLAINME: handle reading message by fragments smaller than actual message size. Why needed? Reportedly, doesn't work: why? */
+#if 0
+	if (cl->read_rb && cl->read_rb->buf_idx > *offset) {
+		rb = cl->read_rb;
+		goto copy_buffer;
+	} else if (cl->read_rb && cl->read_rb->buf_idx > 0 &&
+		   cl->read_rb->buf_idx <= *offset) {
+		rb = cl->read_rb;
+		rets = 0;
+		goto free;
+	} else if ((!cl->read_rb || !cl->read_rb->buf_idx) && *offset > 0) {
+dev->print_log(dev, "%s(): in if to reset offset\n", __func__);
+		/*Offset needs to be cleaned for contiguous reads*/
+		*offset = 0;
+		rets = 0;
+		goto out;
+	}
+#endif
+
+/*****************************************/
+	spin_lock_irqsave(&cl->in_process_spinlock, flags);
+	if (!list_empty(&cl->in_process_list.list)) {
+dev->print_log(dev, "%s(): there is some msg in in_process_list, read it\n", __func__);
+		rb = list_entry(cl->in_process_list.list.next, struct heci_cl_rb, list);
+		list_del_init(&rb->list);
+		spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
+		goto copy_buffer;
+	}
+	spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
+/*****************************************/
+
+	if (waitqueue_active(&cl->rx_wait)) {
+		rets = -EBUSY;
+		goto out;
+	}
+
+dev->print_log(dev, "%s(): before wait_event_interruptible\n", __func__);
+	if (wait_event_interruptible(cl->rx_wait,
+			(dev->dev_state == HECI_DEV_ENABLED && 
+			(cl->read_rb || HECI_CL_INITIALIZING == cl->state || HECI_CL_DISCONNECTED == cl->state || HECI_CL_DISCONNECTING == cl->state)))) {
+		printk(KERN_ALERT "%s(): woke up not in success; sig. pending = %d signal = %08lX\n", __func__, signal_pending(current), current->pending.signal.sig[0]);
+		return	-ERESTARTSYS;
+	}
+dev->print_log(dev, "%s(): after wait_event_interruptible\n", __func__);
+
+	/* If FW reset arrived, this will happen. Don't check cl->, as 'cl' may be freed already */
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto	out;
+	}
+
+	if (HECI_CL_INITIALIZING == cl->state ||
+	    HECI_CL_DISCONNECTED == cl->state ||
+	    HECI_CL_DISCONNECTING == cl->state) {
+		rets = -EBUSY;
+		goto out;
+	}
+
+	rb = cl->read_rb;
+dev->print_log(dev,"%s(): rb[%p] content %02X %02X %02X %02X\n", __func__,rb, rb->buffer.data[0], rb->buffer.data[1], rb->buffer.data[2], rb->buffer.data[3]);
+	if (!rb) {
+		rets = -ENODEV;
+		goto out;
+	}
+
+	/* now copy the data to user space */
+copy_buffer:
+dev->print_log(dev, "%s(): copy_buffer\n", __func__);
+	dev_dbg(&dev->pdev->dev, "buf.size = %d buf.idx= %ld\n",
+	    rb->buffer.size, rb->buf_idx);
+dev->print_log(dev, "%s(): length=%d, ubuf=%p, *offset=%d, rb->buf_idx=%d\n", __func__, length, ubuf, *offset, rb->buf_idx);
+	if (length == 0 || ubuf == NULL || *offset > rb->buf_idx) {
+		rets = -EMSGSIZE;
+		goto free;
+	}
+
+	/* length is being truncated to PAGE_SIZE,
+	 * however buf_idx may point beyond that */
+	length = min_t(size_t, length, rb->buf_idx - *offset);
+
+	if (copy_to_user(ubuf, rb->buffer.data + *offset, length)) {
+		rets = -EFAULT;
+		goto free;
+	}
+
+	rets = length;
+	*offset += length;
+	if ((unsigned long)*offset < rb->buf_idx)
+		goto out;
+
+free:
+dev->print_log(dev, "%s(): in free label\n", __func__);
+dev->print_log(dev, "%s(): return rb[%p] to free_list\n", __func__, rb);
+	heci_io_rb_recycle(rb);
+
+	cl->read_rb = NULL;
+	*offset = 0;
+out:
+dev->print_log(dev, "%s(): end heci read rets= %d\n", __func__, rets);
+	dev_dbg(&dev->pdev->dev, "end heci read rets= %d\n", rets);
+	return rets;
+}
+
+
+/**
+ * heci_write - the write function.
+ *
+ * @file: pointer to file structure
+ * @ubuf: pointer to user buffer
+ * @length: buffer length
+ * @offset: data offset in buffer
+ *
+ * returns >=0 data length on success , <0 on error
+ */
+static ssize_t heci_write(struct file *file, const char __user *ubuf, size_t length, loff_t *offset)
+{
+	struct heci_cl *cl = file->private_data;
+
+	/* TODO: we may further optimize write path by obtaining and directly copy_from_user'ing to tx_ring's buffer */
+	void *write_buf = NULL;
+	struct heci_device *dev;
+	int rets;
+
+	/* Non-blocking semantics are not supported */
+	if (file->f_flags & O_NONBLOCK)
+		return	-EINVAL;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+dev->print_log(dev, "%s(): +++\n", __func__);
+
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto out;
+	}
+
+	/* FIXME: check for DMA size for clients that accept DMA transfers */
+	if (length > cl->device->fw_client->props.max_msg_length || length <= 0) {
+		/* If the client supports DMA, try to use it */
+		if (!(host_dma_enabled && cl->device->fw_client->props.dma_hdr_len & HECI_CLIENT_DMA_ENABLED)) {
+			rets = -EMSGSIZE;
+			goto out;
+		}
+	}
+
+	if (cl->state != HECI_CL_CONNECTED) {
+		dev_err(&dev->pdev->dev, "host client = %d,  is not connected to ME client = %d",
+			cl->host_client_id, cl->me_client_id);
+		rets = -ENODEV;
+		goto out;
+	}
+
+	write_buf = kmalloc(length, GFP_KERNEL);
+	if (!write_buf) {
+		dev_err(&dev->pdev->dev, "write buffer allocation failed\n");
+		rets = -ENOMEM;
+		goto	out;
+	}
+
+	rets = copy_from_user(write_buf, ubuf, length);
+	if (rets)
+		goto out;
+dev->print_log(dev, "%s() call heci_cl_write\n", __func__);
+	rets = heci_cl_send(cl, write_buf, length);
+dev->print_log(dev, "%s() heci_cl_write returned %d\n", __func__, rets);
+	if (!rets)
+		rets = length;
+	else
+		rets = -EIO;
+out:
+	if (write_buf)
+		kfree(write_buf);
+	return rets;
+}
+
+
+int     heci_can_client_connect(struct heci_device *heci_dev, uuid_le *uuid);
+
+
+/**
+ * heci_ioctl_connect_client - the connect to fw client IOCTL function
+ *
+ * @dev: the device structure
+ * @data: IOCTL connect data, input and output parameters
+ * @file: private data of the file object
+ *
+ * Locking: called under "dev->device_lock" lock
+ *
+ * returns 0 on success, <0 on failure.
+ */
+static int heci_ioctl_connect_client(struct file *file, struct heci_connect_client_data *data)
+{
+	struct heci_device *dev;
+	struct heci_client *client;
+	struct heci_cl *cl;
+	int i;
+	int rets;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	cl = file->private_data;
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto end;
+	}
+
+	if (cl->state != HECI_CL_INITIALIZING &&
+	    cl->state != HECI_CL_DISCONNECTED) {
+		rets = -EBUSY;
+		goto end;
+	}
+
+	/* find ME client we're trying to connect to */
+	i = heci_me_cl_by_uuid(dev, &data->in_client_uuid);
+	if (i < 0 || dev->me_clients[i].props.fixed_address) {
+		dev_dbg(&dev->pdev->dev, "Cannot connect to FW Client UUID = %pUl\n",
+				&data->in_client_uuid);
+		rets = -ENODEV;
+		goto end;
+	}
+
+	/* Check if there's driver attached to this UUID */
+	if (!heci_can_client_connect(dev, &data->in_client_uuid))
+		return	-EBUSY;
+
+	cl->me_client_id = dev->me_clients[i].client_id;
+	cl->state = HECI_CL_CONNECTING;
+
+	dev_dbg(&dev->pdev->dev, "Connect to FW Client ID = %d\n",
+			cl->me_client_id);
+	dev_dbg(&dev->pdev->dev, "FW Client - Protocol Version = %d\n",
+			dev->me_clients[i].props.protocol_version);
+	dev_dbg(&dev->pdev->dev, "FW Client - Max Msg Len = %d\n",
+			dev->me_clients[i].props.max_msg_length);
+
+	/* prepare the output buffer */
+	client = &data->out_client_properties;
+	client->max_msg_length = dev->me_clients[i].props.max_msg_length;
+	client->protocol_version = dev->me_clients[i].props.protocol_version;
+	dev_dbg(&dev->pdev->dev, "Can connect?\n");
+
+	rets = heci_cl_connect(cl);
+
+end:
+	ISH_DBG_PRINT(KERN_ALERT "%s(): --- (%d)\n", __func__, rets);
+	return	rets;
+}
+
+
+/**
+ * heci_ioctl - the IOCTL function
+ *
+ * @file: pointer to file structure
+ * @cmd: ioctl command
+ * @data: pointer to heci message structure
+ *
+ * returns 0 on success , <0 on error
+ */
+static long heci_ioctl(struct file *file, unsigned int cmd, unsigned long data)
+{
+	struct heci_device *dev;
+	struct heci_cl *cl = file->private_data;
+	struct heci_connect_client_data *connect_data = NULL;
+	int rets;
+	unsigned	ring_size;
+
+	dev = cl->dev;
+	dev_dbg(&dev->pdev->dev, "IOCTL cmd = 0x%x", cmd);
+
+	/* Test API for triggering host-initiated IPC reset to ISH */
+	if (cmd == 0x12345678) {
+		ISH_DBG_PRINT(KERN_ALERT "%s(): ISH FW reset is requested\n", __func__);
+		/* Re-init */
+		dev->dev_state = HECI_DEV_INITIALIZING;
+		heci_reset(dev, 1);
+
+		if (heci_hbm_start_wait(dev)) {
+			dev_err(&dev->pdev->dev, "HBM haven't started");
+			goto err;
+		}
+
+		if (!heci_host_is_ready(dev)) {
+			dev_err(&dev->pdev->dev, "host is not ready.\n");
+			goto err;
+		}
+
+		if (!heci_hw_is_ready(dev)) {
+			dev_err(&dev->pdev->dev, "ME is not ready.\n");
+			goto err;
+		}
+
+		return	0;
+err:
+		dev_err(&dev->pdev->dev, "link layer initialization failed.\n");
+		dev->dev_state = HECI_DEV_DISABLED;
+		return -ENODEV;
+	}
+
+	/* Test API for triggering host disabling */
+	if (cmd == 0xAA55AA55) {
+		ISH_DBG_PRINT(KERN_ALERT "%s(): ISH host stop is requested\n", __func__);
+		/* Handle ISH reset against upper layers */
+		heci_bus_remove_all_clients(dev);			/* Remove all client devices */
+		dev->dev_state = HECI_DEV_DISABLED;
+		return	0;
+	}
+
+	if (cmd == IOCTL_HECI_SET_RX_FIFO_SIZE) {
+		ring_size = data;
+		if (ring_size > CL_MAX_RX_RING_SIZE)
+			return	-EINVAL;
+		if (cl->state != HECI_CL_INITIALIZING)
+			return	-EBUSY;
+		cl->rx_ring_size = ring_size;
+		return	0;
+	}
+
+	if (cmd == IOCTL_HECI_SET_TX_FIFO_SIZE) {
+		ring_size = data;
+		if (ring_size > CL_MAX_TX_RING_SIZE)
+			return	-EINVAL;
+		if (cl->state != HECI_CL_INITIALIZING)
+			return	-EBUSY;
+		cl->tx_ring_size = ring_size;
+		return	0;
+	}
+
+	if (cmd != IOCTL_HECI_CONNECT_CLIENT)
+		return -EINVAL;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto out;
+	}
+
+	dev_dbg(&dev->pdev->dev, ": IOCTL_HECI_CONNECT_CLIENT.\n");
+
+	connect_data = kzalloc(sizeof(struct heci_connect_client_data),
+							GFP_KERNEL);
+	if (!connect_data) {
+		rets = -ENOMEM;
+		goto out;
+	}
+	dev_dbg(&dev->pdev->dev, "copy connect data from user\n");
+	if (copy_from_user(connect_data, (char __user *)data, sizeof(struct heci_connect_client_data))) {
+		dev_dbg(&dev->pdev->dev, "failed to copy data from userland\n");
+		rets = -EFAULT;
+		goto out;
+	}
+
+	rets = heci_ioctl_connect_client(file, connect_data);
+
+	/* if all is ok, copying the data back to user. */
+	if (rets)
+		goto out;
+
+	dev_dbg(&dev->pdev->dev, "copy connect data to user\n");
+	if (copy_to_user((char __user *)data, connect_data,
+				sizeof(struct heci_connect_client_data))) {
+		dev_dbg(&dev->pdev->dev, "failed to copy data to userland\n");
+		rets = -EFAULT;
+		goto out;
+	}
+
+out:
+	kfree(connect_data);
+	return rets;
+}
+
+/**
+ * heci_compat_ioctl - the compat IOCTL function
+ *
+ * @file: pointer to file structure
+ * @cmd: ioctl command
+ * @data: pointer to heci message structure
+ *
+ * returns 0 on success , <0 on error
+ */
+#ifdef CONFIG_COMPAT
+static long heci_compat_ioctl(struct file *file,
+			unsigned int cmd, unsigned long data)
+{
+	return heci_ioctl(file, cmd, (unsigned long)compat_ptr(data));
+}
+#endif
+
+
+/*
+ * file operations structure will be used for heci char device.
+ */
+static const struct file_operations heci_fops = {
+	.owner = THIS_MODULE,
+	.read = heci_read,
+	.unlocked_ioctl = heci_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = heci_compat_ioctl,
+#endif
+	.open = heci_open,
+	.release = heci_release,
+	.write = heci_write,
+	.llseek = no_llseek
+};
+
+/*
+ * Misc Device Struct
+ */
+static struct miscdevice  heci_misc_device = {
+		.name = "ish",				/* "heci" changed to "ish", stuff it #2 */
+		.fops = &heci_fops,
+		.minor = MISC_DYNAMIC_MINOR,
+};
+
+
+int heci_register(struct heci_device *dev)
+{
+	int ret;
+	heci_misc_device.parent = &dev->pdev->dev;
+	ret = misc_register(&heci_misc_device);
+	if (ret)
+		return ret;
+
+	if (heci_dbgfs_register(dev, heci_misc_device.name))
+		dev_err(&dev->pdev->dev, "cannot register debugfs\n");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(heci_register);
+
+void heci_deregister(struct heci_device *dev)
+{
+	heci_dbgfs_deregister(dev);
+	misc_deregister(&heci_misc_device);
+	heci_misc_device.parent = NULL;
+}
+EXPORT_SYMBOL_GPL(heci_deregister);
+
+static int __init heci_init(void)
+{
+	return heci_cl_bus_init();
+}
+
+static void __exit heci_exit(void)
+{
+	heci_cl_bus_exit();
+}
+
+module_init(heci_init);
+module_exit(heci_exit);
+
+MODULE_AUTHOR("Intel Corporation");
+MODULE_DESCRIPTION("Intel(R) Management Engine Interface");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/misc/heci/heci-api.h b/drivers/misc/heci/heci-api.h
new file mode 100644
index 0000000..7d730b7
--- /dev/null
+++ b/drivers/misc/heci/heci-api.h
@@ -0,0 +1,113 @@
+/******************************************************************************
+ * Intel HECI Interface Header
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2003 - 2012 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
+ * USA
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-heci@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#ifndef _LINUX_HECI_H
+#define _LINUX_HECI_H
+
+#include <linux/uuid.h>
+
+/*
+ * This IOCTL is used to associate the current file descriptor with a
+ * FW Client (given by UUID). This opens a communication channel
+ * between a host client and a FW client. From this point every read and write
+ * will communicate with the associated FW client.
+ * Only in close() (file_operation release()) the communication between
+ * the clients is disconnected
+ *
+ * The IOCTL argument is a struct with a union that contains
+ * the input parameter and the output parameter for this IOCTL.
+ *
+ * The input parameter is UUID of the FW Client.
+ * The output parameter is the properties of the FW client
+ * (FW protocol version and max message size).
+ *
+ */
+#define IOCTL_HECI_CONNECT_CLIENT	_IOWR('H', 0x01, struct heci_connect_client_data)
+
+/* Configuration: set number of Rx/Tx buffers. Must be used before conneciton */
+#define IOCTL_HECI_SET_RX_FIFO_SIZE	_IOWR('H', 0x02, long)
+#define IOCTL_HECI_SET_TX_FIFO_SIZE	_IOWR('H', 0x03, long)
+
+/*
+ * Intel HECI client information struct
+ */
+struct heci_client {
+	__u32 max_msg_length;
+	__u8 protocol_version;
+	__u8 reserved[3];
+};
+
+/*
+ * IOCTL Connect Client Data structure
+ */
+struct heci_connect_client_data {
+	union {
+		uuid_le in_client_uuid;
+		struct heci_client out_client_properties;
+	};
+};
+
+#endif /* _LINUX_HECI_H  */
+
diff --git a/drivers/misc/heci/heci-hid-client.c b/drivers/misc/heci/heci-hid-client.c
new file mode 100644
index 0000000..f568ffa
--- /dev/null
+++ b/drivers/misc/heci/heci-hid-client.c
@@ -0,0 +1,582 @@
+/*
+ * HECI client driver for HID (ISH)
+ *
+ * Copyright (c) 2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/hid.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/kthread.h>
+#include <linux/uuid.h>
+#include "heci_dev.h"
+#include "client.h"
+#include "heci-hid.h"
+
+/* Rx ring buffer pool size */
+#define RX_RING_SIZE	16	
+#define TX_RING_SIZE	32	
+
+/* Declaration will go to header file, probably*/
+int hid_heci_cl_recv(struct heci_cl *cl, u8 *buf, size_t length);
+int	heci_hid_probe(unsigned cur_hid_dev);
+void	heci_hid_remove(void);
+
+
+/* Global vars, may eventually end up in a structure */
+struct heci_cl	*hid_heci_cl = NULL;			/* ISH HECI client */
+
+int	hid_heci_client_found;		/* Set when ISH HECI client is successfully probed */
+int	may_send;				/* Global flag that determines if sender thread can safely send something or it should wait more */
+int	enum_devices_done;			/* Enum devices response complete flag */
+int	hid_descr_done;			/* Get HID descriptor complete flag */
+int	report_descr_done;			/* Get report descriptor complete flag */
+int	get_report_done;			/* Get Feature/Input report complete flag */
+
+struct device_info	*hid_devices;
+unsigned	cur_hid_dev;
+unsigned	hid_dev_count;
+unsigned	max_hid_devices = /*1*/ MAX_HID_DEVICES;
+unsigned	num_hid_devices;
+unsigned char	*hid_descr[MAX_HID_DEVICES];
+int	hid_descr_size[MAX_HID_DEVICES];
+unsigned char	*report_descr[MAX_HID_DEVICES];
+int	report_descr_size[MAX_HID_DEVICES];
+struct hid_device	*hid_sensor_hubs[MAX_HID_DEVICES];
+
+static wait_queue_head_t	init_wait;
+
+
+/*********** Locally redirect ISH_DBG_PRINT **************/
+void g_ish_print_log(char *format, ...);
+/*********************************************************/
+
+
+/* HECI client driver structures and API for bus interface */
+void	process_recv(void *recv_buf, size_t data_len)
+{
+	struct hostif_msg	*recv_msg = (struct hostif_msg *)recv_buf;
+	unsigned char	*payload;
+	/*size_t	size;*/
+	struct device_info	*dev_info;
+	int	i, j;
+	size_t	payload_len, total_len, cur_pos;
+	int	report_type;
+
+	struct report_list *reports_list;
+	char *reports;
+	size_t report_len;
+
+	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s():+++ len=%u\n", __func__, (unsigned)data_len);
+
+	if (data_len < sizeof(struct hostif_msg_hdr)) {
+		printk(KERN_ERR "[hid-ish]: error, received %u which is less than data header %u\n", (unsigned)data_len, (unsigned)sizeof(struct hostif_msg_hdr));
+		return;
+	}
+
+	payload = recv_buf + sizeof(struct hostif_msg_hdr);
+	total_len = data_len;
+	cur_pos = 0;
+
+	may_send = 0;
+
+	do {
+		payload_len = recv_msg->hdr.size;
+
+		switch (recv_msg->hdr.command & CMD_MASK) {
+		default:
+			break;
+
+		case HOSTIF_DM_ENUM_DEVICES:
+			ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): received HOSTIF_DM_ENUM_DEVICES\n", __func__);
+			hid_dev_count = (unsigned)*payload;
+			ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): hid_dev_count=%d\n", __func__, hid_dev_count);
+			hid_devices = kmalloc(hid_dev_count * sizeof(struct device_info), GFP_KERNEL);
+			if (hid_devices)
+				memset(hid_devices, 0, hid_dev_count * sizeof(struct device_info));
+
+			for (i = 0; i < hid_dev_count; ++i) {
+				if (1 + sizeof(struct device_info) * i >= payload_len)
+					printk(KERN_ERR "[hid-ish]: [HOSTIF_DM_ENUM_DEVICES]: content size %u is bigger than payload_len %u\n", 
+						1 + (unsigned)(sizeof(struct device_info) * i), (unsigned)payload_len);
+
+				if (1 + sizeof(struct device_info) * i >= data_len)
+					break;
+
+				dev_info = (struct device_info *)(payload + 1 + sizeof(struct device_info) * i);
+				ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): [%d] -- dev_id=%08X dev_class=%02X pid=%04X vid=%04X\n", __func__,
+					i, dev_info->dev_id, dev_info->dev_class, dev_info->pid, dev_info->vid);
+				if (hid_devices)
+					memcpy(hid_devices + i, dev_info, sizeof(struct device_info));
+			}
+
+			enum_devices_done = 1;
+			if (waitqueue_active(&init_wait))
+				wake_up(&init_wait);
+
+			break;
+
+		case HOSTIF_GET_HID_DESCRIPTOR:
+			ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): received HOSTIF_GET_HID_DESCRIPTOR\n", __func__);
+			ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): dump HID descriptor\n", __func__);
+			for (i = 0; i < payload_len; ++i)
+				ISH_DBG_PRINT(KERN_ALERT "%02X ", payload[i]);
+			ISH_DBG_PRINT(KERN_ALERT "\n");
+			hid_descr[cur_hid_dev] = kmalloc(payload_len, GFP_KERNEL);
+			if (hid_descr[cur_hid_dev])
+				memcpy(hid_descr[cur_hid_dev], payload, payload_len);
+			hid_descr_size[cur_hid_dev] = payload_len;
+
+			hid_descr_done = 1;
+			if (waitqueue_active(&init_wait))
+				wake_up(&init_wait);
+
+			break;
+
+		case HOSTIF_GET_REPORT_DESCRIPTOR:
+			ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): received HOSTIF_GET_REPORT_DESCRIPTOR\n", __func__);
+			ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): Length of report descriptor is %u\n", __func__, (unsigned)payload_len);
+			report_descr[cur_hid_dev] = kmalloc(payload_len, GFP_KERNEL);
+			if (report_descr[cur_hid_dev])
+				memcpy(report_descr[cur_hid_dev], payload, payload_len);
+			report_descr_size[cur_hid_dev] = payload_len;
+
+			report_descr_done = 1;
+			if (waitqueue_active(&init_wait))
+				wake_up(&init_wait);
+
+			break;
+
+		case HOSTIF_GET_FEATURE_REPORT:
+			report_type = HID_FEATURE_REPORT;
+			ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): received HOSTIF_GET_FEATURE_REPORT\n", __func__);
+			ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): dump Get Feature Result\n", __func__);
+			goto	do_get_report;
+
+		case HOSTIF_GET_INPUT_REPORT:
+			report_type = HID_INPUT_REPORT;
+			ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): received HOSTIF_GET_INPUT_REPORT\n", __func__);
+			ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): dump Get Input Result\n", __func__);
+do_get_report:
+			for (i = 0; i < payload_len; ++i)
+				ISH_DBG_PRINT(KERN_ALERT "%02X ", payload[i]);
+			ISH_DBG_PRINT(KERN_ALERT "\n");
+
+
+			/* Get index of device that matches this id */
+			for (i = 0; i < num_hid_devices; ++i)
+				if (recv_msg->hdr.device_id == hid_devices[i].dev_id)
+					if (hid_sensor_hubs[i] != NULL) {
+						hid_input_report(hid_sensor_hubs[i], report_type, payload, payload_len, 0);
+						break;
+					}
+			get_report_done = 1;
+			break;
+
+		case HOSTIF_SET_FEATURE_REPORT:
+			ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): HOSTIF_SET_FEATURE_REPORT returned status=%02X\n", __func__, recv_msg->hdr.status);
+			get_report_done = 1;
+			break;
+
+		case HOSTIF_PUBLISH_INPUT_REPORT:
+			report_type = HID_INPUT_REPORT;
+			do {
+				ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): received ASYNC DATA REPORT [payload_len=%u]. Dump data: \n", __func__, (unsigned)payload_len);
+				for (i = 0; i < payload_len; ++i)
+					ISH_DBG_PRINT(KERN_ALERT "%02X\n", payload[i]);
+			} while (0);
+
+			for (i = 0; i < num_hid_devices; ++i)
+				if (recv_msg->hdr.device_id == hid_devices[i].dev_id)
+					if (hid_sensor_hubs[i] != NULL)
+						hid_input_report(hid_sensor_hubs[i], report_type, payload, payload_len, 0);
+			break;
+
+		case HOSTIF_PUBLISH_INPUT_REPORT_LIST:
+			ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): received HOSTIF_PUBLISH_INPUT_REPORT_LIST\n", __func__);
+
+			report_type = HID_INPUT_REPORT;
+			reports_list = (struct report_list *)payload;
+			reports = (char *)reports_list->reports;
+
+			for (j = 0; j < reports_list->num_of_reports; j++) {
+				recv_msg = (struct hostif_msg *)(reports + sizeof(uint16_t));
+				report_len = *(uint16_t *)reports;
+				payload = reports + sizeof(uint16_t) + sizeof(struct hostif_msg_hdr);
+				payload_len = report_len - sizeof(struct hostif_msg_hdr);
+
+				ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): report #%d, report_len: %d, payload_len: %d, device_id: %d, payload Data\n", __func__, j, (int)report_len, (int)payload_len, (int)recv_msg->hdr.device_id);
+				for (i = 0; i < payload_len; ++i)
+					ISH_DBG_PRINT(KERN_ALERT "%02X ", payload[i]);
+				ISH_DBG_PRINT(KERN_ALERT "\n");
+
+				for (i = 0; i < num_hid_devices; ++i)
+					if (recv_msg->hdr.device_id == hid_devices[i].dev_id)
+						if (hid_sensor_hubs[i] != NULL)
+							hid_input_report(hid_sensor_hubs[i], report_type, payload, payload_len, 0);
+
+				reports += sizeof(uint16_t) + report_len;
+			}
+			break;
+
+		}
+
+		cur_pos += payload_len + sizeof(struct hostif_msg);
+		payload += payload_len + sizeof(struct hostif_msg);
+
+	} while (cur_pos < total_len);
+	may_send = 1;
+}
+
+
+void ish_cl_event_cb(struct heci_cl_device *device, u32 events, void *context)
+{
+	size_t r_length;
+	struct heci_cl_rb *rb_in_process;
+	unsigned long	flags;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s() +++\n", __func__);
+
+	if (!hid_heci_cl)
+		return;
+
+	spin_lock_irqsave(&hid_heci_cl->in_process_spinlock, flags);
+	while (!list_empty(&hid_heci_cl->in_process_list.list)) {
+		rb_in_process = list_entry(hid_heci_cl->in_process_list.list.next, struct heci_cl_rb, list);
+		list_del_init(&rb_in_process->list);
+		spin_unlock_irqrestore(&hid_heci_cl->in_process_spinlock, flags);
+
+		if (!rb_in_process->buffer.data) {
+			ISH_DBG_PRINT(KERN_ALERT "%s(): !rb_in_process-->buffer.data, something's wrong\n", __func__);
+			return;
+		}
+		r_length = rb_in_process->buf_idx;
+		ISH_DBG_PRINT(KERN_ALERT "%s(): OK received buffer of %u length\n", __func__, (unsigned)r_length);
+
+		/* decide what to do with received data */
+		process_recv(rb_in_process->buffer.data, r_length);
+
+		heci_io_rb_recycle(rb_in_process);
+		spin_lock_irqsave(&hid_heci_cl->in_process_spinlock, flags);
+	}
+	spin_unlock_irqrestore(&hid_heci_cl->in_process_spinlock, flags);
+}
+
+void hid_heci_set_feature(struct hid_device *hid, char *buf, unsigned len, int report_id)
+{
+	int	rv;
+	struct hostif_msg *msg = (struct hostif_msg *)buf;
+	int	i;
+
+	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): writing SET FEATURE REPORT\n", __func__);
+	memset(msg, 0, sizeof(struct hostif_msg));
+	msg->hdr.command = HOSTIF_SET_FEATURE_REPORT;
+	for (i = 0; i < num_hid_devices; ++i)
+		if (hid == hid_sensor_hubs[i]) {
+			msg->hdr.device_id = hid_devices[i].dev_id; /* FIXME- temporary when single collection exists, then has to be part of hid_device custom fields */
+			break;
+		}
+	if (i == num_hid_devices)
+		return;
+
+	rv = heci_cl_send(hid_heci_cl, buf, len);
+	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): heci_cl_send() returned %d\n", __func__, rv);
+}
+
+
+void hid_heci_get_report(struct hid_device *hid, int report_id, int report_type)
+{
+	int	rv;
+	static unsigned char	buf[5];
+	unsigned	len;
+	struct hostif_msg_to_sensor *msg = (struct hostif_msg_to_sensor *)buf;
+	int	i;
+
+	len = sizeof(struct hostif_msg_to_sensor);
+
+	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): writing GET REPORT of type: %d\n", __func__, report_type);
+	memset(msg, 0, sizeof(struct hostif_msg_to_sensor));
+	msg->hdr.command = (report_type == HID_FEATURE_REPORT) ? HOSTIF_GET_FEATURE_REPORT : HOSTIF_GET_INPUT_REPORT;
+	for (i = 0; i < num_hid_devices; ++i)
+		if (hid == hid_sensor_hubs[i]) {
+			msg->hdr.device_id = hid_devices[i].dev_id;	/* FIXME - temporary when single collection exists, then has to be part of hid_device custom fields */
+			break;
+		}
+	if (i == num_hid_devices)
+		return;
+
+	msg->report_id = report_id;
+	rv = heci_cl_send(hid_heci_cl, buf, len);
+	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): heci_cl_send() returned %d\n", __func__, rv);
+}
+
+
+int	hid_heci_cl_probe(struct heci_cl_device *cl_device, const struct heci_cl_device_id *id)
+{
+	int	rv;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	if (!cl_device)
+		return	-ENODEV;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): dev != NULL && dev->cl != NULL /* OK */\n", __func__);
+	if (uuid_le_cmp(ish_heci_guid, cl_device->fw_client->props.protocol_name) != 0) {
+		ISH_DBG_PRINT(KERN_ALERT "%s(): device doesn't match\n", __func__);
+		return	-ENODEV;
+	}
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): device matches!\n", __func__);
+	hid_heci_cl = heci_cl_allocate(cl_device->heci_dev);
+	if (!hid_heci_cl)
+		return	-ENOMEM;
+
+	rv = heci_cl_link(hid_heci_cl, HECI_HOST_CLIENT_ID_ANY);
+	if (rv)
+		return	-ENOMEM;
+
+	hid_heci_client_found = 1;
+	if (waitqueue_active(&init_wait))
+		wake_up(&init_wait);
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
+	return	0;
+
+	/* Linux generic drivers framework doesn't like probe() functions to start kernel threads */
+}
+
+
+int     hid_heci_cl_remove(struct heci_cl_device *dev)
+{
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	heci_hid_remove();
+	hid_heci_client_found = 0;
+	hid_heci_cl = NULL;
+	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
+	return  0;
+}
+
+
+struct heci_cl_driver	hid_heci_cl_driver = {
+	.name = "ish",
+	.probe = hid_heci_cl_probe,
+	.remove = hid_heci_cl_remove,
+};
+
+
+/****************************************************************/
+
+struct work_struct my_work;
+
+
+void workqueue_init_function(struct work_struct *work)
+{
+	int	rv;
+	static unsigned char	buf[4096];
+	unsigned	len;
+	struct hostif_msg	*msg = (struct hostif_msg *)buf;
+	int	i;
+	struct heci_device	*dev;
+
+	ISH_DBG_PRINT(KERN_ALERT "[ish client driver] %s() in workqueue func, continue initialization process\n", __func__);
+	g_ish_print_log(KERN_ALERT "[ish client driver] %s() in workqueue func, continue initialization process\n", __func__);
+
+	if (!hid_heci_client_found)
+		wait_event_timeout(init_wait, hid_heci_client_found, 30 * HZ);
+
+	ISH_DBG_PRINT(KERN_ALERT "[ish client driver] %s() completed waiting for hid_heci_client_found[=%d]\n", __func__, hid_heci_client_found);
+	g_ish_print_log(KERN_ALERT "[ish client driver] %s() completed waiting for hid_heci_client_found[=%d]\n", __func__, hid_heci_client_found);
+
+	if (!hid_heci_client_found) {
+		printk(KERN_ERR "[hid-ish]: timed out waiting for hid_heci_client_found\n");
+		rv = -ENODEV;
+		goto	ret;
+	}
+
+	dev = hid_heci_cl->dev;
+
+	/* Connect to FW client */
+	hid_heci_cl->rx_ring_size = RX_RING_SIZE;
+	hid_heci_cl->tx_ring_size = TX_RING_SIZE;
+
+	i = heci_me_cl_by_uuid(dev, &ish_heci_guid);
+	hid_heci_cl->me_client_id = dev->me_clients[i].client_id;
+	hid_heci_cl->state = HECI_CL_CONNECTING;
+
+	rv = heci_cl_connect(hid_heci_cl);
+	if (rv)
+		goto	ret;
+
+	/* Register read callback */
+	heci_register_event_cb(hid_heci_cl->device, ish_cl_event_cb, NULL);
+
+#if 0
+	/*
+	 * Wait until we can send without risking flow-control break scenario (sending OUR FC ahead of message, so that FW will respond)
+	 * We probably need here only a small delay in order to let our FC to be sent over to FW
+	 */
+	schedule_timeout(WAIT_FOR_SEND_SLICE);
+#endif
+
+	/* Send HOSTIF_DM_ENUM_DEVICES */
+	memset(msg, 0, sizeof(struct hostif_msg));
+	msg->hdr.command = HOSTIF_DM_ENUM_DEVICES;
+	len = sizeof(struct hostif_msg);
+	ISH_DBG_PRINT(KERN_ALERT "[ish client driver] %s() writing HOSTIF_DM_ENUM_DEVICES len = %u\n", __func__, len);
+	g_ish_print_log("[ish client driver] %s() writing HOSTIF_DM_ENUM_DEVICES len = %u\n", __func__, len);
+	rv = heci_cl_send(hid_heci_cl, buf, len);
+	ISH_DBG_PRINT(KERN_ALERT "[ish client driver] %s() heci_cl_send() returned %d\n", __func__, rv);
+	g_ish_print_log("[ish client driver] %s() heci_cl_send() returned %d\n", __func__, rv);
+	if (rv)
+		goto	ret;
+
+	rv = 0;
+
+	if (!enum_devices_done)
+		wait_event_timeout(init_wait, enum_devices_done, 30 * HZ);
+
+	if (!enum_devices_done) {
+		printk(KERN_ERR "[ish client driver]: timed out waiting for enum_devices_done\n");
+		rv = -ETIMEDOUT;
+		goto	ret;
+	}
+	if (!hid_devices) {
+		printk(KERN_ERR "[ish client driver]: failed to allocate sensors devices structures\n");
+		rv = -ENOMEM;
+		goto	ret;
+	}
+
+	/* Send GET_HID_DESCRIPTOR for each device */
+	/* Temporary work-around for multi-descriptor traffic: read only the first one */
+	/* Will be removed when multi-TLC are supported */
+
+	num_hid_devices = hid_dev_count;
+	printk(KERN_ALERT "[hid-ish]: enum_devices_done OK, num_hid_devices=%d\n", num_hid_devices);
+
+	for (i = 0; i < num_hid_devices /*hid_dev_count*/; ++i) {
+		cur_hid_dev = i;
+
+		/* Get HID descriptor */
+		hid_descr_done = 0;
+		ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): [%d] writing HOSTIF_GET_HID_DESCRIPTOR\n", __func__, i);
+		memset(msg, 0, sizeof(struct hostif_msg));
+		msg->hdr.command = HOSTIF_GET_HID_DESCRIPTOR;
+		msg->hdr.device_id = hid_devices[i].dev_id;
+		len = sizeof(struct hostif_msg);
+		rv = heci_cl_send(hid_heci_cl, buf, len);
+		ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): heci_cl_send() [HOSTIF_GET_HID_DESCRIPTOR] returned %d\n", __func__, rv);
+		rv = 0;
+#ifdef HOST_VIRTUALBOX
+		timed_wait_for(WAIT_FOR_SEND_SLICE, hid_descr_done);
+#else
+		if (!hid_descr_done)
+			wait_event_timeout(init_wait, hid_descr_done, 30 * HZ);
+#endif
+		if (!hid_descr_done) {
+			printk(KERN_ERR "[hid-ish]: timed out waiting for hid_descr_done\n");
+			continue;
+		}
+
+		if (!hid_descr[i]) {
+			printk(KERN_ERR "[hid-ish]: failed to allocate HID descriptor buffer\n");
+			continue;
+		}
+
+		/* Get report descriptor */
+		report_descr_done = 0;
+		ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): [%d] writing HOSTIF_GET_REPORT_DESCRIPTOR\n", __func__, i);
+		memset(msg, 0, sizeof(struct hostif_msg));
+		msg->hdr.command = HOSTIF_GET_REPORT_DESCRIPTOR;
+		msg->hdr.device_id = hid_devices[i].dev_id;
+		len = sizeof(struct hostif_msg);
+		rv = heci_cl_send(hid_heci_cl, buf, len);
+
+		ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): heci_cl_send() [HOSTIF_GET_REPORT_DESCRIPTOR] returned %d\n", __func__, rv);
+		rv = 0;
+#ifdef HOST_VIRTUALBOX
+		timed_wait_for(WAIT_FOR_SEND_SLICE, report_descr_done);
+#else
+		if (!report_descr_done)
+			wait_event_timeout(init_wait, report_descr_done, 30 * HZ);
+#endif
+		if (!report_descr_done) {
+			printk(KERN_ERR "[hid-ish]: timed out waiting for report_descr_done\n");
+			continue;
+		}
+
+		if (!report_descr[i]) {
+			printk(KERN_ERR "[hid-ish]: failed to allocate report descriptor buffer\n");
+			continue;
+		}
+
+		rv = heci_hid_probe(i);
+		if (rv) {
+			printk(KERN_ERR "[hid-ish]: HECI-HID probe for device #%u failed: %d\n", i, rv);
+			continue;
+		}
+	} /* for() */
+
+	ISH_DBG_PRINT(KERN_ALERT "[hid-ish] %s() in workqueue func, finished initialization process\n", __func__);
+
+ret:
+
+	ISH_DBG_PRINT(KERN_ALERT "[hid-ish] %s() :in ret label --- returning %d\n", __func__, rv);
+}
+/****************************************************************/
+
+static int __init ish_init(void)
+{
+	int	rv;
+	struct workqueue_struct *workqueue_for_init;
+
+	ISH_INFO_PRINT(KERN_ALERT "[hid-ish]: %s():+++ [Build" BUILD_ID "]\n", __func__);
+	g_ish_print_log(KERN_ALERT "[hid-ish]: %s():+++ [Build" BUILD_ID "]\n", __func__);
+/*----------------------*/
+/*return 0;*/
+/*----------------------*/
+	init_waitqueue_head(&init_wait);
+
+	/* Register HECI client device driver - ISH */
+	rv = heci_cl_driver_register(&hid_heci_cl_driver);
+
+	/* 7/7/2014: in order to not stick Android boot, from here & below needs to run in work queue and here we should return rv */
+	/****************************************************************/
+	workqueue_for_init = create_workqueue("workqueue_for_init");
+        INIT_WORK(&my_work, workqueue_init_function);
+        queue_work(workqueue_for_init, &my_work);
+
+        ISH_DBG_PRINT(KERN_ALERT "[ish client driver] %s() enqueue init_work function\n", __func__);
+        g_ish_print_log(KERN_ALERT "[ish client driver] %s() enqueue init_work function\n", __func__);
+	
+	return rv;
+	/****************************************************************/
+
+}
+
+
+static void __exit ish_exit(void)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s():+++\n", __func__);
+	heci_cl_driver_unregister(&hid_heci_cl_driver);
+	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): unregistered from HECI bus\n", __func__);
+	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s():---\n", __func__);
+}
+
+module_init(ish_init);
+module_exit(ish_exit);
+
+MODULE_DESCRIPTION("ISH HECI client driver");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/misc/heci/heci-hid.c b/drivers/misc/heci/heci-hid.c
new file mode 100644
index 0000000..1790230
--- /dev/null
+++ b/drivers/misc/heci/heci-hid.c
@@ -0,0 +1,227 @@
+/*
+ * HECI-HID glue driver.
+ *
+ * Copyright (c) 2012-2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/device.h>
+#include <linux/hid.h>
+#include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/kthread.h>
+#include "heci-hid.h"
+#include "platform-config.h"
+#include "client.h"
+
+/* TODO - figure out if this number is used for anything but assignment. BUS_I2C is not */
+#define	BUS_HECI	0x44
+/* TODO: just to bootstrap, numbers will probably change */
+#define	ISH_HID_VENDOR	0x8086
+#define	ISH_HID_PRODUCT	0x22D8
+#define	ISH_HID_VERSION	0x0200
+
+extern unsigned char	*report_descr[MAX_HID_DEVICES];
+extern int	report_descr_size[MAX_HID_DEVICES];
+extern struct device_info	*hid_devices;
+extern int	may_send;
+extern int	get_report_done;			/* Get Feature/Input report complete flag */
+extern unsigned	cur_hid_dev;
+extern struct hid_device	*hid_sensor_hubs[MAX_HID_DEVICES];
+extern unsigned	num_hid_devices;
+extern struct heci_cl  *hid_heci_cl;			/* HECI client */
+
+void hid_heci_set_feature(struct hid_device *hid, char *buf, unsigned len, int report_id);
+void hid_heci_get_report(struct hid_device *hid, int report_id, int report_type);
+
+static int heci_hid_parse(struct hid_device *hid)
+{
+	int	rv;
+
+	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():+++\n", __func__);
+
+	rv = hid_parse_report(hid, report_descr[cur_hid_dev], report_descr_size[cur_hid_dev]);
+	if (rv) {
+		ISH_DBG_PRINT(KERN_ALERT "[heci-hid] %s(): parsing report descriptor failed\n", __func__);
+		return	rv;
+	}
+
+	ISH_DBG_PRINT(KERN_ALERT "[heci-hid] %s(): parsing report descriptor succeeded\n", __func__);
+	return 0;
+}
+
+static int heci_hid_start(struct hid_device *hid)
+{
+	return 0;
+}
+
+/* should we free smth? */
+static void heci_hid_stop(struct hid_device *hid)
+{
+	return;
+}
+
+/* probably connect might be here (move from probe) */
+static int heci_hid_open(struct hid_device *hid)
+{
+	return 0;
+}
+
+
+/* naturally if connect in open, disconnect here */
+static void ish_heci_close(struct hid_device *hid)
+{
+	return;
+}
+
+static int heci_hid_power(struct hid_device *hid, int lvl)
+{
+	return 0;
+}
+
+
+
+static void heci_hid_request(struct hid_device *hid, struct hid_report *rep, int reqtype)
+{
+	unsigned len = ((rep->size - 1) >> 3) + 1 + (rep->id > 0);	/* this is specific report length, just HID part of it */
+	char *buf;
+	/* s32 checkValue = 0; */
+	/* int i = 0; */
+	unsigned header_size =  sizeof(struct hostif_msg);
+
+	len += header_size;
+
+	switch (reqtype) {
+	case HID_REQ_GET_REPORT:
+		hid_heci_get_report(hid, rep->id, rep->type);
+		break;
+	case HID_REQ_SET_REPORT:
+		buf = kzalloc(len, GFP_KERNEL);
+		hid_output_report(rep, buf + header_size);
+	/* checkValue = rep->field[3]->value[0]; */
+	/* ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s(): after hid_output_report value is %d\n", __func__, checkValue);	 */
+	/* for(;i < len; i++) */
+	/*   ISH_DBG_PRINT("\n%d %d\n", i, (int) buf[i]); */
+		hid_heci_set_feature(hid, buf, len, rep->id);
+		break;
+	}
+
+	return;
+}
+
+
+static int heci_hid_hidinput_input_event(struct input_dev *dev,
+		unsigned int type, unsigned int code, int value)
+{
+	return 0;
+}
+
+
+static int heci_wait_for_response(struct hid_device *hid)
+{
+	get_report_done = 0;
+	timed_wait_for_timeout(WAIT_FOR_SEND_SLICE, get_report_done, (10 * HZ));
+
+	if (!get_report_done) {
+		dbg_hid("timeout waiting for heci device\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static struct hid_ll_driver heci_hid_ll_driver = {
+	.parse = heci_hid_parse,
+	.start = heci_hid_start,
+	.stop = heci_hid_stop,
+	.open = heci_hid_open,
+	.close = ish_heci_close,
+	.power = heci_hid_power,
+	.request = heci_hid_request,
+	.hidinput_input_event = heci_hid_hidinput_input_event,
+	.wait = heci_wait_for_response
+};
+
+
+struct tmp_heci_data {
+	int hdesc_length;
+	struct task_struct	*read_task;
+};
+
+static int heci_hid_get_raw_report(struct hid_device *hid, unsigned char report_number, __u8 *buf, size_t count, unsigned char report_type)
+{
+	return	0;
+}
+
+static int heci_hid_output_raw_report(struct hid_device *hid, __u8 *buf, size_t count, unsigned char report_type)
+{
+	return	0;
+}
+
+/* probably the best way make it driver probe so it will create device with itself as ll_driver, as usb and i2c do */
+int	heci_hid_probe(unsigned cur_hid_dev)
+{
+	int rv;
+	struct hid_device	*hid;
+
+	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():+++\n", __func__);
+
+	hid = hid_allocate_device();
+	if (IS_ERR(hid)) {
+		rv = PTR_ERR(hid);
+		return	-ENOMEM;
+	}
+
+	hid_sensor_hubs[cur_hid_dev] = hid;
+
+	hid->ll_driver = &heci_hid_ll_driver;
+	hid->hid_get_raw_report = heci_hid_get_raw_report;
+	hid->hid_output_raw_report = heci_hid_output_raw_report;
+	hid->bus = BUS_HECI;
+	hid->version = le16_to_cpu(ISH_HID_VERSION);
+	hid->vendor = le16_to_cpu(ISH_HID_VENDOR);
+	hid->product = le16_to_cpu(ISH_HID_PRODUCT);
+
+	snprintf(hid->name, sizeof(hid->name), "%s %04hX:%04hX", "hid-heci", hid->vendor, hid->product);
+
+	rv = hid_add_device(hid);
+	if (rv) {
+		if (rv != -ENODEV)
+			printk(KERN_ERR "[hid-heci]: can't add HID device: %d\n", rv);
+		kfree(hid);
+		return	rv;
+	}
+
+#if 0
+	/* Initialize all reports */
+	list_for_each_entry(report,
+		&hid->report_enum[HID_FEATURE_REPORT].report_list, list)
+		hid_heci_get_report(hid, report->id, HID_FEATURE_REPORT);
+#endif
+
+	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():---\n", __func__);
+	return 0;
+}
+
+void	heci_hid_remove(void)
+{
+	int	i;
+
+	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():+++\n", __func__);
+	for (i = 0; i < num_hid_devices; ++i)
+		if (hid_sensor_hubs[i]) {
+			hid_destroy_device(hid_sensor_hubs[i]);
+			hid_sensor_hubs[i] = NULL;
+		}
+	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():---\n", __func__);
+}
+
diff --git a/drivers/misc/heci/heci-hid.h b/drivers/misc/heci/heci-hid.h
new file mode 100644
index 0000000..907b19c
--- /dev/null
+++ b/drivers/misc/heci/heci-hid.h
@@ -0,0 +1,87 @@
+#ifndef HECI_HID__H
+#define	HECI_HID__H
+
+/*
+ * Constraint 1: currently we support only 1 ISH in a system
+ */
+
+const static	uuid_le ish_heci_guid = UUID_LE(0x33AECD58, 0xB679, 0x4E54, 0x9B, 0xD9, 0xA0, 0x4D, 0x34, 0xF0, 0xC2, 0x26);
+
+struct hostif_msg_hdr {
+	uint8_t	command;	/* Bit 7: is_response */
+#define	CMD_MASK	0x7F
+#define	IS_RESPONSE	0x80
+	uint8_t	device_id;
+	uint8_t	status;
+	uint8_t	flags;
+	uint16_t	size;
+} __attribute__((packed));
+
+struct hostif_msg {
+	struct hostif_msg_hdr	hdr;
+} __attribute__((packed));
+
+struct hostif_msg_to_sensor {
+	struct hostif_msg_hdr	hdr;
+	uint8_t	report_id;
+} __attribute__((packed));
+
+struct device_info {
+	uint32_t	dev_id;
+	uint8_t		dev_class;
+	uint16_t	pid;
+	uint16_t	vid;
+} __attribute__((packed));
+
+#if 0
+/* Needed? */
+struct heci_client {
+	uint32_t	max_msg_len;
+	uint8_t		proto_ver;
+} __attribute__((packed));
+#endif
+
+struct heci_version {
+	uint8_t	major;
+	uint8_t	minor;
+	uint8_t	hotfix;
+	uint16_t	build;
+} __attribute__((packed));
+
+/*
+ * struct for heci aggregated input data
+ */
+struct report_list {
+	uint16_t total_size;
+	uint8_t  num_of_reports;
+	uint8_t  flags;
+	struct {
+		uint16_t  size_of_report;
+		uint8_t report[1];
+	} __attribute__((packed)) reports[1];
+} __attribute__((packed));
+
+/* HOSTIF commands */
+#define	HOSTIF_HID_COMMAND_BASE		0
+#define	HOSTIF_GET_HID_DESCRIPTOR	0
+#define	HOSTIF_GET_REPORT_DESCRIPTOR	1
+#define HOSTIF_GET_FEATURE_REPORT	2
+#define	HOSTIF_SET_FEATURE_REPORT	3
+#define	HOSTIF_GET_INPUT_REPORT		4
+#define	HOSTIF_PUBLISH_INPUT_REPORT	5
+/*#define	HOSTIF_GET_OUTPUT_REPORT	6*/
+/*#define	HOSTIF_SET_OUTPUT_REPORT	7*/
+#define	HOSTIF_PUBLISH_INPUT_REPORT_LIST	6
+#define	HOSTIF_DM_COMMAND_BASE		32
+#define	HOSTIF_DM_ENUM_DEVICES		33
+#define	HOSTIF_DM_ADD_DEVICE		34
+
+/* Meaning, too large data source = "over 9000?" :-) */
+#define	MAX_DATA_BUF	9000
+
+#define	MAX_HID_DEVICES	32
+
+#include "utils.h"
+
+#endif	/* HECI_HID__H */
+
diff --git a/drivers/misc/heci/heci_dev.h b/drivers/misc/heci/heci_dev.h
new file mode 100644
index 0000000..a188f6e
--- /dev/null
+++ b/drivers/misc/heci/heci_dev.h
@@ -0,0 +1,304 @@
+/*
+ * Most HECI provider device and HECI logic declarations
+ *
+ * Copyright (c) 2003-2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _HECI_DEV_H_
+#define _HECI_DEV_H_
+
+#include "platform-config.h"
+#include <linux/types.h>
+#include <linux/watchdog.h>
+#include <linux/poll.h>
+#include "bus.h"
+#include "hbm.h"
+#include <linux/spinlock.h>
+
+#define	IPC_PAYLOAD_SIZE	128
+#define HECI_RD_MSG_BUF_SIZE	IPC_PAYLOAD_SIZE
+/* Number of messages to be held in ISR->BH FIFO */
+#define	RD_INT_FIFO_SIZE	64
+#define	IPC_FULL_MSG_SIZE	132
+/* Number of IPC messages to be held in Tx FIFO, to be sent by ISR - Tx complete interrupt or RX_COMPLETE handler */
+#define	IPC_TX_FIFO_SIZE	512
+
+/*
+ * Number of Maximum HECI Clients
+ */
+#define HECI_CLIENTS_MAX 256
+
+/*
+ * Number of File descriptors/handles
+ * that can be opened to the driver.
+ *
+ * Limit to 255: 256 Total Clients
+ * minus internal client for HECI Bus Messags
+ */
+#define  HECI_MAX_OPEN_HANDLE_COUNT (HECI_CLIENTS_MAX - 1)
+
+/*
+ * Internal Clients Number
+ */
+#define HECI_HOST_CLIENT_ID_ANY        (-1)
+#define HECI_HBM_HOST_CLIENT_ID         0 /* not used, just for documentation */
+
+/* HECI device states */
+enum heci_dev_state {
+	HECI_DEV_INITIALIZING = 0,
+	HECI_DEV_INIT_CLIENTS,
+	HECI_DEV_ENABLED,
+	HECI_DEV_RESETTING,
+	HECI_DEV_DISABLED,
+	HECI_DEV_POWER_DOWN,
+	HECI_DEV_POWER_UP
+};
+
+const char *heci_dev_state_str(int state);
+
+/**
+ * struct heci_me_client - representation of me (fw) client
+ *
+ * @props  - client properties
+ * @client_id - me client id
+ * @heci_flow_ctrl_creds - flow control credits
+ */
+struct heci_me_client {
+	struct heci_client_properties props;
+	u8 client_id;
+	u8 heci_flow_ctrl_creds;
+};
+
+
+struct heci_cl;
+
+/*
+ * Intel HECI message data struct
+ */
+struct heci_msg_data {
+	u32 size;
+	int	dma_flag;	/* non-0 if this is DMA msg buf */
+	unsigned char *data;
+};
+
+/**
+ * struct heci_cl_rb - request block (was: callback) structure
+ *
+ * @cl - client who is running this operation
+ * @type - request type
+ */
+struct heci_cl_rb {
+	struct list_head list;
+	struct heci_cl *cl;
+	struct heci_msg_data buffer;
+	unsigned long buf_idx;
+	unsigned long read_time;
+};
+
+
+struct wr_msg_ctl_info {
+	void	(*ipc_send_compl)(void *);	/* Will be called with 'ipc_send_compl_prm' as parameter */
+	void	*ipc_send_compl_prm;
+	size_t length;
+	struct list_head	link;
+	unsigned char	inline_data[IPC_FULL_MSG_SIZE];
+};
+
+/** struct heci_hw_ops
+ *
+ * @host_is_ready    - query for host readiness
+ * @hw_is_ready      - query if hw is ready
+ * @hw_reset         - reset hw
+ * @hw_start         - start hw after reset
+ * @hw_config        - configure hw
+ * @write            - write a message to FW
+ */
+struct heci_hw_ops {
+	bool (*host_is_ready) (struct heci_device *dev);
+	bool (*hw_is_ready) (struct heci_device *dev);
+	int (*hw_reset) (struct heci_device *dev, bool enable);
+	int  (*hw_start) (struct heci_device *dev);
+	void (*hw_config) (struct heci_device *dev);
+	int (*write)(struct heci_device *dev, struct heci_msg_hdr *hdr, unsigned char *buf);
+	int (*write_ex)(struct heci_device *dev, struct heci_msg_hdr *hdr, void *msg, void(*ipc_send_compl)(void *),void *ipc_send_compl_prm);
+	int (*read)(struct heci_device *dev, unsigned char *buffer, unsigned long buffer_length);
+};
+
+#define PRINT_BUFFER_SIZE 204800
+
+/**
+ * struct heci_device -  HECI private device struct
+ *
+ * @hbm_state - state of host bus message protocol
+ * @mem_addr - mem mapped base register address
+ */
+struct heci_device {
+	struct pci_dev *pdev;	/* pointer to pci device struct */
+	/*
+	 * lists of queues
+	 */
+
+	/* array of pointers to aio lists */
+	struct heci_cl_rb read_list;		/* driver read queue */
+	spinlock_t      read_list_spinlock;
+
+	/*
+	 * list of heci_cl's (formerly: files)
+	 */
+	struct list_head cl_list;
+	long open_handle_count;			/* Why's this?.. */
+
+	/*
+	 * lock for the device
+	 */
+	spinlock_t	device_lock;		/* device lock - for everything that doesn't have a dedicated spinlock */
+
+	bool recvd_hw_ready;
+	/*
+	 * waiting queue for receive message from FW
+	 */
+	wait_queue_head_t wait_hw_ready;
+	wait_queue_head_t wait_hbm_recvd_msg;
+	wait_queue_head_t wait_dma_ready;
+
+	/*
+	 * heci device  states
+	 */
+	enum heci_dev_state dev_state;
+	enum heci_hbm_state hbm_state;
+
+	/* FIFO for input messages for BH processing */
+	unsigned char	rd_msg_fifo[RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE];
+	unsigned	rd_msg_fifo_head, rd_msg_fifo_tail;
+	spinlock_t	rd_msg_spinlock;
+	struct work_struct	bh_hbm_work;
+
+#if 0
+	/* FIFO for output IPC messages. Includes also HECI/IPC header to be supplied in DRBL (first dword) */
+	unsigned char	wr_msg_fifo[IPC_TX_FIFO_SIZE * IPC_FULL_MSG_SIZE];
+#endif
+	/* 
+	 * Control info for IPC messages HECI/IPC sending FIFO - list with inline data buffer
+	 * This structure will be filled with parameters submitted by the caller glue layer 
+	 * 'buf' may be pointing to the external buffer or to 'inline_data'
+	 * 'offset' will be initialized to 0 by submitting
+	 *
+	 * 'ipc_send_compl' is intended for use by clients that send fragmented messages. When a fragment is sent down to IPC msg regs, it will be called.
+	 * If it has more fragments to send, it will do it. With last fragment it will send appropriate HECI "message-complete" flag.
+	 * It will remove the outstanding message (mark outstanding buffer as available).
+	 * If counting flow control is in work and there are more flow control credits, it can put the next client message queued in cl. structure for IPC processing.
+	 *
+	 * (!) We can work on FIFO list or cyclic FIFO in an array
+	 */
+	
+	struct wr_msg_ctl_info wr_processing_list_head, wr_free_list_head;
+	spinlock_t	wr_processing_spinlock;		/* For both processing and free lists */
+/*
+	unsigned	wr_msg_fifo_head, wr_msg_fifo_tail;
+	spinlock_t	wr_msg_spinlock;
+*/
+	struct hbm_version version;
+	struct heci_me_client *me_clients; /* Note: memory has to be allocated */
+	DECLARE_BITMAP(me_clients_map, HECI_CLIENTS_MAX);
+	DECLARE_BITMAP(host_clients_map, HECI_CLIENTS_MAX);
+	u8 me_clients_num;
+	u8 me_client_presentation_num;
+	u8 me_client_index;
+
+	/* List of bus devices */
+	struct list_head device_list;
+
+	/* buffer to save prints from driver */
+	unsigned char log_buffer[PRINT_BUFFER_SIZE];
+	size_t log_head;
+	size_t log_tail;
+	void (*print_log)(struct heci_device *dev, char *format, ...);
+	spinlock_t      log_spinlock;   /* spinlock to protect prints buffer */
+
+#if IS_ENABLED(CONFIG_DEBUG_FS)
+	struct dentry *dbgfs_dir;
+#endif /* CONFIG_DEBUG_FS */
+
+	const struct heci_hw_ops *ops;
+
+	size_t	mtu;	
+	char hw[0] __aligned(sizeof(void *));
+};
+
+/*
+ * heci init function prototypes
+ */
+void heci_device_init(struct heci_device *dev);
+void heci_reset(struct heci_device *dev, int interrupts);
+int heci_start(struct heci_device *dev);
+void heci_stop(struct heci_device *dev);
+
+static inline unsigned long heci_secs_to_jiffies(unsigned long sec)
+{
+	return sec * HZ;	/*msecs_to_jiffies(sec * MSEC_PER_SEC);*/
+}
+
+/*
+ * Register Access Function
+ */
+static inline void heci_hw_config(struct heci_device *dev)
+{
+	dev->ops->hw_config(dev);
+}
+static inline int heci_hw_reset(struct heci_device *dev, bool enable)
+{
+	return dev->ops->hw_reset(dev, enable);
+}
+
+static inline int heci_hw_start(struct heci_device *dev)
+{
+	return dev->ops->hw_start(dev);
+}
+
+static inline bool heci_host_is_ready(struct heci_device *dev)
+{
+	return dev->ops->host_is_ready(dev);
+}
+static inline bool heci_hw_is_ready(struct heci_device *dev)
+{
+	return dev->ops->hw_is_ready(dev);
+}
+
+static inline int heci_write_message(struct heci_device *dev, struct heci_msg_hdr *hdr, unsigned char *buf)
+{
+	return dev->ops->write_ex(dev, hdr, buf, NULL, NULL);
+}
+
+#if IS_ENABLED(CONFIG_DEBUG_FS)
+int heci_dbgfs_register(struct heci_device *dev, const char *name);
+void heci_dbgfs_deregister(struct heci_device *dev);
+#else
+static inline int heci_dbgfs_register(struct heci_device *dev, const char *name)
+{
+	return 0;
+}
+static inline void heci_dbgfs_deregister(struct heci_device *dev) {}
+#endif /* CONFIG_DEBUG_FS */
+
+
+int heci_register(struct heci_device *dev);
+void heci_deregister(struct heci_device *dev);
+
+void    heci_bus_remove_all_clients(struct heci_device *heci_dev);
+
+#define HECI_HDR_FMT "hdr:host=%02d me=%02d len=%d comp=%1d"
+#define HECI_HDR_PRM(hdr)                  \
+	(hdr)->host_addr, (hdr)->me_addr, \
+	(hdr)->length, (hdr)->msg_complete
+
+#endif
+
diff --git a/drivers/misc/heci/hid-ids.h b/drivers/misc/heci/hid-ids.h
new file mode 100644
index 0000000..5309fd5
--- /dev/null
+++ b/drivers/misc/heci/hid-ids.h
@@ -0,0 +1,891 @@
+/*
+ *  USB HID quirks support for Linux
+ *
+ *  Copyright (c) 1999 Andreas Gal
+ *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
+ *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
+ *  Copyright (c) 2006-2007 Jiri Kosina
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#ifndef HID_IDS_H_FILE
+#define HID_IDS_H_FILE
+
+#define USB_VENDOR_ID_3M		0x0596
+#define USB_DEVICE_ID_3M1968		0x0500
+#define USB_DEVICE_ID_3M2256		0x0502
+#define USB_DEVICE_ID_3M3266		0x0506
+
+#define USB_VENDOR_ID_A4TECH		0x09da
+#define USB_DEVICE_ID_A4TECH_WCP32PU	0x0006
+#define USB_DEVICE_ID_A4TECH_X5_005D	0x000a
+#define USB_DEVICE_ID_A4TECH_RP_649	0x001a
+
+#define USB_VENDOR_ID_AASHIMA		0x06d6
+#define USB_DEVICE_ID_AASHIMA_GAMEPAD	0x0025
+#define USB_DEVICE_ID_AASHIMA_PREDATOR	0x0026
+
+#define USB_VENDOR_ID_ACECAD		0x0460
+#define USB_DEVICE_ID_ACECAD_FLAIR	0x0004
+#define USB_DEVICE_ID_ACECAD_302	0x0008
+
+#define USB_VENDOR_ID_ACRUX		0x1a34
+
+#define USB_VENDOR_ID_ACTIONSTAR	0x2101
+#define USB_DEVICE_ID_ACTIONSTAR_1011	0x1011
+
+#define USB_VENDOR_ID_ADS_TECH		0x06e1
+#define USB_DEVICE_ID_ADS_TECH_RADIO_SI470X	0xa155
+
+#define USB_VENDOR_ID_AFATECH		0x15a4
+#define USB_DEVICE_ID_AFATECH_AF9016	0x9016
+
+#define USB_VENDOR_ID_AIPTEK		0x08ca
+#define USB_DEVICE_ID_AIPTEK_01		0x0001
+#define USB_DEVICE_ID_AIPTEK_10		0x0010
+#define USB_DEVICE_ID_AIPTEK_20		0x0020
+#define USB_DEVICE_ID_AIPTEK_21		0x0021
+#define USB_DEVICE_ID_AIPTEK_22		0x0022
+#define USB_DEVICE_ID_AIPTEK_23		0x0023
+#define USB_DEVICE_ID_AIPTEK_24		0x0024
+
+#define USB_VENDOR_ID_AIRCABLE		0x16CA
+#define USB_DEVICE_ID_AIRCABLE1		0x1502
+
+#define USB_VENDOR_ID_AIREN		0x1a2c
+#define USB_DEVICE_ID_AIREN_SLIMPLUS	0x0002
+
+#define USB_VENDOR_ID_ALCOR		0x058f
+#define USB_DEVICE_ID_ALCOR_USBRS232	0x9720
+
+#define USB_VENDOR_ID_ALPS		0x0433
+#define USB_DEVICE_ID_IBM_GAMEPAD	0x1101
+
+#define USB_VENDOR_ID_APPLE		0x05ac
+#define USB_DEVICE_ID_APPLE_MIGHTYMOUSE	0x0304
+#define USB_DEVICE_ID_APPLE_MAGICMOUSE	0x030d
+#define USB_DEVICE_ID_APPLE_MAGICTRACKPAD	0x030e
+#define USB_DEVICE_ID_APPLE_FOUNTAIN_ANSI	0x020e
+#define USB_DEVICE_ID_APPLE_FOUNTAIN_ISO	0x020f
+#define USB_DEVICE_ID_APPLE_GEYSER_ANSI	0x0214
+#define USB_DEVICE_ID_APPLE_GEYSER_ISO	0x0215
+#define USB_DEVICE_ID_APPLE_GEYSER_JIS	0x0216
+#define USB_DEVICE_ID_APPLE_GEYSER3_ANSI	0x0217
+#define USB_DEVICE_ID_APPLE_GEYSER3_ISO	0x0218
+#define USB_DEVICE_ID_APPLE_GEYSER3_JIS	0x0219
+#define USB_DEVICE_ID_APPLE_GEYSER4_ANSI	0x021a
+#define USB_DEVICE_ID_APPLE_GEYSER4_ISO	0x021b
+#define USB_DEVICE_ID_APPLE_GEYSER4_JIS	0x021c
+#define USB_DEVICE_ID_APPLE_ALU_MINI_ANSI	0x021d
+#define USB_DEVICE_ID_APPLE_ALU_MINI_ISO	0x021e
+#define USB_DEVICE_ID_APPLE_ALU_MINI_JIS	0x021f
+#define USB_DEVICE_ID_APPLE_ALU_ANSI	0x0220
+#define USB_DEVICE_ID_APPLE_ALU_ISO	0x0221
+#define USB_DEVICE_ID_APPLE_ALU_JIS	0x0222
+#define USB_DEVICE_ID_APPLE_WELLSPRING_ANSI	0x0223
+#define USB_DEVICE_ID_APPLE_WELLSPRING_ISO	0x0224
+#define USB_DEVICE_ID_APPLE_WELLSPRING_JIS	0x0225
+#define USB_DEVICE_ID_APPLE_GEYSER4_HF_ANSI	0x0229
+#define USB_DEVICE_ID_APPLE_GEYSER4_HF_ISO	0x022a
+#define USB_DEVICE_ID_APPLE_GEYSER4_HF_JIS	0x022b
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_ANSI	0x022c
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_ISO	0x022d
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_JIS	0x022e
+#define USB_DEVICE_ID_APPLE_WELLSPRING2_ANSI	0x0230
+#define USB_DEVICE_ID_APPLE_WELLSPRING2_ISO	0x0231
+#define USB_DEVICE_ID_APPLE_WELLSPRING2_JIS	0x0232
+#define USB_DEVICE_ID_APPLE_WELLSPRING3_ANSI	0x0236
+#define USB_DEVICE_ID_APPLE_WELLSPRING3_ISO	0x0237
+#define USB_DEVICE_ID_APPLE_WELLSPRING3_JIS	0x0238
+#define USB_DEVICE_ID_APPLE_WELLSPRING4_ANSI	0x023f
+#define USB_DEVICE_ID_APPLE_WELLSPRING4_ISO	0x0240
+#define USB_DEVICE_ID_APPLE_WELLSPRING4_JIS	0x0241
+#define USB_DEVICE_ID_APPLE_WELLSPRING4A_ANSI	0x0242
+#define USB_DEVICE_ID_APPLE_WELLSPRING4A_ISO	0x0243
+#define USB_DEVICE_ID_APPLE_WELLSPRING4A_JIS	0x0244
+#define USB_DEVICE_ID_APPLE_WELLSPRING5_ANSI	0x0245
+#define USB_DEVICE_ID_APPLE_WELLSPRING5_ISO	0x0246
+#define USB_DEVICE_ID_APPLE_WELLSPRING5_JIS	0x0247
+#define USB_DEVICE_ID_APPLE_ALU_REVB_ANSI	0x024f
+#define USB_DEVICE_ID_APPLE_ALU_REVB_ISO	0x0250
+#define USB_DEVICE_ID_APPLE_ALU_REVB_JIS	0x0251
+#define USB_DEVICE_ID_APPLE_WELLSPRING5A_ANSI	0x0252
+#define USB_DEVICE_ID_APPLE_WELLSPRING5A_ISO	0x0253
+#define USB_DEVICE_ID_APPLE_WELLSPRING5A_JIS	0x0254
+#define USB_DEVICE_ID_APPLE_WELLSPRING7A_ANSI	0x0259
+#define USB_DEVICE_ID_APPLE_WELLSPRING7A_ISO	0x025a
+#define USB_DEVICE_ID_APPLE_WELLSPRING7A_JIS	0x025b
+#define USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI	0x0249
+#define USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO	0x024a
+#define USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS	0x024b
+#define USB_DEVICE_ID_APPLE_WELLSPRING6_ANSI	0x024c
+#define USB_DEVICE_ID_APPLE_WELLSPRING6_ISO	0x024d
+#define USB_DEVICE_ID_APPLE_WELLSPRING6_JIS	0x024e
+#define USB_DEVICE_ID_APPLE_WELLSPRING7_ANSI	0x0262
+#define USB_DEVICE_ID_APPLE_WELLSPRING7_ISO	0x0263
+#define USB_DEVICE_ID_APPLE_WELLSPRING7_JIS	0x0264
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI  0x0239
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO   0x023a
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_JIS   0x023b
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI  0x0255
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO   0x0256
+#define USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY	0x030a
+#define USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY	0x030b
+#define USB_DEVICE_ID_APPLE_ATV_IRCONTROL	0x8241
+#define USB_DEVICE_ID_APPLE_IRCONTROL4	0x8242
+
+#define USB_VENDOR_ID_ASUS		0x0486
+#define USB_DEVICE_ID_ASUS_T91MT	0x0185
+#define USB_DEVICE_ID_ASUSTEK_MULTITOUCH_YFO	0x0186
+
+#define USB_VENDOR_ID_ASUSTEK		0x0b05
+#define USB_DEVICE_ID_ASUSTEK_LCM	0x1726
+#define USB_DEVICE_ID_ASUSTEK_LCM2	0x175b
+
+#define USB_VENDOR_ID_ATEN		0x0557
+#define USB_DEVICE_ID_ATEN_UC100KM	0x2004
+#define USB_DEVICE_ID_ATEN_CS124U	0x2202
+#define USB_DEVICE_ID_ATEN_2PORTKVM	0x2204
+#define USB_DEVICE_ID_ATEN_4PORTKVM	0x2205
+#define USB_DEVICE_ID_ATEN_4PORTKVMC	0x2208
+
+#define USB_VENDOR_ID_ATMEL		0x03eb
+#define USB_DEVICE_ID_ATMEL_MULTITOUCH	0x211c
+#define USB_DEVICE_ID_ATMEL_MXT_DIGITIZER	0x2118
+#define USB_VENDOR_ID_ATMEL_V_USB	0x16c0
+#define USB_DEVICE_ID_ATMEL_V_USB	0x05df
+
+#define USB_VENDOR_ID_AUREAL		0x0755
+#define USB_DEVICE_ID_AUREAL_W01RN	0x2626
+
+#define USB_VENDOR_ID_AVERMEDIA		0x07ca
+#define USB_DEVICE_ID_AVER_FM_MR800	0xb800
+
+#define USB_VENDOR_ID_AXENTIA		0x12cf
+#define USB_DEVICE_ID_AXENTIA_FM_RADIO	0x7111
+
+#define USB_VENDOR_ID_BAANTO		0x2453
+#define USB_DEVICE_ID_BAANTO_MT_190W2	0x0100
+
+#define USB_VENDOR_ID_BELKIN		0x050d
+#define USB_DEVICE_ID_FLIP_KVM		0x3201
+
+#define USB_VENDOR_ID_BERKSHIRE		0x0c98
+#define USB_DEVICE_ID_BERKSHIRE_PCWD	0x1140
+
+#define USB_VENDOR_ID_BTC		0x046e
+#define USB_DEVICE_ID_BTC_EMPREX_REMOTE	0x5578
+#define USB_DEVICE_ID_BTC_EMPREX_REMOTE_2	0x5577
+
+#define USB_VENDOR_ID_CANDO		0x2087
+#define USB_DEVICE_ID_CANDO_PIXCIR_MULTI_TOUCH 0x0703
+#define USB_DEVICE_ID_CANDO_MULTI_TOUCH	0x0a01
+#define USB_DEVICE_ID_CANDO_MULTI_TOUCH_10_1 0x0a02
+#define USB_DEVICE_ID_CANDO_MULTI_TOUCH_11_6 0x0b03
+#define USB_DEVICE_ID_CANDO_MULTI_TOUCH_15_6 0x0f01
+
+#define USB_VENDOR_ID_CH		0x068e
+#define USB_DEVICE_ID_CH_PRO_THROTTLE	0x00f1
+#define USB_DEVICE_ID_CH_PRO_PEDALS	0x00f2
+#define USB_DEVICE_ID_CH_FIGHTERSTICK	0x00f3
+#define USB_DEVICE_ID_CH_COMBATSTICK	0x00f4
+#define USB_DEVICE_ID_CH_FLIGHT_SIM_ECLIPSE_YOKE       0x0051
+#define USB_DEVICE_ID_CH_FLIGHT_SIM_YOKE	0x00ff
+#define USB_DEVICE_ID_CH_3AXIS_5BUTTON_STICK	0x00d3
+#define USB_DEVICE_ID_CH_AXIS_295	0x001c
+
+#define USB_VENDOR_ID_CHERRY		0x046a
+#define USB_DEVICE_ID_CHERRY_CYMOTION	0x0023
+#define USB_DEVICE_ID_CHERRY_CYMOTION_SOLAR	0x0027
+
+#define USB_VENDOR_ID_CHIC		0x05fe
+#define USB_DEVICE_ID_CHIC_GAMEPAD	0x0014
+
+#define USB_VENDOR_ID_CHICONY		0x04f2
+#define USB_DEVICE_ID_CHICONY_TACTICAL_PAD	0x0418
+#define USB_DEVICE_ID_CHICONY_MULTI_TOUCH	0xb19d
+#define USB_DEVICE_ID_CHICONY_WIRELESS	0x0618
+#define USB_DEVICE_ID_CHICONY_WIRELESS2	0x1123
+#define USB_DEVICE_ID_CHICONY_AK1D	0x1125
+
+#define USB_VENDOR_ID_CHUNGHWAT		0x2247
+#define USB_DEVICE_ID_CHUNGHWAT_MULTITOUCH	0x0001
+
+#define USB_VENDOR_ID_CIDC		0x1677
+
+#define USB_VENDOR_ID_CMEDIA		0x0d8c
+#define USB_DEVICE_ID_CM109		0x000e
+
+#define USB_VENDOR_ID_CODEMERCS		0x07c0
+#define USB_DEVICE_ID_CODEMERCS_IOW_FIRST	0x1500
+#define USB_DEVICE_ID_CODEMERCS_IOW_LAST	0x15ff
+
+#define USB_VENDOR_ID_CREATIVELABS	0x041e
+#define USB_DEVICE_ID_PRODIKEYS_PCMIDI	0x2801
+
+#define USB_VENDOR_ID_CVTOUCH		0x1ff7
+#define USB_DEVICE_ID_CVTOUCH_SCREEN	0x0013
+
+#define USB_VENDOR_ID_CYGNAL		0x10c4
+#define USB_DEVICE_ID_CYGNAL_RADIO_SI470X	0x818a
+
+#define USB_VENDOR_ID_CYPRESS		0x04b4
+#define USB_DEVICE_ID_CYPRESS_MOUSE	0x0001
+#define USB_DEVICE_ID_CYPRESS_HIDCOM	0x5500
+#define USB_DEVICE_ID_CYPRESS_ULTRAMOUSE	0x7417
+#define USB_DEVICE_ID_CYPRESS_BARCODE_1	0xde61
+#define USB_DEVICE_ID_CYPRESS_BARCODE_2	0xde64
+#define USB_DEVICE_ID_CYPRESS_BARCODE_3	0xbca1
+#define USB_DEVICE_ID_CYPRESS_BARCODE_4	0xed81
+#define USB_DEVICE_ID_CYPRESS_TRUETOUCH	0xc001
+
+#define USB_VENDOR_ID_DEALEXTREAME	0x10c5
+#define USB_DEVICE_ID_DEALEXTREAME_RADIO_SI4701	0x819a
+
+#define USB_VENDOR_ID_DELORME		0x1163
+#define USB_DEVICE_ID_DELORME_EARTHMATE	0x0100
+#define USB_DEVICE_ID_DELORME_EM_LT20	0x0200
+
+#define USB_VENDOR_ID_DMI		0x0c0b
+#define USB_DEVICE_ID_DMI_ENC		0x5fab
+
+#define USB_VENDOR_ID_DRAGONRISE	0x0079
+
+#define USB_VENDOR_ID_DWAV		0x0eef
+#define USB_DEVICE_ID_EGALAX_TOUCHCONTROLLER	0x0001
+#define USB_DEVICE_ID_DWAV_TOUCHCONTROLLER	0x0002
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_480D	0x480d
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_480E	0x480e
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7207	0x7207
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_720C	0x720c
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7224	0x7224
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_722A	0x722A
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_725E	0x725e
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7262	0x7262
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_726B	0x726b
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72AA	0x72aa
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72A1	0x72a1
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72FA	0x72fa
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7302	0x7302
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7349	0x7349
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_73F7	0x73f7
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_A001	0xa001
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7224      0x7224
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72D0      0x72d0
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72C4      0x72c4
+
+#define USB_VENDOR_ID_ELECOM		0x056e
+#define USB_DEVICE_ID_ELECOM_BM084	0x0061
+
+#define USB_VENDOR_ID_DREAM_CHEEKY	0x1d34
+
+#define USB_VENDOR_ID_ELO		0x04E7
+#define USB_DEVICE_ID_ELO_TS2515	0x0022
+#define USB_DEVICE_ID_ELO_TS2700	0x0020
+
+#define USB_VENDOR_ID_EMS		0x2006
+#define USB_DEVICE_ID_EMS_TRIO_LINKER_PLUS_II 0x0118
+
+#define USB_VENDOR_ID_FLATFROG		0x25b5
+#define USB_DEVICE_ID_MULTITOUCH_3200	0x0002
+
+#define USB_VENDOR_ID_ESSENTIAL_REALITY	0x0d7f
+#define USB_DEVICE_ID_ESSENTIAL_REALITY_P5 0x0100
+
+#define USB_VENDOR_ID_ETT		0x0664
+#define USB_DEVICE_ID_TC5UH		0x0309
+#define USB_DEVICE_ID_TC4UM		0x0306
+
+#define USB_VENDOR_ID_ETURBOTOUCH	0x22b9
+#define USB_DEVICE_ID_ETURBOTOUCH	0x0006
+
+#define USB_VENDOR_ID_EZKEY		0x0518
+#define USB_DEVICE_ID_BTC_8193		0x0002
+
+#define USB_VENDOR_ID_FORMOSA          0x147a
+#define USB_DEVICE_ID_FORMOSA_IR_RECEIVER      0xe03e
+
+#define USB_VENDOR_ID_FREESCALE		0x15A2
+#define USB_DEVICE_ID_FREESCALE_MX28	0x004F
+
+#define USB_VENDOR_ID_FRUCTEL	0x25B6
+#define USB_DEVICE_ID_GAMETEL_MT_MODE	0x0002
+
+#define USB_VENDOR_ID_GAMERON		0x0810
+#define USB_DEVICE_ID_GAMERON_DUAL_PSX_ADAPTOR	0x0001
+#define USB_DEVICE_ID_GAMERON_DUAL_PCS_ADAPTOR	0x0002
+
+#define USB_VENDOR_ID_GENERAL_TOUCH	0x0dfc
+#define USB_DEVICE_ID_GENERAL_TOUCH_WIN7_TWOFINGERS 0x0003
+#define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PWT_TENFINGERS 0x0100
+
+#define USB_VENDOR_ID_GLAB		0x06c2
+#define USB_DEVICE_ID_4_PHIDGETSERVO_30	0x0038
+#define USB_DEVICE_ID_1_PHIDGETSERVO_30	0x0039
+#define USB_DEVICE_ID_0_0_4_IF_KIT	0x0040
+#define USB_DEVICE_ID_0_16_16_IF_KIT	0x0044
+#define USB_DEVICE_ID_8_8_8_IF_KIT	0x0045
+#define USB_DEVICE_ID_0_8_7_IF_KIT	0x0051
+#define USB_DEVICE_ID_0_8_8_IF_KIT	0x0053
+#define USB_DEVICE_ID_PHIDGET_MOTORCONTROL	0x0058
+
+#define USB_VENDOR_ID_GOODTOUCH		0x1aad
+#define USB_DEVICE_ID_GOODTOUCH_000f	0x000f
+
+#define USB_VENDOR_ID_GOTOP		0x08f2
+#define USB_DEVICE_ID_SUPER_Q2		0x007f
+#define USB_DEVICE_ID_GOGOPEN		0x00ce
+#define USB_DEVICE_ID_PENPOWER		0x00f4
+
+#define USB_VENDOR_ID_GREENASIA		0x0e8f
+#define USB_DEVICE_ID_GREENASIA_DUAL_USB_JOYPAD	0x3013
+
+#define USB_VENDOR_ID_GRETAGMACBETH	0x0971
+#define USB_DEVICE_ID_GRETAGMACBETH_HUEY	0x2005
+
+#define USB_VENDOR_ID_GRIFFIN		0x077d
+#define USB_DEVICE_ID_POWERMATE		0x0410
+#define USB_DEVICE_ID_SOUNDKNOB		0x04AA
+#define USB_DEVICE_ID_RADIOSHARK	0x627a
+
+#define USB_VENDOR_ID_GTCO		0x078c
+#define USB_DEVICE_ID_GTCO_90		0x0090
+#define USB_DEVICE_ID_GTCO_100		0x0100
+#define USB_DEVICE_ID_GTCO_101		0x0101
+#define USB_DEVICE_ID_GTCO_103		0x0103
+#define USB_DEVICE_ID_GTCO_104		0x0104
+#define USB_DEVICE_ID_GTCO_105		0x0105
+#define USB_DEVICE_ID_GTCO_106		0x0106
+#define USB_DEVICE_ID_GTCO_107		0x0107
+#define USB_DEVICE_ID_GTCO_108		0x0108
+#define USB_DEVICE_ID_GTCO_200		0x0200
+#define USB_DEVICE_ID_GTCO_201		0x0201
+#define USB_DEVICE_ID_GTCO_202		0x0202
+#define USB_DEVICE_ID_GTCO_203		0x0203
+#define USB_DEVICE_ID_GTCO_204		0x0204
+#define USB_DEVICE_ID_GTCO_205		0x0205
+#define USB_DEVICE_ID_GTCO_206		0x0206
+#define USB_DEVICE_ID_GTCO_207		0x0207
+#define USB_DEVICE_ID_GTCO_300		0x0300
+#define USB_DEVICE_ID_GTCO_301		0x0301
+#define USB_DEVICE_ID_GTCO_302		0x0302
+#define USB_DEVICE_ID_GTCO_303		0x0303
+#define USB_DEVICE_ID_GTCO_304		0x0304
+#define USB_DEVICE_ID_GTCO_305		0x0305
+#define USB_DEVICE_ID_GTCO_306		0x0306
+#define USB_DEVICE_ID_GTCO_307		0x0307
+#define USB_DEVICE_ID_GTCO_308		0x0308
+#define USB_DEVICE_ID_GTCO_309		0x0309
+#define USB_DEVICE_ID_GTCO_400		0x0400
+#define USB_DEVICE_ID_GTCO_401		0x0401
+#define USB_DEVICE_ID_GTCO_402		0x0402
+#define USB_DEVICE_ID_GTCO_403		0x0403
+#define USB_DEVICE_ID_GTCO_404		0x0404
+#define USB_DEVICE_ID_GTCO_405		0x0405
+#define USB_DEVICE_ID_GTCO_500		0x0500
+#define USB_DEVICE_ID_GTCO_501		0x0501
+#define USB_DEVICE_ID_GTCO_502		0x0502
+#define USB_DEVICE_ID_GTCO_503		0x0503
+#define USB_DEVICE_ID_GTCO_504		0x0504
+#define USB_DEVICE_ID_GTCO_1000		0x1000
+#define USB_DEVICE_ID_GTCO_1001		0x1001
+#define USB_DEVICE_ID_GTCO_1002		0x1002
+#define USB_DEVICE_ID_GTCO_1003		0x1003
+#define USB_DEVICE_ID_GTCO_1004		0x1004
+#define USB_DEVICE_ID_GTCO_1005		0x1005
+#define USB_DEVICE_ID_GTCO_1006		0x1006
+#define USB_DEVICE_ID_GTCO_1007		0x1007
+
+#define USB_VENDOR_ID_GYRATION		0x0c16
+#define USB_DEVICE_ID_GYRATION_REMOTE	0x0002
+#define USB_DEVICE_ID_GYRATION_REMOTE_2 0x0003
+#define USB_DEVICE_ID_GYRATION_REMOTE_3 0x0008
+
+#define USB_VENDOR_ID_HANWANG		0x0b57
+#define USB_DEVICE_ID_HANWANG_TABLET_FIRST	0x5000
+#define USB_DEVICE_ID_HANWANG_TABLET_LAST	0x8fff
+
+#define USB_VENDOR_ID_HANVON		0x20b3
+#define USB_DEVICE_ID_HANVON_MULTITOUCH	0x0a18
+
+#define USB_VENDOR_ID_HANVON_ALT	0x22ed
+#define USB_DEVICE_ID_HANVON_ALT_MULTITOUCH	0x1010
+
+#define USB_VENDOR_ID_HAPP		0x078b
+#define USB_DEVICE_ID_UGCI_DRIVING	0x0010
+#define USB_DEVICE_ID_UGCI_FLYING	0x0020
+#define USB_DEVICE_ID_UGCI_FIGHTING	0x0030
+
+#define USB_VENDOR_ID_IDEACOM		0x1cb6
+#define USB_DEVICE_ID_IDEACOM_IDC6650	0x6650
+#define USB_DEVICE_ID_IDEACOM_IDC6651	0x6651
+
+#define USB_VENDOR_ID_ILITEK		0x222a
+#define USB_DEVICE_ID_ILITEK_MULTITOUCH	0x0001
+
+#define USB_VENDOR_ID_ION		0x15e4
+#define USB_DEVICE_ID_ICADE		0x0132
+
+#define USB_VENDOR_ID_HOLTEK		0x1241
+#define USB_DEVICE_ID_HOLTEK_ON_LINE_GRIP	0x5015
+
+#define USB_VENDOR_ID_HOLTEK_ALT		0x04d9
+#define USB_DEVICE_ID_HOLTEK_ALT_KEYBOARD	0xa055
+
+#define USB_VENDOR_ID_IMATION		0x0718
+#define USB_DEVICE_ID_DISC_STAKKA	0xd000
+
+#define USB_VENDOR_ID_IRTOUCHSYSTEMS	0x6615
+#define USB_DEVICE_ID_IRTOUCH_INFRARED_USB	0x0070
+
+#define USB_VENDOR_ID_JESS		0x0c45
+#define USB_DEVICE_ID_JESS_YUREX	0x1010
+
+#define USB_VENDOR_ID_JESS2		0x0f30
+#define USB_DEVICE_ID_JESS2_COLOR_RUMBLE_PAD 0x0111
+
+#define USB_VENDOR_ID_KBGEAR		0x084e
+#define USB_DEVICE_ID_KBGEAR_JAMSTUDIO	0x1001
+
+#define USB_VENDOR_ID_KENSINGTON	0x047d
+#define USB_DEVICE_ID_KS_SLIMBLADE	0x2041
+
+#define USB_VENDOR_ID_KWORLD		0x1b80
+#define USB_DEVICE_ID_KWORLD_RADIO_FM700	0xd700
+
+#define USB_VENDOR_ID_KEYTOUCH		0x0926
+#define USB_DEVICE_ID_KEYTOUCH_IEC	0x3333
+
+#define USB_VENDOR_ID_KYE		0x0458
+#define USB_DEVICE_ID_KYE_ERGO_525V	0x0087
+#define USB_DEVICE_ID_KYE_GPEN_560	0x5003
+#define USB_DEVICE_ID_KYE_EASYPEN_I405X	0x5010
+#define USB_DEVICE_ID_KYE_MOUSEPEN_I608X	0x5011
+#define USB_DEVICE_ID_KYE_EASYPEN_M610X	0x5013
+
+#define USB_VENDOR_ID_LABTEC		0x1020
+#define USB_DEVICE_ID_LABTEC_WIRELESS_KEYBOARD	0x0006
+
+#define USB_VENDOR_ID_LCPOWER		0x1241
+#define USB_DEVICE_ID_LCPOWER_LC1000	0xf767
+
+#define USB_VENDOR_ID_LD		0x0f11
+#define USB_DEVICE_ID_LD_CASSY		0x1000
+#define USB_DEVICE_ID_LD_CASSY2		0x1001
+#define USB_DEVICE_ID_LD_POCKETCASSY	0x1010
+#define USB_DEVICE_ID_LD_POCKETCASSY2	0x1011
+#define USB_DEVICE_ID_LD_MOBILECASSY	0x1020
+#define USB_DEVICE_ID_LD_MOBILECASSY2	0x1021
+#define USB_DEVICE_ID_LD_MICROCASSYVOLTAGE	0x1031
+#define USB_DEVICE_ID_LD_MICROCASSYCURRENT	0x1032
+#define USB_DEVICE_ID_LD_MICROCASSYTIME		0x1033
+#define USB_DEVICE_ID_LD_MICROCASSYTEMPERATURE	0x1035
+#define USB_DEVICE_ID_LD_MICROCASSYPH		0x1038
+#define USB_DEVICE_ID_LD_JWM		0x1080
+#define USB_DEVICE_ID_LD_DMMP		0x1081
+#define USB_DEVICE_ID_LD_UMIP		0x1090
+#define USB_DEVICE_ID_LD_UMIC		0x10A0
+#define USB_DEVICE_ID_LD_UMIB		0x10B0
+#define USB_DEVICE_ID_LD_XRAY		0x1100
+#define USB_DEVICE_ID_LD_XRAY2		0x1101
+#define USB_DEVICE_ID_LD_XRAYCT		0x1110
+#define USB_DEVICE_ID_LD_VIDEOCOM	0x1200
+#define USB_DEVICE_ID_LD_MOTOR		0x1210
+#define USB_DEVICE_ID_LD_COM3LAB	0x2000
+#define USB_DEVICE_ID_LD_TELEPORT	0x2010
+#define USB_DEVICE_ID_LD_NETWORKANALYSER 0x2020
+#define USB_DEVICE_ID_LD_POWERCONTROL	0x2030
+#define USB_DEVICE_ID_LD_MACHINETEST	0x2040
+#define USB_DEVICE_ID_LD_MOSTANALYSER	0x2050
+#define USB_DEVICE_ID_LD_MOSTANALYSER2	0x2051
+#define USB_DEVICE_ID_LD_ABSESP		0x2060
+#define USB_DEVICE_ID_LD_AUTODATABUS	0x2070
+#define USB_DEVICE_ID_LD_MCT		0x2080
+#define USB_DEVICE_ID_LD_HYBRID		0x2090
+#define USB_DEVICE_ID_LD_HEATCONTROL	0x20A0
+
+#define USB_VENDOR_ID_LENOVO		0x17ef
+#define USB_DEVICE_ID_LENOVO_TPKBD	0x6009
+
+#define USB_VENDOR_ID_LG		0x1fd2
+#define USB_DEVICE_ID_LG_MULTITOUCH	0x0064
+
+#define USB_VENDOR_ID_LOGITECH		0x046d
+#define USB_DEVICE_ID_LOGITECH_AUDIOHUB 0x0a0e
+#define USB_DEVICE_ID_LOGITECH_RECEIVER	0xc101
+#define USB_DEVICE_ID_LOGITECH_HARMONY_FIRST  0xc110
+#define USB_DEVICE_ID_LOGITECH_HARMONY_LAST 0xc14f
+#define USB_DEVICE_ID_LOGITECH_HARMONY_PS3 0x0306
+#define USB_DEVICE_ID_LOGITECH_RUMBLEPAD_CORD	0xc20a
+#define USB_DEVICE_ID_LOGITECH_RUMBLEPAD	0xc211
+#define USB_DEVICE_ID_LOGITECH_EXTREME_3D	0xc215
+#define USB_DEVICE_ID_LOGITECH_RUMBLEPAD2	0xc218
+#define USB_DEVICE_ID_LOGITECH_RUMBLEPAD2_2	0xc219
+#define USB_DEVICE_ID_LOGITECH_WINGMAN_F3D	0xc283
+#define USB_DEVICE_ID_LOGITECH_FORCE3D_PRO	0xc286
+#define USB_DEVICE_ID_LOGITECH_FLIGHT_SYSTEM_G940	0xc287
+#define USB_DEVICE_ID_LOGITECH_WINGMAN_FFG	0xc293
+#define USB_DEVICE_ID_LOGITECH_WHEEL	0xc294
+#define USB_DEVICE_ID_LOGITECH_MOMO_WHEEL	0xc295
+#define USB_DEVICE_ID_LOGITECH_DFP_WHEEL	0xc298
+#define USB_DEVICE_ID_LOGITECH_G25_WHEEL	0xc299
+#define USB_DEVICE_ID_LOGITECH_DFGT_WHEEL	0xc29a
+#define USB_DEVICE_ID_LOGITECH_G27_WHEEL	0xc29b
+#define USB_DEVICE_ID_LOGITECH_WII_WHEEL	0xc29c
+#define USB_DEVICE_ID_LOGITECH_ELITE_KBD	0xc30a
+#define USB_DEVICE_ID_S510_RECEIVER	0xc50c
+#define USB_DEVICE_ID_S510_RECEIVER_2	0xc517
+#define USB_DEVICE_ID_LOGITECH_CORDLESS_DESKTOP_LX500	0xc512
+#define USB_DEVICE_ID_MX3000_RECEIVER	0xc513
+#define USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER	0xc52b
+#define USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER_2	0xc532
+#define USB_DEVICE_ID_SPACETRAVELLER	0xc623
+#define USB_DEVICE_ID_SPACENAVIGATOR	0xc626
+#define USB_DEVICE_ID_DINOVO_DESKTOP	0xc704
+#define USB_DEVICE_ID_DINOVO_EDGE	0xc714
+#define USB_DEVICE_ID_DINOVO_MINI	0xc71f
+#define USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2	0xca03
+
+#define USB_VENDOR_ID_LUMIO		0x202e
+#define USB_DEVICE_ID_CRYSTALTOUCH	0x0006
+#define USB_DEVICE_ID_CRYSTALTOUCH_DUAL	0x0007
+
+#define USB_VENDOR_ID_MADCATZ		0x0738
+#define USB_DEVICE_ID_MADCATZ_BEATPAD	0x4540
+
+#define USB_VENDOR_ID_MCC		0x09db
+#define USB_DEVICE_ID_MCC_PMD1024LS	0x0076
+#define USB_DEVICE_ID_MCC_PMD1208LS	0x007a
+
+#define USB_VENDOR_ID_MGE		0x0463
+#define USB_DEVICE_ID_MGE_UPS		0xffff
+#define USB_DEVICE_ID_MGE_UPS1		0x0001
+
+#define USB_VENDOR_ID_MICROCHIP		0x04d8
+#define USB_DEVICE_ID_PICKIT1		0x0032
+#define USB_DEVICE_ID_PICKIT2		0x0033
+#define USB_DEVICE_ID_PICOLCD		0xc002
+#define USB_DEVICE_ID_PICOLCD_BOOTLOADER	0xf002
+
+#define USB_VENDOR_ID_MICROSOFT		0x045e
+#define USB_DEVICE_ID_SIDEWINDER_GV	0x003b
+#define USB_DEVICE_ID_WIRELESS_OPTICAL_DESKTOP_3_0 0x009d
+#define USB_DEVICE_ID_MS_NE4K		0x00db
+#define USB_DEVICE_ID_MS_LK6K		0x00f9
+#define USB_DEVICE_ID_MS_PRESENTER_8K_BT	0x0701
+#define USB_DEVICE_ID_MS_PRESENTER_8K_USB	0x0713
+#define USB_DEVICE_ID_MS_DIGITAL_MEDIA_3K	0x0730
+#define USB_DEVICE_ID_MS_COMFORT_MOUSE_4500	0x076c
+
+#define USB_VENDOR_ID_MOJO		0x8282
+#define USB_DEVICE_ID_RETRO_ADAPTER	0x3201
+
+#define USB_VENDOR_ID_MONTEREY		0x0566
+#define USB_DEVICE_ID_GENIUS_KB29E	0x3004
+
+#define USB_VENDOR_ID_MSI		0x1770
+#define USB_DEVICE_ID_MSI_GX680R_LED_PANEL	0xff00
+
+#define USB_VENDOR_ID_NATIONAL_SEMICONDUCTOR 0x0400
+#define USB_DEVICE_ID_N_S_HARMONY	0xc359
+
+#define USB_VENDOR_ID_NATSU		0x08b7
+#define USB_DEVICE_ID_NATSU_GAMEPAD	0x0001
+
+#define USB_VENDOR_ID_NCR		0x0404
+#define USB_DEVICE_ID_NCR_FIRST		0x0300
+#define USB_DEVICE_ID_NCR_LAST		0x03ff
+
+#define USB_VENDOR_ID_NEC		0x073e
+#define USB_DEVICE_ID_NEC_USB_GAME_PAD	0x0301
+
+#define USB_VENDOR_ID_NEXIO		0x1870
+#define USB_DEVICE_ID_NEXIO_MULTITOUCH_420	0x010d
+
+#define USB_VENDOR_ID_NEXTWINDOW	0x1926
+#define USB_DEVICE_ID_NEXTWINDOW_TOUCHSCREEN	0x0003
+
+#define USB_VENDOR_ID_NINTENDO		0x057e
+#define USB_DEVICE_ID_NINTENDO_WIIMOTE	0x0306
+
+#define USB_VENDOR_ID_NOVATEK		0x0603
+#define USB_DEVICE_ID_NOVATEK_PCT	0x0600
+#define USB_DEVICE_ID_NOVATEK_MOUSE	0x1602
+
+#define USB_VENDOR_ID_NTRIG		0x1b96
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN   0x0001
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_1   0x0003
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_2   0x0004
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_3   0x0005
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_4   0x0006
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_5   0x0007
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_6   0x0008
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_7   0x0009
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_8   0x000A
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_9   0x000B
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_10   0x000C
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_11   0x000D
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_12   0x000E
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_13   0x000F
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_14   0x0010
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_15   0x0011
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_16   0x0012
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_17   0x0013
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_18   0x0014
+
+#define USB_VENDOR_ID_ONTRAK		0x0a07
+#define USB_DEVICE_ID_ONTRAK_ADU100	0x0064
+
+#define USB_VENDOR_ID_ORTEK		0x05a4
+#define USB_DEVICE_ID_ORTEK_PKB1700	0x1700
+#define USB_DEVICE_ID_ORTEK_WKB2000	0x2000
+
+#define USB_VENDOR_ID_PANASONIC		0x04da
+#define USB_DEVICE_ID_PANABOARD_UBT780	0x1044
+#define USB_DEVICE_ID_PANABOARD_UBT880	0x104d
+
+#define USB_VENDOR_ID_PANJIT		0x134c
+
+#define USB_VENDOR_ID_PANTHERLORD	0x0810
+#define USB_DEVICE_ID_PANTHERLORD_TWIN_USB_JOYSTICK	0x0001
+
+#define USB_VENDOR_ID_PENMOUNT		0x14e1
+#define USB_DEVICE_ID_PENMOUNT_PCI	0x3500
+
+#define USB_VENDOR_ID_PETALYNX		0x18b1
+#define USB_DEVICE_ID_PETALYNX_MAXTER_REMOTE	0x0037
+
+#define USB_VENDOR_ID_PHILIPS		0x0471
+#define USB_DEVICE_ID_PHILIPS_IEEE802154_DONGLE 0x0617
+
+#define USB_VENDOR_ID_PI_ENGINEERING	0x05f3
+#define USB_DEVICE_ID_PI_ENGINEERING_VEC_USB_FOOTPEDAL	0xff
+
+#define USB_VENDOR_ID_PIXART				0x093a
+#define USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN	0x8001
+#define USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN1	0x8002
+#define USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN2	0x8003
+
+#define USB_VENDOR_ID_PLAYDOTCOM	0x0b43
+#define USB_DEVICE_ID_PLAYDOTCOM_EMS_USBII	0x0003
+
+#define USB_VENDOR_ID_POWERCOM		0x0d9f
+#define USB_DEVICE_ID_POWERCOM_UPS	0x0002
+
+#define USB_VENDOR_ID_PRODIGE		0x05af
+#define USB_DEVICE_ID_PRODIGE_CORDLESS	0x3062
+
+#define USB_VENDOR_ID_QUANTA		0x0408
+#define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH		0x3000
+#define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3001		0x3001
+#define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3008		0x3008
+
+#define USB_VENDOR_ID_REALTEK		0x0bda
+#define USB_DEVICE_ID_REALTEK_READER	0x0152
+
+#define USB_VENDOR_ID_ROCCAT		0x1e7d
+#define USB_DEVICE_ID_ROCCAT_ARVO	0x30d4
+#define USB_DEVICE_ID_ROCCAT_ISKU	0x319c
+#define USB_DEVICE_ID_ROCCAT_KONE	0x2ced
+#define USB_DEVICE_ID_ROCCAT_KONEPLUS	0x2d51
+#define USB_DEVICE_ID_ROCCAT_KONEXTD	0x2e22
+#define USB_DEVICE_ID_ROCCAT_KOVAPLUS	0x2d50
+#define USB_DEVICE_ID_ROCCAT_LUA	0x2c2e
+#define USB_DEVICE_ID_ROCCAT_PYRA_WIRED	0x2c24
+#define USB_DEVICE_ID_ROCCAT_PYRA_WIRELESS	0x2cf6
+#define USB_DEVICE_ID_ROCCAT_SAVU	0x2d5a
+
+#define USB_VENDOR_ID_SAITEK		0x06a3
+#define USB_DEVICE_ID_SAITEK_RUMBLEPAD	0xff17
+#define USB_DEVICE_ID_SAITEK_PS1000	0x0621
+
+#define USB_VENDOR_ID_SAMSUNG		0x0419
+#define USB_DEVICE_ID_SAMSUNG_IR_REMOTE	0x0001
+#define USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE	0x0600
+
+#define USB_VENDOR_ID_SENNHEISER	0x1395
+#define USB_DEVICE_ID_SENNHEISER_BTD500USB	0x002c
+
+#define USB_VENDOR_ID_SIGMA_MICRO	0x1c4f
+#define USB_DEVICE_ID_SIGMA_MICRO_KEYBOARD	0x0002
+
+#define USB_VENDOR_ID_SIGMATEL		0x066F
+#define USB_DEVICE_ID_SIGMATEL_STMP3780	0x3780
+
+#define USB_VENDOR_ID_SKYCABLE			0x1223
+#define	USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER	0x3F07
+
+#define USB_VENDOR_ID_SONY			0x054c
+#define USB_DEVICE_ID_SONY_VAIO_VGX_MOUSE	0x024b
+#define USB_DEVICE_ID_SONY_VAIO_VGP_MOUSE	0x0374
+#define USB_DEVICE_ID_SONY_PS3_BDREMOTE		0x0306
+#define USB_DEVICE_ID_SONY_PS3_CONTROLLER	0x0268
+#define USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER	0x042f
+
+#define USB_VENDOR_ID_SOUNDGRAPH	0x15c2
+#define USB_DEVICE_ID_SOUNDGRAPH_IMON_FIRST	0x0034
+#define USB_DEVICE_ID_SOUNDGRAPH_IMON_LAST	0x0046
+
+#define USB_VENDOR_ID_STANTUM		0x1f87
+#define USB_DEVICE_ID_MTP		0x0002
+
+#define USB_VENDOR_ID_STANTUM_STM		0x0483
+#define USB_DEVICE_ID_MTP_STM		0x3261
+
+#define USB_VENDOR_ID_STANTUM_SITRONIX		0x1403
+#define USB_DEVICE_ID_MTP_SITRONIX		0x5001
+
+#define USB_VENDOR_ID_STEELSERIES	0x1038
+#define USB_DEVICE_ID_STEELSERIES_SRWS1	0x1410
+
+#define USB_VENDOR_ID_SUN		0x0430
+#define USB_DEVICE_ID_RARITAN_KVM_DONGLE	0xcdab
+
+#define USB_VENDOR_ID_SUNPLUS		0x04fc
+#define USB_DEVICE_ID_SUNPLUS_WDESKTOP	0x05d8
+
+#define USB_VENDOR_ID_SYMBOL		0x05e0
+#define USB_DEVICE_ID_SYMBOL_SCANNER_1	0x0800
+#define USB_DEVICE_ID_SYMBOL_SCANNER_2	0x1300
+
+#define USB_VENDOR_ID_SYNAPTICS		0x06cb
+#define USB_DEVICE_ID_SYNAPTICS_TP	0x0001
+#define USB_DEVICE_ID_SYNAPTICS_INT_TP	0x0002
+#define USB_DEVICE_ID_SYNAPTICS_CPAD	0x0003
+#define USB_DEVICE_ID_SYNAPTICS_TS	0x0006
+#define USB_DEVICE_ID_SYNAPTICS_STICK	0x0007
+#define USB_DEVICE_ID_SYNAPTICS_WP	0x0008
+#define USB_DEVICE_ID_SYNAPTICS_COMP_TP	0x0009
+#define USB_DEVICE_ID_SYNAPTICS_WTP	0x0010
+#define USB_DEVICE_ID_SYNAPTICS_DPAD	0x0013
+
+#define USB_VENDOR_ID_THINGM		0x27b8
+#define USB_DEVICE_ID_BLINK1		0x01ed
+
+#define USB_VENDOR_ID_THRUSTMASTER	0x044f
+
+#define USB_VENDOR_ID_TIVO		0x150a
+#define USB_DEVICE_ID_TIVO_SLIDE_BT	0x1200
+#define USB_DEVICE_ID_TIVO_SLIDE	0x1201
+
+#define USB_VENDOR_ID_TOPSEED		0x0766
+#define USB_DEVICE_ID_TOPSEED_CYBERLINK	0x0204
+
+#define USB_VENDOR_ID_TOPSEED2		0x1784
+#define USB_DEVICE_ID_TOPSEED2_RF_COMBO	0x0004
+#define USB_DEVICE_ID_TOPSEED2_PERIPAD_701	0x0016
+
+#define USB_VENDOR_ID_TOPMAX		0x0663
+#define USB_DEVICE_ID_TOPMAX_COBRAPAD	0x0103
+
+#define USB_VENDOR_ID_TOUCH_INTL	0x1e5e
+#define USB_DEVICE_ID_TOUCH_INTL_MULTI_TOUCH	0x0313
+
+#define USB_VENDOR_ID_TOUCHPACK		0x1bfd
+#define USB_DEVICE_ID_TOUCHPACK_RTS	0x1688
+
+#define USB_VENDOR_ID_TPV		0x25aa
+#define USB_DEVICE_ID_TPV_OPTICAL_TOUCHSCREEN	0x8883
+
+#define USB_VENDOR_ID_TURBOX		0x062a
+#define USB_DEVICE_ID_TURBOX_KEYBOARD	0x0201
+#define USB_DEVICE_ID_TURBOX_TOUCHSCREEN_MOSART	0x7100
+
+#define USB_VENDOR_ID_TWINHAN		0x6253
+#define USB_DEVICE_ID_TWINHAN_IR_REMOTE	0x0100
+
+#define USB_VENDOR_ID_UCLOGIC		0x5543
+#define USB_DEVICE_ID_UCLOGIC_TABLET_PF1209	0x0042
+#define USB_DEVICE_ID_UCLOGIC_TABLET_KNA5	0x6001
+#define USB_DEVICE_ID_UCLOGIC_TABLET_TWA60	0x0064
+#define USB_DEVICE_ID_UCLOGIC_TABLET_WP4030U	0x0003
+#define USB_DEVICE_ID_UCLOGIC_TABLET_WP5540U	0x0004
+#define USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U	0x0005
+#define USB_DEVICE_ID_UCLOGIC_TABLET_WP1062	0x0064
+#define USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850	0x0522
+#define USB_DEVICE_ID_UCLOGIC_TABLET_TWHA60	0x0781
+
+#define USB_VENDOR_ID_UNITEC	0x227d
+#define USB_DEVICE_ID_UNITEC_USB_TOUCH_0709	0x0709
+#define USB_DEVICE_ID_UNITEC_USB_TOUCH_0A19	0x0a19
+
+#define USB_VENDOR_ID_VELLEMAN		0x10cf
+#define USB_DEVICE_ID_VELLEMAN_K8055_FIRST	0x5500
+#define USB_DEVICE_ID_VELLEMAN_K8055_LAST	0x5503
+#define USB_DEVICE_ID_VELLEMAN_K8061_FIRST	0x8061
+#define USB_DEVICE_ID_VELLEMAN_K8061_LAST	0x8068
+
+#define USB_VENDOR_ID_VERNIER		0x08f7
+#define USB_DEVICE_ID_VERNIER_LABPRO	0x0001
+#define USB_DEVICE_ID_VERNIER_GOTEMP	0x0002
+#define USB_DEVICE_ID_VERNIER_SKIP	0x0003
+#define USB_DEVICE_ID_VERNIER_CYCLOPS	0x0004
+#define USB_DEVICE_ID_VERNIER_LCSPEC	0x0006
+
+#define USB_VENDOR_ID_WACOM		0x056a
+#define USB_DEVICE_ID_WACOM_GRAPHIRE_BLUETOOTH	0x81
+#define USB_DEVICE_ID_WACOM_INTUOS4_BLUETOOTH   0x00BD
+
+#define USB_VENDOR_ID_WALTOP				0x172f
+#define USB_DEVICE_ID_WALTOP_SLIM_TABLET_5_8_INCH	0x0032
+#define USB_DEVICE_ID_WALTOP_SLIM_TABLET_12_1_INCH	0x0034
+#define USB_DEVICE_ID_WALTOP_Q_PAD			0x0037
+#define USB_DEVICE_ID_WALTOP_PID_0038			0x0038
+#define USB_DEVICE_ID_WALTOP_MEDIA_TABLET_10_6_INCH	0x0501
+#define USB_DEVICE_ID_WALTOP_MEDIA_TABLET_14_1_INCH	0x0500
+#define USB_DEVICE_ID_WALTOP_SIRIUS_BATTERY_FREE_TABLET	0x0502
+
+#define USB_VENDOR_ID_WISEGROUP		0x0925
+#define USB_DEVICE_ID_SMARTJOY_PLUS	0x0005
+#define USB_DEVICE_ID_1_PHIDGETSERVO_20	0x8101
+#define USB_DEVICE_ID_4_PHIDGETSERVO_20	0x8104
+#define USB_DEVICE_ID_8_8_4_IF_KIT	0x8201
+#define USB_DEVICE_ID_SUPER_JOY_BOX_3	0x8888
+#define USB_DEVICE_ID_QUAD_USB_JOYPAD	0x8800
+#define USB_DEVICE_ID_DUAL_USB_JOYPAD	0x8866
+
+#define USB_VENDOR_ID_WISEGROUP_LTD	0x6666
+#define USB_VENDOR_ID_WISEGROUP_LTD2	0x6677
+#define USB_DEVICE_ID_SMARTJOY_DUAL_PLUS 0x8802
+#define USB_DEVICE_ID_SUPER_JOY_BOX_3_PRO 0x8801
+#define USB_DEVICE_ID_SUPER_DUAL_BOX_PRO 0x8802
+#define USB_DEVICE_ID_SUPER_JOY_BOX_5_PRO 0x8804
+
+#define USB_VENDOR_ID_X_TENSIONS               0x1ae7
+#define USB_DEVICE_ID_SPEEDLINK_VAD_CEZANNE    0x9001
+
+#define USB_VENDOR_ID_XAT	0x2505
+#define USB_DEVICE_ID_XAT_CSR	0x0220
+
+#define USB_VENDOR_ID_XIROKU		0x1477
+#define USB_DEVICE_ID_XIROKU_SPX	0x1006
+#define USB_DEVICE_ID_XIROKU_MPX	0x1007
+#define USB_DEVICE_ID_XIROKU_CSR	0x100e
+#define USB_DEVICE_ID_XIROKU_SPX1	0x1021
+#define USB_DEVICE_ID_XIROKU_CSR1	0x1022
+#define USB_DEVICE_ID_XIROKU_MPX1	0x1023
+#define USB_DEVICE_ID_XIROKU_SPX2	0x1024
+#define USB_DEVICE_ID_XIROKU_CSR2	0x1025
+#define USB_DEVICE_ID_XIROKU_MPX2	0x1026
+
+#define USB_VENDOR_ID_YEALINK		0x6993
+#define USB_DEVICE_ID_YEALINK_P1K_P4K_B2K	0xb001
+
+#define USB_VENDOR_ID_ZEROPLUS		0x0c12
+
+#define USB_VENDOR_ID_ZYDACRON	0x13EC
+#define USB_DEVICE_ID_ZYDACRON_REMOTE_CONTROL	0x0006
+
+#define USB_VENDOR_ID_ZYTRONIC		0x14c8
+#define USB_DEVICE_ID_ZYTRONIC_ZXY100	0x0005
+
+#define USB_VENDOR_ID_PRIMAX	0x0461
+#define USB_DEVICE_ID_PRIMAX_KEYBOARD	0x4e05
+
+#endif
diff --git a/drivers/misc/heci/hid-strings-def.h b/drivers/misc/heci/hid-strings-def.h
new file mode 100644
index 0000000..e1fd92e
--- /dev/null
+++ b/drivers/misc/heci/hid-strings-def.h
@@ -0,0 +1,517 @@
+/*
+ * some HID constants
+ *
+ * Copyright (c) 2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _HID_STRINGS_DEF_H_
+#define _HID_STRINGS_DEF_H_
+
+
+static const struct sensor_map {
+	unsigned code;
+	char *msg;
+} code_msg_arr[] = { 
+	{0x01,	"type_collection"},
+	{0x10,	"category_biometric"},
+	{0x11,	"type_biometric_presence"},
+	{0x12,	"type_biometric_proximity"},
+	{0x13,	"type_biometric_touch"},
+	{0x20,	"category_electrical"},
+	{0x21,	"type_electrical_capacitance"},
+	{0x22,	"type_electrical_current"},
+	{0x23,	"type_electrical_power"},
+	{0x24,	"type_electrical_inductance"},
+	{0x25,	"type_electrical_resistance"},
+	{0x26,	"type_electrical_voltage"},
+	{0x27,	"type_electrical_potentiometer"},
+	{0x28,	"type_electrical_frequency"},
+	{0x29,	"type_electrical_period"},
+	{0x30,	"category_environmental"},
+	{0x31,	"type_environmental_atmospheric_pressure"},
+	{0x32,	"type_environmental_humidity"},
+	{0x33,	"type_environmental_temperature"},
+	{0x34,	"type_environmental_wind_direction"},
+	{0x35,	"type_environmental_wind_speed"},
+	{0x40,	"category_light"},
+	{0x41,	"type_light_ambientlight"},
+	{0x42,	"type_light_consumer_infrared"},
+	{0x50,	"category_location"},
+	{0x51,	"type_location_broadcast"},
+	{0x52,	"type_location_dead_reckoning"},
+	{0x53,	"type_location_gps"},
+	{0x54,	"type_location_lookup"},
+	{0x55,	"type_location_other"},
+	{0x56,	"type_location_static"},
+	{0x57,	"type_location_triangulation"},
+	{0x60,	"category_mechanical"},
+	{0x61,	"type_mechanical_boolean_switch"},
+	{0x62,	"type_mechanical_boolean_switch_array"},
+	{0x63,	"type_mechanical_multivalue_switch"},
+	{0x64,	"type_mechanical_force"},
+	{0x65,	"type_mechanical_pressure"},
+	{0x66,	"type_mechanical_strain"},
+	{0x67,	"type_mechanical_scale_weight"},
+	{0x68,	"type_mechanical_vibrator"},
+	{0x69,	"type_mechanical_hall_effect_switch"},
+	{0x70,	"category_motion"},
+	{0x71,	"type_motion_accelerometer_1d"},
+	{0x72,	"type_motion_accelerometer_2d"},
+	{0x73,	"type_motion_accelerometer_3d"},
+	{0x74,	"type_motion_gyrometer_1d"},
+	{0x75,	"type_motion_gyrometer_2d"},
+	{0x76,	"type_motion_gyrometer_3d"},
+	{0x77,	"type_motion_motion_detector"},
+	{0x78,	"type_motion_speedometer"},
+	{0x79,	"type_motion_accelerometer"},
+	{0x7A,	"type_motion_gyrometer"},
+	{0x80,	"category_orientation"},
+	{0x81,	"type_orientation_compass_1d"},
+	{0x82,	"type_orientation_compass_2d"},
+	{0x83,	"type_orientation_compass_3d"},
+	{0x84,	"type_orientation_inclinometer_1d"},
+	{0x85,	"type_orientation_inclinometer_2d"},
+	{0x86,	"type_orientation_inclinometer_3d"},
+	{0x87,	"type_orientation_distance_1d"},
+	{0x88,	"type_orientation_distance_2d"},
+	{0x89,	"type_orientation_distance_3d"},
+	{0x8A,	"type_orientation_device_orientation"},
+	{0x8B,	"type_orientation_compass"},
+	{0x8C,	"type_orientation_inclinometer"},
+	{0x8D,	"type_orientation_distance"},
+	{0x90,	"category_scanner"},
+	{0x91,	"type_scanner_barcode"},
+	{0x92,	"type_scanner_rfid"},
+	{0x93,	"type_scanner_nfc"},
+	{0xA0,	"category_time"},
+	{0xA1,	"type_time_alarm"},
+	{0xA2,	"type_time_rtc"},
+	{0xE0,	"category_other"},
+	{0xE1,	"type_other_custom"},
+	{0xE2,	"type_other_generic"},
+	{0xE3,	"type_other_generic_enumerator"},
+	{0xE4,	"type_other_health_monitor"},
+	{0x0201,	"property_sensor_state"},
+	{0x0800,	"state_unknown_sel"},
+	{0x0801,	"state_ready_sel"},
+	{0x0802,	"state_not_available_sel"},
+	{0x0803,	"state_no_data_sel"},
+	{0x0804,	"state_initializing_sel"},
+	{0x0805,	"state_access_denied_sel"},
+	{0x0806,	"state_error_sel"},
+	{0x0202,	"event"},
+	{0x0810,	"event_unknown_sel"},
+	{0x0811,	"event_state_changed_sel"},
+	{0x0812,	"event_property_changed_sel"},
+	{0x0813,	"event_data_updated_sel"},
+	{0x0814,	"event_poll_response_sel"},
+	{0x0815,	"event_change_sensitivity_sel"},
+	{0x0816,	"event_max_reached_sel"},
+	{0x0817,	"event_min_reached_sel"},
+	{0x0818,	"event_high_threshold_cross_upward_sel"},
+	{0x0819,	"event_high_threshold_cross_downward_sel"},
+	{0x081A,	"event_low_threshold_cross_upward_sel"},
+	{0x081B,	"event_low_threshold_cross_downward_sel"},
+	{0x081C,	"event_zero_threshold_cross_upward_sel"},
+	{0x081D,	"event_zero_threshold_cross_downward_sel"},
+	{0x081E,	"event_period_exceeded_sel"},
+	{0x081F,	"event_frequency_exceeded_sel"},
+	{0x0820,	"event_complex_trigger_sel"},
+	{0x0300,	"property"},
+	{0x0301,	"property_friendly_name"},
+	{0x0302,	"property_persistent_unique_id"},
+	{0x0303,	"property_sensor_status"},
+	{0x0304,	"property_minimum_report_interval"},
+	{0x0305,	"property_sensor_manufacturer"},
+	{0x0306,	"property_sensor_model"},
+	{0x0307,	"property_sensor_serial_number"},
+	{0x0308,	"property_sensor_description"},
+	{0x0309,	"property_sensor_connection_type"},
+	{0x0830,	"property_connection_type_pc_integrated_sel"},
+	{0x0831,	"property_connection_type_pc_attached_sel"},
+	{0x0832,	"property_connection_type_pc_external_sel"},
+	{0x030A,	"property_sensor_device_path"},
+	{0x030B,	"property_hardware_revision"},
+	{0x030C,	"property_firmware_version"},
+	{0x030D,	"property_release_date"},
+	{0x030E,	"property_report_interval"},
+	{0x030F,	"property_change_sensitivity_abs"},
+	{0x0310,	"property_change_sensitivity_range_pct"},
+	{0x0311,	"property_change_sensitivity_rel_pct"},
+	{0x0312,	"property_accuracy"},
+	{0x0313,	"property_resolution"},
+	{0x0314,	"property_range_maximum"},
+	{0x0315,	"property_range_minimum"},
+	{0x0316,	"property_reporting_state"},
+	{0x0840,	"property_reporting_state_no_events_sel"},
+	{0x0841,	"property_reporting_state_all_events_sel"},
+	{0x0842,	"property_reporting_state_threshold_events_sel"},
+	{0x0843,	"property_reporting_state_no_events_wake_sel"},
+	{0x0844,	"property_reporting_state_all_events_wake_sel"},
+	{0x0845,	"property_reporting_state_threshold_events_wake_sel"},
+	{0x0317,	"property_sampling_rate"},
+	{0x0318,	"property_response_curve"},
+	{0x0319,	"property_power_state"},
+	{0x0850,	"property_power_state_undefined_sel"},
+	{0x0851,	"property_power_state_d0_full_power_sel"},
+	{0x0852,	"property_power_state_d1_low_power_sel"},
+	{0x0853,	"property_power_state_d2_standby_with_wake_sel"},
+	{0x0854,	"property_power_state_d3_sleep_with_wake_sel"},
+	{0x0855,	"property_power_state_d4_power_off_sel"},
+	{0x08E0,	"property_orientation_magnetometer_accuracy_low"},
+	{0x08E1,	"property_orientation_magnetometer_accuracy_medium"},
+	{0x08E2,	"property_orientation_magnetometer_accuracy_high"},
+	{0x0400,	"data_location"},
+	{0x0401,	"data_location_desired_accuracy"},
+	{0x0402,	"data_location_altitude_antenna_sealevel"},
+	{0x0403,	"data_location_differential_reference_station_id"},
+	{0x0404,	"data_location_altitide_elipsoid_error"},
+	{0x0405,	"data_location_altitide_elipsoid"},
+	{0x0406,	"data_location_altitude_sealevel_error"},
+	{0x0407,	"data_location_altitude_sealevel"},
+	{0x0408,	"data_location_dgps_data_age"},
+	{0x0409,	"data_location_error_radius"},
+	{0x040A,	"data_location_fix_quality"},
+	{0x0870,	"data_fix_quality_no_fix"},
+	{0x0871,	"data_fix_quality_gps"},
+	{0x0872,	"data_fix_quality_dgps"},
+	{0x040B,	"data_location_fix_type"},
+	{0x0880,	"data_fix_type_no_fix"},
+	{0x0881,	"data_fix_type_gps_sps_mode_fix_valid"},
+	{0x0882,	"data_fix_type_dgps_sps_mode_fix_valid"},
+	{0x0883,	"data_fix_type_gps_pps_mode_fix_valid"},
+	{0x0884,	"data_fix_type_real_time_kinematic"},
+	{0x0885,	"data_fix_type_float_rtk"},
+	{0x0886,	"data_fix_type_estimated_dead_reckoning"},
+	{0x0887,	"data_fix_type_manual_input_mode"},
+	{0x0888,	"data_fix_type_simulator_mode"},
+	{0x040C,	"data_location_geoidal_separation"},
+	{0x040D,	"data_location_gps_operation_mode"},
+	{0x0890,	"data_gps_op_mode_manual"},
+	{0x0891,	"data_gps_op_mode_automatic"},
+	{0x040E,	"data_location_gps_selection_mode"},
+	{0x08A0,	"data_gps_sel_mode_autonomous"},
+	{0x08A1,	"data_gps_sel_mode_dgps"},
+	{0x08A2,	"data_gps_sel_mode_estimated_dead_reckoning"},
+	{0x08A3,	"data_gps_sel_mode_manual_input"},
+	{0x08A4,	"data_gps_sel_mode_simulator"},
+	{0x08A5,	"data_gps_sel_mode_data_not_valid"},
+	{0x040F,	"data_location_gps_status"},
+	{0x08B0,	"data_gps_status_data_valid"},
+	{0x08B1,	"data_gps_status_data_not_valid"},
+	{0x0410,	"data_location_position_dilution_of_precision"},
+	{0x0411,	"data_location_horizontal_dilution_of_precision"},
+	{0x0412,	"data_location_vertical_dilution_of_precision"},
+	{0x0413,	"data_location_latitude"},
+	{0x0414,	"data_location_longitude"},
+	{0x0415,	"data_location_true_heading"},
+	{0x0416,	"data_location_magnetic_heading"},
+	{0x0417,	"data_location_magnetic_variation"},
+	{0x0418,	"data_location_speed"},
+	{0x0419,	"data_location_satellites_in_view"},
+	{0x041A,	"data_location_satellites_in_view_azimuth"},
+	{0x041B,	"data_location_satellites_in_view_elevation"},
+	{0x041C,	"data_location_satellites_in_view_id"},
+	{0x041D,	"data_location_satellites_in_view_prns"},
+	{0x041E,	"data_location_satellites_in_view_stn_ratio"},
+	{0x041F,	"data_location_satellites_used_count"},
+	{0x0420,	"data_location_satellites_used_prns"},
+	{0x0421,	"data_location_nmea_sentence"},
+	{0x0422,	"data_location_address_line_1"},
+	{0x0423,	"data_location_address_line_2"},
+	{0x0424,	"data_location_city"},
+	{0x0425,	"data_location_state_or_province"},
+	{0x0426,	"data_location_country_or_region"},
+	{0x0427,	"data_location_postal_code"},
+	{0x042A,	"property_location"},
+	{0x042B,	"property_location_desired_accuracy"},
+	{0x0860,	"desired_accuracy_default"},
+	{0x0861,	"desired_accuracy_high"},
+	{0x0862,	"desired_accuracy_medium"},
+	{0x0863,	"desired_accuracy_low"},
+	{0x0430,	"data_environmental"},
+	{0x0431,	"data_environmental_atmospheric_pressure"},
+	{0x0432,	"data_environmental_reference_pressure"},
+	{0x0433,	"data_environmental_relative_humidity"},
+	{0x0434,	"data_environmental_temperature"},
+	{0x0435,	"data_environmental_wind_direction"},
+	{0x0436,	"data_environmental_wind_speed"},
+	{0x0440,	"property_environmental"},
+	{0x0441,	"property_environmental_reference_pressure"},
+	{0x0450,	"data_motion"},
+	{0x0451,	"data_motion_state"},
+	{0x0452,	"data_motion_acceleration"},
+	{0x0453,	"data_motion_acceleration_x_axis"},
+	{0x0454,	"data_motion_acceleration_y_axis"},
+	{0x0455,	"data_motion_acceleration_z_axis"},
+	{0x0456,	"data_motion_angular_velocity"},
+	{0x0457,	"data_motion_angular_velocity_x_axis"},
+	{0x0458,	"data_motion_angular_velocity_y_axis"},
+	{0x0459,	"data_motion_angular_velocity_z_axis"},
+	{0x045A,	"data_motion_angular_position"},
+	{0x045B,	"data_motion_angular_position_x_axis"},
+	{0x045C,	"data_motion_angular_position_y_axis"},
+	{0x045D,	"data_motion_angular_position_z_axis"},
+	{0x045E,	"data_motion_speed"},
+	{0x045F,	"data_motion_intensity"},
+	{0x0470,	"data_orientation"},
+	{0x0471,	"data_orientation_magnetic_heading"},
+	{0x0472,	"data_orientation_magnetic_heading_x"},
+	{0x0473,	"data_orientation_magnetic_heading_y"},
+	{0x0474,	"data_orientation_magnetic_heading_z"},
+	{0x0475,	"data_orientation_compensated_magnetic_north"},
+	{0x0476,	"data_orientation_compensated_true_north"},
+	{0x0477,	"data_orientation_magnetic_north"},
+	{0x0478,	"data_orientation_true_north"},
+	{0x0479,	"data_orientation_distance"},
+	{0x047A,	"data_orientation_distance_x"},
+	{0x047B,	"data_orientation_distance_y"},
+	{0x047C,	"data_orientation_distance_z"},
+	{0x047D,	"data_orientation_distance_out_of_range"},
+	{0x047E,	"data_orientation_tilt"},
+	{0x047F,	"data_orientation_tilt_x"},
+	{0x0480,	"data_orientation_tilt_y"},
+	{0x0481,	"data_orientation_tilt_z"},
+	{0x0482,	"data_orientation_rotation_matrix"},
+	{0x0483,	"data_orientation_quaternion"},
+	{0x0484,	"data_orientation_magnetic_flux"},
+	{0x0485,	"data_orientation_magnetic_flux_x_axis"},
+	{0x0486,	"data_orientation_magnetic_flux_y_axis"},
+	{0x0487,	"data_orientation_magnetic_flux_z_axis"},
+	{0x0488,	"data_orientation_magnetometer_accuracy"},
+	{0x0490,	"data_mechanical"},
+	{0x0491,	"data_mechanical_boolean_switch_state"},
+	{0x0492,	"data_mechanical_boolean_switch_array_states"},
+	{0x0493,	"data_mechanical_multivalue_switch_value"},
+	{0x0494,	"data_mechanical_force"},
+	{0x0495,	"data_mechanical_absolute_pressure"},
+	{0x0496,	"data_mechanical_gauge_pressure"},
+	{0x0497,	"data_mechanical_strain"},
+	{0x0498,	"data_mechanical_weight"},
+	{0x04A0,	"property_mechanical"},
+	{0x04A1,	"property_mechanical_vibration_state"},
+	{0x04A2,	"data_mechanical_vibration_speed_forward"},
+	{0x04A3,	"data_mechanical_vibration_speed_backward"},
+	{0x04B0,	"data_biometric"},
+	{0x04B1,	"data_biometric_human_presence"},
+	{0x04B2,	"data_biometric_human_proximity_range"},
+	{0x04B3,	"data_biometric_human_proximity_out_of_range"},
+	{0x04B4,	"data_biometric_human_touch_state"},
+	{0x04D0,	"data_light"},
+	{0x04D1,	"data_light_illuminance"},
+	{0x04D2,	"data_light_color_temperature"},
+	{0x04D3,	"data_light_chromaticity"},
+	{0x04D4,	"data_light_chromaticity_x"},
+	{0x04D5,	"data_light_chromaticity_y"},
+	{0x04D6,	"data_light_consumer_ir_sentence_receive"},
+	{0x04E0,	"property_light"},
+	{0x04E1,	"property_light_consumer_ir_sentence_send"},
+	{0x04F0,	"data_scanner"},
+	{0x04F1,	"data_scanner_rfid_tag"},
+	{0x04F2,	"data_scanner_nfc_sentence_receive"},
+	{0x04F8,	"property_scanner"},
+	{0x04F9,	"property_scanner_nfc_sentence_send"},
+	{0x0500,	"data_electrical"},
+	{0x0501,	"data_electrical_capacitance"},
+	{0x0502,	"data_electrical_current"},
+	{0x0503,	"data_electrical_power"},
+	{0x0504,	"data_electrical_inductance"},
+	{0x0505,	"data_electrical_resistance"},
+	{0x0506,	"data_electrical_voltage"},
+	{0x0507,	"data_electrical_frequency"},
+	{0x0508,	"data_electrical_period"},
+	{0x0509,	"data_electrical_percent_of_range"},
+	{0x0520,	"data_time"},
+	{0x0521,	"data_time_year"},
+	{0x0522,	"data_time_month"},
+	{0x0523,	"data_time_day"},
+	{0x0524,	"data_time_day_of_week"},
+	{0x0525,	"data_time_hour"},
+	{0x0526,	"data_time_minute"},
+	{0x0527,	"data_time_second"},
+	{0x0528,	"data_time_millisecond"},
+	{0x0529,	"data_time_timestamp"},
+	{0x052A,	"data_time_julian_day_of_year"},
+	{0x0530,	"property_time"},
+	{0x0531,	"property_time_time_zone_offset_from_utc"},
+	{0x0532,	"property_time_time_zone_name"},
+	{0x0533,	"property_time_daylight_savings_time_observed"},
+	{0x0534,	"property_time_time_trim_adjustment"},
+	{0x0535,	"property_time_arm_alarm"},
+	{0x0540,	"data_custom"},
+	{0x0541,	"data_custom_usage"},
+	{0x0542,	"data_custom_boolean_array"},
+	{0x0543,	"data_custom_value"},
+	{0x0544,	"data_custom_value_1"},
+	{0x0545,	"data_custom_value_2"},
+	{0x0546,	"data_custom_value_3"},
+	{0x0547,	"data_custom_value_4"},
+	{0x0548,	"data_custom_value_5"},
+	{0x0549,	"data_custom_value_6"},
+	{0x054A,	"data_custom_value_7"},
+	{0x054B,	"data_custom_value_8"},
+	{0x054C,	"data_custom_value_9"},
+	{0x054D,	"data_custom_value_10"},
+	{0x054E,	"data_custom_value_11"},
+	{0x054F,	"data_custom_value_12"},
+	{0x0550,	"data_custom_value_13"},
+	{0x0551,	"data_custom_value_14"},
+	{0x0552,	"data_custom_value_15"},
+	{0x0553,	"data_custom_value_16"},
+	{0x0554,	"data_custom_value_17"},
+	{0x0555,	"data_custom_value_18"},
+	{0x0556,	"data_custom_value_19"},
+	{0x0557,	"data_custom_value_20"},
+	{0x0558,	"data_custom_value_21"},
+	{0x0559,	"data_custom_value_22"},
+	{0x055A,	"data_custom_value_23"},
+	{0x055B,	"data_custom_value_24"},
+	{0x055C,	"data_custom_value_25"},
+	{0x055D,	"data_custom_value_26"},
+	{0x055E,	"data_custom_value_27"},
+	{0x055F,	"data_custom_value_28"},
+	{0x0560,	"data_generic"},
+	{0x0561,	"data_generic_guid_or_propertykey"},
+	{0x0562,	"data_generic_category_guid"},
+	{0x0563,	"data_generic_type_guid"},
+	{0x0564,	"data_generic_event_propertykey"},
+	{0x0565,	"data_generic_property_propertykey"},
+	{0x0566,	"data_generic_datafield_propertykey"},
+	{0x0567,	"data_generic_event"},
+	{0x0568,	"data_generic_property"},
+	{0x0569,	"data_generic_datafield"},
+	{0x056A,	"data_enumerator_table_row_index"},
+	{0x056B,	"data_enumerator_table_row_count"},
+	{0x056C,	"data_generic_guid_or_propertykey_kind"},
+	{0x08D0,	"gorpk_kind_category"},
+	{0x08D1,	"gorpk_kind_type"},
+	{0x08D2,	"gorpk_kind_event"},
+	{0x08D3,	"gorpk_kind_property"},
+	{0x08D4,	"gorpk_kind_datafield"},
+	{0x056D,	"data_generic_guid"},
+	{0x056E,	"data_generic_propertykey"},
+	{0x056F,	"data_generic_top_level_collection_id"},
+	{0x0570,	"data_generic_report_id"},
+	{0x0571,	"data_generic_report_item_position_index"},
+	{0x0572,	"data_generic_firmware_vartype"},
+	{0x0900,	"firmware_vartype_vt_null"},
+	{0x0901,	"firmware_vartype_vt_bool"},
+	{0x0902,	"firmware_vartype_vt_ui1"},
+	{0x0903,	"firmware_vartype_vt_i1"},
+	{0x0904,	"firmware_vartype_vt_ui2"},
+	{0x0905,	"firmware_vartype_vt_i2"},
+	{0x0906,	"firmware_vartype_vt_ui4"},
+	{0x0907,	"firmware_vartype_vt_i4"},
+	{0x0908,	"firmware_vartype_vt_ui8"},
+	{0x0909,	"firmware_vartype_vt_i8"},
+	{0x090A,	"firmware_vartype_vt_r4"},
+	{0x090B,	"firmware_vartype_vt_r8"},
+	{0x090C,	"firmware_vartype_vt_wstr"},
+	{0x090D,	"firmware_vartype_vt_str"},
+	{0x090E,	"firmware_vartype_vt_clsid"},
+	{0x090F,	"firmware_vartype_vt_vector_vt_ui1"},
+	{0x0910,	"firmware_vartype_vt_f16e0"},
+	{0x0911,	"firmware_vartype_vt_f16e1"},
+	{0x0912,	"firmware_vartype_vt_f16e2"},
+	{0x0913,	"firmware_vartype_vt_f16e3"},
+	{0x0914,	"firmware_vartype_vt_f16e4"},
+	{0x0915,	"firmware_vartype_vt_f16e5"},
+	{0x0916,	"firmware_vartype_vt_f16e6"},
+	{0x0917,	"firmware_vartype_vt_f16e7"},
+	{0x0918,	"firmware_vartype_vt_f16e8"},
+	{0x0919,	"firmware_vartype_vt_f16e9"},
+	{0x091A,	"firmware_vartype_vt_f16ea"},
+	{0x091B,	"firmware_vartype_vt_f16eb"},
+	{0x091C,	"firmware_vartype_vt_f16ec"},
+	{0x091D,	"firmware_vartype_vt_f16ed"},
+	{0x091E,	"firmware_vartype_vt_f16ee"},
+	{0x091F,	"firmware_vartype_vt_f16ef"},
+	{0x0920,	"firmware_vartype_vt_f32e0"},
+	{0x0921,	"firmware_vartype_vt_f32e1"},
+	{0x0922,	"firmware_vartype_vt_f32e2"},
+	{0x0923,	"firmware_vartype_vt_f32e3"},
+	{0x0924,	"firmware_vartype_vt_f32e4"},
+	{0x0925,	"firmware_vartype_vt_f32e5"},
+	{0x0926,	"firmware_vartype_vt_f32e6"},
+	{0x0927,	"firmware_vartype_vt_f32e7"},
+	{0x0928,	"firmware_vartype_vt_f32e8"},
+	{0x0929,	"firmware_vartype_vt_f32e9"},
+	{0x092A,	"firmware_vartype_vt_f32ea"},
+	{0x092B,	"firmware_vartype_vt_f32eb"},
+	{0x092C,	"firmware_vartype_vt_f32ec"},
+	{0x092D,	"firmware_vartype_vt_f32ed"},
+	{0x092E,	"firmware_vartype_vt_f32ee"},
+	{0x092F,	"firmware_vartype_vt_f32ef"},
+	{0x0573,	"data_generic_unit_of_measure"},
+	{0x0940,	"generic_unit_not_specified"},
+	{0x0941,	"generic_unit_lux"},
+	{0x0942,	"generic_unit_degrees_kelvin"},
+	{0x0943,	"generic_unit_degrees_celsius"},
+	{0x0944,	"generic_unit_pascal"},
+	{0x0945,	"generic_unit_newton"},
+	{0x0946,	"generic_unit_meters_per_second"},
+	{0x0947,	"generic_unit_kilogram"},
+	{0x0948,	"generic_unit_meter"},
+	{0x0949,	"generic_unit_meters_per_sec_sqrd"},
+	{0x094A,	"generic_unit_farad"},
+	{0x094B,	"generic_unit_ampere"},
+	{0x094C,	"generic_unit_watt"},
+	{0x094D,	"generic_unit_henry"},
+	{0x094E,	"generic_unit_ohm"},
+	{0x094F,	"generic_unit_volt"},
+	{0x0950,	"generic_unit_hertz"},
+	{0x0951,	"generic_unit_bar"},
+	{0x0952,	"generic_unit_degrees_anti_clockwise"},
+	{0x0953,	"generic_unit_degrees_clockwise"},
+	{0x0954,	"generic_unit_degrees"},
+	{0x0955,	"generic_unit_degrees_per_second"},
+	{0x0956,	"generic_unit_degrees_per_sec_sqrd"},
+	{0x0957,	"generic_unit_knot"},
+	{0x0958,	"generic_unit_percent"},
+	{0x0959,	"generic_unit_second"},
+	{0x095A,	"generic_unit_millisecond"},
+	{0x095B,	"generic_unit_g"},
+	{0x095C,	"generic_unit_bytes"},
+	{0x095D,	"generic_unit_milligauss"},
+	{0x095E,	"generic_unit_bits"},
+	{0x0574,	"data_generic_unit_exponent"},
+	{0x0970,	"generic_exponent_0"},
+	{0x0971,	"generic_exponent_1"},
+	{0x0972,	"generic_exponent_2"},
+	{0x0973,	"generic_exponent_3"},
+	{0x0974,	"generic_exponent_4"},
+	{0x0975,	"generic_exponent_5"},
+	{0x0976,	"generic_exponent_6"},
+	{0x0977,	"generic_exponent_7"},
+	{0x0978,	"generic_exponent_8"},
+	{0x0979,	"generic_exponent_9"},
+	{0x097A,	"generic_exponent_a"},
+	{0x097B,	"generic_exponent_b"},
+	{0x097C,	"generic_exponent_c"},
+	{0x097D,	"generic_exponent_d"},
+	{0x097E,	"generic_exponent_e"},
+	{0x097F,	"generic_exponent_f"},
+	{0x0575,	"data_generic_report_size"},
+	{0x0576,	"data_generic_report_count"},
+	{0x0580,	"property_generic"},
+	{0x0581,	"property_enumerator_table_row_index"},
+	{0x0582,	"property_enumerator_table_row_count"},
+	{0,	0}
+};
+
+static const char* modifiers[16] = {"none", "chg_sensitivity_abs", "max", "min", "accuracy", "resolution", "thres_high", "thres_low",
+	"calibration_offset", "calibration_multiplier", "report_interval", "freq_max", "period_max", "chg_sensitivity_percent_range",
+	"chg_sensitivity_percent_rel", "custom"};
+
+
+#endif /* _HID_STRINGS_DEF_H_ */
+
diff --git a/drivers/misc/heci/hw-ish-regs.h b/drivers/misc/heci/hw-ish-regs.h
new file mode 100644
index 0000000..c2aa828
--- /dev/null
+++ b/drivers/misc/heci/hw-ish-regs.h
@@ -0,0 +1,116 @@
+/*
+ * ISH registers definitions
+ *
+ * Copyright (c) 2012-2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _HECI_ISH_REGS_H_
+#define _HECI_ISH_REGS_H_
+
+
+/* IPC PCI Offsets and sizes */
+#define IPC_REG_BASE             0x0000 /* Ish IPC Base Address */
+#define IPC_REG_PISR             (IPC_REG_BASE + 0x00)  /*Peripheral Interrupt Status Register */
+#define IPC_REG_PIMR             (IPC_REG_BASE + 0x04)  /* Peripheral Interrupt Mask Register */
+#define IPC_REG_ISH_HOST_FWSTS   (IPC_REG_BASE + 0x34)  /* ISH Host Firmware status Register */
+#define IPC_REG_HOST_COMM        (IPC_REG_BASE + 0x38)  /* Host Communication Register */
+#define IPC_REG_ISH_RST          (IPC_REG_BASE + 0x44)  /* Reset register */
+
+#define IPC_REG_HOST2ISH_DRBL    (IPC_REG_BASE + 0x48)  /*Inbound doorbell register Host to ISH */
+#define IPC_REG_ISH2HOST_DRBL    (IPC_REG_BASE + 0x54)  /*Outbound doorbell register ISH to Host */
+#define IPC_REG_ISH2HOST_MSG     (IPC_REG_BASE + 0x60)  /* ISH to HOST message registers */
+#define IPC_REG_HOST2ISH_MSG     (IPC_REG_BASE + 0xE0)  /* HOST to ISH message registers */
+
+#define	IPC_REG_ISH_RMP2	 (IPC_REG_BASE + 0x368)	/* REMAP2 to enable DMA (D3 RCR) */
+
+/* register bits - HISR */
+
+#define IPC_INT_HOST2ISH_BIT            (1<<0)  /* bit corresponds HOST2ISH interrupt in PISR and PIMR registers */
+#define IPC_INT_ISH2HOST_BIT            (1<<3)  /* bit corresponds ISH2HOST interrupt in PISR and PIMR registers */
+#define IPC_INT_ISH2HOST_CLR_MASK_BIT   (1<<11) /* bit corresponds ISH2HOST busy clear interrupt in PIMR register */
+
+#define IPC_INT_ISH2HOST_CLR_OFFS       (0)  /* offset of ISH2HOST busy clear interrupt in IPC_BUSY_CLR register */
+
+#define IPC_INT_ISH2HOST_CLR_BIT        (1<<IPC_INT_ISH2HOST_CLR_OFFS)  /* bit corresponds ISH2HOST busy clear interrupt in IPC_BUSY_CLR register */
+
+#define IPC_DRBL_BUSY_OFFS              (31)
+#define IPC_DRBL_BUSY_BIT               (1<<IPC_DRBL_BUSY_OFFS) /* bit corresponds busy bit in doorbell registers */
+
+#define	IPC_HOST_OWNS_MSG_OFFS		(30)
+#define	IPC_HOST_OWNS_MSG_BIT		(1<<IPC_HOST_OWNS_MSG_OFFS)	/* A0: bit means that host owns MSGnn registers and is reading them. ISH may not write to them */
+
+#define IPC_HOST_READY_OFFS		(7)
+#define IPC_HOST_READY_BIT              (1<<IPC_HOST_READY_OFFS) /* bit corresponds host ready bit in Host Status Register (HOST_COMM) */
+
+#define IPC_ISH_READY_OFFS              (1) /* bit corresponds host ready bit in ISH Status Register */
+#define IPC_ISH_READY_BIT               (1<<IPC_ISH_READY_OFFS)
+
+#define	IPC_HOSTCOMM_INT_EN_OFFS	(31)
+#define	IPC_HOSTCOMM_INT_EN_BIT		(1<<IPC_HOSTCOMM_INT_EN_OFFS)
+
+/* as of now, both Host and ISH have ILUP at bit 0 */
+#define IPC_ILUP_OFFS					(0)
+#define IPC_ILUP_BIT					(1<<IPC_ILUP_OFFS) /* bit corresponds host ready bit in both status registers */
+
+#define	IPC_RMP2_DMA_ENABLED		0x1	/* Value to enable DMA, per D3 RCR */
+
+#define IPC_MSG_MAX_SIZE                0x80
+
+
+#define IPC_HEADER_LENGTH_MASK          (0x03FF)
+#define IPC_HEADER_PROTOCOL_MASK        (0x0F)
+#define IPC_HEADER_MNG_CMD_MASK         (0x0F)
+
+#define IPC_HEADER_LENGTH_OFFSET         0
+#define IPC_HEADER_PROTOCOL_OFFSET      10
+#define IPC_HEADER_MNG_CMD_OFFSET       16
+
+#define IPC_HEADER_GET_LENGTH(drbl_reg)      (((drbl_reg) >> IPC_HEADER_LENGTH_OFFSET)&IPC_HEADER_LENGTH_MASK)
+#define IPC_HEADER_GET_PROTOCOL(drbl_reg)    (((drbl_reg) >> IPC_HEADER_PROTOCOL_OFFSET)&IPC_HEADER_PROTOCOL_MASK)
+#define IPC_HEADER_GET_MNG_CMD(drbl_reg)     (((drbl_reg) >> IPC_HEADER_MNG_CMD_OFFSET)&IPC_HEADER_MNG_CMD_MASK)
+
+#define IPC_IS_BUSY(drbl_reg)                (((drbl_reg)&IPC_DRBL_BUSY_BIT) == ((u32)IPC_DRBL_BUSY_BIT))
+#define IPC_SET_BUSY(drbl_reg)               ((drbl_reg) | (IPC_DRBL_BUSY_BIT))
+#define IPC_INT_FROM_ISH_TO_HOST(drbl_reg)   (((drbl_reg)&IPC_INT_ISH2HOST_BIT) == ((u32)IPC_INT_ISH2HOST_BIT))
+
+#define IPC_BUILD_HEADER(length, protocol, busy) (((busy)<<IPC_DRBL_BUSY_OFFS) | ((protocol) << IPC_HEADER_PROTOCOL_OFFSET) | ((length)<<IPC_HEADER_LENGTH_OFFSET))
+#define IPC_BUILD_MNG_MSG(cmd, length)			 		(((1)<<IPC_DRBL_BUSY_OFFS)|((IPC_PROTOCOL_MNG)<<IPC_HEADER_PROTOCOL_OFFSET)|((cmd)<<IPC_HEADER_MNG_CMD_OFFSET)|((length)<<IPC_HEADER_LENGTH_OFFSET))
+
+
+#define IPC_SET_HOST_READY(host_status)                 ((host_status) |= (IPC_HOST_READY_BIT))
+#define IPC_SET_HOST_ILUP(host_status)					((host_status) |= (IPC_ILUP_BIT))
+#define IPC_CLEAR_HOST_READY(host_status)               ((host_status) ^= (IPC_HOST_READY_BIT))
+#define IPC_CLEAR_HOST_ILUP(host_status)                ((host_status) ^= (IPC_ILUP_BIT))
+
+/* todo - temp until PIMR HW ready */
+#define IPC_HOST_BUSY_READING_OFFS				(6)
+#define IPC_HOST_BUSY_READING_BIT              (1<<IPC_HOST_BUSY_READING_OFFS) /* bit corresponds host ready bit in Host Status Register (HOST_COMM) */
+#define IPC_SET_HOST_BUSY_READING(host_status)          ((host_status) |= (IPC_HOST_BUSY_READING_BIT))
+#define IPC_CLEAR_HOST_BUSY_READING(host_status)               ((host_status) ^= (IPC_HOST_BUSY_READING_BIT))
+
+
+#define IPC_IS_ISH_HECI_READY(ish_status)               (((ish_status)&IPC_ISH_READY_BIT) == ((u32)IPC_ISH_READY_BIT))
+#define IPC_IS_ISH_ILUP(ish_status)						(((ish_status)&IPC_ILUP_BIT) == ((u32)IPC_ILUP_BIT))
+
+
+#define IPC_PROTOCOL_HECI               1
+#define IPC_PROTOCOL_MNG                3
+
+#define MNG_RX_CMPL_ENABLE              0
+#define MNG_RX_CMPL_DISABLE             1
+#define MNG_RX_CMPL_INDICATION          2
+#define MNG_RESET_NOTIFY				3
+#define MNG_RESET_NOTIFY_ACK			4
+#define MNG_ILLEGAL_CMD    				0xFF
+
+#endif /* _HECI_ISH_REGS_H_ */
+
diff --git a/drivers/misc/heci/hw-ish.c b/drivers/misc/heci/hw-ish.c
new file mode 100644
index 0000000..e04b8bd
--- /dev/null
+++ b/drivers/misc/heci/hw-ish.c
@@ -0,0 +1,699 @@
+/*
+ * H/W layer of HECI provider device (ISH)
+ *
+ * Copyright (c) 2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/pci.h>
+#include <linux/sched.h>
+#include "client.h"
+#include "hw-ish.h"
+#include "utils.h"
+#include "heci_dev.h"
+#include "hbm.h"
+#include <linux/spinlock.h>
+
+#ifdef dev_dbg
+#undef dev_dbg
+#endif
+static void no_dev_dbg(void *v, char *s, ...)
+{
+}
+/*#define dev_dbg dev_err */
+#define dev_dbg no_dev_dbg
+
+void g_ish_print_log(char *format, ...);
+
+#include <linux/delay.h>
+
+int write_ipc_from_queue(struct heci_device *dev);
+static int	ipc_send_mng_msg(struct heci_device *dev, uint32_t msg_code, void *msg, size_t size);
+static int	ipc_send_heci_msg(struct heci_device *dev, struct heci_msg_hdr *hdr, void *msg, void(*ipc_send_compl)(void *),void *ipc_send_compl_prm);
+static u32 ish_read_hdr(const struct heci_device *dev);
+
+/**
+ * ish_reg_read - reads 32bit data from the ISH BAR
+ *
+ * @dev: the device structure
+ * @offset: offset from which to read the data
+ */
+static inline u32 ish_reg_read(const struct heci_device *dev, unsigned long offset)
+{
+	struct ish_hw *hw = to_ish_hw(dev);
+	return readl(hw->mem_addr + offset);
+}
+
+/**
+ * ish_reg_write - Writes 32bit data to the ISH BAR
+ *
+ * @dev: the device structure
+ * @offset: offset from which to write the data
+ * @value: the byte to write
+ */
+static inline void ish_reg_write(struct heci_device *dev, unsigned long offset, u32 value)
+{
+	struct ish_hw *hw = to_ish_hw(dev);
+	writel(value, hw->mem_addr + offset);
+}
+
+static inline u32 ish_read_fw_sts_reg(struct heci_device *dev)
+{
+	return ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);
+}
+
+bool check_generated_interrupt(struct heci_device *dev)
+{
+	bool interrupt_generated = true;
+	u32 pisr_val = 0;
+
+	pisr_val = ish_reg_read(dev, IPC_REG_PISR);
+	interrupt_generated = IPC_INT_FROM_ISH_TO_HOST(pisr_val);
+
+	return interrupt_generated;
+}
+
+
+u32 ipc_output_payload_read(struct heci_device *dev, unsigned long index)
+{
+	return ish_reg_read(dev, IPC_REG_ISH2HOST_MSG +	(index * sizeof(u32)));
+}
+
+/**
+ * ish_read - reads a message from heci device.
+ *
+ * @dev: the device structure
+ * @buffer: message buffer will be written
+ * @buffer_length: message size will be read
+ */
+static int ish_read(struct heci_device *dev, unsigned char *buffer, unsigned long buffer_length)
+{
+	u32	i;
+	u32	*r_buf = (u32 *)buffer;
+	u32	msg_offs;
+
+	dev_dbg(&dev->pdev->dev, "buffer-length = %lu buf[0]0x%08X\n",
+		buffer_length, ipc_output_payload_read(dev, 0));
+
+	msg_offs = IPC_REG_ISH2HOST_MSG + sizeof(struct heci_msg_hdr);
+	for (i = 0; i < buffer_length; i += sizeof(u32))
+		*r_buf++ = ish_reg_read(dev, msg_offs + i);
+
+	return 0;
+}
+
+/**
+ * ish_is_input_ready - check if ISH is ready for receiving data
+ *
+ * @dev: the device structure
+ */
+static bool ish_is_input_ready(struct heci_device *dev)
+{
+	u32 doorbell_val;
+
+	doorbell_val = ish_reg_read(dev, IPC_REG_HOST2ISH_DRBL);
+	return !IPC_IS_BUSY(doorbell_val);
+}
+
+/**
+ * ish_intr_enable - enables heci device interrupts
+ *
+ * @dev: the device structure
+ */
+void ish_intr_enable(struct heci_device *dev)
+{
+/*	u32 host_status = 0; */
+
+	dev_dbg(&dev->pdev->dev, "ish_intr_enable\n");
+	if (dev->pdev->revision == REVISION_ID_CHT_A0 || (dev->pdev->revision & REVISION_ID_SI_MASK) == REVISION_ID_CHT_A0_SI)
+		ish_reg_write(dev, IPC_REG_HOST_COMM, 0x81);
+	else if (dev->pdev->revision == REVISION_ID_CHT_B0 || (dev->pdev->revision & REVISION_ID_SI_MASK) == REVISION_ID_CHT_Bx_SI) {
+		uint32_t	host_comm_val;
+
+		host_comm_val = ish_reg_read(dev, IPC_REG_HOST_COMM);
+		host_comm_val |= IPC_HOSTCOMM_INT_EN_BIT | 0x81;
+		ish_reg_write(dev, IPC_REG_HOST_COMM, host_comm_val);
+	}
+}
+
+/**
+ * ish_intr_disable - disables heci device interrupts
+ *
+ * @dev: the device structure
+ */
+void ish_intr_disable(struct heci_device *dev)
+{
+	dev_dbg(&dev->pdev->dev, "ish_intr_disable\n");
+	if (dev->pdev->revision == REVISION_ID_CHT_A0 || (dev->pdev->revision & REVISION_ID_SI_MASK) == REVISION_ID_CHT_A0_SI)
+		/*ish_reg_write(dev, IPC_REG_HOST_COMM, 0xC1)*/;
+	else if (dev->pdev->revision == REVISION_ID_CHT_B0 || (dev->pdev->revision & REVISION_ID_SI_MASK) == REVISION_ID_CHT_Bx_SI) {
+		uint32_t	host_comm_val;
+
+		host_comm_val = ish_reg_read(dev, IPC_REG_HOST_COMM);
+		host_comm_val &= ~IPC_HOSTCOMM_INT_EN_BIT;
+		host_comm_val |= 0xC1;
+		ish_reg_write(dev, IPC_REG_HOST_COMM, host_comm_val);
+	}
+}
+
+void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr);
+	
+/*
+ * BH processing work function (instead of thread handler)
+ */
+static void	bh_hbm_work_fn(struct work_struct *work)
+{
+	unsigned long	flags;
+	struct heci_device	*dev;
+	unsigned char	hbm[IPC_PAYLOAD_SIZE];
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): work=%p +++\n", __func__, work);
+	dev = container_of(work, struct heci_device, bh_hbm_work);
+	spin_lock_irqsave(&dev->rd_msg_spinlock, flags);
+	if (dev->rd_msg_fifo_head != dev->rd_msg_fifo_tail) {
+		memcpy(hbm, dev->rd_msg_fifo + dev->rd_msg_fifo_head, IPC_PAYLOAD_SIZE);
+		dev->rd_msg_fifo_head = (dev->rd_msg_fifo_head + IPC_PAYLOAD_SIZE) % (RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE);
+		spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
+		heci_hbm_dispatch(dev, (struct heci_bus_message *)hbm);
+	} else {
+		spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
+	}
+	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
+}
+/*#####################################################*/
+
+/*
+ * Got msg with IPC (and upper protocol) header
+ * and add it to the device Tx-to-write list
+ * then try to send the first IPC waiting msg (if DRBL is cleared)
+ * RETURN VALUE:	negative -  fail (means free links list is empty, or msg too long)
+ *			0 -  succeed
+ */
+static int write_ipc_to_queue(struct heci_device *dev, void(*ipc_send_compl)(void *),void *ipc_send_compl_prm, unsigned char *msg, int length)
+{
+	struct wr_msg_ctl_info *ipc_link;
+	unsigned long   flags;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++ length=%u\n", __func__, length);
+	g_ish_print_log(KERN_ALERT "%s(): +++ length=%u\n", __func__, length);
+	if (length > IPC_FULL_MSG_SIZE)
+		return -EMSGSIZE;
+
+	spin_lock_irqsave(&dev->wr_processing_spinlock, flags);
+	if (list_empty(&dev->wr_free_list_head.link)) {
+		spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
+		return -ENOMEM;
+	}
+	ipc_link = list_entry(dev->wr_free_list_head.link.next, struct wr_msg_ctl_info, link);
+	list_del_init(&ipc_link->link);
+
+	ipc_link->ipc_send_compl = ipc_send_compl;
+	ipc_link->ipc_send_compl_prm = ipc_send_compl_prm;
+	ipc_link->length = length;
+	memcpy(ipc_link->inline_data, msg, length);
+
+	list_add_tail(&ipc_link->link, &dev->wr_processing_list_head.link);
+	spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
+
+	write_ipc_from_queue(dev);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): --- \n", __func__);
+	return 0;
+}
+
+/* check if DRBL is cleared. if it is - write the first IPC msg,
+ * then call the callback function (if it isn't NULL)
+ */
+int write_ipc_from_queue(struct heci_device *dev)
+{
+	u32	doorbell_val;
+	unsigned long length;	
+	unsigned long rem;
+	u32	*r_buf;
+	int i;
+	struct wr_msg_ctl_info	*ipc_link;
+	u32	reg_addr;
+	unsigned long	flags;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	g_ish_print_log("%s(): +++\n", __func__);
+	if (!ish_is_input_ready(dev)) {
+		ISH_DBG_PRINT(KERN_ALERT "%s(): --- EBUSY\n", __func__);
+		return -EBUSY;
+	}
+
+	spin_lock_irqsave(&dev->wr_processing_spinlock, flags);
+	/* if empty list - return 0; may happen, as RX_COMPLETE handler doesn't check list emptiness */
+	if (list_empty(&dev->wr_processing_list_head.link)) {
+		spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
+		ISH_DBG_PRINT(KERN_ALERT "%s(): --- empty\n", __func__);
+		g_ish_print_log(KERN_ALERT "%s(): --- empty\n", __func__);
+		return	0;
+	}
+
+	ipc_link = list_entry(dev->wr_processing_list_head.link.next, struct wr_msg_ctl_info, link);
+	length = ipc_link->length - sizeof(u32);
+	/*first 4 bytes of the data is the doorbell value (IPC header)*/
+	doorbell_val = *(u32 *)ipc_link->inline_data;
+	r_buf = (u32 *)(ipc_link->inline_data + sizeof(u32));
+
+	for (i = 0, reg_addr = IPC_REG_HOST2ISH_MSG; i < length >> 2; i++, reg_addr += 4)
+		ish_reg_write(dev, reg_addr, r_buf[i]);
+
+	rem = length & 0x3;
+	if (rem > 0) {
+		u32 reg = 0;
+		memcpy(&reg, &r_buf[length >> 2], rem);
+		ish_reg_write(dev, reg_addr, reg);
+	}
+
+	ish_reg_write(dev, IPC_REG_HOST2ISH_DRBL, doorbell_val);
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): in msg. registers: %08X ! %08X %08X %08X %08X... hostcomm reg: %08X\n", __func__, ish_reg_read(dev, IPC_REG_HOST2ISH_DRBL), ish_reg_read(dev, IPC_REG_HOST2ISH_MSG), ish_reg_read(dev, IPC_REG_HOST2ISH_MSG+4), ish_reg_read(dev, IPC_REG_HOST2ISH_MSG+8), ish_reg_read(dev, IPC_REG_HOST2ISH_MSG+0xC), ish_reg_read(dev, IPC_REG_HOST_COMM));
+	g_ish_print_log(KERN_ALERT "%s(): in msg. registers: %08X ! %08X %08X %08X %08X... hostcomm reg: %08X\n", __func__, ish_reg_read(dev, IPC_REG_HOST2ISH_DRBL), ish_reg_read(dev, IPC_REG_HOST2ISH_MSG), ish_reg_read(dev, IPC_REG_HOST2ISH_MSG+4), ish_reg_read(dev, IPC_REG_HOST2ISH_MSG+8), ish_reg_read(dev, IPC_REG_HOST2ISH_MSG+0xC), ish_reg_read(dev, IPC_REG_HOST_COMM));
+
+
+	if (ipc_link->ipc_send_compl)
+		ipc_link->ipc_send_compl(ipc_link->ipc_send_compl_prm);
+	list_del_init(&ipc_link->link);
+	list_add_tail(&ipc_link->link, &dev->wr_free_list_head.link);
+	spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): --- written %lu bytes [%08X ! %08X %08X %08X %08X...]\n", __func__, length, *(u32 *)ipc_link->inline_data, r_buf[0], r_buf[1], r_buf[2], r_buf[3]);
+	g_ish_print_log(KERN_ALERT "%s(): --- written %lu bytes [%08X ! %08X %08X %08X %08X...]\n", __func__, length, *(u32 *)ipc_link->inline_data, r_buf[0], r_buf[1], r_buf[2], r_buf[3]);
+	return 0;
+}
+
+/*#####################################################*/
+
+static int	ish_fw_reset_handler(struct heci_device *dev)
+{
+	uint32_t	reset_id;
+
+	/* Read reset ID */
+	reset_id = ish_reg_read(dev, IPC_REG_ISH2HOST_MSG) & 0xFFFF;
+
+	/* Handle FW-initiated reset */
+	dev->dev_state = HECI_DEV_RESETTING;
+
+	/* Clear HOST2ISH.ILUP (what's it?) */
+	/*ish_clr_host_rdy(dev);*/
+
+	/* Handle ISH reset against upper layers */
+	heci_bus_remove_all_clients(dev);			/* Remove all client devices */
+
+	/* Send RESET_NOTIFY_ACK (with reset_id) */
+/*#####################################*/
+	if (!ish_is_input_ready(dev))
+		timed_wait_for_timeout(WAIT_FOR_SEND_SLICE, ish_is_input_ready(dev), (2 * HZ));
+
+	/* ISH is dead (?) */
+	if (!ish_is_input_ready(dev)) {
+		return	-EPIPE;
+	} else {
+		/* Set HOST2ISH.ILUP. Apparently we need this BEFORE sending RESET_NOTIFY_ACK - FW will be checking for it */
+		ish_set_host_rdy(dev);
+		ipc_send_mng_msg(dev, MNG_RESET_NOTIFY_ACK, &reset_id, sizeof(uint32_t));
+	}
+/*####################################*/
+
+	/* Wait for ISH'es ILUP and HECI_READY */
+	timed_wait_for_timeout(WAIT_FOR_SEND_SLICE, ish_hw_is_ready(dev), (2 * HZ));
+	if (!ish_hw_is_ready(dev)) {
+		/* ISH is dead */
+		uint32_t	ish_status = ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);
+		printk(KERN_ERR "[heci-ish]: completed reset sequence, ISH is dead (FWSTS = %08X)\n", ish_status);
+		return -ENODEV;
+	}
+
+	return	0;
+}
+
+struct work_struct	fw_reset_work;
+struct heci_device	*heci_dev;
+
+static void	fw_reset_work_fn(struct work_struct *unused)
+{
+	int	rv;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	rv = ish_fw_reset_handler(heci_dev);
+	if (!rv) {
+		/* ISH is ILUP & HECI-ready. Restart HECI */
+		heci_dev->recvd_hw_ready = 1;
+		if (waitqueue_active(&heci_dev->wait_hw_ready))
+			wake_up(&heci_dev->wait_hw_ready);
+
+		heci_dev->dev_state = HECI_DEV_INIT_CLIENTS;
+		heci_dev->hbm_state = HECI_HBM_START;
+		heci_hbm_start_req(heci_dev);
+		ISH_DBG_PRINT(KERN_ALERT "%s(): after heci_hbm_start_req()\n", __func__);
+	
+	} else
+		printk(KERN_ERR "[heci-ish]: FW reset failed (%d)\n", rv);
+}
+
+/*
+ *	Receive and process IPC management messages
+ *
+ *	NOTE: Any other mng command than reset_notify and reset_notify_ack won't wake BH handler
+ */
+static void	recv_ipc(struct heci_device *dev, uint32_t doorbell_val)
+{
+	uint32_t	mng_cmd;
+
+	mng_cmd = IPC_HEADER_GET_MNG_CMD(doorbell_val);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): handled IPC mng_cmd=%08X\n", __func__, mng_cmd);
+
+	switch (mng_cmd) {
+	default:
+		break;
+
+	case MNG_RX_CMPL_INDICATION:
+		ISH_DBG_PRINT(KERN_ALERT "%s(): RX_COMPLETE -- IPC_REG_ISH2HOST_MSG[0] = %08X\n", __func__, ish_reg_read(dev, IPC_REG_ISH2HOST_MSG));
+		write_ipc_from_queue(dev);
+		break;
+
+	case MNG_RESET_NOTIFY:
+		ISH_DBG_PRINT(KERN_ALERT "%s(): MNG_RESET_NOTIFY\n", __func__);
+		if (!heci_dev) {
+			heci_dev = dev;
+			INIT_WORK(&fw_reset_work, fw_reset_work_fn);
+		}
+		schedule_work(&fw_reset_work);
+		break;
+
+	case MNG_RESET_NOTIFY_ACK:
+		ISH_DBG_PRINT(KERN_ALERT "%s(): MNG_RESET_NOTIFY_ACK\n", __func__);
+		dev->recvd_hw_ready = 1;
+		if (waitqueue_active(&dev->wait_hw_ready))
+			wake_up(&dev->wait_hw_ready);
+		break;
+	}
+}
+
+
+
+
+/**
+ * ish_irq_handler - ISR of the HECI device
+ *
+ * @irq: irq number
+ * @dev_id: pointer to the device structure
+ *
+ * returns irqreturn_t
+ */
+irqreturn_t ish_irq_handler(int irq, void *dev_id)
+{
+	struct heci_device *dev = dev_id;
+	uint32_t	doorbell_val;
+	struct heci_msg_hdr	*heci_hdr;
+	bool interrupt_generated;
+	u32 pisr_val;
+	u32	msg_hdr;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): irq=%d +++\n", __func__, irq);
+	g_ish_print_log(KERN_ALERT "%s(): irq=%d +++\n", __func__, irq);
+
+	/* Check that it's interrupt from ISH (may be shared) */
+	pisr_val = ish_reg_read(dev, IPC_REG_PISR);
+	interrupt_generated = IPC_INT_FROM_ISH_TO_HOST(pisr_val);
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): interrupt_generated=%d [PIMR=%08X]\n", __func__, (int)interrupt_generated, ish_reg_read(dev, IPC_REG_PIMR));
+	g_ish_print_log(KERN_ALERT "%s(): interrupt_generated=%d [PIMR=%08X]\n", __func__, (int)interrupt_generated, ish_reg_read(dev, IPC_REG_PIMR));
+	if (!interrupt_generated)
+		return IRQ_NONE;
+
+	doorbell_val = ish_reg_read(dev, IPC_REG_ISH2HOST_DRBL);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): IPC_IS_BUSY=%d\n", __func__, (int)IPC_IS_BUSY(doorbell_val));
+	g_ish_print_log(KERN_ALERT "%s(): IPC_IS_BUSY=%d\n", __func__, (int)IPC_IS_BUSY(doorbell_val));
+	if (!IPC_IS_BUSY(doorbell_val))
+		return IRQ_HANDLED;
+
+	ISH_DBG_PRINT("%s(): doorbell is busy - YES\n", __func__);
+	g_ish_print_log("%s(): doorbell is busy - YES\n", __func__);
+
+	ish_intr_disable(dev);
+
+	ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s(): protocol=%u\n", __func__, IPC_HEADER_GET_PROTOCOL(doorbell_val));
+	g_ish_print_log(KERN_ALERT "[heci-ish] %s(): protocol=%u\n", __func__, IPC_HEADER_GET_PROTOCOL(doorbell_val));
+
+	/* IPC message */
+	if (IPC_HEADER_GET_PROTOCOL(doorbell_val) == IPC_PROTOCOL_MNG) {
+		recv_ipc(dev, doorbell_val);
+		goto	eoi;
+	}
+
+	if (IPC_HEADER_GET_PROTOCOL(doorbell_val) != IPC_PROTOCOL_HECI)
+		goto	eoi;
+
+	/* Read HECI header dword */
+	msg_hdr = ish_read_hdr(dev);
+	if (!msg_hdr)
+		goto	eoi;
+
+	heci_hdr = (struct heci_msg_hdr *)&msg_hdr;
+
+	/* HECI bus message */
+	if (!heci_hdr->host_addr && !heci_hdr->me_addr) {
+		recv_hbm(dev, heci_hdr);
+		goto	eoi;
+
+	} else {
+		/* HECI client message */
+		recv_heci_cl_msg(dev, heci_hdr);
+		goto	eoi;
+	}
+
+eoi:
+	ISH_DBG_PRINT(KERN_ALERT "%s(): Doorbell cleared, busy reading cleared\n", __func__);
+	g_ish_print_log(KERN_ALERT "%s(): Doorbell cleared, busy reading cleared\n", __func__);
+	ish_reg_write(dev, IPC_REG_ISH2HOST_DRBL, 0);
+	/* Here and above: we need to actually read this register in order to unblock further interrupts on CHT A0 */
+	ish_intr_enable(dev);
+	return	IRQ_HANDLED;
+}
+
+
+static int	ipc_send_mng_msg(struct heci_device *dev, uint32_t msg_code, void *msg, size_t size)
+{
+	unsigned char	ipc_msg[IPC_FULL_MSG_SIZE];
+	uint32_t	drbl_val = IPC_BUILD_MNG_MSG(msg_code, size);
+
+	memcpy(ipc_msg, &drbl_val, sizeof(uint32_t));
+	memcpy(ipc_msg + sizeof(uint32_t), msg, size);
+	return	write_ipc_to_queue(dev, NULL, NULL, ipc_msg, sizeof(uint32_t) + size);
+}
+
+
+static int	ipc_send_heci_msg(struct heci_device *dev, struct heci_msg_hdr *hdr, void *msg, void(*ipc_send_compl)(void *), void *ipc_send_compl_prm)
+{
+	unsigned char	ipc_msg[IPC_FULL_MSG_SIZE];
+	uint32_t	drbl_val =  IPC_BUILD_HEADER(hdr->length + sizeof(struct heci_msg_hdr), IPC_PROTOCOL_HECI, 1);
+
+	g_ish_print_log("%s(): +++\n", __func__);
+	memcpy(ipc_msg, &drbl_val, sizeof(uint32_t));
+	memcpy(ipc_msg + sizeof(uint32_t), hdr, sizeof(uint32_t));
+	memcpy(ipc_msg + 2 * sizeof(uint32_t), msg, hdr->length);
+	return	write_ipc_to_queue(dev, ipc_send_compl, ipc_send_compl_prm, ipc_msg, 2 * sizeof(uint32_t) + hdr->length);
+}
+
+
+/**
+ * ish_hw_is_ready - check if the hw is ready
+ *
+ * @dev: the device structure
+ */
+bool ish_hw_is_ready(struct heci_device *dev)
+{
+	u32 ish_status =  ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);
+	return IPC_IS_ISH_ILUP(ish_status) && IPC_IS_ISH_HECI_READY(ish_status);
+}
+
+/**
+ * ish_host_is_ready - check if the host is ready
+ *
+ * @dev: the device structure
+ */
+bool ish_host_is_ready(struct heci_device *dev)
+{
+	return true;
+}
+
+void ish_set_host_rdy(struct heci_device *dev)
+{
+	u32  host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
+	dev_dbg(&dev->pdev->dev, "before HOST start host_status=%08X\n", host_status);
+	IPC_SET_HOST_READY(host_status);
+	ish_reg_write(dev, IPC_REG_HOST_COMM, host_status);
+	host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
+	dev_dbg(&dev->pdev->dev, "actually sent HOST start host_status=%08X\n", host_status);
+}
+
+void ish_clr_host_rdy(struct heci_device *dev)
+{
+	u32  host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
+	dev_dbg(&dev->pdev->dev, "before HOST start host_status=%08X\n", host_status);
+	IPC_CLEAR_HOST_READY(host_status);
+	ish_reg_write(dev, IPC_REG_HOST_COMM, host_status);
+	host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
+	dev_dbg(&dev->pdev->dev, "actually sent HOST start host_status=%08X\n", host_status);
+}
+
+/**
+ * ish_hw_reset - resets host and fw.
+ *
+ * @dev: the device structure
+ * @intr_enable: if interrupt should be enabled after reset.
+ */
+static int ish_hw_reset(struct heci_device *dev, bool intr_enable)
+{
+	struct ipc_rst_payload_type ipc_mng_msg;
+	int	rv = 0;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s():+++\n", __func__);
+	dev_dbg(&dev->pdev->dev, "ish_hw_reset \n");
+	/*temporary we'll send reset*/
+
+	ipc_mng_msg.reset_id = 1;
+	ipc_mng_msg.reserved = 0;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): before ish_intr_enable() \n", __func__);
+	ish_intr_enable(dev);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): after ish_intr_enable() \n", __func__);
+
+/* DEBUG: send self-interrupt and wait 100 (ms) for it to appear in klog */
+/*	ish_reg_write(dev, IPC_REG_ISH2HOST_DRBL, 0x80000000);
+	mdelay(100);
+************************/
+
+	/* Clear the incoming doorbell */
+	ISH_DBG_PRINT(KERN_ALERT "%s(): Doorbell cleared, busy reading cleared\n", __func__);
+	ish_reg_write(dev, IPC_REG_ISH2HOST_DRBL, 0);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): cleared doorbell reg.\n", __func__);
+
+	/* Fixed: this should be set BEFORE writing RESET_NOTIFY, lest response will be received BEFORE this clearing... */
+	dev->recvd_hw_ready = 0;
+
+	/*send message */
+	rv = ipc_send_mng_msg(dev, MNG_RESET_NOTIFY, &ipc_mng_msg, sizeof(struct ipc_rst_payload_type));
+	if (rv) {
+		dev_err(&dev->pdev->dev, "Failed to send IPC MNG_RESET_NOTIFY\n");
+		return	rv;
+	}
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): going to wait for hw_ready.\n", __func__);
+	/*wait_event_interruptible(dev->wait_hw_ready, dev->recvd_hw_ready);*/
+	wait_event_timeout(dev->wait_hw_ready, dev->recvd_hw_ready, 2*HZ);
+	if (!dev->recvd_hw_ready) {
+		dev_err(&dev->pdev->dev, "Timed out waiting for HW ready\n");
+		rv = -ENODEV;
+	}
+	ISH_DBG_PRINT(KERN_ALERT "%s(): woke up from hw_ready.\n", __func__);
+
+	dev_dbg(&dev->pdev->dev, "exit initial link wait \n");
+
+	return rv;
+}
+
+/* Dummy. Do we need it? */
+static void ish_hw_config(struct heci_device *dev)
+{
+	ISH_DBG_PRINT(KERN_ALERT "%s()+++ [ish_hw_reset=%p]\n", __func__, ish_hw_reset);
+	dev_dbg(&dev->pdev->dev, "ish_hw_config \n");
+}
+
+static int ish_hw_start(struct heci_device *dev)
+{
+	struct ish_hw *hw = to_ish_hw(dev);
+
+	dev_dbg(&dev->pdev->dev, "ish_hw_start\n");
+	ish_set_host_rdy(dev);
+#ifdef	D3_RCR
+	/* After that we can enable ISH DMA operation */
+	ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s(): writing DMA_ENABLED\n", __func__);
+	writel(IPC_RMP2_DMA_ENABLED, hw->mem_addr + IPC_REG_ISH_RMP2);
+
+	/* Send 0 IPC message so that ISH FW wakes up if it was already asleep */
+	writel(IPC_DRBL_BUSY_BIT, hw->mem_addr + IPC_REG_HOST2ISH_DRBL);
+#endif
+	ish_intr_enable(dev);
+	return 0;
+}
+
+
+static u32 ish_read_hdr(const struct heci_device *dev)
+{
+	return ish_reg_read(dev, IPC_REG_ISH2HOST_MSG);
+}
+
+
+/**
+ * ish_write - writes a message to heci device.
+ *
+ * @dev: the device structure
+ * @header: header of message
+ * @buf: message buffer will be written
+ * returns 1 if success, 0 - otherwise.
+ */
+
+static int ish_write(struct heci_device *dev, struct heci_msg_hdr *header, unsigned char *buf)
+{
+/*#####################################################################*/
+	unsigned char ipc_msg[IPC_FULL_MSG_SIZE];
+	u32 doorbell_val;
+
+	doorbell_val = IPC_BUILD_HEADER(header->length + sizeof(struct heci_msg_hdr), IPC_PROTOCOL_HECI, 1);
+	memcpy(ipc_msg, (char*)&doorbell_val, sizeof(u32));
+	memcpy(ipc_msg + sizeof(u32), (char*)header, sizeof(struct heci_msg_hdr));
+	memcpy(ipc_msg + sizeof(u32) + sizeof(struct heci_msg_hdr), buf, header->length);
+
+	return write_ipc_to_queue(dev, NULL, NULL, ipc_msg, sizeof(u32) + sizeof(struct heci_msg_hdr) + header->length);
+/*#####################################################################*/
+}
+
+
+static const struct heci_hw_ops ish_hw_ops = {
+	.host_is_ready = ish_host_is_ready,
+	.hw_is_ready = ish_hw_is_ready,
+	.hw_reset = ish_hw_reset,
+	.hw_config = ish_hw_config,
+	.hw_start = ish_hw_start,
+	.read = ish_read,
+	.write = ish_write,
+	.write_ex = ipc_send_heci_msg
+};
+
+
+struct heci_device *ish_dev_init(struct pci_dev *pdev)
+{
+
+	struct heci_device *dev;
+
+	dev = kzalloc(sizeof(struct heci_device) +  sizeof(struct ish_hw), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	heci_device_init(dev);
+
+	/* Rx INT->BH FIFO pointers */
+	dev->rd_msg_fifo_head = 0;
+	dev->rd_msg_fifo_tail = 0;
+	spin_lock_init(&dev->rd_msg_spinlock);
+	spin_lock_init(&dev->wr_processing_spinlock);
+	spin_lock_init(&dev->read_list_spinlock);
+	spin_lock_init(&dev->device_lock);
+	INIT_WORK(&dev->bh_hbm_work, bh_hbm_work_fn);
+
+	dev->ops = &ish_hw_ops;
+	dev->pdev = pdev;
+	dev->mtu = IPC_PAYLOAD_SIZE - sizeof(struct heci_msg_hdr);
+	return dev;
+}
+
diff --git a/drivers/misc/heci/hw-ish.h b/drivers/misc/heci/hw-ish.h
new file mode 100644
index 0000000..0e1e10c
--- /dev/null
+++ b/drivers/misc/heci/hw-ish.h
@@ -0,0 +1,46 @@
+/*
+ * H/W layer of HECI provider device (ISH)
+ *
+ * Copyright (c) 2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _HECI_HW_ISH_H_
+#define _HECI_HW_ISH_H_
+
+#include <linux/pci.h>
+#include "hw-ish-regs.h"
+#include "heci_dev.h"
+
+struct ipc_rst_payload_type {
+    u16            reset_id;
+    u16            reserved;
+} ;
+
+struct ish_hw {
+	void __iomem *mem_addr;
+};
+
+#define to_ish_hw(dev) (struct ish_hw *)((dev)->hw)
+
+
+struct heci_device *ish_dev_init(struct pci_dev *pdev);
+
+irqreturn_t ish_irq_handler(int irq, void *dev_id);
+
+void ish_clr_host_rdy(struct heci_device *dev);
+void ish_set_host_rdy(struct heci_device *dev);
+bool ish_hw_is_ready(struct heci_device *dev);
+void ish_intr_enable(struct heci_device *dev);
+void ish_intr_disable(struct heci_device *dev);
+
+#endif /* _HECI_HW_ISH_H_ */
+
diff --git a/drivers/misc/heci/init.c b/drivers/misc/heci/init.c
new file mode 100644
index 0000000..7f7999f
--- /dev/null
+++ b/drivers/misc/heci/init.c
@@ -0,0 +1,227 @@
+/*
+ * Initialization protocol for HECI driver
+ *
+ * Copyright (c) 2003-2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/export.h>
+#include <linux/pci.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include "heci_dev.h"
+#include "hbm.h"
+#include "client.h"
+#include "utils.h"
+#include "platform-config.h"
+
+const char *heci_dev_state_str(int state)
+{
+#define HECI_DEV_STATE(state) case HECI_DEV_##state: return #state
+	switch (state) {
+	HECI_DEV_STATE(INITIALIZING);
+	HECI_DEV_STATE(INIT_CLIENTS);
+	HECI_DEV_STATE(ENABLED);
+	HECI_DEV_STATE(RESETTING);
+	HECI_DEV_STATE(DISABLED);
+	HECI_DEV_STATE(POWER_DOWN);
+	HECI_DEV_STATE(POWER_UP);
+	default:
+		return "unkown";
+	}
+#undef HECI_DEV_STATE
+}
+EXPORT_SYMBOL(heci_dev_state_str);
+
+void heci_device_init(struct heci_device *dev)
+{
+	/* setup our list array */
+	INIT_LIST_HEAD(&dev->cl_list);
+	INIT_LIST_HEAD(&dev->device_list);
+	init_waitqueue_head(&dev->wait_hw_ready);
+	init_waitqueue_head(&dev->wait_hbm_recvd_msg);
+	init_waitqueue_head(&dev->wait_dma_ready);
+	dev->dev_state = HECI_DEV_INITIALIZING;
+
+	/* We need to reserve something, because client #0 is reserved for HECI bus messages */
+	bitmap_zero(dev->host_clients_map, HECI_CLIENTS_MAX);
+	dev->open_handle_count = 0;
+
+	/*
+	 * Reserving the first three client IDs
+	 * 0: Reserved for HECI Bus Message communications
+	 * 1: Reserved for Watchdog
+	 * 2: Reserved for AMTHI
+	 */
+	bitmap_set(dev->host_clients_map, 0, 3);
+	/*****************************/
+
+	heci_io_list_init(&dev->read_list);
+
+	/* Init IPC processing and free lists */
+	INIT_LIST_HEAD(&dev->wr_processing_list_head.link);
+	INIT_LIST_HEAD(&dev->wr_free_list_head.link);
+	do {
+		int	i;
+
+		for (i = 0; i < IPC_TX_FIFO_SIZE; ++i) {
+			struct wr_msg_ctl_info	*tx_buf;
+
+			tx_buf = kmalloc(sizeof(struct wr_msg_ctl_info), GFP_KERNEL);
+			if (!tx_buf) {
+				/* ERROR: decide what to do with it. IPC buffers may be limited or not available at all - although this shouldn't happen */
+				printk(KERN_ERR "[heci-ish]: failure in Tx FIFO allocations (%d)\n", i);
+				break;
+			}
+			memset(tx_buf, 0, sizeof(struct wr_msg_ctl_info));
+			list_add_tail(&tx_buf->link, &dev->wr_free_list_head.link);
+		}
+		printk(KERN_ALERT "[heci-ish]: success Tx FIFO allocations\n");
+	} while (0);
+}
+EXPORT_SYMBOL_GPL(heci_device_init);
+
+/**
+ * heci_start - initializes host and fw to start work.
+ *
+ * @dev: the device structure
+ *
+ * returns 0 on success, <0 on failure.
+ */
+int heci_start(struct heci_device *dev)
+{
+	heci_hw_config(dev);
+#ifdef FORCE_FW_INIT_RESET
+	/* wait for FW-initiated reset flow, indefinitely */
+	heci_hw_start(dev);
+	/* 16/6/2014: changed this 2->5 seconds following MCG assertion. Once this was 10 seconds, lowered to 2. TODO: check out all FW ISH/SEC path how much it should be */
+	/*timed_wait_for_timeout(WAIT_FOR_CONNECT_SLICE, dev->recvd_hw_ready, (10*HZ));*/
+	if (!dev->recvd_hw_ready)
+		wait_event_timeout(dev->wait_hw_ready, dev->recvd_hw_ready, 10*HZ);
+	/* Lock only after FW-reset flow worked or failed. Otherwise interrupts BH will be locked */
+	if (dev->recvd_hw_ready)
+		goto	reset_done;
+	dev_err(&dev->pdev->dev, "[heci-ish] %s(): Timed out waiting for FW-initiated reset\n", __func__);
+#if 1 
+	goto	err; /* DEBUGDEBUGDEBUG: raise timeout for FW-initiated reset to 10 s and don't sent host-initiated reset flow */
+#endif
+	/* DEBUGDEBUGDEBUG: Below code until 'reset_done:' is defunct */
+#else
+#endif
+	/* acknowledge interrupt and stop interupts */
+	dev_dbg(&dev->pdev->dev, "reset in start the heci device.\n");
+	heci_reset(dev, 1);
+
+reset_done:
+	if (heci_hbm_start_wait(dev)) {
+		dev_err(&dev->pdev->dev, "HBM haven't started");
+		goto err;
+	}
+
+	if (!heci_host_is_ready(dev)) {
+		dev_err(&dev->pdev->dev, "host is not ready.\n");
+		goto err;
+	}
+
+	if (!heci_hw_is_ready(dev)) {
+		dev_err(&dev->pdev->dev, "ME is not ready.\n");
+		goto err;
+	}
+
+	/*if (dev->version.major_version != HBM_MAJOR_VERSION ||
+	    dev->version.minor_version != HBM_MINOR_VERSION) {
+		dev_dbg(&dev->pdev->dev, "HECI start failed.\n");
+		goto err;
+	}*/
+
+	dev_dbg(&dev->pdev->dev, "link layer has been established.\n");
+
+	return 0;
+err:
+	dev_err(&dev->pdev->dev, "link layer initialization failed.\n");
+	dev->dev_state = HECI_DEV_DISABLED;
+	return -ENODEV;
+}
+EXPORT_SYMBOL_GPL(heci_start);
+
+/**
+ * heci_reset - resets host and fw.
+ *
+ * @dev: the device structure
+ * @interrupts_enabled: if interrupt should be enabled after reset.
+ */
+void heci_reset(struct heci_device *dev, int interrupts_enabled)
+{
+	bool unexpected;
+	int ret;
+
+	unexpected = (dev->dev_state != HECI_DEV_INITIALIZING &&
+			dev->dev_state != HECI_DEV_DISABLED &&
+			dev->dev_state != HECI_DEV_POWER_DOWN &&
+			dev->dev_state != HECI_DEV_POWER_UP);
+
+	ret = heci_hw_reset(dev, interrupts_enabled);
+	if (ret) {
+		dev_err(&dev->pdev->dev, "hw reset failed disabling the device\n");
+		interrupts_enabled = false;
+		dev->dev_state = HECI_DEV_DISABLED;
+	}
+
+	dev->hbm_state = HECI_HBM_IDLE;
+
+	if (dev->dev_state != HECI_DEV_INITIALIZING) {
+		if (dev->dev_state != HECI_DEV_DISABLED &&
+		    dev->dev_state != HECI_DEV_POWER_DOWN)
+			dev->dev_state = HECI_DEV_RESETTING;
+
+		heci_cl_all_disconnect(dev);
+	}
+
+	dev->me_clients_num = 0;
+
+	if (unexpected)
+		dev_warn(&dev->pdev->dev, "unexpected reset: dev_state = %s\n",
+			 heci_dev_state_str(dev->dev_state));
+
+	if (!interrupts_enabled) {
+		dev_dbg(&dev->pdev->dev, "intr not enabled end of reset\n");
+		return;
+	}
+	dev_dbg(&dev->pdev->dev, "before sending HOST start\n");
+	ret = heci_hw_start(dev);
+	if (ret) {
+		dev_err(&dev->pdev->dev, "hw_start failed disabling the device\n");
+		dev->dev_state = HECI_DEV_DISABLED;
+		return;
+	}
+
+	dev_dbg(&dev->pdev->dev, "link is established start sending messages.\n");
+	/* link is established * start sending messages.  */
+
+	dev->dev_state = HECI_DEV_INIT_CLIENTS;
+	dev->hbm_state = HECI_HBM_START;
+	heci_hbm_start_req(dev);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): after heci_hbm_start_req()\n", __func__);
+	/* wake up all readings so they can be interrupted */
+	heci_cl_all_read_wakeup(dev);
+}
+EXPORT_SYMBOL_GPL(heci_reset);
+
+void heci_stop(struct heci_device *dev)
+{
+	dev_dbg(&dev->pdev->dev, "stopping the device.\n");
+	dev->dev_state = HECI_DEV_POWER_DOWN;
+	heci_reset(dev, 0);
+	flush_scheduled_work();
+}
+EXPORT_SYMBOL_GPL(heci_stop);
+
diff --git a/drivers/misc/heci/pci-ish.c b/drivers/misc/heci/pci-ish.c
new file mode 100644
index 0000000..c795539
--- /dev/null
+++ b/drivers/misc/heci/pci-ish.c
@@ -0,0 +1,699 @@
+/*
+ * PCI glue for HECI provider device (ISH) driver
+ *
+ * Copyright (c) 2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/aio.h>
+#include <linux/pci.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/cdev.h>
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/uuid.h>
+#include <linux/compat.h>
+#include <linux/jiffies.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include "heci_dev.h"
+#include "hw-ish.h"
+#include "utils.h"
+#include <linux/miscdevice.h>
+
+#ifdef dev_dbg
+#undef dev_dbg
+#endif
+static void no_dev_dbg(void *v, char *s, ...)
+{
+}
+#define dev_dbg no_dev_dbg
+
+/*#define dev_dbg dev_err*/
+
+/*
+ *  heci driver strings
+ */
+static bool nomsi;
+module_param_named(nomsi, nomsi, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(nomsi, "don't use msi (default = false)");
+
+/* Currently this driver works as long as there is only a single AMT device. */
+static struct pci_dev *heci_pci_device;
+
+static DEFINE_PCI_DEVICE_TABLE(ish_pci_tbl) = {
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x22D8)},
+	{0, }
+};
+
+MODULE_DEVICE_TABLE(pci, ish_pci_tbl);
+
+static DEFINE_MUTEX(heci_mutex);
+
+#ifdef TIMER_POLLING
+/*
+ * DD -- ISH timer-polling workaround for H-FPGA (and other platforms that fail to deliver interrupts)
+ * NOTE: currently this will break (crash) if driver is unloaded
+ */
+
+#include <linux/timer.h>
+
+struct timer_list	ish_poll_timer;
+void	*timer_data;
+struct work_struct	ish_poll_work;
+
+void	ish_poll_work_fn(void *prm)
+{
+}
+
+void	ish_poll_timer_fn(unsigned long unused)
+{
+	irqreturn_t	rv;
+
+	rv = ish_irq_handler(0, timer_data);
+	/*ISH_DBG_PRINT(KERN_ALERT "%s(): ish_irq_handler() returned %08X\n", __func__, rv);*/
+
+	/* Reschedule timer */
+	ish_poll_timer.expires += 2;
+	add_timer(&ish_poll_timer);
+}
+
+#endif	/* TIMER_POLLING */
+
+
+#if ISH_DEBUGGER
+
+struct ish_hw *hw_dbg;
+
+static int ishdbg_open(struct inode *inode, struct file *file)
+{
+	return	0;
+}
+
+static int ishdbg_release(struct inode *inode, struct file *file)
+{
+	return	0;
+}
+
+static char	dbg_resp_buf[2048];
+static int	resp_buf_read;
+
+static ssize_t ishdbg_read(struct file *file, char __user *ubuf, size_t length, loff_t *offset)
+{
+	int rv;
+	int copy_len;
+
+	if (resp_buf_read)
+		return	0;	/* EOF */
+	copy_len = (length > strlen(dbg_resp_buf))? strlen(dbg_resp_buf) : length;
+	rv = copy_to_user(ubuf, dbg_resp_buf, copy_len);
+	if (rv)
+		return  -EINVAL;
+	resp_buf_read = 1;
+	return  copy_len;
+}
+
+static ssize_t ishdbg_write(struct file *file, const char __user *ubuf, size_t length, loff_t *offset)
+{
+	char    dbg_req_buf[768];
+	char    cmd[768];
+	int     rv;
+	int     addr, count, sscanf_match, i, cur_index;
+	volatile uint32_t *reg_data;
+
+       	if (length > sizeof(dbg_req_buf))
+		length = sizeof(dbg_req_buf);
+	rv = copy_from_user(dbg_req_buf, ubuf, length);
+	if (rv)
+		return  -EINVAL;
+        if (sscanf(dbg_req_buf, "%s ", cmd) != 1) {
+		printk(KERN_ERR "[ish-dbg]) sscanf failed\n");
+		return  -EINVAL;
+	}
+	sscanf_match = sscanf(dbg_req_buf + 2, "%x %d", &addr, &count);
+	if (!strcmp(cmd, "d")) {
+		/* Dump values: d <addr> [count] */
+		if (sscanf_match == 1)
+			count = 1;
+		else if (sscanf_match != 2) {
+			printk(KERN_ERR "[ish-dbg] sscanf failed, sscanf_match = %d\n", sscanf_match);
+			return  -EINVAL;
+		}
+		if (addr % 4) {
+			printk(KERN_ERR "[ish-dbg] address isn't aligned to 4 bytes\n");
+			return -EINVAL;
+		}
+		cur_index = 0;
+		for (i = 0; i < count; i++) {
+			reg_data = (volatile uint32_t *)((char*)hw_dbg->mem_addr + addr + i*4);
+			cur_index += sprintf(dbg_resp_buf + cur_index, "%08X ", *reg_data);
+		}
+		cur_index += sprintf(dbg_resp_buf + cur_index, "\n");
+		resp_buf_read = 0;
+	}
+	else if (!strcmp(cmd, "e")) {
+		/* Enter values e <addr> <value> */
+		if (sscanf_match != 2) {
+			printk(KERN_ERR "[ish-dbg] sscanf failed, sscanfMatch = %d\n", sscanf_match);
+			return  -EINVAL;
+		}
+		if (addr % 4) {
+			printk(KERN_ERR "[ish-dbg] address isn't aligned to 4 bytes\n");
+			return -EINVAL;
+		}
+		reg_data = (volatile uint32_t *)((char*)hw_dbg->mem_addr + addr);
+		*reg_data = count;
+		sprintf(dbg_resp_buf, "OK\n");
+		resp_buf_read = 0;
+        }
+
+	return  length;
+}
+
+static long ishdbg_ioctl(struct file *file, unsigned int cmd, unsigned long data)
+{
+	return	0;
+}
+
+/*
+ * file operations structure will be used for heci char device.
+ */
+static const struct file_operations ishdbg_fops = {
+	.owner = THIS_MODULE,
+	.read = ishdbg_read,
+	.unlocked_ioctl = ishdbg_ioctl,
+	.open = ishdbg_open,
+	.release = ishdbg_release,
+	.write = ishdbg_write,
+	.llseek = no_llseek
+};
+
+/*
+ * Misc Device Struct
+ */
+static struct miscdevice  ishdbg_misc_device = {
+		.name = "ishdbg",
+		.fops = &ishdbg_fops,
+		.minor = MISC_DYNAMIC_MINOR,
+};
+
+#endif /* ISH_DEBUGGER */
+
+#if ISH_LOG
+
+void delete_from_log(struct heci_device *dev, size_t min_chars)
+{
+	int i;
+
+	dev->log_tail = (dev->log_tail + min_chars - 1) % PRINT_BUFFER_SIZE;    /* log_tail points now on the last char to be deleted */
+	for (i = dev->log_tail; dev->log_buffer[i] != '\n'; i = (i+1) % PRINT_BUFFER_SIZE)
+		;
+	dev->log_tail = (i+1) % PRINT_BUFFER_SIZE;
+}
+
+static void ish_print_log(struct heci_device *dev, char *format, ...)
+{
+	char tmp_buf[1024];
+	va_list args;
+	int length, i, full_space, free_space;
+	unsigned long	flags;
+	struct timeval tv;
+
+	do_gettimeofday(&tv);
+	i = sprintf(tmp_buf, "[%ld.%06ld] ", tv.tv_sec, tv.tv_usec);
+
+	va_start(args, format);
+	length = vsprintf(tmp_buf + i, format, args);
+	va_end(args);
+
+	length = length + i;
+	if (tmp_buf[length-1] != '\n') {        /* if the msg does not end with \n, add it*/
+		tmp_buf[length] = '\n';
+		length++;
+	}
+
+	spin_lock_irqsave(&dev->log_spinlock, flags);
+
+	full_space = dev->log_head - dev->log_tail;
+	if (full_space < 0)
+		full_space = PRINT_BUFFER_SIZE + full_space;
+	free_space = PRINT_BUFFER_SIZE - full_space;
+
+	if (free_space <= length)
+		delete_from_log(dev, (length - free_space)+1);  /* needed at least 1 empty char to recognize whether buffer is full or empty */
+
+	if (dev->log_head + length <= PRINT_BUFFER_SIZE)
+		memcpy(dev->log_buffer + dev->log_head, tmp_buf, length);
+	else {
+		memcpy(dev->log_buffer + dev->log_head, tmp_buf,  PRINT_BUFFER_SIZE - dev->log_head);
+		memcpy(dev->log_buffer, tmp_buf + PRINT_BUFFER_SIZE - dev->log_head, length - (PRINT_BUFFER_SIZE - dev->log_head));
+	}
+	dev->log_head = (dev->log_head + length) % PRINT_BUFFER_SIZE;
+
+	spin_unlock_irqrestore(&dev->log_spinlock, flags);
+}
+
+
+void	g_ish_print_log(char *fmt, ...)
+{
+	char tmp_buf[1024];
+	va_list args;
+	struct heci_device	*dev = pci_get_drvdata(heci_pci_device);
+
+	va_start(args, fmt);
+	vsprintf(tmp_buf, fmt, args);
+	va_end(args);
+	ish_print_log(dev, tmp_buf);
+}
+EXPORT_SYMBOL(g_ish_print_log);
+
+
+static ssize_t ish_read_log(struct heci_device *dev, char *buf, size_t size)
+{
+	int i, full_space, ret_val;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&dev->log_spinlock, flags);
+
+	if (dev->log_head == dev->log_tail) {/* log is empty */
+		spin_unlock_irqrestore(&dev->log_spinlock, flags);
+		return 0;
+	}
+
+	/* read size the minimum between full_space and the buffer size */
+	full_space = dev->log_head - dev->log_tail;
+	if (full_space < 0)
+		full_space = PRINT_BUFFER_SIZE + full_space;
+
+	if (full_space < size)
+		i = (dev->log_tail + full_space) % PRINT_BUFFER_SIZE; /* =dev->log_head */
+	else
+		i = (dev->log_tail + size) % PRINT_BUFFER_SIZE;
+	/* i is the last character to be readen */
+	i = (i-1) % PRINT_BUFFER_SIZE;
+
+	/* read from tail to last '\n' before i */
+	for (;dev->log_buffer[i] != '\n';i = (i-1) % PRINT_BUFFER_SIZE);
+
+	if (dev->log_tail < i) {
+		memcpy(buf, dev->log_buffer + dev->log_tail, i - dev->log_tail + 1);
+		ret_val = i - dev->log_tail + 1;
+	} else {
+		memcpy(buf, dev->log_buffer + dev->log_tail, PRINT_BUFFER_SIZE - dev->log_tail);
+		memcpy(buf + PRINT_BUFFER_SIZE - dev->log_tail, dev->log_buffer, i + 1);
+		ret_val = PRINT_BUFFER_SIZE - dev->log_tail + i + 1;
+	}
+	spin_unlock_irqrestore(&dev->log_spinlock, flags);
+	return ret_val;
+}
+
+static ssize_t ish_read_flush_log(struct heci_device *dev, char *buf, size_t size)
+{
+	int ret;
+	unsigned long	flags;
+
+	ret = ish_read_log(dev, buf, size);
+	spin_lock_irqsave(&dev->log_spinlock, flags);
+	delete_from_log(dev, ret);
+	spin_unlock_irqrestore(&dev->log_spinlock, flags);
+	return ret;
+}
+
+/* show & store functions for both read and flush char devices*/
+ssize_t show_read(struct device *dev, struct device_attribute *dev_attr, char *buf)
+{
+	struct pci_dev *pdev;
+	struct heci_device *heci_dev;
+
+	pdev = container_of(dev, struct pci_dev, dev);
+	heci_dev = pci_get_drvdata(pdev);
+	return ish_read_log(heci_dev, buf, PAGE_SIZE);
+}
+
+ssize_t store_read(struct device *dev, struct device_attribute *dev_attr, const char *buf, size_t count)
+{
+	return count;
+}
+
+static struct device_attribute read_attr = {
+	.attr = {
+		.name = "ish_read_log",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = show_read,
+	.store = store_read
+};
+
+ssize_t show_flush(struct device *dev, struct device_attribute *dev_attr, char *buf)
+{
+	struct pci_dev *pdev;
+	struct heci_device *heci_dev;
+
+	pdev = container_of(dev, struct pci_dev, dev);
+	heci_dev = pci_get_drvdata(pdev);
+	return ish_read_flush_log(heci_dev, buf, PAGE_SIZE);
+}
+
+ssize_t store_flush(struct device *dev, struct device_attribute *dev_attr, const char *buf, size_t count)
+{
+	return count;
+}
+
+static struct device_attribute flush_attr = {
+	.attr = {
+		.name = "ish_flush_log",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = show_flush,
+	.store = store_flush
+};
+
+#endif /* ISH_LOG */
+
+ssize_t show_heci_dev_props(struct device *dev, struct device_attribute *dev_attr, char *buf)
+{
+	struct pci_dev *pdev;
+	struct heci_device *heci_dev;
+	ssize_t	ret = -ENOENT;
+
+	pdev = container_of(dev, struct pci_dev, dev);
+	heci_dev = pci_get_drvdata(pdev);
+
+	if (!strcmp(dev_attr->attr.name, "heci_dev_state")) {
+		sprintf(buf, "%u\n", (unsigned)heci_dev->dev_state);
+		ret = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name, "hbm_state")) {
+		sprintf(buf, "%u\n", (unsigned)heci_dev->hbm_state);
+		ret = strlen(buf);
+	}
+
+	return	ret;
+}
+
+ssize_t store_heci_dev_props(struct device *dev, struct device_attribute *dev_attr, const char *buf, size_t count)
+{
+	return	-EINVAL;
+}
+
+static struct device_attribute heci_dev_state_attr = {
+	.attr = {
+		.name = "heci_dev_state",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = show_heci_dev_props,
+	.store = store_heci_dev_props
+};
+
+static struct device_attribute hbm_state_attr = {
+	.attr = {
+		.name = "hbm_state",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = show_heci_dev_props,
+	.store = store_heci_dev_props
+};
+
+/**********************************/
+
+typedef struct {
+  struct work_struct my_work;
+  struct heci_device *dev;
+} my_work_t;
+
+void workqueue_init_function(struct work_struct *work)
+{
+	struct heci_device *dev = ((my_work_t *)work)->dev;
+	int err;
+
+	ISH_DBG_PRINT(KERN_ALERT "[pci driver] %s() in workqueue func, continue initialization process\n", __func__);
+	
+	pci_set_drvdata(dev->pdev, dev);
+/*	dev_dbg(&dev->pdev->dev, "heci: after pci_set_drvdata\n");*/
+
+	device_create_file(&dev->pdev->dev, &heci_dev_state_attr);
+	device_create_file(&dev->pdev->dev, &hbm_state_attr);
+
+#if ISH_LOG
+
+	device_create_file(&dev->pdev->dev, &read_attr);
+	device_create_file(&dev->pdev->dev, &flush_attr);
+
+	dev->log_head = dev->log_tail = 0;
+	dev->print_log = ish_print_log;
+
+	spin_lock_init(&dev->log_spinlock);
+
+	dev->print_log(dev, "[heci-ish]: %s():+++ [Build "BUILD_ID "]\n", __func__);
+	dev->print_log(dev, "[heci-ish] %s() running on %s revision [%02X]\n", __func__,
+		dev->pdev->revision == REVISION_ID_CHT_A0 || (dev->pdev->revision & REVISION_ID_SI_MASK) == REVISION_ID_CHT_A0_SI ? "CHT A0" :
+		dev->pdev->revision == REVISION_ID_CHT_B0 || (dev->pdev->revision & REVISION_ID_SI_MASK) == REVISION_ID_CHT_Bx_SI ? "CHT B0" : "Unknown", dev->pdev->revision);
+
+#endif /*ISH_LOG*/
+
+	mutex_lock(&heci_mutex);
+	if (heci_start(dev)) {
+		dev_err(&dev->pdev->dev, "heci: Init hw failure.\n");
+		err = -ENODEV;
+		goto out_err;
+	}
+/*	dev_dbg(&dev->pdev->dev, "heci: after heci_start\n");*/
+
+	err = heci_register(dev);
+	if (err)
+		goto out_err;
+/*	dev_dbg(&dev->pdev->dev, "heci: after heci_register\n");*/
+
+
+	mutex_unlock(&heci_mutex);
+
+	ISH_DBG_PRINT(KERN_ALERT "[pci driver] %s() in workqueue func, finished initialization process\n", __func__);
+	kfree((void *)work);
+	return;
+
+out_err:
+	mutex_unlock(&heci_mutex);
+	kfree((void *)work);
+}
+
+/**********************************/
+
+/**
+ * heci_probe - Device Initialization Routine
+ *
+ * @pdev: PCI device structure
+ * @ent: entry in ish_pci_tbl
+ *
+ * returns 0 on success, <0 on failure.
+ */
+static int ish_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	struct heci_device *dev;
+	struct ish_hw *hw;
+	int err;
+	int	rv;
+	struct workqueue_struct *workqueue_for_init;
+	my_work_t *work;
+
+	ISH_INFO_PRINT(KERN_ALERT "[heci-ish]: %s():+++ [Build "BUILD_ID "]\n", __func__);
+	ISH_INFO_PRINT(KERN_ALERT "[heci-ish] %s() running on %s revision [%02X]\n", __func__,
+		pdev->revision == REVISION_ID_CHT_A0 || (pdev->revision & REVISION_ID_SI_MASK) == REVISION_ID_CHT_A0_SI ? "CHT A0" :
+		pdev->revision == REVISION_ID_CHT_B0 || (pdev->revision & REVISION_ID_SI_MASK) == REVISION_ID_CHT_Bx_SI ? "CHT B0" : "Unknown", pdev->revision);
+#if defined (SUPPORT_Ax_ONLY)
+	pdev->revision = REVISION_ID_CHT_A0;
+	ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s() revision forced to A0\n", __func__);
+#elif defined (SUPPORT_Bx_ONLY)
+	pdev->revision = REVISION_ID_CHT_B0;
+	ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s() revision forced to B0\n", __func__);
+#endif
+	mutex_lock(&heci_mutex);
+	if (heci_pci_device) {
+		err = -EEXIST;
+		goto end;
+	}
+	/* enable pci dev */
+	err = pci_enable_device(pdev);
+	if (err) {
+		dev_err(&pdev->dev, "heci: Failed to enable pci device.\n");
+		goto end;
+	}
+	/* set PCI host mastering  */
+	pci_set_master(pdev);
+	/* pci request regions for heci driver */
+	err = pci_request_regions(pdev, KBUILD_MODNAME);
+	if (err) {
+		dev_err(&pdev->dev, "heci: Failed to get pci regions.\n");
+		goto disable_device;
+	}
+
+	/* allocates and initializes the heci dev structure */
+	dev = ish_dev_init(pdev);
+	if (!dev) {
+		err = -ENOMEM;
+		goto release_regions;
+	}
+	hw = to_ish_hw(dev);
+
+	/* mapping  IO device memory */
+	hw->mem_addr = pci_iomap(pdev, 0, 0);
+	if (!hw->mem_addr) {
+		dev_err(&pdev->dev, "mapping I/O device memory failure.\n");
+		err = -ENOMEM;
+		goto free_device;
+	}
+
+#if ISH_DEBUGGER
+	ishdbg_misc_device.parent = &pdev->dev;
+	rv = misc_register(&ishdbg_misc_device);
+	if (rv)
+		dev_err(&pdev->dev, "error starting ISH debugger (misc_register failed): %d\n", rv);	
+	hw_dbg = hw;
+#endif
+
+	heci_pci_device = pdev;
+
+	/* request and enable interrupt   */
+#ifndef TIMER_POLLING
+	err = request_irq(pdev->irq, ish_irq_handler, IRQF_SHARED, KBUILD_MODNAME, dev);
+	if (err) {
+		dev_err(&pdev->dev, "heci: request_irq failure. irq = %d\n", pdev->irq);
+		goto free_device;
+	}
+	printk(KERN_ALERT "[heci-ish]: uses IRQ %d\n", pdev->irq);
+
+	/* Diagnostic output */
+	do {
+		uint32_t	msg_addr;
+		uint32_t	msg_data;
+
+		pci_read_config_dword(pdev, pdev->msi_cap + PCI_MSI_ADDRESS_LO, &msg_addr);
+		pci_read_config_dword(pdev, pdev->msi_cap + PCI_MSI_DATA_32, &msg_data);
+		ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s(): assigned IRQ = %d, [PCI_MSI_ADDRESS_LO] = %08X [PCI_MSI_DATA_32] = %08X\n", __func__, pdev->irq, msg_addr, msg_data);
+	} while (0);
+	/*********************/
+#else
+	/* Init & prepare workqueue */
+	INIT_WORK(&ish_poll_work, ish_poll_work_fn);
+
+	/* Create and schedule ISH polling timer */
+	init_timer(&ish_poll_timer);
+	ish_poll_timer.data = 0;
+	ish_poll_timer.function = ish_poll_timer_fn;
+	ish_poll_timer.expires = jiffies + 2;
+	timer_data = dev;
+	add_timer(&ish_poll_timer);
+
+	/* Init ISH polling timers workqueue */
+#endif
+
+	/* PCI quirk: prevent from being put into D3 state */
+	pdev->dev_flags |= PCI_DEV_FLAGS_NO_D3;
+
+
+	/* 7/7/2014: in order to not stick Android boot, from here & below needs to run in work queue and here we should return success */
+	/****************************************************************/
+	work = (my_work_t *)kmalloc(sizeof(my_work_t), GFP_KERNEL);
+
+	work->dev = dev;
+	workqueue_for_init = create_workqueue("workqueue_for_init");
+	INIT_WORK(&work->my_work, workqueue_init_function);
+	queue_work(workqueue_for_init, &work->my_work);
+
+	ISH_DBG_PRINT("[pci driver] %s() enqueue init_work function\n", __func__);
+
+	mutex_unlock(&heci_mutex);
+	return 0;
+	/****************************************************************/
+
+free_device:
+	pci_iounmap(pdev, hw->mem_addr);
+	kfree(dev);
+release_regions:
+	pci_release_regions(pdev);
+disable_device:
+	pci_disable_device(pdev);
+end:
+	mutex_unlock(&heci_mutex);
+	dev_err(&pdev->dev, "heci: Driver initialization failed.\n");
+	return err;
+}
+
+/**
+ * heci_remove - Device Removal Routine
+ *
+ * @pdev: PCI device structure
+ *
+ * heci_remove is called by the PCI subsystem to alert the driver
+ * that it should release a PCI device.
+ */
+static void ish_remove(struct pci_dev *pdev)
+{
+	struct heci_device *dev;
+	struct ish_hw *hw;
+
+	/*** If this case of removal is viable, also go through HECI clients removal ***/
+
+	if (heci_pci_device != pdev) {
+		dev_err(&pdev->dev, "heci: heci_pci_device != pdev\n");
+		return;
+	}
+
+	dev = pci_get_drvdata(pdev);
+	if (!dev) {
+		dev_err(&pdev->dev, "heci: dev =NULL\n");
+		return;
+	}
+
+	hw = to_ish_hw(dev);
+
+	/* disable interrupts */
+	ish_intr_disable(dev);
+	free_irq(pdev->irq, dev);
+	pci_disable_msi(pdev);
+	pci_iounmap(pdev, hw->mem_addr);
+	heci_pci_device = NULL;
+	flush_scheduled_work();
+	pci_set_drvdata(pdev, NULL);
+	heci_deregister(dev);
+	kfree(dev);
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+}
+
+#define HECI_ISH_PM_OPS	NULL
+
+/*
+ *  PCI driver structure
+ */
+static struct pci_driver ish_driver = {
+	.name = KBUILD_MODNAME,
+	.id_table = ish_pci_tbl,
+	.probe = ish_probe,
+	.remove = ish_remove,
+	.shutdown = ish_remove,
+	.driver.pm = HECI_ISH_PM_OPS,
+};
+
+module_pci_driver(ish_driver);
+
+MODULE_AUTHOR("Intel Corporation");
+MODULE_DESCRIPTION("Intel(R) Integrated Sensor Hub IPC");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/misc/heci/platform-config.h b/drivers/misc/heci/platform-config.h
new file mode 100644
index 0000000..43ff745
--- /dev/null
+++ b/drivers/misc/heci/platform-config.h
@@ -0,0 +1,119 @@
+/*
+ * ISH platform-specific definitions
+ *
+ * Copyright (c) 2012-2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef PLATFORM_CONFIG__H
+#define PLATFORM_CONFIG__H
+
+/* Build ID string */
+#define	BUILD_ID	"0110-imin-support-fixed-hid-client-init"
+
+#define	ISH_DEBUG	0
+#if ISH_DEBUG
+#define	ISH_DBG_PRINT	printk
+#else
+#define	ISH_DBG_PRINT	no_printk
+#endif
+
+#define	ISH_INFO	1
+#if ISH_INFO
+#define	ISH_INFO_PRINT	printk
+#else
+#define	ISH_INFO_PRINT	no_printk
+#endif
+
+#define ISH_LOG		1
+
+#if 0
+/* Define if running on VirtualBox - may solve imprecise timer emulation problems */
+#define	HOST_VIRTUALBOX	1
+#endif
+
+#if 0
+/* Timer-polling workaround for DUTs with non-functional interrupts reporting */
+#define	TIMER_POLLING	1
+#endif
+
+#define	REVISION_ID_CHT_A0	0x6
+#define	REVISION_ID_CHT_A0_SI	0x0
+#define	REVISION_ID_CHT_Bx_SI	0x10
+#define	REVISION_ID_CHT_Kx_SI	0x20
+#define	REVISION_ID_CHT_B0	0xB0
+
+#define	REVISION_ID_SI_MASK	0x70
+
+/* For buggy (pre-)silicon, select model rather than retrieve it */
+#if 0
+/* If defined, will support A0 only, will not check revision ID */
+#define	SUPPORT_Ax_ONLY	1
+
+#else
+
+#if  0
+/* If defined, will support B0 only, will not check revision ID */
+#define	SUPPORT_B0_ONLY	1
+#endif
+#endif
+
+#if defined(SUPPORT_A0_ONLY) && defined (SUPPORT_B0_ONLY)
+#error Only one of SUPPORT_A0_ONLY and SUPPORT_B0_ONLY may be defined
+#endif
+
+/* D3 RCR */
+#define	D3_RCR	1
+
+/* Define in order to force FW-initated reset */
+#define	FORCE_FW_INIT_RESET	1
+
+/* Include ISH register debugger */
+#define	ISH_DEBUGGER	1
+
+/* Debug mutex locking/unlocking */
+#define	DEBUG_LOCK	0
+
+#if DEBUG_LOCK
+
+static void	do_mutex_lock(void *m)
+{
+	mutex_lock(m);
+}
+
+static void	do_mutex_unlock(void *m)
+{
+	mutex_unlock(m);
+}
+
+#ifdef mutex_lock
+#undef mutex_lock
+#endif
+#ifdef mutex_unlock
+#undef mutex_unlock
+#endif
+
+#define mutex_lock(a) \
+	do {\
+		printk(KERN_ALERT "%s:%d[%s] -- mutex_lock(%p)\n", __FILE__, __LINE__, __func__, a);	\
+		do_mutex_lock(a);	\
+	} while (0)
+
+#define mutex_unlock(a) \
+	do {\
+		printk(KERN_ALERT "%s:%d[%s] -- mutex_unlock(%p)\n", __FILE__, __LINE__, __func__, a);	\
+		do_mutex_unlock(a);	\
+	} while (0)
+#endif /* DEBUG_LOCK */
+/*************************************/
+
+#endif /* PLATFORM_CONFIG__H*/
+
diff --git a/drivers/misc/heci/senscol-core.c b/drivers/misc/heci/senscol-core.c
new file mode 100644
index 0000000..ef489d8
--- /dev/null
+++ b/drivers/misc/heci/senscol-core.c
@@ -0,0 +1,867 @@
+/*
+ * Sensor collection framework core
+ */
+
+#include <linux/module.h>
+#include <linux/senscol/senscol-core.h>
+#include <linux/platform_device.h>
+#include <linux/kobject.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include "hid-strings-def.h"
+#include "platform-config.h"
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+
+
+/***** DEBUG *****/
+void g_ish_print_log(char *format, ...);
+/*****************/
+
+
+struct list_head	senscol_impl_list;
+struct list_head	senscol_sensors_list;
+spinlock_t	senscol_lock;
+spinlock_t	senscol_data_lock;
+uint8_t	*senscol_data_buf;
+unsigned	senscol_data_head, senscol_data_tail;
+
+static ssize_t	sc_data_show(struct kobject *kobj, struct attribute *attr, char *buf);
+static ssize_t	sc_data_store(struct kobject *kobj, struct attribute *attr, const char *buf, size_t size);
+static ssize_t	sensors_data_read(struct file *f, struct kobject *kobj, struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size);
+static ssize_t	sensors_data_write(struct file *f, struct kobject *kobj, struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size);
+static ssize_t	sc_sensdef_show(struct kobject *kobj, struct attribute *attr, char *buf);
+static ssize_t	sc_sensdef_store(struct kobject *kobj, struct attribute *attr, const char *buf, size_t size);
+
+static struct platform_device	*sc_pdev;
+
+wait_queue_head_t senscol_read_wait;
+
+const char *senscol_usage_to_name(unsigned usage)
+{
+	int i;
+
+	for (i = 0; code_msg_arr[i].msg && code_msg_arr[i].code != usage; i++)
+		;
+	return	code_msg_arr[i].msg;
+}
+EXPORT_SYMBOL(senscol_usage_to_name);
+
+
+unsigned senscol_name_to_usage(const char *name)
+{
+	int i;
+
+	for (i = 0; code_msg_arr[i].msg && strcmp(code_msg_arr[i].msg, name) != 0; ++i)
+		;
+	return	code_msg_arr[i].code;
+}
+EXPORT_SYMBOL(senscol_name_to_usage);
+
+
+const char	*senscol_get_modifier(unsigned modif)
+{
+	uint32_t to4bits = modif >> 0xC;
+	return	modifiers[to4bits];
+}
+EXPORT_SYMBOL(senscol_get_modifier);
+
+
+
+#if 0
+/*
+ * data kobject attributes and handlers
+ */
+
+static struct attribute	sc_data_defattr_event = {
+	.name = "event",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute	*sc_data_defattrs[] = {
+	&sc_data_defattr_event,
+	NULL
+};
+#endif
+
+static void	sc_data_release(struct kobject *k)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+}
+
+static ssize_t	sc_data_show(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s'\n", __func__, attr->name);
+	sprintf(buf, "%s\n", attr->name);
+	return	strlen(buf);
+}
+
+static ssize_t	sc_data_store(struct kobject *kobj, struct attribute *attr, const char *buf, size_t size)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s' buf='%s' size=%u\n", __func__, attr->name, buf, (unsigned)size);
+	return	size;
+}
+
+struct sysfs_ops	sc_data_sysfs_fops = {
+	.show = sc_data_show,
+	.store = sc_data_store
+};
+
+struct kobj_type	sc_data_kobj_type = {
+	.release = sc_data_release,
+	.sysfs_ops = &sc_data_sysfs_fops
+	/*.default_attrs = sc_data_defattrs*/
+};
+
+struct bin_attribute	sensors_data_binattr = {
+	.attr = {
+		.name = "sensors_data",
+		.mode = S_IRUGO
+	},
+	.size = 0,
+	.read = sensors_data_read,
+	.write = sensors_data_write
+};
+
+struct kobject	sc_data_kobj;
+
+/*****************************************/
+
+
+/*
+ * sensor_def kobject type and handlers
+ */
+static struct attribute	sc_sensdef_defattr_name = {
+	.name = "name",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_sensdef_defattr_type = {
+	.name = "type",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_sensdef_defattr_id = {
+	.name = "id",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_sensdef_defattr_usage_id = {
+	.name = "usage_id",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_sensdef_defattr_sample_size = {
+	.name = "sample_size",
+	.mode = (S_IRUGO)
+};
+
+struct attribute	*sc_sensdef_defattrs[] = {
+	&sc_sensdef_defattr_name,
+	&sc_sensdef_defattr_type,
+	&sc_sensdef_defattr_id,
+	&sc_sensdef_defattr_usage_id,
+	&sc_sensdef_defattr_sample_size,
+	NULL
+};
+
+static void	sc_sensdef_release(struct kobject *k)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+}
+
+static ssize_t	sc_sensdef_show(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	ssize_t	rv;
+	struct sensor_def	*sensdef;
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s'\n", __func__, attr->name);
+	sensdef = container_of(kobj, struct sensor_def, kobj);
+	buf[0] = '\0';
+	if (!strcmp(attr->name, "id"))
+		sprintf(buf, "%08X\n", sensdef->id);
+	else if (!strcmp(attr->name, "sample_size"))
+		sprintf(buf, "%u\n", sensdef->sample_size);
+	else if (!strcmp(attr->name, "usage_id"))
+		sprintf(buf, "%08X\n", sensdef->usage_id);
+	else if (!strcmp(attr->name, "name"))
+		sprintf(buf, "%s\n", sensdef->name);
+
+	rv = strlen(buf) + 1;
+	return	rv;
+}
+
+static ssize_t	sc_sensdef_store(struct kobject *kobj, struct attribute *attr, const char *buf, size_t size)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+	return	-EINVAL;
+}
+struct sysfs_ops	sc_sensdef_sysfs_fops = {
+	.show = sc_sensdef_show,
+	.store = sc_sensdef_store
+};
+
+struct kobj_type	sc_sensdef_kobj_type = {
+	.release = sc_sensdef_release,
+	.sysfs_ops = &sc_sensdef_sysfs_fops,
+	.default_attrs = sc_sensdef_defattrs
+};
+/*****************************************/
+
+/*
+ * kobject type for empty sub-directories
+ */
+static struct attribute	*sc_subdir_defattrs[] = {
+	NULL
+};
+
+static void	sc_subdir_release(struct kobject *k)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+}
+
+static ssize_t	sc_subdir_show(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+	return	-EINVAL;
+}
+
+static ssize_t	sc_subdir_store(struct kobject *kobj, struct attribute *attr, const char *buf, size_t size)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+	return	-EINVAL;
+}
+
+struct sysfs_ops	sc_subdir_sysfs_fops = {
+	.show = sc_subdir_show,
+	.store = sc_subdir_store
+};
+
+struct kobj_type	sc_subdir_kobj_type = {
+	.release = sc_subdir_release,
+	.sysfs_ops = &sc_subdir_sysfs_fops,
+	.default_attrs = sc_subdir_defattrs
+};
+/*****************************************/
+
+/*
+ * sensors 'data_field's kobject type
+ */
+static struct attribute	sc_datafield_defattr_usage_id = {
+	.name = "usage_id",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute	sc_datafield_defattr_exp = {
+	.name = "exponent",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_datafield_defattr_len = {
+	.name = "length",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_datafield_defattr_unit = {
+	.name = "unit",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_datafield_defattr_index = {
+	.name = "index",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute	sc_datafield_defattr_is_numeric = {
+	.name = "is_numeric",
+	.mode = (S_IRUGO)
+};
+
+struct attribute	*sc_datafield_defattrs[] = {
+	&sc_datafield_defattr_usage_id,
+	&sc_datafield_defattr_exp,
+	&sc_datafield_defattr_len,
+	&sc_datafield_defattr_unit,
+	&sc_datafield_defattr_index,
+	&sc_datafield_defattr_is_numeric,
+	NULL
+};
+
+static void	sc_datafield_release(struct kobject *k)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+}
+
+static ssize_t	sc_datafield_show(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	ssize_t	rv;
+	struct data_field	*dfield;
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s'\n", __func__, attr->name);
+	dfield = container_of(kobj, struct data_field, kobj);
+	if (!strcmp(attr->name, "usage_id"))
+		sprintf(buf, "%08X\n", (unsigned)dfield->usage_id);
+	else if (!strcmp(attr->name, "exponent"))
+		sprintf(buf, "%u\n", (unsigned)dfield->exp);
+	else if (!strcmp(attr->name, "length"))
+		sprintf(buf, "%u\n", (unsigned)dfield->len);
+	else if (!strcmp(attr->name, "unit"))
+		sprintf(buf, "%u\n", (unsigned)dfield->unit);
+	else if (!strcmp(attr->name, "index"))
+		sprintf(buf, "%u\n", (unsigned)dfield->index);
+	else if (!strcmp(attr->name, "is_numeric"))
+		sprintf(buf, "%u\n", (unsigned)dfield->is_numeric);
+
+	rv = strlen(buf) + 1;
+	return	rv;
+}
+
+static ssize_t	sc_datafield_store(struct kobject *kobj, struct attribute *attr, const char *buf, size_t size)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s' buf='%s' size=%u\n", __func__, attr->name, buf, (unsigned)size);
+	return	-EINVAL;
+}
+
+struct sysfs_ops	sc_datafield_sysfs_fops = {
+	.show = sc_datafield_show,
+	.store = sc_datafield_store
+};
+
+struct kobj_type	sc_datafield_kobj_type = {
+	.release = sc_datafield_release,
+	.sysfs_ops = &sc_datafield_sysfs_fops,
+	.default_attrs = sc_datafield_defattrs
+};
+/*****************************************/
+
+
+/*
+ * sensors 'properties' kobject type
+ */
+static struct attribute	sc_sensprop_defattr_unit = {
+	.name = "unit",
+	.mode = (S_IRUGO | S_IWUSR | S_IWGRP)
+};
+
+static struct attribute sc_sensprop_defattr_value = {
+	.name = "value",
+	.mode = (S_IRUGO | S_IWUSR | S_IWGRP)
+};
+
+struct attribute	*sc_sensprop_defattrs[] = {
+	&sc_sensprop_defattr_unit,
+	&sc_sensprop_defattr_value,
+	NULL
+};
+
+static void	sc_sensprop_release(struct kobject *k)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+}
+
+static ssize_t	sc_sensprop_show(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	struct sens_property	*pfield;
+	struct sensor_def	*sensor;
+
+	/* We need "property_power_state" (=2), "property_reporting_state" (=2) and "property_report_interval" (in ms?) */
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s'\n", __func__, attr->name);
+	pfield = container_of(kobj, struct sens_property, kobj);
+	sensor = pfield->sensor;
+	sensor->impl->get_sens_property(sensor, pfield, buf, 0x1000);
+
+	return	strlen(buf);
+}
+
+static ssize_t	sc_sensprop_store(struct kobject *kobj, struct attribute *attr, const char *buf, size_t size)
+{
+	struct sens_property	*pfield;
+	struct sensor_def	*sensor;
+
+	/* TODO: stream down set property request and return size upon successful completion or error code */
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s' buf='%s' size=%u\n", __func__, attr->name, buf, (unsigned)size);
+	pfield = container_of(kobj, struct sens_property, kobj);
+	sensor = pfield->sensor;
+	sensor->impl->set_sens_property(sensor, pfield, buf);
+
+	return	size;
+}
+
+struct sysfs_ops	sc_sensprop_sysfs_fops = {
+	.show = sc_sensprop_show,
+	.store = sc_sensprop_store
+};
+
+struct kobj_type	sc_sensprop_kobj_type = {
+	.release = sc_sensprop_release,
+	.sysfs_ops = &sc_sensprop_sysfs_fops,
+	.default_attrs = sc_sensprop_defattrs
+};
+/*****************************************/
+
+static ssize_t	sensors_data_read(struct file *f, struct kobject *kobj, struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size)
+{
+	size_t	count;
+	unsigned	cur;
+	struct senscol_sample	*sample;
+	unsigned long	flags;
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+
+	if (size > PAGE_SIZE)
+		size = PAGE_SIZE;
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): >>> offs=%u size=%u senscol_data_head=%u senscol_data_tail=%u\n", __func__, (unsigned)offs, (unsigned)size, (unsigned)senscol_data_head, (unsigned)senscol_data_tail);
+
+	spin_lock_irqsave(&senscol_data_lock, flags);
+
+	/* Count how much we may copy, keeping whole samples. Copy samples along the way */
+	count = 0;
+	cur = senscol_data_head;
+	while (cur != senscol_data_tail) {
+		sample = (struct senscol_sample *)(senscol_data_buf + cur);
+		if (count + sample->size > size)
+			break;
+		memcpy(buf + count, sample, sample->size);
+		count += sample->size;
+		cur += sample->size;
+		if (cur > SENSCOL_DATA_BUF_LAST)
+			cur = 0;
+	}
+	senscol_data_head = cur;
+
+	spin_unlock_irqrestore(&senscol_data_lock, flags);
+
+	if (count) {
+		ISH_DBG_PRINT(KERN_ALERT "[senscol]: <<< %s(): senscol_data_head=%u senscol_data_tail=%u\n", __func__, senscol_data_head, senscol_data_tail);
+		ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): returning count=%u\n", __func__, (unsigned)count);
+	}
+
+	return	count;
+}
+
+static ssize_t	sensors_data_write(struct file *f, struct kobject *kobj, struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+	return	-EINVAL;
+}
+
+int	add_senscol_impl(struct senscol_impl *impl)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&senscol_lock, flags);
+	list_add_tail(&impl->link, &senscol_impl_list);
+	spin_unlock_irqrestore(&senscol_lock, flags);
+	return	0;
+}
+EXPORT_SYMBOL(add_senscol_impl);
+
+int	remove_senscol_impl(struct senscol_impl *impl)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&senscol_lock, flags);
+	list_del(&impl->link);
+	spin_unlock_irqrestore(&senscol_lock, flags);
+	return	0;
+}
+EXPORT_SYMBOL(remove_senscol_impl);
+
+/* Only allocates new sensor */
+struct sensor_def *alloc_senscol_sensor(void)
+{
+	struct sensor_def *sens;
+
+	sens = kzalloc(sizeof(struct sensor_def), GFP_KERNEL);
+	return	sens;
+}
+EXPORT_SYMBOL(alloc_senscol_sensor);
+
+/* Init sensor (don't call for initialized sensors */
+void	init_senscol_sensor(struct sensor_def *sensor)
+{
+	if (!sensor)
+		return;
+
+	memset(sensor, 0, sizeof(*sensor));
+	sensor->name = NULL;
+	sensor->friendly_name = NULL;
+	sensor->impl = NULL;
+	sensor->data_fields = NULL;
+	sensor->properties = NULL;
+}
+EXPORT_SYMBOL(init_senscol_sensor);
+
+/*
+ * Exposed sensor via sysfs, structure may be static
+ *
+ * The caller is responsible for setting all meaningful fields (may call add_data_field() and add_sens_property() as needed)
+ * We'll consider hiding senscol framework-specific fields into opaque structures
+ */
+
+int	add_senscol_sensor(struct sensor_def *sensor)
+{
+	unsigned long	flags;
+	char	sensor_name[256];	/* Enough for name "sensor_<NN>_def", if convention changes array size should be reviewed */
+	int	i;
+	int	rv;
+
+	if (!sensor->name || !sensor->impl || !sensor->usage_id || !sensor->id)
+		return	-EINVAL;
+
+	spin_lock_irqsave(&senscol_lock, flags);
+	list_add_tail(&sensor->link, &senscol_sensors_list);
+	spin_unlock_irqrestore(&senscol_lock, flags);
+
+	/*
+	 * Create sysfs entries for this sensor
+	 */
+
+	/* Init and add sensor_def kobject */
+	sprintf(sensor_name, "sensor_%X_def", sensor->id);
+	rv = kobject_init_and_add(&sensor->kobj, &sc_sensdef_kobj_type, &sc_pdev->dev.kobj, sensor_name);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): kobject_init_and_add() for 'data' returned %d\n", __func__, rv);
+	if (rv) {
+		rv = -EFAULT;
+err_ret:
+		kobject_put(&sensor->kobj);
+		kobject_del(&sensor->kobj);
+		return	rv;
+	}
+
+/* Special attribute "friendly_name" is retired in favor of generic property "property_friendly_name" */
+#if 0
+	/* If freiendly_name is given, add such attribute */
+	memset(&attr, 0, sizeof(struct attribute));
+	attr.name = "friendly_name";
+	attr.mode = S_IRUGO;
+	rv = sysfs_create_file(&sensor->kobj, &attr);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): sysfs_create_file() for 'friendly_name' returned %d\n", __func__, rv);
+#endif
+
+	/* Create kobjects without attributes for sensor_<NN>_def/data_fields and sensor_<NN>/properties */
+	rv = kobject_init_and_add(&sensor->data_fields_kobj, &sc_subdir_kobj_type, &sensor->kobj, "data_fields");
+	if (rv) {
+		rv = -EFAULT;
+err_ret2:
+		kobject_put(&sensor->data_fields_kobj);
+		kobject_del(&sensor->data_fields_kobj);
+		goto	err_ret;
+	}
+
+	rv = kobject_init_and_add(&sensor->props_kobj, &sc_subdir_kobj_type, &sensor->kobj, "properties");
+	if (rv) {
+		rv = -EFAULT;
+		kobject_put(&sensor->props_kobj);
+		kobject_del(&sensor->props_kobj);
+		goto	err_ret2;
+	}
+
+	/*
+	 * Create kobjects for data_fields
+	 */
+
+	for (i = 0; i < sensor->num_data_fields; ++i) {
+		if (sensor->data_fields[i].name) {
+			/* Mark index */
+			sensor->data_fields[i].index = i;
+			rv = kobject_init_and_add(&sensor->data_fields[i].kobj, &sc_datafield_kobj_type, &sensor->data_fields_kobj, sensor->data_fields[i].name);
+			ISH_DBG_PRINT(KERN_ALERT "%s(): kobject_init_and_add() for data_field '%s' returned %d\n", __func__, sensor->data_fields[i].name, rv);
+		}
+	}
+	ISH_DBG_PRINT(KERN_ALERT "%s(): sample_size=%u\n", __func__, sensor->sample_size);
+
+	/*
+	 * Create kobjects for properties
+	 */
+	for (i = 0; i < sensor->num_properties; ++i) {
+		if (sensor->properties[i].name) {
+			rv = kobject_init_and_add(&sensor->properties[i].kobj, &sc_sensprop_kobj_type, &sensor->props_kobj, sensor->properties[i].name);
+			ISH_DBG_PRINT(KERN_ALERT "%s(): kobject_init_and_add() for property '%s' returned %d\n", __func__, sensor->properties[i].name, rv);
+		}
+	}
+
+	/* Sample size should be set by the caller to size of raw data */
+	sensor->sample_size += offsetof(struct senscol_sample, data);
+
+	return	0;
+}
+EXPORT_SYMBOL(add_senscol_sensor);
+
+struct sensor_def	*get_senscol_sensor_by_name(const char *name)
+{
+	struct sensor_def	*sens, *next;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&senscol_lock, flags);
+	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
+		if (!strcmp(sens->name, name)) {
+			spin_unlock_irqrestore(&senscol_lock, flags);
+			return	sens;
+		}
+	}
+
+	spin_unlock_irqrestore(&senscol_lock, flags);
+	return	NULL;
+}
+EXPORT_SYMBOL(get_senscol_sensor_by_name);
+
+struct sensor_def	*get_senscol_sensor_by_id(uint32_t id)
+{
+	struct sensor_def	*sens, *next;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&senscol_lock, flags);
+	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
+		if (sens->id == id) {
+			spin_unlock_irqrestore(&senscol_lock, flags);
+			return	sens;
+		}
+	}
+
+	spin_unlock_irqrestore(&senscol_lock, flags);
+	return	NULL;
+}
+EXPORT_SYMBOL(get_senscol_sensor_by_id);
+
+/* Add data field to existing sensor */
+int	add_data_field(struct sensor_def *sensor, struct data_field *data)
+{
+	struct data_field	*temp;
+
+	temp = krealloc(sensor->data_fields, (sensor->num_data_fields + 1) * sizeof(struct data_field), GFP_KERNEL);
+	if (!temp)
+		return	-ENOMEM;
+
+	data->sensor = sensor;
+	memcpy(&temp[sensor->num_data_fields++], data, sizeof(struct data_field));
+	sensor->data_fields = temp;
+	return	0;
+}
+EXPORT_SYMBOL(add_data_field);
+
+/* Add property to existing sensor */
+int	add_sens_property(struct sensor_def *sensor, struct sens_property *prop)
+{
+	struct sens_property	*temp;
+
+	temp = krealloc(sensor->properties, (sensor->num_properties + 1) * sizeof(struct sens_property), GFP_KERNEL);
+	if (!temp)
+		return	-ENOMEM;
+
+	prop->sensor = sensor;		/* The needed backlink */
+	memcpy(&temp[sensor->num_properties++], prop, sizeof(struct sens_property));
+	sensor->properties = temp;
+	return	0;
+}
+EXPORT_SYMBOL(add_sens_property);
+
+/*
+ * Push data sample in upstream buffer towards user-mode. Sample's size is determined from the structure
+ *
+ * Samples are queued is a simple FIFO binary buffer with head and tail pointers.
+ * Additional fields if wanted to be communicated to user mode can be defined
+ *
+ * Returns 0 on success, negative error code on error
+ */
+int	push_sample(uint32_t id, void *sample)
+{
+	struct sensor_def	*sensor;
+	unsigned long flags;
+	unsigned char	sample_buf[1024];
+	struct senscol_sample	*p_sample = (struct senscol_sample *)sample_buf;
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+
+	if (!senscol_data_buf)
+		return	-ENOMEM;
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): senscol_data_buf=%p\n", __func__, senscol_data_buf);
+
+	sensor = get_senscol_sensor_by_id(id);
+	if (!sensor)
+		return	-ENODEV;
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): sensor=%p\n", __func__, sensor);
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): senscol_data_head=%u senscol_data_tail=%u sample_size=%u\n", __func__, senscol_data_head, senscol_data_tail, sensor->sample_size);
+
+	spin_lock_irqsave(&senscol_data_lock, flags);
+
+	/* TBD: when buffer overflows we may choose to drop the new data or oldest data. */
+	/* Here we drop the new data */
+	if (senscol_data_head != senscol_data_tail && (senscol_data_head - senscol_data_tail) % SENSCOL_DATA_BUF_SIZE <= sensor->sample_size) {
+		spin_unlock_irqrestore(&senscol_data_lock, flags);
+		ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): dropping sample, senscol_data_head=%u senscol_data_tail=%u sample size=%u\n", __func__, senscol_data_head, senscol_data_tail, sensor->sample_size);
+		return	-ENOMEM;
+	}
+
+	p_sample->id = id;
+	p_sample->size = sensor->sample_size;
+	memcpy(p_sample->data, sample, sensor->sample_size - offsetof(struct senscol_sample, data));
+#if 0
+	ISH_DBG_PRINT(KERN_ALERT "%s(): pushing to buffer, sample_size=%u[%u]\n", __func__, sensor->sample_size, p_sample->size);
+
+	/***** DEBUG - dump sample ******/
+	do {
+		int	i;
+		char	buf[4096];
+
+		sprintf(buf,  "%s(): sample dump [id=%u size=%u] -- ", __func__, p_sample->id, p_sample->size);
+		for (i = 0; i < p_sample->size; ++i)
+			sprintf(buf + strlen(buf),  "%02X ", (unsigned)p_sample->data[i]);
+		ISH_DBG_PRINT(KERN_ALERT "%s\n", buf);
+	} while (0);
+	/********************************/
+#endif
+	memcpy(senscol_data_buf + senscol_data_tail, p_sample, p_sample->size);
+	senscol_data_tail += sensor->sample_size;
+	if (senscol_data_tail > SENSCOL_DATA_BUF_LAST)
+		senscol_data_tail = 0;
+
+	spin_unlock_irqrestore(&senscol_data_lock, flags);
+
+	/* Fire event through "data/event" */
+	ISH_DBG_PRINT(KERN_ALERT "[senscol] %s(): firing data-ready event senscol_data_head=%u senscol_data_tail=%u id=%08X sample_size=%u\n", __func__, senscol_data_head, senscol_data_tail, p_sample->id, sensor->sample_size);
+	/***** DEBUG *****/
+	g_ish_print_log(KERN_ALERT "[senscol] %s(): firing data-ready event senscol_data_head=%u senscol_data_tail=%u id=%08X sample_size=%u\n", __func__, senscol_data_head, senscol_data_tail, p_sample->id, sensor->sample_size);
+	/*****************/
+	/*sysfs_notify(&sc_data_kobj, NULL, "event");*/
+	if (waitqueue_active(&senscol_read_wait))
+		wake_up_interruptible(&senscol_read_wait);
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():--- 0\n", __func__);
+	return	0;
+}
+EXPORT_SYMBOL(push_sample);
+
+
+static int senscol_open(struct inode *inode, struct file *file)
+{
+	return	0;
+}
+
+static int senscol_release(struct inode *inode, struct file *file)
+{
+	return	0;
+}
+
+static ssize_t senscol_read(struct file *file, char __user *ubuf, size_t length, loff_t *offset)
+{
+	return	length;
+}
+
+static ssize_t senscol_write(struct file *file, const char __user *ubuf, size_t length, loff_t *offset)
+{
+	return	length;
+}
+
+static long senscol_ioctl(struct file *file, unsigned int cmd, unsigned long data)
+{
+	return	0;
+}
+
+static unsigned int senscol_poll(struct file *file, poll_table *wait)
+{
+	unsigned int mask = 0;
+	unsigned long   flags;
+	int	rd_ready = 0;
+
+	poll_wait(file, &senscol_read_wait, wait);
+
+	/* If read buffer is empty, wait again on senscol_read_wait */
+
+	spin_lock_irqsave(&senscol_data_lock, flags);
+	rd_ready = (senscol_data_head != senscol_data_tail);
+	spin_unlock_irqrestore(&senscol_data_lock, flags);
+
+	if (rd_ready)
+		mask |= (POLLIN | POLLRDNORM);
+	/*mask |= DEFAULT_POLLMASK|POLLERR|POLLPRI;*/
+	return	mask;
+}
+
+/*
+ * file operations structure will be used for heci char device.
+ */
+static const struct file_operations senscol_fops = {
+	.owner = THIS_MODULE,
+	.read = senscol_read,
+	.unlocked_ioctl = senscol_ioctl,
+	.open = senscol_open,
+	.release = senscol_release,
+	.write = senscol_write,
+	.poll = senscol_poll,
+	.llseek = no_llseek
+};
+
+/*
+ * Misc Device Struct
+ */
+static struct miscdevice  senscol_misc_device = {
+		.name = "sensor-collection",
+		.fops = &senscol_fops,
+		.minor = MISC_DYNAMIC_MINOR,
+};
+
+
+static int __init senscol_init(void)
+{
+	int	rv;
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+
+	INIT_LIST_HEAD(&senscol_impl_list);
+	INIT_LIST_HEAD(&senscol_sensors_list);
+	spin_lock_init(&senscol_lock);
+	spin_lock_init(&senscol_data_lock);
+	init_waitqueue_head(&senscol_read_wait);
+
+	/* Init data buffer */
+	senscol_data_buf = kmalloc(SENSCOL_DATA_BUF_SIZE, GFP_KERNEL);
+	if (!senscol_data_buf)
+		return	-ENOMEM;
+	ISH_DBG_PRINT(KERN_ALERT "[senscol] %s(): allocated senscol_data_buf of size %u\n", __func__, SENSCOL_DATA_BUF_SIZE);
+
+	senscol_data_head = 0;
+	senscol_data_tail = 0;
+
+	/* Create sensor_collection platform device and default sysfs entries */
+	sc_pdev = platform_device_register_simple("sensor_collection", -1, NULL, 0);
+	if (IS_ERR(sc_pdev)) {
+		ISH_DBG_PRINT(KERN_ERR "%s(): failed to create platform device sensor_collection\n", __func__);
+		kfree(senscol_data_buf);
+		return	-ENODEV;
+	}
+
+	senscol_misc_device.parent = &sc_pdev->dev;
+	rv = misc_register(&senscol_misc_device);
+	if (rv)
+		return	rv;
+
+	rv = kobject_init_and_add(&sc_data_kobj, &sc_data_kobj_type, &sc_pdev->dev.kobj, "data");
+	ISH_DBG_PRINT(KERN_ALERT "%s(): kobject_init_and_add() for 'data' returned %d\n", __func__, rv);
+
+	rv = sysfs_create_bin_file(&sc_data_kobj, &sensors_data_binattr);
+	if (rv)
+		ISH_DBG_PRINT(KERN_ERR "%s(): sysfs_create_bin_file() for 'sensors_data' returned %d\n", __func__, rv);
+
+	return	0;
+}
+
+static void __exit senscol_exit(void)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+	kfree(senscol_data_buf);
+}
+
+
+module_init(senscol_init);
+module_exit(senscol_exit);
+
+MODULE_DESCRIPTION("Sensor Collection framework core");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/misc/heci/utils.h b/drivers/misc/heci/utils.h
new file mode 100644
index 0000000..1772f7d
--- /dev/null
+++ b/drivers/misc/heci/utils.h
@@ -0,0 +1,50 @@
+#ifndef UTILS__H
+ #define UTILS__H
+
+#define	WAIT_FOR_SEND_SLICE	(HZ / 10)
+#define	WAIT_FOR_CONNECT_SLICE	(HZ / 10)
+
+/*
+ * Waits for specified event when a thread that triggers event can't signal
+ * Also, waits *at_least* `timeinc` after condition is satisfied
+ */
+#define	timed_wait_for(timeinc, condition) \
+	do { \
+		int completed = 0; \
+		do { \
+			unsigned long	j; \
+			int	done = 0; \
+\
+			completed = (condition); \
+			for (j = jiffies, done = 0; !done; ) { \
+				schedule_timeout(timeinc); \
+				if (jiffies >= j + timeinc) \
+					done = 1; \
+			} \
+		} while (!(completed)); \
+	} while (0)
+
+
+/*
+ * Waits for specified event when a thread that triggers event can't signal with timeout (use whenever we may hang)
+ */
+#define	timed_wait_for_timeout(timeinc, condition, timeout) \
+	do { \
+		int	t = timeout; \
+		do { \
+			unsigned long	j; \
+			int	done = 0; \
+\
+			for (j = jiffies, done = 0; !done; ) { \
+				schedule_timeout(timeinc); \
+				if (jiffies >= j + timeinc) \
+					done = 1; \
+			} \
+			t -= timeinc; \
+			if (t <= 0) \
+				break; \
+		} while (!(condition)); \
+	} while (0)
+
+#endif /* UTILS__H */
+
diff --git a/include/linux/hid-sensor-ids.h b/include/linux/hid-sensor-ids.h
index 4f945d3..8676875 100644
--- a/include/linux/hid-sensor-ids.h
+++ b/include/linux/hid-sensor-ids.h
@@ -19,6 +19,8 @@
 #ifndef _HID_SENSORS_IDS_H
 #define _HID_SENSORS_IDS_H
 
+/***************************/
+
 #define HID_MAX_PHY_DEVICES					0xFF
 
 /* Accel 3D (200073) */
@@ -117,4 +119,444 @@
 #define HID_USAGE_SENSOR_PROP_REPORT_STATE			0x200316
 #define HID_USAGE_SENSOR_PROY_POWER_STATE			0x200319
 
+/**************************/
+
+
+#define HID_USAGE_SENSOR_DATA_ENVIRONMENTAL_RELATIVE_HUMIDITY 0x200433
+#define HID_USAGE_SENSOR_DATA_ENVIRONMENTAL_TEMPERATURE 0x200434
+#define HID_USAGE_SENSOR_DATA_ENVIRONMENTAL_WIND_DIRECTION 0x200435
+#define HID_USAGE_SENSOR_DATA_ENVIRONMENTAL_WIND_SPEED 0x200436
+/* property usages (get/set feature report) */
+#define HID_USAGE_SENSOR_PROPERTY_ENVIRONMENTAL 0x200440
+#define HID_USAGE_SENSOR_PROPERTY_ENVIRONMENTAL_REFERENCE_PRESSURE 0x200441
+
+/* data type motion */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_MOTION 0x200450
+#define HID_USAGE_SENSOR_DATA_MOTION_STATE 0x200451
+#define HID_USAGE_SENSOR_DATA_MOTION_ACCELERATION 0x200452
+#define HID_USAGE_SENSOR_DATA_MOTION_ACCELERATION_X_AXIS 0x200453
+#define HID_USAGE_SENSOR_DATA_MOTION_ACCELERATION_Y_AXIS 0x200454
+#define HID_USAGE_SENSOR_DATA_MOTION_ACCELERATION_Z_AXIS 0x200455
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_VELOCITY 0x200456
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_VELOCITY_X_AXIS 0x200457
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_VELOCITY_Y_AXIS 0x200458
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_VELOCITY_Z_AXIS 0x200459
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_POSITION 0x20045A
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_POSITION_X_AXIS 0x20045B
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_POSITION_Y_AXIS 0x20045C
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_POSITION_Z_AXIS 0x20045D
+#define HID_USAGE_SENSOR_DATA_MOTION_SPEED 0x20045E
+#define HID_USAGE_SENSOR_DATA_MOTION_INTENSITY 0x20045F
+
+/* data type orientation */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_ORIENTATION 0x200470
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_HEADING 0x200471
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_HEADING_X 0x200472
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_HEADING_Y 0x200473
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_HEADING_Z 0x200474
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_COMPENSATED_MAGNETIC_NORTH 0x200475
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_COMPENSATED_TRUE_NORTH 0x200476
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_NORTH 0x200477
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_TRUE_NORTH 0x200478
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE 0x200479
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE_X 0x20047A
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE_Y 0x20047B
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE_Z 0x20047C
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE_OUT_OF_RANGE 0x20047D
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_TILT 0x20047E
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_TILT_X 0x20047F
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_TILT_Y 0x200480
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_TILT_Z 0x200481
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_ROTATION_MATRIX 0x200482
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_QUATERNION 0x200483
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_FLUX 0x200484
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_FLUX_X_AXIS 0x200485
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_FLUX_Y_AXIS 0x200486
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_FLUX_Z_AXIS 0x200487
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETOMETER_ACCURACY 0x200488
+
+/* data type mechanical */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_MECHANICAL 0x200490
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_BOOLEAN_SWITCH_STATE 0x200491
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_BOOLEAN_SWITCH_ARRAY_STATES 0x200492
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_MULTIVALUE_SWITCH_VALUE 0x200493
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_FORCE 0x200494
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_ABSOLUTE_PRESSURE 0x200495
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_GAUGE_PRESSURE 0x200496
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_STRAIN 0x200497
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_WEIGHT 0x200498
+/* property usages (get/set feature report) */
+#define HID_USAGE_SENSOR_PROPERTY_MECHANICAL 0x2004A0
+#define HID_USAGE_SENSOR_PROPERTY_MECHANICAL_VIBRATION_STATE 0x2004A1
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_VIBRATION_SPEED_FORWARD 0x2004A2
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_VIBRATION_SPEED_BACKWARD 0x2004A3
+
+/* data type biometric */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_BIOMETRIC 0x2004B0
+#define HID_USAGE_SENSOR_DATA_BIOMETRIC_HUMAN_PRESENCE 0x2004B1
+#define HID_USAGE_SENSOR_DATA_BIOMETRIC_HUMAN_PROXIMITY_RANGE 0x2004B2
+#define HID_USAGE_SENSOR_DATA_BIOMETRIC_HUMAN_PROXIMITY_OUT_OF_RANGE 0x2004B3
+#define HID_USAGE_SENSOR_DATA_BIOMETRIC_HUMAN_TOUCH_STATE 0x2004B4
+
+/* data type light sensor */
+/* data field usages (input report) */
+/*#define HID_USAGE_SENSOR_DATA_LIGHT 0x2004D0*/
+#define HID_USAGE_SENSOR_DATA_LIGHT_ILLUMINANCE 0x2004D1
+#define HID_USAGE_SENSOR_DATA_LIGHT_COLOR_TEMPERATURE 0x2004D2
+#define HID_USAGE_SENSOR_DATA_LIGHT_CHROMATICITY 0x2004D3
+#define HID_USAGE_SENSOR_DATA_LIGHT_CHROMATICITY_X 0x2004D4
+#define HID_USAGE_SENSOR_DATA_LIGHT_CHROMATICITY_Y 0x2004D5
+#define HID_USAGE_SENSOR_DATA_LIGHT_CONSUMER_IR_SENTENCE_RECEIVE 0x2004D6
+/* property usages (get/set feature report) */
+#define HID_USAGE_SENSOR_PROPERTY_LIGHT 0x2004E0
+#define HID_USAGE_SENSOR_PROPERTY_LIGHT_CONSUMER_IR_SENTENCE_SEND 0x2004E1
+
+/* data type scanner */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_SCANNER 0x2004F0
+#define HID_USAGE_SENSOR_DATA_SCANNER_RFID_TAG 0x2004F1
+#define HID_USAGE_SENSOR_DATA_SCANNER_NFC_SENTENCE_RECEIVE 0x2004F2
+/* property usages (get/set feature report) */
+#define HID_USAGE_SENSOR_PROPERTY_SCANNER 0x2004F8
+#define HID_USAGE_SENSOR_PROPERTY_SCANNER_NFC_SENTENCE_SEND 0x2004F9
+
+/* data type electrical */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL 0x200500
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_CAPACITANCE 0x200501
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_CURRENT 0x200502
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_POWER 0x200503
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_INDUCTANCE 0x200504
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_RESISTANCE 0x200505
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_VOLTAGE 0x200506
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_FREQUENCY 0x200507
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_PERIOD 0x200508
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_PERCENT_OF_RANGE 0x200509
+
+/* data type time */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_TIME 0x200520
+#define HID_USAGE_SENSOR_DATA_TIME_YEAR 0x200521
+#define HID_USAGE_SENSOR_DATA_TIME_MONTH 0x200522
+#define HID_USAGE_SENSOR_DATA_TIME_DAY 0x200523
+#define HID_USAGE_SENSOR_DATA_TIME_DAY_OF_WEEK 0x200524
+#define HID_USAGE_SENSOR_DATA_TIME_HOUR 0x200525
+#define HID_USAGE_SENSOR_DATA_TIME_MINUTE 0x200526
+#define HID_USAGE_SENSOR_DATA_TIME_SECOND 0x200527
+#define HID_USAGE_SENSOR_DATA_TIME_MILLISECOND 0x200528
+#define HID_USAGE_SENSOR_DATA_TIME_TIMESTAMP 0x200529
+#define HID_USAGE_SENSOR_DATA_TIME_JULIAN_DAY_OF_YEAR 0x20052A
+/* property usages (get/set feature report) */
+#define HID_USAGE_SENSOR_PROPERTY_TIME 0x200530
+#define HID_USAGE_SENSOR_PROPERTY_TIME_TIME_ZONE_OFFSET_FROM_UTC 0x200531
+#define HID_USAGE_SENSOR_PROPERTY_TIME_TIME_ZONE_NAME 0x200532
+#define HID_USAGE_SENSOR_PROPERTY_TIME_DAYLIGHT_SAVINGS_TIME_OBSERVED 0x200533
+#define HID_USAGE_SENSOR_PROPERTY_TIME_TIME_TRIM_ADJUSTMENT 0x200534
+#define HID_USAGE_SENSOR_PROPERTY_TIME_ARM_ALARM 0x200535
+
+/* data type custom */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_CUSTOM 0x200540
+#define HID_USAGE_SENSOR_DATA_CUSTOM_USAGE 0x200541
+#define HID_USAGE_SENSOR_DATA_CUSTOM_BOOLEAN_ARRAY 0x200542
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE 0x200543
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_1 0x200544
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_2 0x200545
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_3 0x200546
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_4 0x200547
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_5 0x200548
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_6 0x200549
+
+#if 1 /* define vendor-specific (non-spec) custom datafields */
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_7 0x20054A
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_8 0x20054B
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_9 0x20054C
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_10 0x20054D
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_11 0x20054E
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_12 0x20054F
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_13 0x200550
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_14 0x200551
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_15 0x200552
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_16 0x200553
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_17 0x200554
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_18 0x200555
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_19 0x200556
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_20 0x200557
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_21 0x200558
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_22 0x200559
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_23 0x20055A
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_24 0x20055B
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_25 0x20055C
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_26 0x20055D
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_27 0x20055E
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_28 0x20055F
+#endif
+
+#define HID_DRIVER_USAGE_SENSOR_DATA_CUSTOM_HEALTH_MONITOR 0x200583
+#define HID_DRIVER_USAGE_SENSOR_DATA_CUSTOM_HEALTH_SYSTOLIC_BLOOD_PRESSURE 0x200584
+#define HID_DRIVER_USAGE_SENSOR_DATA_CUSTOM_HEALTH_DYSTOLIC_BLOOD_PRESSURE 0x200585
+#define HID_DRIVER_USAGE_SENSOR_DATA_CUSTOM_HEALTH_HEART_BEAT 0x200586
+
+/* data type generic */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_GENERIC 0x200560
+#define HID_USAGE_SENSOR_DATA_GENERIC_GUID_OR_PROPERTYKEY 0x200561
+#define HID_USAGE_SENSOR_DATA_GENERIC_CATEGORY_GUID 0x200562
+#define HID_USAGE_SENSOR_DATA_GENERIC_TYPE_GUID 0x200563
+#define HID_USAGE_SENSOR_DATA_GENERIC_EVENT_PROPERTYKEY 0x200564
+#define HID_USAGE_SENSOR_DATA_GENERIC_PROPERTY_PROPERTYKEY 0x200565
+#define HID_USAGE_SENSOR_DATA_GENERIC_DATAFIELD_PROPERTYKEY 0x200566
+#define HID_USAGE_SENSOR_DATA_GENERIC_EVENT 0x200567
+#define HID_USAGE_SENSOR_DATA_GENERIC_PROPERTY 0x200568
+#define HID_USAGE_SENSOR_DATA_GENERIC_DATAFIELD 0x200569
+#define HID_USAGE_SENSOR_DATA_ENUMERATOR_TABLE_ROW_INDEX 0x20056A
+#define HID_USAGE_SENSOR_DATA_ENUMERATOR_TABLE_ROW_COUNT 0x20056B
+#define HID_USAGE_SENSOR_DATA_GENERIC_GUID_OR_PROPERTYKEY_KIND 0x20056C
+/* begin GorPK kind selectors */
+#define HID_USAGE_SENSOR_GORPK_KIND_CATEGORY 0x2008D0
+#define HID_USAGE_SENSOR_GORPK_KIND_TYPE 0x2008D1
+#define HID_USAGE_SENSOR_GORPK_KIND_EVENT 0x2008D2
+#define HID_USAGE_SENSOR_GORPK_KIND_PROPERTY 0x2008D3
+#define HID_USAGE_SENSOR_GORPK_KIND_DATAFIELD 0x2008D4
+/* end GorPK kind selectors */
+#define HID_USAGE_SENSOR_DATA_GENERIC_GUID 0x20056D
+#define HID_USAGE_SENSOR_DATA_GENERIC_PROPERTYKEY 0x20056E
+#define HID_USAGE_SENSOR_DATA_GENERIC_TOP_LEVEL_COLLECTION_ID 0x20056F
+#define HID_USAGE_SENSOR_DATA_GENERIC_REPORT_ID 0x200570
+#define HID_USAGE_SENSOR_DATA_GENERIC_REPORT_ITEM_POSITION_INDEX 0x200571
+#define HID_USAGE_SENSOR_DATA_GENERIC_FIRMWARE_VARTYPE 0x200572
+
+/* Units */
+#define HID_USAGE_SENSOR_UNITS_NOT_SPECIFIED			0x00
+#define HID_USAGE_SENSOR_UNITS_LUX				0x01
+#define HID_USAGE_SENSOR_UNITS_KELVIN				0x01000100
+#define HID_USAGE_SENSOR_UNITS_FAHRENHEIT			0x03000100
+#define HID_USAGE_SENSOR_UNITS_PASCAL				0xF1E1
+#define HID_USAGE_SENSOR_UNITS_NEWTON				0x11E1
+#define HID_USAGE_SENSOR_UNITS_METERS_PER_SECOND		0x11F0
+#define HID_USAGE_SENSOR_UNITS_METERS_PER_SEC_SQRD		0x11E0
+#define HID_USAGE_SENSOR_UNITS_FARAD				0xE14F2000
+#define HID_USAGE_SENSOR_UNITS_AMPERE				0x01001000
+#define HID_USAGE_SENSOR_UNITS_WATT				0x21d1
+#define HID_USAGE_SENSOR_UNITS_HENRY				0x21E1E000
+#define HID_USAGE_SENSOR_UNITS_OHM				0x21D1E000
+#define HID_USAGE_SENSOR_UNITS_VOLT				0x21D1F000
+#define HID_USAGE_SENSOR_UNITS_HERTZ				0x01F0
+#define HID_USAGE_SENSOR_UNITS_DEGREES_PER_SEC_SQRD		0x14E0
+#define HID_USAGE_SENSOR_UNITS_RADIANS				0x12
+#define HID_USAGE_SENSOR_UNITS_RADIANS_PER_SECOND		0x12F0
+#define HID_USAGE_SENSOR_UNITS_RADIANS_PER_SEC_SQRD		0x12E0
+#define HID_USAGE_SENSOR_UNITS_SECOND				0x0110
+#define HID_USAGE_SENSOR_UNITS_GAUSS				0x01E1F000
+#define HID_USAGE_SENSOR_UNITS_GRAM				0x0101
+#define HID_USAGE_SENSOR_UNITS_CENTIMETER			0x11
+#define HID_USAGE_SENSOR_UNITS_G				0x1A
+#define HID_USAGE_SENSOR_UNITS_MILLISECOND			0x19
+#define HID_USAGE_SENSOR_UNITS_PERCENT				0x17
+#define HID_USAGE_SENSOR_UNITS_DEGREES				0x14
+#define HID_USAGE_SENSOR_UNITS_DEGREES_PER_SECOND		0x15
+
+/* Modifiers (Mask of 0xF000 to data field number )*/
+#define HID_USAGE_SENSOR_MODIFIER_NONE				0x0000
+#define HID_USAGE_SENSOR_MODIFIER_CHG_SENSITIVITY_ABS		0x1000
+#define HID_USAGE_SENSOR_MODIFIER_MAX				0x2000
+#define HID_USAGE_SENSOR_MODIFIER_MIN				0x3000
+#define HID_USAGE_SENSOR_MODIFIER_ACCURACY			0x4000
+#define HID_USAGE_SENSOR_MODIFIER_RESOLUTION			0x5000
+#define HID_USAGE_SENSOR_MODIFIER_THRES_HIGH			0x6000
+#define HID_USAGE_SENSOR_MODIFIER_THRES_LOW			0x7000
+#define HID_USAGE_SENSOR_MODIFIER_CALIBRATION_OFFSET		0x8000
+#define HID_USAGE_SENSOR_MODIFIER_CALIBRATION_MULTIPLIER	0x9000
+#define HID_USAGE_SENSOR_MODIFIER_REPORT_INTERVAL		0xA000
+#define HID_USAGE_SENSOR_MODIFIER_FREQ_MAX			0xB000
+#define HID_USAGE_SENSOR_MODIFIER_PERIOD_MAX			0xC000
+#define HID_USAGE_SENSOR_MODIFIER_CHG_SENSITIVITY_PERCENT_RANGE	0xD000
+#define HID_USAGE_SENSOR_MODIFIER_CHG_SENSITIVITY_PERCENT_REL	0xE000
+
+/*state usages*/
+#define HID_USAGE_SENSOR_STATE 0x200201
+/* state selectors */
+#define HID_USAGE_SENSOR_STATE_UNKNOWN_SEL 0x200800
+#define HID_USAGE_SENSOR_STATE_READY_SEL 0x200801
+#define HID_USAGE_SENSOR_STATE_NOT_AVAILABLE_SEL 0x200802
+#define HID_USAGE_SENSOR_STATE_NO_DATA_SEL 0x200803
+#define HID_USAGE_SENSOR_STATE_INITIALIZING_SEL 0x200804
+#define HID_USAGE_SENSOR_STATE_ACCESS_DENIED_SEL 0x200805
+#define HID_USAGE_SENSOR_STATE_ERROR_SEL 0x200806
+
+/* state enums */
+#define HID_USAGE_SENSOR_STATE_UNKNOWN_ENUM                                             0x01
+#define HID_USAGE_SENSOR_STATE_READY_ENUM                                               0x02
+#define HID_USAGE_SENSOR_STATE_NOT_AVAILABLE_ENUM                                       0x03
+#define HID_USAGE_SENSOR_STATE_NO_DATA_ENUM                                             0x04
+#define HID_USAGE_SENSOR_STATE_INITIALIZING_ENUM                                        0x05
+#define HID_USAGE_SENSOR_STATE_ACCESS_DENIED_ENUM                                       0x06
+#define HID_USAGE_SENSOR_STATE_ERROR_ENUM                                               0x07
+
+
+/* event usages */
+#define HID_USAGE_SENSOR_EVENT 0x200202
+/* event selectors */
+#define HID_USAGE_SENSOR_EVENT_UNKNOWN_SEL 0x200810
+#define HID_USAGE_SENSOR_EVENT_STATE_CHANGED_SEL 0x200811
+#define HID_USAGE_SENSOR_EVENT_PROPERTY_CHANGED_SEL 0x200812
+#define HID_USAGE_SENSOR_EVENT_DATA_UPDATED_SEL 0x200813
+#define HID_USAGE_SENSOR_EVENT_POLL_RESPONSE_SEL 0x200814
+#define HID_USAGE_SENSOR_EVENT_CHANGE_SENSITIVITY_SEL 0x200815
+#define HID_USAGE_SENSOR_EVENT_MAX_REACHED_SEL 0x200816
+#define HID_USAGE_SENSOR_EVENT_MIN_REACHED_SEL 0x200817
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_UPWARD_SEL 0x200818
+#define HID_USAGE_SENSOR_EVENT_HIGH_THESHOLD_CROSS_ABOVE_SEL        HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_UPWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_DOWNWARD_SEL 0x200819
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_BELOW_SEL       HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_DOWNWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_UPWARD_SEL 0x20081A
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_ABOVE_SEL        HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_UPWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_DOWNWARD_SEL 0x20081B
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_BELOW_SEL        HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_DOWNWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_UPWARD_SEL 0x20081C
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_ABOVE_SEL       HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_UPWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_DOWNWARD_SEL 0x20081D
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_BELOW_SEL       HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_DOWNWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_PERIOD_EXCEEDED_SEL 0x20081E
+#define HID_USAGE_SENSOR_EVENT_FREQUENCY_EXCEEDED_SEL 0x20081F
+#define HID_USAGE_SENSOR_EVENT_COMPLEX_TRIGGER_SEL 0x200820
+
+/* event enums */
+#define HID_USAGE_SENSOR_EVENT_UNKNOWN_ENUM                                             0x01
+#define HID_USAGE_SENSOR_EVENT_STATE_CHANGED_ENUM                                       0x02
+#define HID_USAGE_SENSOR_EVENT_PROPERTY_CHANGED_ENUM                                    0x03
+#define HID_USAGE_SENSOR_EVENT_DATA_UPDATED_ENUM                                        0x04
+#define HID_USAGE_SENSOR_EVENT_POLL_RESPONSE_ENUM                                       0x05
+#define HID_USAGE_SENSOR_EVENT_CHANGE_SENSITIVITY_ENUM                                  0x06
+#define HID_USAGE_SENSOR_EVENT_MAX_REACHED_ENUM                                         0x07
+#define HID_USAGE_SENSOR_EVENT_MIN_REACHED_ENUM                                         0x08
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_UPWARD_ENUM 0x200009
+#define HID_USAGE_SENSOR_EVENT_HIGH_THESHOLD_CROSS_ABOVE_ENUM   HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_UPWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_DOWNWARD_ENUM 0x200A0x
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_BELOW_ENUM  HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_DOWNWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_UPWARD_ENUM                          0x0B
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_ABOVE_ENUM   HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_UPWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_DOWNWARD_ENUM                        0x0C
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_BELOW_ENUM   HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_DOWNWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_UPWARD_ENUM                         0x0D
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_ABOVE_ENUM  HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_UPWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_DOWNWARD_ENUM                       0x0E
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_BELOW_ENUM  HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_DOWNWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_PERIOD_EXCEEDED_ENUM                                     0x0F
+#define HID_USAGE_SENSOR_EVENT_FREQUENCY_EXCEEDED_ENUM                                  0x10
+#define HID_USAGE_SENSOR_EVENT_COMPLEX_TRIGGER_ENUM                                     0x11
+
+
+/* property usages (get/set feature report) */
+#define HID_USAGE_SENSOR_PROPERTY 0x200300
+#define HID_USAGE_SENSOR_PROPERTY_FRIENDLY_NAME 0x200301
+#define HID_USAGE_SENSOR_PROPERTY_PERSISTENT_UNIQUE_ID 0x200302
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_STATUS 0x200303
+#define HID_USAGE_SENSOR_PROPERTY_MINIMUM_REPORT_INTERVAL 0x200304
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_MANUFACTURER 0x200305
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_MODEL 0x200306
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_SERIAL_NUMBER 0x200307
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_DESCRIPTION 0x200308
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_CONNECTION_TYPE 0x200309
+/* begin connection type selectors */
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_INTEGRATED_SEL 0x200830
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_ATTACHED_SEL 0x200831
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_EXTERNAL_SEL 0x200832
+/* end connection type selectors */
+
+/* begin connection type enums */
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_INTEGRATED_ENUM                    0x01
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_ATTACHED_ENUM                      0x02
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_EXTERNAL_ENUM                      0x03
+/* end connection type enums */
+
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_DEVICE_PATH 0x20030A
+#define HID_USAGE_SENSOR_PROPERTY_HARDWARE_REVISION 0x20030B
+#define HID_USAGE_SENSOR_PROPERTY_FIRMWARE_VERSION 0x20030C
+#define HID_USAGE_SENSOR_PROPERTY_RELEASE_DATE 0x20030D
+#define HID_USAGE_SENSOR_PROPERTY_REPORT_INTERVAL 0x20030E
+#define HID_USAGE_SENSOR_PROPERTY_CHANGE_SENSITIVITY_ABS 0x20030F
+#define HID_USAGE_SENSOR_PROPERTY_CHANGE_SENSITIVITY_RANGE_PCT 0x200310
+#define HID_USAGE_SENSOR_PROPERTY_CHANGE_SENSITIVITY_REL_PCT 0x200311
+#define HID_USAGE_SENSOR_PROPERTY_ACCURACY 0x200312
+#define HID_USAGE_SENSOR_PROPERTY_RESOLUTION 0x200313
+#define HID_USAGE_SENSOR_PROPERTY_RANGE_MAXIMUM 0x200314
+#define HID_USAGE_SENSOR_PROPERTY_RANGE_MINIMUM 0x200315
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE 0x200316
+
+/* begin reporting state selectors */
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_SEL 0x200840
+#define HID_USAGE_REPORTING_STATE_ON_NONE_SEL       HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_SEL
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_SEL 0x200841
+#define HID_USAGE_REPORTING_STATE_ON_ALL_SEL        HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_SEL
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_SEL 0x200842
+#define HID_USAGE_REPORTING_STATE_ON_THRESHOLD_SEL  HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_SEL
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_WAKE_SEL 0x200843
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_WAKE_SEL 0x200844
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_WAKE_SEL 0x200845
+/* end reporting state selectors */
+
+/* begin reporting state enums */
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_ENUM                        0x01
+#define HID_USAGE_REPORTING_STATE_ON_NONE_ENUM      HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_ENUM
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_ENUM                       0x02
+#define HID_USAGE_REPORTING_STATE_ON_ALL_ENUM       HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_ENUM
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_ENUM                 0x03
+#define HID_USAGE_REPORTING_STATE_ON_THRESHOLD_ENUM HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_ENUM
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_WAKE_ENUM                   0x04
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_WAKE_ENUM                  0x05
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_WAKE_ENUM            0x06
+/* end reporting state enums */
+
+#define HID_USAGE_SENSOR_PROPERTY_SAMPLING_RATE 0x200317
+#define HID_USAGE_SENSOR_PROPERTY_RESPONSE_CURVE 0x200318
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE 0x200319
+/* begin power state selectors */
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_UNDEFINED_SEL 0x200850
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D0_FULL_POWER_SEL 0x200851
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D1_LOW_POWER_SEL 0x200852
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D2_STANDBY_WITH_WAKE_SEL 0x200853
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D3_SLEEP_WITH_WAKE_SEL 0x200854
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D4_POWER_OFF_SEL 0x200855
+/* end power state selectors */
+
+/* begin power state enums */
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_UNDEFINED_ENUM                            0x01
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D0_FULL_POWER_ENUM                        0x02
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D1_LOW_POWER_ENUM                         0x03
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D2_STANDBY_WITH_WAKE_ENUM                 0x04
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D3_SLEEP_WITH_WAKE_ENUM                   0x05
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D4_POWER_OFF_ENUM                         0x06
+/* end power state enums */
+
+/* begin orientation magnetometer accuracy selectors */
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETOMETER_ACCURACY_LOW 0x02008E0
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETOMETER_ACCURACY_MEDIUM 0x02008E1
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETOMETER_ACCURACY_HIGH 0x02008E2
+/* end orientation magnetometer accuracy selectors */
+
+#define HID_USAGE_SENSOR_DATA_GENERIC_UNIT_EXPONENT 0x200574
+/* begin unit exponent selectors */
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_0 0x200970
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_1 0x200971
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_2 0x200972
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_3 0x200973
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_4 0x200974
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_5 0x200975
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_6 0x200976
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_7 0x200977
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_8 0x200978
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_9 0x200979
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_A 0x20097A
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_B 0x20097B
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_C 0x20097C
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_D 0x20097D
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_E 0x20097E
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_F 0x20097F
+/* end unit exponent selectors */
+
 #endif
diff --git a/include/linux/senscol/senscol-core.h b/include/linux/senscol/senscol-core.h
new file mode 100644
index 0000000..a123705
--- /dev/null
+++ b/include/linux/senscol/senscol-core.h
@@ -0,0 +1,121 @@
+#ifndef	SENSCOL_CORE__
+#define	SENSCOL_CORE__
+
+#include <linux/types.h>
+#include <linux/kobject.h>
+
+struct data_field;
+struct sens_property;
+struct senscol_impl;
+
+struct sensor_def {
+	char	*name; 				/* Must be not NULL */
+	uint32_t	usage_id; 		/* Usage ID */
+	char	*friendly_name;			/* May be NULL */
+	int	num_data_fields;		/* Size of array of data fields */
+	struct data_field *data_fields;		/* Array of data fields */
+	int	num_properties;			/* Size of array of properties */
+	struct sens_property *properties;	/* Array of properties*/
+	uint32_t	id;			/* Unique ID of sensor (running count of discovery iteration) */
+	int	sample_size;			/* Derived from array of data_fields, updated when every data_field is added */
+	struct senscol_impl	*impl;
+	struct list_head	link;
+	struct kobject	kobj;
+	struct kobject	data_fields_kobj;
+	struct kobject	props_kobj;
+};
+
+struct data_field {
+	char *name;				/* Must be not NULL */
+	uint32_t	usage_id;		/* Usage ID of data_field */
+	uint8_t	exp;				/* Exponent: 0..F */
+	uint8_t	len;				/* Length: 0..4 */
+	uint32_t	unit;			/* Usage ID of unit */
+	int	is_numeric;			/* If !is_numeric, only name and usage_id appear */
+	struct kobject	kobj;
+	struct sensor_def	*sensor;	/* We need backlink for properties to their parent sensors */
+	int	index;				/* Index of field in raw data */
+};
+
+struct sens_property {
+	char *name;				/* Must be not NULL */
+	uint32_t	usage_id;		/* Usage ID of sens_property */
+	char	*value;
+	uint32_t	unit;			/* Usage ID of unit */
+	int	is_numeric;			/* If !is_numeric, only name and usage_id appear */
+	struct kobject	kobj;
+	struct sensor_def	*sensor;	/* We need backlink for properties to their parent sensors */
+};
+
+/* Only allocates new sensor */
+struct sensor_def *alloc_senscol_sensor(void);
+
+/* Init sensor (don't call for initialized sensors */
+void	init_senscol_sensor(struct sensor_def *sensor);
+
+/* Exposed sensor via sysfs, structure may be static */
+int	add_senscol_sensor(struct sensor_def *sensor);
+
+struct sensor_def	*get_senscol_sensor_by_name(const char *name);
+struct sensor_def	*get_senscol_sensor_by_id(uint32_t id);
+
+/* Add data field to existing sensor */
+int	add_data_field(struct sensor_def *sensor, struct data_field *data);
+
+/* Add property to existing sensor */
+int	add_sens_property(struct sensor_def *sensor, struct sens_property *prop);
+
+/* Get known name of given usages (NULL if unknown) */
+const char	*senscol_usage_to_name(unsigned usage);
+
+/* Push data sample in upstream buffer towards user-mode. Sample's size is determined from the structure */
+int	push_sample(uint32_t id, void *sample);
+
+/* Get known name of given modifier  safe, always returns value*/
+const char	*senscol_get_modifier(unsigned modif);
+
+/* Sample structure. Understood by binary SysFS provider and user-mode client */
+struct senscol_sample {
+	uint32_t	id;
+	uint32_t	size;	/* For easier/faster traversing of FIFO during reads */
+	uint8_t	data[1];	/* `size' (one or more) bytes of data */
+} __attribute__((packed));
+
+/*
+ * Samples are queued is a simple FIFO binary buffer with head and tail pointers.
+ * If the buffer wraps around, a single sample not start past SENSCOL_DATA_BUF_LAST, but may cross it or start at it
+ * Additional fields if wanted to be communicated to user mode can be define
+ */
+
+
+/*
+ * Suggested size of data buffer:
+ *   avg 24 bytes per sampl
+ *   expected 2600 samples/s for 17 sensors at max. rate
+ *   cover for 10 seconds of data
+ */
+/*#define	SENSCOL_DATA_BUF_SIZE	(24*2600*10)*/
+#define	SENSCOL_DATA_BUF_SIZE	(24*2600)
+#define	SENSCOL_DATA_BUF_LAST	(SENSCOL_DATA_BUF_SIZE-128)
+
+/*
+ * Sensor collection underlying handler.
+ * Supplies set_prop(), get_prop() and get_sample() callback
+ */
+struct senscol_impl {
+	/* Get property value, will return NULL on failure */
+	int	(*get_sens_property)(struct sensor_def *sensor, const struct sens_property* prop, char *value, size_t val_buf_size);
+
+	/* Set property value */
+	int	(*set_sens_property)(struct sensor_def *sensor, const struct sens_property* prop, const char *value);
+
+	/* Get sample */
+	int	(*get_sample)(struct sensor_def *sensor, void *sample_buf, size_t sample_buf_size);
+	struct list_head link;
+};
+
+int	add_senscol_impl(struct senscol_impl *impl);
+int	remove_senscol_impl(struct senscol_impl *impl);
+
+#endif /*SENSCOL_CORE__H*/
+
-- 
1.7.9.5

