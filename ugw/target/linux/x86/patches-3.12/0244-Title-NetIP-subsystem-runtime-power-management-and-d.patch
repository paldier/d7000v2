From 65d0d1aeddaafbd5f6ee889bcec0fe41d1b23a4c Mon Sep 17 00:00:00 2001
From: Emmanuel Jillela <emmanuel.jillela@intel.com>
Date: Thu, 19 Nov 2015 13:02:25 -0700
Subject: [PATCH]     Title: NetIP subsystem runtime power management and
 dualboot handshake updated with F2F            integration
 changes.     Issue: <JIRA:CPM-58>     IssueType: <Feature> 
    Description: <to support netip subsystem runtime power
 management>     Reviewers: <mavitaly, vrpate2>

---
 arch/x86/NetIP_SubSystem/netip_subsystem_defs.h    |   60 +-
 arch/x86/NetIP_SubSystem/netip_subsystem_lld.c     |   31 +-
 arch/x86/NetIP_SubSystem/netip_subsystem_pm.c      |  815 +++++++++++++++-----
 arch/x86/NetIP_SubSystem/netip_subsystem_pm.h      |  142 ++++
 .../NetIP_Subsystem_sysfs/netip_subsystem_sysfs.c  |  298 ++++---
 include/linux/netip_subsystem.h                    |   17 +
 6 files changed, 978 insertions(+), 385 deletions(-)
 create mode 100644 arch/x86/NetIP_SubSystem/netip_subsystem_pm.h

diff --git a/arch/x86/NetIP_SubSystem/netip_subsystem_defs.h b/arch/x86/NetIP_SubSystem/netip_subsystem_defs.h
index 13802d2..bb072d3 100644
--- a/arch/x86/NetIP_SubSystem/netip_subsystem_defs.h
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_defs.h
@@ -32,7 +32,9 @@
 #include  <linux/mutex.h>
 #include <linux/kthread.h>
 #include <linux/spinlock.h>
+#include <linux/acpi.h>
 #include <linux/netip_subsystem.h>
+#include "netip_subsystem_pm.h"
 
 //#define NETSS_DRV_DBG 1
 #ifdef NETSS_DRV_DBG
@@ -41,63 +43,8 @@
 #define NETSS_DBG_PRINT(fmt, args...) ; 
 #endif
 
-#define NETSS_POWER_STATE_MASK (3)
 #define NETSS_MAX_ARM11_INTR 64
-typedef enum netss_power_state 
-{
-   NETIP_ACTIVE_ON_AC = 0,
-   NETIP_ACTIVE_ON_BATTERY = 1,
-   NETIP_STANDBY = 2,
-   NETIP_DEEP_STANDBY = 3,
-   NETIP_POWER_STATE_INVALID = 4,
-}netss_power_state_t;
 
-typedef struct netss_sysfs_attributes_info {
-   uint32_t service_level;        /**sysfs attrivute. it is a vector that represents the netip and its services power states  */
-   uint32_t runtime_state[13];    /**sysfs attibute, for configuring individual service power states */
-   struct mutex lock;            /**to synchronise between the thread that is writing to service_level and thread that is sending message
-                                  * This lock may be needed only during boot time. */
-} netss_sysfs_attributes_info_t;
-
-typedef struct netss_msg_info {
-   uint32_t type;         /**Netip properties or service status msg */
-   uint32_t len;          /**Payload length */
-   uint8_t payload[64];   /**Payload */
-   
-   struct mutex lock; 
-} netss_msg_info_t;
-
-typedef struct netss_service_status {
-   uint8_t id;
-   uint8_t state;
-}netss_service_status_t;
-
-typedef union netss_msg_header {
-   uint8_t  opcode;
-   uint32_t header;
-} netss_msg_header_t;
- 
-typedef struct netss_configure_msg {
-   netss_msg_header_t hdr;       /**header of the message */
-   //uint32_t num_ds_chan;     /**Number of QAM DS channels */
-   uint8_t  docsis_chan[32]; /** each byte if 1, indicates that it is a docsis channel */
-   uint32_t cm_mode;         /**Cable modem operational mode  */
-   uint32_t RCE_floor;       /** */
-   uint32_t RCF_filter;      /** */
-} netss_configure_msg_t;
-
-typedef struct netss_service_status_msg {
-   netss_msg_header_t hdr;       /**header of the message */
-   uint32_t  netip_level;     /** ARM11 power state 0==Active, 2==low power, 3==disable */
-   netss_service_status_t service[0];
-}netss_service_status_msg_t;
-
-typedef struct netss_service_request_msg {
-   netss_msg_header_t hdr;       /**header of the message */
-   uint32_t onBattery;       /**1 == system is on battery or 0 system is on AC power  */
-   uint32_t  netip_level;     /** ARM11 power state 0==Active, 2==low power, 3==disable */
-   netss_service_status_t service[0];
-}netss_service_request_msg_t;
 
 struct net_subsystem_drv_data {
    uint32_t irq_num;          /* The irq number used for Net SubSystem driver */
@@ -112,6 +59,7 @@ struct net_subsystem_drv_data {
    spinlock_t irq_lock;
    struct mutex netss_lock;
    struct task_struct * handshake_thread; /* Thread that exchange messages with netip during boot */
+   acpi_handle acpi_h;
    netss_msg_info_t netip_msg;
    
     
@@ -124,7 +72,5 @@ typedef struct net_ip_mmios {
     unsigned long region2_size;
 }net_ip_mmios_t;
 
-
-
 #endif
 
diff --git a/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c b/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c
index c49222a..72483e4 100755
--- a/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c
@@ -3,7 +3,7 @@
  *
  *  GPL LICENSE SUMMARY
  *
- *  Copyright(c) 2014 Intel Corporation. All rights reserved.
+ *  Copyright(c) 2015 Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of version 2 of the GNU General Public License as
@@ -31,6 +31,7 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/sched.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
@@ -39,6 +40,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/spinlock.h>
 #include <linux/netip_subsystem.h>
+#include <linux/stat.h>
 #include "netip_subsystem_defs.h"
 #include <linux/avalanche/generic/avalanche_intc.h>
 
@@ -53,6 +55,10 @@ static const struct dev_pm_ops netss_pm_ops = {
                            netss_runtime_idle)
 };
 #endif
+int docsis_chan_cfg = 0;
+int  cm_mode = 0;
+int RCE_Floor = 0;
+int RCE_Filter = 0;
 
 static const struct pci_device_id net_subsystem_pci_tbl[] = {
         { PCI_DEVICE( 0x8086, NET_SUBSYTEM_DEV_ID), .driver_data = 0 },
@@ -60,6 +66,10 @@ static const struct pci_device_id net_subsystem_pci_tbl[] = {
 };
 
 net_ip_mmios_t net_ip_mmios;
+module_param(docsis_chan_cfg, int , (S_IRUSR | S_IWUSR ));
+module_param(cm_mode, int, (S_IRUSR | S_IWUSR ));
+module_param(RCE_Floor, int, (S_IRUSR | S_IWUSR ));
+module_param(RCE_Filter, int, (S_IRUSR | S_IWUSR ));
 
 MODULE_DEVICE_TABLE(pci, net_subsystem_pci_tbl);
 /*This function creates boot handshake thread */
@@ -98,9 +108,9 @@ void netss_interrupt_register(netss_interrupt_t intrpt, int arm11_int_id, netss_
                 irq_info->func(pnetss_drv_data->irq_num, irq_info->args);
                 netss_interrupt_ack(intrpt);
                 pnetss_drv_data->pending_interrupts &= ~(1<<intrpt);
-                printk("Cleared pending interrupt for device %d IIR %08x pending %08x\n", intrpt, 
-                            __raw_readl(pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IIR_OFFSET), 
-                                                               pnetss_drv_data->pending_interrupts);
+                NETSS_DBG_PRINT("Cleared pending interrupt for device %d IIR %08x pending %08x\n", intrpt, 
+                                 __raw_readl(pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IIR_OFFSET), 
+                                                                     pnetss_drv_data->pending_interrupts);
              }
         }
         else
@@ -116,9 +126,9 @@ void netss_interrupt_register(netss_interrupt_t intrpt, int arm11_int_id, netss_
                 }
 
                 pnetss_drv_data->pending_arm11_interrupts &= ~(1<<arm11_int_id);
-                printk("Cleared pending interrupt for armm11 %d IIR %08x pending %08x\n", arm11_int_id, 
-                               __raw_readl(pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IIR_OFFSET), 
-                                                            pnetss_drv_data->pending_arm11_interrupts);
+                NETSS_DBG_PRINT("Cleared pending interrupt for armm11 %d IIR %08x pending %08x\n", arm11_int_id, 
+                                        __raw_readl(pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IIR_OFFSET), 
+                                                                     pnetss_drv_data->pending_arm11_interrupts);
             }
         }
         netss_interrupt_enable(intrpt);
@@ -204,7 +214,7 @@ void netss_interrupt_enable(netss_interrupt_t intrpt)
    reg_val = __raw_readl(pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IER_OFFSET);
    if(!(reg_val & (1 << intrpt))) {
       __raw_writel((reg_val | (1<<intrpt)), pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IER_OFFSET);
-      printk(KERN_INFO "Enabling Net IP subdevice %d interrupts reg %x\n", intrpt, __raw_readl(pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IER_OFFSET));
+      NETSS_DBG_PRINT("Enabling Net IP subdevice %d interrupts reg %x\n", intrpt, __raw_readl(pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IER_OFFSET));
    } 
 }
 EXPORT_SYMBOL(netss_interrupt_enable);
@@ -220,7 +230,7 @@ void netss_interrupt_disable(netss_interrupt_t intrpt)
    reg_val = __raw_readl(pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IER_OFFSET);
    if(reg_val & (1 << intrpt)) {
       __raw_writel((reg_val & ~(1<<intrpt)), pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IER_OFFSET);
-      printk(KERN_INFO "Disabling Net IP interrupt id %d interrupts reg %x\n", intrpt, __raw_readl(pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IER_OFFSET));
+      NETSS_DBG_PRINT("Disabling Net IP interrupt id %d interrupts reg %x\n", intrpt, __raw_readl(pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IER_OFFSET));
    } 
 }
 EXPORT_SYMBOL(netss_interrupt_disable);
@@ -394,6 +404,8 @@ static int netss_probe(struct pci_dev *pdev,
    }
    mutex_init(&pnetss_drv_data->netss_lock);
    mutex_init(&pnetss_drv_data->netip_msg.lock);
+   /**Get the ACPI handle */
+   pnetss_drv_data->acpi_h = ACPI_HANDLE(&pdev->dev);
    pci_set_drvdata(pnetss_drv_data->dev,pnetss_drv_data);
    mutex_init(&g_netss_sysfs_attributes_info.lock);
    pnetss_drv_data->netss_driver_initialized = true;
@@ -407,6 +419,7 @@ static int netss_probe(struct pci_dev *pdev,
 
    /* initilize ATOM_INTC IO memory map */
    avalanche_intc_init();
+   printk("docsis_chan_cfg = %08x\n", docsis_chan_cfg);
    return 0;
 
 free_iomem:
diff --git a/arch/x86/NetIP_SubSystem/netip_subsystem_pm.c b/arch/x86/NetIP_SubSystem/netip_subsystem_pm.c
index 7aacdd03..55e9b82 100644
--- a/arch/x86/NetIP_SubSystem/netip_subsystem_pm.c
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_pm.c
@@ -35,27 +35,38 @@
 #include <linux/hw_mailbox.h>
 #include <linux/netip_subsystem.h>
 #include <linux/delay.h>
+#include <linux/timer.h>
 #include "netip_subsystem_defs.h"
+#include "netip_subsystem_pm.h"
 
+extern int docsis_chan_cfg;
+extern int  cm_mode;
+extern int RCE_Floor;
+extern int RCE_Filter;
 
 void netss_sysfs_clean_up(uint32_t available_services);
-#define NETIP_MSG_NONE 0
-#define NETIP_PROPERTIES_MSG 1
-#define NETIP_STATUS_MSG 2
-/** Opcode Enumeration */
-typedef enum netss_opcodes {
-   NETSS_OPCODE_NETIP_PROPERTIES = 1,
-   NETSS_OPCODE_SERVICE_STATUS = 2,
-   NETSS_OPCODE_SERVICE_REQUEST_REPLY = 3,
-   NETSS_OPCODE_CONFIGURE = 4,
-   NETSS_OPCODE_SERVICE_REQUEST = 5,
-}netss_opcodes_t;
 
+
+/**Function that sends service request msg  */
+static int netss_send_service_request_msg(uint32_t service_level);
+
+int __netss_set_service_level(uint32_t level);
 /*External variables */
 extern struct net_subsystem_drv_data *pnetss_drv_data;
 netss_sysfs_attributes_info_t g_netss_sysfs_attributes_info;
 
-/*The variable when set indicates that a message is received from NetIP */
+static int g_enable_debug = 0;
+#define NETSS_PM_PRINT(fmt, args...) { if(g_enable_debug) printk(fmt, ##args); } 
+
+#define IS_SERVICE_RESOURCE_TO_BE_CONTROLLED(id)  ( ( (id == NETSS_SERVICE_ID_SGMII0) || \
+                                                      (id == NETSS_SERVICE_ID_SGMII1) || \
+                                                      (id == NETSS_SERVICE_ID_RGMII2) || \
+                                                      (id == NETSS_SERVICE_ID_RGMII3) || \
+                                                      (id == NETSS_SERVICE_ID_EXSW) ) ? 1 : 0)
+
+/*The variable when set indicates that a message is received from NetIP 
+ *NetIP subsustem msg processing thread sleeps in the work queue
+ *untill this variable is not zero*/
 static int g_netip_msg = 0;
 /*Bit mask representing available services
  * set bit indicates the availablity of the corresponding service.
@@ -67,26 +78,90 @@ static uint16_t g_netip_services_available = 0;
 /*The variable indicates the services whose service status message is received. 
  * if bit n is set, service id n-1's service status message is received */
 static uint16_t g_netip_services_status_received = 0;
-/* Netip services that are initialized and ready to move on */
+/* Netip services that are ready to be  moved to desired power level */
 static uint16_t g_netip_services_status_ready = 0;
 
+/* Netip services that completed the very first power level move */
+static uint16_t g_netip_services_init_complete = 0;
+
+/* Netip services that are requested to change power level by user */
+static uint16_t g_netip_services_change_requested = 0;
+
+/* Netip services that got service request reply */
+static uint16_t g_netip_services_change_complete = 0;
+
 /* Number of Netip services that are ready */
 static uint16_t g_num_netip_services_status_ready = 0;
 
+/*Netip services whose services request reply is pending
+ *We should servie request one after the other only */
+static bool g_netip_service_request_reply_pending = false;
+
+/*Indicates that user space updated sysfs attributes while reply is pending */
+static bool g_netip_service_level_request_pending = false;
+
+/**Indicates whether PMP or power manager informed that we are on battery */
+static bool g_onBattery = false;
+
 /*Current NetIP power state */
-static netss_power_state_t g_current_netip_power_state = NETIP_POWER_STATE_INVALID;
+static netss_power_level_t g_current_netip_power_state = NETSS_POWER_LEVEL_INVALID;
 
 /*Indicated if the bootime hand shake with NetIP is done or not */
 static bool g_netss_boot_handshake_done = false;
 
+/**timer to indicate timeout,if at all happens during dualboot handshake or 
+ * while waiting for the service request replies */
+static struct timer_list netss_pm_timer;
+static bool g_timer_created = false;
+
+/**
+ * puma_netip_notify_state() - invoke to update the state of NETIP
+ * @state: state of NETIP, 0 - Active, 1 - BBU, 2 - Standby, 3 - Deep standby
+ */
+extern int puma_netip_notify_state(int state);
+
 static DECLARE_WAIT_QUEUE_HEAD(waitForNetIPMsgWQ);
 
+static void netss_handle_resource_power_state(uint8_t service_id, uint8_t state)
+{
+   if(pnetss_drv_data->acpi_h == NULL)
+   {
+      //printk("NetIP acpi handle is NULL \n");
+   }
+   else
+   {
+      /** call ACPI function from here to power on/off of the resource associated with the service */
+      //NETSS_PM_PRINT("Changing the resource power state of service id %d state %d\n", service_id, state);
+   }
+   return;
+}
+static void netss_pm_timeout_handler (unsigned long data) 
+{
+   printk("IT APPEARS THAT ATOM NOT RECEIVING MSGS FROM NETIP \n");
+   printk("Keep Checking #cat /sys/class/net/netip_subsystem/service_status \n");
+   if(g_netss_boot_handshake_done)
+   {
+      /**We dint get replies for all service request made */
+      printk("Timeout happened while waiting for service request replies\n");
+      printk("services requested to change power level %08X\n", g_netip_services_change_requested);
+      printk("Received service request replies for %08X\n", g_netip_services_change_complete);
+   }
+   else
+   {
+      printk("Dualboot handshake dint happen \n");
+      printk("Available services = 0x%08X\n", g_netip_services_available);
+      printk("services whose status recieved = 0x%08X\n", g_netip_services_status_received);
+      printk("services ready = 0x%08X\n", g_netip_services_status_ready);
+      printk("services that completed initial power level change = 0x%08X\n", g_netip_services_init_complete);
+   }
+}
 static int  netss_receive_netip_msg(hw_mbox_Masters_e commander,
                               //Uint32 code,
                               Uint8 *dataBuf, Uint32 dataLen,
                               Uint32 *token)
 {
    int i=0;
+   char *msg_name = "unknown";
    mutex_lock(&pnetss_drv_data->netip_msg.lock);
    memcpy(pnetss_drv_data->netip_msg.payload, dataBuf, dataLen);
    pnetss_drv_data->netip_msg.len = dataLen;
@@ -95,18 +170,29 @@ static int  netss_receive_netip_msg(hw_mbox_Masters_e commander,
    if(pnetss_drv_data->netip_msg.type == NETSS_OPCODE_NETIP_PROPERTIES) 
    {
       g_netip_msg = 1;
+      msg_name = "Properties";
    } 
    else if (pnetss_drv_data->netip_msg.type == NETSS_OPCODE_SERVICE_STATUS)
    {
       g_netip_msg = 2;
+      msg_name = "Service Status";
+   }
+   else if (pnetss_drv_data->netip_msg.type == NETSS_OPCODE_SERVICE_REQUEST_REPLY)
+   {
+      g_netip_msg = 3;
+      msg_name = "Service Request Reply";
    }
-   printk("NetIP Msg recvd:");
+   NETSS_PM_PRINT("NetIP Msg recvd: %s\n", msg_name);
    for(i=0; i<dataLen; i++)
    {
-      if(i%4 == 0) (printk("\n"));
-      printk("%2X\t", dataBuf[i]);
+      if(i%4 == 0) 
+      {
+         NETSS_PM_PRINT("\n");
+      }
+      NETSS_PM_PRINT("%2X\t", dataBuf[i]);
    }
-   printk("===========================\n");
+   NETSS_PM_PRINT("\n===========================\n");
+
    mutex_unlock(&pnetss_drv_data->netip_msg.lock);
    wake_up_all(&waitForNetIPMsgWQ);
    return 0;
@@ -158,12 +244,19 @@ static void ness_process_netip_props_msg(void)
       /*netip properties message is null terminated 
        *set the bit n-1, for the service id n
        *service id starts from 1  */
-      g_netip_services_available |= 1 << (*data-1);
+      if(*data < NETSS_SERVICE_ID_MAX)
+      {
+         g_netip_services_available |= 1 << (*data-1);
+      }
+      else
+      {
+         printk("Invalid service id in properties msg %d\n", *data);
+      }
       
       /*Check next two bytes */
       data++;
    } 
-   NETSS_DBG_PRINT("services that are available = %x\n", g_netip_services_available);
+   NETSS_PM_PRINT("services that are available = %x\n", g_netip_services_available);
   
    /*Remove the sysfs attribute files of the services that are not available */
    //netss_sysfs_clean_up(g_netip_services_available);
@@ -195,8 +288,9 @@ static void ness_process_netip_props_msg(void)
 static void netss_send_configure_msg (void)
 {
    int i, j=0, ret;
-   uint32_t docsis_channels = 0xF0F00000; /*Mask indicating the channels numbers configured as docsis channels */
+   //uint32_t docsis_channels = 0xF0F00000; /*Mask indicating the channels numbers configured as docsis channels */
    netss_configure_msg_t cfg_msg;
+   uint8_t *msg= (uint8_t *)(&cfg_msg);
    uint32_t reply_len;
     
    /*clear the message */
@@ -205,9 +299,9 @@ static void netss_send_configure_msg (void)
    cfg_msg.hdr.opcode = NETSS_OPCODE_CONFIGURE;
    /*These values should be read from platfom config files
     *for now writing some default values  */
-   for(i=0; i < sizeof(uint32_t); i++)
+   for(i=0; i < 32; i++)
    {
-      if(docsis_channels & (1 << i)) {
+      if(docsis_chan_cfg & (1 << i)) {
          cfg_msg.docsis_chan[j] = i+1;
          j++;
       }
@@ -215,9 +309,20 @@ static void netss_send_configure_msg (void)
    /*Just write 0 to terminate the list */
    cfg_msg.docsis_chan[j] = 0;
   
-   cfg_msg.cm_mode = 0; 
-   cfg_msg.RCE_floor = 1;
-   cfg_msg.RCF_filter = 0;
+   cfg_msg.cm_mode = cm_mode; 
+   cfg_msg.RCE_floor = RCE_Floor;
+   cfg_msg.RCE_filter = RCE_Filter;
+
+   NETSS_PM_PRINT("configure Msg:");
+   for(i=0; i<sizeof(netss_configure_msg_t); i++)
+   {
+      if(i%4 == 0) 
+      {
+         NETSS_PM_PRINT("\n");
+      }
+      NETSS_PM_PRINT("%2x\t", msg[i]);
+   }
+   NETSS_PM_PRINT("\n============================\n");
    ret = hwMbox_sendOpcode(HW_MBOX_MASTER_NP_CPU, 0, (uint8_t*)&cfg_msg, sizeof(netss_configure_msg_t), sizeof(netss_configure_msg_t), &reply_len);
    if(ret)
    {
@@ -252,83 +357,217 @@ static void ness_process_service_status_msg(void)
 {
    int i=0;
    netss_service_status_msg_t *service_msg =(netss_service_status_msg_t*) &pnetss_drv_data->netip_msg.payload[0];
-   netss_sysfs_attributes_info_t *syfs_info = &g_netss_sysfs_attributes_info;
    netss_service_status_t *service_status = (netss_service_status_t *)&pnetss_drv_data->netip_msg.payload[SERVICE_OFFSET];
    
-   //mutex_lock(&syfs_info->lock);
-   NETSS_DBG_PRINT("processing service status message opcode %d\n", service_msg->hdr.opcode);
-   syfs_info->runtime_state[0] = service_msg->netip_level;
+   NETSS_PM_PRINT("processing service status message opcode %d\n", service_msg->hdr.opcode);
    while(service_status[i].id != 0) 
    {
-      syfs_info->runtime_state[service_status[i].id] = service_status[i].state;
-      g_netip_services_status_received |= (1 << (service_status[i].id -1));
+      /**Check if the service id is available i.e mentioned in netip properties msg and valid */
+      if((g_netip_services_available & (1 << (service_status[i].id-1))) &&
+         (service_status[i].id < NETSS_SERVICE_ID_MAX))
+      {
+         if(!(g_netip_services_status_received & (1 << (service_status[i].id -1))))
+         {
+            g_netip_services_status_received |= (1 << (service_status[i].id -1));
 
-      /*Services that are ready to request */
-      if(service_status[i].state == 2)  {
-         g_netip_services_status_ready |= (1 << (service_status[i].id -1));
-         g_num_netip_services_status_ready++;
+            /*Services that are ready to request */
+            if(service_status[i].state == NETSS_SERVICE_STATUS_INITIALIZED)  
+            {
+               g_netip_services_status_ready |= (1 << (service_status[i].id -1));
+               g_num_netip_services_status_ready++;
+            }
+         }
+      }
+      else
+      {
+         printk("Error:Invalid service id in the status message %d\n", service_status[i].id);
       }
       i++;
    }
-   //mutex_unlock(&syfs_info->lock);
    
    return;
 }
 
-static void netss_update_sysfs_attributes(netss_sysfs_attributes_info_t *syfs_info, netss_service_request_msg_t *service_msg)
+static void netss_update_sysfs_attributes(netss_sysfs_attributes_info_t *sysfs_info, netss_service_request_msg_t *service_msg)
 {
    int i=0;
    uint32_t netip_level = service_msg->netip_level;
    /*Upon successful reply process the reply and update sysfs attributes */
-   syfs_info->runtime_state[0] = service_msg->netip_level;
+   sysfs_info->runtime_state[0] = service_msg->netip_level;
+   /**Clear and update netip level */
+   sysfs_info->service_status &= ~NETSS_BIT_MASK_POWER_LEVEL;
+   sysfs_info->service_status = service_msg->netip_level & NETSS_BIT_MASK_POWER_LEVEL;
 
-   while(service_msg->service[i].id != 0) {
+   while(service_msg->service[i].id != 0) 
+   {
+
+      /**Clear and update the individual service level */
+      NETSS_CLEAR_SERVICE_POWER_LEVEL(service_msg->service[i].id, sysfs_info->service_status);
+      sysfs_info->service_status |= NETSS_SET_SERVICE_POWER_LEVEL(service_msg->service[i].id, service_msg->service[i].state);
 
-     syfs_info->runtime_state[service_msg->service[i].id] = service_msg->service[i].state;
-     i++;
+      if( IS_SERVICE_RESOURCE_TO_BE_CONTROLLED(service_msg->service[i].id) &&
+          (service_msg->service[i].state == NETSS_SERVICE_POWER_LEVEL_OFF))
+      {
+         netss_handle_resource_power_state(service_msg->service[i].id, service_msg->service[i].state);
+      }
+      if(!g_netss_boot_handshake_done) 
+      {
+         /*Service completed initalized by moving to the requested power level*/
+         g_netip_services_init_complete |= (1<< (service_msg->service[i].id-1));
+      }
+      else
+      {
+         g_netip_services_change_complete |=  (1<< (service_msg->service[i].id-1));
+      }
+      i++;
    }
-   if(netip_level == NETIP_ACTIVE_ON_AC) {
-      /* just checking true or not */
-      if(service_msg->onBattery) { 
-         syfs_info->runtime_state[0] = NETIP_ACTIVE_ON_BATTERY;
-         g_current_netip_power_state = NETIP_ACTIVE_ON_BATTERY;
-      } else {
-         g_current_netip_power_state = NETIP_ACTIVE_ON_AC;
+   if(!g_netss_boot_handshake_done)
+   { 
+      NETSS_PM_PRINT("services_ready = %X init complete %X service status %X\n", g_netip_services_status_ready, g_netip_services_init_complete, sysfs_info->service_status);
+   }
+   else
+   {
+      NETSS_PM_PRINT("services_change requested = %X change complete %X service status = %X\n", g_netip_services_change_requested, g_netip_services_change_complete, sysfs_info->service_status);
+   }
+   /*If we have received service request replies for all the services we requested */
+   if( (!g_netss_boot_handshake_done && (g_netip_services_status_ready == g_netip_services_init_complete)) ||
+       (g_netss_boot_handshake_done && (g_netip_services_change_complete == g_netip_services_change_requested)) )
+   {
+      int i=0;
+      uint32_t temp = g_current_netip_power_state;
+      g_current_netip_power_state = service_msg->netip_level;
+     
+      if(g_timer_created)
+      {
+         /**delete the timer as we completed either dualboot handshake or 
+          * a service_request change initiated by user after dualboot handshake */
+         del_timer_sync(&netss_pm_timer);
+      }
+      /**update the status vector with battery status */
+      if(g_onBattery)
+      {
+         sysfs_info->service_status |= NETSS_BIT_MASK_ON_BATTERY;
+      }
+      else
+      {
+         sysfs_info->service_status &= ~NETSS_BIT_MASK_ON_BATTERY;
+      }
+      /**Mark the services that are not ready with reserved power level */
+      for(i = NETSS_SERVICE_ID_DOCSIS; i < NETSS_SERVICE_ID_MAX; i++)
+      {
+         if(!(g_netip_services_status_ready & (1<<(i-1))))
+         {
+            /**Clear power leveland update with reserved */
+            NETSS_CLEAR_SERVICE_POWER_LEVEL(i, sysfs_info->service_status);
+            sysfs_info->service_status |= NETSS_SET_SERVICE_POWER_LEVEL(i, NETSS_SERVICE_POWER_LEVEL_RESERVED);
+         }
+      } 
+      if(service_msg->netip_level == NETSS_POWER_LEVEL_RESERVED)
+      {
+         NETSS_PM_PRINT("ERROR NetIP level should not be reserved level = %d\n", NETSS_POWER_LEVEL_RESERVED);
+      }   
+      if(g_current_netip_power_state == NETSS_POWER_LEVEL_DEEP_STANDBY)
+      {
+#ifdef CONFIG_PM_RUNTIME
+         /**Let the usage counter go to zero */
+         pm_runtime_put(&pnetss_drv_data->dev->dev);
+#endif
+      }        
+      if(temp < g_current_netip_power_state && g_current_netip_power_state != NETSS_POWER_LEVEL_DEEP_STANDBY)
+      {
+         /* No need to call if going to deepstandby, because netss_runtime_suspend will call. 
+          * 1. Call the platform driver api to inform the new power state
+          * we are going to lower power level like active to bbu, active to fast standby/disable
+          */
+          if(g_current_netip_power_state == NETSS_POWER_LEVEL_DISABLE)
+          {
+              puma_netip_notify_state(2);
+          }
+          else if(g_onBattery)
+          {
+             /**inform that we are on BBU */
+             puma_netip_notify_state(1);
+          }
+      } /** g_current_netip_power_state will never be NETSS_POWER_LEVEL_RESERVED, just a safety check */
+      else if(temp == g_current_netip_power_state && g_current_netip_power_state != NETSS_POWER_LEVEL_RESERVED) 
+      {
+         /**There is no change in the netip level */
+         if(g_onBattery && (g_current_netip_power_state == NETSS_POWER_LEVEL_ENABLE))
+         {
+            puma_netip_notify_state(1); 
+         }
+         else
+         {
+            puma_netip_notify_state(g_current_netip_power_state); 
+         }
+      }
+
+      /*We are good to make another cyle of service requests */
+      if(g_netip_services_change_complete == g_netip_services_change_requested)
+      {
+         g_netip_services_change_complete = 0;
+         g_netip_services_change_requested = 0;
+         
+         if (g_netip_service_level_request_pending)
+         {
+            g_netip_service_level_request_pending =  false;
+            /*sysfs attribute was changed from user space, process it */
+            __netss_set_service_level(g_netss_sysfs_attributes_info.service_level);
+         }
       }
-   } else if(netip_level == NETIP_STANDBY) {
-      g_current_netip_power_state = NETIP_STANDBY;
-   } else if(netip_level == NETIP_DEEP_STANDBY) {
-      g_current_netip_power_state = NETIP_DEEP_STANDBY;
-   } else {
-      g_current_netip_power_state = NETIP_POWER_STATE_INVALID;
    }
    return;
 }
+
+static bool netss_request_for_service_level_change(int index)
+{
+   bool add_service_to_msg = false;
+   if(!g_netss_boot_handshake_done)
+   {
+      if((g_netip_services_status_ready & (1<<index)) && !(g_netip_services_init_complete & (1<<index)))
+      {
+         add_service_to_msg = true;
+      }
+   }
+   else
+   {
+      if(g_netip_services_status_ready & (1<<index))
+      {
+         if(!(g_netip_services_change_requested & (1<<index)));
+         {
+            add_service_to_msg = true;
+         }
+      }
+   }
+   return add_service_to_msg;
+}
 /*Service request message format is same as service status message 
- *sys/class/net/subsystem/power/service_level is set by PMP (power management policy)
+ *sys/class/net/netip_subsystem/service_level is set by PMP (power management policy)
  *and it is interpreted as follows
  * ---------------------------------------------
  * |BITS |Service |                            |
    |     |  ID    |      Interpretation        |
  * |------------------------------------------ |
- * |1:0  |   _    | NetIP 00 - Enable OnAC     |
- * |     |        |       01 - Enable OnBattery|
- * |     |        |       10 - Disable         |
- * |     |        |       11 - Off deep stanby |
+ * |1:0  |   _    | NetIP 00 - Enable          |
+ * |     |        |       01 - Reserved        |
+ * |     |        |       10 - Disable/Fast Standby|
+ * |     |        |       11 - Deep stanby     |
+ * |2:2  |        | Reserved                   |
+ * |3:3  |        | On Battery                 |
  * |-------------------------------------------|
- * |3:2  |   1    | Docsis                     |
- * |5:4  |   2    | Spectral Analysis          |
- * |7:6  |   3    | Video                      |
- * |9:8  |   4    | Voice   00 - Enable/Active |
- * |11:10|   5    | Moca    01 - Low           |
- * |13:12|   7    | Wifi    10 - Off           |
- * |15:14|   8    | ExSw                       |
- * |17:16|   9    | RGMII0                     |
- * |19:18|  10    | RGMII1                     |
- * |21:20|  11    | SGMII2                     |
- * |23:22|  12    | SGMII3                     |
+ * |5:4  |   1    | Docsis                     |
+ * |7:6  |   2    | Spectral Analysis          |
+ * |9:8  |   3    | Video                      |
+ * |11:10|   4    | Voice   00 - On            |
+ * |13:12|   5    | Moca    01 - Low           |
+ * |15:14|   6    | BBU     10 - Reserved      |
+ * |17:16|   7    | Wifi    11 - Off           |
+ * |19:18|   8    | ExSw                       |
+ * |21:20|   9    | SGMII0                     |
+ * |23:22|  10    | SGMII1                     |
+ * |25:24|  11    | RGMII2                     |
+ * |27:26|  12    | RGMII3                     |
  * ---------------------------------------------
- * service ID 6 is BBU which is always on if exists, so service_level has no representation
  */
 /** service request/reply message format
  * ---------------------------
@@ -353,12 +592,14 @@ static void netss_update_sysfs_attributes(netss_sysfs_attributes_info_t *syfs_in
  * |-------------------------|
  */
 
-static int ness_send_service_request_msg(uint32_t service_level)
+static int netss_send_service_request_msg(uint32_t service_level)
 {
    int i=0, j=0;
    int ret = -1;
    uint32_t reply_len;
+   uint32_t msg_len=12;
    netss_service_request_msg_t *service_msg = NULL;
+   uint8_t *msg;
    uint32_t service_msg_len;
    netss_sysfs_attributes_info_t *syfs_info = &g_netss_sysfs_attributes_info;
 
@@ -369,6 +610,7 @@ static int ness_send_service_request_msg(uint32_t service_level)
    service_msg_len = (service_msg_len + 3) & ~3;
    /* Alloc memory for service request message */
    service_msg = kzalloc(service_msg_len, GFP_KERNEL);
+   msg = (uint8_t *)service_msg;
    if(!service_msg) {
       printk(KERN_ERR "Could not allocate service request message\n");
    } 
@@ -376,92 +618,143 @@ static int ness_send_service_request_msg(uint32_t service_level)
    {
       //mutex_lock(&syfs_info->lock);
       service_msg->hdr.opcode = NETSS_OPCODE_SERVICE_REQUEST;
+      /**Assume that we are not on Battery */
+      g_onBattery = false;
       if(0 == service_level) 
       {
          /*PMP has not set the service level, 
           *assume Enable onAC power and enable all available services */
-         service_msg->netip_level = 0;
+         service_msg->netip_level =  NETSS_POWER_LEVEL_ENABLE;
          service_msg->onBattery = 0;
-         for(i=0; i < 12; i++)
+         for(i = NETSS_SERVICE_ID_DOCSIS; i < NETSS_SERVICE_ID_MAX; i++) 
          {
-            /*BBU is always on if existed, so dont include in the message */
-            if(i==5) continue;
-
-            if(g_netip_services_status_ready & (1 << j)) {
-               service_msg->service[j].id = i+1; // service ID starts from 1
-               service_msg->service[j].state = 0;
+            /*If the Dual boot handshake is not done then request all the services that are
+             *not moved to a initial power level 
+             *If the dual boot handshake is done then it means power manager want to change the power level
+             *of the services, just make sure that their status was ready and avoid sending request for
+             *for services which are already sent */
+            if(netss_request_for_service_level_change(i-1))
+            {
+               service_msg->service[j].id = i; // service ID starts from 1
+               service_msg->service[j].state = NETSS_SERVICE_POWER_LEVEL_ON;
+               if(IS_SERVICE_RESOURCE_TO_BE_CONTROLLED(i)) 
+               {
+                  netss_handle_resource_power_state(i, NETSS_SERVICE_POWER_LEVEL_ON);
+               }
                j++;
+               msg_len += 2;
             }
          }
       } 
       else 
       {
-         if(0 == (service_level & 3)) {
-            /*On AC power mode, enable all services */
-            service_msg->netip_level = 0;
-         } else if(1 == (service_level & 3)) {
-            /*On Battery mode, put voice in low power mode and disable all services */
+         service_msg->netip_level = (service_level & NETSS_BIT_MASK_POWER_LEVEL);
+
+         if(service_msg->netip_level == NETSS_POWER_LEVEL_RESERVED)
+         {
+            NETSS_PM_PRINT("ERROR NetIP level should not be reserved\n");
+         }
+
+         if (service_level & NETSS_BIT_MASK_ON_BATTERY)
+         {
             service_msg->onBattery = 1;
-            service_msg->netip_level = 0;
-         } else if ( 2 == (service_level & 3)) {
-            /*standby mode, put ARM11 in low power mode and disable all services */
-            service_msg->netip_level = 2;
-         } else if ( 3 == (service_level & 3)) {
-            /*deep standby mode, ARM11 and all netip services are off, PCI device should go to PCI_D3hot state */
-            service_msg->netip_level = 3;
+            g_onBattery = true;
          }
-         for(i=2; i<24; ) 
+         /*This is the case where service_level sysfs attribute is set by PMP
+          * we have to iterate from bit 2 to 23 to see the requested service states
+          * the desription of the servel_level vector is mentioned just above this function */
+         for(i = NETSS_SERVICE_ID_DOCSIS; i < NETSS_SERVICE_ID_MAX; i++) 
          {
-            uint32_t id = i/2;
-            uint8_t service_level = 0;
-            /*if that service is ready to be requested 
-             * BIT 0 represents SERVICE ID 1
-             * BIT 1 represents SERVICE ID 2 ... and so on
-             * BIT 5 represents SERVICE ID 6 (BBU) ... and so on
-             * BIT 11 represents SERVICE ID 12
-             */
-            if(g_netip_services_status_ready & (1 << ((id < 6)?(id-1):id))) {
-               if(id < 6) {
-                  service_msg->service[j].id = id;
-               } else {
-                  /*BBU is id 6 and service_level has no representation of BBU because 
-                   *PMP wont request its status, it is always on */
-                  service_msg->service[j].id = id+1;
+            if(netss_request_for_service_level_change(i-1))
+            {
+               uint32_t level = NETSS_GET_SERVICE_POWER_LEVEL(i, service_level); 
+               service_msg->service[j].id = i; 
+               service_msg->service[j].state = level;
+               if(level == NETSS_SERVICE_POWER_LEVEL_RESERVED)
+               {
+                  NETSS_PM_PRINT("ERROR service id %d  level should not be %d\n", i, NETSS_SERVICE_POWER_LEVEL_RESERVED);
+               }
+               if( IS_SERVICE_RESOURCE_TO_BE_CONTROLLED(i) && 
+                   (level == NETSS_SERVICE_POWER_LEVEL_ON) )
+               {
+                  netss_handle_resource_power_state(i, level);
                }
-               service_level = ((syfs_info->service_level >> i ) & 3 );
-               service_msg->service[j].state = (service_level < 2 )? service_level : service_level+1;
+                
                j++;
-            } else {
-               printk("Service id %d is not initialized, not including in the service request msg \n", 
-                       (id < 6)? id : id+1);
+               msg_len += 2;
+            } 
+            else 
+            {
+               NETSS_PM_PRINT("Service id %d is not initialized, not including in the service request msg \n", i);
             }
-            i += 2;
          }
       }
-      if(3 == (service_level & 3)) {
-         /*BBU should be off if NetIP going to deep standby*/
-         service_msg->service[j].id = 6;
-         service_msg->service[j].state = 3;
-      }
+      
       /*Null termination of the list */
-      service_msg->service[j].id = 0;
-      service_msg->service[j].state = 0;
-    
-      ret = hwMbox_sendOpcode(HW_MBOX_MASTER_NP_CPU, 1, (uint8_t *)service_msg, service_msg_len, service_msg_len, &reply_len);
-      if(ret) {
-         printk(KERN_ERR "Send Sevice Request message failed ret %d \n", ret);
-      } else {
-         netss_update_sysfs_attributes(syfs_info, service_msg);
+      if(msg_len % 4) {
+         service_msg->service[j].id = 0;
+         service_msg->service[j].state = 0;
+         msg_len += 2;
+      } 
+      else
+      {
+         service_msg->service[j].id = 0;
+         service_msg->service[j].state = 0;
+         j++;
+         service_msg->service[j].id = 0;
+         service_msg->service[j].state = 0;
+         msg_len += 4;
+
+      }
+
+      NETSS_PM_PRINT("service request:");
+      for(i=0; i<msg_len; i++)
+      {
+         if(i%4 == 0) 
+         {
+            NETSS_PM_PRINT("\n");
+         }
+         NETSS_PM_PRINT("%2X\t", msg[i]);
       }
-     // mutex_unlock(&syfs_info->lock);
-     /*Can free the message memory now */
-     kfree(service_msg);
+      NETSS_PM_PRINT("\n=======msg_len = %d ===================\n", msg_len);
+
+       ret = hwMbox_sendOpcode(HW_MBOX_MASTER_NP_CPU, 1, (uint8_t *)service_msg, msg_len, msg_len, &reply_len);
+       if(ret) 
+       {
+          printk(KERN_ERR "Send Sevice Request message failed ret %d \n", ret);
+       } 
+       else 
+       {
+          g_netip_service_request_reply_pending =  true;
+          /**Power manager or PMP is making these requests */
+          if( g_netss_boot_handshake_done )
+          {
+             for(i=0; i<j; i++)
+             {
+                if(service_msg->service[i].id != 0)
+                {
+                   g_netip_services_change_requested |= (1 << (service_msg->service[i].id-1));
+                }            
+             }
+             
+             if(g_timer_created) 
+             {
+                /**Set the timeout  value 30 sec before getting replies for all the services */
+                netss_pm_timer.expires = jiffies + msecs_to_jiffies(30000);
+                add_timer(&netss_pm_timer);
+             }
+          }
+       }
+       // mutex_unlock(&syfs_info->lock);
+       /*Can free the message memory now */
+       kfree(service_msg);
    }
    
    /**Add some debug message on success */   
-   
    return ret;
 }
+
+/**Function to send a single service message */
 static int ness_send_single_service_request_msg(uint32_t service_id, uint32_t state)
 {
    int ret = -1;
@@ -470,7 +763,7 @@ static int ness_send_single_service_request_msg(uint32_t service_id, uint32_t st
    uint32_t service_msg_len;
    netss_sysfs_attributes_info_t *syfs_info = &g_netss_sysfs_attributes_info;
 
-   service_msg_len = sizeof(netss_service_request_msg_t)+sizeof(netss_service_status_t)+4;
+   service_msg_len = sizeof(netss_service_request_msg_t)+(2*sizeof(netss_service_status_t));;
    /* Alloc memory for service request message */
    service_msg = kzalloc(service_msg_len, GFP_KERNEL);
    if(!service_msg) {
@@ -479,19 +772,11 @@ static int ness_send_single_service_request_msg(uint32_t service_id, uint32_t st
    else
    {
       service_msg->hdr.opcode = NETSS_OPCODE_SERVICE_REQUEST;
-     
-      if(g_current_netip_power_state == NETIP_ACTIVE_ON_AC) {
-         service_msg->netip_level = 0;
-      } else if (g_current_netip_power_state == NETIP_ACTIVE_ON_BATTERY) {
-         service_msg->netip_level = 0;
-         service_msg->onBattery = 1;
-      } else if (g_current_netip_power_state == NETIP_STANDBY) {
-         service_msg->netip_level = 2;
-      } else if (g_current_netip_power_state == NETIP_DEEP_STANDBY) {
-         service_msg->netip_level = 3;
-      }
+      service_msg->onBattery = g_onBattery;
+      service_msg->netip_level = g_current_netip_power_state;
+
       service_msg->service[0].id = service_id;
-      service_msg->service[0].state = (state < 2)? state : 3;
+      service_msg->service[0].state = state;
       
       service_msg->service[1].id = 0;
       service_msg->service[1].state = 0;
@@ -500,12 +785,19 @@ static int ness_send_single_service_request_msg(uint32_t service_id, uint32_t st
       if(ret) {
          printk(KERN_ERR "Send Single Sevice Request message failed ret %d \n", ret);
       } else {
-         netss_update_sysfs_attributes(syfs_info, service_msg);
+         /*Mark that reply is pending */
+         g_netip_service_request_reply_pending = true;
+         if(g_netss_boot_handshake_done) 
+         {
+            g_netip_services_change_requested |= (1 << (service_id-1));
+         }
+         
       }
 
       /*Can free the message memory now */
       kfree(service_msg);
    }   
+   return ret;
 }
 static int netss_configure_and_setup_netip_services(void *data)
 {
@@ -519,14 +811,24 @@ static int netss_configure_and_setup_netip_services(void *data)
          /*Register netip properties message, update tag and token later */
          hwMbox_registerRecvOpcode(HW_MBOX_MASTER_NP_CPU,
                                    netss_receive_netip_msg,
-                                   0, 0x1);
-         printk("Slept for iterations %d msec %d\n", sleep_count, sleep_count*10); 
+                                   NETSS_MSG_TAG_PROPS_CNFGR_STAT, 0x0);
+         hwMbox_registerRecvOpcode(HW_MBOX_MASTER_NP_CPU,
+                                   netss_receive_netip_msg,
+                                   NETSS_MSG_TAG_SERVICE_REQ_RPLY, 0x1);
+
+         NETSS_PM_PRINT("Slept for iterations %d msec %d\n", sleep_count, sleep_count*10); 
          break;
       }
       msleep(10);
       sleep_count++;
       
    }
+   init_timer(&netss_pm_timer);
+   g_timer_created = true;
+   netss_pm_timer.expires = jiffies + msecs_to_jiffies(60000);
+   netss_pm_timer.function = netss_pm_timeout_handler;
+   /**Within a minute atleast we should receive netip propertis msg */
+   add_timer(&netss_pm_timer);
    while(1)
    {
       /*Wait for netip messages */
@@ -539,7 +841,7 @@ static int netss_configure_and_setup_netip_services(void *data)
          break;
       };
 
-      NETSS_DBG_PRINT("Message from NetIP %d opcode %d \n", g_netip_msg, pnetss_drv_data->netip_msg.type);
+      NETSS_PM_PRINT("Message from NetIP %d opcode %d \n", g_netip_msg, pnetss_drv_data->netip_msg.type);
       /*Acquire sysfs lock */
       mutex_lock(&g_netss_sysfs_attributes_info.lock);
       if(pnetss_drv_data->netip_msg.type == NETSS_OPCODE_NETIP_PROPERTIES) {
@@ -549,39 +851,80 @@ static int netss_configure_and_setup_netip_services(void *data)
          ness_process_netip_props_msg();
          /* send configure message */
          netss_send_configure_msg();
+         if(g_timer_created)
+         {
+            /**Within 30 seconds we should receive status message */
+            mod_timer(&netss_pm_timer, jiffies + msecs_to_jiffies(30000));
+         }
          
       } else if(pnetss_drv_data->netip_msg.type == NETSS_OPCODE_SERVICE_STATUS) {
          /*send reply*/
          netss_send_reply_ack();
          /*process service status message */
          ness_process_service_status_msg();
-         /* send service request message */
-         ness_send_service_request_msg(g_netss_sysfs_attributes_info.service_level);
-      } else if (g_netip_msg == 5) {
-         NETSS_DBG_PRINT("EJ test wake up received %d\n", count++);
-      } else {
-         printk("Unknown message received Opcode type %d\n", pnetss_drv_data->netip_msg.type);
+         if(!g_netip_service_request_reply_pending)
+         {
+            /* send service request message */
+            netss_send_service_request_msg(g_netss_sysfs_attributes_info.service_level);
+         }
+         if(g_timer_created)
+         {
+            /**set timeout as we are waiting for service request replies */
+            mod_timer(&netss_pm_timer, jiffies + msecs_to_jiffies(30000));
+         }
+      } else if(pnetss_drv_data->netip_msg.type == NETSS_OPCODE_SERVICE_REQUEST_REPLY) {
          /*send reply*/
          netss_send_reply_ack();
-      }
-
-      /*We will get multiple service status message, one message per one subsystem
-       *LAN subsystem includes service status message for rgmii0, rgmii1, sgmii2, sgmii3 services/ports */
-
-      if((g_netip_services_available != 0) && (g_netip_services_available == g_netip_services_status_received)) {
-         /*received and requested status of all services */
-         g_netss_boot_handshake_done = true;
+         /*We got a reply */
+         g_netip_service_request_reply_pending = false;
 
+         netss_update_sysfs_attributes(&g_netss_sysfs_attributes_info, (netss_service_request_msg_t*) &pnetss_drv_data->netip_msg.payload[0]);
+         
+         /*Check if all the ready services are moved to initial power state */
+         if(g_netip_services_status_ready == g_netip_services_init_complete)
+         {
+            if(g_netss_boot_handshake_done == false)
+            {
+               /*Check if we have received status messages for all services */
+               if(g_netip_services_status_received  == g_netip_services_available) 
+               {
+                  g_netss_boot_handshake_done = true;
+                  
+                  printk("Dual boot handshake is done services available %08X init complete %08X\n", g_netip_services_available, g_netip_services_init_complete);
 #ifdef CONFIG_PM_RUNTIME
-         /**Increament the usage counter */
-         pm_runtime_get_noresume(&pnetss_drv_data->dev->dev);
+                  /**Increament the usage counter */
+                  /**Count is already one so dont increament */
+                  //pm_runtime_get_noresume(&pnetss_drv_data->dev->dev);
 #endif
-         NETSS_DBG_PRINT("service status of all available services received \n");
-         /*This thread can exit here */
+                  if(g_onBattery) 
+                  {
+                     puma_netip_notify_state(1);
+                  }
+                  else
+                  {
+                     puma_netip_notify_state(0);
+                  }
+               }  
+               else
+               {
+                  NETSS_PM_PRINT("Status of all services not recvd Available %X status recvd %X\n", g_netip_services_status_received, g_netip_services_available);
+               }
+            }
+         }
+         else
+         {
+            /* send service request message */
+            netss_send_service_request_msg(g_netss_sysfs_attributes_info.service_level);
+         }
+      } else if (g_netip_msg == 5) {
+         NETSS_PM_PRINT("test wake up received %d\n", count++);
       } else {
-         NETSS_DBG_PRINT("services available %x status received %x\n", g_netip_services_available, g_netip_services_status_received);
+         NETSS_PM_PRINT("Unknown message received Opcode type %d\n", pnetss_drv_data->netip_msg.type);
+         /*send reply*/
+         netss_send_reply_ack();
       }
-      /*Done processing the message */ 
+
+     /*Done processing the message */ 
       g_netip_msg = NETIP_MSG_NONE;
       /*Release sysfs lock */
       mutex_unlock(&g_netss_sysfs_attributes_info.lock);
@@ -615,46 +958,71 @@ void netss_stop_handshake_thread(void)
 int netss_set_service_state(uint32_t service_id, uint32_t state)
 {
    mutex_lock(&g_netss_sysfs_attributes_info.lock);
+
+   if(g_netip_service_request_reply_pending ) {
+      NETSS_PM_PRINT("Service Request Reply is pending, so cannot send another request\n");
+      mutex_unlock(&g_netss_sysfs_attributes_info.lock);
+      return -1;
+   }
    if(g_netss_boot_handshake_done) {
       /*send message to netip and update the value based on reply*/
       ness_send_single_service_request_msg(service_id, state);
    } else {
-      g_netss_sysfs_attributes_info.runtime_state[service_id] = state;
+      //g_netss_sysfs_attributes_info.runtime_state[service_id] = state;
    }
    mutex_unlock(&g_netss_sysfs_attributes_info.lock);
    return 0;
 }
 EXPORT_SYMBOL(netss_set_service_state);
-uint32_t netss_get_service_state(uint32_t service_id, uint32_t state)
+uint32_t netss_get_service_state(uint32_t service_id)
 {
    uint32_t ret;
    mutex_lock(&g_netss_sysfs_attributes_info.lock);
-   ret = g_netss_sysfs_attributes_info.runtime_state[service_id]; 
+   //ret = g_netss_sysfs_attributes_info.runtime_state[service_id]; 
+   ret = g_netss_sysfs_attributes_info.service_status; 
    mutex_unlock(&g_netss_sysfs_attributes_info.lock); 
    return ret;
 }
 EXPORT_SYMBOL(netss_get_service_state);
-int netss_set_service_level(uint32_t level)
+
+
+int __netss_set_service_level(uint32_t level)
 {
    int ret = -1;
-   netss_power_state_t new_state = level & NETSS_POWER_STATE_MASK;
-   
-   mutex_lock(&g_netss_sysfs_attributes_info.lock); 
-
+   netss_power_level_t new_state = level & NETSS_BIT_MASK_POWER_LEVEL;
+  
+   /** Updated the global service level */
+   g_netss_sysfs_attributes_info.service_level = level;
    /*If Boot handshake is not done, just update the attribute and 
     *boot handshake thread will send the message */
-   if(g_netss_boot_handshake_done) {
-      if(new_state == NETIP_DEEP_STANDBY) {
-         ret = ness_send_service_request_msg(level);
+   if(g_netss_boot_handshake_done && !g_netip_service_request_reply_pending) {
 
-#ifdef CONFIG_PM_RUNTIME
-         pm_runtime_put(&pnetss_drv_data->dev->dev);
-#endif
+      /**NOTE: WHEN TO CALL PLATFORM API
+       * If new power state is greater old power state, call before making service request
+       * Else if new power state  old power state, call after making service request 
+       * ORDER OF THE POWER states FROM HIGHEST TO LOWEST
+       * |======================= ===================|
+       * |POWER LEVELS                  | ENUMERATION|
+       * |===========================================| 
+       * |NETSS_POWER_LEVEL_ACTIVE      |     0      |
+       * |NETSS_POWER_LEVEL_RESERVED    |     1      |
+       * |NETSS_POWER_LEVEL_DISABLE     |     2      |
+       * |NETSS_POWER_LEVEL_DEEP_STANDBY|     3      |
+       * |===========================================|
+       */
 
-      } else if(new_state == NETIP_ACTIVE_ON_AC && g_current_netip_power_state == NETIP_DEEP_STANDBY) {
-         /* TODO
+      if(new_state == NETSS_POWER_LEVEL_DEEP_STANDBY && g_current_netip_power_state != NETSS_POWER_LEVEL_DEEP_STANDBY) {
+         /**We are going to deep standby lowest power level */
+         ret = netss_send_service_request_msg(level);
+         /* This has to be done in the netss_update_sysfs_attributes after
+          * receiving the reply for all the service requests 
           * 1. Call the platform driver api
           */
+      } else if(new_state == NETSS_POWER_LEVEL_ENABLE && g_current_netip_power_state == NETSS_POWER_LEVEL_DEEP_STANDBY) {
+         /*
+          * 1. Call the platform driver api
+          */
+          puma_netip_notify_state(((level & NETSS_BIT_MASK_ON_BATTERY)? 1:0));
 #ifdef CONFIG_PM_RUNTIME
          pm_runtime_get(&pnetss_drv_data->dev->dev);
 #endif
@@ -663,21 +1031,40 @@ int netss_set_service_level(uint32_t level)
       } else if(new_state > g_current_netip_power_state) {
          /*Going to lower power state Ex: Active to BBU, Active to Standby
           *BBU to standby */
-         ret = ness_send_service_request_msg(level);
-         /* TODO 
+         ret = netss_send_service_request_msg(level);
+         /* This has to be done in the netss_update_sysfs_attributes after
+          * receiving the reply for all the service requests 
           * 1. Call the platform driver api
           */
       } else if(new_state < g_current_netip_power_state) {
          /*Going to higher power state Ex: BBU to Active or Standby to Active */
-         /* TODO 
+         /* 
           * 1. Call the platform driver api
           */
-         ret = ness_send_service_request_msg(level);
+          puma_netip_notify_state(((level & NETSS_BIT_MASK_ON_BATTERY)? 1:0));
+          ret = netss_send_service_request_msg(level);
+      } else {
+         /*This is probably changing the individual services without changing netip level */
+         ret = netss_send_service_request_msg(level);
       }
    } else {
-      g_netss_sysfs_attributes_info.service_level = level;
+      /*Service request reply is pending mark service request is pending
+       *so this request will be sent after receiving all replies to the earlier request */
+      if(g_netip_service_request_reply_pending) 
+      {
+         NETSS_PM_PRINT("service level Request pending %X\n", level);
+         g_netip_service_level_request_pending = true;
+      }
    }
-   mutex_unlock(&g_netss_sysfs_attributes_info.lock); 
+   
+   return ret;
+}
+int netss_set_service_level(uint32_t level)
+{
+   int ret = -1;
+   mutex_lock(&g_netss_sysfs_attributes_info.lock);
+   ret = __netss_set_service_level(level);
+   mutex_unlock(&g_netss_sysfs_attributes_info.lock);
    return ret;
 }
 EXPORT_SYMBOL(netss_set_service_level);
@@ -691,23 +1078,51 @@ uint32_t netss_get_service_level(void)
 }
 EXPORT_SYMBOL(netss_get_service_level);
 
+/**Not locking using sysfs attributes lock
+ * user should write this when before running any test */
+int netss_get_debug_level(void)
+{
+   return g_enable_debug; 
+}
+EXPORT_SYMBOL(netss_get_debug_level);
+void netss_set_debug_level(int debug_level)
+{
+   mutex_lock(&g_netss_sysfs_attributes_info.lock); 
+   g_enable_debug = debug_level;
+   mutex_unlock(&g_netss_sysfs_attributes_info.lock); 
+}
+EXPORT_SYMBOL(netss_set_debug_level);
+
 int netss_runtime_suspend(struct device *dev)
 {
    int i=0;
+   uint32_t level;
    struct pci_dev *pdev = to_pci_dev(dev);
    struct net_subsystem_drv_data *pnetss_drv_data = pci_get_drvdata(pdev);
 
    mutex_lock(&g_netss_sysfs_attributes_info.lock);
-   NETSS_DBG_PRINT("NETSS SUSPEND CALLED\n");
-   for(i=0;i<13;i++)
+   NETSS_PM_PRINT("NETSS SUSPEND CALLED\n");
+
+   /**NetIP subsystem overall power level */
+   level = g_netss_sysfs_attributes_info.service_status & NETSS_BIT_MASK_POWER_LEVEL;
+   if(level != NETSS_POWER_LEVEL_DEEP_STANDBY && g_current_netip_power_state != NETSS_POWER_LEVEL_DEEP_STANDBY)
    {
-      if(i==6) continue; /*SKIP BBU */
-      if(g_netss_sysfs_attributes_info.runtime_state[i] !=  NETIP_DEEP_STANDBY) {
-         printk(KERN_ERR "Service id %d is not in disable state, current state is %d\n", i, g_netss_sysfs_attributes_info.runtime_state[i]);
+      printk(KERN_ERR "NetIP subsystem power level is not in deep standby, current state is %d\n", level);
+   }
+   for(i = NETSS_SERVICE_ID_DOCSIS; i < NETSS_SERVICE_ID_MAX;i++)
+   {
+      level = NETSS_GET_SERVICE_POWER_LEVEL(i, g_netss_sysfs_attributes_info.service_status);
+      if(level !=  NETSS_SERVICE_POWER_LEVEL_OFF)
+      {
+         printk(KERN_ERR "Service id %d is not in disable state, current state is %d\n", i, level);
       }
    }
-   /*TODO
-    *1. Call the platform driver api */
+   /*
+    *1. Call the platform driver api 
+    */
+    puma_netip_notify_state(3);
+    /*Resume will be like a fresh boot for NETIP, which involues netip properties, configure messages */
+    g_netss_boot_handshake_done = false;
 
    mutex_unlock(&g_netss_sysfs_attributes_info.lock);
    return 0;
@@ -720,7 +1135,7 @@ int netss_runtime_resume(struct device *dev)
   
    mutex_lock(&g_netss_sysfs_attributes_info.lock);
    level = g_netss_sysfs_attributes_info.service_level; 
-   ness_send_service_request_msg(level); 
+   netss_send_service_request_msg(level); 
    mutex_unlock(&g_netss_sysfs_attributes_info.lock);
    return 0;
 }
@@ -732,6 +1147,8 @@ int netss_runtime_idle(struct device *dev)
    return 0;
 }
 
+/**This is a test api to test whether netip subsystem message handling thread
+ * wakes up correctly or not */
 void netss_wakeup_netip_manager_thread(void)
 {
    mutex_lock(&pnetss_drv_data->netip_msg.lock);
diff --git a/arch/x86/NetIP_SubSystem/netip_subsystem_pm.h b/arch/x86/NetIP_SubSystem/netip_subsystem_pm.h
new file mode 100644
index 0000000..4762141
--- /dev/null
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_pm.h
@@ -0,0 +1,142 @@
+/*
+ * netip_subsystem_pm.h
+ *
+ *  GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2015 Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *    Intel Corporation
+ *    2200 Mission College Blvd.
+ *    Santa Clara, CA  97052
+ *
+ */
+#ifndef _NETIP_SUBSYSTEM_PM_H
+#define _NETIP_SUBSYSTEM_PM_H
+
+/**Defines that indicates the type of message received  
+ * message handling while loop thread uses these values */
+#define NETIP_MSG_NONE 0
+#define NETIP_PROPERTIES_MSG 1
+#define NETIP_STATUS_MSG 2
+#define NETIP_STATUS_REQUEST_REPLY 3
+
+/**Bit position in sysfs service level vector that indicates whether we are on Battery or not */
+#define NETSS_BIT_MASK_ON_BATTERY (8)
+/**Bit mask to extract power level of netip or service. two bits  */
+#define NETSS_BIT_MASK_POWER_LEVEL (3)
+
+/**NetIP subsystem message tag used for properties, configure and status messages */
+#define NETSS_MSG_TAG_PROPS_CNFGR_STAT (0)
+/**NetIP subsystem message tag used for service request and service request reply */
+#define NETSS_MSG_TAG_SERVICE_REQ_RPLY (1)
+
+/**Macro to get the individual service level from the service vector  */
+#define NETSS_GET_SERVICE_POWER_LEVEL(id, val) ((val >> (2*(id+1))) & NETSS_BIT_MASK_POWER_LEVEL) 
+/**Macro to set the individual service level in the service status vector  */
+#define NETSS_SET_SERVICE_POWER_LEVEL(id, val) ((val & NETSS_BIT_MASK_POWER_LEVEL) << (2*(id+1)))
+/**Macro to clear the individual service level from the service status vector  */
+#define NETSS_CLEAR_SERVICE_POWER_LEVEL(id, val) (val &= ~(NETSS_BIT_MASK_POWER_LEVEL << (2*(id+1))))
+/** Opcode Enumeration */
+typedef enum netss_opcodes {
+   NETSS_OPCODE_NETIP_PROPERTIES = 1,
+   NETSS_OPCODE_SERVICE_STATUS = 2,
+   NETSS_OPCODE_SERVICE_REQUEST_REPLY = 3,
+   NETSS_OPCODE_CONFIGURE = 4,
+   NETSS_OPCODE_SERVICE_REQUEST = 5,
+}netss_opcodes_t;
+
+/**NetIP subsystem overall power level */
+typedef enum netss_level_state 
+{
+   NETSS_POWER_LEVEL_ENABLE = 0,
+   NETSS_POWER_LEVEL_RESERVED = 1,
+   NETSS_POWER_LEVEL_DISABLE = 2,
+   NETSS_POWER_LEVEL_DEEP_STANDBY = 3,
+   NETSS_POWER_LEVEL_INVALID = 4,
+}netss_power_level_t;
+
+/**NetIP subsystem individual service power level */
+typedef enum netss_service_power_level_state 
+{
+   NETSS_SERVICE_POWER_LEVEL_ON = 0,
+   NETSS_SERVICE_POWER_LEVEL_LOW = 2,
+   NETSS_SERVICE_POWER_LEVEL_RESERVED = 2,
+   NETSS_SERVICE_POWER_LEVEL_OFF = 3,
+}netss_service_power_level_t;
+
+/**NetIP subsystem service status */
+typedef enum netss_service_status_type
+{
+   NETSS_SERVICE_STATUS_UNUSABLE = 0,
+   NETSS_SERVICE_STATUS_INITIALIZED
+}netss_service_status_type_t;
+
+typedef struct netss_sysfs_attributes_info {
+   uint32_t service_level;        /**sysfs attrivute. it is a vector that represents the netip and its services power states  
+                                   * It is Write only to user space */
+   uint32_t service_status;       /**sysfs attrivute. it is a vector that represents the netip and its services power states 
+                                   * It is Read Only for user space. This gets updated after the service request reply is received. */
+   uint32_t runtime_state[13];    /**sysfs attibute, for configuring individual service power states */
+   struct mutex lock;            /**to synchronise between the thread that is writing to service_level and thread that is sending message
+                                  * This lock may be needed only during boot time. */
+} netss_sysfs_attributes_info_t;
+
+typedef struct netss_msg_info {
+   uint32_t type;         /**Netip properties or service status msg */
+   uint32_t len;          /**Payload length */
+   uint8_t payload[64];   /**Payload */
+   
+   struct mutex lock; 
+} netss_msg_info_t;
+
+typedef struct netss_service_status {
+   uint8_t id;
+   uint8_t state;
+}netss_service_status_t;
+
+typedef union netss_msg_header {
+   uint8_t  opcode;
+   uint32_t header;
+} netss_msg_header_t;
+ 
+typedef struct netss_configure_msg {
+   netss_msg_header_t hdr;       /**header of the message */
+   //uint32_t num_ds_chan;     /**Number of QAM DS channels */
+   uint8_t  docsis_chan[32]; /** each byte if 1, indicates that it is a docsis channel */
+   uint32_t cm_mode;         /**Cable modem operational mode  */
+   uint32_t RCE_floor;       /** */
+   uint32_t RCE_filter;      /** */
+} netss_configure_msg_t;
+
+typedef struct netss_service_status_msg {
+   netss_msg_header_t hdr;       /**header of the message */
+   uint32_t  netip_level;     /** ARM11 power state 0==Active, 2==low power, 3==disable */
+   netss_service_status_t service[0];
+}netss_service_status_msg_t;
+
+typedef struct netss_service_request_msg {
+   netss_msg_header_t hdr;       /**header of the message */
+   uint32_t onBattery;       /**1 == system is on battery or 0 system is on AC power  */
+   uint32_t  netip_level;     /** ARM11 power state 0==Active, 2==low power, 3==disable */
+   netss_service_status_t service[0];
+}netss_service_request_msg_t;
+
+
+#endif
+
diff --git a/drivers/net/NetIP_Subsystem_sysfs/netip_subsystem_sysfs.c b/drivers/net/NetIP_Subsystem_sysfs/netip_subsystem_sysfs.c
index ad5161a..4808c23 100644
--- a/drivers/net/NetIP_Subsystem_sysfs/netip_subsystem_sysfs.c
+++ b/drivers/net/NetIP_Subsystem_sysfs/netip_subsystem_sysfs.c
@@ -1,7 +1,7 @@
 /*  netip_subsystem_sysfs.c: 
  *  GPL LICENSE SUMMARY
  *
- *  Copyright(c) 2014 Intel Corporation. All rights reserved.
+ *  Copyright(c) 2015 Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of version 2 of the GNU General Public License as
@@ -31,6 +31,7 @@
 #include <linux/init.h>
 #include <linux/rtnetlink.h>
 #include <linux/string.h>
+#include <linux/netip_subsystem.h>
 
 static int netssdev_dummy_init(struct net_device *dev)
 {
@@ -53,22 +54,6 @@ static void dummy_setup(struct net_device *dev)
    dev->netdev_ops = &dummy_netdev_ops;
    dev->destructor = free_netdev;
 }
-#define NETSS_SERVICES_MAX 13
-typedef enum netss_service_id_t {
-   NETIP_SUBSYSTEM = 0,
-   DOCSIS,
-   SPECTRAL_ANALYSIS,
-   VIDEO,
-   VOICE,
-   MOCA,
-   BBU,
-   WIFI,
-   EXSW,
-   RGMII0,
-   RGMII1,
-   SGMII2,
-   SGMII3,
-} netss_service_id_t;
 
 struct netss_dev_priv_data_t {
   netss_service_id_t service_id;
@@ -77,9 +62,184 @@ static struct net_device *g_netssdevs[NETSS_SERVICES_MAX];
 extern const char power_group_name[];
 extern uint32_t netss_get_service_state(uint32_t service_id);
 extern int netss_set_service_state(uint32_t service_id, uint32_t state);
+
+extern int netss_get_debug_level(void);
+extern void netss_set_debug_level(int debug_level);
+
 extern uint32_t netss_get_service_level(void);
 extern int netss_set_service_level(uint32_t level);
 
+static ssize_t enable_debug_show(struct device * dev, struct device_attribute *attr, char *buf)
+{
+   return sprintf(buf, "%d\n", netss_get_debug_level());
+}
+
+static ssize_t enable_debug_store(struct device * dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+   int ret;
+   int debug_level = 0;
+   ret = kstrtoint(buf, 10, &debug_level);
+   
+   netss_set_debug_level(debug_level);
+   //printk("Writing to service level ret  %d val = %x\n", ret, service_level);
+   return count;
+}
+static ssize_t service_level_show(struct device * dev, struct device_attribute *attr, char *buf)
+{
+   uint32_t service_level;
+   if(strncmp(attr->attr.name, "service_level", 13) == 0)
+   {
+      service_level = netss_get_service_level();
+   }
+   else
+   {
+      service_level = netss_get_service_state(0);
+   }
+   return sprintf(buf, "0x%08X\n", (unsigned int)service_level);;
+}
+
+static ssize_t service_level_store(struct device * dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+   int ret;
+   uint32_t service_level;
+   ret = kstrtou32(buf,16,&service_level );
+
+   netss_set_service_level(service_level);
+   //printk("Writing to service level ret  %d val = %x\n", ret, service_level);
+   return count;
+}
+//static DEVICE_ATTR(runtime_state, 0644, runtime_state_show, runtime_state_store);
+static DEVICE_ATTR(enable_debug, 0644, enable_debug_show, enable_debug_store);
+static DEVICE_ATTR(service_level, 0644, service_level_show, service_level_store);
+static DEVICE_ATTR(service_status, 0444, service_level_show, service_level_store);
+
+char * get_netss_service_name(int i)
+{
+   switch(i) 
+   {
+      case NETIP_SUBSYSTEM:
+         return "netip_subsystem";
+      case NETSS_SERVICE_ID_DOCSIS:
+         return "docsis";
+      case NETSS_SERVICE_ID_SPECTRAL_ANALYSIS:
+         return "spectraAnalysis";
+      case NETSS_SERVICE_ID_VIDEO:
+         return "video";
+      case NETSS_SERVICE_ID_VOICE:
+         return "voice"; 
+      case NETSS_SERVICE_ID_MOCA:
+         return "moca";
+      case NETSS_SERVICE_ID_BBU:
+         return "bbu";
+      case NETSS_SERVICE_ID_WIFI:
+         return "wifi";
+      case NETSS_SERVICE_ID_EXSW:
+         return "exSw";
+      case NETSS_SERVICE_ID_SGMII0:
+         return "sgmii0";
+      case NETSS_SERVICE_ID_SGMII1:
+         return "sgmii1";
+      case NETSS_SERVICE_ID_RGMII2:
+         return "rgmii2";
+      case NETSS_SERVICE_ID_RGMII3:
+         return "rgmii3";
+      default:
+	return "";
+   }
+}
+
+static int __init netss_sysfs_create_netip_attributes(void)
+{
+   struct netss_dev_priv_data_t *pnetss_dev_priv_data;
+   int ret;
+
+   g_netssdevs[0] = alloc_netdev(sizeof(struct netss_dev_priv_data_t), get_netss_service_name(0), dummy_setup);
+
+   if(!g_netssdevs[0])
+   {
+      ret = -ENOMEM;
+   }
+   else
+   {
+      pnetss_dev_priv_data = netdev_priv(g_netssdevs[0]);
+      pnetss_dev_priv_data->service_id = 0;
+   
+      ret = register_netdevice(g_netssdevs[0]);
+      if (ret < 0) 
+      {
+         free_netdev(g_netssdevs[0]);
+      }
+      else
+      {
+         ret = device_create_file(&g_netssdevs[0]->dev, &dev_attr_service_level);
+         if(ret < 0)
+         {
+            printk("NetIP subsystem service_level sysfs could not be created\n");
+         }
+         else if (0 > (ret = device_create_file(&g_netssdevs[0]->dev, &dev_attr_service_status)))
+         {
+            printk("NetIP subsystem service_status sysfs could not be created\n");
+         } 
+         else if( 0 > (ret = device_create_file(&g_netssdevs[0]->dev, &dev_attr_enable_debug)))
+         {
+            printk("NetIP subsystem enable_debug sysfs could not be created\n");
+         } 
+      }
+   
+   }
+   return ret;
+}
+
+static int __init netss_sysfs_init_module(void)
+{
+   int i, err = 0;
+   for(i=0; i<NETSS_SERVICES_MAX; i++)
+   {
+      g_netssdevs[i] = NULL;
+   }
+   rtnl_lock();
+   err = netss_sysfs_create_netip_attributes();
+   rtnl_unlock();
+ 
+   return err;
+}
+
+static void __exit netss_sysfs_cleanup_module(void)
+{
+   int i;
+   for(i=0; i<NETSS_SERVICES_MAX; i++)
+   {
+      if(g_netssdevs[i] != NULL) {
+         unregister_netdevice(g_netssdevs[i]);
+         free_netdev(g_netssdevs[i]);
+         g_netssdevs[i] = NULL;
+     }
+   }
+}
+void netss_sysfs_clean_up(uint32_t available_services)
+{
+   int i = 1;
+   for(i=0; i<NETSS_SERVICES_MAX; i++)
+   {
+     if(!(available_services & (1 << i))) {
+        if(g_netssdevs[i] != NULL) {
+           unregister_netdevice(g_netssdevs[i]);
+           free_netdev(g_netssdevs[i]);
+           g_netssdevs[i] = NULL;
+        }
+     }
+   }
+
+   return;
+}
+EXPORT_SYMBOL(netss_sysfs_clean_up);
+
+module_init(netss_sysfs_init_module);
+module_exit(netss_sysfs_cleanup_module);
+MODULE_DESCRIPTION("Intel(R) NET SUBSYSTEM sysfs Driver");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("GPL");
+#if 0
 static char * convert_level_to_string_and_show(netss_service_id_t id, uint32_t state)
 {
    char *ret = NULL;
@@ -251,59 +411,6 @@ static ssize_t runtime_state_store(struct device * dev, struct device_attribute
    return count;
 }
 
-static ssize_t service_level_show(struct device * dev, struct device_attribute *attr, char *buf)
-{
-   uint32_t service_level;
-   service_level = netss_get_service_level();
-   return sprintf(buf, "0x%x\n", service_level);;
-}
-
-static ssize_t service_level_store(struct device * dev, struct device_attribute *attr, const char *buf, size_t count)
-{
-   int ret;
-   uint32_t service_level;
-   ret = kstrtou32(buf,16,&service_level );
-
-   netss_set_service_level(service_level);
-   printk("Writing to service level ret  %d val = %x\n", ret, service_level);
-   return count;
-}
-static DEVICE_ATTR(runtime_state, 0644, runtime_state_show, runtime_state_store);
-static DEVICE_ATTR(service_level, 0644, service_level_show, service_level_store);
-
-char * get_netss_service_name(int i)
-{
-   switch(i) 
-   {
-      case NETIP_SUBSYSTEM:
-         return "subsystem";
-      case DOCSIS:
-         return "docsis";
-      case SPECTRAL_ANALYSIS:
-         return "spectraAnalysis";
-      case VIDEO:
-         return "video";
-      case VOICE:
-         return "voice"; case MOCA:
-         return "moca";
-      case BBU:
-         return "bbu";
-      case WIFI:
-         return "wifi";
-      case EXSW:
-         return "exSw";
-      case RGMII0:
-         return "rgmii0";
-      case RGMII1:
-         return "rgmii1";
-      case SGMII2:
-         return "sgmii2";
-      case SGMII3:
-         return "sgmii3";
-      default:
-	return "";
-   }
-}
 static int __init netss_sysfs_create_netip_attributes(void)
 {
    struct netss_dev_priv_data_t *pnetss_dev_priv_data;
@@ -364,53 +471,4 @@ free_netdevs:
    return ret;
 }
 
-
-static int __init netss_sysfs_init_module(void)
-{
-   int i, err = 0;
-   for(i=0; i<NETSS_SERVICES_MAX; i++)
-   {
-      g_netssdevs[i] = NULL;
-   }
-   rtnl_lock();
-   err = netss_sysfs_create_netip_attributes();
-   rtnl_unlock();
- 
-   return err;
-}
-
-static void __exit netss_sysfs_cleanup_module(void)
-{
-   int i;
-   for(i=0; i<NETSS_SERVICES_MAX; i++)
-   {
-      if(g_netssdevs[i] != NULL) {
-         unregister_netdevice(g_netssdevs[i]);
-         free_netdev(g_netssdevs[i]);
-         g_netssdevs[i] = NULL;
-     }
-   }
-}
-void netss_sysfs_clean_up(uint32_t available_services)
-{
-   int i = 1;
-   for(i=0; i<NETSS_SERVICES_MAX; i++)
-   {
-     if(!(available_services & (1 << i))) {
-        if(g_netssdevs[i] != NULL) {
-           unregister_netdevice(g_netssdevs[i]);
-           free_netdev(g_netssdevs[i]);
-           g_netssdevs[i] = NULL;
-        }
-     }
-   }
-
-   return;
-}
-EXPORT_SYMBOL(netss_sysfs_clean_up);
-
-module_init(netss_sysfs_init_module);
-module_exit(netss_sysfs_cleanup_module);
-MODULE_DESCRIPTION("Intel(R) NET SUBSYSTEM sysfs Driver");
-MODULE_AUTHOR("Intel Corporation");
-MODULE_LICENSE("GPL");
+#endif
diff --git a/include/linux/netip_subsystem.h b/include/linux/netip_subsystem.h
index a920018..7d7c836 100755
--- a/include/linux/netip_subsystem.h
+++ b/include/linux/netip_subsystem.h
@@ -95,6 +95,23 @@ typedef struct netss_dev_info {
    unsigned long size;
 }netss_dev_info_t;
 
+#define NETSS_SERVICES_MAX 13
+typedef enum netss_service_id_t {
+   NETIP_SUBSYSTEM = 0,
+   NETSS_SERVICE_ID_DOCSIS,
+   NETSS_SERVICE_ID_SPECTRAL_ANALYSIS,
+   NETSS_SERVICE_ID_VIDEO,
+   NETSS_SERVICE_ID_VOICE,
+   NETSS_SERVICE_ID_MOCA,
+   NETSS_SERVICE_ID_BBU,
+   NETSS_SERVICE_ID_WIFI,
+   NETSS_SERVICE_ID_EXSW,
+   NETSS_SERVICE_ID_SGMII0,
+   NETSS_SERVICE_ID_SGMII1,
+   NETSS_SERVICE_ID_RGMII2,
+   NETSS_SERVICE_ID_RGMII3,
+   NETSS_SERVICE_ID_MAX 
+} netss_service_id_t;
 
 void netss_interrupt_register(netss_interrupt_t intrpt, int arm11_int_id, netss_interrupt_info_t *irq_info);
 bool netss_driver_ready(void);
-- 
1.7.9.5

