add v3.10.x kernel support for mpc83xx inc. DSL CO EASY85600 board support

diff --git a/target/linux/mpc83xx/Makefile b/target/linux/mpc83xx/Makefile
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/Makefile
@@ -0,0 +1,28 @@
+#
+# Copyright (C) 2007-2014 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+include $(TOPDIR)/rules.mk
+
+ARCH:=powerpc
+BOARD:=mpc83xx
+BOARDNAME:=Freescale MPC83xx
+CPU_TYPE:=603e
+FEATURES:=squashfs targz
+MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
+
+LINUX_VERSION:=3.10.49
+
+include $(INCLUDE_DIR)/target.mk
+
+DEFAULT_PACKAGES += kmod-via-velocity
+
+define Target/Description
+	Build firmware images for Freescale MPC83xx based boards (eg. RouterBoard 600).
+endef
+
+KERNELNAME:="uImage"
+
+$(eval $(call BuildTarget))
diff --git a/target/linux/mpc83xx/base-files.mk b/target/linux/mpc83xx/base-files.mk
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/base-files.mk
@@ -0,0 +1,5 @@
+define Package/base-files/install-target
+	rm -f $(1)/etc/config/network
+endef
+
+
diff --git a/target/linux/mpc83xx/base-files/etc/inittab b/target/linux/mpc83xx/base-files/etc/inittab
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/base-files/etc/inittab
@@ -0,0 +1,4 @@
+::sysinit:/etc/init.d/rcS S boot
+::shutdown:/etc/init.d/rcS K shutdown
+ttyS0::askfirst:/bin/ash --login
+ttyS1::askfirst:/bin/ash --login
diff --git a/target/linux/mpc83xx/base-files/etc/uci-defaults/02_network b/target/linux/mpc83xx/base-files/etc/uci-defaults/02_network
new file mode 100755
--- /dev/null
+++ b/target/linux/mpc83xx/base-files/etc/uci-defaults/02_network
@@ -0,0 +1,29 @@
+#!/bin/sh
+#
+# Copyright (C) 2012 OpenWrt.org
+#
+
+[ -e /etc/config/network ] && exit 0
+
+touch /etc/config/network
+
+. /lib/functions/uci-defaults.sh
+. /lib/mpc83xx.sh
+
+ucidef_set_interface_loopback
+
+board=$(mpc83xx_board_name)
+
+case "$board" in
+rb333)
+	ucidef_set_interfaces_lan_wan "eth0 eth1" "eth2"
+	;;
+
+*)
+	ucidef_set_interfaces_lan_wan "eth0" "eth1"
+	;;
+esac
+
+uci commit network
+
+exit 0
diff --git a/target/linux/mpc83xx/base-files/lib/mpc83xx.sh b/target/linux/mpc83xx/base-files/lib/mpc83xx.sh
new file mode 100755
--- /dev/null
+++ b/target/linux/mpc83xx/base-files/lib/mpc83xx.sh
@@ -0,0 +1,44 @@
+#!/bin/sh
+#
+# Copyright (C) 2012 OpenWrt.org
+#
+
+MPC83XX_BOARD_NAME=
+MPC83XX_MODEL=
+
+mpc83xx_board_detect() {
+	local model
+	local name
+
+	model=$(awk 'BEGIN{FS="[ \t]+:[ \t]"} /model/ {print $2}' /proc/cpuinfo)
+
+	case "$model" in
+	"RB333")
+		name="rb333"
+		model="MikroTik RouterBOARD 333"
+		;;
+	"RB600")
+		name="rb600"
+		model="MikroTik RouterBOARD 600"
+		;;
+	esac
+
+	[ -z "$name" ] && name="unknown"
+
+	[ -z "$MPC83XX_BOARD_NAME" ] && MPC83XX_BOARD_NAME="$name"
+	[ -z "$MPC83XX_MODEL" ] && MPC83XX_MODEL="$model"
+
+	[ -e "/tmp/sysinfo/" ] || mkdir -p "/tmp/sysinfo/"
+
+	echo "$MPC83XX_BOARD_NAME" > /tmp/sysinfo/board_name
+	echo "$MPC83XX_MODEL" > /tmp/sysinfo/model
+}
+
+mpc83xx_board_name() {
+	local name
+
+	[ -f /tmp/sysinfo/board_name ] && name=$(cat /tmp/sysinfo/board_name)
+	[ -z "$name" ] && name="unknown"
+
+	echo "$name"
+}
diff --git a/target/linux/mpc83xx/base-files/lib/preinit/03_preinit_do_mpc83xx.sh b/target/linux/mpc83xx/base-files/lib/preinit/03_preinit_do_mpc83xx.sh
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/base-files/lib/preinit/03_preinit_do_mpc83xx.sh
@@ -0,0 +1,9 @@
+#!/bin/sh
+
+do_mpc83xx() {
+	. /lib/mpc83xx.sh
+
+	mpc83xx_board_detect
+}
+
+boot_hook_add preinit_main do_mpc83xx
diff --git a/target/linux/mpc83xx/config-3.10 b/target/linux/mpc83xx/config-3.10
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/config-3.10
@@ -0,0 +1,354 @@
+# CONFIG_40x is not set
+# CONFIG_44x is not set
+CONFIG_6xx=y
+CONFIG_8xxx_WDT=y
+# CONFIG_ADVANCED_OPTIONS is not set
+# CONFIG_ALTIVEC is not set
+# CONFIG_AMIGAONE is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+CONFIG_ARCH_HAS_ILOG2_U32=y
+CONFIG_ARCH_HAS_WALK_MEMORY=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_ARPD is not set
+# CONFIG_ASP834x is not set
+CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH=y
+CONFIG_ATA=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_BLK_DEV_SD=y
+# CONFIG_BOOTX_TEXT is not set
+CONFIG_BOUNCE=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_CMDLINE="console=ttyS0,115200 rootfstype=squashfs,yaffs2,jffs2"
+CONFIG_CMDLINE_BOOL=y
+CONFIG_COMPAT_BRK=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_DEV_TALITOS=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_HW=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_RNG2=y
+# CONFIG_CRYPTO_SHA1_PPC is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_DEFAULT_UIMAGE=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+CONFIG_DMADEVICES=y
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_OF=y
+CONFIG_DTC=y
+# CONFIG_E200 is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EMBEDDED6xx is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_EPAPR_BOOT is not set
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_FIXED_PHY=y
+CONFIG_FSL_DMA=y
+CONFIG_FSL_EMB_PERFMON=y
+CONFIG_FSL_GTM=y
+CONFIG_FSL_LBC=y
+CONFIG_FSL_PCI=y
+CONFIG_FSL_PQ_MDIO=y
+CONFIG_FSL_SOC=y
+# CONFIG_FSL_ULI1575 is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_GENERIC_ACL=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_GENERIC_IO=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_NVRAM=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+# CONFIG_GENERIC_TBSYNC is not set
+CONFIG_GENERIC_TIME_VSYSCALL_OLD=y
+CONFIG_GEN_RTC=y
+# CONFIG_GEN_RTC_X is not set
+# CONFIG_GE_FPGA is not set
+CONFIG_GIANFAR=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_DEVRES=y
+CONFIG_GPIO_MPC8XXX=y
+CONFIG_GPIO_SYSFS=y
+# CONFIG_HAMRADIO is not set
+CONFIG_HAS_DMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+# CONFIG_HAS_RAPIDIO is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+CONFIG_HAVE_IDE=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_HAVE_NET_DSA=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+# CONFIG_HAVE_SETUP_PER_CPU_AREA is not set
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HW_RANDOM=y
+CONFIG_HZ=250
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+CONFIG_HZ_PERIODIC=y
+CONFIG_INET_LRO=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_INPUT=y
+# CONFIG_INPUT_MISC is not set
+# CONFIG_IOMMU_HELPER is not set
+CONFIG_IOSCHED_CFQ=y
+CONFIG_IPIC=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_IRQCHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_IRQ_WORK=y
+CONFIG_ISA_DMA_API=y
+# CONFIG_ISDN is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+# CONFIG_JFFS2_LZMA is not set
+# CONFIG_JFFS2_SUMMARY is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_KERNEL_START=0xc0000000
+# CONFIG_KMETER1 is not set
+# CONFIG_LBDAF is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+# CONFIG_LEDS_TRIGGER_NETDEV is not set
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+CONFIG_LIBCRC32C=y
+CONFIG_LOG_BUF_SHIFT=15
+CONFIG_LOWMEM_SIZE=0x30000000
+# CONFIG_MATH_EMULATION is not set
+CONFIG_MDIO_BITBANG=y
+CONFIG_MDIO_BOARDINFO=y
+CONFIG_MDIO_GPIO=y
+# CONFIG_MMIO_NVRAM is not set
+CONFIG_MODULES_USE_ELF_RELA=y
+# CONFIG_MPC512X_DMA is not set
+CONFIG_MPC830x_RDB=y
+CONFIG_MPC831x_RDB=y
+CONFIG_MPC832x_MDS=y
+CONFIG_MPC832x_RDB=y
+CONFIG_MPC834x_ITX=y
+CONFIG_MPC834x_MDS=y
+CONFIG_MPC836x_MDS=y
+CONFIG_MPC836x_RDK=y
+CONFIG_MPC837x_MDS=y
+CONFIG_MPC837x_RDB=y
+# CONFIG_MPIC is not set
+# CONFIG_MPIC_U3_HT_IRQS is not set
+# CONFIG_MPIC_WEIRD is not set
+CONFIG_MTD_BLOCK2MTD=y
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_ECC=y
+CONFIG_MTD_NAND_FSL_ELBC=y
+CONFIG_MTD_NAND_FSL_UPM=y
+CONFIG_MTD_NAND_RB_PPC=y
+CONFIG_MTD_OF_PARTS=y
+CONFIG_MTD_PHYSMAP_OF=y
+# CONFIG_MTD_SM_COMMON is not set
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_BEB_LIMIT=20
+# CONFIG_MTD_UBI_BLOCK is not set
+# CONFIG_MTD_UBI_FASTMAP is not set
+# CONFIG_MTD_UBI_GLUEBI is not set
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+# CONFIG_NEED_DMA_MAP_STATE is not set
+# CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK is not set
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_NET_EMATCH=y
+# CONFIG_NONSTATIC_KERNEL is not set
+CONFIG_NR_IRQS=512
+CONFIG_OF=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_DEVICE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_GPIO=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_MTD=y
+CONFIG_OF_NET=y
+CONFIG_OF_PCI=y
+CONFIG_OF_PCI_IRQ=y
+CONFIG_OLD_SIGACTION=y
+CONFIG_OLD_SIGSUSPEND=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_PAGE_OFFSET=0xc0000000
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_PATA_RB_PPC=y
+CONFIG_PCI=y
+CONFIG_PCI_DISABLE_COMMON_QUIRKS=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_MSI=y
+CONFIG_PHYLIB=y
+CONFIG_PHYSICAL_START=0x00000000
+CONFIG_POWERNV_MSI=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+# CONFIG_PPC64 is not set
+# CONFIG_PPC_82xx is not set
+CONFIG_PPC_83xx=y
+# CONFIG_PPC_85xx is not set
+# CONFIG_PPC_86xx is not set
+# CONFIG_PPC_8xx is not set
+# CONFIG_PPC_970_NAP is not set
+CONFIG_PPC_BOOK3S=y
+CONFIG_PPC_BOOK3S_32=y
+# CONFIG_PPC_CELL is not set
+# CONFIG_PPC_CELL_NATIVE is not set
+# CONFIG_PPC_CHRP is not set
+# CONFIG_PPC_CLOCK is not set
+# CONFIG_PPC_DCR_MMIO is not set
+# CONFIG_PPC_DCR_NATIVE is not set
+CONFIG_PPC_DISABLE_WERROR=y
+# CONFIG_PPC_DOORBELL is not set
+# CONFIG_PPC_EARLY_DEBUG is not set
+# CONFIG_PPC_EPAPR_HV_PIC is not set
+CONFIG_PPC_FPU=y
+CONFIG_PPC_HAVE_PMU_SUPPORT=y
+# CONFIG_PPC_I8259 is not set
+# CONFIG_PPC_ICP_HV is not set
+# CONFIG_PPC_ICP_NATIVE is not set
+# CONFIG_PPC_ICS_RTAS is not set
+CONFIG_PPC_INDIRECT_PCI=y
+CONFIG_PPC_LIB_RHEAP=y
+# CONFIG_PPC_MM_SLICES is not set
+# CONFIG_PPC_MPC106 is not set
+# CONFIG_PPC_MPC512x is not set
+# CONFIG_PPC_MPC52xx is not set
+CONFIG_PPC_MPC831x=y
+CONFIG_PPC_MPC832x=y
+CONFIG_PPC_MPC834x=y
+CONFIG_PPC_MPC837x=y
+CONFIG_PPC_MSI_BITMAP=y
+CONFIG_PPC_OF=y
+CONFIG_PPC_OF_BOOT_TRAMPOLINE=y
+# CONFIG_PPC_P7_NAP is not set
+CONFIG_PPC_PCI_CHOICE=y
+# CONFIG_PPC_PMAC is not set
+# CONFIG_PPC_RTAS is not set
+CONFIG_PPC_STD_MMU=y
+CONFIG_PPC_STD_MMU_32=y
+CONFIG_PPC_UDBG_16550=y
+# CONFIG_PPC_WSP is not set
+# CONFIG_PPC_XICS is not set
+# CONFIG_PQ2ADS is not set
+# CONFIG_PREEMPT_RCU is not set
+CONFIG_PROC_DEVICETREE=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PTP_1588_CLOCK_GIANFAR is not set
+CONFIG_QE_GPIO=y
+CONFIG_QUICC_ENGINE=y
+CONFIG_RB_IOMAP=y
+CONFIG_RB_PPC=y
+# CONFIG_RCU_STALL_COMMON is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+# CONFIG_SBC834x is not set
+CONFIG_SCHED_HRTICK=y
+CONFIG_SCSI=y
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_SERIAL_8250_FSL=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_QE=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_APBPS2 is not set
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_PCIPS2=y
+CONFIG_SERIO_RAW=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_XILINX_XPS_PS2 is not set
+CONFIG_SIMPLE_GPIO=y
+# CONFIG_SLAB is not set
+CONFIG_SLOB=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+# CONFIG_SWAP is not set
+# CONFIG_SWIOTLB is not set
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_TASK_SIZE=0xc0000000
+# CONFIG_TAU is not set
+CONFIG_TICK_CPU_ACCOUNTING=y
+CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_UBIFS_FS is not set
+CONFIG_UCC=y
+CONFIG_UCC_FAST=y
+CONFIG_UCC_GETH=y
+CONFIG_UCC_SLOW=y
+# CONFIG_UCC_TDM is not set
+# CONFIG_UGETH_TX_ON_DEMAND is not set
+CONFIG_UIDGID_CONVERTED=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_VIA_VELOCITY=y
+CONFIG_VITESSE_PHY=y
+CONFIG_VITESSE_PHY_8601_SKEW=y
+CONFIG_WORD_SIZE=32
+CONFIG_XZ_DEC_BCJ=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_YAFFS_9BYTE_TAGS=y
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_BACKGROUND is not set
+# CONFIG_YAFFS_DISABLE_BLOCK_REFRESHING is not set
+CONFIG_YAFFS_DISABLE_TAGS_ECC=y
+# CONFIG_YAFFS_EMPTY_LOST_AND_FOUND is not set
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_XATTR=y
+CONFIG_YAFFS_YAFFS1=y
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_ZLIB_INFLATE=y
diff --git a/target/linux/mpc83xx/easy85600/base-files/etc/banner b/target/linux/mpc83xx/easy85600/base-files/etc/banner
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/easy85600/base-files/etc/banner
@@ -0,0 +1,2 @@
+ OpenWrt - v14.07 --- Lantiq Edition for DSL CO
+ ----------------------------------------------
diff --git a/target/linux/mpc83xx/easy85600/base-files/etc/config/fstab b/target/linux/mpc83xx/easy85600/base-files/etc/config/fstab
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/easy85600/base-files/etc/config/fstab
@@ -0,0 +1,9 @@
+config global automount
+	option from_fstab 1
+	option anon_mount 1
+	
+config global autoswap
+	option from_fstab 1
+	option anon_swap 0
+
+
diff --git a/target/linux/mpc83xx/easy85600/base-files/etc/profile.arch b/target/linux/mpc83xx/easy85600/base-files/etc/profile.arch
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/easy85600/base-files/etc/profile.arch
@@ -0,0 +1,10 @@
+#!/bin/sh
+
+export PATH=$PATH:/opt/lantiq/bin
+
+alias la='ls -la'
+alias ..='cd ../..'
+alias dsl='dsl_pipe'
+
+# if possible, adapt to size of terminal
+[ -x /usr/bin/resize ] && resize
diff --git a/target/linux/mpc83xx/easy85600/base-files/etc/uci-defaults/network b/target/linux/mpc83xx/easy85600/base-files/etc/uci-defaults/network
new file mode 100755
--- /dev/null
+++ b/target/linux/mpc83xx/easy85600/base-files/etc/uci-defaults/network
@@ -0,0 +1,10 @@
+#!/bin/sh
+# Copyright (C) 2011 OpenWrt.org
+# Copyright (C) 2011 lantiq.com
+
+. /lib/functions/uci-defaults.sh
+
+# uci has errors if the file does not exist:
+touch /etc/config/network
+
+uci -q delete network.lan
diff --git a/target/linux/mpc83xx/easy85600/base-files/etc/uci-defaults/timeserver b/target/linux/mpc83xx/easy85600/base-files/etc/uci-defaults/timeserver
new file mode 100755
--- /dev/null
+++ b/target/linux/mpc83xx/easy85600/base-files/etc/uci-defaults/timeserver
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# Copyright (C) 2011 OpenWrt.org
+# Copyright (C) 2011 lantiq.com
+#
+
+timeserver=10.1.1.1
+
+uci batch <<EOF
+add timeserver timeserver
+set timeserver.@timeserver[-1].hostname=${timeserver}
+add ntpclient ntpserver
+set ntpclient.@ntpserver[-1].hostname=${timeserver}
+EOF
diff --git a/target/linux/mpc83xx/easy85600/base-files/opt/lantiq/bin/what.sh b/target/linux/mpc83xx/easy85600/base-files/opt/lantiq/bin/what.sh
new file mode 100755
--- /dev/null
+++ b/target/linux/mpc83xx/easy85600/base-files/opt/lantiq/bin/what.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+for i in $*; do
+	version=`strings $i | grep "@(#)" | sed 's/\(.*\)@(#)\(.*\)/\2/g'`
+	echo $version
+done
+
diff --git a/target/linux/mpc83xx/easy85600/base-files/opt/lantiq/bin/whatz.sh b/target/linux/mpc83xx/easy85600/base-files/opt/lantiq/bin/whatz.sh
new file mode 100755
--- /dev/null
+++ b/target/linux/mpc83xx/easy85600/base-files/opt/lantiq/bin/whatz.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+for i in $*; do
+	version=`zcat $i | strings | grep "@(#)" | sed 's/\(.*\)@(#)\(.*\)/\2/g'`
+	echo $version
+done
+
diff --git a/target/linux/mpc83xx/easy85600/config-3.10 b/target/linux/mpc83xx/easy85600/config-3.10
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/easy85600/config-3.10
@@ -0,0 +1,14 @@
+# CONFIG_ATA is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_RARP is not set
+CONFIG_LZO_DECOMPRESS=y
+# CONFIG_MODULE_STRIPPED is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_UBI is not set
+# CONFIG_PWM is not set
+# CONFIG_SERIAL_8250_SYSRQ is not set
+CONFIG_SQUASHFS_LZO=y
+CONFIG_SQUASHFS_ZLIB=y
diff --git a/target/linux/mpc83xx/easy85600/target.mk b/target/linux/mpc83xx/easy85600/target.mk
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/easy85600/target.mk
@@ -0,0 +1,11 @@
+SUBTARGET:=easy85600
+BOARDNAME:=EASY85600 (Avinax)
+FEATURES:=jffs2 tgz usb
+DEVICE_TYPE:=other
+
+DEFAULT_PACKAGES+=ifxos kmod-ifxos 
+
+define Target/Description
+	Build for EASY85600 Evaluation Board (TQM8315 based)
+endef
+
diff --git a/target/linux/mpc83xx/files/arch/powerpc/boot/dts/easy85600.dts b/target/linux/mpc83xx/files/arch/powerpc/boot/dts/easy85600.dts
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/files/arch/powerpc/boot/dts/easy85600.dts
@@ -0,0 +1,482 @@
+/*
+ * MPC8315E RDB Device Tree Source
+ *
+ * Copyright 2007 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+/dts-v1/;
+
+/ {
+	compatible = "fsl,mpc8315erdb";
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	aliases {
+		ethernet0 = &enet0;
+		ethernet1 = &enet1;
+		serial0 = &serial0;
+		serial1 = &serial1;
+		pci0 = &pci0;
+		pci1 = &pci1;
+		pci2 = &pci2;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		PowerPC,8315@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			d-cache-line-size = <32>;
+			i-cache-line-size = <32>;
+			d-cache-size = <16384>;
+			i-cache-size = <16384>;
+			timebase-frequency = <0>;	// from bootloader
+			bus-frequency = <0>;		// from bootloader
+			clock-frequency = <0>;		// from bootloader
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x00000000 0x08000000>;	// 128MB at 0
+	};
+
+	localbus@e0005000 {
+		#address-cells = <2>;
+		#size-cells = <1>;
+		compatible = "fsl,mpc8315-elbc", "fsl,elbc", "simple-bus";
+		reg = <0xe0005000 0x1000>;
+		interrupts = <77 0x8>;
+		interrupt-parent = <&ipic>;
+
+		// CS0 and CS1 are swapped when
+		// booting from nand, but the
+		// addresses are the same.
+		ranges = <0x0 0x0 0x80000000 0x04000000
+		          0x1 0x0 0xe0600000 0x00002000
+		          0x2 0x0 0xf0000000 0x00020000
+		          0x3 0x0 0xfa000000 0x00008000>;
+
+		flash@0,0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "cfi-flash";
+			reg = <0x0 0x0 0x04000000>;
+			bank-width = <2>;
+			device-width = <1>;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0x0 0x80000>;
+				read-only;
+			};
+
+			partition@1 {
+				label = "env1";
+				reg = <0x80000 0x20000>;
+				read-only;
+			};
+
+			partition@2 {
+				label = "env2";
+				reg = <0xA0000 0x20000>;
+				read-only;
+			};
+
+			partition@3 {
+				label = "dtb";
+				reg = <0xC0000 0x20000>;
+				read-only;
+			};
+
+			partition@4 {
+				label = "kernel";
+				reg = <0xE0000 0x200000>;
+				read-only;
+			};
+
+			partition@5 {
+				label = "root";
+				reg = <0x2E0000 0xF00000>;
+			};
+
+			partition@6 {
+				label ="free-space";
+				reg = <0x11E0000 0x2E20000>;
+			};
+		};
+
+		nand@1,0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "fsl,mpc8315-fcm-nand",
+			             "fsl,elbc-fcm-nand";
+			reg = <0x1 0x0 0x2000>;
+
+			partition@0 {
+				label = "filesystem";
+				reg = <0x0 0x20000000>;
+				read-only;
+			};
+		};
+	};
+
+	immr@e0000000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		device_type = "soc";
+		compatible = "fsl,mpc8315-immr", "simple-bus";
+		ranges = <0 0xe0000000 0x00100000>;
+		reg = <0xe0000000 0x00000200>;
+		bus-frequency = <0>;
+
+		wdt@200 {
+			device_type = "watchdog";
+			compatible = "mpc83xx_wdt";
+			reg = <0x200 0x100>;
+		};
+
+		i2c@3000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			cell-index = <0>;
+			compatible = "fsl-i2c";
+			reg = <0x3000 0x100>;
+			interrupts = <14 0x8>;
+			interrupt-parent = <&ipic>;
+			dfsrr;
+			rtc@68 {
+				compatible = "dallas,ds1337";
+				reg = <0x68>;
+			};
+			eeprom@50 {
+				compatible = "atmel,24c256"; /* Use 24cxxx whre xx is the density in MBit! 24c256 is 32 kByte */
+				reg = <0x50>;
+			};
+			eeprom@57 {
+				compatible = "atmel,24c256";
+				reg = <0x57>;
+			};
+			sensor@48 {
+				compatible = "national,lm75";
+				reg = <0x48>;
+			};
+			/* Add this for sensors an STK85xxNG */
+			/*sensor@49 {
+				compatible = "national,lm75";
+				reg = <0x49>;
+			};
+			sensor@4A {
+				compatible = "national,lm75";
+				reg = <0x4A>;
+			};
+			sensor@4B {
+				compatible = "national,lm75";
+				reg = <0x4B>;
+			};*/
+		};
+
+		spi@7000 {
+			cell-index = <0>;
+			compatible = "fsl,spi";
+			reg = <0x7000 0x1000>;
+			interrupts = <16 0x8>;
+			interrupt-parent = <&ipic>;
+			mode = "cpu";
+		};
+
+		dma@82a8 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "fsl,mpc8315-dma", "fsl,elo-dma";
+			reg = <0x82a8 4>;
+			ranges = <0 0x8100 0x1a8>;
+			interrupt-parent = <&ipic>;
+			interrupts = <71 8>;
+			cell-index = <0>;
+			dma-channel@0 {
+				compatible = "fsl,mpc8315-dma-channel", "fsl,elo-dma-channel";
+				reg = <0 0x80>;
+				cell-index = <0>;
+				interrupt-parent = <&ipic>;
+				interrupts = <71 8>;
+			};
+			dma-channel@80 {
+				compatible = "fsl,mpc8315-dma-channel", "fsl,elo-dma-channel";
+				reg = <0x80 0x80>;
+				cell-index = <1>;
+				interrupt-parent = <&ipic>;
+				interrupts = <71 8>;
+			};
+			dma-channel@100 {
+				compatible = "fsl,mpc8315-dma-channel", "fsl,elo-dma-channel";
+				reg = <0x100 0x80>;
+				cell-index = <2>;
+				interrupt-parent = <&ipic>;
+				interrupts = <71 8>;
+			};
+			dma-channel@180 {
+				compatible = "fsl,mpc8315-dma-channel", "fsl,elo-dma-channel";
+				reg = <0x180 0x28>;
+				cell-index = <3>;
+				interrupt-parent = <&ipic>;
+				interrupts = <71 8>;
+			};
+		};
+
+		usb@23000 {
+			compatible = "fsl-usb2-dr";
+			reg = <0x23000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupt-parent = <&ipic>;
+			interrupts = <38 0x8>;
+			dr_mode = "host";
+			phy_type = "utmi";
+		};
+
+		enet0: ethernet@24000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			cell-index = <0>;
+			device_type = "network";
+			model = "eTSEC";
+			compatible = "gianfar";
+			reg = <0x24000 0x1000>;
+			ranges = <0x0 0x24000 0x1000>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+			interrupts = <32 0x8 33 0x8 34 0x8>;
+			interrupt-parent = <&ipic>;
+			tbi-handle = <&tbi0>;
+			phy-handle = < &phy0 >;
+
+			mdio@520 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,gianfar-mdio";
+				reg = <0x520 0x20>;
+
+				phy0: ethernet-phy@0 {
+					interrupt-parent = <&ipic>;
+					interrupts = <20 0x8>;
+					reg = <0x2>;
+					device_type = "ethernet-phy";
+				};
+
+				phy1: ethernet-phy@1 {
+					interrupt-parent = <&ipic>;
+					interrupts = <19 0x8>;
+					reg = <0x1>;
+					device_type = "ethernet-phy";
+				};
+
+				tbi0: tbi-phy@11 {
+					reg = <0x11>;
+					device_type = "tbi-phy";
+				};
+			};
+		};
+
+		enet1: ethernet@25000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			cell-index = <1>;
+			device_type = "network";
+			model = "eTSEC";
+			compatible = "gianfar";
+			reg = <0x25000 0x1000>;
+			ranges = <0x0 0x25000 0x1000>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+			interrupts = <35 0x8 36 0x8 37 0x8>;
+			interrupt-parent = <&ipic>;
+			tbi-handle = <&tbi1>;
+			phy-handle = < &phy1 >;
+
+			mdio@520 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,gianfar-tbi";
+				reg = <0x520 0x20>;
+
+				tbi1: tbi-phy@11 {
+					reg = <0x11>;
+					device_type = "tbi-phy";
+				};
+			};
+		};
+
+		serial0: serial@4500 {
+			cell-index = <0>;
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <0x4500 0x100>;
+			clock-frequency = <133333333>;
+			interrupts = <9 0x8>;
+			interrupt-parent = <&ipic>;
+		};
+
+		serial1: serial@4600 {
+			cell-index = <1>;
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <0x4600 0x100>;
+			clock-frequency = <133333333>;
+			interrupts = <10 0x8>;
+			interrupt-parent = <&ipic>;
+		};
+
+		crypto@30000 {
+			compatible = "fsl,sec3.3", "fsl,sec3.1", "fsl,sec3.0",
+				     "fsl,sec2.4", "fsl,sec2.2", "fsl,sec2.1",
+				     "fsl,sec2.0";
+			reg = <0x30000 0x10000>;
+			interrupts = <11 0x8>;
+			interrupt-parent = <&ipic>;
+			fsl,num-channels = <4>;
+			fsl,channel-fifo-len = <24>;
+			fsl,exec-units-mask = <0x97c>;
+			fsl,descriptor-types-mask = <0x3ab0abf>;
+		};
+
+		sata@18000 {
+			compatible = "fsl,mpc8315-sata", "fsl,pq-sata";
+			reg = <0x18000 0x1000>;
+			cell-index = <1>;
+			interrupts = <44 0x8>;
+			interrupt-parent = <&ipic>;
+		};
+
+		sata@19000 {
+			compatible = "fsl,mpc8315-sata", "fsl,pq-sata";
+			reg = <0x19000 0x1000>;
+			cell-index = <2>;
+			interrupts = <45 0x8>;
+			interrupt-parent = <&ipic>;
+		};
+
+		/* IPIC
+		 * interrupts cell = <intr #, sense>
+		 * sense values match linux IORESOURCE_IRQ_* defines:
+		 * sense == 8: Level, low assertion
+		 * sense == 2: Edge, high-to-low change
+		 */
+		ipic: interrupt-controller@700 {
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <2>;
+			reg = <0x700 0x100>;
+			device_type = "ipic";
+		};
+	};
+
+	pci0: pci@e0008500 {
+		interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
+		/* The values are calculated the following:
+		* The first thre values are address values as address-cells is 3 
+		* The first value is the bus number in bits 31-16 (normal 0 because masked out)
+		* Bits 15-8 are the devfn (this is the IDSEL Line shift 3 bits to the left IDSEL AD15 is 0x78)
+		* Bis 7-0 are unused set to 0 and mask out with the interrupt-mask value
+		* The following two values should be 0 and masked out
+		* The fourth value is the interrupt bis from PCI configuration header (one value as interrupt-cells is 1)
+		* The last three values are the interrupt this interrupt is connected to.
+		* First interrupt controller node, then the number and last the flags (8 means level low) */
+		interrupt-map = <
+				/* IDSEL 0x10 - first PCI slot */
+				 0x8000 0x0 0x0 0x1 &ipic 18 0x8
+				 0x8000 0x0 0x0 0x2 &ipic 19 0x8
+				 0x8000 0x0 0x0 0x3 &ipic 20 0x8
+				 0x8000 0x0 0x0 0x3 &ipic 21 0x8
+
+				/* IDSEL 0x11 - Second PCI slot */
+				 0x8800 0x0 0x0 0x1 &ipic 19 0x8
+				 0x8800 0x0 0x0 0x2 &ipic 20 0x8
+				 0x8800 0x0 0x0 0x3 &ipic 21 0x8
+				 0x8800 0x0 0x0 0x4 &ipic 18 0x8
+				 
+				 /* IDSEL 0x12 - USB controller */
+				 0x9000 0x0 0x0 0x1 &ipic 21 0x8>;
+		interrupt-parent = <&ipic>;
+		interrupts = <66 0x8>;
+		bus-range = <0x0 0x0>;
+		ranges = <0x42000000 0 0xC0000000 0xC0000000 0 0x10000000
+			  0x02000000 0 0xD0000000 0xD0000000 0 0x10000000
+			  0x01000000 0 0x00000000 0xe0300000 0 0x00100000>;
+		clock-frequency = <66666666>;
+		#interrupt-cells = <1>;
+		#size-cells = <2>;
+		#address-cells = <3>;
+		reg = <0xe0008500 0x100		/* internal registers */
+		       0xe0008300 0x8>;		/* config space access registers */
+		compatible = "fsl,mpc8349-pci";
+		device_type = "pci";
+	};
+
+	pci1: pcie@e0009000 {
+		#address-cells = <3>;
+		#size-cells = <2>;
+		#interrupt-cells = <1>;
+		device_type = "pci";
+		compatible = "fsl,mpc8315-pcie", "fsl,mpc8314-pcie";
+		reg = <0xe0009000 0x00001000>;
+		ranges = <0x02000000 0 0x40000000 0x40000000 0 0x10000000
+		          0x01000000 0 0x00000000 0xe3100000 0 0x00800000>;
+		bus-range = <0 255>;
+		interrupt-map-mask = <0x0 0 0 7>;
+		interrupt-map = <0 0 0 1 &ipic 1 8
+				 0 0 0 2 &ipic 1 8
+				 0 0 0 3 &ipic 1 8
+				 0 0 0 4 &ipic 1 8>;
+		clock-frequency = <0>;
+
+		pcie@0 {
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			reg = <0 0 0 0 0>;
+			ranges = <0x02000000 0 0x40000000
+				  0x02000000 0 0x40000000
+				  0 0x10000000
+				  0x01000000 0 0x00000000
+				  0x01000000 0 0x00000000
+				  0 0x00800000>;
+		};
+	};
+
+	pci2: pcie@e000a000 {
+		#address-cells = <3>;
+		#size-cells = <2>;
+		#interrupt-cells = <1>;
+		device_type = "pci";
+		compatible = "fsl,mpc8315-pcie", "fsl,mpc8314-pcie";
+		reg = <0xe000a000 0x00001000>;
+		ranges = <0x02000000 0 0x60000000 0x60000000 0 0x10000000
+			  0x01000000 0 0x00000000 0xe3180000 0 0x00800000>;
+		bus-range = <0 255>;
+		interrupt-map-mask = <0xf800 0 0 7>;
+		interrupt-map = <0 0 0 1 &ipic 2 8
+				 0 0 0 2 &ipic 2 8
+				 0 0 0 3 &ipic 2 8
+				 0 0 0 4 &ipic 2 8>;
+		clock-frequency = <0>;
+
+		pcie@0 {
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			reg = <0 0 0 0 0>;
+			ranges = <0x02000000 0 0x60000000
+				  0x02000000 0 0x60000000
+				  0 0x10000000
+				  0x01000000 0 0x00000000
+				  0x01000000 0 0x00000000
+				  0 0x00800000>;
+		};
+	};
+};
diff --git a/target/linux/mpc83xx/files/scripts/mkits.sh b/target/linux/mpc83xx/files/scripts/mkits.sh
new file mode 100755
--- /dev/null
+++ b/target/linux/mpc83xx/files/scripts/mkits.sh
@@ -0,0 +1,111 @@
+#!/bin/bash
+#
+# Licensed under the terms of the GNU GPL License version 2 or later.
+#
+# Author: Peter Tyser <ptyser@xes-inc.com>
+#
+# U-Boot firmware supports the booting of images in the Flattened Image
+# Tree (FIT) format.  The FIT format uses a device tree structure to
+# describe a kernel image, device tree blob, ramdisk, etc.  This script
+# creates an Image Tree Source (.its file) which can be passed to the
+# 'mkimage' utility to generate an Image Tree Blob (.itb file).  The .itb
+# file can then be booted by U-Boot (or other bootloaders which support
+# FIT images).  See doc/uImage.FIT/howto.txt in U-Boot source code for
+# additional information on FIT images.
+#
+
+usage() {
+	echo "Usage: `basename $0` -A arch -C comp -a addr -e entry" \
+		"-v version -k kernel [-d dtb] -o its_file"
+	echo -e "\t-A ==> set architecture to 'arch'"
+	echo -e "\t-C ==> set compression type 'comp'"
+	echo -e "\t-a ==> set load address to 'addr' (hex)"
+	echo -e "\t-e ==> set entry point to 'entry' (hex)"
+	echo -e "\t-v ==> set kernel version to 'version'"
+	echo -e "\t-k ==> include kernel image 'kernel'"
+	echo -e "\t-d ==> include Device Tree Blob 'dtb'"
+	echo -e "\t-o ==> create output file 'its_file'"
+	exit 1
+}
+
+while getopts ":A:C:a:d:e:k:o:v:" OPTION
+do
+	case $OPTION in
+		A ) ARCH=$OPTARG;;
+		C ) COMPRESS=$OPTARG;;
+		a ) LOAD_ADDR=$OPTARG;;
+		d ) DTB=$OPTARG;;
+		e ) ENTRY_ADDR=$OPTARG;;
+		k ) KERNEL=$OPTARG;;
+		o ) OUTPUT=$OPTARG;;
+		v ) VERSION=$OPTARG;;
+		* ) echo "Invalid option passed to '$0' (options:$@)"
+		usage;;
+	esac
+done
+
+# Make sure user entered all required parameters
+if [ -z "${ARCH}" ] || [ -z "${COMPRESS}" ] || [ -z "${LOAD_ADDR}" ] || \
+	[ -z "${ENTRY_ADDR}" ] || [ -z "${VERSION}" ] || [ -z "${KERNEL}" ] || \
+	[ -z "${OUTPUT}" ]; then
+	usage
+fi
+
+# Create a default, fully populated DTS file
+DATA="/dts-v1/;
+
+/ {
+	description = \"Linux kernel ${VERSION}\";
+	#address-cells = <1>;
+
+	images {
+		kernel@1 {
+			description = \"Linux Kernel ${VERSION}\";
+			data = /incbin/(\"${KERNEL}\");
+			type = \"kernel\";
+			arch = \"${ARCH}\";
+			os = \"linux\";
+			compression = \"${COMPRESS}\";
+			load = <${LOAD_ADDR}>;
+			entry = <${ENTRY_ADDR}>;
+			hash@1 {
+				algo = \"crc32\";
+			};
+			hash@2 {
+				algo = \"sha1\";
+			};
+		};
+
+		fdt@1 { /* start fdt */
+			description = \"Flattened Device Tree blob\";
+			data = /incbin/(\"${DTB}\");
+			type = \"flat_dt\";
+			arch = \"${ARCH}\";
+			compression = \"none\";
+			hash@1 {
+				algo = \"crc32\";
+			};
+			hash@2 {
+				algo = \"sha1\";
+			};
+		}; /* end fdt */
+	};
+
+	configurations {
+		default = \"config@1\";
+		config@1 {
+			description = \"Default Linux kernel\";
+			kernel = \"kernel@1\";
+			fdt = \"fdt@1\";
+		};
+	};
+};"
+
+# Conditionally strip fdt information out of tree
+if [ -z "${DTB}" ]; then
+	DATA=`echo "$DATA" | sed '/start fdt/,/end fdt/d'`
+	DATA=`echo "$DATA" | sed '/fdt/d'`
+fi
+
+# Write .its file to disk
+echo "$DATA" > ${OUTPUT}
diff --git a/target/linux/mpc83xx/generic/config-default b/target/linux/mpc83xx/generic/config-default
new file mode 100644
diff --git a/target/linux/mpc83xx/generic/target.mk b/target/linux/mpc83xx/generic/target.mk
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/generic/target.mk
@@ -0,0 +1,7 @@
+SUBTARGET:=generic
+BOARDNAME:=Generic
+FEATURES:=squashfs jffs2 tgz
+
+define Target/Description
+	Build standard images for MPC83xx
+endef
diff --git a/target/linux/mpc83xx/image/Makefile b/target/linux/mpc83xx/image/Makefile
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/image/Makefile
@@ -0,0 +1,40 @@
+#
+# Copyright (C) 2009-2010 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/image.mk
+
+define Image/Prepare
+	$(LINUX_DIR)/scripts/dtc/dtc -O dtb -R 4 -p 0x20000 $(LINUX_DIR)/arch/powerpc/boot/dts/$(SUBTARGET).dts > $(BIN_DIR)/openwrt-mpc83xx-$(SUBTARGET).dtb
+endef
+
+define Image/BuildKernel
+	- cp $(LINUX_DIR)/arch/powerpc/boot/dtbImage.rb600.elf $(BIN_DIR)/openwrt-$(BOARD)-rb600.elf
+	- cp $(LINUX_DIR)/arch/powerpc/boot/dtbImage.rb333.elf $(BIN_DIR)/openwrt-$(BOARD)-rb333.elf
+	cp $(KDIR)/uImage $(BIN_DIR)/openwrt-$(BOARD)-uImage
+endef
+
+define Image/Build
+	$(call Image/Build/$(1),$(1))
+endef
+
+define Image/Build/squashfs
+	$(call prepare_generic_squashfs,$(KDIR)/root.squashfs)
+	( \
+		dd if=$(LINUX_DIR)/arch/powerpc/boot/uImage bs=3072k conv=sync; \
+		dd if=$(KDIR)/root.$(1) bs=256k conv=sync; \
+	) > $(BIN_DIR)/$(IMG_PREFIX)-$(SUBTARGET)-$(1).img
+endef
+
+define Image/Build/jffs2-64k
+	cp $(KDIR)/root.jffs2-64k $(BIN_DIR)/$(IMG_PREFIX).jffs2-64k
+endef
+
+define Image/Build/jffs2-128k
+	cp $(KDIR)/root.jffs2-128k $(BIN_DIR)/$(IMG_PREFIX).jffs-128k
+endef
+
+$(eval $(call BuildImage))
diff --git a/target/linux/mpc83xx/modules.mk b/target/linux/mpc83xx/modules.mk
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/modules.mk
@@ -0,0 +1,25 @@
+#
+# Copyright (C) 2012 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+define KernelPackage/ata-rbppc-cf
+  SUBMENU:=$(BLOCK_MENU)
+  TITLE:=RB600 Compact Flash support
+  DEPENDS:=@TARGET_mpc83xx
+  KCONFIG:= \
+  	CONFIG_PATA_PLATFORM \
+  	CONFIG_PATA_RB_PPC
+  FILES:=\
+  	$(LINUX_DIR)/drivers/ata/pata_rbppc_cf.ko
+  AUTOLOAD:=$(call AutoLoad,41,pata_rbppc_cf,1)
+  $(call AddDepends/ata)
+endef
+
+define KernelPackage/ata-rbppc-cf/description
+  RB600 Compact Flash support.
+endef
+
+$(eval $(call KernelPackage,ata-rbppc-cf))
diff --git a/target/linux/mpc83xx/patches-3.10/100-powerpc_create_fit_uImages.patch b/target/linux/mpc83xx/patches-3.10/100-powerpc_create_fit_uImages.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/patches-3.10/100-powerpc_create_fit_uImages.patch
@@ -0,0 +1,85 @@
+--- a/arch/powerpc/Makefile
++++ b/arch/powerpc/Makefile
+@@ -177,7 +177,9 @@ all: zImage
+ 
+ # With make 3.82 we cannot mix normal and wildcard targets
+ BOOT_TARGETS1 := zImage zImage.initrd uImage
+-BOOT_TARGETS2 := zImage% dtbImage% treeImage.% cuImage.% simpleImage.% uImage.%
++BOOT_TARGETS2 := uImage.fit.% zImage% dtbImage% treeImage.% cuImage.% \
++		 simpleImage.% uImage.%
++
+ 
+ PHONY += $(BOOT_TARGETS1) $(BOOT_TARGETS2)
+ 
+@@ -210,6 +212,7 @@ define archhelp
+   @echo '* zImage          - Build default images selected by kernel config'
+   @echo '  zImage.*        - Compressed kernel image (arch/$(ARCH)/boot/zImage.*)'
+   @echo '  uImage          - U-Boot native image format'
++  @echo '  uImage.fit.<dt> - U-Boot Flattened Image Tree image format'
+   @echo '  cuImage.<dt>    - Backwards compatible U-Boot image for older'
+   @echo '                    versions which do not support device trees'
+   @echo '  dtbImage.<dt>   - zImage with an embedded device tree blob'
+--- a/arch/powerpc/boot/.gitignore
++++ b/arch/powerpc/boot/.gitignore
+@@ -14,6 +14,7 @@ kernel-vmlinux.strip.c
+ kernel-vmlinux.strip.gz
+ mktree
+ uImage
++uImage.fit.*
+ cuImage.*
+ dtbImage.*
+ treeImage.*
+--- a/arch/powerpc/boot/Makefile
++++ b/arch/powerpc/boot/Makefile
+@@ -338,6 +338,9 @@ $(obj)/uImage.initrd.%: vmlinux $(obj)/%
+ $(obj)/uImage.%: vmlinux $(obj)/%.dtb $(wrapperbits)
+ 	$(call if_changed,wrap,uboot-$*,,$(obj)/$*.dtb)
+ 
++$(obj)/uImage.fit.%: vmlinux $(obj)/%.dtb $(wrapperbits)
++	$(call if_changed,wrap,uboot.fit,,$(obj)/$*.dtb)
++
+ $(obj)/cuImage.initrd.%: vmlinux $(obj)/%.dtb $(wrapperbits)
+ 	$(call if_changed,wrap,cuboot-$*,,$(obj)/$*.dtb,$(obj)/ramdisk.image.gz)
+ 
+@@ -375,6 +378,7 @@ install: $(CONFIGURE) $(addprefix $(obj)
+ 
+ # anything not in $(targets)
+ clean-files += $(image-) $(initrd-) cuImage.* dtbImage.* treeImage.* \
++	uImage.* \
+ 	zImage zImage.initrd zImage.chrp zImage.coff zImage.holly \
+ 	zImage.miboot zImage.pmac zImage.pseries \
+ 	zImage.maple simpleImage.* otheros.bld *.dtb
+--- a/arch/powerpc/boot/wrapper
++++ b/arch/powerpc/boot/wrapper
+@@ -47,6 +47,9 @@ CROSS=
+ # mkimage wrapper script
+ MKIMAGE=$srctree/scripts/mkuboot.sh
+ 
++# script to generate an .its file for uImage.fit.* images
++MKITS=$srctree/scripts/mkits.sh
++
+ # directory for object and other files used by this script
+ object=arch/powerpc/boot
+ objbin=$object
+@@ -336,6 +339,21 @@ uboot-obs600)
+     if [ -z "$cacheit" ]; then
+ 	rm -f "$vmz"
+     fi
++    exit 0
++    ;;
++uboot.fit)
++    rm -f "$ofile"
++    ${MKITS} -A ppc -C gzip -a $membase -e $membase -v $version \
++	-d "$srctree/$dtb" -k "$srctree/$vmz" -o "$object/uImage.its"
++
++    # mkimage calls dtc for FIT images so use kernel dtc if necessary
++    export PATH=$PATH:$srctree/scripts/dtc
++
++    ${MKIMAGE} -f "$object/uImage.its" "$ofile"
++    rm "$object/uImage.its"
++    if [ -z "$cacheit" ]; then
++	rm -f "$vmz"
++    fi
+     exit 0
+     ;;
+ esac
diff --git a/target/linux/mpc83xx/patches-3.10/101-mpc8377_wlan-dts-add-gpio-leds.patch b/target/linux/mpc83xx/patches-3.10/101-mpc8377_wlan-dts-add-gpio-leds.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/patches-3.10/101-mpc8377_wlan-dts-add-gpio-leds.patch
@@ -0,0 +1,21 @@
+--- a/arch/powerpc/boot/dts/mpc8377_wlan.dts
++++ b/arch/powerpc/boot/dts/mpc8377_wlan.dts
+@@ -462,4 +462,18 @@
+ 				  0 0x00800000>;
+ 		};
+ 	};
++
++	leds {
++		compatible = "gpio-leds";
++
++		diag {
++			gpios = <&gpio1 9 1>;
++			default-state = "off";
++		};
++
++		wireless {
++			gpios = <&gpio1 10 1>;
++			default-state = "off";
++		};
++	};
+ };
diff --git a/target/linux/mpc83xx/patches-3.10/110-vitesse_8601.patch b/target/linux/mpc83xx/patches-3.10/110-vitesse_8601.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/patches-3.10/110-vitesse_8601.patch
@@ -0,0 +1,93 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -68,6 +68,12 @@ config VITESSE_PHY
+         ---help---
+           Currently supports the vsc8244
+ 
++config VITESSE_PHY_8601_SKEW
++	bool "Enable skew timing to vsc8601"
++	depends on VITESSE_PHY
++	---help---
++	  Apply clock timing adjustments for vsc8601
++
+ config SMSC_PHY
+ 	tristate "Drivers for SMSC PHYs"
+ 	---help---
+--- a/drivers/net/phy/vitesse.c
++++ b/drivers/net/phy/vitesse.c
+@@ -26,6 +26,11 @@
+ #define MII_VSC8244_EXTCON1_TX_SKEW	0x0800
+ #define MII_VSC8244_EXTCON1_RX_SKEW	0x0200
+ 
++/* EXT_CON1 Register values for VSC8601 */
++#define MII_VSC8601_EXTCON1_INIT       0x0000
++#define MII_VSC8601_EXTCON1_SKEW       0x0100
++#define MII_VSC8601_EXTCON1_ACTIPHY    0x0020
++
+ /* Vitesse Interrupt Mask Register */
+ #define MII_VSC8244_IMASK		0x19
+ #define MII_VSC8244_IMASK_IEN		0x8000
+@@ -56,6 +61,7 @@
+ 
+ #define PHY_ID_VSC8244			0x000fc6c0
+ #define PHY_ID_VSC8221			0x000fc550
++#define PHY_ID_VSC8601			0x00070420
+ 
+ MODULE_DESCRIPTION("Vitesse PHY driver");
+ MODULE_AUTHOR("Kriston Carson");
+@@ -97,10 +103,34 @@ static int vsc824x_config_init(struct ph
+ 	return err;
+ }
+ 
++static int vsc8601_config_init(struct phy_device *phydev)
++{
++	int err;
++	int extcon;
++
++	err = phy_write(phydev, MII_VSC8244_AUX_CONSTAT,
++					MII_VSC8244_AUXCONSTAT_INIT);
++
++	if (err < 0)
++		return err;
++
++#ifdef CONFIG_VITESSE_PHY_8601_SKEW
++	extcon = phy_read(phydev, MII_VSC8244_EXT_CON1);
++	if (err < 0)
++		return err;
++
++	extcon |= MII_VSC8601_EXTCON1_SKEW;
++
++	err = phy_write(phydev, MII_VSC8244_EXT_CON1, extcon);
++#endif
++
++	return err;
++}
++
+ static int vsc824x_ack_interrupt(struct phy_device *phydev)
+ {
+ 	int err = 0;
+-	
++
+ 	/*
+ 	 * Don't bother to ACK the interrupts if interrupts
+ 	 * are disabled.  The 824x cannot clear the interrupts
+@@ -176,6 +206,19 @@ static struct phy_driver vsc82xx_driver[
+ 	.ack_interrupt	= &vsc824x_ack_interrupt,
+ 	.config_intr	= &vsc82xx_config_intr,
+ 	.driver		= { .owner = THIS_MODULE,},
++}, {
++	/* Vitesse 8601 */
++	.phy_id         = PHY_ID_VSC8601,
++	.name           = "Vitesse VSC8601",
++	.phy_id_mask    = 0x000ffff8,
++	.features       = PHY_GBIT_FEATURES,
++	.flags          = PHY_HAS_INTERRUPT,
++	.config_init    = &vsc8601_config_init,
++	.config_aneg    = &genphy_config_aneg,
++	.read_status    = &genphy_read_status,
++	.ack_interrupt  = &vsc824x_ack_interrupt,
++	.config_intr    = &vsc82xx_config_intr,
++	.driver         = { .owner = THIS_MODULE,},
+ } };
+ 
+ static int __init vsc82xx_init(void)
diff --git a/target/linux/mpc83xx/patches-3.10/111-etsec27_war.patch b/target/linux/mpc83xx/patches-3.10/111-etsec27_war.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/patches-3.10/111-etsec27_war.patch
@@ -0,0 +1,20 @@
+--- a/drivers/net/ethernet/freescale/gianfar.c
++++ b/drivers/net/ethernet/freescale/gianfar.c
+@@ -1016,7 +1016,16 @@ static int gfar_probe(struct platform_de
+ 	/* We need to delay at least 3 TX clocks */
+ 	udelay(2);
+ 
+-	tempval = (MACCFG1_TX_FLOW | MACCFG1_RX_FLOW);
++	if ((mfspr(SPRN_SVR) & 0xffff) >= 0x0011) {
++		tempval = (MACCFG1_TX_FLOW | MACCFG1_RX_FLOW);
++	} else {
++		/*
++		 * Do not enable flow control on chips earlier than rev 1.1,
++		 * because of the eTSEC27 erratum
++		 */
++		tempval = 0;
++	}
++
+ 	gfar_write(&regs->maccfg1, tempval);
+ 
+ 	/* Initialize MACCFG2. */
diff --git a/target/linux/mpc83xx/patches-3.10/120-ucc_tdm.patch b/target/linux/mpc83xx/patches-3.10/120-ucc_tdm.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/patches-3.10/120-ucc_tdm.patch
@@ -0,0 +1,1307 @@
+--- /dev/null
++++ b/drivers/misc/ucc_tdm.h
+@@ -0,0 +1,221 @@
++/*
++ * drivers/misc/ucc_tdm.h
++ *
++ * UCC Based Linux TDM Driver
++ * This driver is designed to support UCC based TDM for PowerPC processors.
++ * This driver can interface with SLIC device to run VOIP kind of
++ * applications.
++ *
++ * Author: Ashish Kalra & Poonam Aggrwal
++ *
++ * Copyright (c) 2007 Freescale Semiconductor, Inc.
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License as published by the
++ * Free Software Foundation; either version 2 of the License, or (at your
++ * option) any later version.
++ */
++
++#ifndef TDM_H
++#define TDM_H
++
++#define NUM_TS 8
++#define ACTIVE_CH 8
++
++/* SAMPLE_DEPTH is the sample depth is the number of frames before
++ * an interrupt. Must be a multiple of 4
++ */
++#define SAMPLE_DEPTH 80
++
++/* define the number of Rx interrupts to go by for initial stuttering */
++#define STUTTER_INT_CNT 1
++
++/* BMRx Field Descriptions to specify tstate and rstate in UCC parameter RAM*/
++#define EN_BUS_SNOOPING 0x20
++#define BE_BO 0x10
++
++/* UPSMR Register for Transparent UCC controller Bit definitions*/
++#define NBO 0x00000000 /* Normal Mode 1 bit of data per clock */
++
++/* SI Mode register bit definitions */
++#define NORMAL_OPERATION 0x0000
++#define AUTO_ECHO 0x0400
++#define INTERNAL_LB 0x0800
++#define CONTROL_LB 0x0c00
++#define SIMODE_CRT (0x8000 >> 9)
++#define SIMODE_SL (0x8000 >> 10)
++#define SIMODE_CE (0x8000 >> 11)
++#define SIMODE_FE (0x8000 >> 12)
++#define SIMODE_GM (0x8000 >> 13)
++#define SIMODE_TFSD(val) (val)
++#define SIMODE_RFSD(val) ((val) << 8)
++
++#define SI_TDM_MODE_REGISTER_OFFSET 0
++
++#define R_CM 0x02000000
++#define T_CM 0x02000000
++
++#define SET_RX_SI_RAM(n, val) \
++ out_be16((u16 *)&qe_immr->sir.rx[(n)*2], (u16)(val))
++
++#define SET_TX_SI_RAM(n, val) \
++ out_be16((u16 *)&qe_immr->sir.tx[(n)*2], (u16)(val))
++
++/* SI RAM entries */
++#define SIR_LAST 0x0001
++#define SIR_CNT(n) ((n) << 2)
++#define SIR_BYTE 0x0002
++#define SIR_BIT 0x0000
++#define SIR_IDLE 0
++#define SIR_UCC(uccx) (((uccx+9)) << 5)
++
++/* BRGC Register Bit definitions */
++#define BRGC_RESET (0x1<<17)
++#define BRGC_EN (0x1<<16)
++#define BRGC_EXTC_QE (0x00<<14)
++#define BRGC_EXTC_CLK3 (0x01<<14)
++#define BRGC_EXTC_CLK5 (0x01<<15)
++#define BRGC_EXTC_CLK9 (0x01<<14)
++#define BRGC_EXTC_CLK11 (0x01<<14)
++#define BRGC_EXTC_CLK13 (0x01<<14)
++#define BRGC_EXTC_CLK15 (0x01<<15)
++#define BRGC_ATB (0x1<<13)
++#define BRGC_DIV16 (0x1)
++
++/* structure representing UCC transparent parameter RAM */
++struct ucc_transparent_pram {
++ __be16 riptr;
++ __be16 tiptr;
++ __be16 res0;
++ __be16 mrblr;
++ __be32 rstate;
++ __be32 rbase;
++ __be16 rbdstat;
++ __be16 rbdlen;
++ __be32 rdptr;
++ __be32 tstate;
++ __be32 tbase;
++ __be16 tbdstat;
++ __be16 tbdlen;
++ __be32 tdptr;
++ __be32 rbptr;
++ __be32 tbptr;
++ __be32 rcrc;
++ __be32 res1;
++ __be32 tcrc;
++ __be32 res2;
++ __be32 res3;
++ __be32 c_mask;
++ __be32 c_pres;
++ __be16 disfc;
++ __be16 crcec;
++ __be32 res4[4];
++ __be16 ts_tmp;
++ __be16 tmp_mb;
++};
++
++#define UCC_TRANSPARENT_PRAM_SIZE 0x100
++
++struct tdm_cfg {
++ u8 com_pin; /* Common receive and transmit pins
++ * 0 = separate pins
++ * 1 = common pins
++ */
++
++ u8 fr_sync_level; /* SLx bit Frame Sync Polarity
++ * 0 = L1R/TSYNC active logic "1"
++ * 1 = L1R/TSYNC active logic "0"
++ */
++
++ u8 clk_edge; /* CEx bit Tx Rx Clock Edge
++ * 0 = TX data on rising edge of clock
++ * RX data on falling edge
++ * 1 = TX data on falling edge of clock
++ * RX data on rising edge
++ */
++
++ u8 fr_sync_edge; /* FEx bit Frame sync edge
++ * Determine when the sync pulses are sampled
++ * 0 = Falling edge
++ * 1 = Rising edge
++ */
++
++ u8 rx_fr_sync_delay; /* TFSDx/RFSDx bits Frame Sync Delay
++ * 00 = no bit delay
++ * 01 = 1 bit delay
++ * 10 = 2 bit delay
++ * 11 = 3 bit delay
++ */
++
++ u8 tx_fr_sync_delay; /* TFSDx/RFSDx bits Frame Sync Delay
++ * 00 = no bit delay
++ * 01 = 1 bit delay
++ * 10 = 2 bit delay
++ * 11 = 3 bit delay
++ */
++
++ u8 active_num_ts; /* Number of active time slots in TDM
++ * assume same active Rx/Tx time slots
++ */
++};
++
++struct ucc_tdm_info {
++ struct ucc_fast_info uf_info;
++ u32 ucc_busy;
++};
++
++struct tdm_ctrl {
++ u32 device_busy;
++ struct device *device;
++ struct ucc_fast_private *uf_private;
++ struct ucc_tdm_info *ut_info;
++ u32 tdm_port; /* port for this tdm:TDMA,TDMB,TDMC,TDMD */
++ u32 si; /* serial interface: 0 or 1 */
++ struct ucc_fast __iomem *uf_regs; /* UCC Fast registers */
++ u16 rx_mask[8]; /* Active Receive channels LSB is ch0 */
++ u16 tx_mask[8]; /* Active Transmit channels LSB is ch0 */
++ /* Only channels less than the number of FRAME_SIZE are implemented */
++ struct tdm_cfg cfg_ctrl; /* Signaling controls configuration */
++ u8 *tdm_input_data; /* buffer used for Rx by the tdm */
++ u8 *tdm_output_data; /* buffer used for Tx by the tdm */
++
++ dma_addr_t dma_input_addr; /* dma mapped buffer for TDM Rx */
++ dma_addr_t dma_output_addr; /* dma mapped buffer for TDM Tx */
++ u16 physical_num_ts; /* physical number of timeslots in the tdm
++ frame */
++ u32 phase_rx; /* cycles through 0, 1, 2 */
++ u32 phase_tx; /* cycles through 0, 1, 2 */
++ /*
++ * the following two variables are for dealing with "stutter" problem
++ * "stutter" period is about 20 frames or so, varies depending active
++ * channel num depending on the sample depth, the code should let a
++ * few Rx interrupts go by
++ */
++ u32 tdm_icnt;
++ u32 tdm_flag;
++ struct ucc_transparent_pram __iomem *ucc_pram;
++ struct qe_bd __iomem *tx_bd;
++ struct qe_bd __iomem *rx_bd;
++ u32 ucc_pram_offset;
++ u32 tx_bd_offset;
++ u32 rx_bd_offset;
++ u32 rx_ucode_buf_offset;
++ u32 tx_ucode_buf_offset;
++ bool leg_slic;
++ wait_queue_head_t wakeup_event;
++};
++
++struct tdm_client {
++ u32 client_id;
++ void (*tdm_read)(u32 client_id, short chn_id,
++ short *pcm_buffer, short len);
++ void (*tdm_write)(u32 client_id, short chn_id,
++ short *pcm_buffer, short len);
++ wait_queue_head_t *wakeup_event;
++ };
++
++#define MAX_PHASE 1
++#define NR_BUFS 2
++#define EFF_ACTIVE_CH ACTIVE_CH / 2
++
++#endif
+--- /dev/null
++++ b/drivers/misc/ucc_tdm.c
+@@ -0,0 +1,1017 @@
++/*
++ * drivers/misc/ucc_tdm.c
++ *
++ * UCC Based Linux TDM Driver
++ * This driver is designed to support UCC based TDM for PowerPC processors.
++ * This driver can interface with SLIC device to run VOIP kind of
++ * applications.
++ *
++ * Author: Ashish Kalra & Poonam Aggrwal
++ *
++ * Copyright (c) 2007 Freescale Semiconductor, Inc.
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License as published by the
++ * Free Software Foundation; either version 2 of the License, or (at your
++ * option) any later version.
++ */
++
++#include <generated/autoconf.h>
++#include <linux/module.h>
++#include <linux/sched.h>
++#include <linux/kernel.h>
++#include <linux/slab.h>
++#include <linux/errno.h>
++#include <linux/types.h>
++#include <linux/interrupt.h>
++#include <linux/time.h>
++#include <linux/skbuff.h>
++#include <linux/proc_fs.h>
++#include <linux/delay.h>
++#include <linux/dma-mapping.h>
++#include <linux/string.h>
++#include <linux/irq.h>
++#include <linux/of_platform.h>
++#include <linux/io.h>
++#include <linux/wait.h>
++#include <linux/timer.h>
++
++#include <asm/immap_qe.h>
++#include <asm/qe.h>
++#include <asm/ucc.h>
++#include <asm/ucc_fast.h>
++#include <asm/ucc_slow.h>
++
++#include "ucc_tdm.h"
++#define DRV_DESC "Freescale QE UCC TDM Driver"
++#define DRV_NAME "ucc_tdm"
++
++
++/*
++ * define the following #define if snooping or hardware-based cache coherency
++ * is disabled on the UCC transparent controller.This flag enables
++ * software-based cache-coherency support by explicitly flushing data cache
++ * contents after setting up the TDM output buffer(s) and invalidating the
++ * data cache contents before the TDM input buffer(s) are read.
++ */
++#undef UCC_CACHE_SNOOPING_DISABLED
++
++#define MAX_NUM_TDM_DEVICES 8
++
++static struct tdm_ctrl *tdm_ctrl[MAX_NUM_TDM_DEVICES];
++
++static int num_tdm_devices;
++static int num_tdm_clients;
++
++static struct ucc_tdm_info utdm_primary_info = {
++ .uf_info = {
++ .tsa = 1,
++ .cdp = 1,
++ .cds = 1,
++ .ctsp = 1,
++ .ctss = 1,
++ .revd = 1,
++ .urfs = 0x128,
++ .utfs = 0x128,
++ .utfet = 0,
++ .utftt = 0x128,
++ .ufpt = 256,
++ .ttx_trx = UCC_FAST_GUMR_TRANSPARENT_TTX_TRX_TRANSPARENT,
++ .tenc = UCC_FAST_TX_ENCODING_NRZ,
++ .renc = UCC_FAST_RX_ENCODING_NRZ,
++ .tcrc = UCC_FAST_16_BIT_CRC,
++ .synl = UCC_FAST_SYNC_LEN_NOT_USED,
++ },
++ .ucc_busy = 0,
++};
++
++static struct ucc_tdm_info utdm_info[8];
++
++static void dump_siram(struct tdm_ctrl *tdm_c)
++{
++#ifdef DEBUG
++ int i;
++ u16 phy_num_ts;
++
++ phy_num_ts = tdm_c->physical_num_ts;
++
++ pr_debug("SI TxRAM dump\n");
++ /* each slot entry in SI RAM is of 2 bytes */
++ for (i = 0; i < phy_num_ts * 2; i++)
++ pr_debug("%x ", in_8(&qe_immr->sir.tx[i]));
++ pr_debug("\nSI RxRAM dump\n");
++ for (i = 0; i < phy_num_ts * 2; i++)
++ pr_debug("%x ", in_8(&qe_immr->sir.rx[i]));
++ pr_debug("\n");
++#endif
++}
++
++static void dump_ucc(struct tdm_ctrl *tdm_c)
++{
++#ifdef DEBUG
++ struct ucc_transparent_pram *ucc_pram;
++
++ ucc_pram = tdm_c->ucc_pram;
++
++ pr_debug("%s Dumping UCC Registers\n", __FUNCTION__);
++ ucc_fast_dump_regs(tdm_c->uf_private);
++ pr_debug("%s Dumping UCC Parameter RAM\n", __FUNCTION__);
++ pr_debug("rbase = 0x%x\n", in_be32(&ucc_pram->rbase));
++ pr_debug("rbptr = 0x%x\n", in_be32(&ucc_pram->rbptr));
++ pr_debug("mrblr = 0x%x\n", in_be16(&ucc_pram->mrblr));
++ pr_debug("rbdlen = 0x%x\n", in_be16(&ucc_pram->rbdlen));
++ pr_debug("rbdstat = 0x%x\n", in_be16(&ucc_pram->rbdstat));
++ pr_debug("rstate = 0x%x\n", in_be32(&ucc_pram->rstate));
++ pr_debug("rdptr = 0x%x\n", in_be32(&ucc_pram->rdptr));
++ pr_debug("tbase = 0x%x\n", in_be32(&ucc_pram->tbase));
++ pr_debug("tbptr = 0x%x\n", in_be32(&ucc_pram->tbptr));
++ pr_debug("tbdlen = 0x%x\n", in_be16(&ucc_pram->tbdlen));
++ pr_debug("tbdstat = 0x%x\n", in_be16(&ucc_pram->tbdstat));
++ pr_debug("tstate = 0x%x\n", in_be32(&ucc_pram->tstate));
++ pr_debug("tdptr = 0x%x\n", in_be32(&ucc_pram->tdptr));
++#endif
++}
++
++/*
++ * For use when a framing bit is not present
++ * Program current-route SI ram
++ * Set SIxRAM TDMx
++ * Entries must be in units of 8.
++ * SIR_UCC -> Channel Select
++ * SIR_CNT -> Number of bits or bytes
++ * SIR_BYTE -> Byte or Bit resolution
++ * SIR_LAST -> Indicates last entry in SIxRAM
++ * SIR_IDLE -> The Tx data pin is Tri-stated and the Rx data pin is
++ * ignored
++ */
++static void set_siram(struct tdm_ctrl *tdm_c, enum comm_dir dir)
++{
++ const u16 *mask;
++ u16 temp_mask = 1;
++ u16 siram_code = 0;
++ u32 i, j, k;
++ u32 ucc;
++ u32 phy_num_ts;
++
++ phy_num_ts = tdm_c->physical_num_ts;
++ ucc = tdm_c->ut_info->uf_info.ucc_num;
++
++ if (dir == COMM_DIR_RX)
++ mask = tdm_c->rx_mask;
++ else
++ mask = tdm_c->tx_mask;
++ k = 0;
++ j = 0;
++ for (i = 0; i < phy_num_ts; i++) {
++ if ((mask[k] & temp_mask) == temp_mask)
++ siram_code = SIR_UCC(ucc) | SIR_CNT(0) | SIR_BYTE;
++ else
++ siram_code = SIR_IDLE | SIR_CNT(0) | SIR_BYTE;
++ if (dir == COMM_DIR_RX)
++ out_be16((u16 *)&qe_immr->sir.rx[i * 2], siram_code);
++ else
++ out_be16((u16 *)&qe_immr->sir.tx[i * 2], siram_code);
++ temp_mask = temp_mask << 1;
++ j++;
++ if (j >= 16) {
++ j = 0;
++ temp_mask = 0x0001;
++ k++;
++ }
++ }
++ siram_code = siram_code | SIR_LAST;
++
++ if (dir == COMM_DIR_RX)
++ out_be16((u16 *)&qe_immr->sir.rx[(phy_num_ts - 1) * 2],
++ siram_code);
++ else
++ out_be16((u16 *)&qe_immr->sir.tx[(phy_num_ts - 1) * 2],
++ siram_code);
++}
++
++static void config_si(struct tdm_ctrl *tdm_c)
++{
++ u8 rxsyncdelay, txsyncdelay, tdm_port;
++ u16 sixmr_val = 0;
++ u32 tdma_mode_off;
++ u16 *si1_tdm_mode_reg;
++
++ tdm_port = tdm_c->tdm_port;
++
++ set_siram(tdm_c, COMM_DIR_RX);
++
++ set_siram(tdm_c, COMM_DIR_TX);
++
++ rxsyncdelay = tdm_c->cfg_ctrl.rx_fr_sync_delay;
++ txsyncdelay = tdm_c->cfg_ctrl.tx_fr_sync_delay;
++ if (tdm_c->cfg_ctrl.com_pin)
++ sixmr_val |= SIMODE_CRT;
++ if (tdm_c->cfg_ctrl.fr_sync_level == 1)
++ sixmr_val |= SIMODE_SL;
++ if (tdm_c->cfg_ctrl.clk_edge == 1)
++ sixmr_val |= SIMODE_CE;
++ if (tdm_c->cfg_ctrl.fr_sync_edge == 1)
++ sixmr_val |= SIMODE_FE;
++ sixmr_val |= (SIMODE_TFSD(txsyncdelay) | SIMODE_RFSD(rxsyncdelay));
++
++ tdma_mode_off = SI_TDM_MODE_REGISTER_OFFSET * tdm_c->tdm_port;
++
++ si1_tdm_mode_reg = (u8 *)&qe_immr->si1 + tdma_mode_off;
++ out_be16(si1_tdm_mode_reg, sixmr_val);
++
++ dump_siram(tdm_c);
++}
++
++static int tdm_init(struct tdm_ctrl *tdm_c)
++{
++ u32 tdm_port, ucc, act_num_ts;
++ int ret, i, err;
++ u32 cecr_subblock;
++ u32 pram_offset;
++ u32 rxbdt_offset;
++ u32 txbdt_offset;
++ u32 rx_ucode_buf_offset, tx_ucode_buf_offset;
++ u16 bd_status, bd_len;
++ enum qe_clock clock;
++ struct qe_bd __iomem *rx_bd, *tx_bd;
++
++ tdm_port = tdm_c->tdm_port;
++ ucc = tdm_c->ut_info->uf_info.ucc_num;
++ act_num_ts = tdm_c->cfg_ctrl.active_num_ts;
++
++ /*
++ * TDM Tx and Rx CLKs = 2048 KHz.
++ */
++ if (strstr(tdm_c->ut_info->uf_info.tdm_tx_clk, "BRG")) {
++ clock = qe_clock_source(tdm_c->ut_info->uf_info.tdm_tx_clk);
++ err = qe_setbrg(clock, 2048000, 1);
++ if (err < 0) {
++ printk(KERN_ERR "%s: Failed to set %s\n", __FUNCTION__,
++ tdm_c->ut_info->uf_info.tdm_tx_clk);
++ return err;
++ }
++ }
++ if (strstr(tdm_c->ut_info->uf_info.tdm_rx_clk, "BRG")) {
++ clock = qe_clock_source(tdm_c->ut_info->uf_info.tdm_rx_clk);
++ err = qe_setbrg(clock, 2048000, 1);
++ if (err < 0) {
++ printk(KERN_ERR "%s: Failed to set %s\n", __FUNCTION__,
++ tdm_c->ut_info->uf_info.tdm_rx_clk);
++ return err;
++ }
++ }
++ /*
++ * TDM FSyncs = 4 KHz.
++ */
++ if (strstr(tdm_c->ut_info->uf_info.tdm_tx_sync, "BRG")) {
++ clock = qe_clock_source(tdm_c->ut_info->uf_info.tdm_tx_sync);
++ err = qe_setbrg(clock, 4000, 1);
++ if (err < 0) {
++ printk(KERN_ERR "%s: Failed to set %s\n", __FUNCTION__,
++ tdm_c->ut_info->uf_info.tdm_tx_sync);
++ return err;
++ }
++ }
++ if (strstr(tdm_c->ut_info->uf_info.tdm_rx_sync, "BRG")) {
++ clock = qe_clock_source(tdm_c->ut_info->uf_info.tdm_rx_sync);
++ err = qe_setbrg(clock, 4000, 1);
++ if (err < 0) {
++ printk(KERN_ERR "%s: Failed to set %s\n", __FUNCTION__,
++ tdm_c->ut_info->uf_info.tdm_rx_sync);
++ return err;
++ }
++ }
++
++ tdm_c->ut_info->uf_info.uccm_mask = (u32)
++ ((UCC_TRANS_UCCE_RXB | UCC_TRANS_UCCE_BSY) << 16);
++
++ if (ucc_fast_init(&(tdm_c->ut_info->uf_info), &tdm_c->uf_private)) {
++ printk(KERN_ERR "%s: Failed to init uccf\n", __FUNCTION__);
++ return -ENOMEM;
++ }
++
++ ucc_fast_disable(tdm_c->uf_private, COMM_DIR_RX | COMM_DIR_TX);
++
++ /* Write to QE CECR, UCCx channel to Stop Transmission */
++ cecr_subblock = ucc_fast_get_qe_cr_subblock(ucc);
++ qe_issue_cmd(QE_STOP_TX, cecr_subblock,
++ (u8) QE_CR_PROTOCOL_UNSPECIFIED, 0);
++
++ pram_offset = qe_muram_alloc(UCC_TRANSPARENT_PRAM_SIZE,
++ ALIGNMENT_OF_UCC_SLOW_PRAM);
++ if (IS_ERR_VALUE(pram_offset)) {
++ printk(KERN_ERR "%s: Cannot allocate MURAM memory for"
++ " transparent UCC\n", __FUNCTION__);
++ ret = -ENOMEM;
++ goto pram_alloc_error;
++ }
++
++ cecr_subblock = ucc_fast_get_qe_cr_subblock(ucc);
++ qe_issue_cmd(QE_ASSIGN_PAGE_TO_DEVICE, cecr_subblock,
++ QE_CR_PROTOCOL_UNSPECIFIED, pram_offset);
++
++ tdm_c->ucc_pram = qe_muram_addr(pram_offset);
++ tdm_c->ucc_pram_offset = pram_offset;
++
++ /*
++ * zero-out pram, this will also ensure RSTATE, TSTATE are cleared, also
++ * DISFC & CRCEC counters will be initialized.
++ */
++ memset(tdm_c->ucc_pram, 0, sizeof(struct ucc_transparent_pram));
++
++ /* rbase, tbase alignment is 8. */
++ rxbdt_offset = qe_muram_alloc(NR_BUFS * sizeof(struct qe_bd),
++ QE_ALIGNMENT_OF_BD);
++ if (IS_ERR_VALUE(rxbdt_offset)) {
++ printk(KERN_ERR "%s: Cannot allocate MURAM memory for RxBDs\n",
++ __FUNCTION__);
++ ret = -ENOMEM;
++ goto rxbd_alloc_error;
++ }
++ txbdt_offset = qe_muram_alloc(NR_BUFS * sizeof(struct qe_bd),
++ QE_ALIGNMENT_OF_BD);
++ if (IS_ERR_VALUE(txbdt_offset)) {
++ printk(KERN_ERR "%s: Cannot allocate MURAM memory for TxBDs\n",
++ __FUNCTION__);
++ ret = -ENOMEM;
++ goto txbd_alloc_error;
++ }
++ tdm_c->tx_bd = qe_muram_addr(txbdt_offset);
++ tdm_c->rx_bd = qe_muram_addr(rxbdt_offset);
++
++ tdm_c->tx_bd_offset = txbdt_offset;
++ tdm_c->rx_bd_offset = rxbdt_offset;
++
++ rx_bd = tdm_c->rx_bd;
++ tx_bd = tdm_c->tx_bd;
++
++ out_be32(&tdm_c->ucc_pram->rbase, (u32) immrbar_virt_to_phys(rx_bd));
++ out_be32(&tdm_c->ucc_pram->tbase, (u32) immrbar_virt_to_phys(tx_bd));
++
++ for (i = 0; i < NR_BUFS - 1; i++) {
++ bd_status = (u16) ((R_E | R_CM | R_I) >> 16);
++ bd_len = 0;
++ out_be16(&rx_bd->length, bd_len);
++ out_be16(&rx_bd->status, bd_status);
++ out_be32(&rx_bd->buf,
++ tdm_c->dma_input_addr + i * SAMPLE_DEPTH * act_num_ts);
++ rx_bd += 1;
++
++ bd_status = (u16) ((T_R | T_CM) >> 16);
++ bd_len = SAMPLE_DEPTH * act_num_ts;
++ out_be16(&tx_bd->length, bd_len);
++ out_be16(&tx_bd->status, bd_status);
++ out_be32(&tx_bd->buf,
++ tdm_c->dma_output_addr + i * SAMPLE_DEPTH * act_num_ts);
++ tx_bd += 1;
++ }
++
++ bd_status = (u16) ((R_E | R_CM | R_I | R_W) >> 16);
++ bd_len = 0;
++ out_be16(&rx_bd->length, bd_len);
++ out_be16(&rx_bd->status, bd_status);
++ out_be32(&rx_bd->buf,
++ tdm_c->dma_input_addr + i * SAMPLE_DEPTH * act_num_ts);
++
++ bd_status = (u16) ((T_R | T_CM | T_W) >> 16);
++ bd_len = SAMPLE_DEPTH * act_num_ts;
++ out_be16(&tx_bd->length, bd_len);
++ out_be16(&tx_bd->status, bd_status);
++ out_be32(&tx_bd->buf,
++ tdm_c->dma_output_addr + i * SAMPLE_DEPTH * act_num_ts);
++
++ config_si(tdm_c);
++
++ setbits32(&qe_immr->ic.qimr, (0x80000000UL >> ucc));
++
++ rx_ucode_buf_offset = qe_muram_alloc(32, 32);
++ if (IS_ERR_VALUE(rx_ucode_buf_offset)) {
++ printk(KERN_ERR "%s: Cannot allocate MURAM mem for Rx"
++ " ucode buf\n", __FUNCTION__);
++ ret = -ENOMEM;
++ goto rxucode_buf_alloc_error;
++ }
++
++ tx_ucode_buf_offset = qe_muram_alloc(32, 32);
++ if (IS_ERR_VALUE(tx_ucode_buf_offset)) {
++ printk(KERN_ERR "%s: Cannot allocate MURAM mem for Tx"
++ " ucode buf\n", __FUNCTION__);
++ ret = -ENOMEM;
++ goto txucode_buf_alloc_error;
++ }
++ out_be16(&tdm_c->ucc_pram->riptr, (u16) rx_ucode_buf_offset);
++ out_be16(&tdm_c->ucc_pram->tiptr, (u16) tx_ucode_buf_offset);
++
++ tdm_c->rx_ucode_buf_offset = rx_ucode_buf_offset;
++ tdm_c->tx_ucode_buf_offset = tx_ucode_buf_offset;
++
++ /*
++ * set the receive buffer descriptor maximum size to be
++ * SAMPLE_DEPTH * number of active RX channels
++ */
++ out_be16(&tdm_c->ucc_pram->mrblr, (u16) SAMPLE_DEPTH * act_num_ts);
++
++ /*
++ * enable snooping and BE byte ordering on the UCC pram's
++ * tstate & rstate registers.
++ */
++ out_be32(&tdm_c->ucc_pram->tstate, 0x30000000UL);
++ out_be32(&tdm_c->ucc_pram->rstate, 0x30000000UL);
++
++ /*Put UCC transparent controller into serial interface mode. */
++ out_be32(&tdm_c->uf_regs->upsmr, 0);
++
++ /* Reset TX and RX for UCCx */
++ cecr_subblock = ucc_fast_get_qe_cr_subblock(ucc);
++ qe_issue_cmd(QE_INIT_TX_RX, cecr_subblock,
++ (u8) QE_CR_PROTOCOL_UNSPECIFIED, 0);
++
++ return 0;
++
++txucode_buf_alloc_error:
++ qe_muram_free(rx_ucode_buf_offset);
++rxucode_buf_alloc_error:
++ qe_muram_free(txbdt_offset);
++txbd_alloc_error:
++ qe_muram_free(rxbdt_offset);
++rxbd_alloc_error:
++ qe_muram_free(pram_offset);
++pram_alloc_error:
++ ucc_fast_free(tdm_c->uf_private);
++ return ret;
++}
++
++static void tdm_deinit(struct tdm_ctrl *tdm_c)
++{
++ qe_muram_free(tdm_c->rx_ucode_buf_offset);
++ qe_muram_free(tdm_c->tx_ucode_buf_offset);
++
++ if (tdm_c->rx_bd_offset) {
++ qe_muram_free(tdm_c->rx_bd_offset);
++ tdm_c->rx_bd = NULL;
++ tdm_c->rx_bd_offset = 0;
++ }
++ if (tdm_c->tx_bd_offset) {
++ qe_muram_free(tdm_c->tx_bd_offset);
++ tdm_c->tx_bd = NULL;
++ tdm_c->tx_bd_offset = 0;
++ }
++ if (tdm_c->ucc_pram_offset) {
++ qe_muram_free(tdm_c->ucc_pram_offset);
++ tdm_c->ucc_pram = NULL;
++ tdm_c->ucc_pram_offset = 0;
++ }
++}
++
++
++static irqreturn_t tdm_isr(int irq, void *dev_id)
++{
++ u8 *input_tdm_buffer, *output_tdm_buffer;
++ u32 txb, rxb;
++ u32 ucc;
++ register u32 ucce = 0;
++ struct tdm_ctrl *tdm_c;
++ tdm_c = (struct tdm_ctrl *)dev_id;
++
++ tdm_c->tdm_icnt++;
++ ucc = tdm_c->ut_info->uf_info.ucc_num;
++ input_tdm_buffer = tdm_c->tdm_input_data;
++ output_tdm_buffer = tdm_c->tdm_output_data;
++
++ if (in_be32(tdm_c->uf_private->p_ucce) &
++ (UCC_TRANS_UCCE_BSY << 16)) {
++ out_be32(tdm_c->uf_private->p_ucce,
++ (UCC_TRANS_UCCE_BSY << 16));
++ pr_info("%s: From tdm isr busy interrupt\n",
++ __FUNCTION__);
++ dump_ucc(tdm_c);
++
++ return IRQ_HANDLED;
++ }
++
++ if (tdm_c->tdm_flag == 1) {
++ /* track phases for Rx/Tx */
++ tdm_c->phase_rx += 1;
++ if (tdm_c->phase_rx == MAX_PHASE)
++ tdm_c->phase_rx = 0;
++
++ tdm_c->phase_tx += 1;
++ if (tdm_c->phase_tx == MAX_PHASE)
++ tdm_c->phase_tx = 0;
++
++#ifdef CONFIG_TDM_HW_LB_TSA_SLIC
++ {
++ u32 temp_rx, temp_tx, phase_tx, phase_rx;
++ int i;
++ phase_rx = tdm_c->phase_rx;
++ phase_tx = tdm_c->phase_tx;
++ if (phase_rx == 0)
++ phase_rx = MAX_PHASE;
++ else
++ phase_rx -= 1;
++ if (phase_tx == 0)
++ phase_tx = MAX_PHASE;
++ else
++ phase_tx -= 1;
++ temp_rx = phase_rx * SAMPLE_DEPTH * ACTIVE_CH;
++ temp_tx = phase_tx * SAMPLE_DEPTH * ACTIVE_CH;
++
++ /*check if loopback received data on TS0 is correct. */
++ pr_debug("%s: check if loopback received data on TS0"
++ " is correct\n", __FUNCTION__);
++ pr_debug("%d,%d ", phase_rx, phase_tx);
++ for (i = 0; i < 8; i++)
++ pr_debug("%1d,%1d ",
++ input_tdm_buffer[temp_rx + i],
++ output_tdm_buffer[temp_tx + i]);
++ pr_debug("\n");
++ }
++#endif
++
++ /* schedule BH */
++ wake_up_interruptible(&tdm_c->wakeup_event);
++ } else {
++ if (tdm_c->tdm_icnt == STUTTER_INT_CNT) {
++ txb = in_be32(&tdm_c->ucc_pram->tbptr) -
++ in_be32(&tdm_c->ucc_pram->tbase);
++ rxb = in_be32(&tdm_c->ucc_pram->rbptr) -
++ in_be32(&tdm_c->ucc_pram->rbase);
++ tdm_c->phase_tx = txb / sizeof(struct qe_bd);
++ tdm_c->phase_rx = rxb / sizeof(struct qe_bd);
++
++#ifdef CONFIG_TDM_HW_LB_TSA_SLIC
++ tdm_c->phase_tx = tdm_c->phase_rx;
++#endif
++
++ /* signal "stuttering" period is over */
++ tdm_c->tdm_flag = 1;
++
++ pr_debug("%s: stuttering period is over\n",
++ __FUNCTION__);
++
++ if (in_be32(tdm_c->uf_private->p_ucce) &
++ (UCC_TRANS_UCCE_TXE << 16)) {
++ u32 cecr_subblock;
++ out_be32(tdm_c->uf_private->p_ucce,
++ (UCC_TRANS_UCCE_TXE << 16));
++ pr_debug("%s: From tdm isr txe interrupt\n",
++ __FUNCTION__);
++
++ cecr_subblock =
++ ucc_fast_get_qe_cr_subblock(ucc);
++ qe_issue_cmd(QE_RESTART_TX, cecr_subblock,
++ (u8) QE_CR_PROTOCOL_UNSPECIFIED,
++ 0);
++ }
++ }
++ }
++
++ ucce = (in_be32(tdm_c->uf_private->p_ucce)
++ & in_be32(tdm_c->uf_private->p_uccm));
++
++ out_be32(tdm_c->uf_private->p_ucce, ucce);
++
++ return IRQ_HANDLED;
++}
++
++static int tdm_start(struct tdm_ctrl *tdm_c)
++{
++ if (request_irq(tdm_c->ut_info->uf_info.irq, tdm_isr,
++ 0, "tdm", tdm_c)) {
++ printk(KERN_ERR "%s: request_irq for tdm_isr failed\n",
++ __FUNCTION__);
++ return -ENODEV;
++ }
++
++ ucc_fast_enable(tdm_c->uf_private, COMM_DIR_RX | COMM_DIR_TX);
++
++ pr_info("%s 16-bit linear pcm mode active with"
++ " slots 0 & 2\n", __FUNCTION__);
++
++ dump_siram(tdm_c);
++ dump_ucc(tdm_c);
++
++ setbits8(&(qe_immr->si1.siglmr1_h), (0x1 << tdm_c->tdm_port));
++ pr_info("%s UCC based TDM enabled\n", __FUNCTION__);
++
++ return 0;
++}
++
++static void tdm_stop(struct tdm_ctrl *tdm_c)
++{
++ u32 port, si;
++ u32 ucc;
++ u32 cecr_subblock;
++
++ port = tdm_c->tdm_port;
++ si = tdm_c->si;
++ ucc = tdm_c->ut_info->uf_info.ucc_num;
++ cecr_subblock = ucc_fast_get_qe_cr_subblock(ucc);
++
++ qe_issue_cmd(QE_GRACEFUL_STOP_TX, cecr_subblock,
++ (u8) QE_CR_PROTOCOL_UNSPECIFIED, 0);
++ qe_issue_cmd(QE_CLOSE_RX_BD, cecr_subblock,
++ (u8) QE_CR_PROTOCOL_UNSPECIFIED, 0);
++
++ clrbits8(&qe_immr->si1.siglmr1_h, (0x1 << port));
++ ucc_fast_disable(tdm_c->uf_private, COMM_DIR_RX);
++ ucc_fast_disable(tdm_c->uf_private, COMM_DIR_TX);
++ free_irq(tdm_c->ut_info->uf_info.irq, tdm_c);
++}
++
++
++static void config_tdm(struct tdm_ctrl *tdm_c)
++{
++ u32 i, j, k;
++
++ j = 0;
++ k = 0;
++
++ /* Set Mask Bits */
++ for (i = 0; i < ACTIVE_CH; i++) {
++ tdm_c->tx_mask[k] |= (1 << j);
++ tdm_c->rx_mask[k] |= (1 << j);
++ j++;
++ if (j >= 16) {
++ j = 0;
++ k++;
++ }
++ }
++ /* physical number of slots in a frame */
++ tdm_c->physical_num_ts = NUM_TS;
++
++ /* common receive and transmit pins */
++ tdm_c->cfg_ctrl.com_pin = 1;
++
++ /* L1R/TSYNC active logic "1" */
++ tdm_c->cfg_ctrl.fr_sync_level = 0;
++
++ /*
++ * TX data on rising edge of clock
++ * RX data on falling edge
++ */
++ tdm_c->cfg_ctrl.clk_edge = 0;
++
++ /* Frame sync sampled on falling edge */
++ tdm_c->cfg_ctrl.fr_sync_edge = 0;
++
++ /* no bit delay */
++ tdm_c->cfg_ctrl.rx_fr_sync_delay = 0;
++
++ /* no bit delay */
++ tdm_c->cfg_ctrl.tx_fr_sync_delay = 0;
++
++#ifndef CONFIG_TDM_HW_LB_TSA_SLIC
++ if (tdm_c->leg_slic) {
++ /* Need 1 bit delay for Legrity SLIC */
++ tdm_c->cfg_ctrl.rx_fr_sync_delay = 1;
++ tdm_c->cfg_ctrl.tx_fr_sync_delay = 1;
++ pr_info("%s Delay for Legerity!\n", __FUNCTION__);
++ }
++#endif
++
++ tdm_c->cfg_ctrl.active_num_ts = ACTIVE_CH;
++}
++
++static void tdm_read(u32 client_id, short chn_id, short *pcm_buffer,
++ short len)
++{
++ int i;
++ u32 phase_rx;
++ /* point to where to start for the current phase data processing */
++ u32 temp_rx;
++
++ struct tdm_ctrl *tdm_c = tdm_ctrl[client_id];
++
++ u16 *input_tdm_buffer =
++ (u16 *)tdm_c->tdm_input_data;
++
++ phase_rx = tdm_c->phase_rx;
++ if (phase_rx == 0)
++ phase_rx = MAX_PHASE;
++ else
++ phase_rx -= 1;
++
++ temp_rx = phase_rx * SAMPLE_DEPTH * EFF_ACTIVE_CH;
++
++#ifdef UCC_CACHE_SNOOPING_DISABLED
++ flush_dcache_range((size_t) &input_tdm_buffer[temp_rx],
++ (size_t) &input_tdm_buffer[temp_rx +
++ SAMPLE_DEPTH * ACTIVE_CH]);
++#endif
++ for (i = 0; i < len; i++)
++ pcm_buffer[i] =
++ input_tdm_buffer[i * EFF_ACTIVE_CH + temp_rx + chn_id];
++
++}
++
++static void tdm_write(u32 client_id, short chn_id, short *pcm_buffer,
++ short len)
++{
++ int i;
++ int phase_tx;
++ u32 txb;
++ /* point to where to start for the current phase data processing */
++ int temp_tx;
++ struct tdm_ctrl *tdm_c = tdm_ctrl[client_id];
++
++ u16 *output_tdm_buffer;
++ output_tdm_buffer = (u16 *)tdm_c->tdm_output_data;
++ txb = in_be32(&tdm_c->ucc_pram->tbptr) -
++ in_be32(&tdm_c->ucc_pram->tbase);
++ phase_tx = txb / sizeof(struct qe_bd);
++
++ if (phase_tx == 0)
++ phase_tx = MAX_PHASE;
++ else
++ phase_tx -= 1;
++
++ temp_tx = phase_tx * SAMPLE_DEPTH * EFF_ACTIVE_CH;
++
++ for (i = 0; i < len; i++)
++ output_tdm_buffer[i * EFF_ACTIVE_CH + temp_tx + chn_id] =
++ pcm_buffer[i];
++
++#ifdef UCC_CACHE_SNOOPING_DISABLED
++ flush_dcache_range((size_t) &output_tdm_buffer[temp_tx],
++ (size_t) &output_tdm_buffer[temp_tx + SAMPLE_DEPTH *
++ ACTIVE_CH]);
++#endif
++}
++
++
++static int tdm_register_client(struct tdm_client *tdm_client)
++{
++ u32 i;
++ if (num_tdm_clients == num_tdm_devices) {
++ printk(KERN_ERR "all TDM devices busy\n");
++ return -EBUSY;
++ }
++
++ for (i = 0; i < num_tdm_devices; i++) {
++ if (!tdm_ctrl[i]->device_busy) {
++ tdm_ctrl[i]->device_busy = 1;
++ break;
++ }
++ }
++ num_tdm_clients++;
++ tdm_client->client_id = i;
++ tdm_client->tdm_read = tdm_read;
++ tdm_client->tdm_write = tdm_write;
++ tdm_client->wakeup_event =
++ &(tdm_ctrl[i]->wakeup_event);
++ return 0;
++}
++EXPORT_SYMBOL_GPL(tdm_register_client);
++
++static int tdm_deregister_client(struct tdm_client *tdm_client)
++{
++ num_tdm_clients--;
++ tdm_ctrl[tdm_client->client_id]->device_busy = 0;
++ return 0;
++}
++EXPORT_SYMBOL_GPL(tdm_deregister_client);
++
++static int ucc_tdm_probe(struct of_device *ofdev,
++ const struct of_device_id *match)
++{
++ struct device_node *np = ofdev->node;
++ struct resource res;
++ const unsigned int *prop;
++ u32 ucc_num, device_num, err, ret = 0;
++ struct device_node *np_tmp;
++ dma_addr_t physaddr;
++ void *tdm_buff;
++ struct ucc_tdm_info *ut_info;
++
++ prop = of_get_property(np, "device-id", NULL);
++ if (prop == NULL) {
++ printk(KERN_ERR "ucc_tdm: device-id missing\n");
++ return -ENODEV;
++ }
++
++ ucc_num = *prop - 1;
++ if ((ucc_num < 0) || (ucc_num > 7))
++ return -ENODEV;
++
++ ut_info = &utdm_info[ucc_num];
++ if (ut_info->ucc_busy) {
++ printk(KERN_ERR "ucc_tdm: UCC in use by another TDM driver"
++ "instance\n");
++ return -EBUSY;
++ }
++ if (num_tdm_devices == MAX_NUM_TDM_DEVICES) {
++ printk(KERN_ERR "ucc_tdm: All TDM devices already"
++ " initialized\n");
++ return -ENODEV;
++ }
++
++ ut_info->ucc_busy = 1;
++ tdm_ctrl[num_tdm_devices++] =
++ kzalloc(sizeof(struct tdm_ctrl), GFP_KERNEL);
++ if (!tdm_ctrl[num_tdm_devices - 1]) {
++ printk(KERN_ERR "ucc_tdm: no memory to allocate for"
++ " tdm control structure\n");
++ num_tdm_devices--;
++ return -ENOMEM;
++ }
++ device_num = num_tdm_devices - 1;
++
++ tdm_ctrl[device_num]->device = &ofdev->dev;
++ tdm_ctrl[device_num]->ut_info = ut_info;
++
++ tdm_ctrl[device_num]->ut_info->uf_info.ucc_num = ucc_num;
++
++ prop = of_get_property(np, "fsl,tdm-num", NULL);
++ if (prop == NULL) {
++ ret = -EINVAL;
++ goto get_property_error;
++ }
++
++ tdm_ctrl[device_num]->tdm_port = *prop - 1;
++
++ if (tdm_ctrl[device_num]->tdm_port > 3) {
++ ret = -EINVAL;
++ goto get_property_error;
++ }
++
++ prop = of_get_property(np, "fsl,si-num", NULL);
++ if (prop == NULL) {
++ ret = -EINVAL;
++ goto get_property_error;
++ }
++
++ tdm_ctrl[device_num]->si = *prop - 1;
++
++ tdm_ctrl[device_num]->ut_info->uf_info.tdm_tx_clk =
++ of_get_property(np, "fsl,tdm-tx-clk", NULL);
++ if (tdm_ctrl[device_num]->ut_info->uf_info.tdm_tx_clk == NULL) {
++ ret = -EINVAL;
++ goto get_property_error;
++ }
++
++ tdm_ctrl[device_num]->ut_info->uf_info.tdm_rx_clk =
++ of_get_property(np, "fsl,tdm-rx-clk", NULL);
++ if (tdm_ctrl[device_num]->ut_info->uf_info.tdm_rx_clk == NULL) {
++ ret = -EINVAL;
++ goto get_property_error;
++ }
++
++ tdm_ctrl[device_num]->ut_info->uf_info.tdm_tx_sync =
++ of_get_property(np, "fsl,tdm-tx-sync", NULL);
++ if (tdm_ctrl[device_num]->ut_info->uf_info.tdm_tx_sync == NULL) {
++ ret = -EINVAL;
++ goto get_property_error;
++ }
++
++ tdm_ctrl[device_num]->ut_info->uf_info.tdm_rx_sync =
++ of_get_property(np, "fsl,tdm-rx-sync", NULL);
++ if (tdm_ctrl[device_num]->ut_info->uf_info.tdm_rx_sync == NULL) {
++ ret = -EINVAL;
++ goto get_property_error;
++ }
++
++ tdm_ctrl[device_num]->ut_info->uf_info.irq =
++ irq_of_parse_and_map(np, 0);
++ err = of_address_to_resource(np, 0, &res);
++ if (err) {
++ ret = -EINVAL;
++ goto get_property_error;
++ }
++ tdm_ctrl[device_num]->ut_info->uf_info.regs = res.start;
++ tdm_ctrl[device_num]->uf_regs = of_iomap(np, 0);
++
++ np_tmp = NULL;
++ np_tmp = of_find_compatible_node(np_tmp, "slic", "legerity-slic");
++ if (np_tmp != NULL) {
++ tdm_ctrl[device_num]->leg_slic = 1;
++ of_node_put(np_tmp);
++ } else
++ tdm_ctrl[device_num]->leg_slic = 0;
++
++ config_tdm(tdm_ctrl[device_num]);
++
++ tdm_buff = dma_alloc_coherent(NULL, 2 * NR_BUFS * SAMPLE_DEPTH *
++ tdm_ctrl[device_num]->cfg_ctrl.active_num_ts,
++ &physaddr, GFP_KERNEL);
++ if (!tdm_buff) {
++ printk(KERN_ERR "ucc-tdm: could not allocate buffer"
++ "descriptors\n");
++ ret = -ENOMEM;
++ goto alloc_error;
++ }
++
++ tdm_ctrl[device_num]->tdm_input_data = tdm_buff;
++ tdm_ctrl[device_num]->dma_input_addr = physaddr;
++
++ tdm_ctrl[device_num]->tdm_output_data = tdm_buff + NR_BUFS *
++ SAMPLE_DEPTH * tdm_ctrl[device_num]->cfg_ctrl.active_num_ts;
++ tdm_ctrl[device_num]->dma_output_addr = physaddr + NR_BUFS *
++ SAMPLE_DEPTH * tdm_ctrl[device_num]->cfg_ctrl.active_num_ts;
++
++ init_waitqueue_head(&(tdm_ctrl[device_num]->wakeup_event));
++
++ ret = tdm_init(tdm_ctrl[device_num]);
++ if (ret != 0)
++ goto tdm_init_error;
++
++ ret = tdm_start(tdm_ctrl[device_num]);
++ if (ret != 0)
++ goto tdm_start_error;
++
++ dev_set_drvdata(&(ofdev->dev), tdm_ctrl[device_num]);
++
++ pr_info("%s UCC based tdm module installed\n", __FUNCTION__);
++ return 0;
++
++tdm_start_error:
++ tdm_deinit(tdm_ctrl[device_num]);
++tdm_init_error:
++ dma_free_coherent(NULL, 2 * NR_BUFS * SAMPLE_DEPTH *
++ tdm_ctrl[device_num]->cfg_ctrl.active_num_ts,
++ tdm_ctrl[device_num]->tdm_input_data,
++ tdm_ctrl[device_num]->dma_input_addr);
++
++alloc_error:
++ irq_dispose_mapping(tdm_ctrl[device_num]->ut_info->uf_info.irq);
++ iounmap(tdm_ctrl[device_num]->uf_regs);
++
++get_property_error:
++ num_tdm_devices--;
++ kfree(tdm_ctrl[device_num]);
++ ut_info->ucc_busy = 0;
++ return ret;
++}
++
++static int ucc_tdm_remove(struct of_device *ofdev)
++{
++ struct tdm_ctrl *tdm_c;
++ struct ucc_tdm_info *ut_info;
++ u32 ucc_num;
++
++ tdm_c = dev_get_drvdata(&(ofdev->dev));
++ dev_set_drvdata(&(ofdev->dev), NULL);
++ ucc_num = tdm_c->ut_info->uf_info.ucc_num;
++ ut_info = &utdm_info[ucc_num];
++ tdm_stop(tdm_c);
++ tdm_deinit(tdm_c);
++
++ ucc_fast_free(tdm_c->uf_private);
++
++ dma_free_coherent(NULL, 2 * NR_BUFS * SAMPLE_DEPTH *
++ tdm_c->cfg_ctrl.active_num_ts,
++ tdm_c->tdm_input_data,
++ tdm_c->dma_input_addr);
++
++ irq_dispose_mapping(tdm_c->ut_info->uf_info.irq);
++ iounmap(tdm_c->uf_regs);
++
++ num_tdm_devices--;
++ kfree(tdm_c);
++
++ ut_info->ucc_busy = 0;
++
++ pr_info("%s UCC based tdm module uninstalled\n", __FUNCTION__);
++ return 0;
++}
++
++const struct of_device_id ucc_tdm_match[] = {
++ { .type = "tdm", .compatible = "fsl,ucc-tdm", },
++ {},
++};
++
++MODULE_DEVICE_TABLE(of, ucc_tdm_match);
++
++static struct of_platform_driver ucc_tdm_driver = {
++ .name = DRV_NAME,
++ .match_table = ucc_tdm_match,
++ .probe = ucc_tdm_probe,
++ .remove = ucc_tdm_remove,
++ .driver = {
++ .name = DRV_NAME,
++ .owner = THIS_MODULE,
++ },
++};
++
++static int __init ucc_tdm_init(void)
++{
++ u32 i;
++
++ pr_info("ucc_tdm: " DRV_DESC "\n");
++ for (i = 0; i < 8; i++)
++ memcpy(&(utdm_info[i]), &utdm_primary_info,
++ sizeof(utdm_primary_info));
++
++ return of_register_platform_driver(&ucc_tdm_driver);
++}
++
++static void __exit ucc_tdm_exit(void)
++{
++ of_unregister_platform_driver(&ucc_tdm_driver);
++}
++
++module_init(ucc_tdm_init);
++module_exit(ucc_tdm_exit);
++MODULE_AUTHOR("Freescale Semiconductor, Inc");
++MODULE_DESCRIPTION(DRV_DESC);
++MODULE_LICENSE("GPL");
+--- a/drivers/misc/Makefile
++++ b/drivers/misc/Makefile
+@@ -10,6 +10,7 @@ obj-$(CONFIG_INTEL_MID_PTI)	+= pti.o
+ obj-$(CONFIG_ATMEL_PWM)		+= atmel_pwm.o
+ obj-$(CONFIG_ATMEL_SSC)		+= atmel-ssc.o
+ obj-$(CONFIG_ATMEL_TCLIB)	+= atmel_tclib.o
++obj-$(CONFIG_UCC_TDM)		+= ucc_tdm.o
+ obj-$(CONFIG_BMP085)		+= bmp085.o
+ obj-$(CONFIG_BMP085_I2C)	+= bmp085-i2c.o
+ obj-$(CONFIG_BMP085_SPI)	+= bmp085-spi.o
+--- a/drivers/misc/Kconfig
++++ b/drivers/misc/Kconfig
+@@ -210,6 +210,20 @@ config ATMEL_SSC
+ 
+ 	  If unsure, say N.
+ 
++config UCC_TDM
++	tristate "Freescale UCC TDM Driver"
++	depends on QUICC_ENGINE && UCC_FAST
++	default n
++	help
++	 The TDM driver is for UCC based TDM devices for example, TDM device on
++	 MPC832x RDB. Select it to run PowerVoIP on MPC832x RDB board.
++	 The TDM driver can interface with SLIC kind of devices to transmit
++	 and receive TDM samples. The TDM driver receives Time Division
++	 multiplexed samples(for different channels) from the SLIC device,
++	 demutiplexes them and sends them to the upper layers. At the transmit
++	 end the TDM drivers receives samples for different channels, it
++	 multiplexes them and sends them to the SLIC device.
++
+ config ENCLOSURE_SERVICES
+ 	tristate "Enclosure Services"
+ 	default n
+--- a/arch/powerpc/include/asm/ucc_fast.h
++++ b/arch/powerpc/include/asm/ucc_fast.h
+@@ -150,6 +150,10 @@ struct ucc_fast_info {
+ 	enum ucc_fast_rx_decoding_method renc;
+ 	enum ucc_fast_transparent_tcrc tcrc;
+ 	enum ucc_fast_sync_len synl;
++	char *tdm_rx_clk;
++	char *tdm_tx_clk;
++	char *tdm_rx_sync;
++	char *tdm_tx_sync;
+ };
+ 
+ struct ucc_fast_private {
+--- a/arch/powerpc/include/asm/qe.h
++++ b/arch/powerpc/include/asm/qe.h
+@@ -670,6 +670,14 @@ struct ucc_slow_pram {
+ #define UCC_GETH_UCCE_RXF1      0x00000002
+ #define UCC_GETH_UCCE_RXF0      0x00000001
+ 
++/* Transparent UCC Event Register (UCCE) */
++#define UCC_TRANS_UCCE_GRA 0x0080
++#define UCC_TRANS_UCCE_TXE 0x0010
++#define UCC_TRANS_UCCE_RXF 0x0008
++#define UCC_TRANS_UCCE_BSY 0x0004
++#define UCC_TRANS_UCCE_TXB 0x0002
++#define UCC_TRANS_UCCE_RXB 0x0001
++
+ /* UCC Protocol Specific Mode Register (UPSMR), when used for UART */
+ #define UCC_UART_UPSMR_FLC		0x8000
+ #define UCC_UART_UPSMR_SL		0x4000
diff --git a/target/linux/mpc83xx/patches-3.10/200-powerpc-add-rbppc-support.patch b/target/linux/mpc83xx/patches-3.10/200-powerpc-add-rbppc-support.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/patches-3.10/200-powerpc-add-rbppc-support.patch
@@ -0,0 +1,1318 @@
+--- a/arch/powerpc/boot/Makefile
++++ b/arch/powerpc/boot/Makefile
+@@ -89,7 +89,8 @@ src-plat-$(CONFIG_44x) += treeboot-ebony
+ src-plat-$(CONFIG_8xx) += cuboot-8xx.c fixed-head.S ep88xc.c redboot-8xx.c
+ src-plat-$(CONFIG_PPC_MPC52xx) += cuboot-52xx.c
+ src-plat-$(CONFIG_PPC_82xx) += cuboot-pq2.c fixed-head.S ep8248e.c cuboot-824x.c
+-src-plat-$(CONFIG_PPC_83xx) += cuboot-83xx.c fixed-head.S redboot-83xx.c
++src-plat-$(CONFIG_PPC_83xx) += cuboot-83xx.c fixed-head.S redboot-83xx.c \
++				rb600.c rb333.c
+ src-plat-$(CONFIG_FSL_SOC_BOOKE) += cuboot-85xx.c cuboot-85xx-cpm2.c
+ src-plat-$(CONFIG_EMBEDDED6xx) += cuboot-pq2.c cuboot-mpc7448hpc2.c \
+ 					cuboot-c2k.c gamecube-head.S \
+@@ -261,6 +262,8 @@ image-$(CONFIG_MPC834x_ITX)		+= cuImage.
+ image-$(CONFIG_MPC834x_MDS)		+= cuImage.mpc834x_mds
+ image-$(CONFIG_MPC836x_MDS)		+= cuImage.mpc836x_mds
+ image-$(CONFIG_ASP834x)			+= dtbImage.asp834x-redboot
++image-$(CONFIG_RB_PPC)			+= dtbImage.rb600 \
++					   dtbImage.rb333
+ 
+ # Board ports in arch/powerpc/platform/85xx/Kconfig
+ image-$(CONFIG_MPC8540_ADS)		+= cuImage.mpc8540ads
+--- /dev/null
++++ b/arch/powerpc/boot/dts/rb600.dts
+@@ -0,0 +1,283 @@
++/*
++ * RouterBOARD 600 series Device Tree Source
++ *
++ * Copyright 2009 Michael Guntsche <mike@it-loops.com>
++ *
++ * This program is free software; you can redistribute  it and/or modify it
++ * under  the terms of  the GNU General  Public License as published by the
++ * Free Software Foundation;  either version 2 of the  License, or (at your
++ * option) any later version.
++ */
++
++/dts-v1/;
++
++/ {
++	model = "RB600";
++	compatible = "MPC83xx";
++	#address-cells = <1>;
++	#size-cells = <1>;
++
++	aliases {
++		ethernet0 = &enet0;
++		ethernet1 = &enet1;
++		pci0 = &pci0;
++	};
++
++	chosen {
++		bootargs = "console=ttyS0,115200 board=mpc8323 rootfstype=squashfs,yaffs2,jffs2 root=/dev/mtdblock1 boot=1";
++		linux,stdout-path = "/soc8343@e0000000/serial@4500";
++	};
++
++	cpus {
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		PowerPC,8343E@0 {
++			device_type = "cpu";
++			reg = <0x0>;
++			d-cache-line-size = <0x20>;
++			i-cache-line-size = <0x20>;
++			d-cache-size = <0x8000>;
++			i-cache-size = <0x8000>;
++			timebase-frequency = <0x0000000>; // filled by the bootwrapper from the firmware blob
++			clock-frequency = <0x00000000>; // filled by the bootwrapper from the firmware blob
++		};
++	};
++
++	memory {
++		device_type = "memory";
++		reg = <0x0 0x0000000>; // filled by the bootwrapper from the firmware blob
++	};
++
++	cf@f9200000 {
++		lb-timings = <0x5dc 0x3e8 0x1194 0x5dc 0x2af8>;
++		interrupt-at-level = <0x0>;
++		interrupt-parent = <&ipic>;
++		interrupts = <0x16 0x8>;
++		lbc_extra_divider = <0x1>;
++		reg = <0xf9200000 0x200000>;
++		device_type = "rb,cf";
++	};
++
++	cf@f9000000 {
++		lb-timings = <0x5dc 0x3e8 0x1194 0x5dc 0x2af8>;
++		interrupt-at-level = <0x0>;
++		interrupt-parent = <&ipic>;
++		interrupts = <0x14 0x8>;
++		lbc_extra_divider = <0x1>;
++		reg = <0xf9000000 0x200000>;
++		device_type = "rb,cf";
++	};
++
++	flash {
++		reg = <0xff800000 0x20000>;
++	};
++
++	nnand {
++		reg = <0xf0000000 0x1000>;
++	};
++
++	nand {
++		ale = <&gpio 0x6>;
++		cle = <&gpio 0x5>;
++		nce = <&gpio 0x4>;
++		rdy = <&gpio 0x3>;
++		reg = <0xf8000000 0x1000>;
++		device_type = "rb,nand";
++	};
++
++	fancon {
++		interrupt-parent = <&ipic>;
++		interrupts = <0x17 0x8>;
++		sense = <&gpio 0x7>;
++		fan_on = <&gpio 0x9>;
++	};
++
++	pci0: pci@e0008500 {
++		device_type = "pci";
++		compatible = "fsl,mpc8349-pci";
++		reg = <0xe0008500 0x100 0xe0008300 0x8>;
++		#address-cells = <3>;
++		#size-cells = <2>;
++		#interrupt-cells = <1>;
++		ranges = <0x2000000 0x0 0x80000000 0x80000000 0x0 0x20000000 0x1000000 0x0 0x0 0xd0000000 0x0 0x4000000>;
++		bus-range = <0x0 0x0>;
++		interrupt-map = <
++			0x5800 0x0 0x0 0x1 &ipic 0x15 0x8
++			0x6000 0x0 0x0 0x1 &ipic 0x30 0x8
++			0x6000 0x0 0x0 0x2 &ipic 0x11 0x8
++			0x6800 0x0 0x0 0x1 &ipic 0x11 0x8
++			0x6800 0x0 0x0 0x2 &ipic 0x12 0x8
++			0x7000 0x0 0x0 0x1 &ipic 0x12 0x8
++			0x7000 0x0 0x0 0x2 &ipic 0x13 0x8
++			0x7800 0x0 0x0 0x1 &ipic 0x13 0x8
++			0x7800 0x0 0x0 0x2 &ipic 0x30 0x8
++			0x8000 0x0 0x0 0x1 &ipic 0x30 0x8
++			0x8000 0x0 0x0 0x2 &ipic 0x12 0x8
++			0x8000 0x0 0x0 0x3 &ipic 0x11 0x8
++			0x8000 0x0 0x0 0x4 &ipic 0x13 0x8
++			0xa000 0x0 0x0 0x1 &ipic 0x30 0x8
++			0xa000 0x0 0x0 0x2 &ipic 0x11 0x8
++			0xa000 0x0 0x0 0x3 &ipic 0x12 0x8
++			0xa000 0x0 0x0 0x4 &ipic 0x13 0x8
++			0xa800 0x0 0x0 0x1 &ipic 0x11 0x8
++			0xa800 0x0 0x0 0x2 &ipic 0x12 0x8
++			0xa800 0x0 0x0 0x3 &ipic 0x13 0x8
++			0xa800 0x0 0x0 0x4 &ipic 0x30 0x8>;
++		interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
++		interrupt-parent = <&ipic>;
++	};
++
++	soc8343@e0000000 {
++		#address-cells = <1>;
++		#size-cells = <1>;
++		device_type = "soc";
++		compatible = "simple-bus";
++		ranges = <0x0 0xe0000000 0x100000>;
++		reg = <0xe0000000 0x200>;
++		bus-frequency = <0x1>;
++
++		led {
++			user_led = <0x400 0x8>;
++		};
++
++		beeper {
++			reg = <0x500 0x100>;
++		};
++
++		gpio: gpio@0 {
++			reg = <0xc08 0x4>;
++			device-id = <0x0>;
++			compatible = "gpio";
++			device_type = "gpio";
++		};
++
++		dma@82a8 {
++                        #address-cells = <1>;
++                        #size-cells = <1>;
++                        compatible = "fsl,mpc8349-dma", "fsl,elo-dma";
++                        reg = <0x82a8 4>;
++                        ranges = <0 0x8100 0x1a8>;
++                        interrupt-parent = <&ipic>;
++                        interrupts = <71 8>;
++                        cell-index = <0>;
++                        dma-channel@0 {
++                                compatible = "fsl,mpc8349-dma-channel", "fsl,elo-dma-channel";
++                                reg = <0 0x80>;
++                                cell-index = <0>;
++                                interrupt-parent = <&ipic>;
++                                interrupts = <71 8>;
++                        };
++                        dma-channel@80 {
++                                compatible = "fsl,mpc8349-dma-channel", "fsl,elo-dma-channel";
++                                reg = <0x80 0x80>;
++                                cell-index = <1>;
++                                interrupt-parent = <&ipic>;
++                                interrupts = <71 8>;
++                        };
++                        dma-channel@100 {
++                                compatible = "fsl,mpc8349-dma-channel", "fsl,elo-dma-channel";
++                                reg = <0x100 0x80>;
++                                cell-index = <2>;
++                                interrupt-parent = <&ipic>;
++                                interrupts = <71 8>;
++                        };
++                        dma-channel@180 {
++                                compatible = "fsl,mpc8349-dma-channel", "fsl,elo-dma-channel";
++                                reg = <0x180 0x28>;
++                                cell-index = <3>;
++                                interrupt-parent = <&ipic>;
++                                interrupts = <71 8>;
++                        };
++                };
++
++		enet0: ethernet@25000 {
++			#address-cells = <1>;
++			#size-cells = <1>;
++			cell-index = <0>;
++			phy-handle = <&phy0>;
++			tbi-handle = <&tbi0>;
++			interrupt-parent = <&ipic>;
++			interrupts = <0x23 0x8 0x24 0x8 0x25 0x8>;
++			local-mac-address = [00 00 00 00 00 00];
++			reg = <0x25000 0x1000>;
++			ranges = <0x0 0x25000 0x1000>;
++			compatible = "gianfar";
++			model = "TSEC";
++			device_type = "network";
++
++			mdio@520 {
++				#address-cells = <1>;
++				#size-cells = <0>;
++				compatible = "fsl,gianfar-tbi";
++				reg = <0x520 0x20>;
++
++				tbi0: tbi-phy@11 {
++					reg = <0x11>;
++					device_type = "tbi-phy";
++				};
++			};
++		};
++
++		enet1: ethernet@24000 {
++			#address-cells = <1>;
++			#size-cells = <1>;
++			cell-index = <1>;
++			phy-handle = <&phy1>;
++			tbi-handle = <&tbi1>;
++			interrupt-parent = <&ipic>;
++			interrupts = <0x20 0x8 0x21 0x8 0x22 0x8>;
++			local-mac-address = [00 00 00 00 00 00];
++			reg = <0x24000 0x1000>;
++			ranges = <0x0 0x24000 0x1000>;
++			compatible = "gianfar";
++			model = "TSEC";
++			device_type = "network";
++
++			mdio@520 {
++				#size-cells = <0x0>;
++				#address-cells = <0x1>;
++				reg = <0x520 0x20>;
++				compatible = "fsl,gianfar-mdio";
++
++				phy0: ethernet-phy@0 {
++					device_type = "ethernet-phy";
++					reg = <0x0>;
++				};
++
++				phy1: ethernet-phy@1 {
++					device_type = "ethernet-phy";
++					reg = <0x1>;
++				};
++
++				tbi1: tbi-phy@11 {
++					reg = <0x11>;
++					device_type = "tbi-phy";
++				};
++			};
++		};
++
++		ipic: pic@700 {
++			interrupt-controller;
++			#address-cells = <0>;
++			#interrupt-cells = <2>;
++			reg = <0x700 0x100>;
++			device_type = "ipic";
++		};
++
++		serial@4500 {
++			interrupt-parent = <&ipic>;
++			interrupts = <0x9 0x8>;
++			clock-frequency = <0xfe4f840>;
++			reg = <0x4500 0x100>;
++			compatible = "ns16550";
++			device_type = "serial";
++		};
++
++		wdt@200 {
++			reg = <0x200 0x100>;
++			compatible = "mpc83xx_wdt";
++			device_type = "watchdog";
++		};
++	};
++};
+--- /dev/null
++++ b/arch/powerpc/boot/rb600.c
+@@ -0,0 +1,70 @@
++/*
++ * The RouterBOARD platform -- for booting RB600(A) RouterBOARDs.
++ *
++ * Author: Michael Guntsche <mike@it-loops.com>
++ *
++ * Copyright (c) 2009 Michael Guntsche
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License version 2 as published
++ * by the Free Software Foundation.
++ */
++
++#include "ops.h"
++#include "types.h"
++#include "io.h"
++#include "stdio.h"
++#include <libfdt.h>
++
++BSS_STACK(4*1024);
++
++u64 memsize64;
++const void *fw_dtb;
++
++static void rb600_fixups(void)
++{
++	const u32 *reg, *timebase, *clock;
++	int node, size;
++
++	dt_fixup_memory(0, memsize64);
++
++	/* Set the MAC addresses. */
++	node = fdt_path_offset(fw_dtb, "/soc8343@e0000000/ethernet@24000");
++	reg = fdt_getprop(fw_dtb, node, "mac-address", &size);
++	dt_fixup_mac_address_by_alias("ethernet1", (const u8 *)reg);
++
++	node = fdt_path_offset(fw_dtb, "/soc8343@e0000000/ethernet@25000");
++	reg = fdt_getprop(fw_dtb, node, "mac-address", &size);
++	dt_fixup_mac_address_by_alias("ethernet0", (const u8 *)reg);
++
++	/* Find the CPU timebase and clock frequencies. */
++	node = fdt_node_offset_by_prop_value(fw_dtb, -1, "device_type", "cpu", sizeof("cpu"));
++	timebase = fdt_getprop(fw_dtb, node, "timebase-frequency", &size);
++	clock = fdt_getprop(fw_dtb, node, "clock-frequency", &size);
++	dt_fixup_cpu_clocks(*clock, *timebase, 0);
++
++}
++
++void platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
++		   unsigned long r6, unsigned long r7)
++{
++	const u32 *reg;
++	int node, size;
++
++	fw_dtb = (const void *)r3;
++
++	/* Find the memory range. */
++	node = fdt_node_offset_by_prop_value(fw_dtb, -1, "device_type", "memory", sizeof("memory"));
++	reg = fdt_getprop(fw_dtb, node, "reg", &size);
++	memsize64 = reg[1];
++
++	/* Now we have the memory size; initialize the heap. */
++	simple_alloc_init(_end, memsize64 - (unsigned long)_end, 32, 64);
++
++	/* Prepare the device tree and find the console. */
++	fdt_init(_dtb_start);
++	serial_console_init();
++
++	/* Remaining fixups... */
++	platform_ops.fixups = rb600_fixups;
++}
+--- a/arch/powerpc/boot/wrapper
++++ b/arch/powerpc/boot/wrapper
+@@ -217,7 +217,7 @@ ps3)
+     make_space=n
+     pie=
+     ;;
+-ep88xc|ep405|ep8248e)
++ep88xc|ep405|ep8248e|rb600|rb333)
+     platformo="$object/fixed-head.o $object/$platform.o"
+     binary=y
+     ;;
+--- a/arch/powerpc/platforms/83xx/Kconfig
++++ b/arch/powerpc/platforms/83xx/Kconfig
+@@ -38,6 +38,15 @@ config MPC832x_RDB
+ 	help
+ 	  This option enables support for the MPC8323 RDB board.
+ 
++config RB_PPC
++	bool "MikroTik RouterBOARD 333/600 series"
++	select DEFAULT_UIMAGE
++	select QUICC_ENGINE
++	select PPC_MPC832x
++	select PPC_MPC834x
++	help
++	  This option enables support for MikroTik RouterBOARD 333/600 series boards.
++
+ config MPC834x_MDS
+ 	bool "Freescale MPC834x MDS"
+ 	select DEFAULT_UIMAGE
+--- /dev/null
++++ b/arch/powerpc/boot/dts/rb333.dts
+@@ -0,0 +1,426 @@
++
++/*
++ * RouterBOARD 333 series Device Tree Source
++ *
++ * Copyright 2010 Alexandros C. Couloumbis <alex@ozo.com>
++ * Copyright 2009 Michael Guntsche <mike@it-loops.com>
++ *
++ * This program is free software; you can redistribute  it and/or modify it
++ * under  the terms of  the GNU General  Public License as published by the
++ * Free Software Foundation;  either version 2 of the  License, or (at your
++ * option) any later version.
++ *
++ * Warning (reg_format): "reg" property in /qe@e0100000/muram@10000/data-only@0 has invalid length (8 bytes) (#address-cells == 2, #size-cells == 1)
++ * Warning (ranges_format): "ranges" property in /qe@e0100000/muram@10000 has invalid length (12 bytes) (parent #address-cells == 1, child #address-cells == 2, #size-cells == 1)
++ * Warning (avoid_default_addr_size): Relying on default #address-cells value for /qe@e0100000/muram@10000/data-only@0
++ * Warning (avoid_default_addr_size): Relying on default #size-cells value for /qe@e0100000/muram@10000/data-only@0
++ * Warning (obsolete_chosen_interrupt_controller): /chosen has obsolete "interrupt-controller" property
++ *
++ */
++
++
++/dts-v1/;
++
++/ {
++	model = "RB333";
++	compatible = "MPC83xx";
++	#size-cells = <1>;
++	#address-cells = <1>;
++
++	aliases {
++		ethernet0 = &enet0;
++		ethernet1 = &enet1;
++		ethernet2 = &enet2;
++		pci0 = &pci0;
++	};
++
++	chosen {
++		bootargs = "console=ttyS0,115200 board=mpc8323 rootfstype=squashfs,yaffs2,jffs2 root=/dev/mtdblock1 boot=1";
++		// linux,platform = <0x8062>;
++		// linux,initrd = <0x488000 0x0>;
++		linux,stdout-path = "/soc8323@e0000000/serial@4500";
++		// interrupt-controller = <&ipic>;
++	};
++
++	cpus {
++		#cpus = <1>;
++		#size-cells = <0>;
++		#address-cells = <1>;
++
++		PowerPC,8323E@0 {
++			device_type = "cpu";
++			reg = <0x0>;
++			i-cache-size = <0x4000>;
++			d-cache-size = <0x4000>;
++			i-cache-line-size = <0x20>;
++			d-cache-line-size = <0x20>;
++			// clock-frequency = <0x13de3650>;
++			// timebase-frequency = <0x1fc9f08>;
++			timebase-frequency = <0x0000000>; // filled by the bootwrapper from the firmware blob
++			clock-frequency = <0x00000000>; // filled by the bootwrapper from the firmware blob
++			32-bit;
++		};
++	};
++
++	memory {
++		device_type = "memory";
++		reg = <0x0 0x4000000>;
++		// reg = <0x0 0x0000000>; // filled by the bootwrapper from the firmware blob
++	};
++
++	flash {
++		reg = <0xfe000000 0x20000>;
++	};
++
++	nand {
++		ale = <&gpio2 0x3>;
++		cle = <&gpio2 0x2>;
++		nce = <&gpio2 0x1>;
++		rdy = <&gpio2 0x0>;
++		reg = <0xf8000000 0x1000>;
++		device_type = "rb,nand";
++	};
++
++	nnand {
++		reg = <0xf0000000 0x1000>;
++	};
++
++	voltage {
++		voltage_gpio = <&gpio3 0x11>;
++	};
++
++	fancon {
++		interrupt-parent = <&ipic>;
++		interrupts = <0x14 0x8>;
++		fan_on = <&gpio0 0x10>;
++	};
++
++	soc8323@e0000000 {
++		#address-cells = <1>;
++		#size-cells = <1>;
++		device_type = "soc";
++		compatible = "simple-bus";
++		ranges = <0x0 0xe0000000 0x00100000>;
++		reg = <0xe0000000 0x00000200>;
++		bus-frequency = <1>;
++
++		wdt@200 {
++			device_type = "watchdog";
++			compatible = "mpc83xx_wdt";
++			reg = <0x200 0x100>;
++		};
++
++		ipic:pic@700 {
++			interrupt-controller;
++			#address-cells = <0>;
++			#interrupt-cells = <2>;
++			reg = <0x700 0x100>;
++			device_type = "ipic";
++		};
++
++		par_io@1400 {
++			num-ports = <4>;
++			device_type = "par_io";
++			reg = <0x1400 0x100>;
++
++			ucc2pio: ucc_pin@02 {
++				pio-map = <
++			/* port  pin  dir  open_drain  assignment  has_irq */
++					3  4 3 0 2 0
++					3  5 1 0 2 0
++					0 18 1 0 1 0
++					0 19 1 0 1 0
++					0 20 1 0 1 0
++					0 21 1 0 1 0
++					0 30 1 0 1 0
++					3  6 2 0 1 0
++					0 29 2 0 1 0
++					0 31 2 0 1 0
++					0 22 2 0 1 0
++					0 23 2 0 1 0
++					0 24 2 0 1 0
++					0 25 2 0 1 0
++					0 28 2 0 1 0
++					0 26 2 0 1 0
++					3 31 2 0 1 0>;
++			};
++
++			ucc3pio: ucc_pin@03 {
++				pio-map = <
++			/* port  pin  dir  open_drain  assignment  has_irq */
++					1  0 1 0 1 0
++					1  1 1 0 1 0
++					1  2 1 0 1 0
++					1  3 1 0 1 0
++					1 12 1 0 1 0
++					3 24 2 0 1 0
++					1 11 2 0 1 0
++					1 13 2 0 1 0
++					1  4 2 0 1 0
++					1  5 2 0 1 0
++					1  6 2 0 1 0
++					1  7 2 0 1 0
++					1 10 2 0 1 0
++					1  8 2 0 1 0
++					3 29 2 0 1 0>;
++			};
++
++			ucc4pio: ucc_pin@04 {
++				pio-map = <
++			/* port  pin  dir  open_drain  assignment  has_irq */
++					1 18 1 0 1 0
++					1 19 1 0 1 0
++					1 20 1 0 1 0
++					1 21 1 0 1 0
++					1 30 1 0 1 0
++					3 20 2 0 1 0
++					1 30 2 0 1 0
++					1 31 2 0 1 0
++					1 22 2 0 1 0
++					1 23 2 0 1 0
++					1 24 2 0 1 0
++					1 25 2 0 1 0
++					1 28 2 0 1 0
++					1 26 2 0 1 0
++					3 21 2 0 1 0>;
++			};
++		};
++
++		serial0: serial@4500 {
++			cell-index = <0>;
++			device_type = "serial";
++			compatible = "fsl,ns16550", "ns16550";
++			reg = <0x4500 0x100>;
++			clock-frequency = <0x7f27c20>;
++			interrupts = <9 0x8>;
++			interrupt-parent = <&ipic>;
++		};
++
++		dma@82a8 {
++			#address-cells = <1>;
++			#size-cells = <1>;
++			compatible = "fsl,mpc8323-dma", "fsl,elo-dma";
++			reg = <0x82a8 4>;
++			ranges = <0 0x8100 0x1a8>;
++			interrupt-parent = <&ipic>;
++			interrupts = <71 8>;
++			cell-index = <0>;
++			dma-channel@0 {
++				compatible = "fsl,mpc8323-dma-channel", "fsl,elo-dma-channel";
++				reg = <0 0x80>;
++				cell-index = <0>;
++				interrupt-parent = <&ipic>;
++				interrupts = <71 8>;
++			};
++			dma-channel@80 {
++				compatible = "fsl,mpc8323-dma-channel", "fsl,elo-dma-channel";
++				reg = <0x80 0x80>;
++				cell-index = <1>;
++				interrupt-parent = <&ipic>;
++				interrupts = <71 8>;
++			};
++			dma-channel@100 {
++				compatible = "fsl,mpc8323-dma-channel", "fsl,elo-dma-channel";
++				reg = <0x100 0x80>;
++				cell-index = <2>;
++				interrupt-parent = <&ipic>;
++				interrupts = <71 8>;
++			};
++			dma-channel@180 {
++				compatible = "fsl,mpc8323-dma-channel", "fsl,elo-dma-channel";
++				reg = <0x180 0x28>;
++				cell-index = <3>;
++				interrupt-parent = <&ipic>;
++				interrupts = <71 8>;
++			};
++		};
++
++		beeper {
++			gpio = <&gpio3 0x12>;
++			reg = <0x500 0x100>;
++			interrupt-parent = <&ipic>;
++			interrupts = <0x48 0x8>;
++		};
++
++		gpio3: gpio@3 {
++			reg = <0x144c 0x4>;
++			device-id = <0x3>;
++			compatible = "qe_gpio";
++			device_type = "gpio";
++		};
++
++		gpio2: gpio@2 {
++			reg = <0x1434 0x4>;
++			device-id = <0x2>;
++			compatible = "qe_gpio";
++			device_type = "gpio";
++		};
++
++		gpio0: gpio@0 {
++			reg = <0x1404 0x4>;
++			device-id = <0x0>;
++			compatible = "qe_gpio";
++			device_type = "gpio";
++		};
++	};
++
++	pci0: pci@e0008500 {
++		device_type = "pci";
++		// compatible = "83xx";
++		compatible = "fsl,mpc8349-pci";
++		reg = <0xe0008500 0x100 0xe0008300 0x8>;
++		#address-cells = <3>;
++		#size-cells = <2>;
++		#interrupt-cells = <1>;
++		// clock-frequency = <0>;
++		ranges = <0x2000000 0x0 0x80000000 0x80000000 0x0 0x20000000 0x1000000 0x0 0x0 0xd0000000 0x0 0x4000000>;
++		bus-range = <0x0 0x0>;
++		interrupt-map = <
++			/* IDSEL 0x10 AD16 miniPCI slot 0 */
++			0x8000 0x0 0x0 0x1 &ipic 0x11 0x8
++			0x8000 0x0 0x0 0x2 &ipic 0x12 0x8
++
++			/* IDSEL 0x11 AD17 miniPCI slot 1 */
++			0x8800 0x0 0x0 0x1 &ipic 0x12 0x8
++			0x8800 0x0 0x0 0x2 &ipic 0x13 0x8
++
++			/* IDSEL 0x12 AD18  miniPCI slot 2 */
++			0x9000 0x0 0x0 0x1 &ipic 0x13 0x8
++			0x9000 0x0 0x0 0x2 &ipic 0x11 0x8>;
++
++		interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
++		interrupt-parent = <&ipic>;
++		// interrupts = <66 0x8>;
++	};
++
++	qe@e0100000 {
++		reg = <0xe0100000 0x480>;
++		ranges = <0x0 0xe0100000 0x100000>;
++		model = "QE";
++		device_type = "qe";
++		compatible = "fsl,qe";
++		#size-cells = <1>;
++		#address-cells = <1>;
++		brg-frequency = <0>;
++                bus-frequency = <0>;
++                // bus-frequency = <198000000>;
++                fsl,qe-num-riscs = <1>;
++                fsl,qe-num-snums = <28>;
++
++		qeic: qeic@80 {
++			interrupt-controller;
++			compatible = "fsl,qe-ic";
++			big-endian;
++			built-in;
++			reg = <0x80 0x80>;
++			#interrupt-cells = <1>;
++			#address-cells = <0>;
++			device_type = "qeic";
++			interrupts = <0x20 0x8 0x21 0x8>;
++			interrupt-parent = <&ipic>;
++		};
++
++		mdio@2120 {
++			compatible = "ucc_geth_phy";
++			device_type = "mdio";
++			reg = <0x3120 0x18>;
++			#size-cells = <0>;
++			#address-cells = <1>;
++
++			phy3: ethernet-phy@03 {
++				// interface = <0x3>;
++				device_type = "ethernet-phy";
++				reg = <0x3>;
++			};
++
++			phy2: ethernet-phy@02 {
++				// interface = <0x3>;
++				device_type = "ethernet-phy";
++				reg = <0x2>;
++			};
++
++			phy1: ethernet-phy@01 {
++				// interface = <0x3>;
++				device_type = "ethernet-phy";
++				reg = <0x1>;
++			};
++		};
++
++		enet0: ucc@2200 {
++			tx-clock = <0x1a>;
++			rx-clock = <0x1f>;
++			local-mac-address = [00 00 00 00 00 00];
++			interrupt-parent = <&qeic>;
++			interrupts = <0x22>;
++			reg = <0x2200 0x200>;
++			device-id = <0x3>;
++			model = "UCC";
++			compatible = "ucc_geth";
++			device_type = "network";
++			phy-handle = <&phy2>;
++			pio-handle = <&ucc3pio>;
++		};
++
++		enet1: ucc@3200 {
++			tx-clock = <0x22>;
++			rx-clock = <0x20>;
++			local-mac-address = [00 00 00 00 00 00];
++			interrupt-parent = <&qeic>;
++			interrupts = <0x23>;
++			reg = <0x3200 0x200>;
++			device-id = <0x4>;
++			model = "UCC";
++			compatible = "ucc_geth";
++			device_type = "network";
++			phy-handle = <&phy3>;
++			pio-handle = <&ucc4pio>;
++		};
++
++		enet2: ucc@3000 {
++			tx-clock = <0x18>;
++			rx-clock = <0x17>;
++			local-mac-address = [00 00 00 00 00 00];
++			interrupt-parent = <&qeic>;
++			interrupts = <0x21>;
++			reg = <0x3000 0x200>;
++			device-id = <0x2>;
++			model = "UCC";
++			compatible = "ucc_geth";
++			device_type = "network";
++			phy-handle = <&phy1>;
++			pio-handle = <&ucc2pio>;
++		};
++
++		spi@500 {
++			mode = "cpu";
++			interrupt-parent = <&qeic>;
++			interrupts = <0x1>;
++			reg = <0x500 0x40>;
++			compatible = "fsl,spi";
++			device_type = "spi";
++		};
++
++		spi@4c0 {
++			mode = "cpu";
++			interrupt-parent = <&qeic>;
++			interrupts = <0x2>;
++			reg = <0x4c0 0x40>;
++			compatible = "fsl,spi";
++			device_type = "spi";
++		};
++
++		muram@10000 {
++			#address-cells = <1>;
++			#size-cells = <1>;
++			compatible = "fsl,qe-muram", "fsl,cpm-muram";
++			ranges = <0x0 0x10000 0x4000>;
++			device_type = "muram";
++
++			data-only@0 {
++				compatible = "fsl,qe-muram-data",
++					"fsl,cpm-muram-data";
++				reg = <0x0 0x4000>;
++			};
++		};
++	};
++};
+--- /dev/null
++++ b/arch/powerpc/boot/rb333.c
+@@ -0,0 +1,86 @@
++/*
++ * The RouterBOARD platform -- for booting RB333 RouterBOARDs.
++ *
++ * Author: Alexandros C. Couloumbis  <alex@ozo.com>
++ * Author: Michael Guntsche <mike@it-loops.com>
++ *
++ * Copyright (c) 2010 Alexandros C. Couloumbis
++ * Copyright (c) 2009 Michael Guntsche
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License version 2 as published
++ * by the Free Software Foundation.
++ */
++
++#include "ops.h"
++#include "types.h"
++#include "io.h"
++#include "stdio.h"
++#include <libfdt.h>
++
++BSS_STACK(4*1024);
++
++u64 memsize64;
++const void *fw_dtb;
++
++static void rb333_fixups(void)
++{
++	const u32 *reg, *timebase, *clock;
++	int node, size;
++	void *chosen;
++	const char* bootargs;
++
++	dt_fixup_memory(0, memsize64);
++
++	/* Find the CPU timebase and clock frequencies. */
++	node = fdt_node_offset_by_prop_value(fw_dtb, -1, "device_type", "cpu", sizeof("cpu"));
++	timebase = fdt_getprop(fw_dtb, node, "timebase-frequency", &size);
++	clock = fdt_getprop(fw_dtb, node, "clock-frequency", &size);
++	dt_fixup_cpu_clocks(*clock, *timebase, 0);
++
++	/* Set the MAC addresses. */
++	node = fdt_path_offset(fw_dtb, "/qe@e0100000/ucc@2200");
++	reg = fdt_getprop(fw_dtb, node, "mac-address", &size);
++	dt_fixup_mac_address_by_alias("ethernet0", (const u8 *)reg);
++
++	node = fdt_path_offset(fw_dtb, "/qe@e0100000/ucc@3200");
++	reg = fdt_getprop(fw_dtb, node, "mac-address", &size);
++	dt_fixup_mac_address_by_alias("ethernet1", (const u8 *)reg);
++
++	node = fdt_path_offset(fw_dtb, "/qe@e0100000/ucc@3000");
++	reg = fdt_getprop(fw_dtb, node, "mac-address", &size);
++	dt_fixup_mac_address_by_alias("ethernet2", (const u8 *)reg);
++
++	/* Fixup chosen
++	 * The bootloader reads the kernelparm segment and adds the content to
++	 * bootargs. This is needed to specify root and other boot flags.
++	 */
++	chosen = finddevice("/chosen");
++	node = fdt_path_offset(fw_dtb, "/chosen");
++	bootargs = fdt_getprop(fw_dtb, node, "bootargs", &size);
++	setprop_str(chosen, "bootargs", bootargs);
++}
++
++void platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
++		   unsigned long r6, unsigned long r7)
++{
++	const u32 *reg;
++	int node, size;
++
++	fw_dtb = (const void *)r3;
++
++	/* Find the memory range. */
++	node = fdt_node_offset_by_prop_value(fw_dtb, -1, "device_type", "memory", sizeof("memory"));
++	reg = fdt_getprop(fw_dtb, node, "reg", &size);
++	memsize64 = reg[1];
++
++	/* Now we have the memory size; initialize the heap. */
++	simple_alloc_init(_end, memsize64 - (unsigned long)_end, 32, 64);
++
++	/* Prepare the device tree and find the console. */
++	fdt_init(_dtb_start);
++	serial_console_init();
++
++	/* Remaining fixups... */
++	platform_ops.fixups = rb333_fixups;
++}
+--- /dev/null
++++ b/arch/powerpc/platforms/83xx/rbppc.c
+@@ -0,0 +1,388 @@
++/*
++ * Copyright (C) 2010 Alexandros C. Couloumbis <alex@ozo.com>
++ * Copyright (C) 2008-2009 Noah Fontes <nfontes@transtruct.org>
++ * Copyright (C) 2009 Michael Guntsche <mike@it-loops.com>
++ * Copyright (C) Mikrotik 2007
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License as published by the
++ * Free Software Foundation; either version 2 of the License, or (at your
++ * option) any later version.
++ */
++
++#include <linux/delay.h>
++#include <linux/root_dev.h>
++#include <linux/initrd.h>
++#include <linux/interrupt.h>
++#include <linux/of_platform.h>
++#include <linux/of_device.h>
++#include <linux/of_platform.h>
++#include <linux/pci.h>
++#include <asm/time.h>
++#include <asm/ipic.h>
++#include <asm/udbg.h>
++#include <asm/qe.h>
++#include <asm/qe_ic.h>
++#include <sysdev/fsl_soc.h>
++#include <sysdev/fsl_pci.h>
++#include "mpc83xx.h"
++
++#define SYSCTL		0x100
++#define SICRL		0x014
++
++#define GTCFR2		0x04
++#define GTMDR4		0x22
++#define GTRFR4		0x26
++#define GTCNR4		0x2e
++#define GTVER4		0x36
++#define GTPSR4		0x3e
++
++#define GTCFR_BCM	0x40
++#define GTCFR_STP4	0x20
++#define GTCFR_RST4	0x10
++#define GTCFR_STP3	0x02
++#define GTCFR_RST3	0x01
++
++#define GTMDR_ORI	0x10
++#define GTMDR_FRR	0x08
++#define GTMDR_ICLK16	0x04
++
++extern int par_io_data_set(u8 port, u8 pin, u8 val);
++extern int par_io_config_pin(u8 port, u8 pin, int dir, int open_drain,
++			     int assignment, int has_irq);
++
++static unsigned timer_freq;
++static void *gtm;
++
++static int beeper_irq;
++static unsigned beeper_gpio_pin[2];
++
++int rb333model = 0;
++
++irqreturn_t rbppc_timer_irq(int irq, void *ptr)
++{
++	static int toggle = 0;
++
++	par_io_data_set(beeper_gpio_pin[0], beeper_gpio_pin[1], toggle);
++	toggle = !toggle;
++
++	/* ack interrupt */
++	out_be16(gtm + GTVER4, 3);
++
++	return IRQ_HANDLED;
++}
++
++void rbppc_beep(unsigned freq)
++{
++	unsigned gtmdr;
++
++	if (freq > 5000) freq = 5000;
++
++	if (!gtm)
++		return;
++	if (!freq) {
++		out_8(gtm + GTCFR2, GTCFR_STP4 | GTCFR_STP3);
++		return;
++	}
++
++	out_8(gtm + GTCFR2, GTCFR_RST4 | GTCFR_STP3);
++	out_be16(gtm + GTPSR4, 255);
++	gtmdr = GTMDR_FRR | GTMDR_ICLK16;
++	if (beeper_irq != NO_IRQ) gtmdr |= GTMDR_ORI;
++	out_be16(gtm + GTMDR4, gtmdr);
++	out_be16(gtm + GTVER4, 3);
++
++	out_be16(gtm + GTRFR4, timer_freq / 16 / 256 / freq / 2);
++	out_be16(gtm + GTCNR4, 0);
++}
++EXPORT_SYMBOL(rbppc_beep);
++
++static void __init rbppc_setup_arch(void)
++{
++	struct device_node *np;
++
++	np = of_find_node_by_type(NULL, "cpu");
++	if (np) {
++		const unsigned *fp = of_get_property(np, "clock-frequency", NULL);
++		loops_per_jiffy = fp ? *fp / HZ : 0;
++
++		of_node_put(np);
++	}
++
++	np = of_find_node_by_name(NULL, "serial");
++	if (np) {
++		timer_freq =
++		    *(unsigned *) of_get_property(np, "clock-frequency", NULL);
++		of_node_put(np);
++	}
++
++#ifdef CONFIG_PCI
++	np = of_find_node_by_type(NULL, "pci");
++	if (np) {
++		mpc83xx_add_bridge(np);
++	}
++#endif
++
++if (rb333model) {
++
++#ifdef CONFIG_QUICC_ENGINE
++        qe_reset();
++
++        if ((np = of_find_node_by_name(NULL, "par_io")) != NULL) {
++                par_io_init(np);
++                of_node_put(np);
++
++                for (np = NULL; (np = of_find_node_by_name(np, "ucc")) != NULL;)
++                        par_io_of_config(np);
++        }
++#endif
++
++}  /* RB333 */
++
++}
++
++void __init rbppc_init_IRQ(void)
++{
++	struct device_node *np;
++
++	np = of_find_node_by_type(NULL, "ipic");
++	if (np) {
++		ipic_init(np, 0);
++		ipic_set_default_priority();
++		of_node_put(np);
++	}
++
++if (rb333model) {
++
++#ifdef CONFIG_QUICC_ENGINE
++        np = of_find_compatible_node(NULL, NULL, "fsl,qe-ic");
++        if (!np) {
++                np = of_find_node_by_type(NULL, "qeic");
++                if (!np)
++                        return;
++        }
++        qe_ic_init(np, 0, qe_ic_cascade_low_ipic, qe_ic_cascade_high_ipic);
++        of_node_put(np);
++#endif                          /* CONFIG_QUICC_ENGINE */
++
++}  /* RB333 */
++
++}
++
++static int __init rbppc_probe(void)
++{
++	char *model;
++
++	model = of_get_flat_dt_prop(of_get_flat_dt_root(), "model", NULL);
++
++	if (!model)
++		return 0;
++
++	if (strcmp(model, "RB333") == 0) {
++		rb333model = 1;
++		return 1;
++	}
++
++	if (strcmp(model, "RB600") == 0)
++		return 1;
++
++	return 0;
++}
++
++static void __init rbppc_beeper_init(struct device_node *beeper)
++{
++	struct resource res;
++	struct device_node *gpio;
++	const unsigned *pin;
++	const unsigned *gpio_id;
++
++	if (of_address_to_resource(beeper, 0, &res)) {
++		printk(KERN_ERR "rbppc_beeper_init(%s): Beeper error: No region specified\n", beeper->full_name);
++		return;
++	}
++
++	pin = of_get_property(beeper, "gpio", NULL);
++	if (pin) {
++		gpio = of_find_node_by_phandle(pin[0]);
++
++		if (!gpio) {
++			printk(KERN_ERR "rbppc_beeper_init(%s): Beeper error: GPIO handle %x not found\n", beeper->full_name, pin[0]);
++			return;
++		}
++
++		gpio_id = of_get_property(gpio, "device-id", NULL);
++		if (!gpio_id) {
++			printk(KERN_ERR "rbppc_beeper_init(%s): Beeper error: No device-id specified in GPIO\n", beeper->full_name);
++			return;
++		}
++
++		beeper_gpio_pin[0] = *gpio_id;
++		beeper_gpio_pin[1] = pin[1];
++
++		par_io_config_pin(*gpio_id, pin[1], 1, 0, 0, 0);
++	} else {
++		void *sysctl;
++
++		sysctl = ioremap_nocache(get_immrbase() + SYSCTL, 0x100);
++		out_be32(sysctl + SICRL,
++			 in_be32(sysctl + SICRL) | (1 << (31 - 19)));
++		iounmap(sysctl);
++	}
++
++	gtm = ioremap_nocache(res.start, res.end - res.start + 1);
++
++	beeper_irq = irq_of_parse_and_map(beeper, 0);
++	if (beeper_irq != NO_IRQ) {
++		int e = request_irq(beeper_irq, rbppc_timer_irq, 0, "beeper", NULL);
++		if (e) {
++			printk(KERN_ERR "rbppc_beeper_init(%s): Request of beeper irq failed!\n", beeper->full_name);
++		}
++	}
++}
++
++#define SBIT(x) (0x80000000 >> (x))
++#define DBIT(x, y) ((y) << (32 - (((x % 16) + 1) * 2)))
++
++#define GPIO_DIR_RB333(x) ((x) + (0x1408 >> 2))
++#define GPIO_DATA_RB333(x) ((x) + (0x1404 >> 2))
++
++#define SICRL_RB600(x) ((x) + (0x114 >> 2))
++#define GPIO_DIR_RB600(x) ((x) + (0xc00 >> 2))
++#define GPIO_DATA_RB600(x) ((x) + (0xc08 >> 2))
++
++static void rbppc_restart(char *cmd)
++{
++	__be32 __iomem *reg;
++	unsigned rb_model;
++	struct device_node *root;
++	unsigned int size;
++
++	root = of_find_node_by_path("/");
++	if (root) {
++		const char *prop = (char *) of_get_property(root, "model", &size);
++		rb_model = prop[sizeof("RB") - 1] - '0';
++		of_node_put(root);
++		switch (rb_model) {
++		case 3:
++			reg = ioremap(get_immrbase(), 0x2000);
++			local_irq_disable();
++			out_be32(GPIO_DIR_RB333(reg),
++			(in_be32(GPIO_DIR_RB333(reg)) & ~DBIT(4, 3)) | DBIT(4, 1));
++			out_be32(GPIO_DATA_RB333(reg), in_be32(GPIO_DATA_RB333(reg)) & ~SBIT(4));
++			break;
++		case 6:
++			reg = ioremap(get_immrbase(), 0x1000);
++			local_irq_disable();
++			out_be32(SICRL_RB600(reg), in_be32(SICRL_RB600(reg)) & ~0x00800000);
++			out_be32(GPIO_DIR_RB600(reg), in_be32(GPIO_DIR_RB600(reg)) | SBIT(2));
++			out_be32(GPIO_DATA_RB600(reg), in_be32(GPIO_DATA_RB600(reg)) & ~SBIT(2));
++			break;
++		default:
++			mpc83xx_restart(cmd);
++			break;
++		}
++	}
++	else mpc83xx_restart(cmd);
++
++	for (;;) ;
++}
++
++static void rbppc_halt(void)
++{
++	while (1);
++}
++
++static struct of_device_id rbppc_ids[] = {
++	{ .type = "soc", },
++	{ .compatible = "soc", },
++	{ .compatible = "simple-bus", },
++	{ .type = "qe", },
++	{ .compatible = "fsl,qe", },
++	{ .compatible = "gianfar", },
++	{ },
++};
++
++static int __init rbppc_declare_of_platform_devices(void)
++{
++	struct device_node *np;
++	unsigned idx;
++
++	of_platform_bus_probe(NULL, rbppc_ids, NULL);
++
++	np = of_find_node_by_type(NULL, "mdio");
++	if (np) {
++		unsigned len;
++		unsigned *res;
++		const unsigned *eres;
++		struct device_node *ep;
++
++		ep = of_find_compatible_node(NULL, "network", "ucc_geth");
++		if (ep) {
++			eres = of_get_property(ep, "reg", &len);
++			res = (unsigned *) of_get_property(np, "reg", &len);
++			if (res && eres) {
++				res[0] = eres[0] + 0x120;
++			}
++		}
++	}
++
++	np = of_find_node_by_name(NULL, "nand");
++	if (np) {
++		of_platform_device_create(np, "nand", NULL);
++	}
++
++	idx = 0;
++	for_each_node_by_type(np, "rb,cf") {
++		char dev_name[12];
++		snprintf(dev_name, sizeof(dev_name), "cf.%u", idx);
++		of_platform_device_create(np, dev_name, NULL);
++		++idx;
++	}
++
++	np = of_find_node_by_name(NULL, "beeper");
++	if (np) {
++		rbppc_beeper_init(np);
++	}
++
++	return 0;
++}
++machine_device_initcall(rb600, rbppc_declare_of_platform_devices);
++
++define_machine(rb600) {
++	.name 				= "MikroTik RouterBOARD 333/600 series",
++	.probe 				= rbppc_probe,
++	.setup_arch 			= rbppc_setup_arch,
++	.init_IRQ 			= rbppc_init_IRQ,
++	.get_irq 			= ipic_get_irq,
++	.restart 			= rbppc_restart,
++	.halt				= rbppc_halt,
++	.time_init 			= mpc83xx_time_init,
++	.calibrate_decr			= generic_calibrate_decr,
++};
++
++static void fixup_pcibridge(struct pci_dev *dev)
++{
++	if ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
++		/* let the kernel itself set right memory windows */
++		pci_write_config_word(dev, PCI_MEMORY_BASE, 0);
++		pci_write_config_word(dev, PCI_MEMORY_LIMIT, 0);
++		pci_write_config_word(dev, PCI_PREF_MEMORY_BASE, 0);
++		pci_write_config_word(dev, PCI_PREF_MEMORY_LIMIT, 0);
++		pci_write_config_byte(dev, PCI_IO_BASE, 0);
++		pci_write_config_byte(dev, PCI_IO_LIMIT, 4 << 4);
++
++		pci_write_config_byte(
++			dev, PCI_COMMAND,
++			PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY | PCI_COMMAND_IO);
++		pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 8);
++	}
++}
++
++
++static void fixup_rb604(struct pci_dev *dev)
++{
++	pci_write_config_byte(dev, 0xC0, 0x01);
++}
++
++DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, fixup_pcibridge)
++DECLARE_PCI_FIXUP_HEADER(0x3388, 0x0021, fixup_rb604)
diff --git a/target/linux/mpc83xx/patches-3.10/201-powerpc-add-rb_iomap.patch b/target/linux/mpc83xx/patches-3.10/201-powerpc-add-rb_iomap.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/patches-3.10/201-powerpc-add-rb_iomap.patch
@@ -0,0 +1,263 @@
+--- a/arch/powerpc/kernel/Makefile
++++ b/arch/powerpc/kernel/Makefile
+@@ -117,9 +117,11 @@ obj-$(CONFIG_FTRACE_SYSCALLS)	+= ftrace.
+ 
+ obj-$(CONFIG_8XX_MINIMAL_FPEMU) += softemu8xx.o
+ 
++ifneq ($(CONFIG_RB_IOMAP),y)
+ ifneq ($(CONFIG_PPC_INDIRECT_IO),y)
+ obj-y				+= iomap.o
+ endif
++endif
+ 
+ obj64-$(CONFIG_PPC_TRANSACTIONAL_MEM)	+= tm.o
+ 
+--- a/arch/powerpc/platforms/83xx/Makefile
++++ b/arch/powerpc/platforms/83xx/Makefile
+@@ -7,6 +7,7 @@ obj-$(CONFIG_MCU_MPC8349EMITX)	+= mcu_mp
+ obj-$(CONFIG_MPC830x_RDB)	+= mpc830x_rdb.o
+ obj-$(CONFIG_MPC831x_RDB)	+= mpc831x_rdb.o
+ obj-$(CONFIG_MPC832x_RDB)	+= mpc832x_rdb.o
++obj-$(CONFIG_RB_PPC)		+= rbppc.o
+ obj-$(CONFIG_MPC834x_MDS)	+= mpc834x_mds.o
+ obj-$(CONFIG_MPC834x_ITX)	+= mpc834x_itx.o
+ obj-$(CONFIG_MPC836x_MDS)	+= mpc836x_mds.o
+--- a/arch/powerpc/platforms/Kconfig
++++ b/arch/powerpc/platforms/Kconfig
+@@ -191,6 +191,10 @@ config PPC_INDIRECT_MMIO
+ config PPC_IO_WORKAROUNDS
+ 	bool
+ 
++config RB_IOMAP
++	bool
++	default y if RB_PPC
++
+ source "drivers/cpufreq/Kconfig"
+ 
+ menu "CPU Frequency drivers"
+--- a/arch/powerpc/sysdev/Makefile
++++ b/arch/powerpc/sysdev/Makefile
+@@ -71,3 +71,6 @@ subdir-ccflags-$(CONFIG_PPC_WERROR) := -
+ obj-$(CONFIG_PPC_XICS)		+= xics/
+ 
+ obj-$(CONFIG_GE_FPGA)		+= ge/
++
++obj-$(CONFIG_RB_IOMAP)		+= rb_iomap.o
++
+--- /dev/null
++++ b/arch/powerpc/sysdev/rb_iomap.c
+@@ -0,0 +1,204 @@
++#include <linux/init.h>
++#include <linux/pci.h>
++#include <linux/mm.h>
++#include <asm/io.h>
++
++#define LOCALBUS_START		0x40000000
++#define LOCALBUS_MASK		0x007fffff
++#define LOCALBUS_REGMASK	0x001fffff
++
++static void __iomem *localbus_base;
++
++static inline int is_localbus(void __iomem *addr)
++{
++	return ((unsigned) addr & ~LOCALBUS_MASK) == LOCALBUS_START;
++}
++
++static inline unsigned localbus_regoff(unsigned reg) {
++	return (reg << 16) | (((reg ^ 8) & 8) << 17);
++}
++
++static inline void __iomem *localbus_addr(void __iomem *addr)
++{
++	return localbus_base
++	    + ((unsigned) addr & LOCALBUS_MASK & ~LOCALBUS_REGMASK)
++	    + localbus_regoff((unsigned) addr & LOCALBUS_REGMASK);
++}
++
++unsigned int ioread8(void __iomem *addr)
++{
++	if (is_localbus(addr))
++		return in_be16(localbus_addr(addr)) >> 8;
++	return readb(addr);
++}
++EXPORT_SYMBOL(ioread8);
++
++unsigned int ioread16(void __iomem *addr)
++{
++	if (is_localbus(addr))
++		return le16_to_cpu(in_be16(localbus_addr(addr)));
++	return readw(addr);
++}
++EXPORT_SYMBOL(ioread16);
++
++unsigned int ioread16be(void __iomem *addr)
++{
++	return in_be16(addr);
++}
++EXPORT_SYMBOL(ioread16be);
++
++unsigned int ioread32(void __iomem *addr)
++{
++	return readl(addr);
++}
++EXPORT_SYMBOL(ioread32);
++
++unsigned int ioread32be(void __iomem *addr)
++{
++	return in_be32(addr);
++}
++EXPORT_SYMBOL(ioread32be);
++
++void iowrite8(u8 val, void __iomem *addr)
++{
++	if (is_localbus(addr))
++		out_be16(localbus_addr(addr), ((u16) val) << 8);
++	else
++		writeb(val, addr);
++}
++EXPORT_SYMBOL(iowrite8);
++
++void iowrite16(u16 val, void __iomem *addr)
++{
++	if (is_localbus(addr))
++		out_be16(localbus_addr(addr), cpu_to_le16(val));
++	else
++		writew(val, addr);
++}
++EXPORT_SYMBOL(iowrite16);
++
++void iowrite16be(u16 val, void __iomem *addr)
++{
++	out_be16(addr, val);
++}
++EXPORT_SYMBOL(iowrite16be);
++
++void iowrite32(u32 val, void __iomem *addr)
++{
++	writel(val, addr);
++}
++EXPORT_SYMBOL(iowrite32);
++
++void iowrite32be(u32 val, void __iomem *addr)
++{
++	out_be32(addr, val);
++}
++EXPORT_SYMBOL(iowrite32be);
++
++void ioread8_rep(void __iomem *addr, void *dst, unsigned long count)
++{
++	if (is_localbus(addr)) {
++		unsigned i;
++		void *laddr = localbus_addr(addr);
++		u8 *buf = dst;
++
++		for (i = 0; i < count; ++i) {
++			*buf++ = in_be16(laddr) >> 8;
++		}
++	} else {
++		_insb((u8 __iomem *) addr, dst, count);
++	}
++}
++EXPORT_SYMBOL(ioread8_rep);
++
++void ioread16_rep(void __iomem *addr, void *dst, unsigned long count)
++{
++	if (is_localbus(addr)) {
++		unsigned i;
++		void *laddr = localbus_addr(addr);
++		u16 *buf = dst;
++
++		for (i = 0; i < count; ++i) {
++			*buf++ = in_be16(laddr);
++		}
++	} else {
++		_insw_ns((u16 __iomem *) addr, dst, count);
++	}
++}
++EXPORT_SYMBOL(ioread16_rep);
++
++void ioread32_rep(void __iomem *addr, void *dst, unsigned long count)
++{
++	_insl_ns((u32 __iomem *) addr, dst, count);
++}
++EXPORT_SYMBOL(ioread32_rep);
++
++void iowrite8_rep(void __iomem *addr, const void *src, unsigned long count)
++{
++	if (is_localbus(addr)) {
++		unsigned i;
++		void *laddr = localbus_addr(addr);
++		const u8 *buf = src;
++
++		for (i = 0; i < count; ++i) {
++			out_be16(laddr, ((u16) *buf++) << 8);
++		}
++	} else {
++		_outsb((u8 __iomem *) addr, src, count);
++	}
++}
++EXPORT_SYMBOL(iowrite8_rep);
++
++void iowrite16_rep(void __iomem *addr, const void *src, unsigned long count)
++{
++	if (is_localbus(addr)) {
++		unsigned i;
++		void *laddr = localbus_addr(addr);
++		const u16 *buf = src;
++
++		for (i = 0; i < count; ++i) {
++			out_be16(laddr, *buf++);
++		}
++	} else {
++		_outsw_ns((u16 __iomem *) addr, src, count);
++	}
++}
++EXPORT_SYMBOL(iowrite16_rep);
++
++void iowrite32_rep(void __iomem *addr, const void *src, unsigned long count)
++{
++	_outsl_ns((u32 __iomem *) addr, src, count);
++}
++EXPORT_SYMBOL(iowrite32_rep);
++
++void __iomem *ioport_map(unsigned long port, unsigned int len)
++{
++	return (void __iomem *) (port + _IO_BASE);
++}
++EXPORT_SYMBOL(ioport_unmap);
++
++void ioport_unmap(void __iomem *addr)
++{
++	/* Nothing to do */
++}
++EXPORT_SYMBOL(ioport_map);
++
++void pci_iounmap(struct pci_dev *dev, void __iomem *addr)
++{
++	/* Nothing to do */
++}
++EXPORT_SYMBOL(pci_iounmap);
++
++void __iomem *localbus_map(unsigned long addr, unsigned int len)
++{
++	if (!localbus_base)
++		localbus_base = ioremap(addr & ~LOCALBUS_MASK,
++					LOCALBUS_MASK + 1);
++	return (void *) (LOCALBUS_START + (addr & LOCALBUS_MASK));
++}
++EXPORT_SYMBOL(localbus_map);
++
++void localbus_unmap(void __iomem *addr)
++{
++}
++EXPORT_SYMBOL(localbus_unmap);
+--- a/arch/powerpc/platforms/83xx/Kconfig
++++ b/arch/powerpc/platforms/83xx/Kconfig
+@@ -44,6 +44,7 @@ config RB_PPC
+ 	select QUICC_ENGINE
+ 	select PPC_MPC832x
+ 	select PPC_MPC834x
++	select RB_IOMAP
+ 	help
+ 	  This option enables support for MikroTik RouterBOARD 333/600 series boards.
+ 
diff --git a/target/linux/mpc83xx/patches-3.10/202-ata-add-pata_rbppc_cf-driver.patch b/target/linux/mpc83xx/patches-3.10/202-ata-add-pata_rbppc_cf-driver.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/patches-3.10/202-ata-add-pata_rbppc_cf-driver.patch
@@ -0,0 +1,727 @@
+--- a/drivers/ata/Kconfig
++++ b/drivers/ata/Kconfig
+@@ -938,5 +938,12 @@ config PATA_LEGACY
+ 
+ 	  If unsure, say N.
+ 
++config PATA_RB_PPC
++	tristate "MikroTik RB600 PATA support"
++	depends on RB_PPC
++	help
++	  This option enables support for PATA devices on MikroTik RouterBOARD
++	  600 series boards.
++
+ endif # ATA_SFF
+ endif # ATA
+--- a/drivers/ata/Makefile
++++ b/drivers/ata/Makefile
+@@ -92,6 +92,7 @@ obj-$(CONFIG_PATA_PALMLD)	+= pata_palmld
+ obj-$(CONFIG_PATA_PLATFORM)	+= pata_platform.o
+ obj-$(CONFIG_PATA_OF_PLATFORM)	+= pata_of_platform.o
+ obj-$(CONFIG_PATA_RB532)	+= pata_rb532_cf.o
++obj-$(CONFIG_PATA_RB_PPC)	+= pata_rbppc_cf.o
+ obj-$(CONFIG_PATA_RZ1000)	+= pata_rz1000.o
+ obj-$(CONFIG_PATA_SAMSUNG_CF)	+= pata_samsung_cf.o
+ 
+--- /dev/null
++++ b/drivers/ata/pata_rbppc_cf.c
+@@ -0,0 +1,699 @@
++/*
++ * Copyright (C) 2008-2009 Noah Fontes <nfontes@transtruct.org>
++ * Copyright (C) Mikrotik 2007
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License as published by the
++ * Free Software Foundation; either version 2 of the License, or (at your
++ * option) any later version.
++ */
++
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/init.h>
++#include <scsi/scsi_host.h>
++#include <linux/libata.h>
++#include <linux/of_platform.h>
++#include <linux/ata_platform.h>
++#include <linux/slab.h>
++
++#define DEBUG_UPM	0
++
++#define DRV_NAME	"pata_rbppc_cf"
++#define DRV_VERSION	"0.0.2"
++
++#define DEV2SEL_OFFSET	0x00100000
++
++#define IMMR_LBCFG_OFFSET	0x00005000
++#define IMMR_LBCFG_SIZE		0x00001000
++
++#define LOCAL_BUS_MCMR		0x00000078
++#define   MxMR_OP_MASK			0x30000000
++#define   MxMR_OP_NORMAL		0x00000000
++#define   MxMR_OP_WRITE			0x10000000
++#define   MxMR_OP_READ			0x20000000
++#define   MxMR_OP_RUN			0x30000000
++#define   MxMR_LUPWAIT_LOW		0x08000000
++#define   MxMR_LUPWAIT_HIGH		0x00000000
++#define   MxMR_LUPWAIT_ENABLE		0x00040000
++#define   MxMR_RLF_MASK			0x0003c000
++#define   MxMR_RLF_SHIFT			14
++#define   MxMR_WLF_MASK			0x00003c00
++#define   MxMR_WLF_SHIFT			10
++#define   MxMR_MAD_MASK			0x0000003f
++#define LOCAL_BUS_MDR		0x00000088
++#define LOCAL_BUS_LCRR		0x000000D4
++#define   LCRR_CLKDIV_MASK		0x0000000f
++
++#define LOOP_SIZE	4
++
++#define UPM_READ_SINGLE_OFFSET	0x00
++#define UPM_WRITE_SINGLE_OFFSET	0x18
++#define UPM_DATA_SIZE	0x40
++
++#define LBT_CPUIN_MIN		0
++#define LBT_CPUOUT_MIN		1
++#define LBT_CPUOUT_MAX		2
++#define LBT_EXTDEL_MIN		3
++#define LBT_EXTDEL_MAX		4
++#define LBT_SIZE		5
++
++/* UPM machine configuration bits */
++#define N_BASE	0x00f00000
++#define N_CS	0xf0000000
++#define N_CS_H1	0xc0000000
++#define N_CS_H2	0x30000000
++#define N_WE	0x0f000000
++#define N_WE_H1	0x0c000000
++#define N_WE_H2	0x03000000
++#define N_OE	0x00030000
++#define N_OE_H1	0x00020000
++#define N_OE_H2	0x00010000
++#define WAEN	0x00001000
++#define REDO_2	0x00000100
++#define REDO_3	0x00000200
++#define REDO_4	0x00000300
++#define LOOP	0x00000080
++#define NA	0x00000008
++#define UTA	0x00000004
++#define LAST	0x00000001
++
++#define REDO_VAL(mult)	(REDO_2 * ((mult) - 1))
++#define REDO_MAX_MULT	4
++
++#define READ_BASE	(N_BASE | N_WE)
++#define WRITE_BASE	(N_BASE | N_OE)
++#define EMPTY		(N_BASE | N_CS | N_OE | N_WE | LAST)
++
++#define EOF_UPM_SETTINGS	0
++#define ANOTHER_TIMING		1
++
++#define OA_CPUIN_MIN		0x01
++#define OA_CPUOUT_MAX		0x02
++#define OD_CPUOUT_MIN		0x04
++#define OA_CPUOUT_DELTA		0x06
++#define OA_EXTDEL_MAX		0x08
++#define OD_EXTDEL_MIN		0x10
++#define OA_EXTDEL_DELTA		0x18
++#define O_MIN_CYCLE_TIME	0x20
++#define O_MINUS_PREV		0x40
++#define O_HALF_CYCLE		0x80
++
++extern void __iomem *localbus_map(unsigned long addr, unsigned int len);
++extern void localbus_unmap(void __iomem *addr);
++
++struct rbppc_cf_info {
++	unsigned lbcfg_addr;
++	unsigned clk_time_ps;
++	int cur_mode;
++	u32 lb_timings[LBT_SIZE];
++};
++static struct rbppc_cf_info *rbinfo = NULL;
++
++struct upm_setting {
++	unsigned value;
++	unsigned ns[7];
++	unsigned clk_minus;
++	unsigned group_size;
++	unsigned options;
++};
++
++static const struct upm_setting cfUpmReadSingle[] = {
++	{ READ_BASE | N_OE,
++	  /* t1 - ADDR setup time */
++		{  70,  50,  30,  30,  25,  15,  10 }, 0, 0, (OA_CPUOUT_DELTA |
++							      OA_EXTDEL_MAX) },
++	{ READ_BASE | N_OE_H1,
++		{   0,   0,   0,   0,   0,   0,   0 }, 0, 0, O_HALF_CYCLE },
++	{ READ_BASE,
++	  /* t2 - OE0 time */
++		{ 290, 290, 290,  80,  70,  65,  55 }, 0, 2, (OA_CPUOUT_MAX |
++							      OA_CPUIN_MIN) },
++	{ READ_BASE | WAEN,
++		{   1,   1,   1,   1,   1,   0,   0 }, 0, 0, 0 },
++	{ READ_BASE | UTA,
++		{   1,   1,   1,   1,   1,   1,   1 }, 0, 0, 0 },
++	{ READ_BASE | N_OE,
++	  /* t9 - ADDR hold time */
++		{  20,  15,  10,  10,  10,  10,  10 }, 0, 0, (OA_CPUOUT_DELTA |
++							      OD_EXTDEL_MIN) },
++	{ READ_BASE | N_OE | N_CS_H2,
++		{   0,   0,   0,   0,   0,   0,   0 }, 0, 0, O_HALF_CYCLE },
++	{ READ_BASE | N_OE | N_CS,
++	  /* t6Z -IORD data tristate */
++		{  30,  30,  30,  30,  30,  20,  20 }, 1, 1, O_MINUS_PREV },
++	{ ANOTHER_TIMING,
++	  /* t2i -IORD recovery time */
++		{   0,   0,   0,  70,  25,  25,  20 }, 2, 0, 0 },
++	{ ANOTHER_TIMING,
++	  /* CS 0 -> 1 MAX */
++		{   0,   0,   0,   0,   0,   0,   0 }, 1, 0, (OA_CPUOUT_DELTA |
++							      OA_EXTDEL_MAX) },
++	{ READ_BASE | N_OE | N_CS | LAST,
++		{   1,   1,   1,   1,   1,   1,   1 }, 0, 0, 0 },
++	{ EOF_UPM_SETTINGS,
++	  /* min total cycle time - includes turnaround and ALE cycle */
++		{ 600, 383, 240, 180, 120, 100,  80 }, 2, 0, O_MIN_CYCLE_TIME },
++};
++
++static const struct upm_setting cfUpmWriteSingle[] = {
++	{ WRITE_BASE | N_WE,
++	  /* t1 - ADDR setup time */
++		{  70,  50,  30,  30,  25,  15,  10 }, 0, 0, (OA_CPUOUT_DELTA |
++							      OA_EXTDEL_MAX) },
++	{ WRITE_BASE | N_WE_H1,
++		{   0,   0,   0,   0,   0,   0,   0 }, 0, 0, O_HALF_CYCLE },
++	{ WRITE_BASE,
++	  /* t2 - WE0 time */
++		{ 290, 290, 290,  80,  70,  65,  55 }, 0, 1, OA_CPUOUT_DELTA },
++	{ WRITE_BASE | WAEN,
++		{   1,   1,   1,   1,   1,   0,   0 }, 0, 0, 0 },
++	{ WRITE_BASE | N_WE,
++	  /* t9 - ADDR hold time */
++		{  20,  15,  10,  10,  10,  10,  10 }, 0, 0, (OA_CPUOUT_DELTA |
++							      OD_EXTDEL_MIN) },
++	{ WRITE_BASE | N_WE | N_CS_H2,
++		{   0,   0,   0,   0,   0,   0,   0 }, 0, 0, O_HALF_CYCLE },
++	{ WRITE_BASE | N_WE | N_CS,
++	  /* t4 - DATA hold time */
++		{  30,  20,  15,  10,  10,  10,  10 }, 0, 1, O_MINUS_PREV },
++	{ ANOTHER_TIMING,
++	  /* t2i -IOWR recovery time */
++		{   0,   0,   0,  70,  25,  25,  20 }, 1, 0, 0 },
++	{ ANOTHER_TIMING,
++	  /* CS 0 -> 1 MAX */
++		{   0,   0,   0,   0,   0,   0,   0 }, 0, 0, (OA_CPUOUT_DELTA |
++							      OA_EXTDEL_MAX) },
++	{ WRITE_BASE | N_WE | N_CS | UTA | LAST,
++		{   1,   1,   1,   1,   1,   1,   1 }, 0, 0, 0 },
++	/* min total cycle time - includes ALE cycle */
++	{ EOF_UPM_SETTINGS,
++		{ 600, 383, 240, 180, 120, 100,  80 }, 1, 0, O_MIN_CYCLE_TIME },
++};
++
++static u8 rbppc_cf_check_status(struct ata_port *ap) {
++	u8 val = ioread8(ap->ioaddr.status_addr);
++	if (val == 0xF9)
++		val = 0x7F;
++	return val;
++}
++
++static u8 rbppc_cf_check_altstatus(struct ata_port *ap) {
++	u8 val = ioread8(ap->ioaddr.altstatus_addr);
++	if (val == 0xF9)
++		val = 0x7F;
++	return val;
++}
++
++static void rbppc_cf_dummy_noret(struct ata_port *ap) { }
++static int rbppc_cf_dummy_ret0(struct ata_port *ap) { return 0; }
++
++static int ps2clk(int ps, unsigned clk_time_ps) {
++	int psMaxOver;
++	if (ps <= 0) return 0;
++
++	/* round down if <= 2% over clk border, but no more than 1/4 clk cycle */
++	psMaxOver = ps * 2 / 100;
++	if (4 * psMaxOver > clk_time_ps) {
++		psMaxOver = clk_time_ps / 4;
++	}
++	return (ps + clk_time_ps - 1 - psMaxOver) / clk_time_ps;
++}
++
++static int upm_gen_ps_table(const struct upm_setting *upm,
++			    int mode, struct rbppc_cf_info *info,
++			    int *psFinal) {
++	int uidx;
++	int lastUpmValIdx = 0;
++	int group_start_idx = -1;
++	int group_left_num = -1;
++	int clk_time_ps = info->clk_time_ps;
++
++	for (uidx = 0; upm[uidx].value != EOF_UPM_SETTINGS; ++uidx) {
++		const struct upm_setting *us = upm + uidx;
++		unsigned opt = us->options;
++		int ps = us->ns[mode] * 1000 - us->clk_minus * clk_time_ps;
++
++		if (opt & OA_CPUIN_MIN) ps += info->lb_timings[LBT_CPUIN_MIN];
++		if (opt & OD_CPUOUT_MIN) ps -= info->lb_timings[LBT_CPUOUT_MIN];
++		if (opt & OA_CPUOUT_MAX) ps += info->lb_timings[LBT_CPUOUT_MAX];
++		if (opt & OD_EXTDEL_MIN) ps -= info->lb_timings[LBT_EXTDEL_MIN];
++		if (opt & OA_EXTDEL_MAX) ps += info->lb_timings[LBT_EXTDEL_MAX];
++
++		if (us->value == ANOTHER_TIMING) {
++			/* use longest timing from alternatives */
++			if (psFinal[lastUpmValIdx] < ps) {
++				psFinal[lastUpmValIdx] = ps;
++			}
++			ps = 0;
++		}
++		else {
++			if (us->group_size) {
++				group_start_idx = uidx;
++				group_left_num = us->group_size;
++			}
++			else if (group_left_num > 0) {
++				/* group time is divided on all group members */
++				int clk = ps2clk(ps, clk_time_ps);
++				psFinal[group_start_idx] -= clk * clk_time_ps;
++				--group_left_num;
++			}
++			if ((opt & O_MINUS_PREV) && lastUpmValIdx > 0) {
++				int clk = ps2clk(psFinal[lastUpmValIdx],
++						 clk_time_ps);
++				ps -= clk * clk_time_ps;
++			}
++			lastUpmValIdx = uidx;
++		}
++		psFinal[uidx] = ps;
++	}
++	return uidx;
++}
++
++static int free_half(int ps, int clk, int clk_time_ps) {
++    if (clk < 2) return 0;
++    return (clk * clk_time_ps - ps) * 2 >= clk_time_ps;
++}
++
++static void upm_gen_clk_table(const struct upm_setting *upm,
++			      int mode, int clk_time_ps,
++			      int max_uidx, const int *psFinal, int *clkFinal) {
++	int clk_cycle_time;
++	int clk_total;
++	int uidx;
++
++	/* convert picoseconds to clocks */
++	clk_total = 0;
++	for (uidx = 0; uidx < max_uidx; ++uidx) {
++		int clk = ps2clk(psFinal[uidx], clk_time_ps);
++		clkFinal[uidx] = clk;
++		clk_total += clk;
++	}
++
++	/* check possibility of half cycle usage */
++	for (uidx = 1; uidx < max_uidx - 1; ++uidx) {
++		if ((upm[uidx].options & O_HALF_CYCLE) &&
++		    free_half(psFinal[uidx - 1], clkFinal[uidx - 1],
++			      clk_time_ps) &&
++		    free_half(psFinal[uidx + 1], clkFinal[uidx + 1],
++			      clk_time_ps)) {
++			++clkFinal[uidx];
++			--clkFinal[uidx - 1];
++			--clkFinal[uidx + 1];
++		}
++	}
++
++	if ((upm[max_uidx].options & O_MIN_CYCLE_TIME) == 0) return;
++
++	/* check cycle time, adjust timings if needed */
++	clk_cycle_time = (ps2clk(upm[max_uidx].ns[mode] * 1000, clk_time_ps) -
++			  upm[max_uidx].clk_minus);
++	uidx = 0;
++	while (clk_total < clk_cycle_time) {
++		/* extend all timings in round-robin to match cycle time */
++		if (clkFinal[uidx]) {
++#if DEBUG_UPM
++			printk(KERN_INFO "extending %u by 1 clk\n", uidx);
++#endif
++			++clkFinal[uidx];
++			++clk_total;
++		}
++		++uidx;
++		if (uidx == max_uidx) uidx = 0;
++	}
++}
++
++static void add_data_val(unsigned val, int *clkLeft, int maxClk,
++			unsigned *data, int *dataIdx) {
++	if (*clkLeft == 0) return;
++
++	if (maxClk == 0 && *clkLeft >= LOOP_SIZE * 2) {
++		int times;
++		int times1;
++		int times2;
++
++		times = *clkLeft / LOOP_SIZE;
++		if (times > REDO_MAX_MULT * 2) times = REDO_MAX_MULT * 2;
++		times1 = times / 2;
++		times2 = times - times1;
++
++		val |= LOOP;
++		data[*dataIdx] = val | REDO_VAL(times1);
++		++(*dataIdx);
++		data[*dataIdx] = val | REDO_VAL(times2);
++		++(*dataIdx);
++
++		*clkLeft -= times * LOOP_SIZE;
++		return;
++	}
++
++	if (maxClk < 1 || maxClk > REDO_MAX_MULT) maxClk = REDO_MAX_MULT;
++	if (*clkLeft < maxClk) maxClk = *clkLeft;
++
++	*clkLeft -= maxClk;
++	val |= REDO_VAL(maxClk);
++
++	data[*dataIdx] = val;
++	++(*dataIdx);
++}
++
++static int upm_gen_final_data(const struct upm_setting *upm,
++			       int max_uidx, int *clkFinal, unsigned *data) {
++	int dataIdx;
++	int uidx;
++
++	dataIdx = 0;
++	for (uidx = 0; uidx < max_uidx; ++uidx) {
++		int clk = clkFinal[uidx];
++		while (clk > 0) {
++			add_data_val(upm[uidx].value, &clk, 0,
++				     data, &dataIdx);
++		}
++	}
++	return dataIdx;
++}
++
++static int conv_upm_table(const struct upm_setting *upm,
++			  int mode, struct rbppc_cf_info *info,
++			  unsigned *data) {
++#if DEBUG_UPM
++	int uidx;
++#endif
++	int psFinal[32];
++	int clkFinal[32];
++	int max_uidx;
++	int data_len;
++
++	max_uidx = upm_gen_ps_table(upm, mode, info, psFinal);
++
++	upm_gen_clk_table(upm, mode, info->clk_time_ps, max_uidx,
++			  psFinal, clkFinal);
++
++#if DEBUG_UPM
++	/* dump out debug info */
++	for (uidx = 0; uidx < max_uidx; ++uidx) {
++		if (clkFinal[uidx]) {
++			printk(KERN_INFO "idx %d val %08x clk %d ps %d\n",
++				uidx, upm[uidx].value,
++				clkFinal[uidx], psFinal[uidx]);
++		}
++	}
++#endif
++
++	data_len = upm_gen_final_data(upm, max_uidx, clkFinal, data);
++
++#if DEBUG_UPM
++	for (uidx = 0; uidx < data_len; ++uidx) {
++		printk(KERN_INFO "cf UPM x result: idx %d val %08x\n",
++		       uidx, data[uidx]);
++	}
++#endif
++	return 0;
++}
++
++static int gen_upm_data(int mode, struct rbppc_cf_info *info, unsigned *data) {
++	int i;
++
++	for (i = 0; i < UPM_DATA_SIZE; ++i) {
++		data[i] = EMPTY;
++	}
++
++	if (conv_upm_table(cfUpmReadSingle, mode, info, data + UPM_READ_SINGLE_OFFSET)) {
++		return -1;
++	}
++	if (conv_upm_table(cfUpmWriteSingle, mode, info, data + UPM_WRITE_SINGLE_OFFSET)) {
++		return -1;
++	}
++	return 0;
++}
++
++static void rbppc_cf_program_upm(void *upmMemAddr, volatile void *lbcfg_mxmr, volatile void *lbcfg_mdr, const unsigned *upmData, unsigned offset, unsigned len) {
++	unsigned i;
++	unsigned mxmr;
++
++	mxmr = in_be32(lbcfg_mxmr);
++	mxmr &= ~(MxMR_OP_MASK | MxMR_MAD_MASK);
++	mxmr |= (MxMR_OP_WRITE | offset);
++	out_be32(lbcfg_mxmr, mxmr);
++	in_be32(lbcfg_mxmr); /* flush MxMR write */
++
++	for (i = 0; i < len; ++i) {
++		int to;
++		unsigned data = upmData[i + offset];
++		out_be32(lbcfg_mdr, data);
++		in_be32(lbcfg_mdr); /* flush MDR write */
++
++		iowrite8(1, upmMemAddr); /* dummy write to any CF addr */
++
++		/* wait for dummy write to complete */
++		for (to = 10000; to >= 0; --to) {
++			mxmr = in_be32(lbcfg_mxmr);
++			if (((mxmr ^ (i + 1)) & MxMR_MAD_MASK) == 0) {
++				break;
++			}
++			if (to == 0) {
++				printk(KERN_ERR "rbppc_cf_program_upm: UPMx program error at 0x%x: Timeout\n", i);
++			}
++		}
++	}
++	mxmr &= ~(MxMR_OP_MASK | MxMR_RLF_MASK | MxMR_WLF_MASK);
++	mxmr |= (MxMR_OP_NORMAL | (LOOP_SIZE << MxMR_RLF_SHIFT) | (LOOP_SIZE << MxMR_WLF_SHIFT));
++	out_be32(lbcfg_mxmr, mxmr);
++}
++
++static int rbppc_cf_update_piomode(struct ata_port *ap, int mode) {
++	struct rbppc_cf_info *info = (struct rbppc_cf_info *)ap->host->private_data;
++	void *lbcfgBase;
++	unsigned upmData[UPM_DATA_SIZE];
++
++	if (gen_upm_data(mode, info, upmData)) {
++		return -1;
++	}
++
++	lbcfgBase = ioremap_nocache(info->lbcfg_addr, IMMR_LBCFG_SIZE);
++
++	rbppc_cf_program_upm(ap->ioaddr.cmd_addr, ((char *)lbcfgBase) + LOCAL_BUS_MCMR, ((char *)lbcfgBase) + LOCAL_BUS_MDR, upmData, 0, UPM_DATA_SIZE);
++	iounmap(lbcfgBase);
++	return 0;
++}
++
++static void rbppc_cf_set_piomode(struct ata_port *ap, struct ata_device *adev)
++{
++	struct rbppc_cf_info *info = (struct rbppc_cf_info *)ap->host->private_data;
++	int mode = adev->pio_mode - XFER_PIO_0;
++
++	DPRINTK("rbppc_cf_set_piomode: PIO %d\n", mode);
++	if (mode < 0) mode = 0;
++	if (mode > 6) mode = 6;
++
++	if (info->cur_mode < 0 || info->cur_mode > mode) {
++		if (rbppc_cf_update_piomode(ap, mode) == 0) {
++			printk(KERN_INFO "rbppc_cf_set_piomode: PIO mode changed to %d\n", mode);
++			info->cur_mode = mode;
++		}
++	}
++}
++
++static struct scsi_host_template rbppc_cf_sht = {
++	ATA_BASE_SHT(DRV_NAME),
++};
++
++static struct ata_port_operations rbppc_cf_port_ops = {
++	.inherits		= &ata_bmdma_port_ops,
++
++	.sff_check_status	= rbppc_cf_check_status,
++	.sff_check_altstatus	= rbppc_cf_check_altstatus,
++
++	.set_piomode		= rbppc_cf_set_piomode,
++
++	.port_start		= rbppc_cf_dummy_ret0,
++
++	.sff_irq_clear		= rbppc_cf_dummy_noret,
++};
++
++static int rbppc_cf_init_info(struct platform_device *pdev, struct rbppc_cf_info *info) {
++	struct device_node *np;
++	struct resource res;
++	const u32 *u32ptr;
++	void *lbcfgBase;
++	void *lbcfg_lcrr;
++	unsigned lbc_clk_khz;
++	unsigned lbc_extra_divider = 1;
++	unsigned ccb_freq_hz;
++	unsigned lb_div;
++
++	u32ptr = of_get_property(pdev->dev.of_node, "lbc_extra_divider", NULL);
++	if (u32ptr && *u32ptr) {
++		lbc_extra_divider = *u32ptr;
++#if DEBUG_UPM
++		printk(KERN_INFO "rbppc_cf_init_info: LBC extra divider %u\n",
++		       lbc_extra_divider);
++#endif
++	}
++
++	np = of_find_node_by_type(NULL, "serial");
++	if (!np) {
++		printk(KERN_ERR "rbppc_cf_init_info: No serial node found\n");
++		return -1;
++	}
++	u32ptr = of_get_property(np, "clock-frequency", NULL);
++	if (u32ptr == 0 || *u32ptr == 0) {
++		printk(KERN_ERR "rbppc_cf_init_info: Serial does not have clock-frequency\n");
++		of_node_put(np);
++		return -1;
++	}
++	ccb_freq_hz = *u32ptr;
++	of_node_put(np);
++
++	np = of_find_node_by_type(NULL, "soc");
++	if (!np) {
++		printk(KERN_ERR "rbppc_cf_init_info: No soc node found\n");
++		return -1;
++	}
++	if (of_address_to_resource(np, 0, &res)) {
++		printk(KERN_ERR "rbppc_cf_init_info: soc does not have resource\n");
++		of_node_put(np);
++		return -1;
++	}
++	info->lbcfg_addr = res.start + IMMR_LBCFG_OFFSET;
++	of_node_put(np);
++
++	lbcfgBase = ioremap_nocache(info->lbcfg_addr, IMMR_LBCFG_SIZE);
++	lbcfg_lcrr = ((char*)lbcfgBase) + LOCAL_BUS_LCRR;
++	lb_div = (in_be32(lbcfg_lcrr) & LCRR_CLKDIV_MASK) * lbc_extra_divider;
++	iounmap(lbcfgBase);
++
++	lbc_clk_khz = ccb_freq_hz / (1000 * lb_div);
++	info->clk_time_ps = 1000000000 / lbc_clk_khz;
++	printk(KERN_INFO "rbppc_cf_init_info: Using Local-Bus clock %u kHz %u ps\n",
++	       lbc_clk_khz, info->clk_time_ps);
++
++	u32ptr = of_get_property(pdev->dev.of_node, "lb-timings", NULL);
++	if (u32ptr) {
++		memcpy(info->lb_timings, u32ptr, LBT_SIZE * sizeof(*u32ptr));
++#if DEBUG_UPM
++		printk(KERN_INFO "rbppc_cf_init_info: Got LB timings <%u %u %u %u %u>\n",
++		       u32ptr[0], u32ptr[1], u32ptr[2], u32ptr[3], u32ptr[4]);
++#endif
++	}
++	info->cur_mode = -1;
++	return 0;
++}
++
++static int rbppc_cf_probe(struct platform_device *pdev)
++{
++	struct ata_host *host;
++	struct ata_port *ap;
++	struct rbppc_cf_info *info = NULL;
++	struct resource res;
++	void *baddr;
++	const u32 *u32ptr;
++	int irq_level = 0;
++	int err = -ENOMEM;
++
++	printk(KERN_INFO "rbppc_cf_probe: MikroTik RouterBOARD 600 series Compact Flash PATA driver, version " DRV_VERSION "\n");
++
++	if (rbinfo == NULL) {
++		info = kmalloc(sizeof(*info), GFP_KERNEL);
++		if (info == NULL) {
++			printk(KERN_ERR "rbppc_cf_probe: Out of memory\n");
++			goto err_info;
++		}
++		memset(info, 0, sizeof(*info));
++
++		if (rbppc_cf_init_info(pdev, info)) {
++			goto err_info;
++		}
++		rbinfo = info;
++	}
++
++	u32ptr = of_get_property(pdev->dev.of_node, "interrupt-at-level", NULL);
++	if (u32ptr) {
++		irq_level = *u32ptr;
++		printk(KERN_INFO "rbppc_cf_probe: IRQ level %u\n", irq_level);
++	}
++
++	if (of_address_to_resource(pdev->dev.of_node, 0, &res)) {
++	    printk(KERN_ERR "rbppc_cf_probe: No reg property found\n");
++	    goto err_info;
++	}
++
++	host = ata_host_alloc(&pdev->dev, 1);
++	if (!host)
++	    goto err_info;
++
++	baddr = localbus_map(res.start, res.end - res.start + 1);
++	host->iomap = baddr;
++	host->private_data = rbinfo;
++
++	ap = host->ports[0];
++	ap->ops = &rbppc_cf_port_ops;
++	ap->pio_mask = 0x7F;	/* PIO modes 0-6 */
++	ap->mwdma_mask = 0;
++
++	ap->ioaddr.cmd_addr = baddr;
++	ata_sff_std_ports(&ap->ioaddr);
++	ap->ioaddr.ctl_addr = ap->ioaddr.cmd_addr + 14;
++	ap->ioaddr.altstatus_addr = ap->ioaddr.ctl_addr;
++	ap->ioaddr.bmdma_addr = 0;
++
++	err = ata_host_activate(
++		host,
++		irq_of_parse_and_map(pdev->dev.of_node, 0), ata_sff_interrupt,
++		irq_level ? IRQF_TRIGGER_HIGH : IRQF_TRIGGER_LOW,
++		&rbppc_cf_sht);
++	if (!err) return 0;
++
++	localbus_unmap(baddr);
++err_info:
++	if (info) {
++		kfree(info);
++		rbinfo = NULL;
++	}
++	return err;
++}
++
++static int rbppc_cf_remove(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct ata_host *host = dev_get_drvdata(dev);
++
++	if (host == NULL) return -1;
++
++	ata_host_detach(host);
++	return 0;
++}
++
++static struct of_device_id rbppc_cf_ids[] = {
++	{ .name = "cf", },
++	{ },
++};
++
++static struct platform_driver rbppc_cf_driver = {
++	.probe = rbppc_cf_probe,
++	.remove = rbppc_cf_remove,
++	.driver	= {
++		.name = "rbppc-cf",
++		.owner = THIS_MODULE,
++		.of_match_table = rbppc_cf_ids,
++	},
++};
++
++static int __init rbppc_init(void)
++{
++	return platform_driver_register(&rbppc_cf_driver);
++}
++
++static void __exit rbppc_exit(void)
++{
++	platform_driver_unregister(&rbppc_cf_driver);
++}
++
++MODULE_AUTHOR("Mikrotikls SIA");
++MODULE_AUTHOR("Noah Fontes");
++MODULE_DESCRIPTION("MikroTik RouterBOARD 600 series Compact Flash PATA driver");
++MODULE_LICENSE("GPL");
++MODULE_VERSION(DRV_VERSION);
++
++module_init(rbppc_init);
++module_exit(rbppc_exit);
diff --git a/target/linux/mpc83xx/patches-3.10/203-mtd-add-rbppc_nand-driver.patch b/target/linux/mpc83xx/patches-3.10/203-mtd-add-rbppc_nand-driver.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/patches-3.10/203-mtd-add-rbppc_nand-driver.patch
@@ -0,0 +1,279 @@
+--- a/drivers/mtd/nand/Kconfig
++++ b/drivers/mtd/nand/Kconfig
+@@ -432,6 +432,13 @@ config MTD_NAND_PLATFORM
+ 	  devices. You will need to provide platform-specific functions
+ 	  via platform_data.
+ 
++config MTD_NAND_RB_PPC
++	tristate "MikroTik RB333/600 NAND support"
++	depends on RB_PPC
++	help
++	  This option enables support for the NAND device on MikroTik
++	  RouterBOARD 333/600 series boards.
++
+ config MTD_ALAUDA
+ 	tristate "MTD driver for Olympus MAUSB-10 and Fujifilm DPC-R1"
+ 	depends on USB
+--- a/drivers/mtd/nand/Makefile
++++ b/drivers/mtd/nand/Makefile
+@@ -31,6 +31,7 @@ obj-$(CONFIG_MTD_NAND_CM_X270)		+= cmx27
+ obj-$(CONFIG_MTD_NAND_PXA3xx)		+= pxa3xx_nand.o
+ obj-$(CONFIG_MTD_NAND_TMIO)		+= tmio_nand.o
+ obj-$(CONFIG_MTD_NAND_PLATFORM)		+= plat_nand.o
++obj-$(CONFIG_MTD_NAND_RB_PPC)		+= rbppc_nand.o
+ obj-$(CONFIG_MTD_ALAUDA)		+= alauda.o
+ obj-$(CONFIG_MTD_NAND_PASEMI)		+= pasemi_nand.o
+ obj-$(CONFIG_MTD_NAND_ORION)		+= orion_nand.o
+--- /dev/null
++++ b/drivers/mtd/nand/rbppc_nand.c
+@@ -0,0 +1,250 @@
++/*
++ * Copyright (C) 2008-2009 Noah Fontes <nfontes@transtruct.org>
++ * Copyright (C) 2009 Michael Guntsche <mike@it-loops.com>
++ * Copyright (C) Mikrotik 2007
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License as published by the
++ * Free Software Foundation; either version 2 of the License, or (at your
++ * option) any later version.
++ */
++
++#include <linux/init.h>
++#include <linux/module.h>
++#include <linux/mtd/nand.h>
++#include <linux/mtd/mtd.h>
++#include <linux/mtd/partitions.h>
++#include <linux/of_platform.h>
++#include <linux/of_device.h>
++#include <linux/slab.h>
++#include <linux/delay.h>
++#include <asm/io.h>
++
++#define DRV_NAME	"rbppc_nand"
++#define DRV_VERSION	"0.0.2"
++
++static struct mtd_info rmtd;
++static struct nand_chip rnand;
++
++struct rbppc_nand_info {
++	void *gpi;
++	void *gpo;
++	void *localbus;
++
++	unsigned gpio_rdy;
++	unsigned gpio_nce;
++	unsigned gpio_cle;
++	unsigned gpio_ale;
++	unsigned gpio_ctrls;
++};
++
++/* We must use the OOB layout from yaffs 1 if we want this to be recognized
++ * properly. Borrowed from the OpenWRT patches for the RB532.
++ *
++ * See <https://dev.openwrt.org/browser/trunk/target/linux/rb532/
++ * patches-2.6.28/025-rb532_nand_fixup.patch> for more details.
++ */
++static struct nand_ecclayout rbppc_nand_oob_16 = {
++	.eccbytes = 6,
++	.eccpos = { 8, 9, 10, 13, 14, 15 },
++	.oobavail = 9,
++	.oobfree = { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
++};
++
++static struct mtd_partition rbppc_nand_partition_info[] = {
++	{
++		name: "kernel",
++		offset: 0,
++		size: 4 * 1024 * 1024,
++	},
++	{
++		name: "rootfs",
++		offset: MTDPART_OFS_NXTBLK,
++		size: MTDPART_SIZ_FULL,
++	},
++};
++
++static int rbppc_nand_dev_ready(struct mtd_info *mtd) {
++	struct nand_chip *chip = mtd->priv;
++	struct rbppc_nand_info *priv = chip->priv;
++
++	return in_be32(priv->gpi) & priv->gpio_rdy;
++}
++
++static void rbppc_nand_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl) {
++	struct nand_chip *chip = mtd->priv;
++	struct rbppc_nand_info *priv = chip->priv;
++
++	if (ctrl & NAND_CTRL_CHANGE) {
++		unsigned val = in_be32(priv->gpo);
++		if (!(val & priv->gpio_nce)) {
++			/* make sure Local Bus has done NAND operations */
++			readb(priv->localbus);
++		}
++
++		if (ctrl & NAND_CLE) {
++			val |= priv->gpio_cle;
++		} else {
++			val &= ~priv->gpio_cle;
++		}
++		if (ctrl & NAND_ALE) {
++			val |= priv->gpio_ale;
++		} else {
++			val &= ~priv->gpio_ale;
++		}
++		if (!(ctrl & NAND_NCE)) {
++			val |= priv->gpio_nce;
++		} else {
++			val &= ~priv->gpio_nce;
++		}
++		out_be32(priv->gpo, val);
++
++		/* make sure GPIO output has changed */
++		val ^= in_be32(priv->gpo);
++		if (val & priv->gpio_ctrls) {
++			printk(KERN_ERR "rbppc_nand_hwcontrol: NAND GPO change failed 0x%08x\n", val);
++		}
++	}
++
++	if (cmd != NAND_CMD_NONE) writeb(cmd, chip->IO_ADDR_W);
++}
++
++static void rbppc_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
++{
++	struct nand_chip *chip = mtd->priv;
++	memcpy(buf, chip->IO_ADDR_R, len);
++}
++
++static unsigned init_ok = 0;
++
++static int rbppc_nand_probe(struct platform_device *pdev)
++{
++	struct device_node *gpio;
++	struct device_node *nnand;
++	struct resource res;
++	struct rbppc_nand_info *info;
++	void *baddr;
++	const unsigned *rdy, *nce, *cle, *ale;
++
++	printk(KERN_INFO "rbppc_nand_probe: MikroTik RouterBOARD 333/600 series NAND driver, version " DRV_VERSION "\n");
++
++	info = kmalloc(sizeof(*info), GFP_KERNEL);
++
++	rdy = of_get_property(pdev->dev.of_node, "rdy", NULL);
++	nce = of_get_property(pdev->dev.of_node, "nce", NULL);
++	cle = of_get_property(pdev->dev.of_node, "cle", NULL);
++	ale = of_get_property(pdev->dev.of_node, "ale", NULL);
++
++	if (!rdy || !nce || !cle || !ale) {
++		printk(KERN_ERR "rbppc_nand_probe: GPIO properties are missing\n");
++		goto err;
++	}
++	if (rdy[0] != nce[0] || rdy[0] != cle[0] || rdy[0] != ale[0]) {
++		printk(KERN_ERR "rbppc_nand_probe: Different GPIOs are not supported\n");
++		goto err;
++	}
++
++	gpio = of_find_node_by_phandle(rdy[0]);
++	if (!gpio) {
++		printk(KERN_ERR "rbppc_nand_probe: No GPIO<%x> node found\n", *rdy);
++		goto err;
++	}
++	if (of_address_to_resource(gpio, 0, &res)) {
++		printk(KERN_ERR "rbppc_nand_probe: No reg property in GPIO found\n");
++		goto err;
++	}
++	info->gpo = ioremap_nocache(res.start, res.end - res.start + 1);
++
++	if (!of_address_to_resource(gpio, 1, &res)) {
++		info->gpi = ioremap_nocache(res.start, res.end - res.start + 1);
++	} else {
++		info->gpi = info->gpo;
++	}
++	of_node_put(gpio);
++
++	info->gpio_rdy = 1 << (31 - rdy[1]);
++	info->gpio_nce = 1 << (31 - nce[1]);
++	info->gpio_cle = 1 << (31 - cle[1]);
++	info->gpio_ale = 1 << (31 - ale[1]);
++	info->gpio_ctrls = info->gpio_nce | info->gpio_cle | info->gpio_ale;
++
++	nnand = of_find_node_by_name(NULL, "nnand");
++	if (!nnand) {
++		printk("rbppc_nand_probe: No nNAND found\n");
++		goto err;
++	}
++	if (of_address_to_resource(nnand, 0, &res)) {
++		printk("rbppc_nand_probe: No reg property in nNAND found\n");
++		goto err;
++	}
++	of_node_put(nnand);
++	info->localbus = ioremap_nocache(res.start, res.end - res.start + 1);
++
++	if (of_address_to_resource(pdev->dev.of_node, 0, &res)) {
++	    printk("rbppc_nand_probe: No reg property found\n");
++	    goto err;
++	}
++	baddr = ioremap_nocache(res.start, res.end - res.start + 1);
++
++	memset(&rnand, 0, sizeof(rnand));
++	rnand.cmd_ctrl = rbppc_nand_cmd_ctrl;
++	rnand.dev_ready = rbppc_nand_dev_ready;
++	rnand.read_buf = rbppc_nand_read_buf;
++	rnand.IO_ADDR_W = baddr;
++	rnand.IO_ADDR_R = baddr;
++	rnand.priv = info;
++
++	memset(&rmtd, 0, sizeof(rmtd));
++	rnand.ecc.mode = NAND_ECC_SOFT;
++	rnand.ecc.layout = &rbppc_nand_oob_16;
++	rnand.chip_delay = 25;
++	rmtd.priv = &rnand;
++	rmtd.owner = THIS_MODULE;
++
++	if (nand_scan(&rmtd, 1) && nand_scan(&rmtd, 1) && nand_scan(&rmtd, 1) && nand_scan(&rmtd, 1)) {
++		printk(KERN_ERR "rbppc_nand_probe: RouterBOARD NAND device not found\n");
++		return -ENXIO;
++	}
++
++	mtd_device_parse_register(&rmtd, NULL, 0, rbppc_nand_partition_info, 2);
++	init_ok = 1;
++	return 0;
++
++err:
++	kfree(info);
++	return -1;
++}
++
++static struct of_device_id rbppc_nand_ids[] = {
++	{ .name = "nand", },
++	{ },
++};
++
++static struct platform_driver rbppc_nand_driver = {
++	.probe	= rbppc_nand_probe,
++	.driver	= {
++		.name = "rbppc-nand",
++		.owner = THIS_MODULE,
++		.of_match_table = rbppc_nand_ids,
++	},
++};
++
++static int __init rbppc_nand_init(void)
++{
++	return platform_driver_register(&rbppc_nand_driver);
++}
++
++static void __exit rbppc_nand_exit(void)
++{
++	platform_driver_unregister(&rbppc_nand_driver);
++}
++
++MODULE_AUTHOR("Mikrotikls SIA");
++MODULE_AUTHOR("Noah Fontes");
++MODULE_AUTHOR("Michael Guntsche");
++MODULE_DESCRIPTION("MikroTik RouterBOARD 333/600 series NAND driver");
++MODULE_LICENSE("GPL");
++MODULE_VERSION(DRV_VERSION);
++
++module_init(rbppc_nand_init);
++module_exit(rbppc_nand_exit);
diff --git a/target/linux/mpc83xx/patches-3.10/300-mpc8377_wlan-dts-add-openwrt-hacks.patch b/target/linux/mpc83xx/patches-3.10/300-mpc8377_wlan-dts-add-openwrt-hacks.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/mpc83xx/patches-3.10/300-mpc8377_wlan-dts-add-openwrt-hacks.patch
@@ -0,0 +1,23 @@
+--- a/arch/powerpc/boot/dts/mpc8377_wlan.dts
++++ b/arch/powerpc/boot/dts/mpc8377_wlan.dts
+@@ -81,6 +81,11 @@
+ 				reg = <0x3a0000 0x3c60000>;
+ 				label = "rootfs";
+ 			};
++
++			partition1@a0000 {
++				reg = <0xa0000 0x3f60000>;
++				label = "firmware";
++			};
+ 		};
+ 	};
+ 
+@@ -476,4 +481,8 @@
+ 			default-state = "off";
+ 		};
+ 	};
++
++	chosen {
++		bootargs = "console=ttyS0,115200 rootfstype=squashfs noinitrd";
++	};
+ };
