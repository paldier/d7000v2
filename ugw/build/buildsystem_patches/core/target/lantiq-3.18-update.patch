add lantiq kernel patches, mostly for FALCON

diff --git a/target/linux/lantiq/patches-3.18/0031-I2C-MIPS-lantiq-add-FALC-ON-i2c-bus-master.patch b/target/linux/lantiq/patches-3.18/0031-I2C-MIPS-lantiq-add-FALC-ON-i2c-bus-master.patch
--- a/target/linux/lantiq/patches-3.18/0031-I2C-MIPS-lantiq-add-FALC-ON-i2c-bus-master.patch
+++ b/target/linux/lantiq/patches-3.18/0031-I2C-MIPS-lantiq-add-FALC-ON-i2c-bus-master.patch
@@ -1,7 +1,6 @@
-From f17e50f67fa3c77624edf2ca03fae0d50f0ce39b Mon Sep 17 00:00:00 2001
 From: John Crispin <blogic@openwrt.org>
 Date: Thu, 7 Aug 2014 18:26:42 +0200
-Subject: [PATCH 31/36] I2C: MIPS: lantiq: add FALC-ON i2c bus master
+[PATCH 31/36] I2C: MIPS: lantiq: add FALC-ON i2c bus master
 
 This patch adds the driver needed to make the I2C bus work on FALC-ON SoCs.
 
@@ -16,6 +15,7 @@ Signed-off-by: John Crispin <blogic@open
  create mode 100644 drivers/i2c/busses/i2c-lantiq.c
  create mode 100644 drivers/i2c/busses/i2c-lantiq.h
 
+diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
 --- a/drivers/i2c/busses/Kconfig
 +++ b/drivers/i2c/busses/Kconfig
 @@ -553,6 +553,16 @@ config I2C_KEMPLD
@@ -35,6 +35,7 @@ Signed-off-by: John Crispin <blogic@open
  config I2C_MPC
  	tristate "MPC107/824x/85xx/512x/52xx/83xx/86xx"
  	depends on PPC
+diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
 --- a/drivers/i2c/busses/Makefile
 +++ b/drivers/i2c/busses/Makefile
 @@ -53,6 +53,7 @@ obj-$(CONFIG_I2C_IBM_IIC)	+= i2c-ibm_iic
@@ -45,9 +46,11 @@ Signed-off-by: John Crispin <blogic@open
  obj-$(CONFIG_I2C_MPC)		+= i2c-mpc.o
  obj-$(CONFIG_I2C_MV64XXX)	+= i2c-mv64xxx.o
  obj-$(CONFIG_I2C_MXS)		+= i2c-mxs.o
+diff --git a/drivers/i2c/busses/i2c-lantiq.c b/drivers/i2c/busses/i2c-lantiq.c
+new file mode 100644
 --- /dev/null
 +++ b/drivers/i2c/busses/i2c-lantiq.c
-@@ -0,0 +1,747 @@
+@@ -0,0 +1,744 @@
 +
 +/*
 + * Lantiq I2C bus adapter
@@ -82,7 +85,6 @@ Signed-off-by: John Crispin <blogic@open
 +#include <linux/platform_device.h>
 +#include <linux/io.h>
 +#include <linux/of_irq.h>
-+#include <linux/of_i2c.h>
 +
 +#include <lantiq_soc.h>
 +#include "i2c-lantiq.h"
@@ -239,7 +241,7 @@ Signed-off-by: John Crispin <blogic@open
 +		(dec << I2C_FDIV_CFG_DEC_OFFSET),
 +		fdiv_cfg);
 +
-+	dev_info(priv->dev, "setup clocks (in %d kHz, bus %d kHz, dec=%d)\n",
++	dev_info(priv->dev, "setup clocks (in %d Hz, bus %d Hz, dec=%d)\n",
 +		input_clock, priv->i2c_clock, dec);
 +
 +	priv->input_clock = input_clock;
@@ -421,7 +423,7 @@ Signed-off-by: John Crispin <blogic@open
 +
 +	mutex_lock(&priv->mutex);
 +
-+	init_completion(&priv->cmd_complete);
++	reinit_completion(&priv->cmd_complete);
 +	priv->current_msg = msgs;
 +	priv->msgs_num = num;
 +	priv->msg_err = 0;
@@ -621,7 +623,7 @@ Signed-off-by: John Crispin <blogic@open
 +	.functionality	= ltq_i2c_functionality,
 +};
 +
-+static int __devinit ltq_i2c_probe(struct platform_device *pdev)
++static int ltq_i2c_probe(struct platform_device *pdev)
 +{
 +	struct device_node *node = pdev->dev.of_node;
 +	struct ltq_i2c *priv;
@@ -660,9 +662,9 @@ Signed-off-by: John Crispin <blogic@open
 +	init_completion(&priv->cmd_complete);
 +	mutex_init(&priv->mutex);
 +
-+	priv->membase = devm_request_and_ioremap(&pdev->dev, mmres);
-+	if (priv->membase == NULL)
-+		return -ENOMEM;
++	priv->membase = devm_ioremap_resource(&pdev->dev, mmres);
++	if (IS_ERR(priv->membase))
++		return PTR_ERR(priv->membase);
 +
 +	priv->dev = &pdev->dev;
 +	priv->irq_lb = irqres[0].start;
@@ -743,8 +745,6 @@ Signed-off-by: John Crispin <blogic@open
 +		dev_info(&pdev->dev, "version %s\n", DRV_VERSION);
 +	}
 +
-+	of_i2c_register_devices(adap);
-+
 +out:
 +	/* if init failed, we need to deactivate the clock gate */
 +	if (ret)
@@ -753,7 +753,7 @@ Signed-off-by: John Crispin <blogic@open
 +	return ret;
 +}
 +
-+static int __devexit ltq_i2c_remove(struct platform_device *pdev)
++static int ltq_i2c_remove(struct platform_device *pdev)
 +{
 +	struct ltq_i2c *priv = platform_get_drvdata(pdev);
 +
@@ -780,7 +780,7 @@ Signed-off-by: John Crispin <blogic@open
 +
 +static struct platform_driver ltq_i2c_driver = {
 +	.probe	= ltq_i2c_probe,
-+	.remove	= __devexit_p(ltq_i2c_remove),
++	.remove	= ltq_i2c_remove,
 +	.driver	= {
 +		.name	= DRV_NAME,
 +		.owner	= THIS_MODULE,
@@ -795,6 +795,8 @@ Signed-off-by: John Crispin <blogic@open
 +MODULE_ALIAS("platform:" DRV_NAME);
 +MODULE_LICENSE("GPL");
 +MODULE_VERSION(DRV_VERSION);
+diff --git a/drivers/i2c/busses/i2c-lantiq.h b/drivers/i2c/busses/i2c-lantiq.h
+new file mode 100644
 --- /dev/null
 +++ b/drivers/i2c/busses/i2c-lantiq.h
 @@ -0,0 +1,234 @@
diff --git a/target/linux/lantiq/patches-3.18/0340-falcon-easy98000-cpld.patch b/target/linux/lantiq/patches-3.18/0340-falcon-easy98000-cpld.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/0340-falcon-easy98000-cpld.patch
@@ -0,0 +1,439 @@
+simple driver to access the cpld registers on easy98000 incl. LED support
+
+diff --git a/arch/mips/lantiq/falcon/Makefile b/arch/mips/lantiq/falcon/Makefile
+--- a/arch/mips/lantiq/falcon/Makefile
++++ b/arch/mips/lantiq/falcon/Makefile
+@@ -1,1 +1,2 @@
+ obj-y := prom.o reset.o sysctrl.o
++obj-y += addon-easy98000.o dev-leds-easy98000-cpld.o
+diff --git a/arch/mips/lantiq/falcon/addon-easy98000.c b/arch/mips/lantiq/falcon/addon-easy98000.c
+new file mode 100644
+--- /dev/null
++++ b/arch/mips/lantiq/falcon/addon-easy98000.c
+@@ -0,0 +1,247 @@
++/*
++ *  EASY98000 CPLD Addon driver
++ *
++ *  Copyright (C) 2011 Thomas Langer <thomas.langer@lantiq.com>
++ *
++ *  This program is free software; you can redistribute it and/or modify it
++ *  under the terms of the GNU General Public License version 2  as published
++ *  by the Free Software Foundation.
++ *
++ */
++
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/version.h>
++#include <linux/types.h>
++#include <linux/init.h>
++#include <linux/platform_device.h>
++#include <linux/of_platform.h>
++#include <linux/errno.h>
++#include <linux/slab.h>
++#include <linux/proc_fs.h>
++#include <linux/seq_file.h>
++
++struct easy98000_reg_cpld {
++	u16 cmdreg1;		/* 0x1 */
++	u16 cmdreg0;		/* 0x0 */
++	u16 idreg0;		/* 0x3 */
++	u16 resreg;		/* 0x2 */
++	u16 intreg;		/* 0x5 */
++	u16 idreg1;		/* 0x4 */
++	u16 ledreg;		/* 0x7 */
++	u16 pcmconconfig;	/* 0x6 */
++	u16 res0;		/* 0x9 */
++	u16 ethledreg;		/* 0x8 */
++	u16 res1[4];		/* 0xa-0xd */
++	u16 cpld1v;		/* 0xf */
++	u16 cpld2v;		/* 0xe */
++};
++static struct easy98000_reg_cpld * const cpld =
++	(struct easy98000_reg_cpld *)(KSEG1 | 0x17c00000);
++#define cpld_r8(reg) (__raw_readw(&cpld->reg) & 0xFF)
++#define cpld_w8(val, reg) __raw_writew((val) & 0xFF, &cpld->reg)
++
++int easy98000_addon_has_dm9000(void)
++{
++	if ((cpld_r8(idreg0) & 0xF) == 1)
++		return 1;
++	return 0;
++}
++
++#if defined(CONFIG_PROC_FS)
++typedef void (*cpld_dump) (struct seq_file *s);
++struct proc_entry {
++	char *name;
++	void *callback;
++};
++
++static int cpld_proc_show ( struct seq_file *s, void *p )
++{
++	cpld_dump dump = s->private;
++
++	if ( dump != NULL )
++		dump(s);
++
++	return 0;
++}
++
++static int cpld_proc_open ( struct inode *inode, struct file *file )
++{
++	return single_open ( file, cpld_proc_show, PDE_DATA(inode) );
++}
++
++static void cpld_versions_get ( struct seq_file *s )
++{
++	seq_printf(s, "CPLD1: V%d\n", cpld_r8(cpld1v));
++	seq_printf(s, "CPLD2: V%d\n", cpld_r8(cpld2v));
++}
++
++static void cpld_ebu_module_get ( struct seq_file *s )
++{
++	u8 addon_id;
++
++	addon_id = cpld_r8(idreg0) & 0xF;
++	switch (addon_id) {
++	case 0xF: /* nothing connected */
++		break;
++	case 1:
++		seq_printf(s, "Ethernet Controller module (dm9000)\n");
++		break;
++	default:
++		seq_printf(s, "Unknown EBU module (EBU_ID=0x%02X)\n", addon_id);
++		break;
++	}
++}
++
++static void cpld_xmii_module_get ( struct seq_file *s )
++{
++	u8 addon_id;
++	char *mod = NULL;
++
++	addon_id = cpld_r8(idreg1) & 0xF;
++	switch (addon_id) {
++	case 0xF:
++		mod = "no module";
++		break;
++	case 0x1:
++		mod = "RGMII module";
++		break;
++	case 0x4:
++		mod = "GMII MAC Mode (XWAY TANTOS-3G)";
++		break;
++	case 0x5:
++		mod = "MII MAC Mode (XWAY TANTOS-3G)";
++		break;
++	case 0x6:
++		mod = "TMII MAC Mode (XWAY TANTOS-3G)";
++		break;
++	case 0x8:
++		mod = "GMII PHY module";
++		break;
++	case 0x9:
++		mod = "MII PHY module";
++		break;
++	case 0xA:
++		mod = "RMII PHY module";
++		break;
++	default:
++		break;
++	}
++	if (mod)
++		seq_printf(s, "%s\n", mod);
++	else
++		seq_printf(s, "unknown xMII module (xMII_ID=0x%02X)\n", addon_id);
++}
++
++static void cpld_sgmii_module_get ( struct seq_file *s )
++{
++	u8 addon_id;
++	char *mod = NULL;
++
++	addon_id = cpld_r8(idreg1)>>4 & 0xF;
++	switch (addon_id) {
++	case 0xF:
++		mod = "no module";
++		break;
++	case 0x1:
++		mod = "SGMII module";
++		break;
++	default:
++		mod = NULL;
++		break;
++	}
++	if (mod)
++		seq_printf(s, "%s\n", mod);
++	else
++		seq_printf(s, "unknown module (SGMII_ID=0x%02X) found\n", addon_id);
++}
++
++static struct proc_entry proc_entries[] = {
++	{"versions",	cpld_versions_get},
++	{"ebu",		cpld_ebu_module_get},
++	{"xmii",	cpld_xmii_module_get},
++	{"sgmii",	cpld_sgmii_module_get},
++};
++
++static struct file_operations ops = {
++	.owner   = THIS_MODULE,
++	.open    = cpld_proc_open,
++	.read    = seq_read,
++	.llseek  = seq_lseek,
++	.release = single_release,
++};
++
++static void cpld_proc_entry_create(struct proc_dir_entry *parent_node,
++				   struct proc_entry *proc_entry)
++{
++	proc_create_data ( proc_entry->name, (S_IFREG | S_IRUGO), parent_node,
++			   &ops, proc_entry->callback);
++}
++
++static int cpld_proc_install(void)
++{
++	struct proc_dir_entry *driver_proc_node;
++
++	driver_proc_node = proc_mkdir("cpld", NULL);
++	if (driver_proc_node != NULL) {
++		int i;
++		for (i = 0; i < ARRAY_SIZE(proc_entries); i++)
++			cpld_proc_entry_create(driver_proc_node,
++					      &proc_entries[i]);
++	} else {
++		printk("cannot create proc entry");
++		return -1;
++	}
++	return 0;
++}
++#else
++static inline int cpld_proc_install(void) {}
++#endif
++
++static int easy98000_addon_probe(struct platform_device *pdev)
++{
++	return cpld_proc_install();
++}
++
++static int easy98000_addon_remove(struct platform_device *pdev)
++{
++#if defined(CONFIG_PROC_FS)
++	char buf[64];
++	int i;
++
++	for (i = 0; i < sizeof(proc_entries) / sizeof(proc_entries[0]); i++) {
++		sprintf(buf, "cpld/%s", proc_entries[i].name);
++		remove_proc_entry(buf, 0);
++	}
++	remove_proc_entry("cpld", 0);
++#endif
++	return 0;
++}
++
++static const struct of_device_id easy98000_addon_match[] = {
++	{.compatible = "lantiq,easy98000_addon" },
++	{},
++};
++
++static struct platform_driver easy98000_addon_driver = {
++	.probe = easy98000_addon_probe,
++	.remove = easy98000_addon_remove,
++	.driver = {
++		.name = "easy98000_addon",
++		.owner = THIS_MODULE,
++		.of_match_table = easy98000_addon_match,
++	},
++};
++
++int __init easy98000_addon_init(void)
++{
++	return platform_driver_register(&easy98000_addon_driver);
++}
++
++void __exit easy98000_addon_exit(void)
++{
++	platform_driver_unregister(&easy98000_addon_driver);
++}
++
++module_init(easy98000_addon_init);
++module_exit(easy98000_addon_exit);
+diff --git a/arch/mips/lantiq/falcon/dev-leds-easy98000-cpld.c b/arch/mips/lantiq/falcon/dev-leds-easy98000-cpld.c
+new file mode 100644
+--- /dev/null
++++ b/arch/mips/lantiq/falcon/dev-leds-easy98000-cpld.c
+@@ -0,0 +1,174 @@
++/*
++ *  EASY98000 CPLD LED driver
++ *
++ *  Copyright (C) 2013 Ralph Hempel <ralph.hempel@lantiq.com>
++ *
++ *  This program is free software; you can redistribute it and/or modify it
++ *  under the terms of the GNU General Public License version 2  as published
++ *  by the Free Software Foundation.
++ *
++ */
++
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/version.h>
++#include <linux/types.h>
++#include <linux/init.h>
++#include <linux/platform_device.h>
++#include <linux/of_platform.h>
++#include <linux/errno.h>
++#include <linux/leds.h>
++#include <linux/slab.h>
++
++#ifdef CONFIG_LEDS_CLASS
++
++#define LED_NAME	"easy98000_cpld_led"
++#define LED_DESC	"EASY98000 LED driver"
++#define LED_VERSION	"1.0.1"
++
++#define MAX_LED		16
++
++const char *led_name[8] = {
++	"ge0_act",
++	"ge0_link",
++	"ge1_act",
++	"ge1_link",
++	"fe2_act",
++	"fe2_link",
++	"fe3_act",
++	"fe3_link"
++};
++
++#define cpld_base7			((u16 *)(KSEG1 | 0x17c0000c))
++#define cpld_base8			((u16 *)(KSEG1 | 0x17c00012))
++
++#define ltq_r16(reg)			__raw_readw(reg)
++#define ltq_w16(val, reg)		__raw_writew(val, reg)
++
++struct cpld_led_dev {
++	struct led_classdev	cdev;
++	u8			mask;
++	u16			*base;
++};
++
++struct cpld_led_drvdata {
++	struct cpld_led_dev	*led_devs;
++	int			num_leds;
++};
++
++void led_set(u8 mask, u16 *base)
++{
++	ltq_w16(ltq_r16(base) | mask, base);
++}
++
++void led_clear(u8 mask, u16 *base)
++{
++	ltq_w16(ltq_r16(base) & (~mask), base);
++}
++
++void led_blink_clear(u8 mask, u16 *base)
++{
++	led_clear(mask, base);
++}
++
++static void led_brightness(struct led_classdev *led_cdev,
++			       enum led_brightness value)
++{
++	struct cpld_led_dev *led_dev =
++	    container_of(led_cdev, struct cpld_led_dev, cdev);
++
++	if (value)
++		led_set(led_dev->mask, led_dev->base);
++	else
++		led_clear(led_dev->mask, led_dev->base);
++}
++
++static int led_probe(struct platform_device *pdev)
++{
++	int i;
++	char name[32];
++	struct cpld_led_drvdata *drvdata;
++	int ret = 0;
++
++	drvdata = kzalloc(sizeof(struct cpld_led_drvdata) +
++			  sizeof(struct cpld_led_dev) * MAX_LED,
++			  GFP_KERNEL);
++	if (!drvdata)
++		return -ENOMEM;
++
++	drvdata->led_devs = (struct cpld_led_dev *) &drvdata[1];
++
++	for (i = 0; i < MAX_LED; i++) {
++		struct cpld_led_dev *led_dev = &drvdata->led_devs[i];
++		led_dev->cdev.brightness_set = led_brightness;
++		led_dev->cdev.default_trigger = NULL;
++		led_dev->mask = 1 << (i % 8);
++		if(i < 8) {
++			sprintf(name, "easy98000-cpld:%s", led_name[i]);
++			led_dev->base = cpld_base8;
++		} else {
++			sprintf(name, "easy98000-cpld:red:%d", i-8);
++			led_dev->base = cpld_base7;
++		}
++		led_dev->cdev.name = name;
++		ret = led_classdev_register(&pdev->dev, &led_dev->cdev);
++		if (ret)
++			goto err;
++	}
++	platform_set_drvdata(pdev, drvdata);
++	return 0;
++
++err:
++	for (i = i - 1; i >= 0; i--)
++		led_classdev_unregister(&drvdata->led_devs[i].cdev);
++
++	kfree(drvdata);
++	return ret;
++}
++
++static int led_remove(struct platform_device *pdev)
++{
++	int i;
++	struct cpld_led_drvdata *drvdata = platform_get_drvdata(pdev);
++	for (i = 0; i < MAX_LED; i++)
++		led_classdev_unregister(&drvdata->led_devs[i].cdev);
++	kfree(drvdata);
++	return 0;
++}
++
++static const struct of_device_id led_driver_match[] = {
++	{.compatible = "lantiq,easy98000_cpld_led" },
++	{},
++};
++
++static struct platform_driver led_driver = {
++	.probe = led_probe,
++	.remove = led_remove,
++	.driver = {
++		.name = LED_NAME,
++		.owner = THIS_MODULE,
++		.of_match_table = led_driver_match,
++		},
++};
++
++int __init easy98000_cpld_led_init(void)
++{
++	pr_info(LED_DESC ", Version " LED_VERSION
++		" (c) Copyright 2013, Lantiq Deutschland GmbH\n");
++	return platform_driver_register(&led_driver);
++}
++
++void __exit easy98000_cpld_led_exit(void)
++{
++	platform_driver_unregister(&led_driver);
++}
++
++module_init(easy98000_cpld_led_init);
++module_exit(easy98000_cpld_led_exit);
++
++MODULE_DESCRIPTION(LED_NAME);
++MODULE_DESCRIPTION(LED_DESC);
++MODULE_AUTHOR("Ralph Hempel <ralph.hempel@lantiq.com>");
++MODULE_LICENSE("GPL v2");
++
++#endif /* CONFIG_LEDS_CLASS */
diff --git a/target/linux/lantiq/patches-3.18/0500-MIPS-lantiq-VPE-extensions.patch b/target/linux/lantiq/patches-3.18/0500-MIPS-lantiq-VPE-extensions.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/0500-MIPS-lantiq-VPE-extensions.patch
@@ -0,0 +1,983 @@
+From: John Crispin <blogic@openwrt.org>
+Date: Thu, 29 Sep 2011 20:30:40 +0200
+
+[PATCH 15/25] VPE extensions
+
+From 1a3548545403c8f7cc02317643b616db6d0c9a4b Mon Sep 17 00:00:00 2001
+---
+ arch/mips/Kconfig                  |   22 +++
+ arch/mips/include/asm/mipsmtregs.h |   54 +++++++
+ arch/mips/kernel/Makefile          |    3 +-
+ arch/mips/kernel/mips-mt.c         |   97 +++++++++++--
+ arch/mips/kernel/mtsched_proc.c    |  279 ++++++++++++++++++++++++++++++++++++
+ arch/mips/kernel/perf_proc.c       |  191 ++++++++++++++++++++++++
+ arch/mips/kernel/proc.c            |   17 +++
+ arch/mips/kernel/smtc.c            |    7 +
+ arch/mips/kernel/vpe.c             |  250 ++++++++++++++++++++++++++++++++-
+ 9 files changed, 905 insertions(+), 15 deletions(-)
+ create mode 100644 arch/mips/kernel/mtsched_proc.c
+ create mode 100644 arch/mips/kernel/perf_proc.c
+
+diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -1999,6 +1999,28 @@ config MIPS_VPE_LOADER
+ 	  Includes a loader for loading an elf relocatable object
+ 	  onto another VPE and running it.
+ 
++config IFX_VPE_EXT
++	bool "IFX APRP Extensions"
++	depends on MIPS_VPE_LOADER
++	default y
++	help
++	  IFX included extensions in APRP
++
++config PERFCTRS
++	bool "34K Performance counters"
++	depends on MIPS_MT && PROC_FS
++	default n
++	help
++	  34K Performance counter through /proc
++
++config MTSCHED
++	bool "Support mtsched priority configuration for TCs"
++	depends on MIPS_MT && PROC_FS
++	default y
++	help
++	  Support for mtsched priority configuration for TCs through
++	  /proc/mips/mtsched
++
+ config MIPS_VPE_LOADER_CMP
+ 	bool
+ 	default "y"
+diff --git a/arch/mips/include/asm/mipsmtregs.h b/arch/mips/include/asm/mipsmtregs.h
+--- a/arch/mips/include/asm/mipsmtregs.h
++++ b/arch/mips/include/asm/mipsmtregs.h
+@@ -31,16 +31,32 @@
+ #define read_c0_vpeconf1()		__read_32bit_c0_register($1, 3)
+ #define write_c0_vpeconf1(val)		__write_32bit_c0_register($1, 3, val)
+ 
++#define read_c0_vpeschedule()           __read_32bit_c0_register($1, 5)
++#define write_c0_vpeschedule(val)       __write_32bit_c0_register($1, 5, val)
++
++#define read_c0_vpeschefback()      	__read_32bit_c0_register($1, 6)
++#define write_c0_vpeschefback(val)  	__write_32bit_c0_register($1, 6, val)
++
++#define read_c0_vpeopt()              __read_32bit_c0_register($1, 7)
++#define write_c0_vpeopt(val)          __write_32bit_c0_register($1, 7, val)
++
+ #define read_c0_tcstatus()		__read_32bit_c0_register($2, 1)
+ #define write_c0_tcstatus(val)		__write_32bit_c0_register($2, 1, val)
+ 
+ #define read_c0_tcbind()		__read_32bit_c0_register($2, 2)
++#define write_c0_tcbind(val)		__write_32bit_c0_register($2, 2, val)
+ 
+ #define write_c0_tchalt(val)		__write_32bit_c0_register($2, 4, val)
+ 
+ #define read_c0_tccontext()		__read_32bit_c0_register($2, 5)
+ #define write_c0_tccontext(val)		__write_32bit_c0_register($2, 5, val)
+ 
++#define read_c0_tcschedule()		__read_32bit_c0_register($2, 6)
++#define write_c0_tcschedule(val)	__write_32bit_c0_register($2, 6, val)
++
++#define read_c0_tcschefback()		__read_32bit_c0_register($2, 7)
++#define write_c0_tcschefback(val)	__write_32bit_c0_register($2, 7, val)
++
+ #else /* Assembly */
+ /*
+  * Macros for use in assembly language code
+@@ -79,6 +95,8 @@
+ #define MVPCONTROL_STLB_SHIFT	2
+ #define MVPCONTROL_STLB		(_ULCAST_(1) << MVPCONTROL_STLB_SHIFT)
+ 
++#define MVPCONTROL_CPA_SHIFT	3
++#define MVPCONTROL_CPA		(_ULCAST_(1) << MVPCONTROL_CPA_SHIFT)
+ 
+ /* MVPConf0 fields */
+ #define MVPCONF0_PTC_SHIFT	0
+@@ -89,6 +107,8 @@
+ #define MVPCONF0_TCA		( _ULCAST_(1) << MVPCONF0_TCA_SHIFT)
+ #define MVPCONF0_PTLBE_SHIFT	16
+ #define MVPCONF0_PTLBE		(_ULCAST_(0x3ff) << MVPCONF0_PTLBE_SHIFT)
++#define MVPCONF0_PCP_SHIFT	27
++#define MVPCONF0_PCP		(_ULCAST_(1) << MVPCONF0_PCP_SHIFT)
+ #define MVPCONF0_TLBS_SHIFT	29
+ #define MVPCONF0_TLBS		(_ULCAST_(1) << MVPCONF0_TLBS_SHIFT)
+ #define MVPCONF0_M_SHIFT	31
+@@ -126,9 +146,25 @@
+ #define VPECONF0_VPA		(_ULCAST_(1) << VPECONF0_VPA_SHIFT)
+ #define VPECONF0_MVP_SHIFT	1
+ #define VPECONF0_MVP		(_ULCAST_(1) << VPECONF0_MVP_SHIFT)
++#define VPECONF0_ICS_SHIFT	16
++#define VPECONF0_ICS		(_ULCAST_(1) << VPECONF0_ICS_SHIFT)
++#define VPECONF0_DCS_SHIFT	17
++#define VPECONF0_DCS		(_ULCAST_(1) << VPECONF0_DCS_SHIFT)
+ #define VPECONF0_XTC_SHIFT	21
+ #define VPECONF0_XTC		(_ULCAST_(0xff) << VPECONF0_XTC_SHIFT)
+ 
++/* VPEOpt fields */
++#define VPEOPT_DWX_SHIFT	0
++#define VPEOPT_IWX_SHIFT	8
++#define VPEOPT_IWX0		( _ULCAST_(0x1) << VPEOPT_IWX_SHIFT)
++#define VPEOPT_IWX1		( _ULCAST_(0x2) << VPEOPT_IWX_SHIFT)
++#define VPEOPT_IWX2		( _ULCAST_(0x4) << VPEOPT_IWX_SHIFT)
++#define VPEOPT_IWX3		( _ULCAST_(0x8) << VPEOPT_IWX_SHIFT)
++#define VPEOPT_DWX0		( _ULCAST_(0x1) << VPEOPT_DWX_SHIFT)
++#define VPEOPT_DWX1		( _ULCAST_(0x2) << VPEOPT_DWX_SHIFT)
++#define VPEOPT_DWX2		( _ULCAST_(0x4) << VPEOPT_DWX_SHIFT)
++#define VPEOPT_DWX3		( _ULCAST_(0x8) << VPEOPT_DWX_SHIFT)
++
+ /* VPEConf1 fields (per VPE) */
+ #define VPECONF1_NCP1_SHIFT	0
+ #define VPECONF1_NCP1		(_ULCAST_(0xff) << VPECONF1_NCP1_SHIFT)
+@@ -376,6 +412,14 @@ do {									\
+ #define write_vpe_c0_vpeconf0(val)	mttc0(1, 2, val)
+ #define read_vpe_c0_vpeconf1()		mftc0(1, 3)
+ #define write_vpe_c0_vpeconf1(val)	mttc0(1, 3, val)
++#define read_vpe_c0_vpeschedule()	mftc0(1, 5)
++#define write_vpe_c0_vpeschedule(val)	mttc0(1, 5, val)
++#define read_vpe_c0_vpeschefback()	mftc0(1, 6)
++#define write_vpe_c0_vpeschefback(val)	mttc0(1, 6, val)
++#define read_vpe_c0_vpeopt()		mftc0(1, 7)
++#define write_vpe_c0_vpeopt(val)	mttc0(1, 7, val)
++#define read_vpe_c0_wired()		mftc0(6, 0)
++#define write_vpe_c0_wired(val)		mttc0(6, 0, val)
+ #define read_vpe_c0_count()		mftc0(9, 0)
+ #define write_vpe_c0_count(val)		mttc0(9, 0, val)
+ #define read_vpe_c0_status()		mftc0(12, 0)
+@@ -407,6 +451,12 @@ do {									\
+ #define write_tc_c0_tchalt(val)		mttc0(2, 4, val)
+ #define read_tc_c0_tccontext()		mftc0(2, 5)
+ #define write_tc_c0_tccontext(val)	mttc0(2, 5, val)
++#define read_tc_c0_tcschedule()		mftc0(2, 6)
++#define write_tc_c0_tcschedule(val)	mttc0(2, 6, val)
++#define read_tc_c0_tcschefback()	mftc0(2, 7)
++#define write_tc_c0_tcschefback(val)	mttc0(2, 7, val)
++#define read_tc_c0_entryhi()            mftc0(10, 0)
++#define write_tc_c0_entryhi(val)        mttc0(10, 0, val)
+ 
+ /* GPR */
+ #define read_tc_gpr_sp()		mftgpr(29)
+diff --git a/arch/mips/include/asm/vpe.h b/arch/mips/include/asm/vpe.h
+--- a/arch/mips/include/asm/vpe.h
++++ b/arch/mips/include/asm/vpe.h
+@@ -38,6 +38,17 @@ static inline int aprp_cpu_index(void)
+ #endif
+ }
+ 
++/* For the explanation of the APIs please refer the section "MT APRP Kernel
++ * Programming" in AR9 SW Architecture Specification
++ */
++int32_t vpe1_sw_start(void* sw_start_addr, uint32_t tcmask, uint32_t flags);
++int32_t vpe1_sw_stop(uint32_t flags);
++uint32_t vpe1_get_load_addr(uint32_t flags);
++uint32_t vpe1_get_max_mem(uint32_t flags);
++
++int32_t vpe1_set_boot_param(char *field, char *value, char flags);
++int32_t vpe1_get_boot_param(char *field, char **value, char flags);
++
+ enum vpe_state {
+ 	VPE_STATE_UNUSED = 0,
+ 	VPE_STATE_INUSE,
+diff --git a/arch/mips/kernel/Makefile b/arch/mips/kernel/Makefile
+--- a/arch/mips/kernel/Makefile
++++ b/arch/mips/kernel/Makefile
+@@ -79,7 +79,8 @@ obj-$(CONFIG_MIPS32_O32)	+= binfmt_elfo3
+ 
+ obj-$(CONFIG_KGDB)		+= kgdb.o
+ obj-$(CONFIG_PROC_FS)		+= proc.o
+-
++obj-$(CONFIG_MTSCHED)		+= mtsched_proc.o
++obj-$(CONFIG_PERFCTRS)		+= perf_proc.o
+ obj-$(CONFIG_64BIT)		+= cpu-bugs64.o
+ 
+ obj-$(CONFIG_I8253)		+= i8253.o
+diff --git a/arch/mips/kernel/mips-mt.c b/arch/mips/kernel/mips-mt.c
+--- a/arch/mips/kernel/mips-mt.c
++++ b/arch/mips/kernel/mips-mt.c
+@@ -20,26 +20,96 @@
+ #include <asm/cacheflush.h>
+ 
+ int vpelimit;
+-
+ static int __init maxvpes(char *str)
+ {
+ 	get_option(&str, &vpelimit);
+-
+ 	return 1;
+ }
+-
+ __setup("maxvpes=", maxvpes);
+ 
+ int tclimit;
+-
+ static int __init maxtcs(char *str)
+ {
+ 	get_option(&str, &tclimit);
+-
+ 	return 1;
+ }
++__setup("maxtcs=", maxtcs);
+ 
+-__setup("maxtcs=", maxtcs);
++#ifdef CONFIG_IFX_VPE_EXT
++int stlb;
++static int __init istlbshared(char *str)
++{
++	get_option(&str, &stlb);
++	return 1;
++}
++__setup("vpe_tlb_shared=", istlbshared);
++
++int vpe0_wired;
++static int __init vpe0wired(char *str)
++{
++	get_option(&str, &vpe0_wired);
++	return 1;
++}
++__setup("vpe0_wired_tlb_entries=", vpe0wired);
++
++int vpe1_wired;
++static int __init vpe1wired(char *str)
++{
++	get_option(&str, &vpe1_wired);
++	return 1;
++}
++__setup("vpe1_wired_tlb_entries=", vpe1wired);
++
++#ifdef CONFIG_MIPS_MT_SMTC
++extern int nostlb;
++#endif
++void configure_tlb(void)
++{
++	int vpeflags, tcflags, tlbsiz;
++	unsigned int config1val;
++	vpeflags = dvpe();
++	tcflags = dmt();
++	write_c0_vpeconf0((read_c0_vpeconf0() | VPECONF0_MVP));
++	write_c0_mvpcontrol((read_c0_mvpcontrol() | MVPCONTROL_VPC));
++	mips_ihb();
++	//printk("stlb = %d, vpe0_wired = %d vpe1_wired=%d\n", stlb,vpe0_wired, vpe1_wired);
++	if (stlb) {
++		if (!(read_c0_mvpconf0() & MVPCONF0_TLBS)) {
++			emt(tcflags);
++			evpe(vpeflags);
++			return;
++		}
++
++		write_c0_mvpcontrol(read_c0_mvpcontrol() | MVPCONTROL_STLB);
++		write_c0_wired(vpe0_wired + vpe1_wired);
++		if (((read_vpe_c0_config() & MIPS_CONF_MT) >> 7) == 1) {
++			config1val = read_vpe_c0_config1();
++			tlbsiz = (((config1val >> 25) & 0x3f) + 1);
++			if (tlbsiz > 64)
++				tlbsiz = 64;
++			cpu_data[0].tlbsize = tlbsiz;
++			current_cpu_data.tlbsize = tlbsiz;
++		}
++
++	}
++	else {
++		write_c0_mvpcontrol(read_c0_mvpcontrol() & ~MVPCONTROL_STLB);
++		write_c0_wired(vpe0_wired);
++	}
++
++	ehb();
++	write_c0_mvpcontrol((read_c0_mvpcontrol() & ~MVPCONTROL_VPC));
++	ehb();
++	local_flush_tlb_all();
++
++	printk("Wired TLB entries for Linux read_c0_wired() = %d\n", read_c0_wired());
++#ifdef CONFIG_MIPS_MT_SMTC
++	nostlb = !stlb;
++#endif
++	emt(tcflags);
++	evpe(vpeflags);
++}
++#endif
+ 
+ /*
+  * Dump new MIPS MT state for the core. Does not leave TCs halted.
+@@ -74,18 +144,18 @@ void mips_mt_regdump(unsigned long mvpct
+ 			if ((read_tc_c0_tcbind() & TCBIND_CURVPE) == i) {
+ 				printk("  VPE %d\n", i);
+ 				printk("   VPEControl : %08lx\n",
+-				       read_vpe_c0_vpecontrol());
++					read_vpe_c0_vpecontrol());
+ 				printk("   VPEConf0 : %08lx\n",
+-				       read_vpe_c0_vpeconf0());
++					read_vpe_c0_vpeconf0());
+ 				printk("   VPE%d.Status : %08lx\n",
+-				       i, read_vpe_c0_status());
++					i, read_vpe_c0_status());
+ 				printk("   VPE%d.EPC : %08lx %pS\n",
+-				       i, read_vpe_c0_epc(),
+-				       (void *) read_vpe_c0_epc());
++					i, read_vpe_c0_epc(),
++					(void *) read_vpe_c0_epc());
+ 				printk("   VPE%d.Cause : %08lx\n",
+-				       i, read_vpe_c0_cause());
++					i, read_vpe_c0_cause());
+ 				printk("   VPE%d.Config7 : %08lx\n",
+-				       i, read_vpe_c0_config7());
++					i, read_vpe_c0_config7());
+ 				break; /* Next VPE */
+ 			}
+ 		}
+@@ -280,6 +350,9 @@ void mips_mt_set_cpuoptions(void)
+ 		printk("Mapped %ld ITC cells starting at 0x%08x\n",
+ 			((itcblkgrn & 0x7fe00000) >> 20), itc_base);
+ 	}
++#ifdef CONFIG_IFX_VPE_EXT
++	configure_tlb();
++#endif
+ }
+ 
+ /*
+diff --git a/arch/mips/kernel/mtsched_proc.c b/arch/mips/kernel/mtsched_proc.c
+new file mode 100644
+--- /dev/null
++++ b/arch/mips/kernel/mtsched_proc.c
+@@ -0,0 +1,282 @@
++/*
++ * /proc hooks for MIPS MT scheduling policy management for 34K cores
++ *
++ *  This program is free software; you can distribute it and/or modify it
++ *  under the terms of the GNU General Public License (Version 2) as
++ *  published by the Free Software Foundation.
++ *
++ *  This program is distributed in the hope it will be useful, but WITHOUT
++ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
++ *  for more details.
++ *
++ *  You should have received a copy of the GNU General Public License along
++ *  with this program; if not, write to the Free Software Foundation, Inc.,
++ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
++ *
++ * Copyright (C) 2006 Mips Technologies, Inc
++ */
++
++#include <linux/kernel.h>
++
++#include <asm/cpu.h>
++#include <asm/processor.h>
++#include <asm/setup.h>
++#include <asm/mipsregs.h>
++#include <asm/mipsmtregs.h>
++#include <asm/uaccess.h>
++#include <linux/proc_fs.h>
++#include <linux/seq_file.h>
++
++/*static struct proc_dir_entry *mtsched_proc;*/
++
++#ifndef CONFIG_MIPS_MT_SMTC
++#define NTCS 2
++#else
++#define NTCS NR_CPUS
++#endif
++#define NVPES 2
++
++int lastvpe = 1;
++int lasttc = 8;
++
++static int proc_read_mtsched (struct seq_file *s)
++{
++	int i;
++	int vpe;
++	int mytc;
++	unsigned long flags;
++	unsigned int mtflags;
++	unsigned int haltstate;
++	unsigned int vpes_checked[NVPES];
++	unsigned int vpeschedule[NVPES];
++	unsigned int vpeschefback[NVPES];
++	unsigned int tcschedule[NTCS];
++	unsigned int tcschefback[NTCS];
++
++	/* Dump the state of the MIPS MT scheduling policy manager */
++	/* Inititalize control state */
++	for(i = 0; i < NVPES; i++) {
++		vpes_checked[i] = 0;
++		vpeschedule[i] = 0;
++		vpeschefback[i] = 0;
++	}
++	for(i = 0; i < NTCS; i++) {
++		tcschedule[i] = 0;
++		tcschefback[i] = 0;
++	}
++	
++	/* Disable interrupts and multithreaded issue */
++	local_irq_save(flags);
++	mtflags = dvpe();
++
++	/* Then go through the TCs, halt 'em, and extract the values */
++	mytc = (read_c0_tcbind() & TCBIND_CURTC) >> TCBIND_CURTC_SHIFT;
++	for(i = 0; i < NTCS; i++) {
++		if(i == mytc) {
++			/* No need to halt ourselves! */
++			tcschedule[i] = read_c0_tcschedule();
++			tcschefback[i] = read_c0_tcschefback();
++			/* If VPE bound to TC hasn't been checked, do it */
++			vpe = read_c0_tcbind() & TCBIND_CURVPE;
++			if(!vpes_checked[vpe]) {
++				vpeschedule[vpe] = read_c0_vpeschedule();
++				vpeschefback[vpe] = read_c0_vpeschefback();
++				vpes_checked[vpe] = 1;
++			}
++		} else {
++			settc(i);
++			haltstate = read_tc_c0_tchalt();
++			write_tc_c0_tchalt(TCHALT_H);
++			mips_ihb();
++			tcschedule[i] = read_tc_c0_tcschedule();
++			tcschefback[i] = read_tc_c0_tcschefback();
++			/* If VPE bound to TC hasn't been checked, do it */
++			vpe = read_tc_c0_tcbind() & TCBIND_CURVPE;
++			if(!vpes_checked[vpe]) {
++			    vpeschedule[vpe] = read_vpe_c0_vpeschedule();
++			    vpeschefback[vpe] = read_vpe_c0_vpeschefback();
++			    vpes_checked[vpe] = 1;
++			}
++			if(!haltstate) write_tc_c0_tchalt(0);
++		}
++	}
++	/* Re-enable MT and interrupts */
++	evpe(mtflags);
++	local_irq_restore(flags);
++	for(vpe=0; vpe < NVPES; vpe++) {
++		seq_printf(s, "VPE[%d].VPEschedule  = 0x%08x\n",
++			vpe, vpeschedule[vpe]);
++		seq_printf(s, "VPE[%d].VPEschefback = 0x%08x\n",
++			vpe, vpeschefback[vpe]);
++	}
++	for(i=0; i < NTCS; i++) {
++		seq_printf(s, "TC[%d].TCschedule    = 0x%08x\n",
++			i, tcschedule[i]);
++		seq_printf(s, "TC[%d].TCschefback   = 0x%08x\n",
++			i, tcschefback[i]);
++	}
++
++	return 0;
++}
++
++/*
++ * Write to perf counter registers based on text input
++ */
++
++#define TXTBUFSZ 100
++static int proc_write_mtsched(struct file *file, const __user char *buffer,
++				size_t count, loff_t *offset)
++{
++	int len = 0;
++	char mybuf[TXTBUFSZ];
++	/* At most, we will set up 9 TCs and 2 VPEs, 11 entries in all */
++	char entity[1];   //, entity1[1];
++	int number[1];
++	unsigned long value[1];
++	int nparsed = 0 , index = 0;
++	unsigned long flags;
++	unsigned int mtflags;
++	unsigned int haltstate;
++	unsigned int tcbindval;
++
++	if(count >= TXTBUFSZ) len = TXTBUFSZ-1;
++	else len = count;
++	memset(mybuf,0,TXTBUFSZ);
++	if(copy_from_user(mybuf, buffer, len)) return -EFAULT;
++
++	nparsed = sscanf(mybuf, "%c%d %lx",
++		 &entity[0] ,&number[0], &value[0]);
++
++	/*
++	 * Having acquired the inputs, which might have
++	 * generated exceptions and preemptions,
++	 * program the registers.
++	 */
++	/* Disable interrupts and multithreaded issue */
++	local_irq_save(flags);
++	mtflags = dvpe();
++
++	if(entity[index] == 't' ) {
++		/* Set TCSchedule or TCScheFBack of specified TC */
++		if(number[index] > NTCS) goto skip;
++		/* If it's our own TC, do it direct */
++		if(number[index] ==
++				((read_c0_tcbind() & TCBIND_CURTC)
++				>> TCBIND_CURTC_SHIFT)) {
++			if(entity[index] == 't')
++				 write_c0_tcschedule(value[index]);
++			else
++				write_c0_tcschefback(value[index]);
++		} else {
++		/* Otherwise, we do it via MTTR */
++			settc(number[index]);
++			haltstate = read_tc_c0_tchalt();
++			write_tc_c0_tchalt(TCHALT_H);
++			mips_ihb();
++			if(entity[index] == 't')
++				 write_tc_c0_tcschedule(value[index]);
++			else
++				write_tc_c0_tcschefback(value[index]);
++			mips_ihb();
++			if(!haltstate) write_tc_c0_tchalt(0);
++		}
++	} else if(entity[index] == 'v') {
++		/* Set VPESchedule of specified VPE */
++		if(number[index] > NVPES) goto skip;
++		tcbindval = read_c0_tcbind();
++		/* Are we doing this to our current VPE? */
++		if((tcbindval & TCBIND_CURVPE) == number[index]) {
++			/* Then life is simple */
++			write_c0_vpeschedule(value[index]);
++		} else {
++			/*
++			 * Bind ourselves to the other VPE long enough
++			 * to program the bind value.
++			 */
++			write_c0_tcbind((tcbindval & ~TCBIND_CURVPE)
++					   | number[index]);
++			mips_ihb();
++			write_c0_vpeschedule(value[index]);
++			mips_ihb();
++			/* Restore previous binding */
++			write_c0_tcbind(tcbindval);
++			mips_ihb();
++		}
++	}
++
++	else if(entity[index] == 'r') {
++		unsigned int vpes_checked[2], vpe ,i , mytc;
++		vpes_checked[0] = vpes_checked[1] = 0;
++
++		/* Then go through the TCs, halt 'em, and extract the values */
++		mytc = (read_c0_tcbind() & TCBIND_CURTC) >> TCBIND_CURTC_SHIFT;
++
++		for(i = 0; i < NTCS; i++) {
++			if(i == mytc) {
++				/* No need to halt ourselves! */
++				write_c0_vpeschefback(0);
++				write_c0_tcschefback(0);
++			} else {
++				settc(i);
++				haltstate = read_tc_c0_tchalt();
++				write_tc_c0_tchalt(TCHALT_H);
++				mips_ihb();
++				write_tc_c0_tcschefback(0);
++				/* If VPE bound to TC hasn't been checked, do it */
++				vpe = read_tc_c0_tcbind() & TCBIND_CURVPE;
++				if(!vpes_checked[vpe]) {
++				    write_vpe_c0_vpeschefback(0);
++				    vpes_checked[vpe] = 1;
++				}
++				if(!haltstate) write_tc_c0_tchalt(0);
++			}
++		}
++	}
++	else {
++		printk ("\n Usage : <t/v><0/1> <Hex Value>\n Example : t0 0x01\n");
++	}
++
++skip:
++	/* Re-enable MT and interrupts */
++	evpe(mtflags);
++	local_irq_restore(flags);
++	return (len);
++}
++
++static int mtsched_proc_show (struct seq_file *s, void *p)
++{
++	seq_printf(s, "mtsched_proc_show\n");
++	return proc_read_mtsched (s);
++}
++
++static int mtsched_proc_open (struct inode *inode, struct file *file)
++{
++	return single_open (file, mtsched_proc_show, NULL);
++}
++
++
++static const struct file_operations mtsched_proc_fops = {
++  .owner = THIS_MODULE,
++  .open = mtsched_proc_open,
++  .read = seq_read,
++  .write = proc_write_mtsched,
++  .llseek = seq_lseek,
++  .release = single_release,
++};
++
++static int __init init_mtsched_proc(void)
++{
++	extern struct proc_dir_entry *get_mips_proc_dir(void);
++
++	if (!cpu_has_mipsmt) {
++		printk("mtsched: not a MIPS MT capable processor\n");
++		return -ENODEV;
++	}
++	proc_create ("mtsched", 0, get_mips_proc_dir(), &mtsched_proc_fops);
++
++	return 0;
++}
++
++/* Automagically create the entry */
++module_init(init_mtsched_proc);
+diff --git a/arch/mips/kernel/perf_proc.c b/arch/mips/kernel/perf_proc.c
+new file mode 100644
+--- /dev/null
++++ b/arch/mips/kernel/perf_proc.c
+@@ -0,0 +1,191 @@
++/*
++ * /proc hooks for CPU performance counter support for SMTC kernel
++ * (and ultimately others)
++ * Copyright (C) 2006 Mips Technologies, Inc
++ */
++
++#include <linux/kernel.h>
++
++#include <asm/cpu.h>
++#include <asm/processor.h>
++#include <asm/setup.h>
++#include <asm/mipsregs.h>
++#include <asm/uaccess.h>
++#include <linux/proc_fs.h>
++
++/*
++ * /proc diagnostic and statistics hooks
++ */
++
++
++/* Internal software-extended event counters */
++
++static unsigned long long extencount[4] = {0,0,0,0};
++
++static struct proc_dir_entry *perf_proc;
++
++static int proc_read_perf(char *page, char **start, off_t off,
++				int count, int *eof, void *data)
++{
++	int totalen = 0;
++	int len;
++
++	len = sprintf(page, "PerfCnt[0].Ctl : 0x%08x\n", read_c0_perfctrl0());
++	totalen += len;
++	page += len;
++	len = sprintf(page, "PerfCnt[0].Cnt : %Lu\n",
++		extencount[0] + (unsigned long long)((unsigned)read_c0_perfcntr0()));
++	totalen += len;
++	page += len;
++	len = sprintf(page, "PerfCnt[1].Ctl : 0x%08x\n", read_c0_perfctrl1());
++	totalen += len;
++	page += len;
++	len = sprintf(page, "PerfCnt[1].Cnt : %Lu\n",
++		extencount[1] + (unsigned long long)((unsigned)read_c0_perfcntr1()));
++	totalen += len;
++	page += len;
++	len = sprintf(page, "PerfCnt[2].Ctl : 0x%08x\n", read_c0_perfctrl2());
++	totalen += len;
++	page += len;
++	len = sprintf(page, "PerfCnt[2].Cnt : %Lu\n",
++		extencount[2] + (unsigned long long)((unsigned)read_c0_perfcntr2()));
++	totalen += len;
++	page += len;
++	len = sprintf(page, "PerfCnt[3].Ctl : 0x%08x\n", read_c0_perfctrl3());
++	totalen += len;
++	page += len;
++	len = sprintf(page, "PerfCnt[3].Cnt : %Lu\n",
++		extencount[3] + (unsigned long long)((unsigned)read_c0_perfcntr3()));
++	totalen += len;
++	page += len;
++
++	return totalen;
++}
++
++/*
++ * Write to perf counter registers based on text input
++ */
++
++#define TXTBUFSZ 100
++
++static int proc_write_perf(struct file *file, const char *buffer,
++				unsigned long count, void *data)
++{
++	int len;
++	int nparsed;
++	int index;
++	char mybuf[TXTBUFSZ];
++
++	int which[4];
++	unsigned long control[4];
++	long long ctrdata[4];
++
++	if(count >= TXTBUFSZ) len = TXTBUFSZ-1;
++	else len = count;
++	memset(mybuf,0,TXTBUFSZ);
++	if(copy_from_user(mybuf, buffer, len)) return -EFAULT;
++
++	nparsed = sscanf(mybuf,
++			"%d %lx %Ld %d %lx %Ld %d %lx %Ld %d %lx %Ld",
++				&which[0], &control[0], &ctrdata[0],
++				&which[1], &control[1], &ctrdata[1],
++				&which[2], &control[2], &ctrdata[2],
++				&which[3], &control[3], &ctrdata[3]);
++
++	for(index = 0; nparsed >= 3; index++) {
++		switch (which[index]) {
++		case 0:
++			write_c0_perfctrl0(control[index]);
++			if(ctrdata[index] != -1) {
++			    extencount[0] = (unsigned long long)ctrdata[index];
++			    write_c0_perfcntr0((unsigned long)0);
++			}
++			break;
++		case 1:
++			write_c0_perfctrl1(control[index]);
++			if(ctrdata[index] != -1) {
++			    extencount[1] = (unsigned long long)ctrdata[index];
++			    write_c0_perfcntr1((unsigned long)0);
++			}
++			break;
++		case 2:
++			write_c0_perfctrl2(control[index]);
++			if(ctrdata[index] != -1) {
++			    extencount[2] = (unsigned long long)ctrdata[index];
++			    write_c0_perfcntr2((unsigned long)0);
++			}
++			break;
++		case 3:
++			write_c0_perfctrl3(control[index]);
++			if(ctrdata[index] != -1) {
++			    extencount[3] = (unsigned long long)ctrdata[index];
++			    write_c0_perfcntr3((unsigned long)0);
++			}
++			break;
++		}
++		nparsed -= 3;
++	}
++	return (len);
++}
++
++extern int (*perf_irq)(void);
++
++/*
++ * Invoked when timer interrupt vector picks up a perf counter overflow
++ */
++
++static int perf_proc_irq(void)
++{
++	unsigned long snapshot;
++
++	/*
++	 * It would be nice to do this as a loop, but we don't have
++	 * indirect access to CP0 registers.
++	 */
++	snapshot = read_c0_perfcntr0();
++	if ((long)snapshot < 0) {
++		extencount[0] +=
++			(unsigned long long)((unsigned)read_c0_perfcntr0());
++		write_c0_perfcntr0(0);
++	}
++	snapshot = read_c0_perfcntr1();
++	if ((long)snapshot < 0) {
++		extencount[1] +=
++			(unsigned long long)((unsigned)read_c0_perfcntr1());
++		write_c0_perfcntr1(0);
++	}
++	snapshot = read_c0_perfcntr2();
++	if ((long)snapshot < 0) {
++		extencount[2] +=
++			(unsigned long long)((unsigned)read_c0_perfcntr2());
++		write_c0_perfcntr2(0);
++	}
++	snapshot = read_c0_perfcntr3();
++	if ((long)snapshot < 0) {
++		extencount[3] +=
++			(unsigned long long)((unsigned)read_c0_perfcntr3());
++		write_c0_perfcntr3(0);
++	}
++	return 0;
++}
++
++static int __init init_perf_proc(void)
++{
++	extern struct proc_dir_entry *get_mips_proc_dir(void);
++
++	struct proc_dir_entry *mips_proc_dir = get_mips_proc_dir();
++
++	write_c0_perfcntr0(0);
++	write_c0_perfcntr1(0);
++	write_c0_perfcntr2(0);
++	write_c0_perfcntr3(0);
++	perf_proc = create_proc_entry("perf", 0644, mips_proc_dir);
++	perf_proc->read_proc = proc_read_perf;
++	perf_proc->write_proc = proc_write_perf;
++	perf_irq = perf_proc_irq;
++
++	return 0;
++}
++
++/* Automagically create the entry */
++module_init(init_perf_proc);
+diff --git a/arch/mips/kernel/proc.c b/arch/mips/kernel/proc.c
+--- a/arch/mips/kernel/proc.c
++++ b/arch/mips/kernel/proc.c
+@@ -7,6 +7,7 @@
+ #include <linux/kernel.h>
+ #include <linux/sched.h>
+ #include <linux/seq_file.h>
++#include <linux/proc_fs.h>
+ #include <asm/bootinfo.h>
+ #include <asm/cpu.h>
+ #include <asm/cpu-features.h>
+@@ -166,3 +167,19 @@ const struct seq_operations cpuinfo_op =
+ 	.stop	= c_stop,
+ 	.show	= show_cpuinfo,
+ };
++
++/*
++ * Support for MIPS/local /proc hooks in /proc/mips/
++ */
++
++static struct proc_dir_entry *mips_proc = NULL;
++
++struct proc_dir_entry *get_mips_proc_dir(void)
++{
++       /*
++        * This ought not to be preemptable.
++        */
++       if(mips_proc == NULL)
++               mips_proc = proc_mkdir("mips", NULL);
++       return(mips_proc);
++}
+diff --git a/arch/mips/kernel/vpe.c b/arch/mips/kernel/vpe.c
+--- a/arch/mips/kernel/vpe.c
++++ b/arch/mips/kernel/vpe.c
+@@ -138,12 +138,39 @@ void release_vpe(struct vpe *v)
+ 	kfree(v);
+ }
+ 
++static void __maybe_unused dump_mtregs(void)
++{
++	unsigned long val;
++
++	val = read_c0_config3();
++	printk("config3 0x%lx MT %ld\n", val,
++	       (val & CONFIG3_MT) >> CONFIG3_MT_SHIFT);
++
++	val = read_c0_mvpcontrol();
++	printk("MVPControl 0x%lx, STLB %ld VPC %ld EVP %ld\n", val,
++	       (val & MVPCONTROL_STLB) >> MVPCONTROL_STLB_SHIFT,
++	       (val & MVPCONTROL_VPC) >> MVPCONTROL_VPC_SHIFT,
++	       (val & MVPCONTROL_EVP));
++
++	val = read_c0_mvpconf0();
++	printk("mvpconf0 0x%lx, PVPE %ld PTC %ld M %ld\n", val,
++	       (val & MVPCONF0_PVPE) >> MVPCONF0_PVPE_SHIFT,
++	       val & MVPCONF0_PTC, (val & MVPCONF0_M) >> MVPCONF0_M_SHIFT);
++}
++
+ /* Find some VPE program space */
+ void *alloc_progmem(unsigned long len)
+ {
+ 	void *addr;
+ 
+ #ifdef CONFIG_MIPS_VPE_LOADER_TOM
++#ifdef CONFIG_IFX_VPE_EXT
++	if (vpe1_load_addr) {
++		memset((void *)vpe1_load_addr, 0, len);
++		return (void *)vpe1_load_addr;
++	}
++#endif
++
+ 	/*
+ 	 * This means you must tell Linux to use less memory than you
+ 	 * physically have, for example by passing a mem= boot argument.
+@@ -381,6 +408,20 @@ static int apply_r_mips_lo16(struct modu
+ 		mips_hi16_list = NULL;
+ 	}
+ 
++#if defined(CONFIG_IFX_VPE_EXT) && 0
++	/*
++	 * $a2 & $a3 are used to pass command line parameters to VPE1. $a2
++	 * points to the start of the command line string and $a3 points to
++	 * the end of the string. This convention is identical to the Linux
++	 * kernel boot parameter passing mechanism. Please note that $a3 is
++	 * used to pass physical memory size or 0 in SDE tool kit. So, if you
++	 * are passing comand line parameters through $a2 & $a3 SDE programs
++	 * don't work as desired.
++	 */
++	mttgpr(6, command_line);
++	mttgpr(7, (command_line + strlen(command_line)));
++	if (is_sdepgm)
++#endif
+ 	/*
+ 	 * Ok, we're done with the HI16 relocs.	 Now deal with the LO16.
+ 	 */
+@@ -565,6 +606,9 @@ static int find_vpe_symbols(struct vpe *
+ 	if ((v->__start == 0) || (v->shared_ptr == NULL))
+ 		return -1;
+ 
++#ifdef CONFIG_IFX_VPE_EXT
++	is_sdepgm = 1;
++#endif
+ 	return 0;
+ }
+ 
+@@ -732,6 +776,15 @@ static int vpe_elfload(struct vpe *v)
+ 			   (unsigned long)v->load_addr + v->len);
+ 
+ 	if ((find_vpe_symbols(v, sechdrs, symindex, strtab, &mod)) < 0) {
++#ifdef CONFIG_IFX_VPE_EXT
++		if (vpe1_load_addr) {
++			/* Conversion to KSEG1 is required ??? */
++			v->__start = KSEG1ADDR(vpe1_load_addr);
++			is_sdepgm = 0;
++			return 0;
++		}
++#endif
++
+ 		if (v->__start == 0) {
+ 			pr_warn("VPE loader: program does not contain a __start symbol\n");
+ 			return -ENOEXEC;
+@@ -768,6 +821,9 @@ static int vpe_open(struct inode *inode,
+ 	struct vpe_notifications *notifier;
+ 	struct vpe *v;
+ 	int ret;
++#ifdef CONFIG_IFX_VPE_EXT
++   int progsize;
++#endif
+ 
+ 	if (VPE_MODULE_MINOR != iminor(inode)) {
+ 		/* assume only 1 device at the moment. */
+@@ -793,7 +849,12 @@ static int vpe_open(struct inode *inode,
+ 		release_progmem(v->load_addr);
+ 		cleanup_tc(get_tc(aprp_cpu_index()));
+ 	}
+-
++#ifdef CONFIG_IFX_VPE_EXT
++	progsize = (vpe1_mem  != 0) ? vpe1_mem : P_SIZE;
++	//printk("progsize = %x\n", progsize);
++	v->pbuffer = vmalloc(progsize);
++	v->plen = progsize;
++#else
+ 	/* this of-course trashes what was there before... */
+ 	v->pbuffer = vmalloc(P_SIZE);
+ 	if (!v->pbuffer) {
+@@ -870,6 +931,18 @@ static ssize_t vpe_write(struct file *fi
+ 		pr_warn("VPE loader: elf size too big. Perhaps strip uneeded symbols\n");
+ 		return -ENOMEM;
+ 	}
++#ifdef CONFIG_IFX_VPE_EXT
++#ifndef CONFIG_MIPS_MT_SMTC
++	configure_tlb();
++#endif
++#endif
++
++#ifndef CONFIG_MIPS_MT_SMTC
++	if (!vpelimit)
++		vpelimit = 1;
++	if (!tclimit)
++		tclimit = 1;
++#endif
+ 
+ 	count -= copy_from_user(v->pbuffer + v->len, buffer, count);
+ 	if (!count)
diff --git a/target/linux/lantiq/patches-3.18/0501-MIPS-lantiq-VPE-softdog.patch b/target/linux/lantiq/patches-3.18/0501-MIPS-lantiq-VPE-softdog.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/0501-MIPS-lantiq-VPE-softdog.patch
@@ -0,0 +1,178 @@
+From 79bbd1bfeb1dd9c66dd81605611d8d1db3e81822 Mon Sep 17 00:00:00 2001
+From: John Crispin <blogic@openwrt.org>
+Date: Thu, 29 Sep 2011 21:29:14 +0200
+Subject: [PATCH 16/25] VPE softdog
+
+--- /dev/null
++++ b/arch/mips/include/asm/mach-lantiq/softdog_vpe.h
+@@ -0,0 +1,40 @@
++/*
++ *   This program is free software; you can redistribute it and/or modify
++ *   it under the terms of the GNU General Public License as published by
++ *   the Free Software Foundation; either version 2 of the License, or
++ *   (at your option) any later version.
++ *
++ *   This program is distributed in the hope that it will be useful,
++ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ *   GNU General Public License for more details.
++ *
++ *   You should have received a copy of the GNU General Public License
++ *   along with this program; if not, write to the Free Software
++ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
++ *
++ *   Copyright (C) 2005 infineon
++ *   Copyright (C) 2007 John Crispin <blogic@openwrt.org>
++ *
++ */
++#ifndef _SOFTDOG_VPE_H__
++#define _SOFTDOG_VPE_H__
++
++typedef int (*VPE_SW_WDOG_RESET)(unsigned long wdog_cleared_ok_count);
++
++#ifdef CONFIG_VPE_SOFTDOG
++extern unsigned long vpe1_wdog_ctr;
++extern unsigned long vpe1_wdog_timeout;
++
++unsigned long vpe1_sw_wdog_start(unsigned long);
++unsigned long vpe1_sw_wdog_stop(unsigned long);
++
++int32_t vpe1_sw_wdog_register_reset_handler(VPE_SW_WDOG_RESET reset_fn);
++#else
++static inline unsigned long vpe1_sw_wdog_start(unsigned long flags) { return 0; }
++static inline unsigned long vpe1_sw_wdog_stop(unsigned long flags) { return 0; }
++
++static inline int32_t vpe1_sw_wdog_register_reset_handler(VPE_SW_WDOG_RESET reset_fn) { return 0; }
++#endif
++
++#endif
+--- a/arch/mips/lantiq/Kconfig
++++ b/arch/mips/lantiq/Kconfig
+@@ -51,4 +51,8 @@ config XRX200_PHY_FW
+ 	bool "XRX200 PHY firmware loader"
+ 	depends on SOC_XWAY
+ 
++config VPE_SOFTDOG
++	bool "VPE1 watchdog"
++	depends on MIPS_VPE_LOADER
++
+ endif
+--- a/arch/mips/lantiq/Makefile
++++ b/arch/mips/lantiq/Makefile
+@@ -7,6 +7,7 @@
+ obj-y := irq.o clk.o prom.o
+ 
+ obj-$(CONFIG_EARLY_PRINTK) += early_printk.o
++obj-$(CONFIG_VPE_SOFTDOG) += softdog_vpe.o
+ 
+ obj-$(CONFIG_SOC_TYPE_XWAY) += xway/
+ obj-$(CONFIG_SOC_FALCON) += falcon/
+--- /dev/null
++++ b/arch/mips/lantiq/softdog_vpe.c
+@@ -0,0 +1,106 @@
++/*
++** =============================================================================
++** FILE NAME     : softdog_vpe.c
++** MODULES       : LXDB
++** DATE          : 24-03-2008
++** AUTHOR        : LXDB Team
++** DESCRIPTION   : This header file contains the code for the watchdog
++**                 implementation on vpe1 side.
++** REFERENCES    :
++** COPYRIGHT     : Copyright (c) 2008
++**                 Am Campeon 1-12, 85579 Neubiberg, Germany
++**
++** HISTORY       :
++** $Date   $Author    $Comment
++** 24-03-2008   LXDB    Initial version
++** ============================================================================
++*/
++
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/types.h>
++#include <linux/timer.h>
++#include <linux/reboot.h>
++#include <linux/init.h>
++#include <linux/jiffies.h>
++
++#include <asm/softdog_vpe.h>
++
++static unsigned long last_wdog_value;
++static unsigned long vpe1_wdog_cleared;
++
++static unsigned long vpe1_wdog_dead;
++static void watchdog_vpe0_fire(unsigned long); /* Called when vpe0 timer expires */
++static void keep_alive_vpe0(unsigned long);
++VPE_SW_WDOG_RESET reset_local_fn;
++
++
++static struct timer_list watchdog_vpe0_ticktock =
++                TIMER_INITIALIZER(watchdog_vpe0_fire, 0, 0);
++
++static void watchdog_vpe0_fire (unsigned long flags)
++{
++	volatile unsigned long *wdog_ctr_value;
++	wdog_ctr_value = (void*)vpe1_wdog_ctr;
++	if (*wdog_ctr_value == last_wdog_value) { /* VPE1 watchdog expiry handling */
++		vpe1_sw_wdog_stop(flags);
++		vpe1_wdog_dead++;
++		printk(KERN_DEBUG "VPE1 watchdog reset handler called\n");
++	/* Call the reset handler function */
++		reset_local_fn(flags);
++	} else { /* Everything is OK on vpe1 side. Continue. */
++		last_wdog_value = *wdog_ctr_value;
++		vpe1_wdog_cleared++;
++		keep_alive_vpe0(flags);
++	}
++}
++
++int32_t vpe1_sw_wdog_register_reset_handler (VPE_SW_WDOG_RESET reset_fn)
++{
++	reset_local_fn = (VPE_SW_WDOG_RESET)reset_fn;
++	return 0;
++}
++
++static void keep_alive_vpe0(unsigned long flags)
++{
++	mod_timer(&watchdog_vpe0_ticktock, jiffies+ vpe1_wdog_timeout );
++}
++
++unsigned long vpe1_sw_wdog_start(unsigned long flags)
++{
++	volatile unsigned long *wdog_ctr_value;
++	wdog_ctr_value = (void*)vpe1_wdog_ctr;
++	*wdog_ctr_value = 0;
++	last_wdog_value = 0;
++	keep_alive_vpe0(flags);
++	return 0;
++}
++
++unsigned long vpe1_sw_wdog_stop(unsigned long flags)
++{
++	del_timer(&watchdog_vpe0_ticktock);
++	return 0;
++}
++
++static int __init watchdog_vpe1_init(void)
++{
++	/* Nothing to be done here */
++	return 0;
++}
++
++static void __exit watchdog_vpe1_exit(void)
++{
++	unsigned long flags=0;
++	vpe1_sw_wdog_stop(flags);
++}
++
++module_init(watchdog_vpe1_init);
++module_exit(watchdog_vpe1_exit);
++
++EXPORT_SYMBOL(vpe1_sw_wdog_register_reset_handler);
++EXPORT_SYMBOL(vpe1_sw_wdog_start);
++EXPORT_SYMBOL(vpe1_sw_wdog_stop);
++
++MODULE_AUTHOR("LXDB");
++MODULE_DESCRIPTION("Software Watchdog For VPE1");
++MODULE_LICENSE("GPL");
diff --git a/target/linux/lantiq/patches-3.18/0502-MIPS-lantiq-add-physical_memsize.patch b/target/linux/lantiq/patches-3.18/0502-MIPS-lantiq-add-physical_memsize.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/0502-MIPS-lantiq-add-physical_memsize.patch
@@ -0,0 +1,44 @@
+CONFIG_MIPS_VPE_LOADER requires us to provide physical_memsize for VPE1
+
+diff --git a/arch/mips/lantiq/prom.c b/arch/mips/lantiq/prom.c
+--- a/arch/mips/lantiq/prom.c
++++ b/arch/mips/lantiq/prom.c
+@@ -25,6 +25,8 @@
+ DEFINE_SPINLOCK(ebu_lock);
+ EXPORT_SYMBOL_GPL(ebu_lock);
+ 
++unsigned long physical_memsize = 0L;
++
+ /*
+  * this struct is filled by the soc specific detection code and holds
+  * information about the specific soc type, revision and name
+@@ -67,6 +69,10 @@ extern struct boot_param_header __image_
+ 
+ void __init plat_mem_setup(void)
+ {
++	/* assume 16M as default incase uboot fails to pass proper ramsize */
++	unsigned long memsize = 16;
++	char **envp = (char **) KSEG1ADDR(fw_arg2);
++
+ 	ioport_resource.start = IOPORT_RESOURCE_START;
+ 	ioport_resource.end = IOPORT_RESOURCE_END;
+ 	iomem_resource.start = IOMEM_RESOURCE_START;
+@@ -80,6 +86,18 @@ void __init plat_mem_setup(void)
+ 	 */
+ 	__dt_setup_arch(&__image_dtb);
+ 
++	while (*envp) {
++		char *e = (char *)KSEG1ADDR(*envp); printk("e=%s\n", e);
++		if (!strncmp(e, "memsize=", 8)) {
++			e += 8;
++			if (kstrtoul(e, 0, &memsize))
++				pr_warning("bad memsize specified\n");
++		}
++		envp++;
++	}
++	memsize *= 1024 * 1024;
++	physical_memsize = memsize; printk("MEMSIZE = %lu\n", physical_memsize);
++
+ 	strlcpy(arcs_cmdline, boot_command_line, COMMAND_LINE_SIZE);
+ }
+ 
diff --git a/target/linux/lantiq/patches-3.18/0520-sdk-add-irq-defines.patch b/target/linux/lantiq/patches-3.18/0520-sdk-add-irq-defines.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/0520-sdk-add-irq-defines.patch
@@ -0,0 +1,254 @@
+add interrupt definitions for external drivers (SDK)
+
+--- a/arch/mips/include/asm/mach-lantiq/falcon/falcon_irq.h
++++ b/arch/mips/include/asm/mach-lantiq/falcon/falcon_irq.h
+@@ -22,4 +22,249 @@
+ 
+ #define MAX_IM			5
+ 
++/* HOST IF Event Interrupt */
++#define FALCON_IRQ_HOST				(INT_NUM_IM0_IRL0 + 0)
++/* HOST IF Mailbox0 Receive Interrupt */
++#define FALCON_IRQ_HOST_MB0_RX			(INT_NUM_IM0_IRL0 + 1)
++/* HOST IF Mailbox0 Transmit Interrupt */
++#define FALCON_IRQ_HOST_MB0_TX			(INT_NUM_IM0_IRL0 + 2)
++/* HOST IF Mailbox1 Receive Interrupt */
++#define FALCON_IRQ_HOST_MB1_RX			(INT_NUM_IM0_IRL0 + 3)
++/* HOST IF Mailbox1 Transmit Interrupt */
++#define FALCON_IRQ_HOST_MB1_TX			(INT_NUM_IM0_IRL0 + 4)
++/* I2C Last Single Data Transfer Request */
++#define FALCON_IRQ_I2C_LSREQ			(INT_NUM_IM0_IRL0 + 8)
++/* I2C Single Data Transfer Request */
++#define FALCON_IRQ_I2C_SREQ			(INT_NUM_IM0_IRL0 + 9)
++/* I2C Last Burst Data Transfer Request */
++#define FALCON_IRQ_I2C_LBREQ			(INT_NUM_IM0_IRL0 + 10)
++/* I2C Burst Data Transfer Request */
++#define FALCON_IRQ_I2C_BREQ			(INT_NUM_IM0_IRL0 + 11)
++/* I2C Error Interrupt */
++#define FALCON_IRQ_I2C_I2C_ERR			(INT_NUM_IM0_IRL0 + 12)
++/* I2C Protocol Interrupt */
++#define FALCON_IRQ_I2C_I2C_P			(INT_NUM_IM0_IRL0 + 13)
++/* SSC Transmit Interrupt */
++#define FALCON_IRQ_SSC_T			(INT_NUM_IM0_IRL0 + 14)
++/* SSC Receive Interrupt */
++#define FALCON_IRQ_SSC_R			(INT_NUM_IM0_IRL0 + 15)
++/* SSC Error Interrupt */
++#define FALCON_IRQ_SSC_E			(INT_NUM_IM0_IRL0 + 16)
++/* SSC Frame Interrupt */
++#define FALCON_IRQ_SSC_F			(INT_NUM_IM0_IRL0 + 17)
++/* Advanced Encryption Standard Interrupt */
++#define FALCON_IRQ_AES_AES			(INT_NUM_IM0_IRL0 + 27)
++/* Secure Hash Algorithm Interrupt */
++#define FALCON_IRQ_SHA_HASH			(INT_NUM_IM0_IRL0 + 28)
++/* PCM Receive Interrupt */
++#define FALCON_IRQ_PCM_RX			(INT_NUM_IM0_IRL0 + 29)
++/* PCM Transmit Interrupt */
++#define FALCON_IRQ_PCM_TX			(INT_NUM_IM0_IRL0 + 30)
++/* PCM Transmit Crash Interrupt */
++#define FALCON_IRQ_PCM_HW2_CRASH		(INT_NUM_IM0_IRL0 + 31)
++
++/* EBU Serial Flash Command Error */
++#define FALCON_IRQ_EBU_SF_CMDERR		(INT_NUM_IM1_IRL0 + 0)
++/* EBU Serial Flash Command Overwrite Error */
++#define FALCON_IRQ_EBU_SF_COVERR		(INT_NUM_IM1_IRL0 + 1)
++/* EBU Serial Flash Busy */
++#define FALCON_IRQ_EBU_SF_BUSY			(INT_NUM_IM1_IRL0 + 2)
++/* External Interrupt from GPIO P0 */
++#define FALCON_IRQ_GPIO_P0			(INT_NUM_IM1_IRL0 + 4)
++/* External Interrupt from GPIO P1 */
++#define FALCON_IRQ_GPIO_P1			(INT_NUM_IM1_IRL0 + 5)
++/* External Interrupt from GPIO P2 */
++#define FALCON_IRQ_GPIO_P2			(INT_NUM_IM1_IRL0 + 6)
++/* External Interrupt from GPIO P3 */
++#define FALCON_IRQ_GPIO_P3			(INT_NUM_IM1_IRL0 + 7)
++/* External Interrupt from GPIO P4 */
++#define FALCON_IRQ_GPIO_P4			(INT_NUM_IM1_IRL0 + 8)
++/* 8kHz backup interrupt derived from core-PLL */
++#define FALCON_IRQ_FSC_BKP			(INT_NUM_IM1_IRL0 + 10)
++/* FSC Timer Interrupt 0 */
++#define FALCON_IRQ_FSCT_CMP0			(INT_NUM_IM1_IRL0 + 11)
++/* FSC Timer Interrupt 1 */
++#define FALCON_IRQ_FSCT_CMP1			(INT_NUM_IM1_IRL0 + 12)
++/* 8kHz root interrupt derived from GPON interface */
++#define FALCON_IRQ_FSC_ROOT			(INT_NUM_IM1_IRL0 + 13)
++/* Time of Day */
++#define FALCON_IRQ_TOD				(INT_NUM_IM1_IRL0 + 14)
++/* PMA Interrupt from IntNode of the 200MHz Domain */
++#define FALCON_IRQ_PMA_200M			(INT_NUM_IM1_IRL0 + 15)
++/* PMA Interrupt from IntNode of the TX Clk Domain */
++#define FALCON_IRQ_PMA_TX			(INT_NUM_IM1_IRL0 + 16)
++/* PMA Interrupt from IntNode of the RX Clk Domain */
++#define FALCON_IRQ_PMA_RX			(INT_NUM_IM1_IRL0 + 17)
++/* SYS1 Interrupt */
++#define FALCON_IRQ_SYS1				(INT_NUM_IM1_IRL0 + 20)
++/* SYS GPE Interrupt */
++#define FALCON_IRQ_SYS_GPE			(INT_NUM_IM1_IRL0 + 21)
++/* Watchdog Access Error Interrupt */
++#define FALCON_IRQ_WDT_AEIR			(INT_NUM_IM1_IRL0 + 24)
++/* Watchdog Prewarning Interrupt */
++#define FALCON_IRQ_WDT_PIR			(INT_NUM_IM1_IRL0 + 25)
++/* SBIU interrupt */
++#define FALCON_IRQ_SBIU0			(INT_NUM_IM1_IRL0 + 27)
++/* FPI Bus Control Unit Interrupt */
++#define FALCON_IRQ_BCU0				(INT_NUM_IM1_IRL0 + 29)
++/* DDR Controller Interrupt */
++#define FALCON_IRQ_DDR				(INT_NUM_IM1_IRL0 + 30)
++/* Crossbar Error Interrupt */
++#define FALCON_IRQ_XBAR_ERROR			(INT_NUM_IM1_IRL0 + 31)
++
++/* ICTRLL 0 Interrupt */
++#define FALCON_IRQ_ICTRLL0			(INT_NUM_IM2_IRL0 + 0)
++/* ICTRLL 1 Interrupt */
++#define FALCON_IRQ_ICTRLL1			(INT_NUM_IM2_IRL0 + 1)
++/* ICTRLL 2 Interrupt */
++#define FALCON_IRQ_ICTRLL2			(INT_NUM_IM2_IRL0 + 2)
++/* ICTRLL 3 Interrupt */
++#define FALCON_IRQ_ICTRLL3			(INT_NUM_IM2_IRL0 + 3)
++/* OCTRLL 0 Interrupt */
++#define FALCON_IRQ_OCTRLL0			(INT_NUM_IM2_IRL0 + 4)
++/* OCTRLL 1 Interrupt */
++#define FALCON_IRQ_OCTRLL1			(INT_NUM_IM2_IRL0 + 5)
++/* OCTRLL 2 Interrupt */
++#define FALCON_IRQ_OCTRLL2			(INT_NUM_IM2_IRL0 + 6)
++/* OCTRLL 3 Interrupt */
++#define FALCON_IRQ_OCTRLL3			(INT_NUM_IM2_IRL0 + 7)
++/* OCTRLG Interrupt */
++#define FALCON_IRQ_OCTRLG			(INT_NUM_IM2_IRL0 + 9)
++/* IQM Interrupt */
++#define FALCON_IRQ_IQM				(INT_NUM_IM2_IRL0 + 10)
++/* FSQM Interrupt */
++#define FALCON_IRQ_FSQM				(INT_NUM_IM2_IRL0 + 11)
++/* TMU Interrupt */
++#define FALCON_IRQ_TMU				(INT_NUM_IM2_IRL0 + 12)
++/* LINK1 Interrupt */
++#define FALCON_IRQ_LINK1			(INT_NUM_IM2_IRL0 + 14)
++/* ICTRLC 0 Interrupt */
++#define FALCON_IRQ_ICTRLC0			(INT_NUM_IM2_IRL0 + 16)
++/* ICTRLC 1 Interrupt */
++#define FALCON_IRQ_ICTRLC1			(INT_NUM_IM2_IRL0 + 17)
++/* OCTRLC Interrupt */
++#define FALCON_IRQ_OCTRLC			(INT_NUM_IM2_IRL0 + 18)
++/* CONFIG Break Interrupt */
++#define FALCON_IRQ_CONFIG_BREAK			(INT_NUM_IM2_IRL0 + 19)
++/* CONFIG Interrupt */
++#define FALCON_IRQ_CONFIG			(INT_NUM_IM2_IRL0 + 20)
++/* Dispatcher Interrupt */
++#define FALCON_IRQ_DISP				(INT_NUM_IM2_IRL0 + 21)
++/* TBM Interrupt */
++#define FALCON_IRQ_TBM				(INT_NUM_IM2_IRL0 + 22)
++/* GTC Downstream Interrupt */
++#define FALCON_IRQ_GTC_DS			(INT_NUM_IM2_IRL0 + 29)
++/* GTC Upstream Interrupt */
++#define FALCON_IRQ_GTC_US			(INT_NUM_IM2_IRL0 + 30)
++/* EIM Interrupt */
++#define FALCON_IRQ_EIM				(INT_NUM_IM2_IRL0 + 31)
++
++/* ASC0 Transmit Interrupt */
++#define FALCON_IRQ_ASC0_T			(INT_NUM_IM3_IRL0 + 0)
++/* ASC0 Receive Interrupt */
++#define FALCON_IRQ_ASC0_R			(INT_NUM_IM3_IRL0 + 1)
++/* ASC0 Error Interrupt */
++#define FALCON_IRQ_ASC0_E			(INT_NUM_IM3_IRL0 + 2)
++/* ASC0 Transmit Buffer Interrupt */
++#define FALCON_IRQ_ASC0_TB			(INT_NUM_IM3_IRL0 + 3)
++/* ASC0 Autobaud Start Interrupt */
++#define FALCON_IRQ_ASC0_ABST			(INT_NUM_IM3_IRL0 + 4)
++/* ASC0 Autobaud Detection Interrupt */
++#define FALCON_IRQ_ASC0_ABDET			(INT_NUM_IM3_IRL0 + 5)
++/* ASC1 Modem Status Interrupt */
++#define FALCON_IRQ_ASC0_MS			(INT_NUM_IM3_IRL0 + 6)
++/* ASC0 Soft Flow Control Interrupt */
++#define FALCON_IRQ_ASC0_SFC			(INT_NUM_IM3_IRL0 + 7)
++/* ASC1 Transmit Interrupt */
++#define FALCON_IRQ_ASC1_T			(INT_NUM_IM3_IRL0 + 8)
++/* ASC1 Receive Interrupt */
++#define FALCON_IRQ_ASC1_R			(INT_NUM_IM3_IRL0 + 9)
++/* ASC1 Error Interrupt */
++#define FALCON_IRQ_ASC1_E			(INT_NUM_IM3_IRL0 + 10)
++/* ASC1 Transmit Buffer Interrupt */
++#define FALCON_IRQ_ASC1_TB			(INT_NUM_IM3_IRL0 + 11)
++/* ASC1 Autobaud Start Interrupt */
++#define FALCON_IRQ_ASC1_ABST			(INT_NUM_IM3_IRL0 + 12)
++/* ASC1 Autobaud Detection Interrupt */
++#define FALCON_IRQ_ASC1_ABDET			(INT_NUM_IM3_IRL0 + 13)
++/* ASC1 Modem Status Interrupt */
++#define FALCON_IRQ_ASC1_MS			(INT_NUM_IM3_IRL0 + 14)
++/* ASC1 Soft Flow Control Interrupt */
++#define FALCON_IRQ_ASC1_SFC			(INT_NUM_IM3_IRL0 + 15)
++/* GPTC Timer/Counter 1A Interrupt */
++#define FALCON_IRQ_GPTC_TC1A			(INT_NUM_IM3_IRL0 + 16)
++/* GPTC Timer/Counter 1B Interrupt */
++#define FALCON_IRQ_GPTC_TC1B			(INT_NUM_IM3_IRL0 + 17)
++/* GPTC Timer/Counter 2A Interrupt */
++#define FALCON_IRQ_GPTC_TC2A			(INT_NUM_IM3_IRL0 + 18)
++/* GPTC Timer/Counter 2B Interrupt */
++#define FALCON_IRQ_GPTC_TC2B			(INT_NUM_IM3_IRL0 + 19)
++/* GPTC Timer/Counter 3A Interrupt */
++#define FALCON_IRQ_GPTC_TC3A			(INT_NUM_IM3_IRL0 + 20)
++/* GPTC Timer/Counter 3B Interrupt */
++#define FALCON_IRQ_GPTC_TC3B			(INT_NUM_IM3_IRL0 + 21)
++/* DFEV0, Channel 1 Transmit Interrupt */
++#define FALCON_IRQ_DFEV0_2TX			(INT_NUM_IM3_IRL0 + 26)
++/* DFEV0, Channel 1 Receive Interrupt */
++#define FALCON_IRQ_DFEV0_2RX			(INT_NUM_IM3_IRL0 + 27)
++/* DFEV0, Channel 1 General Purpose Interrupt */
++#define FALCON_IRQ_DFEV0_2GP			(INT_NUM_IM3_IRL0 + 28)
++/* DFEV0, Channel 0 Transmit Interrupt */
++#define FALCON_IRQ_DFEV0_1TX			(INT_NUM_IM3_IRL0 + 29)
++/* DFEV0, Channel 0 Receive Interrupt */
++#define FALCON_IRQ_DFEV0_1RX			(INT_NUM_IM3_IRL0 + 30)
++/* DFEV0, Channel 0 General Purpose Interrupt */
++#define FALCON_IRQ_DFEV0_1GP			(INT_NUM_IM3_IRL0 + 31)
++
++/* ICTRLL 0 Error */
++#define FALCON_IRQ_ICTRLL0_ERR			(INT_NUM_IM4_IRL0 + 0)
++/* ICTRLL 1 Error */
++#define FALCON_IRQ_ICTRLL1_ERR			(INT_NUM_IM4_IRL0 + 1)
++/* ICTRLL 2 Error */
++#define FALCON_IRQ_ICTRLL2_ERR			(INT_NUM_IM4_IRL0 + 2)
++/* ICTRLL 3 Error */
++#define FALCON_IRQ_ICTRLL3_ERR			(INT_NUM_IM4_IRL0 + 3)
++/* OCTRLL 0 Error */
++#define FALCON_IRQ_OCTRLL0_ERR			(INT_NUM_IM4_IRL0 + 4)
++/* OCTRLL 1 Error */
++#define FALCON_IRQ_OCTRLL1_ERR			(INT_NUM_IM4_IRL0 + 5)
++/* OCTRLL 2 Error */
++#define FALCON_IRQ_OCTRLL2_ERR			(INT_NUM_IM4_IRL0 + 6)
++/* OCTRLL 3 Error */
++#define FALCON_IRQ_OCTRLL3_ERR			(INT_NUM_IM4_IRL0 + 7)
++/* ICTRLG Error */
++#define FALCON_IRQ_ICTRLG_ERR			(INT_NUM_IM4_IRL0 + 8)
++/* OCTRLG Error */
++#define FALCON_IRQ_OCTRLG_ERR			(INT_NUM_IM4_IRL0 + 9)
++/* IQM Error */
++#define FALCON_IRQ_IQM_ERR			(INT_NUM_IM4_IRL0 + 10)
++/* FSQM Error */
++#define FALCON_IRQ_FSQM_ERR			(INT_NUM_IM4_IRL0 + 11)
++/* TMU Error */
++#define FALCON_IRQ_TMU_ERR			(INT_NUM_IM4_IRL0 + 12)
++/* MPS Status Interrupt #0 (VPE1 to VPE0) */
++#define FALCON_IRQ_MPS_IR0			(INT_NUM_IM4_IRL0 + 14)
++/* MPS Status Interrupt #1 (VPE1 to VPE0) */
++#define FALCON_IRQ_MPS_IR1			(INT_NUM_IM4_IRL0 + 15)
++/* MPS Status Interrupt #2 (VPE1 to VPE0) */
++#define FALCON_IRQ_MPS_IR2			(INT_NUM_IM4_IRL0 + 16)
++/* MPS Status Interrupt #3 (VPE1 to VPE0) */
++#define FALCON_IRQ_MPS_IR3			(INT_NUM_IM4_IRL0 + 17)
++/* MPS Status Interrupt #4 (VPE1 to VPE0) */
++#define FALCON_IRQ_MPS_IR4			(INT_NUM_IM4_IRL0 + 18)
++/* MPS Status Interrupt #5 (VPE1 to VPE0) */
++#define FALCON_IRQ_MPS_IR5			(INT_NUM_IM4_IRL0 + 19)
++/* MPS Status Interrupt #6 (VPE1 to VPE0) */
++#define FALCON_IRQ_MPS_IR6			(INT_NUM_IM4_IRL0 + 20)
++/* MPS Status Interrupt #7 (VPE1 to VPE0) */
++#define FALCON_IRQ_MPS_IR7			(INT_NUM_IM4_IRL0 + 21)
++/* MPS Status Interrupt #8 (VPE1 to VPE0) */
++#define FALCON_IRQ_MPS_IR8			(INT_NUM_IM4_IRL0 + 22)
++/* VPE0 Exception Level Flag Interrupt */
++#define FALCON_IRQ_VPE0_EXL			(INT_NUM_IM4_IRL0 + 29)
++/* VPE0 Error Level Flag Interrupt */
++#define FALCON_IRQ_VPE0_ERL			(INT_NUM_IM4_IRL0 + 30)
++/* VPE0 Performance Monitoring Counter Interrupt */
++#define FALCON_IRQ_VPE0_PMCIR			(INT_NUM_IM4_IRL0 + 31)
++
+ #endif /* _FALCON_IRQ__ */
diff --git a/target/linux/lantiq/patches-3.18/1012-lantiq-irq_set_default_host.patch b/target/linux/lantiq/patches-3.18/1012-lantiq-irq_set_default_host.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/1012-lantiq-irq_set_default_host.patch
@@ -0,0 +1,14 @@
+set the default irq domain for lantiq
+
+diff --git a/arch/mips/lantiq/irq.c b/arch/mips/lantiq/irq.c
+--- a/arch/mips/lantiq/irq.c
++++ b/arch/mips/lantiq/irq.c
+@@ -431,6 +431,8 @@ int __init icu_of_init(struct device_nod
+ 		(MAX_IM * INT_NUM_IM_OFFSET) + MIPS_CPU_IRQ_CASCADE,
+ 		&irq_domain_ops, 0);
+ 
++	irq_set_default_host(ltq_domain);
++
+ #if defined(CONFIG_MIPS_MT_SMP)
+ 	if (cpu_has_vint) {
+ 		pr_info("Setting up IPI vectored interrupts\n");
diff --git a/target/linux/lantiq/patches-3.18/1015-sdk-compat.patch b/target/linux/lantiq/patches-3.18/1015-sdk-compat.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/1015-sdk-compat.patch
@@ -0,0 +1,130 @@
+add some compatibility functions to access sysctrl from external (SDK) drivers
+
+diff --git a/arch/mips/include/asm/mach-lantiq/falcon/lantiq_soc.h b/arch/mips/include/asm/mach-lantiq/falcon/lantiq_soc.h
+--- a/arch/mips/include/asm/mach-lantiq/falcon/lantiq_soc.h
++++ b/arch/mips/include/asm/mach-lantiq/falcon/lantiq_soc.h
+@@ -41,6 +41,11 @@
+ #define SYSCTL_SYS1		0
+ #define SYSCTL_SYSETH		1
+ #define SYSCTL_SYSGPE		2
++extern void ltq_sysctl_activate(int module, unsigned int mask);
++extern void ltq_sysctl_deactivate(int module, unsigned int mask);
++extern void ltq_sysctl_clken(int module, unsigned int mask);
++extern void ltq_sysctl_clkdis(int module, unsigned int mask);
++extern void ltq_sysctl_reboot(int module, unsigned int mask);
+ 
+ /* BOOT_SEL - find what boot media we have */
+ #define BS_FLASH		0x1
+diff --git a/arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h b/arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h
+new file mode 100644
+--- /dev/null
++++ b/arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h
+@@ -0,0 +1,60 @@
++/*
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of
++ * the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ * MA 02111-1307 USA
++ *
++ * Copyright (C) 2010 Thomas Langer, Lantiq Deutschland
++ */
++
++#ifndef __FALCON_SYSCTRL_H
++#define __FALCON_SYSCTRL_H
++
++#include <falcon/lantiq_soc.h>
++
++static inline void sys1_hw_activate(u32 mask)
++{ ltq_sysctl_activate(SYSCTL_SYS1, mask); }
++static inline void sys1_hw_deactivate(u32 mask)
++{ ltq_sysctl_deactivate(SYSCTL_SYS1, mask); }
++static inline void sys1_hw_clk_enable(u32 mask)
++{ ltq_sysctl_clken(SYSCTL_SYS1, mask); }
++static inline void sys1_hw_clk_disable(u32 mask)
++{ ltq_sysctl_clkdis(SYSCTL_SYS1, mask); }
++static inline void sys1_hw_activate_or_reboot(u32 mask)
++{ ltq_sysctl_reboot(SYSCTL_SYS1, mask); }
++
++static inline void sys_eth_hw_activate(u32 mask)
++{ ltq_sysctl_activate(SYSCTL_SYSETH, mask); }
++static inline void sys_eth_hw_deactivate(u32 mask)
++{ ltq_sysctl_deactivate(SYSCTL_SYSETH, mask); }
++static inline void sys_eth_hw_clk_enable(u32 mask)
++{ ltq_sysctl_clken(SYSCTL_SYSETH, mask); }
++static inline void sys_eth_hw_clk_disable(u32 mask)
++{ ltq_sysctl_clkdis(SYSCTL_SYSETH, mask); }
++static inline void sys_eth_hw_activate_or_reboot(u32 mask)
++{ ltq_sysctl_reboot(SYSCTL_SYSETH, mask); }
++
++static inline void sys_gpe_hw_activate(u32 mask)
++{ ltq_sysctl_activate(SYSCTL_SYSGPE, mask); }
++static inline void sys_gpe_hw_deactivate(u32 mask)
++{ ltq_sysctl_deactivate(SYSCTL_SYSGPE, mask); }
++static inline void sys_gpe_hw_clk_enable(u32 mask)
++{ ltq_sysctl_clken(SYSCTL_SYSGPE, mask); }
++static inline void sys_gpe_hw_clk_disable(u32 mask)
++{ ltq_sysctl_clkdis(SYSCTL_SYSGPE, mask); }
++static inline void sys_gpe_hw_activate_or_reboot(u32 mask)
++{ ltq_sysctl_reboot(SYSCTL_SYSGPE, mask); }
++static inline int sys_gpe_hw_is_activated(u32 mask)
++{ return 1; }
++
++#endif /* __FALCON_SYSCTRL_H */
+diff --git a/arch/mips/lantiq/falcon/sysctrl.c b/arch/mips/lantiq/falcon/sysctrl.c
+--- a/arch/mips/lantiq/falcon/sysctrl.c
++++ b/arch/mips/lantiq/falcon/sysctrl.c
+@@ -262,3 +262,44 @@ void __init ltq_soc_init(void)
+ 	clkdev_add_sys("1e100c00.serial", SYSCTL_SYS1, ACTS_ASC0_ACT);
+ 	clkdev_add_sys("1e200000.i2c", SYSCTL_SYS1, ACTS_I2C_ACT);
+ }
++
++
++/*
++ * for compatibility to external drivers from Lantiq
++ * see arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h
++ */
++
++void ltq_sysctl_activate(int module, unsigned int mask)
++{
++	struct clk clk = { .module = module, .bits = mask };
++	sysctl_activate(&clk);
++}
++EXPORT_SYMBOL(ltq_sysctl_activate);
++
++void ltq_sysctl_deactivate(int module, unsigned int mask)
++{
++	struct clk clk = { .module = module, .bits = mask };
++	sysctl_deactivate(&clk);
++}
++EXPORT_SYMBOL(ltq_sysctl_deactivate);
++
++void ltq_sysctl_clken(int module, unsigned int mask)
++{
++	struct clk clk = { .module = module, .bits = mask };
++	sysctl_clken(&clk);
++}
++EXPORT_SYMBOL(ltq_sysctl_clken);
++
++void ltq_sysctl_clkdis(int module, unsigned int mask)
++{
++	struct clk clk = { .module = module, .bits = mask };
++	sysctl_clkdis(&clk);
++}
++EXPORT_SYMBOL(ltq_sysctl_clkdis);
++
++void ltq_sysctl_reboot(int module, unsigned int mask)
++{
++	struct clk clk = { .module = module, .bits = mask };
++	sysctl_reboot(&clk);
++}
++EXPORT_SYMBOL(ltq_sysctl_reboot);
diff --git a/target/linux/lantiq/patches-3.18/1017-udp-in-kernel-redirect.patch b/target/linux/lantiq/patches-3.18/1017-udp-in-kernel-redirect.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/1017-udp-in-kernel-redirect.patch
@@ -0,0 +1,376 @@
+From: John Crispin <blogic@openwrt.org>
+Date: Thu, 29 Sep 2011 20:29:54 +0200
+
+[PATCH 17/25] udp in-kernel redirect
+
+---
+ include/linux/udp_redirect.h |   57 +++++++++++++
+ net/Kconfig                  |    6 ++
+ net/ipv4/Makefile            |    3 +
+ net/ipv4/udp.c               |   28 ++++++-
+ net/ipv4/udp_redirect_symb.c |  186 ++++++++++++++++++++++++++++++++++++++++++
+ 5 files changed, 276 insertions(+), 4 deletions(-)
+ create mode 100644 include/linux/udp_redirect.h
+ create mode 100644 net/ipv4/udp_redirect_symb.c
+
+diff --git a/include/linux/udp_redirect.h b/include/linux/udp_redirect.h
+new file mode 100644
+--- /dev/null
++++ b/include/linux/udp_redirect.h
+@@ -0,0 +1,57 @@
++#ifndef _UDP_REDIRECT_H
++#define _UDP_REDIRECT_H
++
++/******************************************************************************
++
++                               Copyright (c) 2006
++                            Infineon Technologies AG
++                     Am Campeon 1-12; 81726 Munich, Germany
++
++  THE DELIVERY OF THIS SOFTWARE AS WELL AS THE HEREBY GRANTED NON-EXCLUSIVE,
++  WORLDWIDE LICENSE TO USE, COPY, MODIFY, DISTRIBUTE AND SUBLICENSE THIS
++  SOFTWARE IS FREE OF CHARGE.
++
++  THE LICENSED SOFTWARE IS PROVIDED "AS IS" AND INFINEON EXPRESSLY DISCLAIMS
++  ALL REPRESENTATIONS AND WARRANTIES, WHETHER EXPRESS OR IMPLIED, INCLUDING
++  WITHOUT LIMITATION, WARRANTIES OR REPRESENTATIONS OF WORKMANSHIP,
++  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, DURABILITY, THAT THE
++  OPERATING OF THE LICENSED SOFTWARE WILL BE ERROR FREE OR FREE OF ANY THIRD
++  PARTY CLAIMS, INCLUDING WITHOUT LIMITATION CLAIMS OF THIRD PARTY INTELLECTUAL
++  PROPERTY INFRINGEMENT.
++
++  EXCEPT FOR ANY LIABILITY DUE TO WILFUL ACTS OR GROSS NEGLIGENCE AND EXCEPT
++  FOR ANY PERSONAL INJURY INFINEON SHALL IN NO EVENT BE LIABLE FOR ANY CLAIM
++  OR DAMAGES OF ANY KIND, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
++  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
++  DEALINGS IN THE SOFTWARE.
++
++******************************************************************************/
++
++/* ============================= */
++/* Includes                      */
++/* ============================= */
++#ifndef _LINUX_TYPES_H
++#include <linux/types.h>
++#endif
++
++
++/* ============================= */
++/* Definitions                   */
++/* ============================= */
++#define UDP_REDIRECT_MAGIC (void*)0x55445052L
++
++
++/* ============================= */
++/* Global variable declaration   */
++/* ============================= */
++extern int (*udp_do_redirect_fn)(struct sock *sk, struct sk_buff *skb);
++extern int (*udpredirect_getfrag_fn)(void *p, char * to,
++                                     int offset, int fraglen, int odd,
++                                     struct sk_buff *skb);
++/* ============================= */
++/* Global function declaration   */
++/* ============================= */
++
++extern int udpredirect_getfrag(void *p, char * to, int offset,
++                               int fraglen, int odd, struct sk_buff *skb);
++#endif
+diff --git a/net/Kconfig b/net/Kconfig
+--- a/net/Kconfig
++++ b/net/Kconfig
+@@ -82,6 +82,12 @@ config INET
+ 
+ 	  Short answer: say Y.
+ 
++config IFX_UDP_REDIRECT
++	bool "IFX Kernel Packet Interface for UDP redirection"
++	help
++	  You can say Y here if you want to use hooks from kernel for
++	  UDP redirection.
++
+ if INET
+ source "net/ipv4/Kconfig"
+ source "net/ipv6/Kconfig"
+diff --git a/net/ipv4/Makefile b/net/ipv4/Makefile
+--- a/net/ipv4/Makefile
++++ b/net/ipv4/Makefile
+@@ -15,6 +15,9 @@ obj-y     := route.o inetpeer.o protocol
+ 
+ obj-$(CONFIG_NET_IP_TUNNEL) += ip_tunnel.o
+ obj-$(CONFIG_SYSCTL) += sysctl_net_ipv4.o
++ifneq ($(CONFIG_IFX_UDP_REDIRECT),)
++obj-$(CONFIG_IFX_UDP_REDIRECT) += udp_redirect_symb.o
++endif
+ obj-$(CONFIG_PROC_FS) += proc.o
+ obj-$(CONFIG_IP_MULTIPLE_TABLES) += fib_rules.o
+ obj-$(CONFIG_IP_MROUTE) += ipmr.o
+diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
+--- a/net/ipv4/udp.c
++++ b/net/ipv4/udp.c
+@@ -114,6 +114,10 @@
+ #include <net/busy_poll.h>
+ #include "udp_impl.h"
+ 
++#if defined(CONFIG_IFX_UDP_REDIRECT) || defined(CONFIG_IFX_UDP_REDIRECT_MODULE)
++#include <linux/udp_redirect.h>
++#endif
++
+ struct udp_table udp_table __read_mostly;
+ EXPORT_SYMBOL(udp_table);
+ 
+@@ -877,7 +881,7 @@ int udp_sendmsg(struct kiocb *iocb, stru
+ 	u8  tos;
+ 	int err, is_udplite = IS_UDPLITE(sk);
+ 	int corkreq = up->corkflag || msg->msg_flags&MSG_MORE;
+-	int (*getfrag)(void *, char *, int, int, int, struct sk_buff *);
++	int (*getfrag)(void *, char *, int, int, int, struct sk_buff *) = NULL;
+ 	struct sk_buff *skb;
+ 	struct ip_options_data opt_copy;
+ 
+@@ -896,7 +900,13 @@ int udp_sendmsg(struct kiocb *iocb, stru
+ 	ipc.ttl = 0;
+ 	ipc.tos = -1;
+ 
+-	getfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag;
++/* UDPREDIRECT */
++#if defined(CONFIG_IFX_UDP_REDIRECT) || defined(CONFIG_IFX_UDP_REDIRECT_MODULE)
++	if(udpredirect_getfrag_fn && sk->sk_user_data == UDP_REDIRECT_MAGIC)
++		getfrag = udpredirect_getfrag_fn;
++	else
++#endif /* IFX_UDP_REDIRECT */
++		getfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag;
+ 
+ 	fl4 = &inet->cork.fl.u.ip4;
+ 	if (up->pending) {
+@@ -1736,6 +1746,7 @@ int __udp4_lib_rcv(struct sk_buff *skb, 
+ 	struct rtable *rt = skb_rtable(skb);
+ 	__be32 saddr, daddr;
+ 	struct net *net = dev_net(skb->dev);
++	int ret = 0;
+ 
+ 	/*
+ 	 *  Validate the packet.
+@@ -1769,6 +1780,7 @@ int __udp4_lib_rcv(struct sk_buff *skb, 
+ 		if (unlikely(sk->sk_rx_dst != dst))
+ 			udp_sk_rx_dst_set(sk, dst);
+ 
++
+ 		ret = udp_queue_rcv_skb(sk, skb);
+ 		sock_put(sk);
+ 		/* a return value > 0 means to resubmit the input, but
+@@ -1792,6 +1804,15 @@ int __udp4_lib_rcv(struct sk_buff *skb, 
+ 			skb_checksum_try_convert(skb, IPPROTO_UDP, uh->check,
+ 						 inet_compute_pseudo);
+ 
++		/* UDPREDIRECT */
++#if defined(CONFIG_IFX_UDP_REDIRECT) || defined(CONFIG_IFX_UDP_REDIRECT_MODULE)
++		if(udp_do_redirect_fn && sk->sk_user_data == UDP_REDIRECT_MAGIC)
++		{
++			udp_do_redirect_fn(sk,skb);
++			kfree_skb(skb);
++			return(0);
++		}
++#endif
+ 		ret = udp_queue_rcv_skb(sk, skb);
+ 		sock_put(sk);
+ 
+@@ -2249,7 +2270,7 @@ struct proto udp_prot = {
+ 	.clear_sk	   = sk_prot_clear_portaddr_nulls,
+ };
+ EXPORT_SYMBOL(udp_prot);
+-
++EXPORT_SYMBOL(udp_rcv);
+ /* ------------------------------------------------------------------------ */
+ #ifdef CONFIG_PROC_FS
+ 
+diff --git a/net/ipv4/udp_redirect_symb.c b/net/ipv4/udp_redirect_symb.c
+new file mode 100644
+--- /dev/null
++++ b/net/ipv4/udp_redirect_symb.c
+@@ -0,0 +1,186 @@
++/******************************************************************************
++
++                               Copyright (c) 2006
++                            Infineon Technologies AG
++                     Am Campeon 1-12; 81726 Munich, Germany
++
++  THE DELIVERY OF THIS SOFTWARE AS WELL AS THE HEREBY GRANTED NON-EXCLUSIVE,
++  WORLDWIDE LICENSE TO USE, COPY, MODIFY, DISTRIBUTE AND SUBLICENSE THIS
++  SOFTWARE IS FREE OF CHARGE.
++
++  THE LICENSED SOFTWARE IS PROVIDED "AS IS" AND INFINEON EXPRESSLY DISCLAIMS
++  ALL REPRESENTATIONS AND WARRANTIES, WHETHER EXPRESS OR IMPLIED, INCLUDING
++  WITHOUT LIMITATION, WARRANTIES OR REPRESENTATIONS OF WORKMANSHIP,
++  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, DURABILITY, THAT THE
++  OPERATING OF THE LICENSED SOFTWARE WILL BE ERROR FREE OR FREE OF ANY THIRD
++  PARTY CLAIMS, INCLUDING WITHOUT LIMITATION CLAIMS OF THIRD PARTY INTELLECTUAL
++  PROPERTY INFRINGEMENT.
++
++  EXCEPT FOR ANY LIABILITY DUE TO WILFUL ACTS OR GROSS NEGLIGENCE AND EXCEPT
++  FOR ANY PERSONAL INJURY INFINEON SHALL IN NO EVENT BE LIABLE FOR ANY CLAIM
++  OR DAMAGES OF ANY KIND, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
++  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
++  DEALINGS IN THE SOFTWARE.
++
++******************************************************************************/
++#if defined(CONFIG_IFX_UDP_REDIRECT) || defined(CONFIG_IFX_UDP_REDIRECT_MODULE)
++/* ============================= */
++/* Includes                      */
++/* ============================= */
++#include <net/checksum.h>
++#include <net/udp.h>
++#include <linux/module.h>
++#include <linux/skbuff.h>
++#include <linux/udp_redirect.h>
++
++/* ============================= */
++/* Global variable definition    */
++/* ============================= */
++int (*udpredirect_getfrag_fn) (void *p, char * to, int offset,
++                               int fraglen, int odd, struct sk_buff *skb) = NULL;
++int (*udp_do_redirect_fn)(struct sock *sk, struct sk_buff *skb) = NULL;
++
++/* ============================= */
++/* Local type definitions        */
++/* ============================= */
++struct udpfakehdr
++{
++  struct udphdr uh;
++  u32 saddr;
++  u32 daddr;
++  struct iovec *iov;
++  u32 wcheck;
++};
++
++/* ============================= */
++/* Local function declaration    */
++/* ============================= */
++static int udpredirect_csum_partial_copy_fromiovecend(unsigned char *kdata,
++              struct iovec *iov, int offset, unsigned int len, __wsum *csump);
++
++static int udpredirect_memcpy_fromiovecend(unsigned char *kdata, struct iovec *iov, int offset,
++                        int len);
++
++/* ============================= */
++/* Global function definition    */
++/* ============================= */
++
++/*
++   Copy of udp_getfrag() from udp.c
++   This function exists because no copy_from_user() is needed for udpredirect.
++*/
++
++int
++udpredirect_getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb)
++{
++   struct iovec *iov = from;
++
++        if (skb->ip_summed == CHECKSUM_PARTIAL) {
++                if (udpredirect_memcpy_fromiovecend(to, iov, offset, len) < 0)
++                        return -EFAULT;
++        } else {
++                __wsum csum = 0;
++                if (udpredirect_csum_partial_copy_fromiovecend(to, iov, offset, len, &csum) < 0)
++                        return -EFAULT;
++                skb->csum = csum_block_add(skb->csum, csum, odd);
++        }
++        return 0;
++}
++
++static int udpredirect_memcpy_fromiovecend(unsigned char *kdata, struct iovec *iov, int offset,
++                        int len)
++{
++        /* Skip over the finished iovecs */
++        while (offset >= iov->iov_len) {
++                offset -= iov->iov_len;
++                iov++;
++        }
++
++        while (len > 0) {
++                u8 __user *base = iov->iov_base + offset;
++                int copy = min_t(unsigned int, len, iov->iov_len - offset);
++
++                offset = 0;
++                memcpy(kdata, base, copy);
++                len -= copy;
++                kdata += copy;
++                iov++;
++        }
++
++        return 0;
++}
++
++/*
++   Copy of csum_partial_copy_fromiovecend() from iovec.c
++   This function exists because no copy_from_user() is needed for udpredirect.
++*/
++
++int udpredirect_csum_partial_copy_fromiovecend(unsigned char *kdata, struct iovec *iov,
++				 int offset, unsigned int len, __wsum *csump)
++{
++	__wsum csum = *csump;
++	int partial_cnt = 0, err = 0;
++
++	/* Skip over the finished iovecs */
++	while (offset >= iov->iov_len) {
++		offset -= iov->iov_len;
++		iov++;
++	}
++
++	while (len > 0) {
++		u8 __user *base = iov->iov_base + offset;
++		int copy = min_t(unsigned int, len, iov->iov_len - offset);
++
++		offset = 0;
++
++		/* There is a remnant from previous iov. */
++		if (partial_cnt) {
++			int par_len = 4 - partial_cnt;
++
++			/* iov component is too short ... */
++			if (par_len > copy) {
++				memcpy(kdata, base, copy);
++				kdata += copy;
++				base  += copy;
++				partial_cnt += copy;
++				len   -= copy;
++				iov++;
++				if (len)
++					continue;
++				*csump = csum_partial(kdata - partial_cnt,
++							 partial_cnt, csum);
++				goto out;
++			}
++			memcpy(kdata, base, par_len);
++			csum = csum_partial(kdata - partial_cnt, 4, csum);
++			kdata += par_len;
++			base  += par_len;
++			copy  -= par_len;
++			len   -= par_len;
++			partial_cnt = 0;
++		}
++
++		if (len > copy) {
++			partial_cnt = copy % 4;
++			if (partial_cnt) {
++				copy -= partial_cnt;
++				memcpy(kdata + copy, base + copy, partial_cnt);
++			}
++		}
++
++		if (copy) {
++			csum = csum_partial_copy_nocheck(base, kdata, copy, csum);
++		}
++		len   -= copy + partial_cnt;
++		kdata += copy + partial_cnt;
++		iov++;
++	}
++        *csump = csum;
++out:
++	return err;
++}
++
++EXPORT_SYMBOL(udpredirect_getfrag);
++EXPORT_SYMBOL(udp_do_redirect_fn);
++EXPORT_SYMBOL(udpredirect_getfrag_fn);
++#endif /* CONFIG_IFX_UDP_REDIRECT* */
diff --git a/target/linux/lantiq/patches-3.18/1100-lantiq-irq-icu_map-number.patch b/target/linux/lantiq/patches-3.18/1100-lantiq-irq-icu_map-number.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/1100-lantiq-irq-icu_map-number.patch
@@ -0,0 +1,14 @@
+in icu_map the virtual irq should be used instead of the hw_irq
+
+diff --git a/arch/mips/lantiq/irq.c b/arch/mips/lantiq/irq.c
+--- a/arch/mips/lantiq/irq.c
++++ b/arch/mips/lantiq/irq.c
+@@ -345,7 +345,7 @@ static int icu_map(struct irq_domain *d,
+ 		if (hw == ltq_eiu_irq[i].start)
+ 			chip = &ltq_eiu_type;
+ 
+-	irq_set_chip_and_handler(hw, chip, handle_level_irq);
++	irq_set_chip_and_handler(irq, chip, handle_level_irq);
+ 
+ 	return 0;
+ }
diff --git a/target/linux/lantiq/patches-3.18/2000-falcon-fix-reboot.patch b/target/linux/lantiq/patches-3.18/2000-falcon-fix-reboot.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2000-falcon-fix-reboot.patch
@@ -0,0 +1,15 @@
+Falcon: avoid problems with the gcc "__builtin_unreachable", replace with endless loop
+
+--- a/arch/mips/lantiq/falcon/reset.c
++++ b/arch/mips/lantiq/falcon/reset.c
+@@ -47,6 +47,10 @@ EXPORT_SYMBOL_GPL(ltq_reset_cause);
+ #define WDT_PW1		0x00BE0000
+ #define WDT_PW2		0x00DC0000
+ 
++/* to avoid problems with the gcc "__builtin_unreachable", change definition here! */
++#undef unreachable
++#define unreachable()	do { } while(1)
++
+ static void machine_restart(char *command)
+ {
+ 	local_irq_disable();
diff --git a/target/linux/lantiq/patches-3.18/2002-falcon-fix-gpefreq.patch b/target/linux/lantiq/patches-3.18/2002-falcon-fix-gpefreq.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2002-falcon-fix-gpefreq.patch
@@ -0,0 +1,21 @@
+fix detection of invalid gpe clock setting
+
+--- a/arch/mips/lantiq/falcon/sysctrl.c
++++ b/arch/mips/lantiq/falcon/sysctrl.c
+@@ -147,12 +147,11 @@ static void falcon_gpe_enable(void)
+ 	if (status & (1 << (GPPC_OFFSET + 1)))
+ 		return;
+ 
+-	if (status_r32(STATUS_CONFIG) == 0)
++	freq = (status_r32(STATUS_CONFIG) &
++		GPEFREQ_MASK) >>
++		GPEFREQ_OFFSET;
++	if (freq == 0)
+ 		freq = 1; /* use 625MHz on unfused chip */
+-	else
+-		freq = (status_r32(STATUS_CONFIG) &
+-			GPEFREQ_MASK) >>
+-			GPEFREQ_OFFSET;
+ 
+ 	/* apply new frequency */
+ 	sysctl_w32_mask(SYSCTL_SYS1, 7 << (GPPC_OFFSET + 1),
diff --git a/target/linux/lantiq/patches-3.18/2005-falcon-sysctrl-refactor.patch b/target/linux/lantiq/patches-3.18/2005-falcon-sysctrl-refactor.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2005-falcon-sysctrl-refactor.patch
@@ -0,0 +1,127 @@
+falcon: refactor 'sysctrl_init' from common code in 'ltq_soc_init'
+
+diff --git a/arch/mips/lantiq/falcon/sysctrl.c b/arch/mips/lantiq/falcon/sysctrl.c
+--- a/arch/mips/lantiq/falcon/sysctrl.c
++++ b/arch/mips/lantiq/falcon/sysctrl.c
+@@ -62,17 +62,26 @@
+ #define ACTS_PADCTRL3	0x00200000
+ #define ACTS_PADCTRL4	0x00400000
+ 
+-#define sysctl_w32(m, x, y)	ltq_w32((x), sysctl_membase[m] + (y))
+-#define sysctl_r32(m, x)	ltq_r32(sysctl_membase[m] + (x))
+-#define sysctl_w32_mask(m, clear, set, reg)	\
++#define sysctl_w32(m,val,reg)	ltq_w32((val), sysctl_membase[m] + (reg))
++#define sysctl_r32(m,reg)	ltq_r32(sysctl_membase[m] + (reg))
++#define sysctl_w32_mask(m,clear,set,reg)	\
+ 		sysctl_w32(m, (sysctl_r32(m, reg) & ~(clear)) | (set), reg)
+ 
+-#define status_w32(x, y)	ltq_w32((x), status_membase + (y))
+-#define status_r32(x)		ltq_r32(status_membase + (x))
++#define status_w32(val,reg)	sysctl_w32(3, val, reg)
++#define status_r32(reg)		sysctl_r32(3, reg)
+ 
+-static void __iomem *sysctl_membase[3], *status_membase;
++static const char *sysctrl_compatible[] = {
++	"lantiq,sys1-falcon",
++	"lantiq,syseth-falcon",
++	"lantiq,sysgpe-falcon",
++	"lantiq,status-falcon",
++	"lantiq,ebu-falcon"
++};
++
++static void __iomem *sysctl_membase[ARRAY_SIZE(sysctrl_compatible)];
+ void __iomem *ltq_sys1_membase, *ltq_ebu_membase;
+ 
++
+ void falcon_trigger_hrst(int level)
+ {
+ 	sysctl_w32(SYSCTL_SYS1, level & 1, SYS1_HRSTOUTC);
+@@ -181,62 +190,38 @@ static inline void clkdev_add_sys(const 
+ 	clkdev_add(&clk->cl);
+ }
+ 
++void __iomem * __init sysctrl_init(const char *compatible)
++{
++	struct device_node *np;
++	struct resource res;
++	void __iomem *base;
++
++	np = of_find_compatible_node(NULL, NULL, compatible);
++	if (!np)
++		panic("Failed to load node '%s'", compatible);
++
++	if (of_address_to_resource(np, 0, &res))
++		panic("Failed to get '%s' resources", compatible);
++
++	if (request_mem_region(res.start, resource_size(&res), res.name) < 0)
++		pr_err("Failed to request '%s' mem-region\n", compatible);
++
++	base = ioremap_nocache(res.start, resource_size(&res));
++	if (!base)
++		panic("Failed to remap '%s' resources", compatible);
++
++	return base;
++}
++
+ void __init ltq_soc_init(void)
+ {
+-	struct device_node *np_status =
+-		of_find_compatible_node(NULL, NULL, "lantiq,status-falcon");
+-	struct device_node *np_ebu =
+-		of_find_compatible_node(NULL, NULL, "lantiq,ebu-falcon");
+-	struct device_node *np_sys1 =
+-		of_find_compatible_node(NULL, NULL, "lantiq,sys1-falcon");
+-	struct device_node *np_syseth =
+-		of_find_compatible_node(NULL, NULL, "lantiq,syseth-falcon");
+-	struct device_node *np_sysgpe =
+-		of_find_compatible_node(NULL, NULL, "lantiq,sysgpe-falcon");
+-	struct resource res_status, res_ebu, res_sys[3];
+ 	int i;
+ 
+-	/* check if all the core register ranges are available */
+-	if (!np_status || !np_ebu || !np_sys1 || !np_syseth || !np_sysgpe)
+-		panic("Failed to load core nodes from devicetree");
++	for (i = 0; i < ARRAY_SIZE(sysctrl_compatible); i++)
++		sysctl_membase[i] = sysctrl_init(sysctrl_compatible[i]);
+ 
+-	if (of_address_to_resource(np_status, 0, &res_status) ||
+-			of_address_to_resource(np_ebu, 0, &res_ebu) ||
+-			of_address_to_resource(np_sys1, 0, &res_sys[0]) ||
+-			of_address_to_resource(np_syseth, 0, &res_sys[1]) ||
+-			of_address_to_resource(np_sysgpe, 0, &res_sys[2]))
+-		panic("Failed to get core resources");
+-
+-	if ((request_mem_region(res_status.start, resource_size(&res_status),
+-				res_status.name) < 0) ||
+-		(request_mem_region(res_ebu.start, resource_size(&res_ebu),
+-				res_ebu.name) < 0) ||
+-		(request_mem_region(res_sys[0].start,
+-				resource_size(&res_sys[0]),
+-				res_sys[0].name) < 0) ||
+-		(request_mem_region(res_sys[1].start,
+-				resource_size(&res_sys[1]),
+-				res_sys[1].name) < 0) ||
+-		(request_mem_region(res_sys[2].start,
+-				resource_size(&res_sys[2]),
+-				res_sys[2].name) < 0))
+-		pr_err("Failed to request core resources");
+-
+-	status_membase = ioremap_nocache(res_status.start,
+-					resource_size(&res_status));
+-	ltq_ebu_membase = ioremap_nocache(res_ebu.start,
+-					resource_size(&res_ebu));
+-
+-	if (!status_membase || !ltq_ebu_membase)
+-		panic("Failed to remap core resources");
+-
+-	for (i = 0; i < 3; i++) {
+-		sysctl_membase[i] = ioremap_nocache(res_sys[i].start,
+-						resource_size(&res_sys[i]));
+-		if (!sysctl_membase[i])
+-			panic("Failed to remap sysctrl resources");
+-	}
+ 	ltq_sys1_membase = sysctl_membase[0];
++	ltq_ebu_membase = sysctl_membase[4];
+ 
+ 	falcon_gpe_enable();
+ 
diff --git a/target/linux/lantiq/patches-3.18/2009-GPIO-MIPS-lantiq-add-gpio-driver-for-falcon-SoC.patch b/target/linux/lantiq/patches-3.18/2009-GPIO-MIPS-lantiq-add-gpio-driver-for-falcon-SoC.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2009-GPIO-MIPS-lantiq-add-gpio-driver-for-falcon-SoC.patch
@@ -0,0 +1,399 @@
+From: Thomas Langer <thomas.langer@lantiq.com>
+Date: Thu, 8 Aug 2013 16:19:15 +0200
+
+[PATCH 24/34] GPIO: MIPS: lantiq: add gpio driver for falcon SoC
+
+Add driver for GPIO blocks found on Lantiq FALCON SoC. The SoC has 5 banks of
+up to 32 pads. The GPIO blocks have a per pin IRQs.
+
+Signed-off-by: Thomas Langer <thomas.langer@lantiq.com>
+Acked-by: John Crispin <blogic@openwrt.org>
+Cc: linux-mips@linux-mips.org
+Cc: linux-gpio@vger.kernel.org
+---
+ drivers/gpio/Kconfig       |    5 +
+ drivers/gpio/Makefile      |    1 +
+ drivers/gpio/gpio-falcon.c |  348 ++++++++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 354 insertions(+)
+ create mode 100644 drivers/gpio/gpio-falcon.c
+
+diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
+--- a/drivers/gpio/Kconfig
++++ b/drivers/gpio/Kconfig
+@@ -163,6 +163,11 @@ config GPIO_ZEVIO
+ 	help
+ 	  Say yes here to support the GPIO controller in LSI ZEVIO SoCs.
+ 
++config GPIO_FALCON
++	def_bool y
++	depends on MIPS && SOC_FALCON
++	select GPIO_GENERIC
++
+ config GPIO_MM_LANTIQ
+ 	bool "Lantiq Memory mapped GPIOs"
+ 	depends on LANTIQ && SOC_XWAY
+diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
+--- a/drivers/gpio/Makefile
++++ b/drivers/gpio/Makefile
+@@ -30,6 +30,7 @@ obj-$(CONFIG_GPIO_DWAPB)	+= gpio-dwapb.o
+ obj-$(CONFIG_GPIO_EM)		+= gpio-em.o
+ obj-$(CONFIG_GPIO_EP93XX)	+= gpio-ep93xx.o
+ obj-$(CONFIG_GPIO_F7188X)	+= gpio-f7188x.o
++obj-$(CONFIG_GPIO_FALCON)	+= gpio-falcon.o
+ obj-$(CONFIG_GPIO_GE_FPGA)	+= gpio-ge.o
+ obj-$(CONFIG_GPIO_GRGPIO)	+= gpio-grgpio.o
+ obj-$(CONFIG_GPIO_ICH)		+= gpio-ich.o
+diff --git a/drivers/gpio/gpio-falcon.c b/drivers/gpio/gpio-falcon.c
+new file mode 100644
+--- /dev/null
++++ b/drivers/gpio/gpio-falcon.c
+@@ -0,0 +1,349 @@
++/*
++ *  This program is free software; you can redistribute it and/or modify it
++ *  under the terms of the GNU General Public License version 2 as published
++ *  by the Free Software Foundation.
++ *
++ *  Copyright (C) 2012 Thomas Langer <thomas.langer@lantiq.com>
++ *  Copyright (C) 2012 John Crispin <blogic@openwrt.org>
++ */
++
++#include <linux/gpio.h>
++#include <linux/interrupt.h>
++#include <linux/slab.h>
++#include <linux/export.h>
++#include <linux/err.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_irq.h>
++#include <linux/pinctrl/pinctrl.h>
++#include <linux/pinctrl/consumer.h>
++#include <linux/platform_device.h>
++
++#include <lantiq_soc.h>
++
++/* Data Output Register */
++#define GPIO_OUT            0x00000000
++/* Data Input Register */
++#define GPIO_IN             0x00000004
++/* Direction Register */
++#define GPIO_DIR            0x00000008
++/* External Interrupt Control Register 0 */
++#define GPIO_EXINTCR0       0x00000018
++/* External Interrupt Control Register 1 */
++#define GPIO_EXINTCR1       0x0000001C
++/* IRN Capture Register */
++#define GPIO_IRNCR          0x00000020
++/* IRN Interrupt Configuration Register */
++#define GPIO_IRNCFG		0x0000002C
++/* IRN Interrupt Enable Set Register */
++#define GPIO_IRNRNSET       0x00000030
++/* IRN Interrupt Enable Clear Register */
++#define GPIO_IRNENCLR       0x00000034
++/* Output Set Register */
++#define GPIO_OUTSET         0x00000040
++/* Output Cler Register */
++#define GPIO_OUTCLR         0x00000044
++/* Direction Clear Register */
++#define GPIO_DIRSET         0x00000048
++/* Direction Set Register */
++#define GPIO_DIRCLR         0x0000004C
++
++/* turn a gpio_chip into a falcon_gpio_port */
++#define ctop(c)		container_of(c, struct falcon_gpio_port, gpio_chip)
++/* turn a irq_data into a falcon_gpio_port */
++#define itop(i)		((struct falcon_gpio_port *) irq_get_chip_data(i->irq))
++
++#define port_r32(p, reg)	ltq_r32(p->port + reg)
++#define port_w32(p, val, reg)	ltq_w32(val, p->port + reg)
++#define port_w32_mask(p, clear, set, reg) \
++		port_w32(p, (port_r32(p, reg) & ~(clear)) | (set), reg)
++
++#define MAX_BANKS		5
++#define PINS_PER_PORT		32
++
++struct falcon_gpio_port {
++	struct gpio_chip gpio_chip;
++	void __iomem *port;
++	unsigned int irq_base;
++	unsigned int chained_irq;
++	struct clk *clk;
++	char name[6];
++};
++
++static struct irq_chip falcon_gpio_irq_chip;
++
++static int falcon_gpio_direction_input(struct gpio_chip *chip,
++					unsigned int offset)
++{
++	port_w32(ctop(chip), 1 << offset, GPIO_DIRCLR);
++
++	return 0;
++}
++
++static void falcon_gpio_set(struct gpio_chip *chip, unsigned int offset,
++					int value)
++{
++	if (value)
++		port_w32(ctop(chip), 1 << offset, GPIO_OUTSET);
++	else
++		port_w32(ctop(chip), 1 << offset, GPIO_OUTCLR);
++}
++
++static int falcon_gpio_direction_output(struct gpio_chip *chip,
++					unsigned int offset, int value)
++{
++	falcon_gpio_set(chip, offset, value);
++	port_w32(ctop(chip), 1 << offset, GPIO_DIRSET);
++
++	return 0;
++}
++
++static int falcon_gpio_get(struct gpio_chip *chip, unsigned int offset)
++{
++	if ((port_r32(ctop(chip), GPIO_DIR) >> offset) & 1)
++		return (port_r32(ctop(chip), GPIO_OUT) >> offset) & 1;
++	else
++		return (port_r32(ctop(chip), GPIO_IN) >> offset) & 1;
++}
++
++static int falcon_gpio_request(struct gpio_chip *chip, unsigned offset)
++{
++	int gpio = chip->base + offset;
++
++	return pinctrl_request_gpio(gpio);
++}
++
++static void falcon_gpio_free(struct gpio_chip *chip, unsigned offset)
++{
++	int gpio = chip->base + offset;
++
++	pinctrl_free_gpio(gpio);
++}
++
++static int falcon_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
++{
++	return ctop(chip)->irq_base + offset;
++}
++
++static void falcon_gpio_disable_irq(struct irq_data *d)
++{
++	unsigned int offset = d->irq - itop(d)->irq_base;
++
++	port_w32(itop(d), 1 << offset, GPIO_IRNENCLR);
++}
++
++static void falcon_gpio_enable_irq(struct irq_data *d)
++{
++	unsigned int offset = d->irq - itop(d)->irq_base;
++
++	port_w32(itop(d), 1 << offset, GPIO_IRNRNSET);
++}
++
++static void falcon_gpio_ack_irq(struct irq_data *d)
++{
++	unsigned int offset = d->irq - itop(d)->irq_base;
++
++	port_w32(itop(d), 1 << offset, GPIO_IRNCR);
++}
++
++static void falcon_gpio_mask_and_ack_irq(struct irq_data *d)
++{
++	unsigned int offset = d->irq - itop(d)->irq_base;
++
++	port_w32(itop(d), 1 << offset, GPIO_IRNENCLR);
++	port_w32(itop(d), 1 << offset, GPIO_IRNCR);
++}
++
++static int falcon_gpio_irq_type(struct irq_data *d, unsigned int type)
++{
++	unsigned int offset = d->irq - itop(d)->irq_base;
++	unsigned int mask = 1 << offset;
++
++	if ((type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_NONE)
++		return 0;
++
++	if ((type & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) != 0) {
++		/* level triggered */
++		port_w32_mask(itop(d), 0, mask, GPIO_IRNCFG);
++		irq_set_chip_and_handler_name(d->irq,
++			&falcon_gpio_irq_chip, handle_level_irq, "mux");
++	} else {
++		/* edge triggered */
++		port_w32_mask(itop(d), mask, 0, GPIO_IRNCFG);
++		irq_set_chip_and_handler_name(d->irq,
++			&falcon_gpio_irq_chip, handle_simple_irq, "mux");
++	}
++
++	if ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {
++		port_w32_mask(itop(d), mask, 0, GPIO_EXINTCR0);
++		port_w32_mask(itop(d), 0, mask, GPIO_EXINTCR1);
++	} else {
++		if ((type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_LEVEL_HIGH)) != 0)
++			/* positive logic: rising edge, high level */
++			port_w32_mask(itop(d), mask, 0, GPIO_EXINTCR0);
++		else
++			/* negative logic: falling edge, low level */
++			port_w32_mask(itop(d), 0, mask, GPIO_EXINTCR0);
++		port_w32_mask(itop(d), mask, 0, GPIO_EXINTCR1);
++	}
++
++	return gpio_direction_input(itop(d)->gpio_chip.base + offset);
++}
++
++static void falcon_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
++{
++	struct falcon_gpio_port *gpio_port = irq_desc_get_handler_data(desc);
++	unsigned long irncr;
++	int offset;
++
++	/* acknowledge interrupt */
++	irncr = port_r32(gpio_port, GPIO_IRNCR);
++	port_w32(gpio_port, irncr, GPIO_IRNCR);
++
++	desc->irq_data.chip->irq_ack(&desc->irq_data);
++
++	for_each_set_bit(offset, &irncr, gpio_port->gpio_chip.ngpio)
++		generic_handle_irq(gpio_port->irq_base + offset);
++}
++
++static int falcon_gpio_irq_map(struct irq_domain *d, unsigned int irq,
++				irq_hw_number_t hw)
++{
++	struct falcon_gpio_port *port = d->host_data;
++
++	irq_set_chip_and_handler_name(irq, &falcon_gpio_irq_chip,
++			handle_simple_irq, "mux");
++	irq_set_chip_data(irq, port);
++
++	/* set to negative logic (falling edge, low level) */
++	port_w32_mask(port, 0, 1 << hw, GPIO_EXINTCR0);
++	return 0;
++}
++
++static struct irq_chip falcon_gpio_irq_chip = {
++	.name = "gpio_irq_mux",
++	.irq_mask = falcon_gpio_disable_irq,
++	.irq_unmask = falcon_gpio_enable_irq,
++	.irq_ack = falcon_gpio_ack_irq,
++	.irq_mask_ack = falcon_gpio_mask_and_ack_irq,
++	.irq_set_type = falcon_gpio_irq_type,
++};
++
++static const struct irq_domain_ops irq_domain_ops = {
++	.xlate = irq_domain_xlate_onetwocell,
++	.map = falcon_gpio_irq_map,
++};
++
++static struct irqaction gpio_cascade = {
++	.handler = no_action,
++	.flags = IRQF_DISABLED,
++	.name = "gpio_cascade",
++};
++
++static int falcon_gpio_probe(struct platform_device *pdev)
++{
++	struct pinctrl_gpio_range *gpio_range;
++	struct device_node *node = pdev->dev.of_node;
++	const __be32 *bank = of_get_property(node, "lantiq,bank", NULL);
++	struct falcon_gpio_port *gpio_port;
++	struct resource *gpiores, irqres;
++	int ret, size;
++
++	if (!bank || *bank >= MAX_BANKS)
++		return -ENODEV;
++
++	size = pinctrl_falcon_get_range_size(*bank);
++	if (size < 1) {
++		dev_err(&pdev->dev, "pad not loaded for bank %d\n", *bank);
++		return size;
++	}
++
++	gpio_range = devm_kzalloc(&pdev->dev, sizeof(struct pinctrl_gpio_range),
++				GFP_KERNEL);
++	if (!gpio_range)
++		return -ENOMEM;
++
++	gpio_port = devm_kzalloc(&pdev->dev, sizeof(struct falcon_gpio_port),
++				GFP_KERNEL);
++	if (!gpio_port)
++		return -ENOMEM;
++
++	snprintf(gpio_port->name, 6, "gpio%d", *bank);
++	gpio_port->gpio_chip.label = gpio_port->name;
++	gpio_port->gpio_chip.direction_input = falcon_gpio_direction_input;
++	gpio_port->gpio_chip.direction_output = falcon_gpio_direction_output;
++	gpio_port->gpio_chip.get = falcon_gpio_get;
++	gpio_port->gpio_chip.set = falcon_gpio_set;
++	gpio_port->gpio_chip.request = falcon_gpio_request;
++	gpio_port->gpio_chip.free = falcon_gpio_free;
++	gpio_port->gpio_chip.base = *bank * PINS_PER_PORT;
++	gpio_port->gpio_chip.ngpio = size;
++	gpio_port->gpio_chip.dev = &pdev->dev;
++
++	gpiores = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	gpio_port->port = devm_ioremap_resource(&pdev->dev, gpiores);
++	if (IS_ERR(gpio_port->port))
++		return PTR_ERR(gpio_port->port);
++
++	gpio_port->clk = devm_clk_get(&pdev->dev, NULL);
++	if (IS_ERR(gpio_port->clk))
++		return PTR_ERR(gpio_port->clk);
++	clk_activate(gpio_port->clk);
++
++	if (of_irq_to_resource_table(node, &irqres, 1) == 1) {
++		gpio_port->irq_base = INT_NUM_EXTRA_START + (32 * *bank);
++		gpio_port->gpio_chip.to_irq = falcon_gpio_to_irq;
++		gpio_port->chained_irq = irqres.start;
++		irq_domain_add_legacy(node, size, gpio_port->irq_base, 0,
++					&irq_domain_ops, gpio_port);
++		setup_irq(irqres.start, &gpio_cascade);
++		irq_set_handler_data(irqres.start, gpio_port);
++		irq_set_chained_handler(irqres.start, falcon_gpio_irq_handler);
++	}
++
++	ret = gpiochip_add(&gpio_port->gpio_chip);
++	if (ret)
++		return ret;
++
++	platform_set_drvdata(pdev, gpio_port);
++
++	gpio_range->name = "FALCON GPIO";
++	gpio_range->id = *bank;
++	gpio_range->base = gpio_port->gpio_chip.base;
++	gpio_range->pin_base = gpio_port->gpio_chip.base;
++	gpio_range->npins = gpio_port->gpio_chip.ngpio;
++	gpio_range->gc = &gpio_port->gpio_chip;
++
++	pinctrl_falcon_add_gpio_range(gpio_range);
++
++	return 0;
++}
++
++static const struct of_device_id falcon_gpio_match[] = {
++	{ .compatible = "lantiq,falcon-gpio" },
++	{ .compatible = "lantiq,gpio-falcon" },
++	{},
++};
++MODULE_DEVICE_TABLE(of, falcon_gpio_match);
++
++static struct platform_driver falcon_gpio_driver = {
++	.probe = falcon_gpio_probe,
++	.driver = {
++		.name = "gpio-falcon",
++		.owner = THIS_MODULE,
++		.of_match_table = falcon_gpio_match,
++	},
++};
++
++int __init falcon_gpio_init(void)
++{
++	int ret;
++
++	pr_info("FALC(tm) ON GPIO Driver, (C) 2012 Lantiq Deutschland Gmbh\n");
++	ret = platform_driver_register(&falcon_gpio_driver);
++	if (ret)
++		pr_err("falcon_gpio: Error registering platform driver!");
++	return ret;
++}
++
++subsys_initcall(falcon_gpio_init);
diff --git a/target/linux/lantiq/patches-3.18/2010-falcon-gpio-use-local-function-in-falcon_gpio_irq_type.patch b/target/linux/lantiq/patches-3.18/2010-falcon-gpio-use-local-function-in-falcon_gpio_irq_type.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2010-falcon-gpio-use-local-function-in-falcon_gpio_irq_type.patch
@@ -0,0 +1,15 @@
+use driver internal function in falcon_gpio_irq_type (instead gpio_direction_input)
+to avoid dump in gpio_ensure_requested()
+
+diff --git a/drivers/gpio/gpio-falcon.c b/drivers/gpio/gpio-falcon.c
+--- a/drivers/gpio/gpio-falcon.c
++++ b/drivers/gpio/gpio-falcon.c
+@@ -187,7 +187,7 @@ static int falcon_gpio_irq_type(struct i
+ 		port_w32_mask(itop(d), mask, 0, GPIO_EXINTCR1);
+ 	}
+ 
+-	return gpio_direction_input(itop(d)->gpio_chip.base + offset);
++	return falcon_gpio_direction_input(&itop(d)->gpio_chip, offset);
+ }
+ 
+ static void falcon_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
diff --git a/target/linux/lantiq/patches-3.18/2012-falcon-gpio-remove-irq_base.patch b/target/linux/lantiq/patches-3.18/2012-falcon-gpio-remove-irq_base.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2012-falcon-gpio-remove-irq_base.patch
@@ -0,0 +1,130 @@
+gpio-falcon: don't use a fixed irq_base, use dynamic number assignment
+
+diff --git a/drivers/gpio/gpio-falcon.c b/drivers/gpio/gpio-falcon.c
+--- a/drivers/gpio/gpio-falcon.c
++++ b/drivers/gpio/gpio-falcon.c
+@@ -64,7 +64,7 @@
+ struct falcon_gpio_port {
+ 	struct gpio_chip gpio_chip;
+ 	void __iomem *port;
+-	unsigned int irq_base;
++	struct irq_domain *domain;
+ 	unsigned int chained_irq;
+ 	struct clk *clk;
+ 	char name[6];
+@@ -122,33 +122,33 @@ static void falcon_gpio_free(struct gpio
+ 
+ static int falcon_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+ {
+-	return ctop(chip)->irq_base + offset;
++	return irq_create_mapping(ctop(chip)->domain, offset);
+ }
+ 
+ static void falcon_gpio_disable_irq(struct irq_data *d)
+ {
+-	unsigned int offset = d->irq - itop(d)->irq_base;
++	unsigned int offset = d->hwirq;
+ 
+ 	port_w32(itop(d), 1 << offset, GPIO_IRNENCLR);
+ }
+ 
+ static void falcon_gpio_enable_irq(struct irq_data *d)
+ {
+-	unsigned int offset = d->irq - itop(d)->irq_base;
++	unsigned int offset = d->hwirq;
+ 
+ 	port_w32(itop(d), 1 << offset, GPIO_IRNRNSET);
+ }
+ 
+ static void falcon_gpio_ack_irq(struct irq_data *d)
+ {
+-	unsigned int offset = d->irq - itop(d)->irq_base;
++	unsigned int offset = d->hwirq;
+ 
+ 	port_w32(itop(d), 1 << offset, GPIO_IRNCR);
+ }
+ 
+ static void falcon_gpio_mask_and_ack_irq(struct irq_data *d)
+ {
+-	unsigned int offset = d->irq - itop(d)->irq_base;
++	unsigned int offset = d->hwirq;
+ 
+ 	port_w32(itop(d), 1 << offset, GPIO_IRNENCLR);
+ 	port_w32(itop(d), 1 << offset, GPIO_IRNCR);
+@@ -156,7 +156,7 @@ static void falcon_gpio_mask_and_ack_irq
+ 
+ static int falcon_gpio_irq_type(struct irq_data *d, unsigned int type)
+ {
+-	unsigned int offset = d->irq - itop(d)->irq_base;
++	unsigned int offset = d->hwirq;
+ 	unsigned int mask = 1 << offset;
+ 
+ 	if ((type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_NONE)
+@@ -166,12 +166,12 @@ static int falcon_gpio_irq_type(struct i
+ 		/* level triggered */
+ 		port_w32_mask(itop(d), 0, mask, GPIO_IRNCFG);
+ 		irq_set_chip_and_handler_name(d->irq,
+-			&falcon_gpio_irq_chip, handle_level_irq, "mux");
++			&falcon_gpio_irq_chip, handle_level_irq, "level");
+ 	} else {
+ 		/* edge triggered */
+ 		port_w32_mask(itop(d), mask, 0, GPIO_IRNCFG);
+ 		irq_set_chip_and_handler_name(d->irq,
+-			&falcon_gpio_irq_chip, handle_simple_irq, "mux");
++			&falcon_gpio_irq_chip, handle_simple_irq, "edge");
+ 	}
+ 
+ 	if ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {
+@@ -194,7 +194,7 @@ static void falcon_gpio_irq_handler(unsi
+ {
+ 	struct falcon_gpio_port *gpio_port = irq_desc_get_handler_data(desc);
+ 	unsigned long irncr;
+-	int offset;
++	int offset, child_irq;
+ 
+ 	/* acknowledge interrupt */
+ 	irncr = port_r32(gpio_port, GPIO_IRNCR);
+@@ -202,8 +202,11 @@ static void falcon_gpio_irq_handler(unsi
+ 
+ 	desc->irq_data.chip->irq_ack(&desc->irq_data);
+ 
+-	for_each_set_bit(offset, &irncr, gpio_port->gpio_chip.ngpio)
+-		generic_handle_irq(gpio_port->irq_base + offset);
++	for_each_set_bit(offset, &irncr, gpio_port->gpio_chip.ngpio) {
++		child_irq = irq_find_mapping(gpio_port->domain, offset);
++		if (child_irq)
++			generic_handle_irq(child_irq);
++	}
+ }
+ 
+ static int falcon_gpio_irq_map(struct irq_domain *d, unsigned int irq,
+@@ -212,7 +215,7 @@ static int falcon_gpio_irq_map(struct ir
+ 	struct falcon_gpio_port *port = d->host_data;
+ 
+ 	irq_set_chip_and_handler_name(irq, &falcon_gpio_irq_chip,
+-			handle_simple_irq, "mux");
++				      handle_simple_irq, port->name);
+ 	irq_set_chip_data(irq, port);
+ 
+ 	/* set to negative logic (falling edge, low level) */
+@@ -221,7 +224,7 @@ static int falcon_gpio_irq_map(struct ir
+ }
+ 
+ static struct irq_chip falcon_gpio_irq_chip = {
+-	.name = "gpio_irq_mux",
++	.name = "gpio-falcon",
+ 	.irq_mask = falcon_gpio_disable_irq,
+ 	.irq_unmask = falcon_gpio_enable_irq,
+ 	.irq_ack = falcon_gpio_ack_irq,
+@@ -291,10 +294,9 @@ static int falcon_gpio_probe(struct plat
+ 	clk_activate(gpio_port->clk);
+ 
+ 	if (of_irq_to_resource_table(node, &irqres, 1) == 1) {
+-		gpio_port->irq_base = INT_NUM_EXTRA_START + (32 * *bank);
+ 		gpio_port->gpio_chip.to_irq = falcon_gpio_to_irq;
+ 		gpio_port->chained_irq = irqres.start;
+-		irq_domain_add_legacy(node, size, gpio_port->irq_base, 0,
++		gpio_port->domain = irq_domain_add_simple(node, size, 0,
+ 					&irq_domain_ops, gpio_port);
+ 		setup_irq(irqres.start, &gpio_cascade);
+ 		irq_set_handler_data(irqres.start, gpio_port);
diff --git a/target/linux/lantiq/patches-3.18/2013-falcon-gpio-fix-locking.patch b/target/linux/lantiq/patches-3.18/2013-falcon-gpio-fix-locking.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2013-falcon-gpio-fix-locking.patch
@@ -0,0 +1,21 @@
+gpio-falcon: fix recursive locking in .irq_set_type
+this is called while already holding the "irq_desc_lock"
+
+diff --git a/drivers/gpio/gpio-falcon.c b/drivers/gpio/gpio-falcon.c
+--- a/drivers/gpio/gpio-falcon.c
++++ b/drivers/gpio/gpio-falcon.c
+@@ -166,12 +166,12 @@ static int falcon_gpio_irq_type(struct i
+ 	if ((type & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) != 0) {
+ 		/* level triggered */
+ 		port_w32_mask(itop(d), 0, mask, GPIO_IRNCFG);
+-		irq_set_chip_and_handler_name(d->irq,
++		__irq_set_chip_handler_name_locked(d->irq,
+ 			&falcon_gpio_irq_chip, handle_level_irq, "level");
+ 	} else {
+ 		/* edge triggered */
+ 		port_w32_mask(itop(d), mask, 0, GPIO_IRNCFG);
+-		irq_set_chip_and_handler_name(d->irq,
++		__irq_set_chip_handler_name_locked(d->irq,
+ 			&falcon_gpio_irq_chip, handle_simple_irq, "edge");
+ 	}
+ 
diff --git a/target/linux/lantiq/patches-3.18/2015-falcon-gpio-use-aliases.patch b/target/linux/lantiq/patches-3.18/2015-falcon-gpio-use-aliases.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2015-falcon-gpio-use-aliases.patch
@@ -0,0 +1,62 @@
+gpio-falcon: use and prefer entries from "aliases" as bank number
+
+diff --git a/drivers/gpio/gpio-falcon.c b/drivers/gpio/gpio-falcon.c
+--- a/drivers/gpio/gpio-falcon.c
++++ b/drivers/gpio/gpio-falcon.c
+@@ -250,17 +250,25 @@ static int falcon_gpio_probe(struct plat
+ {
+ 	struct pinctrl_gpio_range *gpio_range;
+ 	struct device_node *node = pdev->dev.of_node;
+-	const __be32 *bank = of_get_property(node, "lantiq,bank", NULL);
++	uint32_t bank;
+ 	struct falcon_gpio_port *gpio_port;
+ 	struct resource *gpiores, irqres;
+ 	int ret, size;
+ 
+-	if (!bank || *bank >= MAX_BANKS)
++	ret = of_alias_get_id(node, "gpio");
++	if (ret >= 0) {
++		bank = ret;
++	} else {
++		if (of_property_read_u32(node, "lantiq,bank", &bank))
++			return -ENODEV;
++	}
++
++	if (bank >= MAX_BANKS)
+ 		return -ENODEV;
+ 
+-	size = pinctrl_falcon_get_range_size(*bank);
++	size = pinctrl_falcon_get_range_size(bank);
+ 	if (size < 1) {
+-		dev_err(&pdev->dev, "pad not loaded for bank %d\n", *bank);
++		dev_err(&pdev->dev, "pad not loaded for bank %d\n", bank);
+ 		return size;
+ 	}
+ 
+@@ -274,7 +282,7 @@ static int falcon_gpio_probe(struct plat
+ 	if (!gpio_port)
+ 		return -ENOMEM;
+ 
+-	snprintf(gpio_port->name, 6, "gpio%d", *bank);
++	snprintf(gpio_port->name, 6, "gpio%d", bank);
+ 	gpio_port->gpio_chip.label = gpio_port->name;
+ 	gpio_port->gpio_chip.direction_input = falcon_gpio_direction_input;
+ 	gpio_port->gpio_chip.direction_output = falcon_gpio_direction_output;
+@@ -282,7 +290,7 @@ static int falcon_gpio_probe(struct plat
+ 	gpio_port->gpio_chip.set = falcon_gpio_set;
+ 	gpio_port->gpio_chip.request = falcon_gpio_request;
+ 	gpio_port->gpio_chip.free = falcon_gpio_free;
+-	gpio_port->gpio_chip.base = *bank * PINS_PER_PORT;
++	gpio_port->gpio_chip.base = bank * PINS_PER_PORT;
+ 	gpio_port->gpio_chip.ngpio = size;
+ 	gpio_port->gpio_chip.dev = &pdev->dev;
+ 
+@@ -313,7 +321,7 @@ static int falcon_gpio_probe(struct plat
+ 	platform_set_drvdata(pdev, gpio_port);
+ 
+ 	gpio_range->name = "FALCON GPIO";
+-	gpio_range->id = *bank;
++	gpio_range->id = bank;
+ 	gpio_range->base = gpio_port->gpio_chip.base;
+ 	gpio_range->pin_base = gpio_port->gpio_chip.base;
+ 	gpio_range->npins = gpio_port->gpio_chip.ngpio;
diff --git a/target/linux/lantiq/patches-3.18/2020-lantiq-serial-use-pinctrl.patch b/target/linux/lantiq/patches-3.18/2020-lantiq-serial-use-pinctrl.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2020-lantiq-serial-use-pinctrl.patch
@@ -0,0 +1,32 @@
+add use of devm_pinctrl_get_select_default to active default pinctrl settings
+
+--- a/drivers/tty/serial/lantiq.c
++++ b/drivers/tty/serial/lantiq.c
+@@ -37,6 +37,8 @@
+ #include <linux/io.h>
+ #include <linux/clk.h>
+ #include <linux/gpio.h>
++#include <linux/pinctrl/consumer.h>
++#include <linux/err.h>
+ 
+ #include <lantiq_soc.h>
+ 
+@@ -681,6 +683,7 @@ lqasc_probe(struct platform_device *pdev
+ 	struct ltq_uart_port *ltq_port;
+ 	struct uart_port *port;
+ 	struct resource *mmres, irqres[3];
++	struct pinctrl *pinctrl;
+ 	int line = 0;
+ 	int ret;
+ 
+@@ -719,6 +722,10 @@ lqasc_probe(struct platform_device *pdev
+ 	port->irq	= irqres[0].start;
+ 	port->mapbase	= mmres->start;
+ 
++	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
++	if (IS_ERR(pinctrl))
++		dev_warn(&pdev->dev, "pins are not configured from the driver\n");
++
+ 	ltq_port->fpiclk = clk_get_fpi();
+ 	if (IS_ERR(ltq_port->fpiclk)) {
+ 		pr_err("failed to get fpi clk\n");
diff --git a/target/linux/lantiq/patches-3.18/2022-lantiq-serial-dummy-tty-tx.patch b/target/linux/lantiq/patches-3.18/2022-lantiq-serial-dummy-tty-tx.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2022-lantiq-serial-dummy-tty-tx.patch
@@ -0,0 +1,115 @@
+this patch adds the possibility to disable tx output in the serial driver
+
+diff --git a/drivers/tty/serial/lantiq.c b/drivers/tty/serial/lantiq.c
+--- a/drivers/tty/serial/lantiq.c
++++ b/drivers/tty/serial/lantiq.c
+@@ -112,8 +112,9 @@
+ #define ASCFSTAT_TXFREEMASK	0x3F000000
+ #define ASCFSTAT_TXFREEOFF	24
+ 
+-static void lqasc_tx_chars(struct uart_port *port);
++static void lqasc_tx_chars(struct uart_port *port, const bool dummy);
+ static struct ltq_uart_port *lqasc_port[MAXPORTS];
++static unsigned int lqasc_tx_block[MAXPORTS] = {0};
+ static struct uart_driver lqasc_reg;
+ static DEFINE_SPINLOCK(ltq_asc_lock);
+ 
+@@ -128,6 +129,17 @@ struct ltq_uart_port {
+ 	unsigned int		err_irq;
+ };
+ 
++int lqasc_tty_block_tx(const unsigned int line, const unsigned int block)
++{
++	if (line >= MAXPORTS)
++		return -1;
++
++	lqasc_tx_block[line] = block;
++
++	return 0;
++}
++EXPORT_SYMBOL(lqasc_tty_block_tx);
++
+ static inline struct
+ ltq_uart_port *to_ltq_uart_port(struct uart_port *port)
+ {
+@@ -145,7 +157,7 @@ lqasc_start_tx(struct uart_port *port)
+ {
+ 	unsigned long flags;
+ 	spin_lock_irqsave(&ltq_asc_lock, flags);
+-	lqasc_tx_chars(port);
++	lqasc_tx_chars(port, lqasc_tx_block[port->line] ? true : false);
+ 	spin_unlock_irqrestore(&ltq_asc_lock, flags);
+ 	return;
+ }
+@@ -223,7 +235,7 @@ lqasc_rx_chars(struct uart_port *port)
+ }
+ 
+ static void
+-lqasc_tx_chars(struct uart_port *port)
++lqasc_tx_chars(struct uart_port *port, const bool dummy)
+ {
+ 	struct circ_buf *xmit = &port->state->xmit;
+ 	if (uart_tx_stopped(port)) {
+@@ -232,9 +244,12 @@ lqasc_tx_chars(struct uart_port *port)
+ 	}
+ 
+ 	while (((ltq_r32(port->membase + LTQ_ASC_FSTAT) &
+-		ASCFSTAT_TXFREEMASK) >> ASCFSTAT_TXFREEOFF) != 0) {
++		ASCFSTAT_TXFREEMASK) >> ASCFSTAT_TXFREEOFF) != 0 || dummy) {
+ 		if (port->x_char) {
+-			ltq_w8(port->x_char, port->membase + LTQ_ASC_TBUF);
++			if (!dummy)
++				ltq_w8(port->x_char,
++				       port->membase + LTQ_ASC_TBUF);
++
+ 			port->icount.tx++;
+ 			port->x_char = 0;
+ 			continue;
+@@ -243,8 +258,9 @@ lqasc_tx_chars(struct uart_port *port)
+ 		if (uart_circ_empty(xmit))
+ 			break;
+ 
+-		ltq_w8(port->state->xmit.buf[port->state->xmit.tail],
+-			port->membase + LTQ_ASC_TBUF);
++		if (!dummy)
++			ltq_w8(port->state->xmit.buf[port->state->xmit.tail],
++			       port->membase + LTQ_ASC_TBUF);
+ 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+ 		port->icount.tx++;
+ 	}
+@@ -597,18 +613,16 @@ lqasc_console_putchar(struct uart_port *
+ 	ltq_w8(ch, port->membase + LTQ_ASC_TBUF);
+ }
+ 
+-
+-static void
+-lqasc_console_write(struct console *co, const char *s, u_int count)
++void lqasc_console_puts(const short index, const char *s, u_int count)
+ {
+ 	struct ltq_uart_port *ltq_port;
+ 	struct uart_port *port;
+ 	unsigned long flags;
+ 
+-	if (co->index >= MAXPORTS)
++	if (index >= MAXPORTS)
+ 		return;
+ 
+-	ltq_port = lqasc_port[co->index];
++	ltq_port = lqasc_port[index];
+ 	if (!ltq_port)
+ 		return;
+ 
+@@ -618,6 +632,13 @@ lqasc_console_write(struct console *co, 
+ 	uart_console_write(port, s, count, lqasc_console_putchar);
+ 	spin_unlock_irqrestore(&ltq_asc_lock, flags);
+ }
++EXPORT_SYMBOL(lqasc_console_puts);
++
++static void
++lqasc_console_write(struct console *co, const char *s, u_int count)
++{
++	lqasc_console_puts(co->index, s, count);
++}
+ 
+ static int __init
+ lqasc_console_setup(struct console *co, char *options)
diff --git a/target/linux/lantiq/patches-3.18/2040-lantiq-i2c-use-pinctrl.patch b/target/linux/lantiq/patches-3.18/2040-lantiq-i2c-use-pinctrl.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2040-lantiq-i2c-use-pinctrl.patch
@@ -0,0 +1,33 @@
+add use of devm_pinctrl_get_select_default to active default pinctrl settings
+
+diff --git a/drivers/i2c/busses/i2c-lantiq.c b/drivers/i2c/busses/i2c-lantiq.c
+--- a/drivers/i2c/busses/i2c-lantiq.c
++++ b/drivers/i2c/busses/i2c-lantiq.c
+@@ -32,6 +32,8 @@
+ #include <linux/platform_device.h>
+ #include <linux/io.h>
+ #include <linux/of_irq.h>
++#include <linux/pinctrl/consumer.h>
++#include <linux/err.h>
+ 
+ #include <lantiq_soc.h>
+ #include "i2c-lantiq.h"
+@@ -576,6 +578,7 @@ static int ltq_i2c_probe(struct platform
+ 	struct ltq_i2c *priv;
+ 	struct i2c_adapter *adap;
+ 	struct resource *mmres, irqres[4];
++	struct pinctrl *pinctrl;
+ 	int ret = 0;
+ 
+ 	dev_dbg(&pdev->dev, "probing\n");
+@@ -587,6 +590,10 @@ static int ltq_i2c_probe(struct platform
+ 		return -ENODEV;
+ 	}
+ 
++	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
++	if (IS_ERR(pinctrl))
++		dev_warn(&pdev->dev, "pins are not configured from the driver\n");
++
+ 	/* allocate private data */
+ 	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+ 	if (!priv) {
diff --git a/target/linux/lantiq/patches-3.18/2041-lantiq-i2c-fix-parent.patch b/target/linux/lantiq/patches-3.18/2041-lantiq-i2c-fix-parent.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2041-lantiq-i2c-fix-parent.patch
@@ -0,0 +1,22 @@
+fix assignment of parent and of_node
+
+diff --git a/drivers/i2c/busses/i2c-lantiq.c b/drivers/i2c/busses/i2c-lantiq.c
+--- a/drivers/i2c/busses/i2c-lantiq.c
++++ b/drivers/i2c/busses/i2c-lantiq.c
+@@ -608,6 +608,8 @@ static int ltq_i2c_probe(struct platform
+ 	adap->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;
+ 	strlcpy(adap->name, DRV_NAME "-adapter", sizeof(adap->name));
+ 	adap->algo = &ltq_i2c_algorithm;
++	adap->dev.parent = &pdev->dev;
++	adap->dev.of_node = node;
+ 
+ 	if (of_property_read_u32(node, "clock-frequency", &priv->i2c_clock)) {
+ 		dev_warn(&pdev->dev, "No I2C speed selected, using 100kHz\n");
+@@ -696,6 +698,7 @@ static int ltq_i2c_probe(struct platform
+ 		dev_err(&pdev->dev, "can't configure adapter\n");
+ 		i2c_del_adapter(adap);
+ 		platform_set_drvdata(pdev, NULL);
++		goto out;
+ 	} else {
+ 		dev_info(&pdev->dev, "version %s\n", DRV_VERSION);
+ 	}
diff --git a/target/linux/lantiq/patches-3.18/2060-spi-xway-to-generic-lantiq-ssc.patch b/target/linux/lantiq/patches-3.18/2060-spi-xway-to-generic-lantiq-ssc.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2060-spi-xway-to-generic-lantiq-ssc.patch
@@ -0,0 +1,1881 @@
+update Lantiq SPI driver to work on more platforms (e.g. Falcon, SVIP)
+
+diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
+--- a/drivers/spi/Kconfig
++++ b/drivers/spi/Kconfig
+@@ -598,13 +598,29 @@ config SPI_NUC900
+ 	  SPI driver for Nuvoton NUC900 series ARM SoCs
+ 
+ config SPI_XWAY
+-	tristate "Lantiq XWAY SPI controller"
+-	depends on LANTIQ && SOC_TYPE_XWAY
++	tristate "Lantiq SPI controller"
++	depends on LANTIQ
+ 	select SPI_BITBANG
+ 	help
+ 	  This driver supports the Lantiq SoC SPI controller in master
+ 	  mode.
+ 
++config SPI_XWAY_BV
++	bool "Byte valid control enable for Lantiq SPI controller"
++	depends on SPI_XWAY
++	help
++	  With byte valid control enabled, the FPI opcode (from CPU) or
++	  D2P_DMA_BE input (from DMA) controls data width for serial
++	  transfer.
++
++config SPI_XWAY_CSI
++	tristate "Lantiq SPI controller for CSI"
++	depends on LANTIQ
++	select SPI_BITBANG
++	help
++	  This driver supports the Lantiq SoC SPI controller in Combined
++	  Serial Interface mode.
++
+ #
+ # Add new SPI master controllers in alphabetical order above this line
+ #
+diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
+--- a/drivers/spi/Makefile
++++ b/drivers/spi/Makefile
+@@ -87,3 +87,4 @@ obj-$(CONFIG_SPI_XCOMM)		+= spi-xcomm.o
+ obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
+ obj-$(CONFIG_SPI_XTENSA_XTFPGA)		+= spi-xtensa-xtfpga.o
+ obj-$(CONFIG_SPI_XWAY)			+= spi-xway.o
++obj-$(CONFIG_SPI_XWAY_CSI)		+= spi-xway-csi.o
+diff --git a/drivers/spi/spi-xway-csi.c b/drivers/spi/spi-xway-csi.c
+new file mode 100644
+--- /dev/null
++++ b/drivers/spi/spi-xway-csi.c
+@@ -0,0 +1,1178 @@
++/*
++ * Lantiq SoC SPI controller for Combined Serial Interface
++ *
++ * Copyright (C) 2011 Daniel Schwierzeck <daniel.schwierzeck@googlemail.com>
++ * Copyright (C) 2012 John Crispin <blogic@openwrt.org>
++ *
++ * This program is free software; you can distribute it and/or modify it
++ * under the terms of the GNU General Public License (Version 2) as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/init.h>
++#include <linux/module.h>
++#include <linux/workqueue.h>
++#include <linux/platform_device.h>
++#include <linux/io.h>
++#include <linux/sched.h>
++#include <linux/delay.h>
++#include <linux/interrupt.h>
++#include <linux/completion.h>
++#include <linux/spinlock.h>
++#include <linux/err.h>
++#include <linux/clk.h>
++#include <linux/spi/spi.h>
++#include <linux/spi/spi_bitbang.h>
++#include <linux/of_gpio.h>
++#include <linux/of_irq.h>
++#include <linux/gpio.h>
++
++#include <lantiq_soc.h>
++
++#define LTQ_SPI_CLC		0x00	/* Clock control */
++#define LTQ_SPI_PISEL		0x04	/* Port input select */
++#define LTQ_SPI_ID		0x08	/* Identification */
++#define LTQ_SPI_CON		0x10	/* Control */
++#define LTQ_SPI_STAT		0x14	/* Status */
++#define LTQ_SPI_WHBSTATE	0x18	/* Write HW modified state */
++#define LTQ_SPI_TB		0x20	/* Transmit buffer */
++#define LTQ_SPI_RB		0x24	/* Receive buffer */
++#define LTQ_SPI_RXFCON		0x30	/* Receive FIFO control */
++#define LTQ_SPI_TXFCON		0x34	/* Transmit FIFO control */
++#define LTQ_SPI_FSTAT		0x38	/* FIFO status */
++#define LTQ_SPI_BRT		0x40	/* Baudrate timer */
++#define LTQ_SPI_BRSTAT		0x44	/* Baudrate timer status */
++#define LTQ_SPI_SFCON		0x60	/* Serial frame control */
++#define LTQ_SPI_SFSTAT		0x64	/* Serial frame status */
++#define LTQ_SPI_GPOCON		0x70	/* General purpose output control */
++#define LTQ_SPI_GPOSTAT		0x74	/* General purpose output status */
++#define LTQ_SPI_FGPO		0x78	/* Forced general purpose output */
++#define LTQ_SPI_RXREQ		0x80	/* Receive request */
++#define LTQ_SPI_RXCNT		0x84	/* Receive count */
++#define LTQ_SPI_DMACON		0xEC	/* DMA control */
++#define LTQ_SPI_IRNEN		0xF4	/* Interrupt node enable */
++#define LTQ_SPI_IRNICR		0xF8	/* Interrupt node interrupt capture */
++#define LTQ_SPI_IRNCR		0xFC	/* Interrupt node control */
++
++#define LTQ_SPI_CLC_SMC_SHIFT	16	/* Clock divider for sleep mode */
++#define LTQ_SPI_CLC_SMC_MASK	0xFF
++#define LTQ_SPI_CLC_RMC_SHIFT	8	/* Clock divider for normal run mode */
++#define LTQ_SPI_CLC_RMC_MASK	0xFF
++#define LTQ_SPI_CLC_DISS	BIT(1)	/* Disable status bit */
++#define LTQ_SPI_CLC_DISR	BIT(0)	/* Disable request bit */
++
++#define LTQ_SPI_ID_TXFS_SHIFT	24	/* Implemented TX FIFO size */
++#define LTQ_SPI_ID_TXFS_MASK	0x3F
++#define LTQ_SPI_ID_RXFS_SHIFT	16	/* Implemented RX FIFO size */
++#define LTQ_SPI_ID_RXFS_MASK	0x3F
++#define LTQ_SPI_ID_REV_MASK	0x1F	/* Hardware revision number */
++#define LTQ_SPI_ID_CFG		BIT(5)	/* DMA interface support */
++
++#define LTQ_SPI_CON_BM_SHIFT	16	/* Data width selection */
++#define LTQ_SPI_CON_BM_MASK	0x1F
++#define LTQ_SPI_CON_EM		BIT(24)	/* Echo mode */
++#define LTQ_SPI_CON_IDLE	BIT(23)	/* Idle bit value */
++#define LTQ_SPI_CON_ENBV	BIT(22)	/* Enable byte valid control */
++#define LTQ_SPI_CON_RUEN	BIT(12)	/* Receive underflow error enable */
++#define LTQ_SPI_CON_TUEN	BIT(11)	/* Transmit underflow error enable */
++#define LTQ_SPI_CON_AEN		BIT(10)	/* Abort error enable */
++#define LTQ_SPI_CON_REN		BIT(9)	/* Receive overflow error enable */
++#define LTQ_SPI_CON_TEN		BIT(8)	/* Transmit overflow error enable */
++#define LTQ_SPI_CON_LB		BIT(7)	/* Loopback control */
++#define LTQ_SPI_CON_PO		BIT(6)	/* Clock polarity control */
++#define LTQ_SPI_CON_PH		BIT(5)	/* Clock phase control */
++#define LTQ_SPI_CON_HB		BIT(4)	/* Heading control */
++#define LTQ_SPI_CON_CSBEN	BIT(3)	/* Chip Select Enable */
++#define LTQ_SPI_CON_CSBINV	BIT(2)	/* Chip Select Invert */
++#define LTQ_SPI_CON_RXOFF	BIT(1)	/* Switch receiver off */
++#define LTQ_SPI_CON_TXOFF	BIT(0)	/* Switch transmitter off */
++
++#define LTQ_SPI_STAT_RXBV_MASK	0x7
++#define LTQ_SPI_STAT_RXBV_SHIFT	28
++#define LTQ_SPI_STAT_BSY	BIT(13)	/* Busy flag */
++#define LTQ_SPI_STAT_RUE	BIT(12)	/* Receive underflow error flag */
++#define LTQ_SPI_STAT_TUE	BIT(11)	/* Transmit underflow error flag */
++#define LTQ_SPI_STAT_AE		BIT(10)	/* Abort error flag */
++#define LTQ_SPI_STAT_RE		BIT(9)	/* Receive error flag */
++#define LTQ_SPI_STAT_TE		BIT(8)	/* Transmit error flag */
++#define LTQ_SPI_STAT_SSEL	BIT(2)	/* Slave Selected bit */
++#define LTQ_SPI_STAT_MS		BIT(1)	/* Master/slave select bit */
++#define LTQ_SPI_STAT_EN		BIT(0)	/* Enable bit */
++
++#define LTQ_SPI_WHBSTATE_SETTUE	BIT(15)	/* Set transmit underflow error flag */
++#define LTQ_SPI_WHBSTATE_SETAE	BIT(14)	/* Set abort error flag */
++#define LTQ_SPI_WHBSTATE_SETRE	BIT(13)	/* Set receive error flag */
++#define LTQ_SPI_WHBSTATE_SETTE	BIT(12)	/* Set transmit error flag */
++#define LTQ_SPI_WHBSTATE_CLRTUE	BIT(11)	/* Clear transmit underflow error
++						flag */
++#define LTQ_SPI_WHBSTATE_CLRAE	BIT(10)	/* Clear abort error flag */
++#define LTQ_SPI_WHBSTATE_CLRRE	BIT(9)	/* Clear receive error flag */
++#define LTQ_SPI_WHBSTATE_CLRTE	BIT(8)	/* Clear transmit error flag */
++#define LTQ_SPI_WHBSTATE_SETME	BIT(7)	/* Set mode error flag */
++#define LTQ_SPI_WHBSTATE_CLRME	BIT(6)	/* Clear mode error flag */
++#define LTQ_SPI_WHBSTATE_SETRUE	BIT(5)	/* Set receive underflow error flag */
++#define LTQ_SPI_WHBSTATE_CLRRUE	BIT(4)	/* Clear receive underflow error flag */
++#define LTQ_SPI_WHBSTATE_SETMS	BIT(3)	/* Set master select bit */
++#define LTQ_SPI_WHBSTATE_CLRMS	BIT(2)	/* Clear master select bit */
++#define LTQ_SPI_WHBSTATE_SETEN	BIT(1)	/* Set enable bit (operational mode) */
++#define LTQ_SPI_WHBSTATE_CLREN	BIT(0)	/* Clear enable bit (config mode */
++#define LTQ_SPI_WHBSTATE_CLR_ERRORS	0x0F50
++
++#define LTQ_SPI_RXFCON_RXFITL_SHIFT	8 /* FIFO interrupt trigger level */
++#define LTQ_SPI_RXFCON_RXFITL_MASK	0x3F
++#define LTQ_SPI_RXFCON_RXFLU		BIT(1)	/* FIFO flush */
++#define LTQ_SPI_RXFCON_RXFEN		BIT(0)	/* FIFO enable */
++
++#define LTQ_SPI_TXFCON_TXFITL_SHIFT	8 /* FIFO interrupt trigger level */
++#define LTQ_SPI_TXFCON_TXFITL_MASK	0x3F
++#define LTQ_SPI_TXFCON_TXFLU		BIT(1)	/* FIFO flush */
++#define LTQ_SPI_TXFCON_TXFEN		BIT(0)	/* FIFO enable */
++
++#define LTQ_SPI_FSTAT_RXFFL_MASK	0x3f
++#define LTQ_SPI_FSTAT_RXFFL_SHIFT	0
++#define LTQ_SPI_FSTAT_TXFFL_MASK	0x3f
++#define LTQ_SPI_FSTAT_TXFFL_SHIFT	8
++
++#define LTQ_SPI_GPOCON_ISCSBN_SHIFT	8
++#define LTQ_SPI_GPOCON_INVOUTN_SHIFT	0
++
++#define LTQ_SPI_FGPO_SETOUTN_SHIFT	8
++#define LTQ_SPI_FGPO_CLROUTN_SHIFT	0
++
++#define LTQ_SPI_RXREQ_RXCNT_MASK	0xFFFF	/* Receive count value */
++#define LTQ_SPI_RXCNT_TODO_MASK		0xFFFF	/* Recevie to-do value */
++
++#define LTQ_SPI_IRNEN_F		BIT(3)	/* Frame end interrupt request */
++#define LTQ_SPI_IRNEN_E		BIT(2)	/* Error end interrupt request */
++#define LTQ_SPI_IRNEN_T		BIT(0)	/* Transmit end interrupt request */
++#define LTQ_SPI_IRNEN_R		BIT(1)	/* Receive end interrupt request */
++#define LTQ_SPI_IRNEN_T_XWAY	BIT(1)	/* Transmit end interrupt request */
++#define LTQ_SPI_IRNEN_R_XWAY	BIT(0)	/* Receive end interrupt request */
++#define LTQ_SPI_IRNEN_ALL	0xF
++
++struct ltq_spi {
++	struct spi_bitbang	bitbang;
++	spinlock_t		lock;
++
++	struct device		*dev;
++	void __iomem		*base;
++	struct clk		*fpiclk;
++	struct clk		*spiclk;
++
++	int			status;
++	int			irq[3];
++
++	const u8		*tx;
++	u8			*rx;
++	u32			tx_cnt;
++	u32			rx_cnt;
++	u32			len;
++	struct spi_transfer	*curr_transfer;
++
++	u32 (*get_tx) (struct ltq_spi *);
++
++	u16			txfs;
++	u16			rxfs;
++	unsigned		dma_support:1;
++	unsigned		cfg_mode:1;
++	int			xrq_gpio;
++
++	u32			irnen_t;
++	u32			irnen_r;
++};
++
++static inline struct ltq_spi *ltq_spi_to_hw(struct spi_device *spi)
++{
++	return spi_master_get_devdata(spi->master);
++}
++
++static inline u32 ltq_spi_reg_read(struct ltq_spi *hw, u32 reg)
++{
++	return ioread32be(hw->base + reg);
++}
++
++static inline void ltq_spi_reg_write(struct ltq_spi *hw, u32 val, u32 reg)
++{
++	iowrite32be(val, hw->base + reg);
++}
++
++static inline void ltq_spi_reg_setbit(struct ltq_spi *hw, u32 bits, u32 reg)
++{
++	u32 val;
++
++	val = ltq_spi_reg_read(hw, reg);
++	val |= bits;
++	ltq_spi_reg_write(hw, val, reg);
++}
++
++static inline void ltq_spi_reg_clearbit(struct ltq_spi *hw, u32 bits, u32 reg)
++{
++	u32 val;
++
++	val = ltq_spi_reg_read(hw, reg);
++	val &= ~bits;
++	ltq_spi_reg_write(hw, val, reg);
++}
++
++static void ltq_spi_hw_enable(struct ltq_spi *hw)
++{
++	u32 clc;
++
++	/* Power-up module */
++	clk_enable(hw->spiclk);
++
++	/*
++	 * Set clock divider for run mode to 1 to
++	 * run at same frequency as FPI bus
++	 */
++	clc = (1 << LTQ_SPI_CLC_RMC_SHIFT);
++	ltq_spi_reg_write(hw, clc, LTQ_SPI_CLC);
++}
++
++static void ltq_spi_hw_disable(struct ltq_spi *hw)
++{
++	/* Set clock divider to 0 and set module disable bit */
++	ltq_spi_reg_write(hw, LTQ_SPI_CLC_DISR, LTQ_SPI_CLC);
++
++	/* Power-down module */
++	clk_disable(hw->spiclk);
++}
++
++static void ltq_spi_reset_fifos(struct ltq_spi *hw)
++{
++	u32 val;
++
++	/*
++	 * Enable and flush FIFOs. Set interrupt trigger level to
++	 * half of FIFO count implemented in hardware.
++	 */
++	if (hw->txfs > 1) {
++		val = hw->txfs << (LTQ_SPI_TXFCON_TXFITL_SHIFT - 1);
++		val |= LTQ_SPI_TXFCON_TXFEN | LTQ_SPI_TXFCON_TXFLU;
++		ltq_spi_reg_write(hw, val, LTQ_SPI_TXFCON);
++	}
++
++	if (hw->rxfs > 1) {
++		val = hw->rxfs << (LTQ_SPI_RXFCON_RXFITL_SHIFT - 1);
++		val |= LTQ_SPI_RXFCON_RXFEN | LTQ_SPI_RXFCON_RXFLU;
++		ltq_spi_reg_write(hw, val, LTQ_SPI_RXFCON);
++	}
++}
++
++static inline int ltq_spi_wait_ready(struct ltq_spi *hw)
++{
++	u32 stat;
++	unsigned long timeout;
++
++	timeout = jiffies + msecs_to_jiffies(200);
++
++	do {
++		stat = ltq_spi_reg_read(hw, LTQ_SPI_STAT);
++		if (!(stat & LTQ_SPI_STAT_BSY))
++			return 0;
++
++		cond_resched();
++	} while (!time_after_eq(jiffies, timeout));
++
++	dev_err(hw->dev, "SPI wait ready timed out stat: %x\n", stat);
++
++	return -ETIMEDOUT;
++}
++
++static inline int ltq_spi_wait_slave_selected(struct ltq_spi *hw)
++{
++	u32 stat;
++	unsigned long timeout;
++
++	/* wait for the smallest amount of time possible, because chip select
++	 * activation occurs within 3 clock periods */
++	timeout = jiffies + 1;
++
++	do {
++		stat = ltq_spi_reg_read(hw, LTQ_SPI_STAT);
++		if (stat & LTQ_SPI_STAT_SSEL)
++			return 0;
++
++		cond_resched();
++	} while (!time_after_eq(jiffies, timeout));
++	return -ETIMEDOUT;
++}
++
++static inline int ltq_spi_wait_slave_not_selected(struct ltq_spi *hw)
++{
++	u32 stat;
++	unsigned long timeout;
++
++	timeout = jiffies + msecs_to_jiffies(200);
++
++	do {
++		stat = ltq_spi_reg_read(hw, LTQ_SPI_STAT);
++		if (!(stat & LTQ_SPI_STAT_SSEL))
++			return 0;
++
++		cond_resched();
++	} while (!time_after_eq(jiffies, timeout));
++
++	dev_err(hw->dev, "SPI wait slave not selected timed out stat: %x\n",
++		stat);
++
++	return -ETIMEDOUT;
++}
++
++static inline int ltq_spi_wait_rx(struct ltq_spi *hw)
++{
++	u32 fstat;
++	unsigned long timeout;
++
++	timeout = jiffies + msecs_to_jiffies(200);
++
++	do {
++		if (hw->len - hw->rx_cnt == 0)
++			return 0;
++		/* Determine how much FIFOs are filled with RX data */
++		fstat = ltq_spi_reg_read(hw, LTQ_SPI_FSTAT);
++		if ((fstat >> LTQ_SPI_FSTAT_RXFFL_SHIFT) &
++			LTQ_SPI_FSTAT_RXFFL_MASK)
++			return 0;
++		cond_resched();
++	} while (!time_after_eq(jiffies, timeout));
++
++	dev_err(hw->dev, "SPI wait for RX data timed out, %d byte(s) missing\n",
++		hw->len - hw->rx_cnt);
++
++	return -ETIMEDOUT;
++}
++
++static void ltq_spi_config_mode_set(struct ltq_spi *hw)
++{
++	if (hw->cfg_mode)
++		return;
++
++	/*
++	 * Putting the SPI module in config mode is only safe if no
++	 * transfer is in progress as indicated by busy flag STATE.BSY.
++	 */
++	if (ltq_spi_wait_ready(hw)) {
++		ltq_spi_reset_fifos(hw);
++		hw->status = -ETIMEDOUT;
++	}
++	ltq_spi_reg_write(hw, LTQ_SPI_WHBSTATE_CLREN, LTQ_SPI_WHBSTATE);
++
++	hw->cfg_mode = 1;
++}
++
++static void ltq_spi_run_mode_set(struct ltq_spi *hw)
++{
++	if (!hw->cfg_mode)
++		return;
++
++	ltq_spi_reg_write(hw, LTQ_SPI_WHBSTATE_SETEN, LTQ_SPI_WHBSTATE);
++
++	hw->cfg_mode = 0;
++}
++
++static u32 ltq_spi_tx_word_u8(struct ltq_spi *hw)
++{
++	const u8 *tx = hw->tx;
++	u32 data = *tx++;
++
++	hw->tx_cnt++;
++	hw->tx++;
++
++	return data;
++}
++
++static u32 ltq_spi_tx_word_u16(struct ltq_spi *hw)
++{
++	const u16 *tx = (u16 *) hw->tx;
++	u32 data = *tx++;
++
++	hw->tx_cnt += 2;
++	hw->tx += 2;
++
++	return data;
++}
++
++static u32 ltq_spi_tx_word_u32(struct ltq_spi *hw)
++{
++	const u32 *tx = (u32 *) hw->tx;
++	u32 data = *tx++;
++
++	hw->tx_cnt += 4;
++	hw->tx += 4;
++
++	return data;
++}
++
++static void ltq_spi_bits_per_word_set(struct spi_device *spi)
++{
++	struct ltq_spi *hw = ltq_spi_to_hw(spi);
++	u32 bm;
++	u8 bits_per_word = spi->bits_per_word;
++
++	/*
++	 * Use either default value of SPI device or value
++	 * from current transfer.
++	 */
++	if (hw->curr_transfer && hw->curr_transfer->bits_per_word)
++		bits_per_word = hw->curr_transfer->bits_per_word;
++
++	if (bits_per_word <= 8)
++		hw->get_tx = ltq_spi_tx_word_u8;
++	else if (bits_per_word <= 16)
++		hw->get_tx = ltq_spi_tx_word_u16;
++	else if (bits_per_word <= 32)
++		hw->get_tx = ltq_spi_tx_word_u32;
++
++	/* CON.BM value = bits_per_word - 1 */
++	bm = (bits_per_word - 1) << LTQ_SPI_CON_BM_SHIFT;
++
++	ltq_spi_reg_clearbit(hw, LTQ_SPI_CON_BM_MASK <<
++			     LTQ_SPI_CON_BM_SHIFT, LTQ_SPI_CON);
++	ltq_spi_reg_setbit(hw, bm, LTQ_SPI_CON);
++}
++
++static void ltq_spi_speed_set(struct spi_device *spi)
++{
++	struct ltq_spi *hw = ltq_spi_to_hw(spi);
++	u32 br, max_speed_hz, spi_clk;
++	u32 speed_hz = spi->max_speed_hz;
++
++	/*
++	 * Use either default value of SPI device or value
++	 * from current transfer.
++	 */
++	if (hw->curr_transfer && hw->curr_transfer->speed_hz)
++		speed_hz = hw->curr_transfer->speed_hz;
++
++	/*
++	 * SPI module clock is derived from FPI bus clock dependent on
++	 * divider value in CLC.RMS which is always set to 1.
++	 */
++	spi_clk = clk_get_rate(hw->fpiclk);
++
++	/*
++	 * Maximum SPI clock frequency in master mode is half of
++	 * SPI module clock frequency. Maximum reload value of
++	 * baudrate generator BR is 2^16.
++	 */
++	max_speed_hz = spi_clk / 2;
++	if (speed_hz >= max_speed_hz)
++		br = 0;
++	else {
++		/* BR calculation formula
++		 * br = (max_speed_hz / speed_hz) - 1;
++		 * given on page 1030 of SVIP product specification sets
++		 * clock frequency bigger than requested, if
++		 * max_speed_hz / speed_hz has a fractional part. The clock
++		 * however must always be at maximum the requested value.
++		 */
++		br = max_speed_hz / speed_hz;
++		if (!(max_speed_hz % speed_hz))
++			br--;
++	}
++
++	if (br > 0xFFFF)
++		br = 0xFFFF;
++	/*
++	 * Whenever the SSC is in slave mode, you have to make sure, that
++	 * BR.BR_VAL is 1 at least. Otherwise serial transmit and receive
++	 * data is corrupted.
++	 */
++	if (br == 0)
++		br = 1;
++
++	ltq_spi_reg_write(hw, br, LTQ_SPI_BRT);
++}
++
++static void ltq_spi_clockmode_set(struct spi_device *spi)
++{
++	struct ltq_spi *hw = ltq_spi_to_hw(spi);
++	u32 con;
++
++	con = ltq_spi_reg_read(hw, LTQ_SPI_CON);
++
++	/*
++	 * SPI mode mapping in CON register:
++	 * Mode CPOL CPHA CON.PO CON.PH
++	 *  0    0    0      0      1
++	 *  1    0    1      0      0
++	 *  2    1    0      1      1
++	 *  3    1    1      1      0
++	 */
++	if (spi->mode & SPI_CPHA)
++		con &= ~LTQ_SPI_CON_PH;
++	else
++		con |= LTQ_SPI_CON_PH;
++
++	if (spi->mode & SPI_CPOL)
++		con |= LTQ_SPI_CON_PO;
++	else
++		con &= ~LTQ_SPI_CON_PO;
++
++	/* Set heading control */
++	if (spi->mode & SPI_LSB_FIRST)
++		con &= ~LTQ_SPI_CON_HB;
++	else
++		con |= LTQ_SPI_CON_HB;
++
++	ltq_spi_reg_write(hw, con, LTQ_SPI_CON);
++}
++
++static void ltq_spi_xmit_set(struct ltq_spi *hw, struct spi_transfer *t)
++{
++	u32 con;
++
++	con = ltq_spi_reg_read(hw, LTQ_SPI_CON);
++
++	if (t) {
++		if (t->tx_buf && t->rx_buf) {
++			con &= ~(LTQ_SPI_CON_TXOFF | LTQ_SPI_CON_RXOFF);
++		} else if (t->rx_buf) {
++			con &= ~LTQ_SPI_CON_RXOFF;
++			con |= LTQ_SPI_CON_TXOFF;
++		} else if (t->tx_buf) {
++			con &= ~LTQ_SPI_CON_TXOFF;
++			con |= LTQ_SPI_CON_RXOFF;
++		}
++	} else
++		con |= (LTQ_SPI_CON_TXOFF | LTQ_SPI_CON_RXOFF);
++
++	ltq_spi_reg_write(hw, con, LTQ_SPI_CON);
++}
++
++
++static void ltq_spi_chipselect(struct spi_device *spi, int cs)
++{
++	struct ltq_spi *hw = ltq_spi_to_hw(spi);
++
++	ltq_spi_wait_ready(hw);
++
++	switch (cs) {
++	case BITBANG_CS_ACTIVE:
++		ltq_spi_bits_per_word_set(spi);
++		ltq_spi_speed_set(spi);
++		ltq_spi_clockmode_set(spi);
++		/* Wait till chip select is inactive, otherwise it could
++		 * happen that transfer is started in the middle of chip
++		 * select and chip select is deactivated before all the
++		 * data is sent/received.
++		 */
++		if (ltq_spi_wait_slave_not_selected(hw))
++			hw->status = -ETIMEDOUT;
++		ltq_spi_run_mode_set(hw);
++		break;
++
++	case BITBANG_CS_INACTIVE:
++		ltq_spi_config_mode_set(hw);
++		break;
++	}
++}
++
++static int ltq_spi_setup_transfer(struct spi_device *spi,
++				  struct spi_transfer *t)
++{
++	struct ltq_spi *hw = ltq_spi_to_hw(spi);
++	u8 bits_per_word = spi->bits_per_word;
++
++	hw->curr_transfer = t;
++
++	if (t && t->bits_per_word)
++		bits_per_word = t->bits_per_word;
++
++	if (bits_per_word > 32)
++		return -EINVAL;
++
++	return 0;
++}
++
++static int ltq_spi_setup(struct spi_device *spi)
++{
++	struct ltq_spi *hw = ltq_spi_to_hw(spi);
++	u32 con;
++
++	/* Set default word length to 8 if not set */
++	if (!spi->bits_per_word)
++		spi->bits_per_word = 8;
++
++	if (spi->bits_per_word > 32)
++		return -EINVAL;
++
++	/*
++	 * reset SPI transmission request - set pin to low
++	 */
++	__gpio_set_value(hw->xrq_gpio, 0);
++	wmb();
++	/* configure chip select */
++	con = ltq_spi_reg_read(hw, LTQ_SPI_CON);
++	con |= LTQ_SPI_CON_CSBEN;
++
++	if (spi->mode & SPI_CS_HIGH)
++		con |= LTQ_SPI_CON_CSBINV;
++	else
++		con &= ~LTQ_SPI_CON_CSBINV;
++
++	ltq_spi_reg_write(hw, con, LTQ_SPI_CON);
++
++	return 0;
++}
++
++static void ltq_spi_cleanup(struct spi_device *spi)
++{
++
++}
++
++
++/*
++ * "Normally" returns Byte Valid = 4.
++ * If the unaligned remainder of the packet is 3 bytes, these have to be
++ * transferred as a combination of a 16-bit and a 8-bit FPI transfer. For
++ * 2 or 1 remaining bytes a single 16-bit or 8-bit transfer will do.
++ */
++static inline u8 _estimate_bv(u32 byte_pos, u32 bytelen)
++{
++	int remainder = bytelen % 4;
++
++	if (byte_pos < (bytelen - remainder))
++		return 4;
++
++	if (remainder == 3) {
++		if (byte_pos == (bytelen - remainder))
++			return 2;
++		else
++			return 1;
++	}
++	return remainder;
++}
++
++
++static void ltq_spi_txfifo_write(struct ltq_spi *hw)
++{
++	u32 fstat, data;
++	u16 fifo_space;
++
++	/* Determine how much FIFOs are free for TX data */
++	fstat = ltq_spi_reg_read(hw, LTQ_SPI_FSTAT);
++	fifo_space = hw->txfs - ((fstat >> LTQ_SPI_FSTAT_TXFFL_SHIFT) &
++					LTQ_SPI_FSTAT_TXFFL_MASK);
++
++	if (!fifo_space)
++		return;
++
++	while (hw->tx_cnt < hw->len && fifo_space) {
++		data = hw->get_tx(hw);
++		ltq_spi_reg_write(hw, data, LTQ_SPI_TB);
++		fifo_space--;
++	}
++}
++
++
++static void ltq_spi_rxfifo_read(struct ltq_spi *hw)
++{
++	u32 fstat, data, mcon;
++	u16 fifo_fill;
++	u8 rxbv, shift, *rx8;
++
++	/* Determine how much FIFOs are filled with RX data */
++	fstat = ltq_spi_reg_read(hw, LTQ_SPI_FSTAT);
++	fifo_fill = ((fstat >> LTQ_SPI_FSTAT_RXFFL_SHIFT)
++			& LTQ_SPI_FSTAT_RXFFL_MASK);
++
++	if (!fifo_fill)
++		return;
++
++	mcon = ltq_spi_reg_read(hw, LTQ_SPI_CON);
++
++	/* In slave mode, MCON.BM is
++	 * the only control of the data width. */
++	while (fifo_fill && hw->rx_cnt < hw->len) {
++		rxbv = ((mcon >> LTQ_SPI_CON_BM_SHIFT &
++			LTQ_SPI_CON_BM_MASK) >> 3) + 1;
++		data = ltq_spi_reg_read(hw, LTQ_SPI_RB);
++		shift = (rxbv - 1) << 3;
++		rx8 = hw->rx;
++		while (rxbv) {
++			*rx8++ = (data >> shift) & 0xFF;
++			rxbv--;
++			shift -= 8;
++			hw->rx_cnt++;
++			hw->rx++;
++		}
++
++		fifo_fill--;
++	}
++}
++
++static void ltq_spi_rxreq_set(struct ltq_spi *hw)
++{
++	u32 rxreq, rxreq_max, rxtodo, stat;
++
++	rxtodo = ltq_spi_reg_read(hw, LTQ_SPI_RXCNT) & LTQ_SPI_RXCNT_TODO_MASK;
++	stat = ltq_spi_reg_read(hw, LTQ_SPI_STAT);
++
++	/*
++	 * In RX-only mode the serial clock is activated only after writing
++	 * the expected amount of RX bytes into RXREQ register.
++	 * To avoid receive overflows at high clocks it is better to request
++	 * only the amount of bytes that fits into all FIFOs. This value
++	 * depends on the FIFO size implemented in hardware.
++	 * Request additional data only if BSY bit is not set, otherwise timeout
++	 * in ltq_spi_wait_ready will occur. Reason of this is unclear as
++	 * documentation states that BSY bit is set either because a serial
++	 * transfer is ongoing or because data is still in one of the FIFOs,
++	 * however, debbugging code added to ltq_spi_wait_ready shows that FIFOs
++	 * are empty (TXFFL and RXFFL of SSC_FSTAT are 0) and in some cases
++	 * also transfer is not ongoing (EN bit of SSC_STATE is 0). The solution
++	 * was taken from ltq_ssc driver from Linux 2.6 written by Andreas Schmidt
++	 * <andreas.schmidt@infineon.com>.
++	 */
++	if (!(stat & LTQ_SPI_STAT_BSY) && !rxtodo) {
++		rxreq = hw->len - hw->rx_cnt;
++		rxreq_max = hw->rxfs << 2;
++		rxreq = min(rxreq_max, rxreq);
++		if (rxreq)
++			ltq_spi_reg_write(hw, rxreq, LTQ_SPI_RXREQ);
++	}
++}
++
++static inline void ltq_spi_tx_complete(struct ltq_spi *hw)
++{
++
++}
++
++
++irqreturn_t ltq_spi_csi_tx_irq(int irq, void *data)
++{
++	struct ltq_spi *hw = data;
++	unsigned long flags;
++	int completed = 0;
++
++	spin_lock_irqsave(&hw->lock, flags);
++
++	if (hw->tx_cnt < hw->len)
++		ltq_spi_txfifo_write(hw);
++
++	if (hw->tx_cnt == hw->len)
++		completed = 1;
++
++	spin_unlock_irqrestore(&hw->lock, flags);
++
++	if (completed)
++		ltq_spi_tx_complete(hw);
++
++	return IRQ_HANDLED;
++}
++
++irqreturn_t ltq_spi_csi_rx_irq(int irq, void *data)
++{
++	struct ltq_spi *hw = data;
++	unsigned long flags;
++
++	spin_lock_irqsave(&hw->lock, flags);
++
++	if (hw->rx_cnt < hw->len) {
++		ltq_spi_rxfifo_read(hw);
++
++		if (hw->tx && hw->tx_cnt < hw->len)
++			ltq_spi_txfifo_write(hw);
++	}
++
++	if (hw->rx_cnt < hw->len && !hw->tx)
++		ltq_spi_rxreq_set(hw);
++
++	spin_unlock_irqrestore(&hw->lock, flags);
++
++	return IRQ_HANDLED;
++}
++
++irqreturn_t ltq_spi_csi_err_irq(int irq, void *data)
++{
++	struct ltq_spi *hw = data;
++	unsigned long flags;
++
++	spin_lock_irqsave(&hw->lock, flags);
++
++	/* Disable all interrupts */
++	ltq_spi_reg_clearbit(hw, LTQ_SPI_IRNEN_ALL, LTQ_SPI_IRNEN);
++
++	dev_err(hw->dev, "SPI error interrupt occurred stat: %x\n",
++		ltq_spi_reg_read(hw, LTQ_SPI_STAT));
++
++	/* Clear all error flags */
++	ltq_spi_reg_write(hw, LTQ_SPI_WHBSTATE_CLR_ERRORS, LTQ_SPI_WHBSTATE);
++
++	/* Flush FIFOs */
++	ltq_spi_reg_setbit(hw, LTQ_SPI_RXFCON_RXFLU, LTQ_SPI_RXFCON);
++	ltq_spi_reg_setbit(hw, LTQ_SPI_TXFCON_TXFLU, LTQ_SPI_TXFCON);
++
++	hw->status = -EIO;
++	spin_unlock_irqrestore(&hw->lock, flags);
++
++	if (hw->tx)
++		ltq_spi_tx_complete(hw);
++
++	return IRQ_HANDLED;
++}
++
++static int ltq_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
++{
++	struct ltq_spi *hw = ltq_spi_to_hw(spi);
++	u32 irq_flags = 0;
++
++	hw->tx = t->tx_buf;
++	hw->rx = t->rx_buf;
++	hw->len = t->len;
++	hw->tx_cnt = 0;
++	hw->rx_cnt = 0;
++	hw->status = 0;
++
++	ltq_spi_xmit_set(hw, t);
++
++	/* Enable error interrupts */
++	ltq_spi_reg_setbit(hw, LTQ_SPI_IRNEN_E, LTQ_SPI_IRNEN);
++
++	if (hw->tx) {
++		/* Initially fill TX FIFO with as much data as possible */
++		ltq_spi_txfifo_write(hw);
++
++		irq_flags |= hw->irnen_t;
++
++		/* Always enable RX interrupt in Full Duplex mode */
++		if (hw->rx)
++			irq_flags |= hw->irnen_r;
++	} else if (hw->rx) {
++		/* Start RX clock */
++		ltq_spi_rxreq_set(hw);
++
++		/* Enable RX interrupt to receive data from RX FIFOs */
++		irq_flags |= hw->irnen_r;
++	}
++
++	/* Enable TX or RX interrupts */
++	ltq_spi_reg_setbit(hw, irq_flags, LTQ_SPI_IRNEN);
++
++	/* A low to high edge requests SPI transmission */
++	__gpio_set_value(hw->xrq_gpio, 1);
++	wmb();
++	/* Wait till start of SPI access (SSC.STATE.SSEL = 1) */
++	/* Note. SSEL = 0 could simply mean that the whole SPI transfer
++	 * has already been completed, and chip select returned to
++	 * inactive state, therefore ltq_spi_wait_slave_selected
++	 * returning non zero result is not signaled as error. */
++	ltq_spi_wait_slave_selected(hw);
++	/* Reset SPI transmission request */
++	__gpio_set_value(hw->xrq_gpio, 0);
++	wmb();
++	/* Wait till end of SPI access (SSC.STATE.SSEL = 0) */
++	if (ltq_spi_wait_slave_not_selected(hw)) {
++		hw->status = -ETIMEDOUT;
++		/* Disable all interrupts */
++		ltq_spi_reg_clearbit(hw, LTQ_SPI_IRNEN_ALL,
++			LTQ_SPI_IRNEN);
++		return hw->status;
++	}
++
++	if (hw->rx) {
++		u32 fstat;
++		u16 fifo_fill;
++
++		/* Completion can't be used with RX, because RX interrupt may
++		 * never occur. RX interrupt occurs only when RX FIFO fill
++		 * reaches specified level (half of FIFO size, in this driver).
++		 * Additional uncertainty is introduced by the fact that rx_cnt
++		 * and rxfs are counting bytes, but FIFO stores words (possibly
++		 * of different size).
++		 * Solution is just to poll for RX data.
++		 */
++		while (hw->rx_cnt < hw->len && !hw->status) {
++			/* Determine how much FIFOs are filled with RX data */
++			fstat = ltq_spi_reg_read(hw, LTQ_SPI_FSTAT);
++			fifo_fill = ((fstat >> LTQ_SPI_FSTAT_RXFFL_SHIFT)
++					& LTQ_SPI_FSTAT_RXFFL_MASK);
++
++			if (fifo_fill)
++				ltq_spi_csi_rx_irq(hw->irq[0], hw);
++			else {
++				/* In slave mode exit, if nothing received
++				 * within some predefined time interval */
++				if (ltq_spi_wait_rx(hw)) {
++					hw->status = -ETIMEDOUT;
++					break;
++				}
++			}
++		}
++	}
++
++	/* Disable all interrupts */
++	ltq_spi_reg_clearbit(hw, LTQ_SPI_IRNEN_ALL, LTQ_SPI_IRNEN);
++
++	if (!hw->status) {
++		/*
++		 * A signaled TX completion doesn't guarantee that the data has been sent
++		 * on the SPI bus, it just garantees that it has been written to TX FIFO.
++		 * Verification of completion of transfer is done by polling of BSY bit of
++		 * SSC_STATE register.
++		 */
++		if (!hw->rx)
++			hw->status = ltq_spi_wait_ready(hw);
++		/*
++		 * Return length of current transfer for bitbang utility code if
++		 * no errors occurred during transmission.
++		 */
++		if (!hw->status)
++			hw->status = hw->len;
++	}
++
++	return hw->status;
++}
++
++static const struct ltq_spi_irq_map {
++	char *name;
++	irq_handler_t handler;
++} ltq_spi_irqs[] = {
++	{ "spi_rx", ltq_spi_csi_rx_irq },
++	{ "spi_tx", ltq_spi_csi_tx_irq },
++	{ "spi_err", ltq_spi_csi_err_irq },
++};
++
++static int ltq_spi_probe(struct platform_device *pdev)
++{
++	struct resource irqres[3];
++	struct spi_master *master;
++	struct resource *r;
++	struct ltq_spi *hw;
++	int ret, i;
++	u32 data, id;
++	struct pinctrl *pinctrl;
++
++	if (of_irq_to_resource_table(pdev->dev.of_node, irqres, 3) != 3) {
++		dev_err(&pdev->dev, "IRQ settings missing in device tree\n");
++		return -EINVAL;
++	}
++
++	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
++	if (IS_ERR(pinctrl))
++		dev_warn(&pdev->dev, "pins are not configured from the driver\n");
++
++	master = spi_alloc_master(&pdev->dev, sizeof(struct ltq_spi));
++	if (!master) {
++		dev_err(&pdev->dev, "spi_alloc_master\n");
++		ret = -ENOMEM;
++		goto err;
++	}
++
++	hw = spi_master_get_devdata(master);
++
++	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (r == NULL) {
++		dev_err(&pdev->dev, "platform_get_resource\n");
++		ret = -ENOENT;
++		goto err_master;
++	}
++
++	r = devm_request_mem_region(&pdev->dev, r->start, resource_size(r),
++			pdev->name);
++	if (!r) {
++		dev_err(&pdev->dev, "failed to request memory region\n");
++		ret = -ENXIO;
++		goto err_master;
++	}
++
++	hw->base = devm_ioremap_nocache(&pdev->dev, r->start, resource_size(r));
++	if (!hw->base) {
++		dev_err(&pdev->dev, "failed to remap memory region\n");
++		ret = -ENXIO;
++		goto err_master;
++	}
++
++	/* setup transfer request gpio used by spi */
++	hw->xrq_gpio = of_get_named_gpio(pdev->dev.of_node, "gpio-xrq",
++		0);
++	if (!gpio_is_valid(hw->xrq_gpio)) {
++		dev_err(&pdev->dev, "invalid gpio %d\n", hw->xrq_gpio);
++		ret = -EINVAL;
++		goto err_master;
++	}
++	/* request a GPIO */
++	ret = devm_gpio_request(&pdev->dev, hw->xrq_gpio, "spi-xrq");
++	if (ret) {
++		dev_err(&pdev->dev, "failed to request GPIO %d\n",
++			hw->xrq_gpio);
++		goto err_master;
++	}
++	/*
++	 * configure pin as output and reset SPI transmission request -
++	 * set pin to low
++	 */
++	ret = gpio_direction_output(hw->xrq_gpio, 0);
++	if (ret) {
++		dev_err(&pdev->dev, "failed to configure gpio %d as output driving low\n",
++			hw->xrq_gpio);
++		goto err_master;
++	}
++
++	memset(hw->irq, 0, sizeof(hw->irq));
++	for (i = 0; i < ARRAY_SIZE(ltq_spi_irqs); i++) {
++		hw->irq[i] = irqres[i].start;
++		ret = request_irq(hw->irq[i], ltq_spi_irqs[i].handler,
++				  0, ltq_spi_irqs[i].name, hw);
++		if (ret) {
++			dev_err(&pdev->dev, "failed to request %s irq (%d)\n",
++					ltq_spi_irqs[i].name, hw->irq[i]);
++			goto err_irq;
++		}
++	}
++
++	hw->fpiclk = clk_get_fpi();
++	if (IS_ERR(hw->fpiclk)) {
++		dev_err(&pdev->dev, "failed to get fpi clock\n");
++		ret = PTR_ERR(hw->fpiclk);
++		goto err_clk;
++	}
++
++	hw->spiclk = clk_get(&pdev->dev, NULL);
++	if (IS_ERR(hw->spiclk)) {
++		dev_err(&pdev->dev, "failed to get spi clock gate\n");
++		ret = PTR_ERR(hw->spiclk);
++		goto err_clk;
++	}
++
++	hw->bitbang.master = spi_master_get(master);
++	hw->bitbang.chipselect = ltq_spi_chipselect;
++	hw->bitbang.setup_transfer = ltq_spi_setup_transfer;
++	hw->bitbang.txrx_bufs = ltq_spi_txrx_bufs;
++
++	if (of_machine_is_compatible("lantiq,ase")) {
++		master->num_chipselect = 3;
++
++		hw->irnen_t = LTQ_SPI_IRNEN_T_XWAY;
++		hw->irnen_r = LTQ_SPI_IRNEN_R_XWAY;
++	} else {
++		master->num_chipselect = 6;
++
++		hw->irnen_t = LTQ_SPI_IRNEN_T;
++		hw->irnen_r = LTQ_SPI_IRNEN_R;
++	}
++
++	master->bus_num = pdev->id;
++	master->setup = ltq_spi_setup;
++	master->cleanup = ltq_spi_cleanup;
++	master->dev.of_node = pdev->dev.of_node;
++
++	hw->dev = &pdev->dev;
++	spin_lock_init(&hw->lock);
++
++	ltq_spi_hw_enable(hw);
++
++	/* Read module capabilities */
++	id = ltq_spi_reg_read(hw, LTQ_SPI_ID);
++	hw->txfs = (id >> LTQ_SPI_ID_TXFS_SHIFT) & LTQ_SPI_ID_TXFS_MASK;
++	hw->rxfs = (id >> LTQ_SPI_ID_TXFS_SHIFT) & LTQ_SPI_ID_TXFS_MASK;
++	hw->dma_support = (id & LTQ_SPI_ID_CFG) ? 1 : 0;
++
++	ltq_spi_config_mode_set(hw);
++
++	/* Enable error checking, disable TX/RX, set idle value high */
++	data = LTQ_SPI_CON_RUEN | LTQ_SPI_CON_AEN |
++		LTQ_SPI_CON_TEN | LTQ_SPI_CON_REN |
++		LTQ_SPI_CON_TXOFF | LTQ_SPI_CON_RXOFF | LTQ_SPI_CON_IDLE;
++	ltq_spi_reg_write(hw, data, LTQ_SPI_CON);
++
++	/* Enable slave mode and clear error flags */
++	ltq_spi_reg_write(hw, LTQ_SPI_WHBSTATE_CLRMS |
++		LTQ_SPI_WHBSTATE_CLR_ERRORS, LTQ_SPI_WHBSTATE);
++
++	/* Reset GPIO/CS registers */
++	ltq_spi_reg_write(hw, 0x0, LTQ_SPI_GPOCON);
++	ltq_spi_reg_write(hw, 0xFF00, LTQ_SPI_FGPO);
++
++	/* Enable and flush FIFOs */
++	ltq_spi_reset_fifos(hw);
++
++	ret = spi_bitbang_start(&hw->bitbang);
++	if (ret) {
++		dev_err(&pdev->dev, "spi_bitbang_start failed\n");
++		goto err_bitbang;
++	}
++
++	platform_set_drvdata(pdev, hw);
++
++	pr_info("Lantiq SoC SPI controller rev %u (TXFS %u, RXFS %u, DMA %u, CSI mode)\n",
++		id & LTQ_SPI_ID_REV_MASK, hw->txfs, hw->rxfs, hw->dma_support);
++
++	return 0;
++
++err_bitbang:
++	ltq_spi_hw_disable(hw);
++
++err_clk:
++	if (hw->fpiclk)
++		clk_put(hw->fpiclk);
++	if (hw->spiclk)
++		clk_put(hw->spiclk);
++
++err_irq:
++	clk_put(hw->fpiclk);
++
++	for (; i > 0; i--)
++		free_irq(hw->irq[i], hw);
++
++err_master:
++	spi_master_put(master);
++
++err:
++	return ret;
++}
++
++static int ltq_spi_remove(struct platform_device *pdev)
++{
++	struct ltq_spi *hw = platform_get_drvdata(pdev);
++	int ret, i;
++
++	ret = spi_bitbang_stop(&hw->bitbang);
++	if (ret)
++		return ret;
++
++	platform_set_drvdata(pdev, NULL);
++
++	ltq_spi_config_mode_set(hw);
++	ltq_spi_hw_disable(hw);
++
++	for (i = 0; i < ARRAY_SIZE(hw->irq); i++)
++		if (0 < hw->irq[i])
++			free_irq(hw->irq[i], hw);
++
++	if (hw->fpiclk)
++		clk_put(hw->fpiclk);
++	if (hw->spiclk)
++		clk_put(hw->spiclk);
++
++	spi_master_put(hw->bitbang.master);
++
++	return 0;
++}
++
++static const struct of_device_id ltq_spi_match[] = {
++	{ .compatible = "lantiq,spi-xway-csi" },
++	{ .compatible = "lantiq,spi-lantiq-ssc-csi" },
++	{},
++};
++MODULE_DEVICE_TABLE(of, ltq_spi_match);
++
++static struct platform_driver ltq_spi_driver = {
++	.probe = ltq_spi_probe,
++	.remove = ltq_spi_remove,
++	.driver = {
++		.name = "spi-lantiq-ssc-csi",
++		.owner = THIS_MODULE,
++		.of_match_table = ltq_spi_match,
++	},
++};
++
++module_platform_driver(ltq_spi_driver);
++
++MODULE_DESCRIPTION("Lantiq SoC SPI controller driver in CSI mode");
++MODULE_AUTHOR("Martins Pukitis <martins.pukitis@lantiq.com>");
++MODULE_LICENSE("GPL");
++MODULE_ALIAS("platform:spi-xway-csi");
++MODULE_ALIAS("platform:spi-lantiq-ssc-csi");
+diff --git a/drivers/spi/spi-xway.c b/drivers/spi/spi-xway.c
+--- a/drivers/spi/spi-xway.c
++++ b/drivers/spi/spi-xway.c
+@@ -80,6 +80,8 @@
+ #define LTQ_SPI_CON_PO		BIT(6)	/* Clock polarity control */
+ #define LTQ_SPI_CON_PH		BIT(5)	/* Clock phase control */
+ #define LTQ_SPI_CON_HB		BIT(4)	/* Heading control */
++#define LTQ_SPI_CON_CSBEN	BIT(3)	/* Chip Select Enable */
++#define LTQ_SPI_CON_CSBINV	BIT(2)	/* Chip Select Invert */
+ #define LTQ_SPI_CON_RXOFF	BIT(1)	/* Switch receiver off */
+ #define LTQ_SPI_CON_TXOFF	BIT(0)	/* Switch transmitter off */
+ 
+@@ -91,6 +93,7 @@
+ #define LTQ_SPI_STAT_AE		BIT(10)	/* Abort error flag */
+ #define LTQ_SPI_STAT_RE		BIT(9)	/* Receive error flag */
+ #define LTQ_SPI_STAT_TE		BIT(8)	/* Transmit error flag */
++#define LTQ_SPI_STAT_SSEL	BIT(2)	/* Slave Selected bit */
+ #define LTQ_SPI_STAT_MS		BIT(1)	/* Master/slave select bit */
+ #define LTQ_SPI_STAT_EN		BIT(0)	/* Enable bit */
+ 
+@@ -139,13 +142,15 @@
+ 
+ #define LTQ_SPI_IRNEN_F		BIT(3)	/* Frame end interrupt request */
+ #define LTQ_SPI_IRNEN_E		BIT(2)	/* Error end interrupt request */
+-#define LTQ_SPI_IRNEN_T		BIT(1)	/* Transmit end interrupt request */
+-#define LTQ_SPI_IRNEN_R		BIT(0)	/* Receive end interrupt request */
++#define LTQ_SPI_IRNEN_T		BIT(0)	/* Transmit end interrupt request */
++#define LTQ_SPI_IRNEN_R		BIT(1)	/* Receive end interrupt request */
++#define LTQ_SPI_IRNEN_T_XWAY	BIT(1)	/* Transmit end interrupt request */
++#define LTQ_SPI_IRNEN_R_XWAY	BIT(0)	/* Receive end interrupt request */
+ #define LTQ_SPI_IRNEN_ALL	0xF
+ 
+ struct ltq_spi {
+ 	struct spi_bitbang	bitbang;
+-	struct completion	done;
++	struct completion	tx_done;
+ 	spinlock_t		lock;
+ 
+ 	struct device		*dev;
+@@ -169,6 +174,9 @@ struct ltq_spi {
+ 	u16			rxfs;
+ 	unsigned		dma_support:1;
+ 	unsigned		cfg_mode:1;
++
++	u32			irnen_t;
++	u32			irnen_r;
+ };
+ 
+ static inline struct ltq_spi *ltq_spi_to_hw(struct spi_device *spi)
+@@ -178,12 +186,20 @@ static inline struct ltq_spi *ltq_spi_to
+ 
+ static inline u32 ltq_spi_reg_read(struct ltq_spi *hw, u32 reg)
+ {
++#ifdef __BIG_ENDIAN
+ 	return ioread32be(hw->base + reg);
++#else /* __LITTLE_ENDIAN */
++	return ioread32(hw->base + reg);
++#endif
+ }
+ 
+ static inline void ltq_spi_reg_write(struct ltq_spi *hw, u32 val, u32 reg)
+ {
++#ifdef __BIG_ENDIAN
+ 	iowrite32be(val, hw->base + reg);
++#else /* __LITTLE_ENDIAN */
++	iowrite32(val, hw->base + reg);
++#endif
+ }
+ 
+ static inline void ltq_spi_reg_setbit(struct ltq_spi *hw, u32 bits, u32 reg)
+@@ -222,7 +238,7 @@ static void ltq_spi_hw_enable(struct ltq
+ static void ltq_spi_hw_disable(struct ltq_spi *hw)
+ {
+ 	/* Set clock divider to 0 and set module disable bit */
+-	ltq_spi_reg_write(hw, LTQ_SPI_CLC_DISS, LTQ_SPI_CLC);
++	ltq_spi_reg_write(hw, LTQ_SPI_CLC_DISR, LTQ_SPI_CLC);
+ 
+ 	/* Power-down module */
+ 	clk_disable(hw->spiclk);
+@@ -343,6 +359,14 @@ static void ltq_spi_bits_per_word_set(st
+ 	if (hw->curr_transfer && hw->curr_transfer->bits_per_word)
+ 		bits_per_word = hw->curr_transfer->bits_per_word;
+ 
++#ifdef CONFIG_SPI_XWAY_BV
++	if (bits_per_word != 8) {
++		dev_err(&spi->dev, "setup: invalid bits_per_word %u (expect 8 in byte valid mode)\n",
++			spi->bits_per_word);
++		bits_per_word = 8;
++	}
++#endif
++
+ 	if (bits_per_word <= 8)
+ 		hw->get_tx = ltq_spi_tx_word_u8;
+ 	else if (bits_per_word <= 16)
+@@ -385,8 +409,18 @@ static void ltq_spi_speed_set(struct spi
+ 	max_speed_hz = spi_clk / 2;
+ 	if (speed_hz >= max_speed_hz)
+ 		br = 0;
+-	else
+-		br = (max_speed_hz / speed_hz) - 1;
++	else {
++		/* BR calculation formula
++		 * br = (max_speed_hz / speed_hz) - 1;
++		 * given on page 1030 of SVIP product specification sets
++		 * clock frequency bigger than requested, if
++		 * max_speed_hz / speed_hz has a fractional part. The clock
++		 * however must always be at maximum the requested value.
++		 */
++		br = max_speed_hz / speed_hz;
++		if (!(max_speed_hz % speed_hz))
++			br--;
++	}
+ 
+ 	if (br > 0xFFFF)
+ 		br = 0xFFFF;
+@@ -472,6 +506,8 @@ static void ltq_spi_chipselect(struct sp
+ {
+ 	struct ltq_spi *hw = ltq_spi_to_hw(spi);
+ 
++	ltq_spi_wait_ready(hw);
++
+ 	switch (cs) {
+ 	case BITBANG_CS_ACTIVE:
+ 		ltq_spi_bits_per_word_set(spi);
+@@ -501,8 +537,10 @@ static int ltq_spi_setup_transfer(struct
+ 
+ 	if (bits_per_word > 32)
+ 		return -EINVAL;
+-
+-	ltq_spi_config_mode_set(hw);
++#ifdef CONFIG_SPI_XWAY_BV
++	if (bits_per_word != 8)
++		return -EINVAL;
++#endif
+ 
+ 	return 0;
+ }
+@@ -511,6 +549,9 @@ static int ltq_spi_setup(struct spi_devi
+ {
+ 	struct ltq_spi *hw = ltq_spi_to_hw(spi);
+ 	u32 gpocon, fgpo;
++#ifdef CONFIG_SPI_XWAY_BV
++	u32 con;
++#endif
+ 
+ 	/* Set default word length to 8 if not set */
+ 	if (!spi->bits_per_word)
+@@ -518,6 +559,16 @@ static int ltq_spi_setup(struct spi_devi
+ 
+ 	if (spi->bits_per_word > 32)
+ 		return -EINVAL;
++#ifdef CONFIG_SPI_XWAY_BV
++	if (spi->bits_per_word != 8) {
++		dev_err(&spi->dev, "setup: invalid bits_per_word %u (expect 8 in byte valid mode)\n",
++			spi->bits_per_word);
++		return -EINVAL;
++	}
++	con = ltq_spi_reg_read(hw, LTQ_SPI_CON);
++	con |= LTQ_SPI_CON_ENBV;
++	ltq_spi_reg_write(hw, con, LTQ_SPI_CON);
++#endif
+ 
+ 	/*
+ 	 * Up to six GPIOs can be connected to the SPI module
+@@ -528,10 +579,11 @@ static int ltq_spi_setup(struct spi_devi
+ 
+ 	if (spi->mode & SPI_CS_HIGH)
+ 		gpocon |= (1 << spi->chip_select);
++	else
++		gpocon &= ~(1 << spi->chip_select);
++	ltq_spi_reg_setbit(hw, gpocon, LTQ_SPI_GPOCON);
+ 
+ 	fgpo = (1 << (spi->chip_select + LTQ_SPI_FGPO_SETOUTN_SHIFT));
+-
+-	ltq_spi_reg_setbit(hw, gpocon, LTQ_SPI_GPOCON);
+ 	ltq_spi_reg_setbit(hw, fgpo, LTQ_SPI_FGPO);
+ 
+ 	return 0;
+@@ -542,10 +594,37 @@ static void ltq_spi_cleanup(struct spi_d
+ 
+ }
+ 
++
++/*
++ * "Normally" returns Byte Valid = 4.
++ * If the unaligned remainder of the packet is 3 bytes, these have to be
++ * transferred as a combination of a 16-bit and a 8-bit FPI transfer. For
++ * 2 or 1 remaining bytes a single 16-bit or 8-bit transfer will do.
++ */
++static inline u8 _estimate_bv(u32 byte_pos, u32 bytelen)
++{
++	int remainder = bytelen % 4;
++
++	if (byte_pos < (bytelen - remainder))
++		return 4;
++
++	if (remainder == 3) {
++		if (byte_pos == (bytelen - remainder))
++			return 2;
++		else
++			return 1;
++	}
++	return remainder;
++}
++
++
+ static void ltq_spi_txfifo_write(struct ltq_spi *hw)
+ {
+ 	u32 fstat, data;
+ 	u16 fifo_space;
++#ifdef CONFIG_SPI_XWAY_BV
++	int i, txbv;
++#endif
+ 
+ 	/* Determine how much FIFOs are free for TX data */
+ 	fstat = ltq_spi_reg_read(hw, LTQ_SPI_FSTAT);
+@@ -556,15 +635,42 @@ static void ltq_spi_txfifo_write(struct 
+ 		return;
+ 
+ 	while (hw->tx_cnt < hw->len && fifo_space) {
++#ifndef CONFIG_SPI_XWAY_BV
+ 		data = hw->get_tx(hw);
+ 		ltq_spi_reg_write(hw, data, LTQ_SPI_TB);
++#else /* CONFIG_SPI_XWAY_BV */
++		txbv = _estimate_bv(hw->tx_cnt, hw->len);
++
++		for (i = 0, data = 0; i < txbv; i++)
++			data |= hw->get_tx(hw) << ((txbv - i - 1) << 3);
++
++		switch (txbv) {
++		case 1:
++			iowrite8(data & 0xFF,
++				(u8 *)(hw->base + LTQ_SPI_TB) + 3);
++			break;
++#ifdef __BIG_ENDIAN
++		case 2:
++			iowrite16be(data & 0xFFFF,
++				(u16 *)(hw->base + LTQ_SPI_TB) + 1);
++			break;
++#else /* __LITTLE_ENDIAN */
++		case 2:
++			iowrite16(data & 0xFFFF, hw->base + LTQ_SPI_TB);
++			break;
++#endif
++		default:
++			ltq_spi_reg_write(hw, data, LTQ_SPI_TB);
++		}
++#endif /* CONFIG_SPI_XWAY_BV */
+ 		fifo_space--;
+ 	}
+ }
+ 
++
+ static void ltq_spi_rxfifo_read(struct ltq_spi *hw)
+ {
+-	u32 fstat, data, *rx32;
++	u32 fstat, data, *rx32, mcon;
+ 	u16 fifo_fill;
+ 	u8 rxbv, shift, *rx8;
+ 
+@@ -576,48 +682,95 @@ static void ltq_spi_rxfifo_read(struct l
+ 	if (!fifo_fill)
+ 		return;
+ 
+-	/*
+-	 * The 32 bit FIFO is always used completely independent from the
+-	 * bits_per_word value. Thus four bytes have to be read at once
+-	 * per FIFO.
+-	 */
+-	rx32 = (u32 *) hw->rx;
+-	while (hw->len - hw->rx_cnt >= 4 && fifo_fill) {
+-		*rx32++ = ltq_spi_reg_read(hw, LTQ_SPI_RB);
+-		hw->rx_cnt += 4;
+-		hw->rx += 4;
+-		fifo_fill--;
+-	}
+-
+-	/*
+-	 * If there are remaining bytes, read byte count from STAT.RXBV
+-	 * register and read the data byte-wise.
+-	 */
+-	while (fifo_fill && hw->rx_cnt < hw->len) {
+-		rxbv = (ltq_spi_reg_read(hw, LTQ_SPI_STAT) >>
+-			LTQ_SPI_STAT_RXBV_SHIFT) & LTQ_SPI_STAT_RXBV_MASK;
+-		data = ltq_spi_reg_read(hw, LTQ_SPI_RB);
+-
+-		shift = (rxbv - 1) * 8;
+-		rx8 = hw->rx;
+-
+-		while (rxbv) {
+-			*rx8++ = (data >> shift) & 0xFF;
+-			rxbv--;
+-			shift -= 8;
+-			hw->rx_cnt++;
+-			hw->rx++;
++	mcon = ltq_spi_reg_read(hw, LTQ_SPI_CON);
++	if (mcon & LTQ_SPI_CON_TXOFF) {
++		/* If transmitter is off, all 32 bits are valid for all words of
++		 * the receive request except the final word, which has less
++		 * than 4 bytes valid if the value in RXREQ.RXCNT is not
++		 * divisible by 4. */
++		rx32 = (u32 *) hw->rx;
++		while (hw->len - hw->rx_cnt >= 4 && fifo_fill) {
++			*rx32++ = ltq_spi_reg_read(hw, LTQ_SPI_RB);
++			hw->rx_cnt += 4;
++			hw->rx += 4;
++			fifo_fill--;
+ 		}
+ 
+-		fifo_fill--;
++		/*
++		 * If there are remaining bytes, read byte count from STAT.RXBV
++		 * register and read the data byte-wise.
++		 */
++		while (fifo_fill && hw->rx_cnt < hw->len) {
++			rxbv = (ltq_spi_reg_read(hw, LTQ_SPI_STAT) >>
++				LTQ_SPI_STAT_RXBV_SHIFT) &
++				LTQ_SPI_STAT_RXBV_MASK;
++			data = ltq_spi_reg_read(hw, LTQ_SPI_RB);
++
++			shift = (rxbv - 1) << 3;
++			rx8 = hw->rx;
++
++			while (rxbv) {
++				*rx8++ = (data >> shift) & 0xFF;
++				rxbv--;
++				shift -= 8;
++				hw->rx_cnt++;
++				hw->rx++;
++			}
++
++			fifo_fill--;
++		}
++	} else {
++		/* If transmitter is on */
++		if (mcon & LTQ_SPI_CON_ENBV) {
++			/* If SSC_MCON.ENBV = 1, the FPI opcode (from CPU)
++			 * or D2P_DMA_BE input (from DMA) controls data width
++			 * for serial transfer. */
++			while (fifo_fill) {
++				rxbv = _estimate_bv(hw->rx_cnt, hw->len);
++				data = ltq_spi_reg_read(hw, LTQ_SPI_RB);
++
++				shift = (rxbv - 1) << 3;
++				rx8 = hw->rx;
++
++				while (rxbv) {
++					*rx8++ = (data >> shift) & 0xFF;
++					rxbv--;
++					shift -= 8;
++					hw->rx_cnt++;
++					hw->rx++;
++				}
++
++				fifo_fill--;
++			}
++		} else {
++			/* If SSC_MCON.ENBV = 0, the bit range
++			 * SSC_MCON.BM:0 contains the received data. */
++			while (fifo_fill && hw->rx_cnt < hw->len) {
++				rxbv = ((mcon >> LTQ_SPI_CON_BM_SHIFT &
++					LTQ_SPI_CON_BM_MASK) >> 3) + 1;
++				data = ltq_spi_reg_read(hw, LTQ_SPI_RB);
++				shift = (rxbv - 1) << 3;
++				rx8 = hw->rx;
++				while (rxbv) {
++					*rx8++ = (data >> shift) & 0xFF;
++					rxbv--;
++					shift -= 8;
++					hw->rx_cnt++;
++					hw->rx++;
++				}
++
++				fifo_fill--;
++			}
++		}
+ 	}
+ }
+ 
+ static void ltq_spi_rxreq_set(struct ltq_spi *hw)
+ {
+-	u32 rxreq, rxreq_max, rxtodo;
++	u32 rxreq, rxreq_max, rxtodo, stat;
+ 
+ 	rxtodo = ltq_spi_reg_read(hw, LTQ_SPI_RXCNT) & LTQ_SPI_RXCNT_TODO_MASK;
++	stat = ltq_spi_reg_read(hw, LTQ_SPI_STAT);
+ 
+ 	/*
+ 	 * In RX-only mode the serial clock is activated only after writing
+@@ -625,20 +778,31 @@ static void ltq_spi_rxreq_set(struct ltq
+ 	 * To avoid receive overflows at high clocks it is better to request
+ 	 * only the amount of bytes that fits into all FIFOs. This value
+ 	 * depends on the FIFO size implemented in hardware.
++	 * Request additional data only if BSY bit is not set, otherwise timeout
++	 * in ltq_spi_wait_ready will occur. Reason of this is unclear as
++	 * documentation states that BSY bit is set either because a serial
++	 * transfer is ongoing or because data is still in one of the FIFOs,
++	 * however, debbugging code added to ltq_spi_wait_ready shows that FIFOs
++	 * are empty (TXFFL and RXFFL of SSC_FSTAT are 0) and in some cases
++	 * also transfer is not ongoing (EN bit of SSC_STATE is 0). The solution
++	 * was taken from ltq_ssc driver from Linux 2.6 written by Andreas Schmidt
++	 * <andreas.schmidt@infineon.com>.
+ 	 */
+-	rxreq = hw->len - hw->rx_cnt;
+-	rxreq_max = hw->rxfs << 2;
+-	rxreq = min(rxreq_max, rxreq);
+-
+-	if (!rxtodo && rxreq)
+-		ltq_spi_reg_write(hw, rxreq, LTQ_SPI_RXREQ);
++	if (!(stat & LTQ_SPI_STAT_BSY) && !rxtodo) {
++		rxreq = hw->len - hw->rx_cnt;
++		rxreq_max = hw->rxfs << 2;
++		rxreq = min(rxreq_max, rxreq);
++		if (rxreq)
++			ltq_spi_reg_write(hw, rxreq, LTQ_SPI_RXREQ);
++	}
+ }
+ 
+-static inline void ltq_spi_complete(struct ltq_spi *hw)
++static inline void ltq_spi_tx_complete(struct ltq_spi *hw)
+ {
+-	complete(&hw->done);
++	complete(&hw->tx_done);
+ }
+ 
++
+ irqreturn_t ltq_spi_tx_irq(int irq, void *data)
+ {
+ 	struct ltq_spi *hw = data;
+@@ -656,7 +820,7 @@ irqreturn_t ltq_spi_tx_irq(int irq, void
+ 	spin_unlock_irqrestore(&hw->lock, flags);
+ 
+ 	if (completed)
+-		ltq_spi_complete(hw);
++		ltq_spi_tx_complete(hw);
+ 
+ 	return IRQ_HANDLED;
+ }
+@@ -665,7 +829,6 @@ irqreturn_t ltq_spi_rx_irq(int irq, void
+ {
+ 	struct ltq_spi *hw = data;
+ 	unsigned long flags;
+-	int completed = 0;
+ 
+ 	spin_lock_irqsave(&hw->lock, flags);
+ 
+@@ -676,16 +839,11 @@ irqreturn_t ltq_spi_rx_irq(int irq, void
+ 			ltq_spi_txfifo_write(hw);
+ 	}
+ 
+-	if (hw->rx_cnt == hw->len)
+-		completed = 1;
+-	else if (!hw->tx)
++	if (hw->rx_cnt < hw->len && !hw->tx)
+ 		ltq_spi_rxreq_set(hw);
+ 
+ 	spin_unlock_irqrestore(&hw->lock, flags);
+ 
+-	if (completed)
+-		ltq_spi_complete(hw);
+-
+ 	return IRQ_HANDLED;
+ }
+ 
+@@ -699,6 +857,9 @@ irqreturn_t ltq_spi_err_irq(int irq, voi
+ 	/* Disable all interrupts */
+ 	ltq_spi_reg_clearbit(hw, LTQ_SPI_IRNEN_ALL, LTQ_SPI_IRNEN);
+ 
++	dev_err(hw->dev, "SPI error interrupt occurred stat: %x\n",
++		ltq_spi_reg_read(hw, LTQ_SPI_STAT));
++
+ 	/* Clear all error flags */
+ 	ltq_spi_reg_write(hw, LTQ_SPI_WHBSTATE_CLR_ERRORS, LTQ_SPI_WHBSTATE);
+ 
+@@ -709,7 +870,8 @@ irqreturn_t ltq_spi_err_irq(int irq, voi
+ 	hw->status = -EIO;
+ 	spin_unlock_irqrestore(&hw->lock, flags);
+ 
+-	ltq_spi_complete(hw);
++	if (hw->tx)
++		ltq_spi_tx_complete(hw);
+ 
+ 	return IRQ_HANDLED;
+ }
+@@ -725,7 +887,7 @@ static int ltq_spi_txrx_bufs(struct spi_
+ 	hw->tx_cnt = 0;
+ 	hw->rx_cnt = 0;
+ 	hw->status = 0;
+-	init_completion(&hw->done);
++	init_completion(&hw->tx_done);
+ 
+ 	ltq_spi_xmit_set(hw, t);
+ 
+@@ -735,32 +897,68 @@ static int ltq_spi_txrx_bufs(struct spi_
+ 	if (hw->tx) {
+ 		/* Initially fill TX FIFO with as much data as possible */
+ 		ltq_spi_txfifo_write(hw);
+-		irq_flags |= LTQ_SPI_IRNEN_T;
++
++		irq_flags |= hw->irnen_t;
+ 
+ 		/* Always enable RX interrupt in Full Duplex mode */
+ 		if (hw->rx)
+-			irq_flags |= LTQ_SPI_IRNEN_R;
++			irq_flags |= hw->irnen_r;
+ 	} else if (hw->rx) {
+ 		/* Start RX clock */
+ 		ltq_spi_rxreq_set(hw);
+ 
+ 		/* Enable RX interrupt to receive data from RX FIFOs */
+-		irq_flags |= LTQ_SPI_IRNEN_R;
++		irq_flags |= hw->irnen_r;
+ 	}
+ 
+ 	/* Enable TX or RX interrupts */
+ 	ltq_spi_reg_setbit(hw, irq_flags, LTQ_SPI_IRNEN);
+-	wait_for_completion_interruptible(&hw->done);
++	if (hw->tx)
++		wait_for_completion_interruptible(&hw->tx_done);
++	if (hw->rx) {
++		u32 fstat;
++		u16 fifo_fill;
++
++		/* Completion can't be used with RX, because RX interrupt may
++		 * never occur. RX interrupt occurs only when RX FIFO fill
++		 * reaches specified level (half of FIFO size, in this driver).
++		 * Additional uncertainty is introduced by the fact that rx_cnt
++		 * and rxfs are counting bytes, but FIFO stores words (possibly
++		 * of different size).
++		 * Solution is just to poll for RX data.
++		 */
++		while (hw->rx_cnt < hw->len && !hw->status) {
++			/* Determine how much FIFOs are filled with RX data */
++			fstat = ltq_spi_reg_read(hw, LTQ_SPI_FSTAT);
++			fifo_fill = ((fstat >> LTQ_SPI_FSTAT_RXFFL_SHIFT)
++					& LTQ_SPI_FSTAT_RXFFL_MASK);
++
++			if (fifo_fill)
++				ltq_spi_rx_irq(hw->irq[0], hw);
++			else
++				cond_resched();
++		}
++	}
+ 
+ 	/* Disable all interrupts */
+ 	ltq_spi_reg_clearbit(hw, LTQ_SPI_IRNEN_ALL, LTQ_SPI_IRNEN);
+ 
+-	/*
+-	 * Return length of current transfer for bitbang utility code if
+-	 * no errors occured during transmission.
+-	 */
+-	if (!hw->status)
+-		hw->status = hw->len;
++	if (!hw->status) {
++		/*
++		 * A signaled TX completion doesn't guarantee that the data has been sent
++		 * on the SPI bus, it just garantees that it has been written to TX FIFO.
++		 * Verification of completion of transfer is done by polling of BSY bit of
++		 * SSC_STATE register.
++		 */
++		if (!hw->rx)
++			hw->status = ltq_spi_wait_ready(hw);
++		/*
++		 * Return length of current transfer for bitbang utility code if
++		 * no errors occurred during transmission.
++		 */
++		if (!hw->status)
++			hw->status = hw->len;
++	}
+ 
+ 	return hw->status;
+ }
+@@ -850,17 +1048,25 @@ static int ltq_spi_probe(struct platform
+ 	hw->bitbang.setup_transfer = ltq_spi_setup_transfer;
+ 	hw->bitbang.txrx_bufs = ltq_spi_txrx_bufs;
+ 
+-	if (of_machine_is_compatible("lantiq,ase"))
++	if (of_machine_is_compatible("lantiq,ase")) {
+ 		master->num_chipselect = 3;
+-	else
++
++		hw->irnen_t = LTQ_SPI_IRNEN_T_XWAY;
++		hw->irnen_r = LTQ_SPI_IRNEN_R_XWAY;
++	} else {
+ 		master->num_chipselect = 6;
++
++		hw->irnen_t = LTQ_SPI_IRNEN_T;
++		hw->irnen_r = LTQ_SPI_IRNEN_R;
++	}
++
+ 	master->bus_num = pdev->id;
+ 	master->setup = ltq_spi_setup;
+ 	master->cleanup = ltq_spi_cleanup;
+ 	master->dev.of_node = pdev->dev.of_node;
+ 
+ 	hw->dev = &pdev->dev;
+-	init_completion(&hw->done);
++	init_completion(&hw->tx_done);
+ 	spin_lock_init(&hw->lock);
+ 
+ 	ltq_spi_hw_enable(hw);
+@@ -875,13 +1081,13 @@ static int ltq_spi_probe(struct platform
+ 
+ 	/* Enable error checking, disable TX/RX, set idle value high */
+ 	data = LTQ_SPI_CON_RUEN | LTQ_SPI_CON_AEN |
+-	    LTQ_SPI_CON_TEN | LTQ_SPI_CON_REN |
+-	    LTQ_SPI_CON_TXOFF | LTQ_SPI_CON_RXOFF | LTQ_SPI_CON_IDLE;
++		LTQ_SPI_CON_TEN | LTQ_SPI_CON_REN |
++		LTQ_SPI_CON_TXOFF | LTQ_SPI_CON_RXOFF | LTQ_SPI_CON_IDLE;
+ 	ltq_spi_reg_write(hw, data, LTQ_SPI_CON);
+ 
+ 	/* Enable master mode and clear error flags */
+ 	ltq_spi_reg_write(hw, LTQ_SPI_WHBSTATE_SETMS |
+-			  LTQ_SPI_WHBSTATE_CLR_ERRORS, LTQ_SPI_WHBSTATE);
++		LTQ_SPI_WHBSTATE_CLR_ERRORS, LTQ_SPI_WHBSTATE);
+ 
+ 	/* Reset GPIO/CS registers */
+ 	ltq_spi_reg_write(hw, 0x0, LTQ_SPI_GPOCON);
+@@ -898,7 +1104,11 @@ static int ltq_spi_probe(struct platform
+ 
+ 	platform_set_drvdata(pdev, hw);
+ 
+-	pr_info("Lantiq SoC SPI controller rev %u (TXFS %u, RXFS %u, DMA %u)\n",
++#ifdef CONFIG_SPI_XWAY_BV
++	pr_info("Lantiq SoC SPI controller rev %u (TXFS %u, RXFS %u, DMA %u, byte valid mode on)\n",
++#else
++	pr_info("Lantiq SoC SPI controller rev %u (TXFS %u, RXFS %u, DMA %u, byte valid mode off)\n",
++#endif
+ 		id & LTQ_SPI_ID_REV_MASK, hw->txfs, hw->rxfs, hw->dma_support);
+ 
+ 	return 0;
+@@ -953,6 +1163,7 @@ static int ltq_spi_remove(struct platfor
+ 
+ static const struct of_device_id ltq_spi_match[] = {
+ 	{ .compatible = "lantiq,spi-xway" },
++	{ .compatible = "lantiq,spi-lantiq-ssc" },
+ 	{},
+ };
+ MODULE_DEVICE_TABLE(of, ltq_spi_match);
+@@ -961,7 +1172,7 @@ static struct platform_driver ltq_spi_dr
+ 	.probe = ltq_spi_probe,
+ 	.remove = ltq_spi_remove,
+ 	.driver = {
+-		.name = "spi-xway",
++		.name = "spi-lantiq-ssc",
+ 		.owner = THIS_MODULE,
+ 		.of_match_table = ltq_spi_match,
+ 	},
+@@ -973,3 +1184,4 @@ MODULE_DESCRIPTION("Lantiq SoC SPI contr
+ MODULE_AUTHOR("Daniel Schwierzeck <daniel.schwierzeck@googlemail.com>");
+ MODULE_LICENSE("GPL");
+ MODULE_ALIAS("platform:spi-xway");
++MODULE_ALIAS("platform:spi-lantiq-ssc");
diff --git a/target/linux/lantiq/patches-3.18/2061-falcon-add-spi-clock.patch b/target/linux/lantiq/patches-3.18/2061-falcon-add-spi-clock.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2061-falcon-add-spi-clock.patch
@@ -0,0 +1,21 @@
+Falcon: register clock for SPI
+
+diff --git a/arch/mips/lantiq/falcon/sysctrl.c b/arch/mips/lantiq/falcon/sysctrl.c
+--- a/arch/mips/lantiq/falcon/sysctrl.c
++++ b/arch/mips/lantiq/falcon/sysctrl.c
+@@ -61,6 +61,7 @@
+ #define ACTS_PADCTRL2	0x00200000
+ #define ACTS_PADCTRL3	0x00200000
+ #define ACTS_PADCTRL4	0x00400000
++#define ACTS_SSC0	0x00002000
+ 
+ #define sysctl_w32(m,val,reg)	ltq_w32((val), sysctl_membase[m] + (reg))
+ #define sysctl_r32(m,reg)	ltq_r32(sysctl_membase[m] + (reg))
+@@ -245,6 +246,7 @@ void __init ltq_soc_init(void)
+ 	clkdev_add_sys("1e100b00.serial", SYSCTL_SYS1, ACTS_ASC1_ACT);
+ 	clkdev_add_sys("1e100c00.serial", SYSCTL_SYS1, ACTS_ASC0_ACT);
+ 	clkdev_add_sys("1e200000.i2c", SYSCTL_SYS1, ACTS_I2C_ACT);
++	clkdev_add_sys("1e100d00.spi", SYSCTL_SYS1, ACTS_SSC0);
+ }
+ 
+ 
diff --git a/target/linux/lantiq/patches-3.18/2070-falcon-ext-sysctrl.patch b/target/linux/lantiq/patches-3.18/2070-falcon-ext-sysctrl.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2070-falcon-ext-sysctrl.patch
@@ -0,0 +1,924 @@
+extended sysctrl for SDK usage
+- provide locked access to shared registers
+- define some register bits and mask
+
+diff --git a/arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h b/arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h
+--- a/arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h
++++ b/arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h
+@@ -22,39 +22,475 @@
+ 
+ #include <falcon/lantiq_soc.h>
+ 
+-static inline void sys1_hw_activate(u32 mask)
++#ifndef SYSCTRL_USE_EXTENDED
++# define SYSCTRL_USE_EXTENDED
++#endif
++
++/** Mask definition for SYS1.STATUS block */
++#define SYSCTRL_SYS1_STATUS			0x80000000
++/** Mask definition for SYS1.SHA1 block */
++#define SYSCTRL_SYS1_SHA1			0x40000000
++/** Mask definition for SYS1.AES block */
++#define SYSCTRL_SYS1_AES 			0x20000000
++/** Mask definition for SYS1.PCM block */
++#define SYSCTRL_SYS1_PCM 			0x10000000
++/** Mask definition for SYS1.FSCT block */
++#define SYSCTRL_SYS1_FSCT 			0x08000000
++/** Mask definition for SYS1.GPTC block */
++#define SYSCTRL_SYS1_GPTC 			0x04000000
++/** Mask definition for SYS1.MPS block */
++#define SYSCTRL_SYS1_MPS 			0x02000000
++/** Mask definition for SYS1.DFEV0 block */
++#define SYSCTRL_SYS1_DFEV0 			0x01000000
++/** Mask definition for SYS1.PADCTRL4 block */
++#define SYSCTRL_SYS1_PADCTRL4 			0x00400000
++/** Mask definition for SYS1.PADCTRL3 block */
++#define SYSCTRL_SYS1_PADCTRL3 			0x00200000
++/** Mask definition for SYS1.PADCTRL1 block */
++#define SYSCTRL_SYS1_PADCTRL1 			0x00100000
++/** Mask definition for SYS1.P4 block */
++#define SYSCTRL_SYS1_P4 			0x00040000
++/** Mask definition for SYS1.P3 block */
++#define SYSCTRL_SYS1_P3 			0x00020000
++/** Mask definition for SYS1.P1 block */
++#define SYSCTRL_SYS1_P1 			0x00010000
++/** Mask definition for SYS1.HOST block */
++#define SYSCTRL_SYS1_HOST 			0x00008000
++/** Mask definition for SYS1.I2C block */
++#define SYSCTRL_SYS1_I2C 			0x00004000
++/** Mask definition for SYS1.SSC0 block */
++#define SYSCTRL_SYS1_SSC0 			0x00002000
++/** Mask definition for SYS1.ASC0 block */
++#define SYSCTRL_SYS1_ASC0 			0x00001000
++/** Mask definition for SYS1.ASC1 block */
++#define SYSCTRL_SYS1_ASC1 			0x00000800
++/** Mask definition for SYS1.DCDCAPD block */
++#define SYSCTRL_SYS1_DCDCAPD 			0x00000400
++/** Mask definition for SYS1.DCDCDDR block */
++#define SYSCTRL_SYS1_DCDCDDR 			0x00000200
++/** Mask definition for SYS1.DCDC1V0 block */
++#define SYSCTRL_SYS1_DCDC1V0 			0x00000100
++/** Mask definition for SYS1.TRC2MEM block */
++#define SYSCTRL_SYS1_TRC2MEM 			0x00000040
++/** Mask definition for SYS1.DDR block */
++#define SYSCTRL_SYS1_DDR 			0x00000020
++/** Mask definition for SYS1.EBU block */
++#define SYSCTRL_SYS1_EBU 			0x00000010
++
++/** Mask definition for SYS_ETH.GPHY1MII2 block */
++#define SYSCTRL_SYS_ETH_GPHY1MII2 		0x02000000
++/** Mask definition for SYS_ETH.GPHY0MII2 block */
++#define SYSCTRL_SYS_ETH_GPHY0MII2 		0x01000000
++/** Mask definition for SYS_ETH.PADCTRL2 block */
++#define SYSCTRL_SYS_ETH_PADCTRL2 		0x00200000
++/** Mask definition for SYS_ETH.PADCTRL0 block */
++#define SYSCTRL_SYS_ETH_PADCTRL0 		0x00100000
++/** Mask definition for SYS_ETH.P2 block */
++#define SYSCTRL_SYS_ETH_P2 			0x00020000
++/** Mask definition for SYS_ETH.P0 block */
++#define SYSCTRL_SYS_ETH_P0 			0x00010000
++/** Mask definition for SYS_ETH.xMII block */
++#define SYSCTRL_SYS_ETH_XMII 			0x00000800
++/** Mask definition for SYS_ETH.SGMII block */
++#define SYSCTRL_SYS_ETH_SGMII 			0x00000400
++/** Mask definition for SYS_ETH.GPHY1 block */
++#define SYSCTRL_SYS_ETH_GPHY1 			0x00000200
++/** Mask definition for SYS_ETH.GPHY0 block */
++#define SYSCTRL_SYS_ETH_GPHY0 			0x00000100
++/** Mask definition for SYS_ETH.MDIO block */
++#define SYSCTRL_SYS_ETH_MDIO 			0x00000080
++/** Mask definition for SYS_ETH.GMAC3 block */
++#define SYSCTRL_SYS_ETH_GMAC3 			0x00000008
++/** Mask definition for SYS_ETH.GMAC2 block */
++#define SYSCTRL_SYS_ETH_GMAC2 			0x00000004
++/** Mask definition for SYS_ETH.GMAC1 block */
++#define SYSCTRL_SYS_ETH_GMAC1 			0x00000002
++/** Mask definition for SYS_ETH.GMAC0 block */
++#define SYSCTRL_SYS_ETH_GMAC0 			0x00000001
++
++/** Mask definition for SYS_GPE.COP7 block */
++#define SYSCTRL_SYS_GPE_COP7 			0x80000000
++/** Mask definition for SYS_GPE.COP6 block */
++#define SYSCTRL_SYS_GPE_COP6 			0x40000000
++/** Mask definition for SYS_GPE.COP5 block */
++#define SYSCTRL_SYS_GPE_COP5 			0x20000000
++/** Mask definition for SYS_GPE.COP4 block */
++#define SYSCTRL_SYS_GPE_COP4 			0x10000000
++/** Mask definition for SYS_GPE.COP3 block */
++#define SYSCTRL_SYS_GPE_COP3 			0x08000000
++/** Mask definition for SYS_GPE.COP2 block */
++#define SYSCTRL_SYS_GPE_COP2 			0x04000000
++/** Mask definition for SYS_GPE.COP1 block */
++#define SYSCTRL_SYS_GPE_COP1 			0x02000000
++/** Mask definition for SYS_GPE.COP0 block */
++#define SYSCTRL_SYS_GPE_COP0 			0x01000000
++/** Mask definition for SYS_GPE.PE5 block */
++#define SYSCTRL_SYS_GPE_PE5 			0x00200000
++/** Mask definition for SYS_GPE.PE4 block */
++#define SYSCTRL_SYS_GPE_PE4 			0x00100000
++/** Mask definition for SYS_GPE.PE3 block */
++#define SYSCTRL_SYS_GPE_PE3 			0x00080000
++/** Mask definition for SYS_GPE.PE2 block */
++#define SYSCTRL_SYS_GPE_PE2 			0x00040000
++/** Mask definition for SYS_GPE.PE1 block */
++#define SYSCTRL_SYS_GPE_PE1 			0x00020000
++/** Mask definition for SYS_GPE.PE0 block */
++#define SYSCTRL_SYS_GPE_PE0 			0x00010000
++/** Mask definition for SYS_GPE.ARB block */
++#define SYSCTRL_SYS_GPE_ARB 			0x00002000
++/** Mask definition for SYS_GPE.FSQM block */
++#define SYSCTRL_SYS_GPE_FSQM 			0x00001000
++/** Mask definition for SYS_GPE.TMU block */
++#define SYSCTRL_SYS_GPE_TMU 			0x00000800
++/** Mask definition for SYS_GPE.MRG block */
++#define SYSCTRL_SYS_GPE_MRG 			0x00000400
++/** Mask definition for SYS_GPE.DISP block */
++#define SYSCTRL_SYS_GPE_DISP 			0x00000200
++/** Mask definition for SYS_GPE.IQM block */
++#define SYSCTRL_SYS_GPE_IQM 			0x00000100
++/** Mask definition for SYS_GPE.CPUE block */
++#define SYSCTRL_SYS_GPE_CPUE 			0x00000080
++/** Mask definition for SYS_GPE.CPUI block */
++#define SYSCTRL_SYS_GPE_CPUI 			0x00000040
++/** Mask definition for SYS_GPE.GPONE block */
++#define SYSCTRL_SYS_GPE_GPONE 			0x00000020
++/** Mask definition for SYS_GPE.GPONI block */
++#define SYSCTRL_SYS_GPE_GPONI 			0x00000010
++/** Mask definition for SYS_GPE.LAN3 block */
++#define SYSCTRL_SYS_GPE_LAN3 			0x00000008
++/** Mask definition for SYS_GPE.LAN2 block */
++#define SYSCTRL_SYS_GPE_LAN2 			0x00000004
++/** Mask definition for SYS_GPE.LAN1 block */
++#define SYSCTRL_SYS_GPE_LAN1 			0x00000002
++/** Mask definition for SYS_GPE.LAN0 block */
++#define SYSCTRL_SYS_GPE_LAN0 			0x00000001
++
++/** Chip Version Number Mask */
++#define SYSCTRL_CHIPID_VERSION_MASK 		0xF0000000
++/** Chip Version Number Offset */
++#define SYSCTRL_CHIPID_VERSION_OFFSET 		28
++/** Part Number, Constant Part Mask */
++#define SYSCTRL_CHIPID_PARTNR_MASK 		0x0FFFF000
++/** Part Number, Constant Part Offset */
++#define SYSCTRL_CHIPID_PARTNR_OFFSET 		12
++/** Manufacturer ID Mask */
++#define SYSCTRL_CHIPID_MANID_MASK 		0x00000FFE
++/** Manufacturer ID Offset */
++#define SYSCTRL_CHIPID_MANID_OFFSET 		1
++/** Constant bit Mask */
++#define SYSCTRL_CHIPID_CONST1_MASK 		0x00000001
++/** Constant bit Offset */
++#define SYSCTRL_CHIPID_CONST1_OFFSET 		0
++
++/** PHY_CLKO pin frequency, 25 MHz */
++#define SYSCTRL_EXTPHYC_CLKSEL_F25 		0x00000001
++/** PHY_CLKO pin frequency, 125 MHz */
++#define SYSCTRL_EXTPHYC_CLKSEL_F125 		0x00000002
++/** PHY_CLKO pin frequency, 50 MHz */
++#define SYSCTRL_EXTPHYC_CLKSEL_F50 		0x00000005
++
++/** GMAC connects to GPHY0_GMII interface */
++#define SYSCTRL_MUX_GPHY0_GMII 			0x00000000
++/** GMAC connects to GPHY0_MII2 interface */
++#define SYSCTRL_MUX_GPHY0_MII2 			0x00000001
++/** GMAC connects to GPHY1_GMII interface */
++#define SYSCTRL_MUX_GPHY1_GMII 			0x00000002
++/** GMAC connects to GPHY1_MII2 interface */
++#define SYSCTRL_MUX_GPHY1_MII2 			0x00000003
++/** GMAC connects to SGMII interface */
++#define SYSCTRL_MUX_SGMII 			0x00000004
++/** GMAC connects to xMII0 interface */
++#define SYSCTRL_MUX_XMII0 			0x00000005
++/** GMAC connects to xMII1 interface */
++#define SYSCTRL_MUX_xMII1 			0x00000006
++
++/** FUSE0 SFC field Mask */
++#define SYSCTRL_FUSE0_SFC_MASK 			0x80000000
++/** FUSE0 SFC field Offset */
++#define SYSCTRL_FUSE0_SFC_OFFSET 		31
++/** FUSE0 SFC field Select */
++#define SYSCTRL_FUSE0_SFC_SEL 			0x80000000
++/** FUSE0 SC_MBCFG field Mask */
++#define SYSCTRL_FUSE0_SC_MBCFG_MASK		0x40000000
++/** FUSE0 SC_MBCFG field Offset */
++#define SYSCTRL_FUSE0_SC_MBCFG_OFFSET		30
++/** FUSE0 SC_MBCFG field Select */
++#define SYSCTRL_FUSE0_SC_MBCFG_SEL 		0x40000000
++/** FUSE0 Device Type field Mask */
++#define SYSCTRL_FUSE0_F0_MASK 			0x3C000000
++/** FUSE0 Device Type field Offset */
++#define SYSCTRL_FUSE0_F0_OFFSET 		26
++/** FUSE0 Device Type field value: FALCOND */
++#define SYSCTRL_FUSE0_F0_FALCOND 		0x00000000
++/** FUSE0 Device Type field value: FALCONV */
++#define SYSCTRL_FUSE0_F0_FALCONV 		0x04000000
++/** FUSE0 Device Type field value: FALCONM */
++#define SYSCTRL_FUSE0_F0_FALCONM 		0x08000000
++/** FUSE0 Device Type field value: SFP */
++#define SYSCTRL_FUSE0_F0_FALCONS 		0x0C000000
++/** FUSE0 Device Type field value: D2 */
++#define SYSCTRL_FUSE0_F0_FALCOND2 		0x10000000
++/** FUSE0 Device Type field value: SR */
++#define SYSCTRL_FUSE0_F0_FALCONSR 		0x14000000
++/** FUSE0 VCALMM20 Voltage Reference Mask */
++#define SYSCTRL_FUSE0_VCALMM20_MASK 		0x03F00000
++/** FUSE0 VCALMM20 Voltage Reference Offset */
++#define SYSCTRL_FUSE0_VCALMM20_OFFSET 		20
++/** FUSE0 VCALMM100 Voltage Reference Mask */
++#define SYSCTRL_FUSE0_VCALMM100_MASK 		0x000FC000
++/** FUSE0 VCALMM100 Voltage Reference Offset */
++#define SYSCTRL_FUSE0_VCALMM100_OFFSET 		14
++/** FUSE0 VCALMM400 Voltage Reference Mask */
++#define SYSCTRL_FUSE0_VCALMM400_MASK 		0x00003F00
++/** FUSE0 VCALMM400 Voltage Reference Offset */
++#define SYSCTRL_FUSE0_VCALMM400_OFFSET 		8
++/** FUSE0 RCALMM R error correction Mask */
++#define SYSCTRL_FUSE0_RCALMM_MASK 		0x000000FF
++/** FUSE0 RCALMM R error correction Offset */
++#define SYSCTRL_FUSE0_RCALMM_OFFSET 		0
++
++/** FUSE1 Spare fuse1 Mask */
++#define SYSCTRL_FUSE1_F1_MASK 			0xFFF00000
++/** FUSE1 Spare fuse1 Offset */
++#define SYSCTRL_FUSE1_F1_OFFSET 		20
++/** FUSE1 FREE_1 Mask */
++#define SYSCTRL_FUSE1_FR1_MASK 			0x000F0000
++/** FUSE1 FREE_1 Offset */
++#define SYSCTRL_FUSE1_FR1_OFFSET 		16
++/** FUSE1 DCDC 1V0 OFFSET Mask */
++#define SYSCTRL_FUSE1_OFFSET1V0DCDC_MASK   	0x0000F800
++/** FUSE1 DCDC 1V0 OFFSET Offset */
++#define SYSCTRL_FUSE1_OFFSET1V0DCDC_OFFSET	11
++/** FUSE1 DCDC APD OFFSET Mask */
++#define SYSCTRL_FUSE1_OFFSETAPDDCDC_MASK 	0x000007C0
++/** FUSE1 DCDC APD OFFSET Offset */
++#define SYSCTRL_FUSE1_OFFSETAPDDCDC_OFFSET 	6
++/** FUSE1 DCDC APD GAIN Mask */
++#define SYSCTRL_FUSE1_GAINAPDDCDC_MASK 		0x0000003F
++/** FUSE1 DCDC APD GAIN Offset */
++#define SYSCTRL_FUSE1_GAINAPDDCDC_OFFSET 	0
++
++/** ANALOG Status of written FUSES Mask */
++#define SYSCTRL_ANALOG_FS_MASK 			0xE0000000
++/** ANALOG Status of written FUSES Offset */
++#define SYSCTRL_ANALOG_FS_OFFSET 		29
++/** ANALOG fuse A11 format */
++#define SYSCTRL_ANALOG_FS_FS0 			0x00000000
++/** ANALOG fuse new format */
++#define SYSCTRL_ANALOG_FS_FS1 			0x20000000
++/** ANALOG fuse reserved format  */
++#define SYSCTRL_ANALOG_FS_FS2 			0x40000000
++/** Reserved Analog eFuses Mask */
++#define SYSCTRL_ANALOG_A0_MASK 			0x1C000000
++/** Reserved Analog eFuses Offset */
++#define SYSCTRL_ANALOG_A0_OFFSET 		26
++/** ANALOG fuse Absolut Temperature Mask */
++#define SYSCTRL_ANALOG_TEMPMM_MASK 		0x03F00000
++/** ANALOG fuse Absolut Temperature Offset */
++#define SYSCTRL_ANALOG_TEMPMM_OFFSET 		20
++/** ANALOG fuse Drive DAC Gain Mask */
++#define SYSCTRL_ANALOG_GAINDRIVEDAC_MASK 	0x000F8000
++/** ANALOG fuse Drive DAC Gain Offset */
++#define SYSCTRL_ANALOG_GAINDRIVEDAC_OFFSET 	15
++/** ANALOG fuse Bias Voltage Generation Mask */
++#define SYSCTRL_ANALOG_VBGP_MASK 		0x00007000
++/** ANALOG fuse Bias Voltage Generation Offset */
++#define SYSCTRL_ANALOG_VBGP_OFFSET 		12
++/** ANALOG fuse Bias Current Generation Mask */
++#define SYSCTRL_ANALOG_IREFBGP_MASK 		0x00000F00
++/** ANALOG fuse Bias Current Generation Offset */
++#define SYSCTRL_ANALOG_IREFBGP_OFFSET 		8
++/** ANALOG fuse Bias Voltage Generation Mask */
++#define SYSCTRL_ANALOG_TBGP_MASK 		0x000000E0
++/** ANALOG fuse Bias Voltage Generation Offset */
++#define SYSCTRL_ANALOG_TBGP_OFFSET 		5
++/** ANALOG fuse BIAS DAC Gain Mask */
++#define SYSCTRL_ANALOG_GAINBIASDAC_MASK 	0x0000001F
++/** ANALOG fuse BIAS DAC Gain Offset */
++#define SYSCTRL_ANALOG_GAINBIASDAC_OFFSET 	0
++
++/** CONFIG fuse ddr PU driver Mask */
++#define SYSCTRL_CONFIG_DDRPU_MASK 		0xC0000000
++/** CONFIG fuse ddr PU driver Offset */
++#define SYSCTRL_CONFIG_DDRPU_OFFSET 		30
++/** CONFIG fuse ddr PD driver Mask */
++#define SYSCTRL_CONFIG_DDRPD_MASK 		0x30000000
++/** CONFIG fuse ddr PD driver Mask */
++#define SYSCTRL_CONFIG_DDRPD_OFFSET 		28
++/** CONFIG fuse Authentification Unit enable Mask */
++#define SYSCTRL_CONFIG_SHA1EN_MASK 		0x08000000
++/** CONFIG fuse Authentification Unit enable Offset */
++#define SYSCTRL_CONFIG_SHA1EN_OFFSET 		27
++/** CONFIG fuse Encryption Unit enable Mask */
++#define SYSCTRL_CONFIG_AESEN_MASK 		0x04000000
++/** CONFIG fuse Encryption Unit enable Offset */
++#define SYSCTRL_CONFIG_AESEN_OFFSET 		26
++/** CONFIG fuse Subversion Number Mask */
++#define SYSCTRL_CONFIG_SUBVERS_MASK 		0x03C00000
++/** CONFIG fuse Subversion Number Offset  */
++#define SYSCTRL_CONFIG_SUBVERS_OFFSET 		22
++/** CONFIG fuse Subversion Number: AV1 */
++#define SYSCTRL_CONFIG_SUBVERS_AV1 		0x00000000
++/** CONFIG fuse Subversion Number: AV2 */
++#define SYSCTRL_CONFIG_SUBVERS_AV2 		0x00400000
++/** CONFIG fuse Subversion Number: AV3 */
++#define SYSCTRL_CONFIG_SUBVERS_AV3 		0x00800000
++/** CONFIG fuse Subversion Number: AV4 */
++#define SYSCTRL_CONFIG_SUBVERS_AV4 		0x00C00000
++/** CONFIG fuse Subversion Number: BV1 */
++#define SYSCTRL_CONFIG_SUBVERS_BV1 		0x01000000
++/** CONFIG fuse PLL settings Mask */
++#define SYSCTRL_CONFIG_PLLINFRA_MASK 		0x003FF000
++/** CONFIG fuse PLL settings Offset */
++#define SYSCTRL_CONFIG_PLLINFRA_OFFSET 		12
++/** CONFIG fuse GPE frequency selection Mask */
++#define SYSCTRL_CONFIG_GPEFREQ_MASK 		0x00000C00
++/** CONFIG fuse GPE frequency selection Offset */
++#define SYSCTRL_CONFIG_GPEFREQ_OFFSET		10
++/** CONFIG fuse RM enable Mask */
++#define SYSCTRL_CONFIG_RME_MASK 		0x00000200
++/** CONFIG fuse RM enable Offset */
++#define SYSCTRL_CONFIG_RME_OFFSET 		9
++/** CONFIG fuse RM settings Mask */
++#define SYSCTRL_CONFIG_RM_MASK 			0x000001E0
++/** CONFIG fuse RM settings Offset */
++#define SYSCTRL_CONFIG_RM_OFFSET 		5
++/** CONFIG fuse RM enable for GPE Memories Mask */
++#define SYSCTRL_CONFIG_RMEGPE_MASK 		0x00000010
++/** CONFIG fuse RM enable for GPE Memories Offset */
++#define SYSCTRL_CONFIG_RMEGPE_OFFSET 		4
++/** CONFIG fuse RM settings for GPE Memories Mask */
++#define SYSCTRL_CONFIG_RMGPE_MASK 		0x0000000F
++/** CONFIG fuse RM settings for GPE Memories Offset */
++#define SYSCTRL_CONFIG_RMGPE_OFFSET 		0
++
++/** FUSE0 Fuse Selector */
++#define SYSCTRL_FUSE_0				0
++/** FUSE1 Fuse Selector */
++#define SYSCTRL_FUSE_1				1
++/** ANALOG Fuse Selector */
++#define SYSCTRL_FUSE_ANALOG			2
++/** CONFIG Fuse Selector */
++#define SYSCTRL_FUSE_CONFIG			3
++
++/** xMII0 Interface Selector */
++#define SYSCTRL_INTERFACE_XMII0			0
++/** xMII1 Interface Selector */
++#define SYSCTRL_INTERFACE_XMII1			1
++/** SGMII Interface Selector */
++#define SYSCTRL_INTERFACE_SGMII			2
++
++/** Data Rate 10 MBit/s */
++#define SYSCTRL_DRC_10				0
++/** Data Rate 100 MBit/s */
++#define SYSCTRL_DRC_100				1
++/** Data Rate 200 MBit/s */
++#define SYSCTRL_DRC_200				5
++/** Data Rate 1000 MBit/s */
++#define SYSCTRL_DRC_1000			2
++/** Data Rate 2500 MBit/s */
++#define SYSCTRL_DRC_2500			4
++
++/** Linear 1.5 V Regulator set to 1.34V */
++#define SYSCTRL_LDO1V5_1V34		        0
++/** Linear 1.5 V Regulator set to 1.39V */
++#define SYSCTRL_LDO1V5_1V39		        1
++/** Linear 1.5 V Regulator set to 1.44V */
++#define SYSCTRL_LDO1V5_1V44		        2
++/** Linear 1.5 V Regulator set to 1.50V */
++#define SYSCTRL_LDO1V5_1V50		        3
++/** Linear 1.5 V Regulator set to 1.56V */
++#define SYSCTRL_LDO1V5_1V56		        4
++/** Linear 1.5 V Regulator set to 1.63V */
++#define SYSCTRL_LDO1V5_1V63		        5
++/** Linear 1.5 V Regulator set to 1.70V */
++#define SYSCTRL_LDO1V5_1V70		        6
++/** Linear 1.5 V Regulator set to 1.78V */
++#define SYSCTRL_LDO1V5_1V78		        7
++
++unsigned int ltq_sysctl_is_activated(const int module, const unsigned int mask);
++
++unsigned int ltq_sysctl_is_clocked(const int module, const unsigned int mask);
++
++static inline void ltq_sysctl_sys1_activate(unsigned int mask)
+ { ltq_sysctl_activate(SYSCTL_SYS1, mask); }
+-static inline void sys1_hw_deactivate(u32 mask)
++static inline void ltq_sysctl_sys1_deactivate(unsigned int mask)
+ { ltq_sysctl_deactivate(SYSCTL_SYS1, mask); }
+-static inline void sys1_hw_clk_enable(u32 mask)
++static inline void ltq_sysctl_sys1_clk_enable(unsigned int mask)
+ { ltq_sysctl_clken(SYSCTL_SYS1, mask); }
+-static inline void sys1_hw_clk_disable(u32 mask)
++static inline void ltq_sysctl_sys1_clk_disable(unsigned int mask)
+ { ltq_sysctl_clkdis(SYSCTL_SYS1, mask); }
+-static inline void sys1_hw_activate_or_reboot(u32 mask)
++static inline void ltq_sysctl_sys1_reboot(unsigned int mask)
+ { ltq_sysctl_reboot(SYSCTL_SYS1, mask); }
++static inline
++unsigned int ltq_sysctl_sys1_is_activated(const unsigned int mask)
++{ return ltq_sysctl_is_activated(SYSCTL_SYS1, mask); }
++static inline
++unsigned int ltq_sysctl_sys1_is_clocked(const unsigned int mask)
++{ return ltq_sysctl_is_clocked(SYSCTL_SYS1, mask); }
+ 
+-static inline void sys_eth_hw_activate(u32 mask)
++static inline void ltq_sysctl_sys_eth_activate(unsigned int mask)
+ { ltq_sysctl_activate(SYSCTL_SYSETH, mask); }
+-static inline void sys_eth_hw_deactivate(u32 mask)
++static inline void ltq_sysctl_sys_eth_deactivate(unsigned int mask)
+ { ltq_sysctl_deactivate(SYSCTL_SYSETH, mask); }
+-static inline void sys_eth_hw_clk_enable(u32 mask)
++static inline void ltq_sysctl_sys_eth_clk_enable(unsigned int mask)
+ { ltq_sysctl_clken(SYSCTL_SYSETH, mask); }
+-static inline void sys_eth_hw_clk_disable(u32 mask)
++static inline void ltq_sysctl_sys_eth_clk_disable(unsigned int mask)
+ { ltq_sysctl_clkdis(SYSCTL_SYSETH, mask); }
+-static inline void sys_eth_hw_activate_or_reboot(u32 mask)
++static inline void ltq_sysctl_sys_eth_reboot(unsigned int mask)
+ { ltq_sysctl_reboot(SYSCTL_SYSETH, mask); }
++static inline
++unsigned int ltq_sysctl_sys_eth_is_activated(const unsigned int mask)
++{ return ltq_sysctl_is_activated(SYSCTL_SYSETH, mask); }
++static inline
++unsigned int ltq_sysctl_sys_eth_is_clocked(const unsigned int mask)
++{ return ltq_sysctl_is_clocked(SYSCTL_SYSETH, mask); }
+ 
+-static inline void sys_gpe_hw_activate(u32 mask)
++static inline void ltq_sysctl_sys_gpe_activate(unsigned int mask)
+ { ltq_sysctl_activate(SYSCTL_SYSGPE, mask); }
+-static inline void sys_gpe_hw_deactivate(u32 mask)
++static inline void ltq_sysctl_sys_gpe_deactivate(unsigned int mask)
+ { ltq_sysctl_deactivate(SYSCTL_SYSGPE, mask); }
+-static inline void sys_gpe_hw_clk_enable(u32 mask)
++static inline void ltq_sysctl_sys_gpe_clk_enable(unsigned int mask)
+ { ltq_sysctl_clken(SYSCTL_SYSGPE, mask); }
+-static inline void sys_gpe_hw_clk_disable(u32 mask)
++static inline void ltq_sysctl_sys_gpe_clk_disable(unsigned int mask)
+ { ltq_sysctl_clkdis(SYSCTL_SYSGPE, mask); }
+-static inline void sys_gpe_hw_activate_or_reboot(u32 mask)
++static inline void ltq_sysctl_sys_gpe_reboot(unsigned int mask)
+ { ltq_sysctl_reboot(SYSCTL_SYSGPE, mask); }
+-static inline int sys_gpe_hw_is_activated(u32 mask)
+-{ return 1; }
++static inline
++unsigned int ltq_sysctl_sys_gpe_is_activated(const unsigned int mask)
++{ return ltq_sysctl_is_activated(SYSCTL_SYSGPE, mask); }
++static inline
++unsigned int ltq_sysctl_sys_gpe_is_clocked(const unsigned int mask)
++{ return ltq_sysctl_is_clocked(SYSCTL_SYSGPE, mask); }
++
++unsigned int ltq_sysctl_sys_gpe_hw_is_activated(unsigned int mask);
++
++void ltq_sysctl_dgasp_cfg_set(const unsigned int enable,
++			      const unsigned int hyst);
++
++void ltq_sysctl_dgasp_cfg_get(unsigned int *enable, unsigned int *hyst);
++
++void ltq_sysctl_clko_enable(const unsigned int enable);
++
++void ltq_sysctl_ldo1v5_cfg_set(const unsigned int enable,
++			       const unsigned int control);
++
++void ltq_sysctl_ldo1v5_cfg_get(unsigned int *enable,
++			       unsigned int *control);
++
++int ltq_sysctl_fuse_get(const unsigned int fuse, unsigned int *val);
++
++void ltq_sysctl_chipid_get(unsigned int *chipid);
++
++void ltq_sysctl_ephy_clko_set(const unsigned int enable,
++			      const unsigned int clk);
++
++int ltq_sysctl_drc_set(const unsigned int interface, const unsigned int drc);
++
++int ltq_sysctl_mac_mux_set(const unsigned int mac, const unsigned int mux);
++
++int ltq_sysctl_mac_mux_get(const unsigned int mac, unsigned int *mux);
++
++int ltq_sysctl_mac_drs_get(const unsigned int mac, unsigned int *drs);
+ 
+ #endif /* __FALCON_SYSCTRL_H */
+diff --git a/arch/mips/lantiq/falcon/sysctrl.c b/arch/mips/lantiq/falcon/sysctrl.c
+--- a/arch/mips/lantiq/falcon/sysctrl.c
++++ b/arch/mips/lantiq/falcon/sysctrl.c
+@@ -11,16 +11,43 @@
+ #include <linux/export.h>
+ #include <linux/clkdev.h>
+ #include <linux/of_address.h>
++#include <linux/spinlock.h>
++#include <falcon/sysctrl.h>
+ #include <asm/delay.h>
+ 
+ #include <lantiq_soc.h>
+ 
+ #include "../clk.h"
+ 
++
++/* CPU0 Clock Control Register */
++#define SYS1_CPU0CC		0x0040
++/* CLKO Pad Control Register */
++#define SYS1_CLKOC		0x00b8
+ /* infrastructure control register */
+ #define SYS1_INFRAC		0x00bc
++/* HRST_OUT_N Control Register */
++#define SYS1_HRSTOUTC		0x00c0
++
++/* Chip Identification Register */
++#define STATUS_CHIPID		0x000C
++/* SPARE fuse register 0 */
++#define STATUS_FUSE0		0x0038
++/* Fuses for Analog modules */
++#define STATUS_ANALOG		0x003C
+ /* Configuration fuses for drivers and pll */
+ #define STATUS_CONFIG		0x0040
++/* SPARE fuse register 1 */
++#define STATUS_FUSE1		0x0044
++
++/* External PHY Control Register */
++#define SYS_ETH_EXTPHYC		0x00B0
++/* Datarate Control Register */
++#define SYS_ETH_DRC		0x00B8
++/* GMAC Multiplexer Control Register */
++#define SYS_ETH_GMUXC		0x00BC
++/* Datarate Status Register */
++#define SYS_ETH_DRS		0x00C0
+ 
+ /* GPE frequency selection */
+ #define GPPC_OFFSET		24
+@@ -40,28 +67,39 @@
+ #define SYSCTL_DEACT		0x0028
+ /* reboot Register */
+ #define SYSCTL_RBT		0x002c
+-/* CPU0 Clock Control Register */
+-#define SYS1_CPU0CC		0x0040
+-/* HRST_OUT_N Control Register */
+-#define SYS1_HRSTOUTC		0x00c0
++
+ /* clock divider bit */
+ #define CPU0CC_CPUDIV		0x0001
+ 
+-/* Activation Status Register */
+-#define ACTS_ASC0_ACT	0x00001000
+-#define ACTS_ASC1_ACT	0x00000800
+-#define ACTS_I2C_ACT	0x00004000
+-#define ACTS_P0		0x00010000
+-#define ACTS_P1		0x00010000
+-#define ACTS_P2		0x00020000
+-#define ACTS_P3		0x00020000
+-#define ACTS_P4		0x00040000
+-#define ACTS_PADCTRL0	0x00100000
+-#define ACTS_PADCTRL1	0x00100000
+-#define ACTS_PADCTRL2	0x00200000
+-#define ACTS_PADCTRL3	0x00200000
+-#define ACTS_PADCTRL4	0x00400000
+-#define ACTS_SSC0	0x00002000
++/* CLKO Pad Control Register */
++#define CLKOC_OEN 		0x00000001
++
++/* Infrastructure Control Register */
++#define INFRAC_DGASPEN 		0x00000040
++#define INFRAC_DGASPHYS_MASK 	0x00000030
++#define INFRAC_DGASPHYS_OFFSET 	4
++#define INFRAC_LIN1V5C_MASK 	0x00000007
++#define INFRAC_LIN1V5EN 	0x00000008
++
++/* External PHY Control Register */
++#define EXTPHYC_CLKEN 		0x80000000
++
++/* Data Rate Control Register */
++#define DRC_xMII0_MASK 	 	0x00700000
++#define DRC_xMII0_OFFSET 	20
++#define DRC_xMII1_MASK		0x07000000
++#define DRC_xMII1_OFFSET 	24
++#define DRC_SGMII_MASK 		0x00070000
++#define DRC_SGMII_OFFSET	16
++
++/* GMAC Multiplexer Control Register */
++#define GMUXC_GMAC0_MASK 	0x00000007
++
++/* GMAC Data Rate Status register */
++#define DRS_GMAC1_OFFSET 	4
++
++#define GMAC_MASK(mac)		(GMUXC_GMAC0_MASK << (4 * (mac)))
++#define GMAC_OFFSET(mac)	(DRS_GMAC1_OFFSET * (mac))
+ 
+ #define sysctl_w32(m,val,reg)	ltq_w32((val), sysctl_membase[m] + (reg))
+ #define sysctl_r32(m,reg)	ltq_r32(sysctl_membase[m] + (reg))
+@@ -83,6 +121,8 @@ static void __iomem *sysctl_membase[ARRA
+ void __iomem *ltq_sys1_membase, *ltq_ebu_membase;
+ 
+ 
++static DEFINE_SPINLOCK(sysctrl_lock);
++
+ void falcon_trigger_hrst(int level)
+ {
+ 	sysctl_w32(SYSCTL_SYS1, level & 1, SYS1_HRSTOUTC);
+@@ -146,7 +186,7 @@ static void sysctl_reboot(struct clk *cl
+ 	sysctl_wait(clk, clk->bits, SYSCTL_ACTS);
+ }
+ 
+-/* enable the ONU core */
++/* enable the ONU core (without locking, as only called once during init) */
+ static void falcon_gpe_enable(void)
+ {
+ 	unsigned int freq;
+@@ -233,20 +273,20 @@ void __init ltq_soc_init(void)
+ 		clkdev_add_static(CLOCK_400M, CLOCK_100M, CLOCK_200M, 0);
+ 
+ 	/* add our clock domains */
+-	clkdev_add_sys("1d810000.gpio", SYSCTL_SYSETH, ACTS_P0);
+-	clkdev_add_sys("1d810100.gpio", SYSCTL_SYSETH, ACTS_P2);
+-	clkdev_add_sys("1e800100.gpio", SYSCTL_SYS1, ACTS_P1);
+-	clkdev_add_sys("1e800200.gpio", SYSCTL_SYS1, ACTS_P3);
+-	clkdev_add_sys("1e800300.gpio", SYSCTL_SYS1, ACTS_P4);
+-	clkdev_add_sys("1db01000.pad", SYSCTL_SYSETH, ACTS_PADCTRL0);
+-	clkdev_add_sys("1db02000.pad", SYSCTL_SYSETH, ACTS_PADCTRL2);
+-	clkdev_add_sys("1e800400.pad", SYSCTL_SYS1, ACTS_PADCTRL1);
+-	clkdev_add_sys("1e800500.pad", SYSCTL_SYS1, ACTS_PADCTRL3);
+-	clkdev_add_sys("1e800600.pad", SYSCTL_SYS1, ACTS_PADCTRL4);
+-	clkdev_add_sys("1e100b00.serial", SYSCTL_SYS1, ACTS_ASC1_ACT);
+-	clkdev_add_sys("1e100c00.serial", SYSCTL_SYS1, ACTS_ASC0_ACT);
+-	clkdev_add_sys("1e200000.i2c", SYSCTL_SYS1, ACTS_I2C_ACT);
+-	clkdev_add_sys("1e100d00.spi", SYSCTL_SYS1, ACTS_SSC0);
++	clkdev_add_sys("1d810000.gpio", SYSCTL_SYSETH, SYSCTRL_SYS_ETH_P0);
++	clkdev_add_sys("1d810100.gpio", SYSCTL_SYSETH, SYSCTRL_SYS_ETH_P2);
++	clkdev_add_sys("1e800100.gpio", SYSCTL_SYS1, SYSCTRL_SYS1_P1);
++	clkdev_add_sys("1e800200.gpio", SYSCTL_SYS1, SYSCTRL_SYS1_P3);
++	clkdev_add_sys("1e800300.gpio", SYSCTL_SYS1, SYSCTRL_SYS1_P4);
++	clkdev_add_sys("1db01000.pad", SYSCTL_SYSETH, SYSCTRL_SYS_ETH_PADCTRL0);
++	clkdev_add_sys("1db02000.pad", SYSCTL_SYSETH, SYSCTRL_SYS_ETH_PADCTRL2);
++	clkdev_add_sys("1e800400.pad", SYSCTL_SYS1, SYSCTRL_SYS1_PADCTRL1);
++	clkdev_add_sys("1e800500.pad", SYSCTL_SYS1, SYSCTRL_SYS1_PADCTRL3);
++	clkdev_add_sys("1e800600.pad", SYSCTL_SYS1, SYSCTRL_SYS1_PADCTRL4);
++	clkdev_add_sys("1e100b00.serial", SYSCTL_SYS1, SYSCTRL_SYS1_ASC1);
++	clkdev_add_sys("1e100c00.serial", SYSCTL_SYS1, SYSCTRL_SYS1_ASC0);
++	clkdev_add_sys("1e200000.i2c", SYSCTL_SYS1, SYSCTRL_SYS1_I2C);
++	clkdev_add_sys("1e100d00.spi", SYSCTL_SYS1, SYSCTRL_SYS1_SSC0);
+ }
+ 
+ 
+@@ -255,6 +295,15 @@ void __init ltq_soc_init(void)
+  * see arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h
+  */
+ 
++unsigned int ltq_sysctl_sys_gpe_hw_is_activated(unsigned int mask)
++{
++	if (!ltq_sysctl_sys_gpe_is_clocked(mask))
++		return 0;
++
++	return ltq_sysctl_sys_gpe_is_activated(mask);
++}
++EXPORT_SYMBOL(ltq_sysctl_sys_gpe_hw_is_activated);
++
+ void ltq_sysctl_activate(int module, unsigned int mask)
+ {
+ 	struct clk clk = { .module = module, .bits = mask };
+@@ -269,6 +318,30 @@ void ltq_sysctl_deactivate(int module, u
+ }
+ EXPORT_SYMBOL(ltq_sysctl_deactivate);
+ 
++unsigned int ltq_sysctl_is_activated(const int module, const unsigned int mask)
++{
++	switch(module) {
++	case SYSCTL_SYS1:
++	case SYSCTL_SYSETH:
++	case SYSCTL_SYSGPE:
++		return (sysctl_r32(module, SYSCTL_ACTS) & mask) == mask ? 1 : 0;
++	}
++	return 0;
++}
++EXPORT_SYMBOL(ltq_sysctl_is_activated);
++
++unsigned int ltq_sysctl_is_clocked(const int module, const unsigned int mask)
++{
++	switch(module) {
++	case SYSCTL_SYS1:
++	case SYSCTL_SYSETH:
++	case SYSCTL_SYSGPE:
++		return (sysctl_r32(module, SYSCTL_CLKS) & mask) == mask ? 1 : 0;
++	}
++	return 0;
++}
++EXPORT_SYMBOL(ltq_sysctl_is_clocked);
++
+ void ltq_sysctl_clken(int module, unsigned int mask)
+ {
+ 	struct clk clk = { .module = module, .bits = mask };
+@@ -289,3 +362,217 @@ void ltq_sysctl_reboot(int module, unsig
+ 	sysctl_reboot(&clk);
+ }
+ EXPORT_SYMBOL(ltq_sysctl_reboot);
++
++void ltq_sysctl_dgasp_cfg_set(const unsigned int enable,
++			      const unsigned int hyst)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&sysctrl_lock, flags);
++
++	if (enable)
++		sysctl_w32_mask(SYSCTL_SYS1,
++				INFRAC_DGASPEN | INFRAC_DGASPHYS_MASK,
++				INFRAC_DGASPEN |
++					((hyst << INFRAC_DGASPHYS_OFFSET) &
++							INFRAC_DGASPHYS_MASK),
++				SYS1_INFRAC);
++	else
++		sysctl_w32_mask(SYSCTL_SYS1, INFRAC_DGASPEN, 0, SYS1_INFRAC);
++
++	spin_unlock_irqrestore(&sysctrl_lock, flags);
++}
++EXPORT_SYMBOL(ltq_sysctl_dgasp_cfg_set);
++
++void ltq_sysctl_dgasp_cfg_get(unsigned int *enable, unsigned int *hyst)
++{
++	unsigned int infrac;
++
++	infrac = sysctl_r32(SYSCTL_SYS1, SYS1_INFRAC);
++
++	if (enable)
++		*enable = infrac & INFRAC_DGASPEN ? 1 : 0;
++
++	if (hyst)
++		*hyst   = (infrac & INFRAC_DGASPHYS_MASK) >>
++							INFRAC_DGASPHYS_OFFSET;
++}
++EXPORT_SYMBOL(ltq_sysctl_dgasp_cfg_get);
++
++void ltq_sysctl_clko_enable(const unsigned int enable)
++{
++	sysctl_w32_mask(SYSCTL_SYS1,
++			CLKOC_OEN,
++			enable ? CLKOC_OEN : 0,
++			SYS1_CLKOC);
++}
++EXPORT_SYMBOL(ltq_sysctl_clko_enable);
++
++void ltq_sysctl_ldo1v5_cfg_set(const unsigned int enable,
++			       const unsigned int control)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&sysctrl_lock, flags);
++
++	if (enable)
++		sysctl_w32_mask(SYSCTL_SYS1,
++				INFRAC_LIN1V5C_MASK,
++				control & INFRAC_LIN1V5C_MASK,
++				SYS1_INFRAC);
++
++	sysctl_w32_mask(SYSCTL_SYS1,
++			INFRAC_LIN1V5EN,
++			enable ? INFRAC_LIN1V5EN : 0,
++			SYS1_INFRAC);
++
++	spin_unlock_irqrestore(&sysctrl_lock, flags);
++}
++EXPORT_SYMBOL(ltq_sysctl_ldo1v5_cfg_set);
++
++void ltq_sysctl_ldo1v5_cfg_get(unsigned int *enable,
++			       unsigned int *control)
++{
++	unsigned int infrac;
++
++	infrac = sysctl_r32(SYSCTL_SYS1, SYS1_INFRAC);
++
++	if (enable)
++		*enable  = infrac & INFRAC_LIN1V5EN ? 1 : 0;
++
++	if (control)
++		*control = infrac & INFRAC_LIN1V5C_MASK;
++}
++EXPORT_SYMBOL(ltq_sysctl_ldo1v5_cfg_get);
++
++int ltq_sysctl_fuse_get(const unsigned int fuse, unsigned int *val)
++{
++	switch (fuse) {
++	case SYSCTRL_FUSE_0:
++		*val = status_r32(STATUS_FUSE0);
++		break;
++	case SYSCTRL_FUSE_1:
++		*val = status_r32(STATUS_FUSE1);
++		break;
++	case SYSCTRL_FUSE_ANALOG:
++		*val = status_r32(STATUS_ANALOG);
++		break;
++	case SYSCTRL_FUSE_CONFIG:
++		*val = status_r32(STATUS_CONFIG);
++		break;
++	default:
++		return -1;
++	}
++	return 0;
++}
++EXPORT_SYMBOL(ltq_sysctl_fuse_get);
++
++void ltq_sysctl_chipid_get(unsigned int *chipid)
++{
++	if (chipid)
++		*chipid = status_r32(STATUS_CHIPID);
++}
++EXPORT_SYMBOL(ltq_sysctl_chipid_get);
++
++void ltq_sysctl_ephy_clko_set(const unsigned int enable, const unsigned int clk)
++{
++	unsigned int val = clk & 0x7;
++
++	if (enable)
++		val |= EXTPHYC_CLKEN;
++
++	sysctl_w32(SYSCTL_SYSETH, val, SYS_ETH_EXTPHYC);
++}
++EXPORT_SYMBOL(ltq_sysctl_ephy_clko_set);
++
++int ltq_sysctl_drc_set(const unsigned int interface, const unsigned int drc)
++{
++	unsigned int mask, reg;
++	unsigned long flags;
++
++	switch (drc) {
++	default:
++		return -1;
++	case SYSCTRL_DRC_2500:
++		if (interface != SYSCTRL_INTERFACE_SGMII)
++			return -1;
++		break;
++	case SYSCTRL_DRC_200:
++		if (interface == SYSCTRL_INTERFACE_SGMII)
++			return -1;
++		break;
++	case SYSCTRL_DRC_10:
++	case SYSCTRL_DRC_100:
++	case SYSCTRL_DRC_1000:
++		break;
++	}
++
++	switch (interface) {
++	case SYSCTRL_INTERFACE_XMII0:
++		mask = DRC_xMII0_MASK;
++		reg  = drc << DRC_xMII0_OFFSET;
++		break;
++	case SYSCTRL_INTERFACE_XMII1:
++		mask = DRC_xMII1_MASK;
++		reg  = drc << DRC_xMII1_OFFSET;
++		break;
++	case SYSCTRL_INTERFACE_SGMII:
++		mask = DRC_SGMII_MASK;
++		reg  = drc << DRC_SGMII_OFFSET;
++		break;
++	default:
++		return -1;
++	}
++
++	spin_lock_irqsave(&sysctrl_lock, flags);
++	sysctl_w32_mask(SYSCTL_SYSETH, mask, reg & mask, SYS_ETH_DRC);
++	spin_unlock_irqrestore(&sysctrl_lock, flags);
++
++	return 0;
++}
++EXPORT_SYMBOL(ltq_sysctl_drc_set);
++
++int ltq_sysctl_mac_mux_set(const unsigned int mac, const unsigned int mux)
++{
++	unsigned int mask;
++	unsigned long flags;
++
++	if (mac > 3)
++		return -1;
++
++	mask = GMAC_MASK(mac);
++
++	spin_lock_irqsave(&sysctrl_lock, flags);
++	sysctl_w32_mask(SYSCTL_SYSETH,
++			mask,
++			(mux << GMAC_OFFSET(mac)) & mask,
++			SYS_ETH_GMUXC);
++	spin_unlock_irqrestore(&sysctrl_lock, flags);
++
++	return 0;
++}
++EXPORT_SYMBOL(ltq_sysctl_mac_mux_set);
++
++int ltq_sysctl_mac_mux_get(const unsigned int mac, unsigned int *mux)
++{
++	if (mac > 3 || !mux)
++		return -1;
++
++	*mux = (sysctl_r32(SYSCTL_SYSETH, SYS_ETH_GMUXC) & GMAC_MASK(mac)) >>
++							       GMAC_OFFSET(mac);
++
++	return 0;
++}
++EXPORT_SYMBOL(ltq_sysctl_mac_mux_get);
++
++int ltq_sysctl_mac_drs_get(const unsigned int mac, unsigned int *drs)
++{
++	if (mac > 3 || !drs)
++		return -1;
++
++	*drs = (sysctl_r32(SYSCTL_SYSETH, SYS_ETH_DRS) & GMAC_MASK(mac)) >>
++							       GMAC_OFFSET(mac);
++
++	return 0;
++}
++EXPORT_SYMBOL(ltq_sysctl_mac_drs_get);
diff --git a/target/linux/lantiq/patches-3.18/2080-gen-nand-of.patch b/target/linux/lantiq/patches-3.18/2080-gen-nand-of.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2080-gen-nand-of.patch
@@ -0,0 +1,52 @@
+check the dts file for mtd name, the auto generated name may not be compatible with uboot settings
+check the dts file for presence of bbt-use-flash variable, use bad block table in the flash (by default OOB is used)
+http://lists.infradead.org/pipermail/linux-mtd/2013-March/046371.html
+
+--- a/drivers/mtd/nand/plat_nand.c
++++ b/drivers/mtd/nand/plat_nand.c
+@@ -12,6 +12,7 @@
+ #include <linux/io.h>
+ #include <linux/module.h>
+ #include <linux/platform_device.h>
++#include <linux/of.h>
+ #include <linux/slab.h>
+ #include <linux/mtd/mtd.h>
+ #include <linux/mtd/nand.h>
+@@ -35,6 +36,7 @@ static int plat_nand_probe(struct platfo
+ 	struct plat_nand_data *data;
+ 	struct resource *res;
+ 	const char **part_types;
++	const char __maybe_unused	*of_mtd_name = NULL;
+ 	int err = 0;
+ 
+ 	if (!pdata) {
+@@ -75,7 +77,20 @@ static int plat_nand_probe(struct platfo
+ 	data->chip.priv = &data;
+ 	data->mtd.priv = &data->chip;
+ 	data->mtd.owner = THIS_MODULE;
+-	data->mtd.name = dev_name(&pdev->dev);
++	if (pdev->dev.of_node) {
++		int i;
++		of_property_read_string(pdev->dev.of_node,
++						"linux,mtd-name", &of_mtd_name);
++		if (of_mtd_name)
++			data->mtd.name = of_mtd_name;
++		else
++			data->mtd.name = dev_name(&pdev->dev);
++		if (of_get_property(pdev->dev.of_node, "bbt-use-flash", &i))
++			data->chip.bbt_options |= NAND_BBT_USE_FLASH;
++	} else {
++		data->mtd.name = dev_name(&pdev->dev);
++		data->chip.bbt_options |= pdata->chip.bbt_options;
++	}
+ 
+ 	data->chip.IO_ADDR_R = data->io_base;
+ 	data->chip.IO_ADDR_W = data->io_base;
+@@ -87,7 +102,6 @@ static int plat_nand_probe(struct platfo
+ 	data->chip.read_byte = pdata->ctrl.read_byte;
+ 	data->chip.chip_delay = pdata->chip.chip_delay;
+ 	data->chip.options |= pdata->chip.options;
+-	data->chip.bbt_options |= pdata->chip.bbt_options;
+ 
+ 	data->chip.ecc.hwctl = pdata->ctrl.hwcontrol;
+ 	data->chip.ecc.layout = pdata->chip.ecclayout;
diff --git a/target/linux/lantiq/patches-3.18/2090-fix-bad-blocks-in-mtd-split.patch b/target/linux/lantiq/patches-3.18/2090-fix-bad-blocks-in-mtd-split.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2090-fix-bad-blocks-in-mtd-split.patch
@@ -0,0 +1,84 @@
+skip bad blocks when doing the mtd split
+
+diff --git a/drivers/mtd/mtdpart.c b/drivers/mtd/mtdpart.c
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -759,6 +759,22 @@ mtd_pad_erasesize(struct mtd_info *mtd, 
+ 	return len;
+ }
+ 
++static unsigned long fix_size_for_bad_blocks(struct mtd_info *mtd,
++			unsigned long offset, unsigned long size)
++{
++	unsigned long offs = 0;
++
++	if (mtd->_block_isbad) {
++		while (offs < size) {
++			if (mtd->_block_isbad(mtd, offs + offset))
++				size += mtd->erasesize;
++			offs += mtd->erasesize;
++		}
++	}
++
++	return size;
++}
++
+ static int split_squashfs(struct mtd_info *master, int offset, int *split_offset)
+ {
+ 	size_t squashfs_len;
+@@ -768,12 +784,26 @@ static int split_squashfs(struct mtd_inf
+ 	if (ret)
+ 		return ret;
+ 
++	squashfs_len = fix_size_for_bad_blocks(master, offset, squashfs_len);
+ 	len = mtd_pad_erasesize(master, offset, squashfs_len);
+ 	*split_offset = offset + len;
+ 
+ 	return 0;
+ }
+ 
++static int detect_squashfs_partition(struct mtd_info *master, unsigned long offset)
++{
++	unsigned long temp;
++	size_t len;
++	int ret;
++
++	ret = mtd_read(master, offset, 4, &len, (void *)&temp);
++	if (ret || len != sizeof(temp))
++		return 0;
++
++	return le32_to_cpu(temp) == SQUASHFS_MAGIC;
++}
++
+ static void split_rootfs_data(struct mtd_info *master, struct mtd_part *part)
+ {
+ 	unsigned int split_offset = 0;
+@@ -810,15 +840,26 @@ static void split_uimage(struct mtd_info
+ 		__be32 size;
+ 	} hdr;
+ 	size_t len;
++	unsigned long offs = 0;
+ 
+-	if (mtd_read(master, part->offset, sizeof(hdr), &len, (void *) &hdr))
++	if (master->_block_isbad) {
++		while (master->_block_isbad(master, part->offset + offs)) {
++			offs += master->erasesize;
++		}
++	}
++
++	if (mtd_read(master, part->offset + offs, sizeof(hdr), &len, (void *) &hdr))
+ 		return;
+ 
+ 	if (len != sizeof(hdr) || hdr.magic != cpu_to_be32(UBOOT_MAGIC))
+ 		return;
+ 
+ 	len = be32_to_cpu(hdr.size) + 0x40;
+-	if (len + master->erasesize > part->mtd.size)
++	len = fix_size_for_bad_blocks(master, part->offset, len);
++	if (!detect_squashfs_partition(master, part->offset + len))
++		len = mtd_pad_erasesize(master, part->offset, len);
++
++	if (len > part->mtd.size)
+ 		return;
+ 
+ 	if (config_enabled(CONFIG_MTD_SPLIT_UIMAGE_FW))
diff --git a/target/linux/lantiq/patches-3.18/2100-spi-falcon-clock-setup-fix.patch b/target/linux/lantiq/patches-3.18/2100-spi-falcon-clock-setup-fix.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2100-spi-falcon-clock-setup-fix.patch
@@ -0,0 +1,56 @@
+spi_falcon: when setting up the clock, do not change the EBU clock but use it as input
+
+diff --git a/drivers/spi/spi-falcon.c b/drivers/spi/spi-falcon.c
+--- a/drivers/spi/spi-falcon.c
++++ b/drivers/spi/spi-falcon.c
+@@ -308,33 +308,32 @@ int falcon_sflash_xfer(struct spi_device
+ 
+ static int falcon_sflash_setup(struct spi_device *spi)
+ {
+-	unsigned int i;
++	unsigned int i, ebuclk;
+ 	unsigned long flags;
++	struct device *dev = &spi->dev;
+ 
+ 	spin_lock_irqsave(&ebu_lock, flags);
+ 
+-	if (spi->max_speed_hz >= CLOCK_100M) {
+-		/* set EBU clock to 100 MHz */
+-		ltq_sys1_w32_mask(0, EBUCC_EBUDIV_SELF100, EBUCC);
+-		i = 1; /* divider */
+-	} else {
+-		/* set EBU clock to 50 MHz */
+-		ltq_sys1_w32_mask(EBUCC_EBUDIV_SELF100, 0, EBUCC);
++	if (ltq_sys1_r32(EBUCC) & EBUCC_EBUDIV_SELF100)
++		ebuclk = CLOCK_100M;
++	else
++		ebuclk = CLOCK_50M;
+ 
+-		/* search for suitable divider */
+-		for (i = 1; i < 7; i++) {
+-			if (CLOCK_50M / i <= spi->max_speed_hz)
+-				break;
+-		}
++	/* search for suitable divider */
++	for (i = 1; i < 7; i++) {
++		if (ebuclk / i <= spi->max_speed_hz)
++			break;
+ 	}
++	dev_dbg(dev, "max_speed is %d Hz, set speed to %d Hz\n", 
++		spi->max_speed_hz, ebuclk / i);
+ 
+ 	/* setup period of serial clock */
+ 	ltq_ebu_w32_mask(SFTIME_SCKF_POS_MASK
+-		     | SFTIME_SCKR_POS_MASK
+-		     | SFTIME_SCK_PER_MASK,
+-		     (i << SFTIME_SCKR_POS_OFFSET)
+-		     | (i << (SFTIME_SCK_PER_OFFSET + 1)),
+-		     SFTIME);
++			| SFTIME_SCKR_POS_MASK
++			| SFTIME_SCK_PER_MASK,
++			(i << SFTIME_SCKR_POS_OFFSET)
++			| (i << (SFTIME_SCK_PER_OFFSET + 1)),
++			SFTIME);
+ 
+ 	/*
+ 	 * set some bits of unused_wd, to not trigger HOLD/WP
diff --git a/target/linux/lantiq/patches-3.18/2101-spi-falcon-reduce-blocking.patch b/target/linux/lantiq/patches-3.18/2101-spi-falcon-reduce-blocking.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2101-spi-falcon-reduce-blocking.patch
@@ -0,0 +1,166 @@
+reduce possible system-blocking by accesses to EBU registers:
+- use a small delay to relax system performance
+- do locking with a hardware semaphore (with no impact, if the MPS module is not active)
+
+diff --git a/drivers/spi/spi-falcon.c b/drivers/spi/spi-falcon.c
+--- a/drivers/spi/spi-falcon.c
++++ b/drivers/spi/spi-falcon.c
+@@ -78,6 +78,8 @@
+ #define SFSTAT_CMD_ERR		0x20000000
+ /* Access Command Pending */
+ #define SFSTAT_CMD_PEND		0x00400000
++/* Protocol Engine Active */
++#define SFSTAT_ACTIVE		0x00100000
+ /* Frequency set to 100MHz. */
+ #define EBUCC_EBUDIV_SELF100	0x00000001
+ /* Serial Flash */
+@@ -92,11 +94,44 @@
+ #define CLOCK_100M	100000000
+ #define CLOCK_50M	50000000
+ 
++#define UDELAY_VAL	1
++
+ struct falcon_sflash {
+ 	u32 sfcmd; /* for caching of opcode, direction, ... */
+ 	struct spi_master *master;
+ };
+ 
++#define MPS_BASE		KSEG1ADDR(0x1D004000)
++#define VPE0_BINSEM(x)		(0x100+4*(x))
++#define VPE1_BINSEM(x)		(0x200+4*(x))
++#define BINSEM_NR		1
++
++static inline void binsem_lock(void)
++{
++	while (ltq_r32((void*)(MPS_BASE + VPE0_BINSEM(BINSEM_NR))) != 0) ;
++}
++static inline void binsem_unlock(void)
++{
++	ltq_w32(0, (void*)(MPS_BASE + VPE0_BINSEM(BINSEM_NR)));
++}
++
++static inline int wait_cmd_pending(struct device *dev)
++{
++	u32 val;
++	do {
++		binsem_lock();
++		val = ltq_ebu_r32(SFSTAT);
++		binsem_unlock();
++		if (val & SFSTAT_CMD_ERR) {
++			/* reset error status */
++			dev_err(dev, "SFSTAT: CMD_ERR (%x)\n", val);
++			ltq_ebu_w32(SFSTAT_CMD_ERR, SFSTAT);
++			return -EBADE;
++		}
++	} while (val & (SFSTAT_CMD_PEND | SFSTAT_ACTIVE));
++	return 0;
++}
++
+ int falcon_sflash_xfer(struct spi_device *spi, struct spi_transfer *t,
+ 		unsigned long flags)
+ {
+@@ -196,8 +231,11 @@ int falcon_sflash_xfer(struct spi_device
+ 			priv->sfcmd &= ~(SFCMD_ALEN_MASK | SFCMD_DUMLEN_MASK);
+ 			priv->sfcmd |= (alen << SFCMD_ALEN_OFFSET) |
+ 					 (dumlen << SFCMD_DUMLEN_OFFSET);
+-			if (alen > 0)
++			if (alen > 0) {
++				binsem_lock();
+ 				ltq_ebu_w32(val, SFADDR);
++				binsem_unlock();
++			}
+ 
+ 			dev_dbg(dev, "wr %02X, alen=%d (addr=%06X) dlen=%d\n",
+ 				priv->sfcmd & SFCMD_OPC_MASK,
+@@ -233,14 +271,22 @@ int falcon_sflash_xfer(struct spi_device
+ 						~SFCMD_KEEP_CS_KEEP_SELECTED;
+ 				}
+ 				if ((len == 4) || (bytelen == 0)) {
++					if (wait_cmd_pending(dev)<0)
++						return -EBADE;
++					binsem_lock();
+ 					ltq_ebu_w32(val, SFDATA);
+ 					ltq_ebu_w32(priv->sfcmd
+ 						| (len<<SFCMD_DLEN_OFFSET),
+ 						SFCMD);
++					binsem_unlock();
++					udelay(UDELAY_VAL);
+ 					len = 0;
+ 					val = 0;
+-					priv->sfcmd &= ~(SFCMD_ALEN_MASK
+-							 | SFCMD_DUMLEN_MASK);
++					if (priv->sfcmd & (SFCMD_ALEN_MASK | SFCMD_DUMLEN_MASK)) {
++						priv->sfcmd &= ~(SFCMD_ALEN_MASK
++								| SFCMD_DUMLEN_MASK);
++						udelay(UDELAY_VAL);
++					 }
+ 				}
+ 			} while (bytelen);
+ 			state = state_end;
+@@ -258,22 +304,23 @@ int falcon_sflash_xfer(struct spi_device
+ 				}
+ 				len = (bytelen > 4) ? 4 : bytelen;
+ 				bytelen -= len;
++				if (wait_cmd_pending(dev)<0)
++					return -EBADE;
++				binsem_lock();
+ 				ltq_ebu_w32(priv->sfcmd
+ 					| (len << SFCMD_DLEN_OFFSET), SFCMD);
+-				priv->sfcmd &= ~(SFCMD_ALEN_MASK
+-						 | SFCMD_DUMLEN_MASK);
+-				do {
+-					val = ltq_ebu_r32(SFSTAT);
+-					if (val & SFSTAT_CMD_ERR) {
+-						/* reset error status */
+-						dev_err(dev, "SFSTAT: CMD_ERR");
+-						dev_err(dev, " (%x)\n", val);
+-						ltq_ebu_w32(SFSTAT_CMD_ERR,
+-							SFSTAT);
+-						return -EBADE;
+-					}
+-				} while (val & SFSTAT_CMD_PEND);
++				binsem_unlock();
++				if (priv->sfcmd & (SFCMD_ALEN_MASK | SFCMD_DUMLEN_MASK)) {
++					priv->sfcmd &= ~(SFCMD_ALEN_MASK
++							| SFCMD_DUMLEN_MASK);
++					udelay(UDELAY_VAL);
++				 }
++				udelay(UDELAY_VAL);
++				if (wait_cmd_pending(dev)<0)
++					return -EBADE;
++				binsem_lock();
+ 				val = ltq_ebu_r32(SFDATA);
++				binsem_unlock();
+ 				do {
+ 					*rxp = (val & 0xFF);
+ 					rxp++;
+@@ -287,9 +334,11 @@ int falcon_sflash_xfer(struct spi_device
+ 		case state_disable_cs:
+ 		{
+ 			priv->sfcmd &= ~SFCMD_KEEP_CS_KEEP_SELECTED;
++			binsem_lock();
+ 			ltq_ebu_w32(priv->sfcmd | (0 << SFCMD_DLEN_OFFSET),
+ 				SFCMD);
+ 			val = ltq_ebu_r32(SFSTAT);
++			binsem_unlock();
+ 			if (val & SFSTAT_CMD_ERR) {
+ 				/* reset error status */
+ 				dev_err(dev, "SFSTAT: CMD_ERR (%x)\n", val);
+@@ -331,6 +380,8 @@ static int falcon_sflash_setup(struct sp
+ 	dev_dbg(dev, "max_speed is %d Hz, set speed to %d Hz\n", 
+ 		spi->max_speed_hz, ebuclk / i);
+ 
++	binsem_lock();
++
+ 	/* setup period of serial clock */
+ 	ltq_ebu_w32_mask(SFTIME_SCKF_POS_MASK
+ 			| SFTIME_SCKR_POS_MASK
+@@ -351,6 +402,8 @@ static int falcon_sflash_setup(struct sp
+ 	/* set address wrap around to maximum for 24-bit addresses */
+ 	ltq_ebu_w32_mask(SFCON_DEV_SIZE_MASK, SFCON_DEV_SIZE_A23_0, SFCON);
+ 
++	binsem_unlock();
++
+ 	spin_unlock_irqrestore(&ebu_lock, flags);
+ 
+ 	return 0;
diff --git a/target/linux/lantiq/patches-3.18/2102-spi-falcon-extend-addressing.patch b/target/linux/lantiq/patches-3.18/2102-spi-falcon-extend-addressing.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2102-spi-falcon-extend-addressing.patch
@@ -0,0 +1,53 @@
+spi_falcon: support 4byte addressing modes as used for flashes > 128Mbit
+
+diff --git a/drivers/spi/spi-falcon.c b/drivers/spi/spi-falcon.c
+--- a/drivers/spi/spi-falcon.c
++++ b/drivers/spi/spi-falcon.c
+@@ -3,7 +3,8 @@
+  *  under the terms of the GNU General Public License version 2 as published
+  *  by the Free Software Foundation.
+  *
+- *  Copyright (C) 2012 Thomas Langer <thomas.langer@lantiq.com>
++ *  Copyright (C) 2012, 2015 Lantiq Beteiligungs-GmbH & Co. KG
++ *  Thomas Langer <thomas.langer@lantiq.com>
+  */
+ 
+ #include <linux/module.h>
+@@ -63,6 +64,7 @@
+ #define SFTIME_SCKF_POS_MASK	0x0000F000
+ /* Device Size */
+ #define SFCON_DEV_SIZE_A23_0	0x03000000
++#define SFCON_DEV_SIZE_A31_0	0x0B000000
+ #define SFCON_DEV_SIZE_MASK	0x0F000000
+ /* Read Data Position */
+ #define SFTIME_RD_POS_MASK	0x000F0000
+@@ -213,14 +215,12 @@ int falcon_sflash_xfer(struct spi_device
+ 			alen = 0;
+ 			dumlen = 0;
+ 			while (bytelen > 0) {
+-				if (alen < 3) {
++				if (alen < 4) {
++					/* up to 4 bytes can by handled as address */
+ 					val = (val << 8) | (*txp++);
+ 					alen++;
+-				} else if ((dumlen < 15) && (*txp == 0)) {
+-					/*
+-					 * assume dummy bytes are set to 0
+-					 * from upper layer
+-					 */
++				} else if (dumlen < 15) {
++					/* assume additional bytes are dummy */
+ 					dumlen++;
+ 					txp++;
+ 				} else {
+@@ -399,8 +399,8 @@ static int falcon_sflash_setup(struct sp
+ 	ltq_ebu_w32(BUSRCON0_AGEN_SERIAL_FLASH | BUSRCON0_PORTW_8_BIT_MUX,
+ 			BUSRCON0);
+ 	ltq_ebu_w32(BUSWCON0_AGEN_SERIAL_FLASH, BUSWCON0);
+-	/* set address wrap around to maximum for 24-bit addresses */
+-	ltq_ebu_w32_mask(SFCON_DEV_SIZE_MASK, SFCON_DEV_SIZE_A23_0, SFCON);
++	/* set address wrap around to maximum for 32-bit addresses */
++	ltq_ebu_w32_mask(SFCON_DEV_SIZE_MASK, SFCON_DEV_SIZE_A31_0, SFCON);
+ 
+ 	binsem_unlock();
+ 
diff --git a/target/linux/lantiq/patches-3.18/2110-conntrack-hook.patch b/target/linux/lantiq/patches-3.18/2110-conntrack-hook.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2110-conntrack-hook.patch
@@ -0,0 +1,139 @@
+allow registration of multiple conntrack_event callbacks
+currently fixed to 2
+
+diff --git a/include/net/netfilter/nf_conntrack_ecache.h b/include/net/netfilter/nf_conntrack_ecache.h
+--- a/include/net/netfilter/nf_conntrack_ecache.h
++++ b/include/net/netfilter/nf_conntrack_ecache.h
+@@ -80,7 +80,8 @@ nf_conntrack_event_cache(enum ip_conntra
+ 	struct net *net = nf_ct_net(ct);
+ 	struct nf_conntrack_ecache *e;
+ 
+-	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
++	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb[0]) &&
++		  !rcu_access_pointer(net->ct.nf_conntrack_event_cb[1]))
+ 		return;
+ 
+ 	e = nf_ct_ecache_find(ct);
+@@ -98,12 +99,13 @@ nf_conntrack_eventmask_report(unsigned i
+ {
+ 	int ret = 0;
+ 	struct net *net = nf_ct_net(ct);
+-	struct nf_ct_event_notifier *notify;
++	struct nf_ct_event_notifier *notify[2];
+ 	struct nf_conntrack_ecache *e;
+ 
+ 	rcu_read_lock();
+-	notify = rcu_dereference(net->ct.nf_conntrack_event_cb);
+-	if (notify == NULL)
++	notify[0] = rcu_dereference(net->ct.nf_conntrack_event_cb[0]);
++	notify[1] = rcu_dereference(net->ct.nf_conntrack_event_cb[1]);
++	if (notify[0] == NULL && notify[1] == NULL)
+ 		goto out_unlock;
+ 
+ 	e = nf_ct_ecache_find(ct);
+@@ -122,7 +124,10 @@ nf_conntrack_eventmask_report(unsigned i
+ 		if (!((eventmask | missed) & e->ctmask))
+ 			goto out_unlock;
+ 
+-		ret = notify->fcn(eventmask | missed, &item);
++		if (notify[0])
++			ret = notify[0]->fcn(eventmask | missed, &item);
++		if (notify[1])
++			notify[1]->fcn(eventmask | missed, &item);
+ 		if (unlikely(ret < 0 || missed)) {
+ 			spin_lock_bh(&ct->lock);
+ 			if (ret < 0) {
+diff --git a/include/net/netns/conntrack.h b/include/net/netns/conntrack.h
+--- a/include/net/netns/conntrack.h
++++ b/include/net/netns/conntrack.h
+@@ -101,7 +101,7 @@ struct netns_ct {
+ 	struct hlist_head	*expect_hash;
+ 	struct ct_pcpu __percpu *pcpu_lists;
+ 	struct ip_conntrack_stat __percpu *stat;
+-	struct nf_ct_event_notifier __rcu *nf_conntrack_event_cb;
++	struct nf_ct_event_notifier __rcu *nf_conntrack_event_cb[2];
+ 	struct nf_exp_event_notifier __rcu *nf_expect_event_cb;
+ 	struct nf_ip_net	nf_ct_proto;
+ #if defined(CONFIG_NF_CONNTRACK_LABELS)
+diff --git a/net/netfilter/nf_conntrack_ecache.c b/net/netfilter/nf_conntrack_ecache.c
+--- a/net/netfilter/nf_conntrack_ecache.c
++++ b/net/netfilter/nf_conntrack_ecache.c
+@@ -119,14 +119,15 @@ void nf_ct_deliver_cached_events(struct 
+ {
+ 	struct net *net = nf_ct_net(ct);
+ 	unsigned long events, missed;
+-	struct nf_ct_event_notifier *notify;
++	struct nf_ct_event_notifier *notify[2];
+ 	struct nf_conntrack_ecache *e;
+ 	struct nf_ct_event item;
+-	int ret;
++	int ret = 0;
+ 
+ 	rcu_read_lock();
+-	notify = rcu_dereference(net->ct.nf_conntrack_event_cb);
+-	if (notify == NULL)
++	notify[0] = rcu_dereference(net->ct.nf_conntrack_event_cb[0]);
++	notify[1] = rcu_dereference(net->ct.nf_conntrack_event_cb[1]);
++	if (notify[0] == NULL && notify[1] == NULL)
+ 		goto out_unlock;
+ 
+ 	e = nf_ct_ecache_find(ct);
+@@ -150,7 +151,11 @@ void nf_ct_deliver_cached_events(struct 
+ 	item.portid = 0;
+ 	item.report = 0;
+ 
+-	ret = notify->fcn(events | missed, &item);
++	if (notify[0])
++		ret = notify[0]->fcn(events | missed, &item);
++
++	if (notify[1])
++		notify[1]->fcn(events, &item);
+ 
+ 	if (likely(ret >= 0 && !missed))
+ 		goto out_unlock;
+@@ -172,15 +177,20 @@ int nf_conntrack_register_notifier(struc
+ {
+ 	int ret;
+ 	struct nf_ct_event_notifier *notify;
++	int idx = 0;
+ 
+ 	mutex_lock(&nf_ct_ecache_mutex);
+-	notify = rcu_dereference_protected(net->ct.nf_conntrack_event_cb,
++	notify = rcu_dereference_protected(net->ct.nf_conntrack_event_cb[idx],
+ 					   lockdep_is_held(&nf_ct_ecache_mutex));
+ 	if (notify != NULL) {
+-		ret = -EBUSY;
+-		goto out_unlock;
++		notify = rcu_dereference_protected(net->ct.nf_conntrack_event_cb[++idx],
++					   lockdep_is_held(&nf_ct_ecache_mutex));
++		if (notify != NULL) {
++			ret = -EBUSY;
++			goto out_unlock;
++		}
+ 	}
+-	rcu_assign_pointer(net->ct.nf_conntrack_event_cb, new);
++	rcu_assign_pointer(net->ct.nf_conntrack_event_cb[idx], new);
+ 	ret = 0;
+ 
+ out_unlock:
+@@ -195,10 +205,17 @@ void nf_conntrack_unregister_notifier(st
+ 	struct nf_ct_event_notifier *notify;
+ 
+ 	mutex_lock(&nf_ct_ecache_mutex);
+-	notify = rcu_dereference_protected(net->ct.nf_conntrack_event_cb,
++	notify = rcu_dereference_protected(net->ct.nf_conntrack_event_cb[0],
+ 					   lockdep_is_held(&nf_ct_ecache_mutex));
+-	BUG_ON(notify != new);
+-	RCU_INIT_POINTER(net->ct.nf_conntrack_event_cb, NULL);
++	if (notify == new) {
++		RCU_INIT_POINTER(net->ct.nf_conntrack_event_cb[0], NULL);
++	} else {
++		notify = rcu_dereference_protected(net->ct.nf_conntrack_event_cb[1],
++						   lockdep_is_held(&nf_ct_ecache_mutex));
++		if (notify == new) {
++			RCU_INIT_POINTER(net->ct.nf_conntrack_event_cb[1], NULL);
++		}
++	}
+ 	mutex_unlock(&nf_ct_ecache_mutex);
+ }
+ EXPORT_SYMBOL_GPL(nf_conntrack_unregister_notifier);
diff --git a/target/linux/lantiq/patches-3.18/2120-ipv6-ndisc-table-export.patch b/target/linux/lantiq/patches-3.18/2120-ipv6-ndisc-table-export.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/2120-ipv6-ndisc-table-export.patch
@@ -0,0 +1,13 @@
+add EXPORT_SYMBOL for "nd_tbl" to allow neigh_lookup from a module
+
+diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
+--- a/net/ipv6/ndisc.c
++++ b/net/ipv6/ndisc.c
+@@ -142,6 +142,7 @@ struct neigh_table nd_tbl = {
+ 	.gc_thresh2 =	 512,
+ 	.gc_thresh3 =	1024,
+ };
++EXPORT_SYMBOL(nd_tbl);
+ 
+ static void ndisc_fill_addr_option(struct sk_buff *skb, int type, void *data)
+ {
diff --git a/target/linux/lantiq/patches-3.18/3000-DT-PLATFORM-DRIVER-Fill-the-resources-before-probe-and-defer-if-needed.patch b/target/linux/lantiq/patches-3.18/3000-DT-PLATFORM-DRIVER-Fill-the-resources-before-probe-and-defer-if-needed.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/lantiq/patches-3.18/3000-DT-PLATFORM-DRIVER-Fill-the-resources-before-probe-and-defer-if-needed.patch
@@ -0,0 +1,205 @@
+Subject:	[PATCH v2] dt: platform driver: Fill the resources before probe and defer if needed
+(rebased for 3.10.x, Thomas Langer)
+
+From:	devicetree-owner@vger.kernel.org on behalf of Jean-Jacques Hiblot <jjhiblot@traphandler.com>
+Sent:	Freitag, 21. Februar 2014 14:19
+To:	grant.likely@linaro.org; gregkh@linuxfoundation.org; robh+dt@kernel.org
+Cc:	gregory.clement@free-electrons.com; devicetree@vger.kernel.org; linux-kernel@vger.kernel.org; linux-arm-kernel@lists.infradead.org; Jean-Jacques Hiblot
+
+
+The goal of this patch is to allow drivers to be probed even if at the time of
+the DT parsing some of their ressources are not available yet.
+
+In the current situation, the resource of a platform device are filled from the
+DT at the time the device is created (of_device_alloc()). The drawbackof this
+is that a device sitting close to the top of the DT (ahb for example) but
+depending on ressources that are initialized later (IRQ domain dynamically
+created for example)  will fail to probe because the ressources don't exist
+at this time.
+
+This patch fills the resource structure only before the device is probed and
+will defer the probe if the resource are not available yet.
+
+Signed-off-by: Jean-Jacques Hiblot <jjhiblot@traphandler.com>
+Reviewed-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+---
+
+Hi Grant,
+
+I reworked the patch as you proposed. To keep the overhead minimum, nirq and
+nreg are computed only the first time.
+In this implementation, only the missing IRQ ressources are re-tried for. It could
+easily be changed to re-parse all the IRQs though (replace if (!res->flags)
+with if ((!res->flags) || (res->flags & IORESOURCE_IRQ)).
+
+drivers/base/platform.c     |   5 +++
+ drivers/of/platform.c       | 100 +++++++++++++++++++++++++++++++++-----------
+ include/linux/of_platform.h |  10 +++++
+ 3 files changed, 90 insertions(+), 25 deletions(-)
+
+diff --git a/drivers/base/platform.c b/drivers/base/platform.c
+--- a/drivers/base/platform.c
++++ b/drivers/base/platform.c
+@@ -503,6 +503,10 @@ static int platform_drv_probe(struct dev
+ 	struct platform_device *dev = to_platform_device(_dev);
+ 	int ret;
+ 
++	ret = of_platform_device_prepare(dev);
++	if (ret)
++		goto error;
++
+ 	ret = of_clk_set_defaults(_dev->of_node, false);
+ 	if (ret < 0)
+ 		return ret;
+@@ -519,6 +523,7 @@ static int platform_drv_probe(struct dev
+ 		ret = -ENXIO;
+ 	}
+ 
++error:
+ 	return ret;
+ }
+ 
+diff --git a/drivers/of/platform.c b/drivers/of/platform.c
+--- a/drivers/of/platform.c
++++ b/drivers/of/platform.c
+@@ -106,37 +106,11 @@ struct platform_device *of_device_alloc(
+ 				  struct device *parent)
+ {
+ 	struct platform_device *dev;
+-	int rc, i, num_reg = 0, num_irq;
+-	struct resource *res, temp_res;
+ 
+ 	dev = platform_device_alloc("", -1);
+ 	if (!dev)
+ 		return NULL;
+ 
+-	/* count the io and irq resources */
+-	while (of_address_to_resource(np, num_reg, &temp_res) == 0)
+-		num_reg++;
+-	num_irq = of_irq_count(np);
+-
+-	/* Populate the resource table */
+-	if (num_irq || num_reg) {
+-		res = kzalloc(sizeof(*res) * (num_irq + num_reg), GFP_KERNEL);
+-		if (!res) {
+-			platform_device_put(dev);
+-			return NULL;
+-		}
+-
+-		dev->num_resources = num_reg + num_irq;
+-		dev->resource = res;
+-		for (i = 0; i < num_reg; i++, res++) {
+-			rc = of_address_to_resource(np, i, res);
+-			WARN_ON(rc);
+-		}
+-		if (of_irq_to_resource_table(np, res, num_irq) != num_irq)
+-			pr_debug("not all legacy IRQ resources mapped for %s\n",
+-				 np->name);
+-	}
+-
+ 	dev->dev.of_node = of_node_get(np);
+ 	dev->dev.parent = parent;
+ 
+@@ -249,6 +223,81 @@ err_clear_flag:
+ 	return NULL;
+ }
+ 
++static int of_reg_count(struct device_node *np)
++{
++	int nreg = 0;
++	struct resource temp_res;
++
++	while (of_address_to_resource(np, nreg, &temp_res) == 0)
++		nreg++;
++
++	return nreg;
++}
++
++int of_platform_device_prepare(struct platform_device *dev)
++{
++	struct device_node *np;
++	int i, irq_index;
++	struct resource *res;
++
++	/*
++	 * This function applies only devices described in the DT.
++	 * Other platform devices have their ressources already populated.
++	 */
++	np = dev->dev.of_node;
++	if (!np)
++		return 0;
++
++	/* Populate the resource table */
++	if (!dev->resource) {
++		int rc, nreg = 0, nirq;
++		/* count the io and irq resources */
++		nreg = of_reg_count(np);
++		nirq = of_irq_count(np);
++
++		if (!nirq && !nreg)
++			return 0;
++
++		res = kzalloc(sizeof(*res) * (nirq + nreg), GFP_KERNEL);
++		if (!res)
++			return -ENOMEM;
++
++		dev->resource = res;
++		dev->num_resources = nreg + nirq;
++
++		for (i = 0; i < nreg; i++, res++) {
++			rc = of_address_to_resource(np, i, res);
++			if (WARN_ON(rc)) {
++				/* THIS IS BAD; don't try to defer probing */
++				dev->num_resources = 0;
++				dev->resource = NULL;
++				kfree(res);
++				return rc;
++			}
++		}
++
++		if (!rc && of_irq_to_resource_table(np, res, nirq) != nirq) {
++			/* IRQ controller is yet available. defer probing */
++			return -EPROBE_DEFER;
++		}
++
++		return 0;
++	}
++
++	/* See which IRQ resources need to be redone */
++	irq_index = 0;
++	for (i = 0, res = dev->resource; i < dev->num_resources; i++, res++) {
++		if (!res->flags) {
++			if (!of_irq_to_resource(np, irq_index, res))
++				return -EPROBE_DEFER;
++			irq_index++;
++		} else if (res->flags & IORESOURCE_IRQ)
++			irq_index++;
++	}
++	return 0;
++}
++EXPORT_SYMBOL(of_platform_device_prepare);
++
+ /**
+  * of_platform_device_create - Alloc, initialize and register an of_device
+  * @np: pointer to node to create device for
+diff --git a/include/linux/of_platform.h b/include/linux/of_platform.h
+--- a/include/linux/of_platform.h
++++ b/include/linux/of_platform.h
+@@ -53,6 +53,17 @@ struct of_dev_auxdata {
+ 
+ extern const struct of_device_id of_default_bus_match_table[];
+ 
++/* Populate the resource for a platform device */
++#ifdef CONFIG_OF
++int of_platform_device_prepare(struct platform_device *dev);
++#else
++static inline int of_platform_device_prepare(
++	struct platform_device *dev)
++{
++	return 0;
++}
++#endif
++
+ /* Platform drivers register/unregister */
+ extern struct platform_device *of_device_alloc(struct device_node *np,
+ 					 const char *bus_id,
